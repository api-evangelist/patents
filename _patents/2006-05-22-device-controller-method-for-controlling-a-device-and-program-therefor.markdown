---
title: Device controller, method for controlling a device, and program therefor
abstract: A device controller for controlling a device, comprises: a sending section that sends a message from an execution object to an operation section; and a control section that controls the device according to a procedure that is preset corresponding to the message in response to the message, wherein the sending section comprises: an evaluation section that generates an indication indicating reliability of the execution object in response to receiving the message from the execution object; and an indication attachment section that attaches the indication to the received message, a storage section that stores a plurality of procedures corresponding to indications, and the control section is configured to check the indication in response to receiving the message, and to execute a given procedure from the plurality of procedures stored in the storage section.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08117451&OS=08117451&RS=08117451
owner: Kyocera Corporation
number: 08117451
owner_city: Kyoto
owner_country: JP
publication_date: 20060522
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention relates to a device controller that controls a device coupled to a computer, a method for controlling a device, and a program therefor.","Priority is claimed on Japanese Patent Application No. 2005-149746, filed May 23, 2005, the content of which is incorporated herein by reference.","2. Description of the Related Art","A device driver has been used for controlling a device that is connected to a computer. An operating system (OS) running on a computer provides a general-purpose interface for various device drivers. With the interface, when a new device is developed, this device is available from execution objects, such as application programs or the OS, by installing a device driver that supports the new device. A manufacturer of the device provides the device driver, and the OS provides application programs with the capability to control the device by means of a system call.","A system call of an OS takes a message as an argument, which is passed to a device driver. The device driver operates the device according to the passed message. For example, for writing a program for controlling the device in the C language, a system call, such as open( ), close( ), read( ), write( ), ioctl( ), or the like, is used. Such a system call controls, i.e., opens, closes, reads from, or writes into the device according to the message. Such system calls (i.e., functions) may provide similar functionalities on various OSs although names of the functions may vary depending on the OS or the execution environment. When a system call is called, a service of a kernel of the OS is invoked.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 7","b":["55","562","561","571","572","574","561","574","572"]},"An interface of such a conventional device driver, which defines messages for the device driver and procedures to exchange messages to and from the device driver, has been publicly available in order to realize functionalities supported by the device. Furthermore, message interfaces have been standardized so that the same program can be executed for devices manufactured by different manufacturers without modifying the program, which has facilitated widespread use of devices.","When standardization of message interfaces is typically realized by defining a high-level API that is in a higher level than system calls, the high-level API is provided by the OS as a library or a dynamic link library (DLL). When an execution object calls the high-level API, the high-level API calls a system call to send a message to the device driver.","In general, a single instance of a device driver exists for a single device, and multiple instances of the high-level API exist for each application program. Such a single instance for each device driver is adapted in order to realize an exclusive access control in which a conflict is detected when multiple application programs try to control the device at the same time.","Portable telephone apparatuses have become available on the market which run such a general-purpose OS so that useful functionalities of the OS are utilized and various useful application programs running on the OS can connect to the wireless network of portable telephones and utilize the network.","In such apparatuses, a device that supports wireless telephone or data communication is coupled to a portable computer running the OS and an interface between the device and the OS is provided as a device driver. This technique offers various advantages. Examples include provision of publicly known means to control the device from an OS and application programs, and availability of a memory protection feature in an OS having such a memory protection feature that separates user spaces from the kernel space. In addition, portable telephone manufacturers can provide sophisticated functionalities while reducing the development cost of the OS. Furthermore, developers of OSs can eliminate extra labor to port an OS or application programs into different devices, thereby making latest high-performance devices available (see Japanese Unexamined Patent Application, First Publication No. H09-218844).","Device manufacturers and portable telephone manufacturers want to allow access to some functionalities of the device to the OS or trusted software programs while restricting the access from untrusted software programs, such as user applications, which is realized with a device controller or a method for controlling a device using conventional device drivers. That is, if usage of system calls, such as open( ), close( ), read( ), write( ), ioctl( ), by an execution program is permitted, even an untrusted software program can operate the device. For example, although operations that can interfere with the operation of the device, operations that charge fees to a user, or operations that read personal information of the user via an untrusted software program should be restricted, such a selective restriction was hard to be realized.","When a message interface between a device driver and an execution object is standardized, it is possible for the OS to restrict by usage of a certain message. However, when a device-specific functionality is utilized while restricting the usage thereof, the OS should handle respective conditions, which requires modification of the OS in many cases. Modification of the OS by the OS developer for restricting access to the device is not a practical solution.","An object of the present invention is to provide a solution that suitably enhances the flexibility in setting the access control by a device driver on a device to application programs while ensuring the versatility of a message interface.","In order to solve the above-identified problems, a first aspect of the present invention provides a device controller for controlling a device, comprising: a sending section that sends a message from an execution object to an operation section; and a control section that controls the device according to a procedure that is preset corresponding to the message in response to the message, wherein the sending section comprises: an evaluation section that generates an indication indicating reliability of the execution object in response to receiving the message from the execution object; and an indication attachment section that attaches the indication to the received message, a storage section that stores a plurality of procedures corresponding to indications, and the control section is configured to check the indication in response to receiving the message, and to execute a given procedure from the plurality of procedures stored in the storage section.","A second aspect of the present invention provides, in the above device controller, a device controller in which the sending section may further comprise an authentication attachment section that attaches an authentication to the message sent to the operation section, and the control section may determine a validity of the authentication in response to receiving the message from the sending section, and protect from an execution object when the validity of the authentication is not established.","Furthermore, a third aspect of the present invention provides a method for controlling a device, comprising: obtaining an indication indicating reliability of an execution object in response to receiving a message from the execution object; and sending the message to which the indication is attached; looking up the indication in response to receiving the message to which the indication is attached; and selecting a procedure to be executed from a plurality of procedures according to a reliability of the execution object.","Furthermore, a fourth aspect of the present invention provides a program for controlling a device, the program making a computer execute the steps of: receiving a message related to an operation of the device from an execution object; obtaining an indication indicating reliability of the execution object that sends the message; attaching the indication to the received message; and sending the message to the device.","Furthermore, a fifth aspect of the present invention provides a program for controlling a device, the program making a computer execute the steps of: receiving a message to which is attached an indication indicating a reliability of an execution object that sends a message related to an operation of the device; looking up the indication and selecting an operation procedure from a plurality of operation procedures that are set according to the reliability of the execution object for each message; and operating the device according to the selected operation procedure.","According to the present invention, upon sending the received message from the execution object to the operation section that operates the device, an indication indicating the reliability of the execution object is obtained and is attached to the message. The operation section is configured to select an operation procedure according to the reliability by looking up the indication. Accordingly, a general-purpose OS can be advantageously embedded into a computer and the device driver may be implemented to the system utilizing that OS.","That is, as for an advantage of the sending section, since it is suffice to provide the sending section with a functionality for obtaining the above-identified indication, it is suffice to execute a standardized procedure independent from the characteristics of the device and the sending section can be advantageously configured using an OS having standardized interfaces of execution objects and the device driver. Furthermore, as for an advantage of the operation section, the operation section can select processing procedures without being controlled by the execution object or the sending section, and the operation section can look up an indication indicating the reliability of the execution object upon selecting the processing procedure. Advantageously, it is therefore possible to build a device driver using the operation section, and a flexible countermeasure can be taken only with operations on the device driver against an unauthorized access to the device from the outside.","According to the above aspects, the reliability of an execution object that is a sender of a message can be obtained for each message, and the device driver can determine whether or not to provide the functionalities of the device. Furthermore, the device driver can select a detailed operation when the functionalities are provided. By this feature, it is possible to provide functionalities of the device only to trusted execution objects, limit the functionalities to untrusted execution objects, and to modify the functionalities as appropriate. Since such limiting or modification of the functionalities is determined by the device driver, it becomes possible to control the device based on policies adopted by manufacturer(s) of the device and\/or the device driver without making a request to modify the OS.","Furthermore, it is possible to attach an electronic authentication to a message sent to the operation section from the sending section, thereby enhancing the protection against unauthorized access or the like. If the validity of the message from the sending section is not established, the operation section may take certain protection measures, such as not responding to the message by ignoring it, elevating a security level when such a level is set in the device driver or the like, prompting the sending section (i.e., the OS or the like) to strengthen the protection, for example.","The above configuration may be advantageous for building a system in that the device driver can detect an intention to maliciously operate the device by mimicking a message from the OS. In response to detecting such an attack, the device driver may transition to a higher security mode while notifying the OS of the attack for prompting the OS to strengthen its security.","Hereafter, various embodiments of the present invention will be described with reference to the drawings.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["101","101","201","102","101","103","101"]},"An antenna  is configured to send or receive radio waves used for communication. A wireless unit  is configured to carry out communication using the antenna . A digital signal processor (DSP)  is configured to perform various operations, such as modulation and demodulation operation of sent or received signals. A digital\/analog (D\/A) converter  is configured to convert digital audio signals or ring tones output from the DSP  to analog audio signals which is sent to a speaker . A digital\/analog (D\/A) converter  is configured to convert analog audio signals input from a microphone  to digital audio signals, which is supplied to the DSP . The microphone  is configured to input voices of a caller or the like.","A key operation unit  includes keys, such as numeric keys, an on-hook key, an off-hook key, a power-on button, a shutter release button, function selection keys (function keys), for example, and is configured to capture key inputs of the keys. A display unit  includes a liquid crystal display panel or a liquid crystal touch panel, for example, and is configured to output various indications related to communication, messages, a menu screen, or execution screens of various application programs.","The portable telephone apparatus having the above-described configuration is capable of operating an application execution mode in addition to a voice call mode, as typical in portable telephone apparatuses. In the application execution mode, any application programs that are installed by a user can be started and executed.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","b":"5"},"Reference numeral  denotes a device controller that controls the device , and reference numeral  denotes an execution object that sends messages to the device . The device controller  or the execution object  is realized by a cooperative operation between hardware resources, such as the CPU  or the memory  shown in , for example, and software resources, such as the OS, device driver programs implemented by the OS, and application programs installed in the OS.","An operating system (OS)  generates a process to execute an application program , as shown in . The application program  links to a high-level application program interface (API) , as well as linking an external execution object  that is downloaded at runtime download. The high-level API  further links to a system call . The system call  is a standard function for invoking a service of the kernel, and exists while being linked to a process of the application program . The application program , the high-level API , the execution object , and the system call  form the execution object  as a process instance of the application program .","As used herein, the term \u201cexecution object\u201d refers to a set of executable programs. The execution objects may be application programs written by a user or a software manufacturer, libraries or DLLs provided by the OS, or objects obtained via a network or a medium. For example, the execution objects may be application programs, objects or DLLs dynamically linked at runtime, programs or scripts executed on interpreters, or objects of byte codes executed on a virtual machine. Furthermore, user processes or kernel processes linking to such objects can be regarded as execution objects.","When the application program  calls the high-level API , the high-level API  calls the system call  by specifying as an argument a suitable message for sending to the device driver . The system call  is a group of functions including open( ), close( ), read( ), write( ), ioctl( ), or the like, and the message is sent to the OS  by the ioctl( ) function. The OS (kernel)  includes an evaluation unit  that evaluates the execution object  before the message is sent to the device driver .","In the evaluation, a determination is made as to whether the execution object  is a user process or a kernel process of the OS . It is then determination whether the process is a known process or an unknown process. The extent of this determination is narrowed down by determining the operation mode of the process.","When the process is a known kernel process, the determination is immediately made by predetermining an evaluation value thereof. The evaluation values are unsigned 16-bit values in which the upper 8 bits represent a class and the lower 8 bits represent a detailed evaluation value within the class. Four types of class are defined: \u201cknown object,\u201d \u201cunknown object with a digital signature,\u201d \u201cunknown safe object,\u201d and \u201cother object.\u201d Values of the upper 8 bits of the evaluation value other than these four types are reversed and invalid.","When the process is an unknown process, the evaluation unit  examines all execution objects to which the process instance links at that time, and sets the lowest evaluation value among the evaluation values of the execution object as the evaluation value of the execution object . In this example, since the application program , the high-level API , the execution object  that is dynamically linked, and the system call  have been linked, their evaluation values are examined and the lowest value is determined. Since the high-level API  and the system call  are DLLs provided by the OS , they are known, reliable objects which have higher evaluation values belonging to Class 1. Class 1 means a known object. Known objects are execution objects bundled to the OS  and their reliability is ensured by the OS .","The application program  has a low evaluation value under normal conditions since it is unknown. However, in some cases in which a signature of the creator or provider may be attached to increase the reliability, it is possible to set a slightly higher value belonging to Class 2 as its evaluation value. Class 2 means an unknown object with a digital signature. Although such an unknown object with a digital signature is unknown to the OS , the digital signature is provided and the object is an execution object whose signature is verified by the OS  and whose reliability is confirmed.","The execution object  that has been downloaded and dynamically linked is regarded as unsafe and its evaluation value is a low value belonging to Class 4. Class 4 means a tampered execution object or an execution object that is determined as unsafe based on certain determination criteria. An object of Class 4 is an execution object that is determined as having been tampered with as a result of verification of its digital signature or as unsafe based on determination criteria. Class 3 objects are unknown safe objects without a digital signature and are execution objects that have been determined as safe based on certain determination criteria.","The evaluation unit  uses the evaluation value of the execution object  as the evaluation value of the execution object . In the case of a network-oriented execution object that downloads required objects from a network for execution, no link is made until it is actually being called. In such an execution environment, objects that are linked change dynamically. Since it is impossible to evaluate all evaluation values of all of the objects being linked, the execution object is given a low evaluation value belonging to Class 4.","An attaching unit  sends the message to the device driver  after attaching an indication to the message. The device driver  includes a selection unit  that selects a procedure according to the indication attached to the message and an operating unit  that executes an operation to the device  for each message. The operating unit  is configured to look up an area  in which procedures of processing have been stored. Suppose that there are four types of message, for example, the area is divided into four procedure categories: Category I to IV corresponding to each message type. In each procedure category, a plurality of procedure procedures -, -, . . . , are stored corresponding to the evaluation values.","The selection unit  looks up the indication and modifies actual procedure according to the indication. If the indication indicates that the execution object  is a kernel process and if the execution object  is known, the device driver  provides a wide variety of functionalities. When the execution object  is a kernel process but is unknown, its functionalities are limited. For example, when a device driver calls another device driver, it is an unknown kernel process. The indication indicates that the execution object  is a user process, the actual operations on the device  are modified according to the magnitude of the evaluation value and provided functionalities are limited. For example, by returning an error code while ignoring all operations on the device  corresponding to messages, the device  is prevented from controlling the execution object .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 4","FIGS. 1 and 4","FIG. 4"],"b":["61","7","62","101","61","5","61","102"]},"In step S, the evaluation unit  included in the OS  evaluates the execution object  that is the originator of the message and generates an indication. The OS  looks up a process that is being executed at that time, and determines whether it is being executed in the kernel mode execution or executed in the user mode. Furthermore, it is determined whether or not the executing process is a known kernel process, and if it is a known process, a pre-determined indication is referred. If the executing process is an unknown process, an indication corresponding to the process is generated. At that time, it is determined whether a digital signature is attached, and if so, the signature is valid and is not tampered with. For unknown processes without a digital signature, the determination is made based on certain publicly disclosed determination criteria. Based on this determination, the object is classified into safe execution objects and other execution objects. In the indication, a flag indicating the execution mode of the process, the evaluation value, identification information and reliability information of the execution object determining the evaluation value in that process are included.","The flow then proceeds to step S. In step S, the OS  carries out a procedure for sending the message and the indication to the device driver . The OS  has a management table to which device drivers are registered and is able to invoke the device driver  specified by the descriptor according to the device .","The flow then proceeds to step S. In step S, the device driver  executes an operation on the device  while modifying the operation based on the message and the indication.  is a flowchart showing a process flow of the device driver. Referring to , the device driver  first selects a given procedure according to the message specified as an argument (S). If the message in the argument is Message , a first procedure (S-) is executed. If the message in the argument is Message , a second procedure (S-) is executed. If the message in the argument is Message , a third procedure (S-) is executed. If the message in the argument is Message , a fourth procedure (S-) is executed. Any number of the messages and any number of procedures required for controlling the device may be used.","In the first to fourth procedures (S---), as described hereafter in detail, the device  is operated while modifying the operation based on the indication. When one of the first to fourth procedures (S- through S-) returns, step S is executed. In step S, the return value of one of the first to fourth procedures (S- through S-) is set to a return value as a result of the procedure shown in . The return value is \u201c0\u201d when no error occurs and \u201c\u22121\u201d upon error.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 6","FIG. 5","FIG. 6"],"b":["301","302","1","302","2","302","3","302","4"]},"Since Class 1 is a known object, it is possible to extract information to determine the identity of the object from the indication in the first procedure (S-) and to branch to an appropriate procedure. Since Class 2 is an unknown object with a digital signature, reading operations on the device are only permitted when the creator of the signature is the manufacturer of the device in the second procedure (S-). If the creator of the signature is a trusted related company, only read operations on the status of the device is allowed. If the creator is a party other than these, only reading operations of limited statuses the public disclosure of which is permitted. Since Class 3 is an unknown safe object, only reading operations of limited statuses the public disclosure of which is permitted in the third procedure (S-) because the origin of the object is unknown or the object is determined as safe according to certain determination criteria.","Since Class 4 is an execution object that has been determined as having been tampered with or as unsafe, most of the functionalities are denied in the fourth procedure (S-). In some cases, it is possible to notify the device  that it is subjected to the unsafe execution object and make the device  transition to any suitable protection state. When the device  transitions to the protection state, it is possible to take various measures, such as prohibiting an access to a certain service which may charge an expensive charge fee, or prohibiting reading of personal information of the user.","According to such a configuration, it becomes possible to modify the actual operation corresponding to the message according to the indication based on the judgment of the device driver . As a result, manufacturers of devices can limit functionalities of the device or deny access to certain functionalities based on the criteria set by the device manufacturer independently from OS developers.","Referring back to , in the above-described embodiment, no determination is made as to whether the message to be sent to the device driver  and the indication have been truly created by the evaluation unit  and the OS . Thus, it seems that a malicious application can operate the device by directly linking the device driver  as a DLL. However, the kernel of the OS  firstly links the device driver , and the device driver instance that has been linked later can recognize that it is not the first instance and can deny its operation.","Furthermore, further ensuring safety is important, and in step S in which the OS  sends the message and the indication to the device driver  (see ), it is possible to attach a digital signature that indicates that they were created by the evaluation unit  and the OS  and have not been tampered with. The device driver  can verify the fact. In this case, the OS  may attach consecutive numbers or pseudo-random numbers to the message and the indication, create hashes of the three pieces of information, and send them to the device driver  after encrypting with a private key of the OS  (by an authentication attachment section). The device driver creates hashes of the pieces of information received, decrypts the received encrypted data  using a public key of the OS , and compares the hashes by matching them to verify that there is no tampering (by the determination section). If a received message is tampered with, the device driver  transitions to the protection mode since it is highly likely that the device is subjected to an unauthorized attack to operate the device (by the protection section). In the protection mode, messages from the execution object are all ignored and the security level setting may be enhanced. Furthermore, it is possible to prompt the OS  to take protective measures. It should be noted that when the private key of the OS  is stored while being encrypted by another key, it is possible to reduce the risk of the private key being stolen by a malicious application.","Furthermore, the program according to the present invention can be recorded in a computer-readable recording medium and distributed, and may be distributed in a manner in which only a part of the functionalities are realized. For example, the program of the present invention may be distributed as a differential program that can realize certain functionalities in combination with a program for an existing system that has been recorded in a computer system.","Furthermore, the above-described computer-readable recording medium includes storage apparatuses, such as a hard disk and other nonvolatile storage apparatuses, and the like, in addition to storage media, such as portable magnetic disks magneto-optical disks. Furthermore, the program of the present invention may be supplied to another computer system via any transmission medium, such as the Internet or any other networks. In this case, the term \u201ccomputer-readable recording medium\u201d includes any media that contain the program for a certain period of time on a transmission medium, such as volatile memories of computer systems serving as a host or a client computer.","While preferred embodiments of the invention have been described and illustrated above, it should be understood that these are examples of the invention and are not to be considered as limiting. Additions, omissions, substitutions, and other modifications can be made without departing from the spirit or scope of the present invention. Accordingly, the invention is not to be considered as being limited by the foregoing description, and is only limited by the scope of the appended claims.","For example, although some embedded devices have an operating system that is not equipped with any memory protection features, such as the user mode or the kernel mode, the present invention may be applicable to such cases. Furthermore, some OSs do not have a multi-process functionality. However, even in such cases, because such OSs manage execution objects as execution units for executing application programs, the present invention may be effectively applied by looking up a component object group within an execution object according to a management scheme specific to each OS."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
