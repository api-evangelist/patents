---
title: Wallet application for interacting with a secure element application without a trusted server for authentication
abstract: Communication between a software application midlet of a contactless payment device and a control applet resident within a secure element of the contactless payment device includes selecting, on the software application midlet, a card applet to configure from a registered list of card applets, the list comprising application identifiers (AIDs) of card applets resident in the secure element; transmitting, through a secure channel, to the control applet on the secure element, the selected card applet's AID and an instruction for a selected function to be performed on the selected card applet; invoking, by the control applet, process method function calls of a card runtime environment, wherein the process method function calls are defined by the card issuer or the card runtime environment for performing the selected function on the selected card applet; and rendering the process method function calls, thereby performing the selected function on the selected card applet.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08646059&OS=08646059&RS=08646059
owner: Google Inc.
number: 08646059
owner_city: Mountain View
owner_country: US
publication_date: 20110926
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["This application claims priority to U.S. Provisional Patent Application No. 61\/424,609, filed Dec. 17, 2010 and entitled \u201cMultiple Contactless Payment Application, Control, And Architecture.\u201d The entire contents of the above-identified priority application are hereby fully incorporated herein by reference.","The invention relates generally to systems, methods, and devices for controlling multiple card software applications using a control software application, the control and card software applications resident in a secure element of a contactless smart card.","Contactless payment technology incorporates proximity communications between two devices to authenticate and enable payment for goods and services over the air (OTA) or without physical connection. Near Field Communication (NFC) is an example of a proximity communication option that can enable contactless payment technologies and that is supported by the Global System for Mobile Communications (GSM) Association. RFID is an example of a proximity communication method that can be adapted to enable NFC contactless payment technology. NFC communication ranges generally range from about 3 to about 4 inches. Such short communication distances limit, as well as, enable secure communication between close field proximity enabled devices. Proximity enabled contactless payment also can be implemented on Code Division Multiple Access (CDMA) devices with an embedded secure element within an NFC controller or a Re-usable Identification Module (R-UIM) type card.","In GSM phones, a proximity enabled (for example, NFC) controller with an antenna is incorporated into the device with the secure contactless software applications located on a smart chip. The smart chip can be further incorporated into one of several exemplary phone components, including a standard Subscribed Identity Module (SIM) card, a separate Mobile Secure Digital Card (for example, a secure digital (SD) card with non-volatile memory, such as EEPROM), or an embedded chip for the payment module purposes. An NFC-enabled contactless payment device enables financial transactions, ticketing, secure authentication, and coupons among several services that are available to the device owner.","The NFC contactless payment device can function as a credit card to enable purchases at the point-of-sale (POS) or even via merchant websites, where in the later case a GSM phone can be used to secure bank information from an authenticating server called a trusted service manager (TSM). The bank information is used in a form entry for payments on a merchant website. The TSM hosts and controls all credit card information sent to or withdrawn from a trusted NFC enabled contactless payment device.","Card software applications can be identified by Application Identifiers (AIDs) and are typically stored within the secure element of the mobile device. AIDs may be standardized by the ISO 7816 specification and include between 5 and 16 bytes. The first five bytes collectively of the AID is called a Registered Identifier (RID), which typically identifies the card company\u2014for example, MasterCard\u00ae, Discover\u00ae, or Visa\u00ae. The subsequent bytes may include the PIX or Proprietary application Identifier Extension, which can be used to identify such information as the application type, version, manufacturer, and other information. The secure element can exist within a removable smart chip, SD card, or embedded within a fixed chip on the mobile device. The secure element allows a wallet software application resident on the mobile device and accessible by the mobile device user to interact securely with certain functions within the secure element, while protecting a majority of the information stored within it. Further, a secure communication channel uses encryption methods for communication between the secure element and external device and software. The secure element on the smart card includes crypto processors for calculating crypto algorithms, memory controller units to manage the Read Only Memory (ROM), Ready Access Memory (RAM), and EEPROM flash memory within the smart card.","In certain exemplary embodiments, a computer-implemented method for controlling a plurality of contactless smart card software applications using a control software application, the control software application and the plurality of contactless smart card software applications resident in a secure element comprises receiving, at the control software application in the secure element, an application identifier (AID) of a selected contactless smart card software application from the plurality of registered contactless smart card software applications and a software code for an instruction to be performed on the selected contactless smart card software application; executing, in the secure element, at one of the control software application, the card runtime environment, or the selected contactless smart card software application, a process method function call associated with the software code, thereby performing the instruction on the selected contactless smart card software application; and updating, at the control software application, a registered list of the plurality of contactless smart card software applications with a software coded tag responsive to the instruction performed.","In certain exemplary embodiments, a computer-implemented method for communication between a software application midlet of a contactless payment device and a control applet resident within a secure element of a smart card, the smart card resident in the contactless payment device comprises selecting, on the software application midlet, at least one of plurality of card applets to configure from a registered list of card applets, wherein the registered list comprises application identifiers (AIDs) of card applets resident in the secure element transmitting, through a secure channel, to the control applet on the secure element, the selected card applet's AID, and a computer-coded instruction for a selected function to be performed on the selected card applet; invoking, by the control applet, process method function calls of a card runtime environment, wherein the process method function calls are defined by the card issuer or the card runtime environment for performing the selected function on the selected card applet; and rendering, by the card runtime environment, the process method function calls, thereby performing the selected function on the selected card applet.","In certain exemplary embodiments, a computer-implemented method to edit a card software application resident in the secure element of a contactless smart card, the card software applications for routing external card reader requests to one of a plurality of alternate card software applications, comprises selecting, in the secure element, using a process method function call of a card runtime environment, one of a plurality of card software applications for personalization, wherein the process method function call uses an application identifier (AID) of the card software application for selection; authenticating, in the secure element, access to the card software application using issuer security domain (ISD) keys stored in the contactless smart card, thereby gaining access to the data contents of the card software application; editing, in the secure element, the card software application by editing at least one of file control information (FCI), a priority status tag, and application discretionary data, wherein the edited FCI comprises the routing information to route the external card reader requests received at the card software application to an alternate AID of the alternate card software application; and installing, in the secure element, the edited card software application, thereby enabling the edited card software application to instantiate a related card sharable interface object (SIO), the SIO comprising at least the alternate AID defined in the edited information for routing the external card reader requests.","In certain exemplary embodiments, a computer-implemented method for managing the lifecycle of a card software application received from a remote trusted service manager (TSM) to a secure element of a contactless smart card comprises receiving, from the remote TSM to a card runtime environment of the secure element, one of a plurality of card software applications in computer-coded form and one of a plurality of computer-coded instructions for performing a function on the received card software application, wherein the card software application comprises account information of one card instrument and an application identifier (AID) code; rendering, in the secure element, the computer-coded instruction, wherein the rendered computer code performs the function on the card software application or invokes a process method function call of the card runtime environment to perform the function on the card software application; registering, in a control software application of the secure element, the card software application using the AID code, wherein the control software application comprises a list of AIDs of previously received and registered card software applications and a card application status tag for each of the listed AIDs; and updating, in the control software application, the card application status tag of the registered card software application, wherein the card application status tag is updated with a computer code related to the function performed.","In certain exemplary embodiments, a computer-implemented method for using sharable interface objects (SIOs) to share data between a control applet and a plurality of card applets across at least one secure firewall in a secure element of a contactless smart card comprises creating, in the secure element, a control SIO owned by the control applet and at least a card SIO owned by one of the plurality of card applets, wherein the card applet and the card SIO are located within a card memory context, the card memory context separated by the secure firewall from a control memory context comprising the control applet and the control SIO; enabling, in the secure element, the control applet to request access to the card SIO across the secure firewall; and invoking, in the secure element, by the control applet a data request or a data transmission process method function call in the card applet for returning card SIO data to the control applet or transmitting new SIO data to the card SIO, wherein the invoking step is initiated when the request for access in the enabling step is granted.","Contactless payment devices typically include smart phones; mobile phones; PDAs; mobile computing devices such as netbooks and iPad\u00aes; other electronically enabled key fobs; electronically enabled credit card type cards; and other devices. Some devices can be used for multiple purposes, including financial transactions, coupons, ticketing, secure authentication, and related applications. An NFC enabled chip is implemented, either independently or on existing components, within the contactless payment device, such as the SIM card, U-RIM card, an embedded chip or an external SD card, or any type of smart card.","The secure element can be contained on the contactless payment device, for example, on a smart card capable of hosting secure elements. In certain exemplary embodiments, SIM cards may be capable of hosting a secure element, for example, an NFC SIM Card. The secure element includes components typical of a smart card such as the crypto processors and random generators. A master file in the file structure of the smart card includes additional files that retain authentication keys and application information within the card. The secure element communicates with an NFC controller and the host controller on the contactless payment device. In an exemplary embodiment, the systems and methods described herein can be implemented in Java, using Java Card for the Smart Card applets and J2ME for the midlet applications running on the contactless payment device. The term \u201ccard software application\u201d and \u201ccard applet\u201d are used interchangeably in this disclosure to refer to a software applications running within the secure element of a smart card. A midlet, for example, a \u201cwallet midlet\u201d or a \u201cWallet\u201d software application may be a user-interface software application can be developed as a J2ME midlet, where the midlet can be downloaded and installed in the device. Further, the midlet can be made available to a user of the mobile device via a user-interface for making changes with the contents of the midlet functionality.","Card software application providers typically establish Issuer Security Domain (ISD) within the secure element of a smart card, where the ISD utilize keys on the smart card for communication across ISDs or between data objects created by the applets in different ISDs. The ISD may be used to load and delete payment system packages, to instantiate payment applications from external devices, to instantiate a Trusted Service Manager (TSM) Security Domain for download of payment and other card software applications, to lock\/unlock card software applications, and to terminate secure element software applications. A proximity payment system environment (PPSE) provides an application directory listing, according to EMVCo (Eurocard-Mastercard-Visa standards) and the specifications of the various card software applications. An updatable directory listing in a file control information (FCI) template is available to a control software application within the secure element. The FCI may be updated with data obtained from the control application and the TSM. The PPSE may be owned by the issuer of the secure element in the mobile device, where the issuer controls the authentication and approval of software applications installed to the secure element. The payment applications may be loaded on the mobile device as a card software application package, where each package, for example, a MasterCard package, typically contains software code for all supported payment applications within MasterCards\u201d offerings, e.g., Mstripe, Mchip, and any other suitable payment application. The payment application creates data objects to control flow of application data. The payment application and the data objects inside the software application package may be protected by a firewall that is described by virtue of the operating system (OS) that functions as the interface among the multiple software application and the control application. In certain examples, the OS is a Java Card operating system (JCOS).","In certain exemplary embodiments, the card software applications and the control software application may be applets within the JCOS structure. The applets, outside of MasterCard's card software applets, each use full-size AIDs for recognition, and may be applets developed in a Java compiler\/converter environment. For certain MasterCard payment applications, a \u201cumbrella application,\u201d referred to herein as the generic software application, for all payment type card software applications may be used, where the first 7 bytes in the AID of each card software application is the same. An instance of the MasterCard payment application may be selected for activation and can be masked using the 7 byte AID, which hides the full-size AIDs from the terminal. The masked AID then redirects the terminal request for an application to the activated instance of the payment application underlying the masked 7 byte AID.","In certain exemplary embodiments, a user preference setting is exposed and controlled by the control software application. Direct access to an instance of the card software application occurs only if the full-size AID is listed. An unselected user preference for an instance of a card application to be listed within the PPSE application directory indicates that the selection of a payment application is rejected. When a full-sized AID is selected, the directory software application then routes payment transaction commands according to user selected settings, directly to the selected instance. Instantiation and creation of a card software instance during post-issuance and routing of the card software application object, as well as personalization commands for the card software application are all functions performed by the control software application, with support from the card software applications being installed.","Java Specification Requests (JSR) may be used in J2ME (Java Micro edition) to standardize various communication channels between the various components in the contactless payment device. In certain exemplary embodiments, the JSR177 specification is used to allow communication between a graphical user interface midlet application on the device operating system and an applet in the secure element of the smart card using application protocol data unit (APDU). The JSR257 specifications allows the midlet application on the device to access the radio interface via the ISA 14443 standard, and also can provide a low level interface to the secure element. JSR177 establishes security and trust for application programming interfaces (API), where the API supports communication between the device and the smart card. A card execution environment, for e.g., in the case of a Java Card, a Java Card Runtime Environment (JCRE) and the Java Card API may be stored in the ROM of the smart card. Payment type card software applications and the control software application can be developed as API Java packages and may be loaded into the volatile flash memory section of the smart card. The card execution environment includes an instruction set for compiling software applications as well as application programming interface (API) function calls. The card execution environment may be implemented via a virtual machine that compiles the overlying software applications to the native machine language of the underlying physical hardware. Java bytecode and .NET bytecode are examples of the instruction set, while Java class libraries and .NET class libraries are examples of the API function calls that can be implemented via a card virtual machine, thereby forming a card execution environment.","In certain exemplary embodiments, security of data objects from each application in the smart card prevents rogue applications and coding errors from stealing data. This security is implemented via applet firewalls in the Java Card Platform. Spaces can be allocated to data objects for the card execution environment (e.g., JCRE for Java Cards), and for each applet and applet group. These spaces are called \u201ccontexts.\u201d A \u201cJCRE context\u201d is an allocated space for the java card runtime environment in the smart card temporary memory. Group contexts may be allocated to applets within an application, where an applet performs a sub-routine within an application on the smart card. Each context is separated by an in-built firewall that prevents data objects from being shared. While this implementation safeguards the data objects from other applications, it prevents multiple instances of an application type from sharing information. An application for a single card type, with multiple instances (for different financial instruments) can be developed, where the multiple instances are separate applets, and therefore share the same data objects. When one applet calls another applet within the application group, the control for data objects is transferred to the second applet. Routing of the application to an applet allows an instance of the application to be selected.","In certain exemplary embodiments, the data objects created and owned by each card software application can be shared between multiple applications using shareable interface objects (SIOs). This implementation allows the control software application to control selected data objects from other software applications within the smart card, without including security and firewall procedures. This implementation allows the controller application to review the status of other card software application type applets via review of the data objects generated by each applet. Each applet in the secure element of the smart card is identified by a unique AID. In certain exemplary embodiments, the control software application and each of the card software applications are included within independent applets, each with its own fixed AID. When an applet is created, the JCRE is notified and the applet is registered using the assigned AID of the applet. Thereafter, the JCRE encapsulates the AID bytes into an AID object, which is an object defined by the JCRE system. An applet that creates an SIO for the purpose of sharing may be referred to as the server applet, with the AID object being used by other applets, the other applets being referred to as client applets that use the server AID for identification purposes. The SIO is shareable between other applets through the firewall by the server-client relationship established within the JCRE system. However, the applet that requests the shareable object gains control of the object until it has finished its processes; thereafter, the SIO may be available to the other applets, provided the other applets have the required pre-defined permissions.","In certain exemplary embodiments, the server-client SIO definition within the JCRE allows a \u201cwallet\u201d software application to track all instances of the card software applications in the secure element via the control software application in the smart card. Events may be referred to functions performed on each of the card software applications. Events having occurred and the state of each card software application instance is logged using the information from the respective SIO for each of the applets. In certain exemplary embodiments, the control software application contains a user preferred list (UPL) of the preferred payment applications. In certain exemplary embodiments, the preferred card software applications are presented in the list, while other non-preferential card software applications are not presented in the list. The wallet application contains a list of all payment applications registered with the JCRE. Through the SIO, using the secure element JSRs, the wallet application can be used by the contactless payment device user to select certain card software applications as preferred applications via a user-interface, thereby creating an order based on the type of card software application. The various functions performed via a user-interface instruction may include instructions to enable or disable certain card software applications and to delete a card software application instance. In certain exemplary embodiments, all of these exemplary JSR functions can be performed without any trusted service manager authentication.","The proximity payment service environment (PPSE) is a directory software application that is selected by the terminal reader when the contactless payment device is presented to the reader. Following the above functions that personalize the choice of the payment type card software application, a wallet software application can be used to send management commands, which are used to update the PPSE with the available and active card software applications in the order selected by the user.","System Architecture",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","108","104","152","140","104","152","108","140","132","136","136","108","136"]},"In certain exemplary embodiments, external application providers  provide card software applications to the TSM  for deployment to the mobile device . In an alternative embodiment, each of the external application providers , may include a TSM for providing trusted card software applications directly to the mobile device via the Internet  or the mobile service provider . Exemplary external application providers  include credit card companies  for providing credit card type payment card software applications (e.g., Java credit\/debit\/PayWave\/PayPass type applets), ticketing companies  for providing tickets to events, travel, and other related functions, coupon companies  for providing coupons that are downloaded and scan-able at a point-of-sale (POS) using the contactless smart card, RFID tags, barcodes, QR 2 dimensional bar codes, and other similar optical coding methods, an authentication company  for providing authentication data that may be used to lock\/unlock physical appliances or for virtual functions on computer software, and a protected information provider , such as a bank, merchant, or other financial service provider, for providing confidential or otherwise protected information (for example, account information), which may be used to instantiate a particular card.","In certain exemplary embodiments, an application host OS  on the mobile device  provides the user of the mobile device with the capability to manage multiple card software applications and its instances - using a wallet software application , where the wallet software application does not need TSM  permission to perform certain functions on each of the card software applications and its instances -. The management of the card software applications may be performed via a control software application , which communicates with the wallet software application  using APDUs, transmitted and received, through a secure and encrypted communication channel. The control software application may freely communicate with the multiple card software applications and its instances - because each of the card and control software applications are resident within the same secure element . Alternatively, multiple secure elements providing a secure communication channels will provide the same functionality as disclosed herein. The user may engage the control software application  using commands to activate, deactivate, prioritize, delete, and install card software applications within the secure element.","When the card software applications have been activated and prioritized, the NFC controller  is notified of the state of readiness of the mobile device  for an NFC transaction. The NFC controller polls, through the antenna , a radio signal, or listens for radio signals from a reader terminal device . On establishing a channel between the devices  and , the reader requests to see the list of available card software applications within the secure element . A directory is first displayed, after which, based on the set priority or the type of reader, an application - is chosen and initiated for the transaction.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["100","240","252","260","156","148","156","152","160","164","160","148","156","152","212"]},"In certain exemplary embodiments, the sharable interface objects (SIOs) A-X are used to communicated with the software applications and instances , , - within the secure element  of the contactless smart card. The SIOs are owned by the respective software applications and are created at the time of creation of the software applications. To share data across the software applications, the owner of the SIO is designated to be in a server mode control of the SIO, while the recipients function as the clients to the SIO. Data created by the software applications may be stored in the SIO in a recognizable format established by existing standards such as the GP and SECM standards. In certain exemplary embodiments, the AIDs of each of the applications are stored in a list format  in the control software application . The control software application includes a list  of the activate\/inactive\/non-activatable card software application AIDs in certain format. In certain exemplary embodiments, the list  typically includes appropriate short and full sized AIDs depending on the type of card software application. Some legacy readers with the requirement to read full sized AID require the corresponding card software application to have their full sized AID listed (e.g., ).","In certain exemplary embodiments, the active AIDs from the control software application  typically updates the directory software application . Alternatively, the control software application may server as the directory software application with special privileges to contactless requests from a reader, and different privileges to contact requests from the user internally via the user-interface. Each card software application , , , and  may include instances of their respective applications, such as  and . The instances may share the same SIO, where the active instance takes ownership of the SIOs . The SIO store the application data that defines the issuer of the card software application, the user data within the card issuer application, and possibly a log of transactions tied to the specific card software application and\/or its instances. When a card software application , , , and  is enabled, the SIO is active and is accessed by the client mode control software application . The control software application maintains a UPL  of a list  of card software applications and their status from each card software application server SIOs .","In certain exemplary embodiments, a reader  reads the secure element  for the first time, the PPSE  is read by the reader . The list of available card software applications  are displayed by the AIDs  to the reader. The reader then chooses or is defaulted to one of the multiple available card software applications. Accordingly, if the reader  chooses s_AID2 B, then the corresponding full AID is retrieved from the control software application. The selected full AID will be f_AID21 F. The corresponding card software application  is triggered and the application itself, or its instance , in this case, is activated to the NFC controller for radio transmission of data to the reader.","In certain exemplary embodiments, the user may configure the list in the control software application , using the wallet application on the user-interface, where the wallet application sends APDU instructions to the control software application  to perform a function on the selected card software application or its instances , , , and , or the UPL  on the application .","In certain exemplary embodiments, in the case that the user chooses not to enter a PIN prior to payment, the settings for such processes can be controlled by the user. In case the mobile is powered off and running in virtual card emulation mode where the secure element is powered by the field, the control software application may not access the control functions defined within the device. Implicit access control is provided by the owner of the contactless payment device.","Additionally, in certain exemplary embodiments, only the contact interface performs management commands, and the control software application applet does not have any influence on functionality or security of card software applets. The management commands may be primarily capable of enabling or disabling the selection of the payment application and updating the PPSE file control information (FCI)  for the application lists . The control software application  is assigned a specific fixed AID and can be called by the external wallet application for selection. Internal to the smart card, the control software application AID may be used by a card software application , , , and , in the server mode (for sharing of data object SIOs as previously discussed), and may have AIDs designated by the operating system of the JCRE (at installation of the card software application) in the absence of an assigned AID. The server mode card or control software application can then verify the AID. The control software application may be the client software application for SIO purposes in event notification functions, for example, instantiation of new contactless payment applications, deletion of instantiation applications, and transaction events, like payments.","The user preference list (UPL)  stored within the control software application  as previously discussed may be implemented using registry tags. Information contained within the UPL is illustrated in Table 1 according to certain exemplary embodiments. The items marked \u201cUser Defined\u2014UD\u201d are accessible through the secure firewall using the SIOs. The other items are not accessible to the user or other applets, thereby reducing any risk of including data security. In certain exemplary embodiments, the use of a PPSE directory software application  for card software application lists may be merged with the function of the UPL  of the control software application , thereby creating a single list which can be accessed by the user-interface via the secure communication channel In this embodiment, changes made by the user to the list on the user-interface can be used to update the UPL on the control software application which is then made available to the reader when the reader terminal requests a list of active applications on the contactless mobile device.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Application related data: 61"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["AID: 4F","(ES)","A000000003101001","A000000004001010","A0000000043060","\u2014"]},{"entry":["Application Short File","(ID)","1","2","3",{}]},{"entry":["ID: 94",{},{},{},{},{}]},{"entry":["Priority: 81","(UD)","2","1","3",{}]},{"entry":["Lifecycle: 9F70","(ES)","SELECTABLE","SELECTABLE","SELECTABLE",{}]},{"entry":[{},{},"ACTIVE","NOT_ACTIVE","ACTIVE",{}]},{"entry":["Update Counter: 80","(ID)","2","6","1",{}]},{"entry":["Discretionary Data: A6",{},{},{},{},{}]},{"entry":["MC indicator: AA","(ID)","false","true","true",{}]},{"entry":["Payment system: AB","(ID)","VISA","MCCREDIT","MCDEBIT",{}]},{"entry":["Issuer: AC","(ES)","BOA","CITI","WF",{}]},{"entry":["\u2018AlwaysOn\u2019: AD","(UD)","true","false","fase"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Event Logging list: A7"},{"entry":"Global Event Sequence Counter: A9 (ES)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Event: AF"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Short File ID: 94 (ID)","Sequence Counter: A8 (ID)","Event ID: AE (ES)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["2","12","1"]},{"entry":["1","13","3"]},{"entry":["1","14","6"]},{"entry":["3","15","2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":"Codes:"},{"entry":"Externally supplied\u2014ES"},{"entry":"Internally derived\u2014ID"},{"entry":"User defined\u2014UD"}]}}]}}},"In certain exemplary embodiments, external commands formatted to the control software applet may be represented by Global Platform (GP) 2.2 standard. The GP 2.2 standard defines Java Card API standards for applets within the secure element. This will allow an easier transition for the next Java Card Open Platform (JCOP) platform for supporting updates and amendments. As shown in Table 1 above, the event logging list can be used to trace the payment events, installation of bank instances, and deletion thereof. The Global Platform type control software application can include a standard format based on the Secure Element Contactless Management or SECM in the Europay, MasterCard, and Visa\u2014the EMV standard, or contactless registry service (CRS), which is GP standard terminology. Further, the card software applet in certain exemplary embodiments is defined to work with both, the GP standard and a SECM standard, where each standard supports a type of on-card software application management. The control software application can implement an APDU instruction set to perform the following exemplary functions per the request of a wallet application: get non-secure information on registered contactless card and external software applications (via the AID of the card software application) and their respective contactless registry information (GP standard reference for the UPL); activate\/deactivate contactless card software applications; and respond with a list of conflicting application AIDs, where the APDU also establishes the order of applications in the UPL registry of the control software application by receiving a list of application AIDs. Additionally, some exemplary modules have AIDs that are reserved by the GP standard for the purpose of installing the control software application, including an executable load file AID, an executable module AID, and an application AID. The control software application may typically process the APDU commands, therefore providing the user with expected management capabilities via the user-interface.","The exemplary parameters in the UPL in Table 1 may be accessed through a GET STATUS and SET STATUS command issued by the control software application. The application AID tag \u201c4F\u201d may be a tag within the contactless registry UPL. Partial AID matching is supported when this tag is used as a search criterion in the GET STATUS command. If a length for the AID is not specified in the GET STATUS command, then a complete contactless registry UPL may be returned. In an exemplary embodiment, the GP control software application can be resident outside the security domain because the definition of the GET STATUS and SET STATUS commands require access to only the non-secure status information and not the actual secure data. Application short file ID defines the local namespace of the contactless registry UPL. This item is used by the event logging list to map an application identifier to the software application that produced the event. Priority indicator defines the order in which the payment applications are represented in the PPSE. An entry of \u201c0\u201d means that the respective contactless card software application is not accessible over the contactless interface, for example, the card software application may be disabled by the user or locked by the issuer.","In certain exemplary embodiments, the Application Lifecycle State tag \u201c9F70\u201d provides the application lifecycle state on the first byte as defined in GP2.2 standards. The Contactless Activation State may be encoded on the second byte as defined in GP2.2 standards. The software application discretionary data may be accessible to the wallet application through the control software application, for proprietary usage. In certain exemplary embodiments, if the card software application belongs to MasterCard, a MasterCard indicator may be set in the corresponding cell of Table 1. The tag for the control software application can execute logic on the short-size AID limitation on legacy readers. Value coding may be on one of the tag byte as follows: \u201cA5\u201d indicates not in MasterCard payment system, i.e., false, while \u201c5A\u201d indicates a MasterCard payment system instance, i.e., true.","In certain exemplary embodiments, the system indicator tag codes in Table 1 are provided in ASCII used by the payment system, for example, \u201cVISA.\u201d The issuing bank tags can be coded in ACII, for example, \u201cCITI.\u201d The mechanism to determine the issuer can be done by either using information provided by the trusted service agent (TSA), which is a trusted service manager (TSM) owned off-card software application on the payment device (or wallet application), or information coded in the payment application's PIX. In certain exemplary embodiments, the \u201cAlways On\u201d feature from the payment card software application describes a state where a contactless card software application that is activated on a payment device is accessible to a contactless terminal as long as the mobile device is capable of communicating over the antenna interface, even when the payment device is not \u201cswitched on\u201d. A card software application in the \u201cAlways On\u201d state can be equated to a regular contactless card in that the only action required from the mobile device user to initiate a contactless transaction is the act of presenting the contactless payment device to the contactless terminal. Conversely, a contactless payment card software application that is not in an \u201cAlways On\u201d state would need the consumer to take a conscious action on their payment device to make the application accessible prior to the act of presenting the mobile payment device to the contactless terminal. As an example, setting byte data to \u201cA5\u201d in Table 1 indicates not an \u201calways on\u201d or false state, while \u201c5A\u201d indicates \u201cAlways On\u201d or true state.","The Event logging list in Table 1 includes recorded transaction events. The on-card software application resident in the secure element initiates an event, for example, a PayPass event, where the last transaction command could signal a payment attempt. In order to support the GP standard, the CRS version of the control software application will reference the contactless registry UPL using the short file application ID and record the global sequence counter value at the time of event. An event ID (identifier) signals what type of event occurred. Events may be triggered by the payment type card software applications that are activated on the mobile payment device. The following events are exemplary events that may be registered in this list, where the byte code is coded in the event ID, for example, application INSTALL\u2014tag, 01, application DELETE\u2014tag 02, application SELECT: 03, application BLOCKED: 04, application UNBLOCKED: 05, PIN VERIFIED: 06, PIN FAILED: 07, and Payment transaction: 08.","Event sequence counter, short file ID, or Event ID are chronologically numbered in the event logging list. The value of the global event sequence counter is recorded, together with the short file ID. Then, events can be identified in order. Event ID specifies what type of event occurred. The Global Event Sequence Counter is a short number, recording the number of all events that occurred. An unsigned overflow is allowed to occur (at a range of 65000 to 0). The trusted service agent (TSA) are software applications within a trusted server manager (TSM) that manage deployment of card software applications to the secure element of contactless smart cards. The trusted service agent (TSA) also manages updates to the deployed card software applications in a remote contactless payment device's secure element based on requests from the user of the contactless payment device or an issuer of the TSM card software application. The UPL in the control software application is self-contained using notification mechanisms through the SIOs.","In certain exemplary embodiments, the control software application SIO uses Shared Notify Service Interface, which is a shareable (tagging) interface for notification of SIO data. The following methods are accessible by card software applications in the format of \u201cnotify(AID aid, short event)\u201d: application INSTALL: 01; application DELETE: 02; application SELECT: 03; application BLOCKED: 04; application UNBLOCKED: 05; PIN VERIFIED: 06; PIN FAILED: 07; and Payment Transaction: 08.","In certain exemplary embodiments, the control software application may implement the Shared Notify Service Interface by itself. When a notify message is triggered, the control software application runs instruction based logic to update the UPL.  depicts a block diagram illustrating a system for event notification using a self-contained control software application according to certain exemplary embodiments. A trusted service agent  sends a one of a number of available requests , along with the AID and a card software application for installation, deletion, or another function, each to be performed within the secure element  of a contactless smart card. In certain exemplary embodiments, the install application B request is received via the JCRE . The JCRE  includes API classes and methods  and  to perform the functions requested by the TSA . For an exemplary install function, an install instruction A is sent to the card software application represented by the short AID of the full AID reference used in the TSA request (B). In certain exemplary embodiments, the card software application for card type C B is chosen to receive the API function call from the JCRE  because the full AID the received request includes the short AID of the selected card type C B. This indicates that the received software application may actually be an institutional instance of an existing card software application. The card software application B initiates the installation of the instance of the card software application as received within the secure element.","In certain exemplary embodiments, upon installation, the card software application notifies the control software application  of the newly installed instance of the card software application. The card software application may simply trigger a method call B with the card software Java applet using the full AID of the instance, along with an event ID to indicate the function  performed on the instance (e.g., install, delete, etc.). The control software application  adds H the AID of the payment card software application or a card software application instance to the UPL . In certain exemplary embodiments, the card software application applets  access the control software application SIOs  from a constructor class instance of the card software application , thereby triggering the instantiation event for notification of deletion A, installation B, transaction X, and other related functions .","In certain exemplary embodiments, to ensure the constructor instance is not throwing an exception during instantiation (for example, if an algorithm including a function requested by the TSA is not supported or the contactless smart card memory is not sufficient), event notification  can be done after JCRE registration of the instance (register method) . In certain exemplary embodiments, for MasterCard owned card software application instances e.g., instance , the event for notification  can be triggered by a generic software application upon creation of the instance, where the generic software application masks the full AID to support short and long AID implementations from the terminal reader's that reads only the full or only a short sized AID. For the DELETE function , the secure element  operating system OS receives a JCRE  function  which marks the card software application instance or the whole card software application package for deletion. If open references are not found, the deleted applet is removed from registry  and the memory is freed by the OS. The JCRE  provides an AppletEvent method \u201cuninstall,\u201d which is called, if implemented, before a card software applet  is deleted. The \u201cuninstall\u201d method allows the instance to execute maintenance before removal. As an example, references can be set to null, or in this case, notification  is sent to the control software application  that the instance  has been deleted. The control software application then removes the deleted payment card software application entry (AID) G from the UPL . As such, this removal allows synchronization of the UPL  against the actual JCRE registry D supporting the notification event mechanism.","A card software applet can trigger an event to the control software application  through its SIO  using an applet defined uninstall method using the JCRE APIs. For MasterCard owned banking instances, for example, the generic software application applet signals the removal of an instance (by setting it to \u201cnull\u201d and clearing all data). During SELECT, the payment card software application  notifies the control software application  that the payment card software application A-X is selected. The control software application  updates the event logging list  accordingly and a sequence counter  notes the notification. The AID can be provided as a parameter within the notification A-X to the control software application  for performing the selection. However, for a MasterCard bank instance, the full-size AID can be included in the notification as the server mode SIO may not determine the bank instance masked by the payment card software application's short AID. In certain exemplary embodiments, this solution applies for legacy readers, where legacy readers are unable to read the short-sized AID. For non-MasterCard payment applications, the AID can be retrieved using JCSystem.getPreviousContextAID method in the SIO java card functions of the JCRE . After finding the AID of the client of the SIO, the control software application  searches through all AIDs in UPL  and maps it to the corresponding short File ID (SFID).","In certain exemplary embodiments, for the UNBLOCKED\/BLOCKED functions from the JCRE , based on requests from the TSA  may be rendered on a selected AID of the card software application  for blocking. The instruction for blocking or unblocking may be defined by the control software application  using APIs from the JCRE that causes a selected card software application  to trigger an event to the control software application . Simultaneously, another instruction is executed, for example, to remove the card software application instance from PPSE or the JCRE registry D, and to clear \u201cAlwaysOn\u201d for the blocking event. For the PIN VERIFIED\/PIN FAILED functions, the payment card software application A-X informs the control software application  about the status of the card software application post rendering of the function. The TSA  will interface directly with the payment card software application  for PIN processing. The wallet application on the mobile device OS also has a method to gather a PIN processing state using the UPLs  event list and the APDU disclosed previously. In case of payment transaction commands, a payment card software application  can trigger a function to add a transaction event  as a notification to the event logging list  of the control software application . The timing of the event notification is defined by the card software application, for example, it can be during the selection of the card software application or after the last command processed on the secure element.","System Process","In certain exemplary embodiments, external commands available for the CRS (GP control software application) include a SELECT command. The SELECT command initiates the CRS to return file control information (FCI) signaling the version number and global event sequence counter. Here, the data may include the CRS AID, which can be the AID for the control software application. The response to the command is tag \u201c6F\u201d: FCI template, tag \u201c84\u201d: CRS AID, tag \u201cA5\u201d: FCI Proprietary Template, tag \u201c9F08\u201d: version number (2 bytes), Value \u201c01\u201d \u201c00,\u201d tag \u201cA9\u201d: Global Event Sequence Counter (big endian). To obtain a CRS registry entry, the GET STATUS command is used. This command retrieves the CRS registered contactless applications, the Lifecycle status, and other information according to the given match\/search criteria. Data on non-contactless payment applications may not be available through this command (for example, the CRS control software application itself cannot be mined). Authentication is not required to process this command. Data secured is of the format tag \u201c4F,\u201d full-size AID, partial AID, where \u201c4F\u201d \u201c00\u201d means complete registry. An alternative response could be \u201cregistry entry\u201d: \u201cnone\u201d if not found; if found, the data is encapsulated in the application related data tag \u201c61\u201d for the certain exemplary conditions including, one applet in case of full-size matching AID, one or more applets in case of partial AID match, and a complete registry if no AID specified.","The SET STATUS command may be used to modify the \u201cAvailability State\u201d of the CRS registered contactless software card application(s), and the priority assigned to the active application list in the PPSE or the FCI. In addition, the SET STATUS command can be used to globally switch on\/off the contactless interface. The SET STATUS command may be limited in terms of modification options offered to non-contactless application data. Further, authentication may not be required to process this command. The data targeted by the SET STATUS command for one or more application AIDs includes information corresponding to contactless interface activation\/deactivation status, application lifecycle state, and application discretionary data. The response to the command may either be an \u201cOK,\u201d data\/signal when the user preference is rendered, a \u201cwarning\u201d data\/signal when conflict resolution is successful where user preference is executed partially, and\/or an \u201cerror\u201d data\/signal when conflict resolution fails, where the previous user preference is still active. This process is illustrated in .","In certain exemplary embodiments, for the GP specification of a payment environment, an internal method call in the PPSE towards the control software application applet typically modifies the FCI. By way of an example, a function, \u201csetFci(byte[ ] aidList):void\u201d, may be defined that lists parameter AID including tag length value (TLV) of the coded AIDs, where the coding may be defined according to the EMVCo contactless specification. A clearFci( ): void function may be defined for clearing the FCI content in the PPSE. However, for EMV compliant terminals, the PPSE may not show any payment applications on the secure element for this method, and a direct read is performed to an active card software application as illustrated in .","In certain exemplary embodiments, the JCRE or the control software application may include internal method calls toward each of the payment card software applications. When the payment card software application does not belong to the MasterCard payment system, the AID parameter and its length may not be of relevance for the reader and internal card software application selection. The selection of the card software application may be enabled or disabled accordingly. In case the card software application belongs to the MasterCard payment system, a generic software application locates the institution (e.g., bank, stores, etc.) instance of a card software application according to the AID parameter. In certain exemplary embodiments, the internal method calls applicable may include such custom functions as, a enableSelection(byte[ ] aid): Boolean, for enabling selection of a payment card software application and returning values as true if enabled or false for a general error (for example, the applet is locked). Another exemplary method call includes the disableSelection(byte[ ] aid): void, which disables selection of a payment type card software application.","Further,  also illustrates a standard payment transaction and related event notification using a payment type card software application, where the payment is processed as defined by EMV standards to support existing readers  according to certain exemplary embodiments. Payment type card software applications allow a selection and a transaction over a contactless radio interface. In certain exemplary embodiments, using the terminal  selects either the PPSE or an activated card software application X and receives the FCI from the PPSE listing the available card types by the AID. In certain exemplary embodiments, the terminal reader  may make a default request for a particular card software application. For MasterCard payment applications, in view of the previously described legacy ready issues, the reader terminal matches short-sized AIDs of the MasterCard payment application. The terminal then selects the matching short-sized AID of the MasterCard payment application. Upon receipt of a SELECT command, the MasterCard applet checks if an active bank instance exists, and if yes, then the payment card software application sets routing information for commands to the active bank instance. The SELECT command is forwarded to the active bank instance. If the response is modified, the application exchanges FCI with the short-sized AID of the MasterCard payment application. This response is communicated back to the terminal. If an active bank instance does not exist, the same error status is returned to the terminal as for non-existent AIDs on the card. Thereafter, all proceeding commands and responses are routed to the selected bank instance.","For non-MasterCard payment applications, the terminal will match full-size AIDs, and will select a full-size AID of the payment application. Upon receipt of a SELECT command, the payment card software application checks if selection is enabled, and, if yes, initiates processing functions as previously discussed. If the selection is disabled, the same error status is communicated to the terminal as is returned for non-existent AIDs on the smart card. For access purposes, in an exemplary embodiment, only the wallet application can access the control software application externally. An access control is not needed for any other application, and indirect access control is limited and exercised by the use of a contact interface, ownership of the contactless payment device, or security features on the device, such as hiding API access to the secure element. Additional security can include adding PIN verification, among other methods. The control software application does not exhibit the UPL or any other information internally. The control software application uses UPL for the decision process, for example, what payments applications should be updated with active\/inactive (activated\/deactivated) information and what content should PPSE exhibit to the terminal. To perform this function, the application follows the SIO method by acting as the client and accessing information via the SIO PPSE and payment applications.","Compared to the PPSE in a card form factor, the PPSE in a mobile contactless payment device may not be static. The user preference for a specific payment instrument may be applied by activating and deactivating certain payment apps and also, by exhibiting directory of available card software applications to the terminal. Such a directory may be contained in the FCI of the device PPSE. The PPSE functionality may conform to the definitions of the EMV specifications in order to support legacy readers. For mobile contactless payment devices, the PPSE can be updatable. In certain exemplary embodiments, the update process is handled internally through the control software application. The EMV approach makes the update process configurable directly using the user-interface, i.e., the wallet application, on the mobile device. The EMV contactless mobile specification commands \u201cPUT TEMPLATE\u201d and \u201cGET TEMPLATE\u201d can be mapped to SIO methods for the control software application. The FCI in the PPSE can be a list similar to the UPL list; however, some differences may be related to the strict structure as defined by EMV, where full-size AIDs of MasterCard payment applications' bank instances may not be listed. Instead, only the first 7 bytes are listed. In this manner, a subset of the UPL is listed (in case the UPL includes strict EMV structure with extensions such as \u201cAlwaysOn.\u201d). This listing is illustrated in , where the directory software application  includes a list of short and full sized AIDs . When the application  is presented to the reader device , the reader device may select an application according to the pre-set reader designations or the availability of the active card software applications .","In certain exemplary embodiments, the PPSE FCI  is accessed for reading through the contactless interface, and is not access controlled to support legacy type readers with EMV specifications. Here, all the data in the PPSE may not be distributed to merchants' reader by default, but is available to the user for selection via the user-interface. The user may choose to use the access functionality for specific payments on short distance contactless communication with a specific merchant terminal. The wallet application user-interface may implement configuration options for the data included in the PPSE, where the data can be further distributed, for example, using loyalty programs or pinpointed advertising.","Application Lifecycle Management of on-card application lifecycles are defined in GlobalPlatform (GP) specifications, specifically for contactless in GP 2.2. In certain exemplary embodiments, the existing card lifecycles may be coded on the first byte, while the second byte defines a contactless activation state. The additional three contactless activation states are \u201cACTIVATED,\u201d \u201cDEACTIVATED,\u201d and \u201cNON_ACTIVABLE.\u201d The contactless activation state byte may be encoded independently of the application lifecycle state byte. The value of the contactless activation state byte can be retrieved independently using the GET STATUS command from the CRS control software application. A card software application currently in the \u201cACTIVATED\u201d state is able to communicate through the contactless interface. Conversely, an application currently in the \u201cDEACTIVATED\u201d state may not able to communicate through the contactless interface. An application in the \u201cNON_ACTIVATABLE\u201d state is implicitly DEACTIVATED due to some internal reason known by the application or its provider (for example, a possible attempt of fraudulent use), and cannot be ACTIVATED by the control software application. Any attempt to activate an application that is currently in the NON_ACTIVATABLE state typically fails.","In certain exemplary embodiments, transitions between the three contactless activation states abide by certain rules maintained by the control software application. In an exemplary rule, an application may always able to transition itself into the \u201cDEACTIVATED\u201d state automatically. In another exemplary rule, an application cannot transition itself into the \u201cACTIVATED\u201d state without user permission and in yet another rule, an application may transition itself into the \u201cNON_ACTIVATABLE\u201d state at any time, thereby indicating to the OPEN that it is both deactivated, and not in a suitable internal state to become ACTIVATED on the contactless interface. Further, an application may be able to transition itself from the NON_ACTIVATABLE state to the DEACTIVATED state, thereby indicating to the OPEN that it is in a suitable state to become ACTIVATED again. In addition, certain rules may also be applied to the lifecycle process for communication with the contactless interface. In one exemplary rule, an application may not communicate through the contactless interface if it is not in a selectable state (in particular, when the application is in the LOCKED state). Further, when an Application is unlocked, the contactless activation state remains in the same state as it was prior to being in the LOCKED state, which means that the wallet application should be cautious while setting the contactless activation state to DEACTIVATED.","In certain exemplary embodiments, personalization of certain card software applications may not be compliant to EMV and other payment system standard specifications. This may be a result of the application objects that are created, and may not be directly available for use via a full-size AID compared to a payment card software application on a card (form factor). MasterCard in legacy reader devices may not support short-sized or partial AIDs. A personalization flow modification and personalized commands can be considered in this case. In certain exemplary embodiments, support for legacy readers can be implemented on a personalized PPSE. The card software applications that access the issuer secure domain (ISD) of the contactless smart card can be accessed for customized GP API creation using the issuer secure domain (ISD) keys. The personalization method, in certain exemplary embodiments, is performed by injecting personalization keys encrypted with an ISD data encryption key (DEK) to the ISD to access existing card software applications. A payment card software application may be selected and authenticated using the personalization keys for customization purposes.","In certain exemplary embodiments, the personalization of the selected payment card software application may be implemented by changing the FCI tag  and other accessible data upon gaining ISD access. Further, the personalization phase for a payment card software application can then be disabled to complete functionality of the personalized software application within the secure element. An INSTALL function for install and selection of the application is applied to the personalized card software application. The INSTALL function is the GP command handled by a payment card software application to instantiate a bank object, which, in this case, is a full-size AID included in the INSTALL command. A new command may be created to describe this same function for the purposes of personalization of the card software applications. The payment card software application notifies, via the SIO, internally, to the control software application of successful instantiation. In another exemplary embodiment, a second new command may be instituted using the available APIs for selection, by file, of the personalized card software application's data object with full-size AID. The selected data object can be routed by the secure element OS to the payment application. The personalization script for a selected card software application may be created according to the payment system specification to be supported by the software application. A final personalization command may be applied to disable (or terminate) the bank object personalization phase. While the payment card software application may not be personalized afterwards, it is an option to allow bank object instantiation and personalization during post-issuance.","In certain exemplary embodiments, deletion of a card software application involves sending the DELETE command directly to the card software application. The data field of the command contains the AID of the instance of the card software application to be deleted. In certain exemplary embodiments, only a full-size AID is accepted to identify the exact instance for deletion. In certain exemplary embodiments, to delete a card software application instance, a card software application is selected and authenticated using ISD keys, where the card software application accesses the ISD in the secure element using GP APIs defined by the JCRE. The GP's DELETE [AID] command may be executed, and the card software application clears all instance specific data, where the data is not shared. All the session data is cleared to 0s. The secret keys are overwritten with 0s and the transient keys, transient data, and persistent data are set to null. The set instance is also set to null and the garbage collector method is called for cleanup. The card software application then notifies the control software application about the deletion using the SIO.","In certain exemplary embodiments, all card software applications other than the MasterCard type card software applications may be allocated a memory size limitation. The persistent memory typically stores code and data, while transient memory can provide such data as the number of instances of card software applications available to the user. For example, only two MChip instances may be installed within the smart card. Further, it may be possible to free memory for a removed payment application, but it may not be possible to free memory in the secure element for a deselected application. When only one card software application and its instance exists, then the AID length can be set to a default at 7 bytes, while more than one instance changes the AID length requirement to 8 bytes.","In certain exemplary embodiments, the systems and methods of implementing a secure element control software application to control the PPSE and the individual card software applications, and the process of personalizing payment applications to conform to the control software application, may be described in a service level agreement (SLA) between the control application owner and the payment card software application owner. The SLA defines the level of personalization and interaction allowed between the payment card software application and the controller application. The SLA defines business rules that will be automatically implemented when the payment device owner selects a payment card software application for installing on the device from a trusted server. As illustrated in , the control software application in the secure element interacts with the wallet application, where the wallet application is available to a user via a graphical user interface (GUI) of the contactless payment device. The wallet application secures data from the secure element and displays aggregated payment options to the user. The SLA defines business rules to control the payment card software application priority with respect to the reader terminals at points-of-sale. The control software application can prevent the reader terminal from applying certain forceful methods to select a payment card software application from a list of available options. For example, the control software application can prevent readers from choosing a certain credit card application over a different credit card application.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 4","b":["400","405","410"]},"In certain exemplary embodiments, the received software coded instruction may be a short software coded remote method invocation (RMI) to an existing API within the secure element to perform a function on the selected card software application. In another exemplary embodiment, the software coded instruction may be the function itself that is rendered within the virtual machine in the secure element of the smart card. Further, if the software coded instruction is received from the wallet application, then the instruction is in the APDU format, and may be issued to a process method of the card software applet representing the selected AID. The instructions may include at least, \u201cinstall,\u201d \u201cdelete,\u201d \u201cactivate,\u201d \u201cdeactivate,\u201d and \u201cprioritize.\u201d The prioritize instruction contains information on where to place the selected card software application from among the list of registered active card software applications.","Block  triggers an update to the registered list  of card software applications stored with a software coded tag responsive to the instruction performed. The tags are stored in the event logging list  as depicted in . The updated list of the card software application is synchronized, via an update, block , with the PPSE list, or in the alternative, the PPSE list is directly altered to reflect the changes requested by the software coded instruction. In certain exemplary embodiments, the software coded instructions are rendered via the control software application to the list of registered applications within the PPSE applet, thereby eliminating the redundancy of a UPL and a PPSE based FCI list.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 5","b":["500","500","504","512","504","512","508","508","520"]},"In certain exemplary embodiments, the FCI directory list is returned to the user in short sized (7 byte) AIDs depicted in block . The terminal process in block  analyzes the data received and selects a 7 byte AID among the FCI list. The selected 7 byte AID is sent, referenced in block , to the card software applications list (UPL) in the control software application. In block , the selected short AID is compared to the UPL list to retrieve the full size AID related to it. The SIO of the selected full size AID is accessed via a client mode function for the control software application and the full size AID with SIO data is returned to the control software application, per block . The full size AID is exchanged for the related 7 byte AID, and the data, along with the 7 byte AID, is transmitted to the terminal for processing, block . The 7 byte AID and its related full sized AID are then used for the next set of card software related function transactions with the UPL providing the exchange of short and full size AID at each transaction process shown in blocks -.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 6","b":"600"},"The control software application  in  communicates via SIOs  with the card software applications  (shown as the \u201ccard software applications\u201d). Each software application, for purposes of transaction, control, directory, or any other smart card function is loaded into the smart card as an application package. The application package includes multiple computer-coded files for installation within the smart card. When installed in the secure element, the application package creates its own SIO within an application memory context assigned to the application package by the runtime environment of the smart card. The creation of SIO related to a control applet and at least one card applet is depicted via block . The application memory contexts are independent object spaces defined by a firewall that separates each of the contexts. By way of an example, a Java card runtime environment (JCRE) allocates an area within the smart card memory for storing the application package and associated data objects. When an application package renders within the runtime environment of the smart card during execution, the application generates data that is stored within the fields of the associated data objects. Each of the allocated application memory contexts forms a secure and isolated memory area for the overlying software application and data object. For a software application instance that is installed within an existing application package, the application instance and the SIO of the instance share the same context with its parent application package. In the Java Card implementation, the application package is a class file and the application instances are instances of the classes.","When applications and their instances reside within the same context, the SIOs related to the application and their instances may be shared by each of the other instances within the context without special access requests. Accordingly, a card software application, which in a Java Card implementation is a card applet, may obtain data from SIO fields of other instances of the card applet by requesting the data directly from the parent applet that owns the SIO. However, when for application packages that are installed in one application memory context, their SIOs are limited for access by firewalls of the application memory context. In an exemplary embodiment, block  depicts the step in method , for enabling applets to request for access to SIOs across a firewall, where the requisition is implemented via block , using process method function calls of the runtime environment. Accordingly, a software application or its instance that resides in a different application memory context has to perform a client role by initiating an access request via the runtime environment process method function calls to a server card applet including the intended SIO data to be accessed across the firewall. After access is granted, block  depicts a method step, where the client software application may invoke process method function calls in the server applet to access the data in the server applet's SIO.","In block , an exemplary embodiment of tracking information related to one of a number of SIOs is depicted. The control applet and the directory applet stores a registered list of card applets available within the smart card device. The directory applet may only register the active card applets from data provided by the control applet on the status of each of the card applets. The data provided by the control applet is stored in pre-defined fields of the control applet SIO as illustrated in  at B. Only the active instances or application packages (illustrated as  in ) from the control application SIO are listed in the directory application SIO, and may be presented to an external card reader. Accordingly, when an SIO owned by a card applet is accessed by the control applet or the directory applet for performing an action on the card applet, such action is recorded by updating data tags related to the card applet via block . Actions performed on the card applet include, a delete action, a select event, a block event, an unblock event, a personal identification number (PIN) verified event, a PIN failed event, and a payment transaction event. The data tag is illustrated in  at G-H, where the data  is retrieved from the SIO of the control applet.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 7"},"Block  depicts a receiving step, where the TSM includes trusted service agents to authenticate requests for card software applications from remote contactless payment devices that include the smart card. The TSM also authenticates instructions for functions to be performed on new or installed card software applications. The card software applications are typically in a computer-coded form, for example, in a Java Card implementation, the card software application may be in CAP file, where the CAP file is a compressed set of components including bytecode, class information, links, and verification information. The smart card receives the card software application, along with an AID or an AID may be assigned to the application by the runtime environment. Block  performs the rendering step, wherein the received instruction is rendered to perform the function of the received card software application. Alternatively, the function may be performed on an existing card software application. Block  performs a registration step for the card software application, where the AID of the card software application is listed in the control software application along with a computer coded tag, the computer coded tag responsive to the function performed on the card software application. The registration process involves, in one exemplary embodiment, listing the AID code received with the card software application with a status tag that defines the status of the application. The receipt of a card software application from a TSM, installation, and registration of the card software application is illustrated in , and has been described in detail with reference to the exemplary system and device of . The instructions that may be performed on the card software application using process methods include delete, activate, de-activate, add instance, install, block, and unblock.","The TSM also provides instructions to the contactless smart card based on requests received by a user of the contactless smart card. By way of an example, if the user wants to activate\/deactivate a card software application registered within the control software application, the user issues a request to the control software application. However, the user may not be able to directly send data or instructions for functions to the control software application, as the controls software application is resident within the secure element. Accordingly, the user needs to secure authentication for instructions prior to the control software application receiving and rendering the instruction. The TSM provides authentication for instructions received by the smart card from the user of the smart card device. When the smart card is embedded within a contactless payment device, the user may provide an instruction via a user-interface software application that renders on the contactless payment device.","In a Java Card implementation, a user-interface MIDlet is deployed on the contactless payment device, where the MIDlet passes user input to the runtime environment (or JCRE) of the smart card, and the runtime environment authenticates the instructions via process method function calls to the TSM. The authenticated computer coded instruction is sent to the runtime environment for rendering. Alternatively, the TSM may issue pre-defined instructions for such exemplary external functions, as blocking\/unblocking a card software application because of such issues as a theft, over-uses, or account overdraft. Such pre-defined instructions do not need external requests to the control software application, but may deploy directly to the control software application for rendering. Block  depicts a step of method  wherein the TSM sends one of number of available instructions to be performed on the card software application. The instruction from the TSM may be in the form of a software code to invoke a process method function call of the card runtime environment. Block  uses process methods in the card runtime environment to update the card application status tag in the control software application with a computer code related to the instruction performed.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 8","b":["800","805","810"]},"Block  depicts the editing step of the exemplary embodiment of method . Once an external device gains access to the card software application, certain data fields may be edited. In certain exemplary embodiments, the file control information (FCI), a priority status tag, and application discretionary data may be edited. Applets, in the form of the control software application or the card software application typically return a success status when an external card reader selects an application. However, when the selected card software application's FCI data is activated, then the selected card software application returns the FCI data retrieved from an SIO that includes the FCI data as an object field. The FCI data is returned in a tag length value (TLV) format as disclosed above. The FCI data may be edited to include additional AID bytes, where the external card reader selects a short (or 7 byte) AID, and the selected card software application automatically routes the selection to an instance of the card software application, the instance including a full sized AID.","Further, the edited FCI can be edited to include routing information to route an external card reader request received at the card software application to an alternate AID of an alternate card software application. The editing and routing in the card software application enables the smart card to route external card reader requests to any underlying active instance of the card software application. Accordingly, multiple instances of a card software application may reside on the smart card, with one of the instances designated as an active instance. Further, in the case of a legacy reader that may read a short sized AID with 7 bytes of AID data, the reader may be routed to the complete AID using the edited AID as an intermediate routing application.","Block  depicts the installation process that follows the editing, where the edited card software application is installed for \u201cmake selectable,\u201d which causes the runtime environment to instantiate a related card sharable interface object (SIO), the card SIO including the alternate AID defined for retrieval by the FCI as described above.","As mentioned previously, the method  is useful with secure element payment applications for legacy readers. Certain legacy readers recognize only applets having a short-form AID. However, the long-form AID applets can allow more functionality and specifically can allow use of multiple software applications within a mobile device. A legacy card reader requests invocation of a software applet based on the short-form AID known to the legacy card reader. A router applet operating on the mobile device receives the request for the short-form AID applet, determines the long-form AID applet corresponding to the short-form AID applet, and routes the request to the long-form AID applet, thereby invoking the long-form AID applet. In this manner, legacy readers that have stored therein only the short-form AID applet can invoke the functionality of the long-form AID applet on the smart card. Additionally, newer readers implementing the long-form AID applet can request directly the long-form AID applet.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 9","b":"900"},"Many primary functions, such as de-activate and activate for a card applet within the secure element require TSM permissions prior to implementation. Using ISD keys, via process method function calls of the card issuer or the card runtime environment, allows some primary functions to be performed on a card applet using input from a user on an insecure midlet. Block  depicts a selection step to identify at least one card applet to configure from a midlet residing outside the secure element. The selection step uses the AID of the intended applet to identify the applet. In an exemplary embodiment, the midlet recognizes the name of the card applet from the user input and extracts an AID related to the name, where the AID is used for the remainder of the steps. Block  includes application programmable interface (API) function calls for transmitting the AID of the selected card applet, and for encrypting and transmitting a computer coded instruction for a function to be performed on the card applet. The stored keys in the secure element can be used to verify and decrypt the receiving computer-coded instruction. Block  depicts an invoking step, where the control applet initiates process method function calls defined by the card issuer or the card runtime environment. The invoked process method function calls perform the selected function defined in the computer-coded instruction selected by a user on the midlet. The card runtime environment renders, via block , the process method function call, thereby performing the selected function on the selected card applet.","One or more aspects of the invention may include a computer program that embodies the functions described and illustrated herein, wherein the computer program is implemented in a computer system that includes instructions stored in a machine-readable medium and a processor that executes the instructions. However, it should be apparent that there could be many different ways of implementing the invention in computer programming, and the invention should not be construed as limited to any one set of computer program instructions. Further, a skilled programmer would be able to write such a computer program to implement an embodiment of the disclosed invention based on the appended flow charts and associated description in the application text. Therefore, disclosure of a particular set of program code instructions is not considered necessary for an adequate understanding of how to make and use the invention. The inventive functionality of the invention will be explained in more detail in the following description of exemplary embodiments, read in conjunction with the figures illustrating the program flow.","The exemplary methods and acts described in the embodiments presented previously are illustrative, and, in alternative embodiments, certain acts can be performed in a different order, in parallel with one another, omitted entirely, and\/or combined between different exemplary embodiments, and\/or certain additional acts can be performed, without departing from the scope and spirit of the invention. Accordingly, such alternative embodiments are included in the inventions described herein.","The exemplary embodiments can be used with computer hardware and software that perform the methods and processing functions described above. As will be appreciated by those having ordinary skill in that art, the systems, methods, and procedures described herein can be embodied in a programmable computer, computer executable software, or digital circuitry. The software can be stored on computer readable media. For example, computer readable media can include a floppy disk, RAM, ROM, hard disk, removable media, flash memory, memory stick, optical media, magneto-optical media, CD-ROM, etc. Digital circuitry can include integrated circuits, gate arrays, building block logic, field programmable gate arrays (\u201cFPGA\u201d), etc.","Although specific embodiments have been described above in detail, the description is merely for purposes of illustration. It should be appreciated, therefore, that many aspects described above are not intended as required or essential elements unless explicitly stated otherwise. Various modifications of, and equivalent acts corresponding to, the disclosed aspects of the exemplary embodiments, in addition to those described above, can be made by a person of ordinary skill in the art, having the benefit of the present disclosure, without departing from the spirit and scope of the invention defined in the following claims, the scope of which is to be accorded the broadest interpretation so as to encompass such modifications and equivalent structures."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
