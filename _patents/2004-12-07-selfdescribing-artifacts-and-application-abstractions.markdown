---
title: Self-describing artifacts and application abstractions
abstract: Described herein is at least one implementation employing multiple self-describing software artifacts persisted on one or more computer-storage media of a software-based computer. In this implementation, each artifact is representative of at least part of the software components (e.g., load modules, processes, applications, and operating system components) of the computing system and each artifact is described by at least one associated “manifest,” which include metadata declarative descriptions of the associated artifact.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07451435&OS=07451435&RS=07451435
owner: Microsoft Corporation
number: 07451435
owner_city: Redmond
owner_country: US
publication_date: 20041207
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This invention generally relates to a technology for managing the software components of one or more computer systems.","The reliable installation, configuration, maintenance, and removal of components of a conventional software-based computer have long been a difficult problem. Examples of such components include the following: operating systems (OSs), application programs, device drivers, application programming interfaces, and other systems programs. Examples of conventional software-based computers include the typical general-purpose personal computers (PC) running one of the many existing OSs.","A software-based computer is typically embodied by the persistent contents and configuration of its secondary computer-storage system (e.g., a \u201chard disk\u201d). The conventional computer-embodying content and configuration is merely a collection of bits accumulated over time and without centralized oversight and coordination. Typically, these accumulated bits are the result of a series of individual ad hoc events throughout the lifetime of the computer. Examples of changes include, for example, installation of a program, change of a configuration setting in a registry key, deletion of a file, or installation of a software patch.","When a software-based computer boots, it merely executes whatever the computer finds on hard disk. Since the correctness of the contents on the computer's disk ultimately depends on the correctness of each of these ad hoc events over the lifetime of the computer, the contents and configuration of the computer may readily become corrupted, damaged, skewed, obsolete, or simply incorrect.","The correctness of the computer's contents and configuration is further threatened by other externally initiated ad hoc event involving a malicious attack by a virus, a worm, spyware, and the like. Unbeknownst to the user of the software-based computer, these malicious attacks alter the computer's contents and configuration, most likely in a manner that is inconsistent with the user's desires.","Various products and services (e.g., so-called \u201canti-virus\u201d and \u201cdisk cleanup\u201d utilities) are available for detecting and correcting a computer's contents and configuration that have become corrupted, damaged, skewed, and\/or attacked. While clearly well intentioned, these products and services may just compound the problem by introducing yet another ad hoc event to the resulting accumulation of bits on the computer's disk.","Conventional software-based computers are inherently brittle. One reason is because the computer's collection of accumulated bits has incomplete descriptions that are, at best, anecdotal. These incomplete descriptions are merely the results of the same series of ad hoc events and do not systematically describe the bits on the disk or the series of events that produced them. They are also unmatched with any specification, total or partial, of what the system configuration should be, or of any way of checking the state against the specification.","The following fact illustrates the inadequacies of conventional software-based computers: Given an arbitrary offline \u201csystem image,\u201d one cannot in general determine conclusively that the system image contains a functional OS or a specific functional application. A system image is a bit-for-bit copy of the contents and configuration information typically persisted on a hard disk of a conventional software-based computer. Those contents and configuration, as discussed above, embody the computer.","Given a system image, one may check if specific files exist on the image. This check may be done with empirical knowledge of which specific files are installed with a particular OS or particular application. However, such empirical evidence does not tell one whether all of the necessary components (of the particular OS or particular application) are installed. Such empirical evidence does not tell one whether there are any conflicting components are installed. Further, such empirical evidence does not tell one whether all of the components (of the particular OS or particular application) are configured correctly to produce a functional computer. Such checks are necessary but not sufficient.","Even if one empirically determines the existence of all of the specific files necessary for a particular OS or application to function, that fact is not sufficient for one to know that particular OS or application on the image will function correctly. Again, these checks are necessary but not sufficient.","Indeed, the only effective conventional recourse is to abandon the offline examination of the image and implement an online examination. One may boot a computer using the system image and observe the results. This conventional approach is often impractical, unsatisfactory, and unsafe. Clearly, this approach is not scalable.","Even using the conventional approach of an online examination, it is often difficult to identify, without doubt, which particular applications and\/or OS components are installed or even currently running. Often all that one has determined is that an application or component having a specific name exists on the computer. This determination relies on the software developers avoiding the use of misleading names. Such misleading names may occur inadvertently or purposefully.","For example, while existing OSs available in the marketplace (like Windows\u00ae XP or Linux) might show a list of running processes, by name of the file used to start the process, the name of each running process is only a \u201chint\u201d as to true identity of the process. For example, an innocuously named process might have been hijacked by a virus and subverted to another potentially malevolent task. Alternatively, a properly named process may have been corrupted by, for example, an administrator installing a seemingly unrelated application.","With conventional software-based computers, there is no descriptive structural link between low-level software abstractions and high-level software abstractions. This means that there is nothing in the structure or architecture of the conventional software-based computers that descriptively and necessarily links low-level and high-level software abstractions.","Low-level software abstractions include, for example, particular files (e.g., load modules) on a disk and particular processes executing on the computer. High-level software abstractions include, for example, applications programs (e.g., Microsoft\u00ae Publisher\u00ae desktop publishing product) and families of applications (e.g., Microsoft\u00ae Office\u00ae suite of office productivity products).","For example, the concept of an application program is part of a user-centric model. Where a user sees an application program (or group of programs) that helps the user accomplish a specific task (e.g., word processing, spreadsheet analysis, and database management), a conventional software-based computer merely sees one or more active processes. There is nothing inherent in the architecture of the conventional software-based computers that descriptively and necessarily links the active processes (and their load model sources) with the representation of the application program that the user sees (typically via a graphic user-interface (GUI) process).","Described herein is at least one implementation employing multiple self-describing software artifacts persisted on one or more computer-storage media of a software-based computer. In this implementation, each artifact is representative of at least part of the software components (e.g., load modules, processes, applications, and operating system components) of the computing system and each artifact is described by at least one associated \u201cmanifest,\u201d which include metadata declarative descriptions of the associated artifact.","The following description sets forth techniques implementing a computing technology for a software-based computer employing self-describing software artifacts. An exemplary implementation of these techniques may be referred to as an \u201cexemplary self-describing artifact architecture.\u201d","The exemplary self-describing artifact architecture provides a refreshing and invigorating approach to the realm of computer science. Rather than being no more than an accumulation of bits resulting from series of ad hoc events during the lifetime of a software-based computer, the contents and configuration of the computer utilizing this new architecture is an organized, stable, reliable, robust, and deterministically constructible collection of self-defining software artifacts.","Before describing the new architecture, a brief introductions of terminology is appropriate. The following terms, as used herein, are briefly defined here. However, the reader is encourage the read the full text to understand and appreciate the full meaning of each term in the context of the full description.\n\n",{"@attributes":{"id":"p-0030","num":"0034"},"figref":"FIG. 1","b":["100","100","102","110","102","112","110"]},"The computer  has access to at least one computer-storage device  (e.g., a \u201chard disk\u201d). The computer-storage device  contains the contents and configuration that embody the computer . The contents include various software components, which include (by way of example and not limitation) an operating system (OS), the OS elements, all installed applications, and all other associated components (e.g., device drivers, installation files, data, load modules, etc.). The configuration includes the specified properties of each software component and the defined interrelationship amongst the components.","For the purposes of this discussion, references to the \u201csystem\u201d represents the software-based computer  as it is embodied by the contents and configuration of the storage device . A persisted offline (i.e., non-executing) copy of the system may be called, herein, a \u201csystem image.\u201d",{"@attributes":{"id":"p-0033","num":"0037"},"figref":"FIG. 1","b":["130","140","150","120","120"]},"Unlike a conventional software-based computer, the artifacts of the computer  are not merely an accumulation of bits resulting from series of ad hoc events during the lifetime of the computer. Rather, each of the artifacts of the computer  are associated with at least one manifest. For example, systems artifact  has its associated manifest  stored therewith the artifact or at some derivable or known-location on the storage device . Artifacts  and  have their associated manifests,  and  respectively.","These artifacts are called \u201cself-describing artifacts\u201d because each of the artifacts (via its associated manifest of metadata) describes itself. Rather than being procedural (e.g., a list of actions to be performed), the self-describing metadata descriptions are a declarative description of the desired state of the artifact.","Each description is a complete prescriptive record of the state necessary for the artifact to be consistent and correct. By analogy while a set of directions is procedural, a precise address is declarative and more powerful in the sense that it allows new computation; for example, one can use the address to determine a new set of directions for a different starting point. The declarative description includes a record of all of the artifact's interdependencies and interrelationships with other components of the system.","These metadata descriptions effectively bridge low-level and high-level software abstractions. Low-level software abstractions include, for example, particular artifacts (e.g., load modules) on a storage device and particular processes executing on the computer. High-level software abstractions include, for example, running applications programs and families of applications. High-level software abstractions may also include the running operating system (such as OS ) and its elements.","As depicted in , the computer  has, in the memory , three oversight and managerial functional components that utilize the self-components describing property of the artifacts on the computer . Those functional include a self-describing artifact manager , an execution gatekeeper , and a systems verifier .","While each of these functional components are shown separately in , their functionality may be combined into fewer components or expanded to additional components. Furthermore, these functional components may be part of the computer's OS  or they may be part of a non-OS component of the computer .","The self-describing artifact manager  manages the self-describing artifacts on the storage device . As part of that management, the manager may facilitate persistence and structuring of artifacts. The manager may ensure the maintenance of the association between each artifact and its manifest. The manager may ensure the consistency of an artifact to the description in its manifest. Furthermore, the manager may update self-describing artifacts in response to changes in configuration of the system.","The self-describing artifact manager  may assist in the optimization on the loading of artifacts from the storage device . The self-describing artifact manager may take a larger view of the overall operation of the applications and the OS of the computer. Based on this view, the self-describing artifact manager  may determine which artifacts (e.g., load modules) will be combined in processes for a particular application. The manager may then combine artifacts into a smaller, and presumably optimized, number of artifacts. Similarly, using the system manifest (which contains declarative descriptions of the entire system) to determine which applications will be invoked soon, the self-describing artifact manager can encourage the start of some applications before they are actually invoked.","The execution gateway  clears an application (and possibly other executable components) for invocation. When invocation of an application is pending, the execution gatekeeper  examines its associated self-describing artifacts. The declarative descriptions in the self-describing artifacts may specify explicit static or dynamic conditions that are required for the associated application. An example of typical explicit conditions is a list of necessary components, which must exist on the system for the successful execution of the application. Another example of typical explicit conditions is a list of applications and system components that must have been launched (or are in a specified current state) before an application itself is allowed to launch.","The gatekeeper examines the current conditions and if they meet the requirements specified in the declarative descriptions of the associated artifacts, then the gatekeeper allows invocation of the application. Otherwise, then the gatekeeper does not allow invocation of the application.","With the governance of the execution gatekeeper , no code will execute on the computer  unless the code is described in an associated manifest. In one embodiment, only code described in associated manifests and signed by trusted software publishers may be installed or run on the computer .","In addition, the execution gatekeeper  may perform audits on the integrity of the system as a check against external modification (e.g., by way of innocent data corruption or malicious attacks). The audit is based upon the manifests of the self-describing artifacts of the system.","The system verifier  performs one or more verifications on the self-describing artifacts. It may perform this in response to a manual request to do so, in response to an action (e.g., installation of new software), in reponse to new information becoming available, and\/or as scheduled to do so. Furthermore, verifications made by the system verifier  are based, at least in part, upon information gathered from an examination of the manifests of the self-describing artifacts.","The system verifier  performs one or more of the following verifications:\n\n","As shown in , another computer  is configured with its own memory  (e.g., volatile, non-volatile, removable, non-removable, etc.). This memory has a system inspector  therein.","As represented by the large-headed arrow, the system inspector  receives, as input, the \u201csystem image\u201d of the computer . In other words, it receives a copy of the system-embodying contents and configuration of the computer . It may be received directly from the computer  or indirectly as a separate copy of the \u201csystem image.\u201d","The system inspector  performs an analysis of the offline \u201csystem image\u201d to verify conclusively that the computer  contains specific functional components (such as the OS or applications). More particularly, the inspector examines the self-describing artifacts to see if all of the necessary components (described as such and referenced by manifests of the self-describing artifacts) are located and properly identified. The inspector reports the results of this examination.","The information contained in the manifest for an artifact can be used by a compiler or other optimization tool to facilitate the optimization of the code in the artifact, at install time, program load time, or another time of a user's choosing, by describing all of the libraries, components, and dependencies of the artifact. This description permits the compiler or tool to make more precise assumptions about the environment in which the artifact executes and the code within the artifact.","The information contained in the manifest for an artifact can be used by an error detection tool to facilitate ensuring the correctness of the code in the artifact, at install time, program load time, or another time of a user's choosing, by describing all of the libraries, components, and dependencies of the artifact. This description permits the tool to make more precise assumptions about the environment in which the artifact executes and the code within the artifact.","Manifest","A manifest contains metadata that describes artifacts of the computer . The metadata also describes configuration information related to the artifacts including external dependencies and external interfaces. The manifests also describe the connectivity relationships between software components.","For example, the manifest for an application called \u201cProgramA\u201d, as delivered by its publisher, includes a list of the binary load modules (EXEs, DLLs, etc.), certificates attesting to the authenticity of the components and provider, a list of the names of configuration settings and their default values, a list of external binary load modules required by the program's load modules, a list of external settings and names accessed by the program, and a list of names and settings exposed by ProgramA, such as the information required to tell the operating system that ProgramA wants to be the default editor for files with the \u201c.ZZZ\u201d extension.","In at least one embodiment, the manifests of self-describing artifacts contain declarative descriptions that provide sufficient information to enable the following:\n\n","The manifest need not contain all available metadata about a program or system, but it needs to provide sufficient information to enable reliably locating additional metadata. In one embodiment, for example, the binary load modules (EXE, DLLS, etc.) for a program contain metadata that references metadata associated with specific load modules. In this embodiment, the manifest informs the system of the existence of this additional metadata within the load modules.","In one embodiment, the manifest identifies the type of each subcomponent of the manifest. The subcomponent type identifies a piece of helper software, which knows how to interpret the contents of the subcomponent, extract additional metadata from the component, and derive additional metadata about the component.","For example, in one embodiment, load modules described in a manifest are expressed in an abstract instruction set that allows a verification tool to determine if they obey certain software properties, such as conformance to communication requirements. The manifest for the load modules identifies the exact abstract instruction set used for each load module so that the system verifier  can determine which helper software to load to verify specific system properties, such as the communication requirements.","In yet another aspect of an embodiment, the information used to determine compatibility among the parts of a system is delivered independently of the components, as well as along with them. This information can arrive from many sources, and a local administrator or agent can define or follow rules for disambiguating partial or contradictory information.","In yet another aspect of an embodiment, the information used to determine compatibility among the parts of a system changes over time, as new information becomes available at an appropriate location, or as old information is revoked.","Manifests may be combined into graphs to describe arbitrarily complex software systems. Manifests may refer to external manifests as dependencies. Manifests may also contain embedded manifests. In one embodiment, the manifest for an application contains or uses manifests for subcomponents of the application.","Depending on packaging decisions made by the publisher of the application, subcomponents can be either embedded in the manifest or referenced as external entities. In one embodiment, external dependencies include a name and version number of the dependency, or other clarifying information. In another embodiment, external dependencies are named through a signed digest. In another embodiment, this information can be updated, revoked, and clarified (i.e., disambiguated).","In one embodiment, the manifest for an application is packaged and delivered with its associated application. In another embodiment, the manifest for an application is packaged and delivered separately from its associated application. With this, the presumably multiple components of an application may be delivered separately and after delivery of its associated manifest.","In one embodiment, external manifests may also be referenced as sources of external information. These external manifests may be named individually, or they may be named as members of a group.","There are two forms of the manifests: static and dynamic. The static manifests are stored in association with software artifacts. The dynamic manifests are employed during the runtime of an executable component associated therewith. The dynamic manifest includes the static metadata (which is still available at runtime) and additional dynamic metadata that are constructed at runtime to connect runtime system elements, like processes and operating system objects.","This aspect further enables bridging from low-level implementation concepts to higher-level concepts. The self-describing feature of the software artifacts is useful on a running and active system and not just a static system. For example, the \u201cwell-formedness\u201d and or consistency of a running system of processes can be verified similarly to the verification of the system image.","In one embodiment, \u201c\u00fcber\u201d manifests describe all software available on the computer , directly or indirectly, and whether such software is installed or not.","Methodological Implementation of Exemplary Self-Describing Artifact Management and Gatekeeping",{"@attributes":{"id":"p-0068","num":"0095"},"figref":["FIG. 2","FIG. 2","FIG. 1"],"b":["200","160","162","200"]},"At  of , the self-describing artifact manager  facilitates persistence of manifests with their associated artifacts. As shown in of , manifest  is persisted in association with the systems artifact  or it is stored at some derivable or known-location on the storage device . Similarly, manifests  and  are stored in association with application artifacts  and .","At , the self-describing artifact manager  updates the self-describing artifacts of a system in accordance with the changes in the system's content and\/or configuration. Such changes may be result of, for example, installation of new content, a manual configuration change, and automatic configuration change performed by the operating system. Before they are applied, updates may be checked in the context of the collection of system manifests to ensure that if applied they will result in a viable system.","At , the self-describing artifact manager  optimizes the use of artifacts for execution. The manager can determine which load modules will be combined in processes for an application. The manager can then combine load modules into a smaller number of load modules, which have been optimized together. Similarly, using the system manifest to determine which applications will be invoked soon, the self-describing artifact manager can encourage the start of some applications before they are actually invoked.","At , the execution gatekeeper  examines the associated self-describing artifacts to determine whether to allow execution of the associated application (or other program) based upon the current conditions and the declarative descriptions of the associated manifests. When such determination is made, the gatekeeper may limit or prevent execution of the associated application (or other program).","For example, local policy of a computer may precisely describe which applications can and cannot be invoked, as well as the manner in which they may be invoked. If so, the gatekeeper will only allow invocation in the specified manner.","At , the system verifier  audits the integrity of the system against external modification. The audit is based upon the manifests of the self-describing artifacts of the system. For example, a load module's manifest may contain a signed digest of the contents of the one or more associated load modules. The gatekeeper can periodically check the contents of all load modules to see if they still match their specified digests.","Methodological Implementation of Exemplary System Verification",{"@attributes":{"id":"p-0075","num":"0102"},"figref":["FIG. 3","FIG. 3","FIG. 1"],"b":["300","164","300"]},"At  of , the systems verifier  responds to a triggering event. Examples of a triggering event includes (by way of example and not limitation) receiving a manual verification request, performance of action by another program (e.g., installing software), and a schedule time event. This triggering event may be identifiable and associated with a particular type of desired verification.","At , the system verifier  examines the manifests of the self-describing artifacts to gather information from those manifests.","At , the verifier performs a verification of the online and active system of the computer . More particularly, it is a verification of the self-describing artifacts. As it is possible, these verifications may be performed on an offline \u201csystem image\u201d as well.","The verifications performed by the verifier are designed to promote the stability, integrity, robustness of the system in its fully functioning condition. The following are a list of example verifications that the may be performed by the system verifier  (list provided by way of example not limitation):\n\n","At , the verifier reports the results of the verification to whatever called it (e.g., the OS  and\/or the user).","System Inspection","This new architecture overcomes many of the inadequacies of conventional software-based computers. For example, given an arbitrary offline \u201csystem image\u201d of a software-based computer using the new architecture, one can, indeed, determine conclusively that the image contains a functional OS or a specific functional application. This cannot be done with a software-based computer using a conventional architecture.","The manifest of each artifact is stored within (or can be retrieved along with) a persistent \u201csystem image\u201d of a software-based computer's content and configurations. The artifacts are stored in such a manner that their associated metadata (of their manifests) can be inspected (by, for example, the system inspector ) when the image is offline. In addition, other contents of the image may be inspected as well.","In doing so, the system inspector  may make strong statements about the contents and the future behavior of the system. This is possible even if the metadata and other parts of the system image are scattered across a distributed store, such that they come together only when the system boots and runs. By examining the static manifests of the self-describing artifacts and proposed or anticipated dynamic manifests of associated prototypes and abstractions, the system inspector  can verify a number of properties of the software-based computer .","For example, the inspector can verify the classes of properties supporting compositional verification. In other words, the inspector can determine whether all of the necessary elements of a component of the software-based computer  exist on its persisted system image and that the elements compose correctly.","A property is compositionally verifiable if components can be verified for the property individually, and when composed, the system can be known to maintain the same property without re-verifying the all of the components. For example, in programming systems type safety is considered compositionally verifiable if individual load modules can be verified as type safe and when legally combined they maintain type safety. In this case, the system inspector  can verify that each load is type safe and then verify that the load modules are combined in a legal manner without requiring complex verification across the entire system whenever a new load module is added.","Methodological Implementation of Exemplary System Inspection",{"@attributes":{"id":"p-0086","num":"0123"},"figref":["FIG. 4","FIG. 4","FIG. 1"],"b":["400","180","400"]},"At  of , the system inspector  obtains a copy of an offline \u201csystem image\u201d of a software-based computer, such as the computer . This action is illustrated in  by the large-headed arrow.","At , the system inspector  performs an analysis of the offline system image to verify conclusively that the computer  contains specific functional components (such as the OS or applications). More particularly, the inspector examines the self-describing artifacts to see if all of the necessary components (described as such and referenced by manifests of the self-describing artifacts) are located and properly identified.","At , the inspector reports the results of this analysis.","Abstractions","Operating systems provide abstractions to frame computation and allow programmers to create software more easily by focusing more completely on their domain of expertise. An abstraction denotes a model of one or more components that represents the essential characteristics of those components that distinguish them from all other kinds of components and thus provides crisply defined conceptual boundaries.","Examples of existing operating system abstractions include file system abstractions to control and manage storage, I\/O abstractions to control I\/O devices, Graphical User Interface (GUI) abstractions, process abstractions to hold computation, and interprocess communication (IPC) abstractions to enable communication between processes.","Without these basic abstractions, programmers would be forced to devise their own ad hoc methods for performing common tasks. Invariably such diverse ad hoc methods lead to reduced programmer productivity, large scale duplication of effort, and increased system errors.","In, at least, one implementation, the exemplary self-describing artifact architecture creates new operating system abstractions, which include:\n\n",{"@attributes":{"id":"p-0094","num":"0136"},"figref":["FIG. 5","FIG. 5"],"b":["500","500"],"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["1. Systems tier , which includes:\n        \n        ","2. Application tier , which includes:\n        \n        ","3. Process tier , which includes:\n        \n        ","4. Load source tier , which includes load source manifests  associated with at least one load-source artifact (e.g., load module)."]}}}},"For completeness, the system model may also include a system abstraction representing the entire running software system. In practice, the operating system  itself typically acts as the system abstraction.","Manifests are declarative description a software component (e.g., process, application, or OS element). When the manifests and the software components are persisted in association with each other, then the components are self-describing artifact.","The manifest is used to create a prototype. The act of installing a manifest and its described artifacts into a system creates a prototype. A prototype is a \u201crunable\u201d or \u201cexecutable\u201d manifestation of a software component. The prototype is used to create an instance or an abstraction of a software component. An instance or abstraction is a \u201crunning\u201d or \u201cexecuting\u201d manifestation of a prototype.","In the example structure , the right-to-left arrows are to be read as \u201cis described by.\u201d So, for example, the top tier  may read this way: OS abstraction  \u201cis described by\u201d its system prototype , which \u201cis described by\u201d its system manifest .","In this structure, the left-to-right arrows are to be read as \u201cis used to create.\u201d So, for example, the second tier  may read this way: Application manifest  \u201cis used to create\u201d its application prototype , which \u201cis used to create\u201d its application abstraction .","Similarly, the members of each tier have a defined relationship between members in other tiers. Each member of a progressively higher tier references or includes the like members of lower tiers.","In the example structure , the top-to-bottom arrows are to be read as \u201cincludes or \u201csupervises.\u201d So, for example, the system manifest  \u201cincludes\u201d the application manifest , which \u201cincludes\u201d the process manifest , which \u201cincludes\u201d the load-source manifest .","In this structure, the bottom-to-top arrows are to be read as \u201ccontained in\u201d or \u201cis supervised by.\u201d So, for example, the process prototype  \u201cis supervised by\u201d the application prototype , which \u201cis supervised by\u201d the systems prototype .","In alternative implementations, the exemplary self-describing artifact architecture has a different number of tiers, different arrangements of tiers, and\/or different abstractions.","The systems manifest  describes the entire system (i.e., all of the artifacts). It is a top-level manifest pointing to manifests for each operating system component and each application. Depending on scope, individual operating system components are described with application, process, or load source manifests.","The application manifest  contains the process manifest . As such, the application manifest describes or specifies the processes that are created when the application (represented by application abstraction ) runs. Application manifests may also identify the interprocess communication interfaces exposed or required by the application and describe the bindings between interprocess communication interfaces of processes within the application.","The process manifest  contains load module manifests describing or specifying the load modules included in the process (represented by the process abstraction ). Process manifests may identify the interprocess communication interfaces exposed or required by each process and describe the bindings between code and data interfaces on load modules.","The load source manifest  describes or specifies the persisted binary file containing the executable code of the load module and identifies any further load modules required by this load module. Load source manifests identify the code and data interfaces exposed or required by the load module.","An embodiment may support several types of manifests including manifests for running processes and for process prototypes, manifests for running applications and for application prototypes, manifests for running operating system components and for their prototypes, manifests for hardware devices, and one or more manifests for the system as a whole. In such an embodiment, the differing manifests may share and reuse the same structural elements.","Application Abstraction","Rather then just being part of a user-centric model, the concept of an application program is actually part of this the exemplary self-describing artifact architecture . In particular, the OS  (or portions thereof) inherently recognize the concept of an \u201capplication abstraction.\u201d As described by its associated manifest, an application abstraction is descriptively and necessarily linked to specific low-level abstractions (such as active processes and their load sources) and specific high-level abstractions (such as the operating system).","When a user, either directly or indirectly, runs a program, the OS  creates an instance of an application abstraction (such as application abstraction ) from an application prototype (such as application prototype ). Creating an instance of an application includes creating new instances of processes described by their process prototypes.","The static description of the application is embodied in one or more application manifests (such as application manifest ). The OS  maintains \u201cdynamic\u201d metadata that links processes with applications, processes with process prototypes, and applications with application prototypes. The OS  also maintains additional dynamic metadata that links process prototypes and application prototypes with their respective manifests.","The application abstraction is embodied in a dynamic object. Other software components (such as part of the OS) can communicate with the dynamic application abstraction objects to determine which applications are running, to determine which processes belong to an application, and to retrieve other metadata, such as manifests, that are also available. For example, given the identity of a process, a program can ask the OS for the identity of the application to which it belongs; given the identity of an application, a program can ask the operating system for the identity of its application prototype; etc.","Methodological Implementation of Exemplary Application Abstraction Management",{"@attributes":{"id":"p-0113","num":"0168"},"figref":["FIG. 6","FIG. 6","FIG. 1"],"b":["600","112","600"]},"At  of , the OS  recognizes a triggering event. Examples of a triggering event include (by way of example and not limitation) receiving a manual program invocation request from a user, receiving an invocation request from another program, and a scheduled time event for program invocation. This triggering event typically identifies the application to be invoked.","At , the OS  creates an instance of the identified application described by its application prototype. This instance is called an \u201capplication abstraction.\u201d As illustrated by example structure  of , creating the application abstraction includes creating new instances of associated processes described by their process prototypes.","At , the OS maintains \u201cdynamic\u201d metadata that links associated processes with the identified application abstraction, processes with process prototypes, and applications with application prototypes.","At , the OS facilitates identification of and communication with application abstraction by other software components.","Exemplary Computing System and Environment",{"@attributes":{"id":"p-0118","num":"0173"},"figref":"FIG. 7","b":["700","700"]},"The exemplary computing environment  is only one example of a computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the computer and network architectures. Neither should the computing environment  be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computing environment .","The exemplary self-describing artifact architecture may be implemented with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers, server computers, thin clients, thick clients, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, personal digital assistants (PDA), appliances, special-purpose electronics (e.g., a DVD player), programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The exemplary self-describing artifact architecture may be described in the general context of processor-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The exemplary self-describing artifact architecture may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","The computing environment  includes a general-purpose computing device in the form of a computer . The components of computer  may include, but are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components, including the processor , to the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include a CardBus, Personal Computer Memory Card International Association (PCMCIA), Accelerated Graphics Port (AGP), Small Computer System Interface (SCSI), Universal Serial Bus (USB), IEEE 1394, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus, also known as a Mezzanine bus.","Computer  typically includes a variety of processor-readable media. Such media may be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media.","The system memory  includes processor-readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  may be connected to the system bus  by one or more interfaces (not shown).","The disk drives and their associated processor-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of processor-readable media, which may store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, may also be utilized to implement the exemplary computing system and environment.","Any number of program modules may be stored on the hard disk  magnetic disk , optical disk , ROM , and\/or RAM , including, by way of example, an operating system , one or more application programs , other program modules , and program data .","A user may enter commands and information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device may also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices may include components, such as speakers (not shown) and a printer , which may be connected to computer  via the input\/output interfaces .","Computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, the remote computing device  may be a personal computer, a portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. The remote computing device  is illustrated as a portable computer that may include many or all of the elements and features described herein, relative to computer .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet. Such networking environments may be wired or wireless.","When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which may be internal or external to computer , may be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  may be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted, relative to the computer  or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of remote computer . For purposes of illustration, application programs and other executable program components, such as the operating system, are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computing device , and are executed by the data processor(s) of the computer.","Processor-Executable Instructions","An implementation of an exemplary self-describing artifact architecture may be described in the general context of processor-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.","Exemplary Operating Environment",{"@attributes":{"id":"p-0136","num":"0191"},"figref":["FIG. 7","FIG. 7"],"b":["700","728","730","726"]},"The operating environment is only an example of a suitable operating environment and is not intended to suggest any limitation as to the scope or use of functionality of the exemplary self-describing artifact architecture(s) described herein. Other well known computing systems, environments, and\/or configurations that are suitable for use include, but are not limited to, personal computers (PCs), server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, wireless phones and equipment, general and special-purpose appliances, application-specific integrated circuits (ASICs), network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","Processor-Readable Media","An implementation of an exemplary self-describing artifact architecture may be stored on or transmitted across some form of processor-readable media. Processor-readable media may be any available media that may be accessed by a computer. By way of example, processor-readable media may comprise, but is not limited to, \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","\u201cComputer storage media\u201d include volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which may be used to store the desired information and which may be accessed by a computer.","\u201cCommunication media\u201d typically embodies processor-readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also includes any information delivery media.","The techniques, described herein, may be implemented in many ways, including (but not limited to) program modules, general- and special-purpose computing systems, network servers and equipment, dedicated electronics and hardware, and as part of one or more computer networks. The techniques, described herein, may be implemented, for example, on a computer system depicted in . More particularly, these techniques may be implemented, for example, by an operating system on a computer system depicted in .","Although the one or more above-described implementations have been described in language specific to structural features and\/or methodological steps, it is to be understood that other implementations may be practiced without the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of one or more implementations."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like elements and features.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
