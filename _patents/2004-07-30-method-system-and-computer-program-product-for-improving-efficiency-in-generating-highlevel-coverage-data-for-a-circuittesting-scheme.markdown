---
title: Method, system and computer program product for improving efficiency in generating high-level coverage data for a circuit-testing scheme
abstract: A method, system and computer program product for generating a coverage model to describe a testing scheme for a simulated system are described. In a preferred embodiment, a simulated system is tested with a testing simulation program. A simple event database is generated with the testing simulation program. Results of a checker analysis from the testing with the testing simulation program are obtained, and coverage data is created from a coverage model configuration file, the simple event database and the results of the checker analysis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07454680&OS=07454680&RS=07454680
owner: International Business Machines Corporation
number: 07454680
owner_city: Armonk
owner_country: US
publication_date: 20040730
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["1. Technical Field","The present invention relates in general to testing and verification and in particular to creating coverage models for testing schemes. Still more particularly, the present invention relates to a system, method and computer program product for improving efficiency in generating coverage data for a circuit testing scheme.","2. Description of the Related Art","With the increasing penetration of processor-based systems into every facet of human activity, demands have increased on the processor and application-specific integrated circuit (ASIC) development and production community to produce systems that are free from design flaws. Circuit products, including microprocessors, digital signal and other special-purpose processors, and ASICs, have become involved in the performance of a vast array of critical functions, and the involvement of microprocessors in the important tasks of daily life has heightened the expectation of error-free and flaw-free design. Whether the impact of errors in design would be measured in human lives or in mere dollars and cents, consumers of circuit products have lost tolerance for results polluted by design errors. Consumers will not tolerate, by way of example, miscalculations on the floor of the stock exchange, in the medical devices that support human life, or in the computers that control their automobiles. All of these activities represent areas where the need for reliable circuit results has risen to a mission-critical concern.","In response to the increasing need for reliable, error free designs, the processor and ASIC design and development community has developed rigorous, if incredibly expensive, methods for testing and verification. Simulation has been a traditional method for verifying such complex designs as processor chips. Since the simulation time for a design grows, in the worst case, as the cube of the number of logic elements, simulation and verification of complex systems is one of the most time-consuming computing tasks today. It is therefore important to use simulation cycles effectively, with the aim that few bugs escape and development time is reduced. One way to increase the simulation effectiveness is to use a simulation coverage tool that helps measure simulation effectiveness and refine the simulation process.","A coverage model defines the basic characteristics of events that constitute the coverage space. Conversely, a coverage space is a collection of all possible events or simulations that can legally occur in hardware. A coverage tool measures how much of a design has been exercised against a chosen coverage model. The operative word is exercised, because a coverage tool does not measure the correctness of a design. Several coverage models are possible for any given design.","Conventional methods for generating coverage data have serious drawbacks. Foremost among them, conventional coverage models depend on reading the input to a testing scheme (in the form of input traces) to determine what portions of the coverage space have been tested. While the input states are relevant, a model based on input states is not sufficiently descriptive of the internal state of hardware under test.","Second, conventional systems for generating coverage models are incredibly labor-intensive. Conventional systems for generating coverage models depend on the time-intensive creation, usually in a programming language, of detailed scripts for each desired coverage model of a given item of simulated hardware. Because system designs change rapidly and coverage models must likewise change rapidly, the investment of time necessary to develop coverage models has prohibited their most effective possible applications.","What is needed is a more efficient method for developing more accurate coverage models.","A method, system and computer program product for generating a coverage model to describe a testing scheme for a simulated system are disclosed. In a preferred embodiment, a simulated system is tested with a testing simulation program. A simple event database is generated with the testing simulation program. Results of a checker analysis from the testing with the testing simulation program are obtained, and coverage data is created from a coverage model configuration file, the simple event database and the results of the checker analysis.","With reference now to figures and in particular with reference to , there is depicted a block diagram of a data processing system equipped with a hardware simulation and testing system, in accordance with a preferred embodiment of the present invention. Data processing system  contains a processing storage unit (e.g., RAM ) and a processor . Data processing system  also includes non-volatile storage  such as a hard disk drive or other direct access storage device. An Input\/Output (I\/O) controller (\u201cI\/O CONTROL\u201d)  provides connectivity to a network  through a wired or wireless link, such as a network cable . I\/O controller  connects to user I\/O devices  such as a keyboard, a display device, a mouse, or a printer through wired or wireless link , such as cables or a radio-frequency connection. System interconnect  connects processor , RAM , storage , and I\/O controller .","Within RAM , data processing system  stores several items of data and instructions while operating in accordance with a preferred embodiment of the present invention. These include: a system configuration file , tracers , input trace files , checkers , testing simulation program , checker results , simple event database , coverage model configuration file , coverage generator , coverage data , coverage database , operating system  and other applications . Tracers , testing simulation program , coverage generator , coverage database  and other applications  interface with processor , RAM , I\/O control , and storage  through operating system . One skilled in the data processing arts will quickly realize that additional components of data processing system  may be added to or substituted for those shown without departing from the scope of the present invention.","Processor  executes instructions from programs, often stored in RAM , in the course of performing the present invention. In a preferred embodiment of the present invention, processor  executes tracers , testing simulation program , coverage generator , coverage database  and other applications , as well as operating system , though not all of tracers , testing simulation program , coverage generator , coverage database  and other applications , as well as operating system  will run simultaneously. Tracers  analyze system configuration file , which contains instructions for modeling specifications of a system topology and system properties of a simulated circuit or system, and generates input trace files , which contain instructions for simulating inputs to the simulated circuit described in system configuration file . The inputs to the simulated circuit or system described in system configuration file  are called input simple events.","Testing simulation program  includes a computer program product, stored in RAM  and executed on processor , which provides a series of tools for behavior-simulation testing. Generally speaking, testing simulation program  contains rule-based instructions for predicting the behavior of logically or mathematically modeled items of hardware and software, described in system configuration file , in response to simple events, described in input trace files . Testing simulation program  uses the series of rules contained in its own instructions, in conjunction with system configuration file , to predict the response of the simulated hardware modeled in system configuration file  to external and internal stimuli contained in input trace files .","Depending on what items of hardware are under test, system configuration file  may model the designs of many different kinds of hardware, but preferably provides a software representation of components such as microprocessors and application specific integrated circuits (ASICs). In the preferred embodiment depicted in , system configuration file  includes a simulated processor.","Testing simulation program  generates simple event database  containing output result trace files, called output simple events, which represent the response of the simulated hardware modeled in system configuration file  to external and internal stimuli contained in input trace files , and data for sorting the output result trace files by associated input simple events and time fields associated with the input simple events.","Testing simulation program  also runs checkers , which are instructions that verify particular events such as the interactions of the simulated hardware described by system configuration file  with external and internal stimuli contained in input trace files . The interactions of the simulated hardware described by system configuration file  with external and internal stimuli contained in input trace files  are verified by comparing output result trace files in simple event database  to expected values. Testing simulation program  then records results verified by checkers  to checker results , a result recording file. Testing simulation program  may also report the contents of checker results  or the status selected indicators of the status of system configuration file  to user I\/O . Additionally, all or part of testing simulation program , operating system , input trace files , system configuration file , and checker results  may, at times, be stored in storage  or in RAM .","Coverage model configuration file  contains rules that specify how to form coverage events from output simple events contained in simple event database . A coverage event refers to a particular condition of the simulated hardware described by system configuration file . A goal of coverage analysis is to describe the coverage of relevant coverage events by the conditions described by the trace files in simple event database .","Coverage model configuration file  contains a coverage model specification, which indicates to coverage generator  the rules for forming complex coverage events from several simple events and specifies the format of the coverage events. In the preferred embodiment, a coverage model specification includes several attributes. An attribute called GLOBAL_EQUAL_FIELDS (GEF)  specifies simple event component attributes of a coverage event, which must have equal values. An attribute called PARTIAL_EQUAL_FIELDS  specifies selected component events, which must have equal values for listed fields. Time criteria are also specified in coverage model configuration file . Simple event components of a coverage event must meet the specified time criteria. An attribute called SEQUENTIAL (S)  specifies a list of simple events, which, when meeting the global criteria previously described, are monitored to determine if one follows the other in an ordered list (ordered by issue time) with no other simple events in between. An attribute called CONCURRENT (C)  specifies a list of simple events, which are monitored to determine if they are outstanding at the same time. A simple event is outstanding if it has issued (IT) and has not yet completed (CT) and performed (PT). An attribute called SEQUENTIAL_OVERLAP (SO)  specifies simple events, which are monitored to determine if they are both SEQUENTIAL and CONCURRENT as defined above.","Simple event restrictions allow the user to specify separate restrictions on each of the simple event components of a coverage event. It is possible to restrict the simple event component by event type (i.e., EVENT_TYPE field) (ET) , by association with a particular device in the system, which is defined in the system config file (i.e., RESTRICTED_FIELD) (RF) , or by results of analysis by a checker (i.e., USER_SELECTION_FIELD) (USF) . USF  allows coverage generator  to test arbitrary attributes associated by the checker with a simple event.","Further coverage event format specifications allow the user specify the format of the coverage event for the current model. For each component definition, the user can indicate which attribute of the simple event should be extracted and appended to the final coverage event string.","As used with respect to the preferred embodiment, a simple event is defined as all of the data associated with a single trace appearing in a simple event database . For example, all the times (IT, PT, CT), data, response, type, and source information for a single READ transaction on a bus would comprise a single simple event. By contrast, a coverage event is defined as an n-tuple of simple events. A single simple event that is a part of some valid coverage event is termed a component event of the coverage event. A coverage string is defined as a concatenation of the string values of various (possibly different) fields from each of the component events of a coverage event.","A coverage model is a specification that describes the number and type of simple events that can comprise a valid coverage event along with instructions detailing how to form a coverage string from a coverage event. Coverage models are defined in coverage model configuration file  and can be created or redefined by the users without the need to recompile any code.","A coverage model as described with respect to the preferred embodiment is one in which all simple event members of a coverage event either occur sequentially (e.g., there is no other valid Event with time between that of adjacent simple events) or concurrently (e.g., all simple events are outstanding at the same cycle) or both.","There are multiple types of attributes that need to be specified to define a coverage model. Component event attributes describe the attributes a simple event in isolation must have to be considered a part of a coverage event for a specific coverage model. An example would be to consider only those bus operations sourced by a device on the system bus as candidates for the first component of a coverage event.","Combinational attributes describe to coverage generator  the relationships component simple events (or a subset of simple events) must have in order to be considered a valid coverage event. For example, only events which reference the same cache line may comprise a valid coverage event. Additionally, coverage generator  must be instructed how to form a valid coverage string from a coverage event. That is, a coverage model must specify which data to extract from each simple event when forming a coverage string. For example, a coverage event can consist of 2 simple events, such as an instruction to form a coverage string by concatenating a sourcing device value of the first simple event, called DEVICE, and an operation type value of the second simple event, called OPERTYPE. Coverage event counts are based on counting the number of different coverage strings rather than counting coverage events.","Coverage generator  then employs checker results , simple event database , and coverage model configuration file  to generate coverage data , which coverage generator  supplies to coverage database  by executing rules contained in coverage model configuration file . Coverage data is generated by coverage generator  according to the rules of a coverage model. Coverage generator  can generate coverage data for one or more of a plurality of models, in response to a plurality of commands that may be present in coverage model configuration file .","Turning now to , a data flow for a process for performing hardware simulation testing and generating coverage data, in accordance with a preferred embodiment of the present invention is depicted. The process begins with step , which depicts the creation of the design data such as system configuration file . The process then moves to step , which illustrates data processing system  running tracers . Tracers  use system configuration file  to create input trace files .","The process then proceeds to step , which depicts creation of a test case or test driver. In the initial case, test case or test drivers are based on system configuration file  and input trace files . The process next proceeds to step , which depicts data processing system  cycling a simulator, such as testing simulation program . Testing simulation program  employs checkers , input trace files  and system configuration file  to simulate the behavior of hardware specified in system configuration file  in response to stimuli represented in input trace files . Testing simulation program  is cycled, in that it is run repeatedly and iteratively.","The process next proceeds to step , which illustrates data processing system  creating output trace files, generated by testing simulation program , in the form of simple event database . The process then moves to step , which depicts operation on data processing system  of coverage generator . The operation of coverage generator  employs checker results , coverage model configuration file  and simple event database .","The process then proceeds to step , which depicts storage of the coverage data  generated by coverage generator . As indicated by return path , steps  through  can be repeated iteratively to collect coverage data  for multiple iterations of testing simulation program . Coverage data , collected over multiple simulation runs, is collectively referred to herein as coverage database .","Following step , he process then moves to step , which depicts performing a coverage analysis. Coverage analysis involves analyzing the coverage model contained in coverage database  to ascertain the strengths and limitations of checkers  and input trace files  in providing meaningful testing by testing simulation program . The process then moves to step , which illustrates forming a new test case or test driver in light of the results of coverage analysis in step . The process then repeats and continues until coverage analysis  indicates that effective coverage for the design has been achieved.","With reference now to , a high level logical flowchart of a process for generating a sequential or sequential-concurrent coverage model in accordance with the preferred embodiment of the present invention is illustrated. The process begins at step , which corresponds to activation of coverage generator . The process next moves to step , which depicts coverage generator  identifying all GEF  attributes listed in coverage model configuration file . The process then proceeds to step , which depicts coverage generator  identifying all possible values for each attribute identified in step . The process next moves to step , which illustrates the coverage generator  creating an ordered simple event list, where for each distinct combination of attribute values identified in step , each event in the list has the same attribute value as the selected combination.","The process then moves to step , which depicts coverage generator  queuing a next simple event list. The process next proceeds to step , which illustrates coverage generator  initializing a linked list of coverage events. The process then moves to step , which depicts coverage generator  traversing the simple event list queued in step . The process next proceeds to step , which depicts coverage generator  queuing the next event in the simple event list designated in step . The process then moves to step , which depicts coverage generator  appending an event to a compound event list.","Next at step , coverage generator  determines whether the compound event size equals the current model size, which model size is the number of simple events in a coverage event for the model under construction. If the compound event size does not equal the current model size, then the process next moves to step , which depicts coverage generator  determining whether the current queued event, (queued in step ) is the last event in the applicable simple event list. If the current simple event is not the last event in the current simple event list, then the process proceeds to step , which depicts coverage generator  queuing the next event in the simple event list.","If in step , coverage generator  determines that the event queued in step  is the last event in the simple event list, the process moves to step . Step  depicts coverage generator  determining whether the current list is the last simple event list. If in step , coverage generator  determines that the current list is not the last simple event list, then the process returns to step , which depicts coverage generator  queuing the next simple event list for processing. If in step , coverage generator  determines that the current list is the last list, then the process ends at step .","If in step , coverage generator  determines that the compound event size equals the model size, then the process moves to step , which depicts coverage generator  determining if every event in the compound event meets the time and component restrictions defined in the coverage model configuration file . If every event in the compound event does not meet the time and component restrictions defined in the coverage model configuration file , then the process moves to step  which depicts coverage generator  removing the front element in the current coverage event list.","The process then moves to step , which is described above. If in step , the current event meets all time and component restrictions defined in coverage model specification, then the process moves to step , which depicts coverage generator  forming a coverage event from components in the compound event using formatting rules from coverage model configuration file . The process then proceeds to step , which is described above.","Turning now to , a high-level logical flowchart of an exemplary process for generating a concurrent coverage model in accordance with the preferred embodiment of the present invention is depicted.","The process begins at step , which corresponds to activation of coverage generator . The process next moves to step , which depicts coverage generator  identifying all GEF  attributes listed in coverage model configuration file . The process then proceeds to step , which depicts coverage generator  identifying all possible values for each attribute identified in step .","The process then moves to step , which illustrates coverage generator  identifying the number of simple events that compose a compound event for the current coverage model, a value hereafter referred to as n. The process then moves to step , which depicts for each distinct combination of attributes, coverage generator  creating simple event lists. Coverage generator  populates each list with events that have the same attribute settings as the current combination and, for each list, inserts only events that are not restricted by the appropriate component list event definition of the coverage model.","The process then moves to step , which depicts queuing the next n-tuple of the simple event list. The process then moves to step , which illustrates coverage generator  determining whether the final simple event list has been processed. If, in step , coverage generator  determines that the final list has been processed, then the process proceeds to step , which depicts the end of the process. If, in step , coverage generator  determines that the final list has not been processed, then the process moves to step , which depicts coverage generator  setting the current time to zero, initializing the model size n, selecting the current set of lists of selected concurrent events based on concurrent attribute settings.","The process next proceeds to step , which illustrates coverage generator  determining whether the current time is greater than all event times in all simple lists. If the current time is greater than all event times in all simple lists, then the process moves to step , which depicts queuing the next n-tuple of simple lists, as described above. If the current time is not greater than all event times and all simple lists, the process moves to step , which depicts advancing the current time to the next time boundary. The next time boundary is defined as the first event in which one of the pair of parameters IT, PT is greater than the current time over all lists in simple event list n-tuple. The process then proceeds to step , which illustrates, for each i, which is an index over all component lists, zero to n-i, coverage generator  inserting all events from the ith simple list that are outstanding at current time into an ith concurrent events list. The process then moves to step , which depicts coverage generator  forming a distinct n-tuple list of events from the ith concurrent events list by taking event i in the n-tuple from the ith list.","The process next proceeds to step , which depicts coverage generator  forming a coverage event from an event tuple, following formatting rules specified in the coverage model definition. The process then proceeds to step , which depicts coverage generator  recording the current coverage event string. The process next proceeds to step , which illustrates coverage generator  determining whether more distinct coverage tuples are possible. If more distinct coverage tuples are possible, the process then moves to step , which is described above. If no more distinct tuples are possible, the process then proceeds to step , which depicts coverage model , querying the concurrent events list. The process next moves to step .","The present invention provides several advantages over prior art solutions for creating coverage models. First, much of the software infrastructure required to create coverage data, which prior art methods required to be generated through time-intensive creation, usually in a programming language, of detailed scripts for each desired coverage model of a given item of simulated hardware, is supplied as a part of the present invention. The reduction of dependence on scripts through a fully integrated coverage modeling tool reduces development and maintenance cost. Second, the computational resources required for both coverage and checking are reduced because files and data structures are shared, rather than needing to be recreated for the separate activities. Additionally, checker data can be used for forming the coverage data, increasing accuracy of the coverage model and increasing flexibility of the coverage model by allowing more types to be created. Finally, with shared input files, the checking and coverage performance work from the same trace data, which results in coverage models that more closely approximate actual coverage performance.","While the invention has been particularly shown as described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. It is also important to note that although the present invention has been described in the context of a fully functional computer system, those skilled in the art will appreciate that the mechanisms of the present invention are capable of being distributed as a program product in a variety of forms, and that the present invention applies equally regardless of the particular type of computer-readable storage media. Examples of computer-readable storage media include recordable type media such as floppy disks or CD ROMs."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed descriptions of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
