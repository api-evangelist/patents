---
title: Generating service component definition language from metadata
abstract: An SCA generator is configured to use data in a Metadata repository to generate files that can be used by an SCA server. The SCA generator includes an instruction analyzing module configured to analyze input instructions and to determine the Metadata repository from the input instructions. The SCA generator also includes a matching module configured to match a service identifier received with the input instructions to service metadata stored in the Metadata repository and a retrieving module configured to retrieve service parameters for the matched service. The SCA generator further includes a tree generating module configured to generate a parser tree based on the retrieved service parameters and an output file generation module configured to recursively walk through the parser tree and to generate target output files. The target output files generated by the output generation module are configured such that the SCA server can access services that have associated service metadata stored in the Metadata repository.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08239419&OS=08239419&RS=08239419
owner: Oracle International Corporation
number: 08239419
owner_city: Redwood Shores
owner_country: US
publication_date: 20090804
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["One embodiment is directed generally to a computer system, and in particular to file generation in a computer system.","Enterprise application servers may implement a service-oriented architecture (\u201cSOA\u201d) and are often utilized by businesses to deliver application services. SOA is a strategy that organizes the discrete functions contained in enterprise applications into interoperable, standards-based services that may be combined and reused to meet business needs. Such application servers may be distributed to handle a large number of transactions and may provide mission-critical systems, including core banking services, airline reservations, brokerage services, e-commerce operations, and telecom services. Tuxedo\u00ae Service Metadata, used by Oracle Tuxedo\u00ae, contains information pertaining to services available in a Tuxedo\u00ae Domain.","In the case of Service Component Architecture (\u201cSCA\u201d), a set of specifications is used that describe a model for building applications and systems using SOA. SCA extends and complements prior approaches to implementing services, builds on open standards such as web services and encourages an SOA organization of business application code based on components that implement business logic. SCA relies on a composite file defined in Service Component Definition Language (\u201cSCDL\u201d) that can describe a service provided by such a component. Tuxedo\u00ae Service Metadata and SCA differ in both philosophy and programming model and data in a Tuxedo\u00ae Metadata Repository typically cannot be used by a SCA server to access services. To access a Tuxedo\u00ae service from a SCA client or to access a SCA component from a Tuxedo\u00ae server typically requires knowledge not only of Tuxedo\u00ae, but also of the SCA framework, with its tedious Extensible Markup Language (\u201cXML\u201d)-based composite and component files.","In an embodiment, an SCA generator is configured to use data in a Metadata repository to generate files that can be used by an SCA server. The SCA generator includes an instruction analyzing module configured to analyze input instructions and to determine the Metadata repository from the input instructions. The SCA generator also includes a matching module configured to match a service identifier received with the input instructions to service metadata stored in the Metadata repository and a retrieving module configured to retrieve service parameters for the matched service. The SCA generator further includes a tree generating module configured to generate a parser tree based on the retrieved service parameters and an output file generation module configured to recursively walk through the parser tree and to generate target output files. The target output files generated by the output generation module are configured so that the SCA server can access services that have associated service metadata stored in the Metadata repository.","In some embodiments, an SCA generator is configured to use data in a Metadata repository to generate files that can be used by an SCA server. The SCA generator generates a parser tree based on service parameters and recursively walks through the parser tree and to generate target output files. The target output files generated by the output generation module are configured so that the SCA server can access services that have associated service metadata stored in the Metadata repository.","In some embodiments, Oracle Services Architecture Leveraging Tuxedo\u00ae (\u201cSALT\u201d) provides a new programming model based on SCA for Tuxedo\u00ae for building applications and solutions. Oracle SALT\u00ae is a standards-based, bidirectional Web-services gateway for Oracle Tuxedo\u00ae supporting enterprise applications written in programming languages including C, C++ and COBOL, among others. Oracle SALT\u00ae allows applications to access existing Tuxedo\u00ae services as standard Web services as well as allowing Tuxedo\u00ae applications to call external Web services with a high-performance, easy-to-use, configuration-driven model. In this context, a service is a business function provided by a component.","In such embodiments, a tool is provided by Tuxedo\u00ae SALT for SCA that allows interfaces and SCDL-based component and composite files to be generated from data gathered through a Tuxedo\u00ae Service Metadata Repository. An SCA component is a configured instance of an implementation and includes the specification of the defined properties, provided services and required service references for the implementation. An SCA composite is an aggregation of components. Using this tool, a developer does not need to learn the SCA framework. The input for the tool may be Tuxedo\u00ae Service Metadata and the output may be various files. The process may be to transform the Tuxedo\u00ae Service Metadata into SCA SCDL files and schema files for XML. In some embodiments, the tool generates header files, composite files, component files, and in some cases, XML Schema Definition (\u201cXSD\u201d) schema for complex data types to help the developer develop an SCA solution for Oracle SALT\u00ae. The tool is capable of performing server-side conversion of service definitions in the Tuxedo\u00ae Service Metadata Repository for a Tuxedo\u00ae server into SCDL and\/or interface files for SCA. The tool is also capable of generating interface and SCDL files that can be used by a client. The generated SCDL composite and component files may also help architects and administrators to deploy a SCA component-based application within a Tuxedo\u00ae Application Domain.","A function of some embodiments of the present invention is to generate appropriate header files and SCA SCDL files in order to ease development tasks. The files are also used by the SCA runtime to locate Application-to-Transaction Monitor Interface (\u201cATMI\u201d) components. ATMI is an Application Programming Interface (\u201cAPI\u201d) that supports the development of transactional applications in the Tuxedo\u00ae environment. Some embodiments of the tool take Tuxedo\u00ae Service Metadata regardless of whether it is stored in a Tuxedo\u00ae Metadata Repository Runtime Service, a Tuxedo\u00ae Service Metadata Repository file or in a Tuxedo\u00ae Service Metadata Repository input file.","In some embodiments, the files that are generated for each service may include a composite file (described with a \u201c.composite\u201d extension herein), a component file (described with a \u201c.componentType\u201d extension herein), an abstract base class header file (used as an interface), and a skeletal implementation class header file. Depending on the complexity of the input arguments, the output buffer type, the error buffer type, and extra XSD schema may also be generated for each service.","Optionally, in some embodiments, a user can specify whether he or she wants to generate a single composite and a single component file with multiple Tuxedo\u00ae services. A combined single abstract base class file and a skeletal implementation class header file can also be generated at the user's discretion. The user further has the ability in some embodiments to choose whether to generate server side or client side SCDL files. By default, the tool may be configured to generate server side SCDL files.","The Generated Composite File","The purpose of the generated composite file in some embodiments is for the SCA runtime to know where the service is located. To accomplish this in the client code, a composite context may be retrieved and used to call a function that locates a service, referred to as \u201clocateService( )\u201d. The SCA runtime may then read the generated composite file. For the purposes of this example, a service called \u201cTOUPPER\u201d that converts lower case characters into upper case characters will be used. The composite file may be as follows:",{"@attributes":{"id":"p-0018","num":"0017"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"]},{"entry":[{},"<composite xmlns=\u201chttp:\/\/www.osoa.org\/xmlns\/sca\/1.0\u201d "]},{"entry":[{},"name=\u201cTOUPPERComposite\u201d>"]},{"entry":[{},"\u2003<service name=\u201cTOUPPER\u201d>"]},{"entry":[{},"\u2003\u2003<interface.cpp header=\u201cTOUPPER.h\u201d\/>"]},{"entry":[{},"\u2003\u2003<binding.atmi requires=\u201clegacy\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<map target=\u201cTOUPPER\u201d>TOUPPER<\/map>"]},{"entry":[{},"\u2003\u2003\u2003<serviceType>RequestResponse<\/serviceType>"]},{"entry":[{},"\u2003\u2003\u2003<inputBufferType"]},{"entry":[{},"\u2003\u2003\u2003target=\u201cTOUPPER\u201d>STRING<\/inputBufferType>"]},{"entry":[{},"\u2003\u2003\u2003<outputBufferType"]},{"entry":[{},"\u2003\u2003\u2003target=\u201cTOUPPER\u201d>STRING<\/outputBufferType>"]},{"entry":[{},"\u2003\u2003<\/binding.atmi>"]},{"entry":[{},"\u2003\u2003<reference>TOUPPERComponent<\/reference>"]},{"entry":[{},"\u2003<\/service>"]},{"entry":[{},"\u2003<component name=\u201cTOUPPERComponent\u201d>"]},{"entry":[{},"\u2003\u2003<implementation.cpp library=\u201cTOUPPER\u201d"]},{"entry":[{},"\u2003\u2003header=\u201cTOUPPERImpl.h\u201d\/>"]},{"entry":[{},"\u2003<\/component>"]},{"entry":[{},"<\/composite>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The above composite TOUPPERComposite contains a component called TOUPPERComponent and a service called \u201cTOUPPER\u201d. The TOUPPERComponent may be implanted in a shared object called TOUPPER.dll for Windows\u00ae and libTOUPPER.so for UNIX. The access methods are described in the header TOUPPERImpl.h.","It is also possible to generate a composite file suitable for client use, such as the following:",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"]},{"entry":[{},"<composite xmlns=\u201chttp:\/\/www.osoa.org\/xmlns\/sca\/1.0\u201d"]},{"entry":[{},"name=\u201cTOUPPERComposite\u201d>"]},{"entry":[{},"\u2003<reference name=\u201cTOUPPER\u201d>"]},{"entry":[{},"\u2003\u2003<interface.cpp header=\u201cTOUPPER.h\u201d\/>"]},{"entry":[{},"\u2003\u2003<binding.atmi requires=\u201clegacy\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<serviceType>RequestResponse<\/serviceType>"]},{"entry":[{},"\u2003\u2003\u2003<inputBufferType"]},{"entry":[{},"\u2003\u2003\u2003target=\u201cTOUPPER\u201d>STRING<\/inputBufferType>"]},{"entry":[{},"\u2003\u2003\u2003<outputBufferType"]},{"entry":[{},"\u2003\u2003\u2003target=\u201cTOUPPER\u201d>STRING<\/outputBufferType>"]},{"entry":[{},"\u2003\u2003<\/binding.atmi>"]},{"entry":[{},"\u2003<\/reference>"]},{"entry":[{},"<\/composite>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Generated ComponentType File","The generated component type file links the name of the implementation class with abstract behavior. The file is named after the implementation class and contains a reference to the abstract class. It may be named TOUPPERImpl.componentType, for example, and may be as follows:",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"]},{"entry":[{},"<componentType xmlns=\u201chttp:\/\/www.osoa.org\/xmlns\/sca\/1.0\u201d>"]},{"entry":[{},"\u2003<service name=\u201cTOUPPER\u201d>"]},{"entry":[{},"\u2003\u2003<interface.cpp header=\u201cTOUPPER.h\u201d\/>"]},{"entry":[{},"\u2003<\/service>"]},{"entry":[{},"<\/componentType>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Generated Abstract Class Header File","The abstract base class represents the Tuxedo\u00ae service that is to be exposed. This may be similar to defining a Java interface. The header file of this abstract class will be used by the client application to understand the available Tuxedo\u00ae service interface. The class may be the same as the file name without an extension. The abstract class header file may be as follows:",{"@attributes":{"id":"p-0027","num":"0026"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#ifndef TOUPPER_h"]},{"entry":[{},"#define TOUPPER_h"]},{"entry":[{},"#include <string>"]},{"entry":[{},"class TOUPPER"]},{"entry":[{},"{"]},{"entry":[{},"public:"]},{"entry":[{},"\u2003\u2003\u2003\u2002virtual std:string TOUPPER(std::string) = 0;"]},{"entry":[{},"}"]},{"entry":[{},"#endif TOUPPER_h"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"While a C++ header is shown above, one of ordinary skill in the art will readily appreciate that the tool may be configured for Java, COBOL, or any other desired programming language.","The Generated Implementation Class Header File","The generated implementation class header file for TOUPPER may be named TOUPPERImpl.h. However, as with all of the files discussed above, the naming convention that is used is by design choice. The implementation class header file may be as follows:",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#ifndef TOUPPERImpl_h"]},{"entry":[{},"#define TOUPPERImpl_h"]},{"entry":[{},"#include \u201cTOUPPER.h\u201d"]},{"entry":[{},"#include <string>"]},{"entry":[{},"class TOUPPERImpl:public TOUPPER"]},{"entry":[{},"{"]},{"entry":[{},"public:"]},{"entry":[{},"\u2003\u2003\u2003\u2002TOUPPERImpl( );"]},{"entry":[{},"\u2003\u2003\u2003\u2002virtual ~TOUPPERImpl( );"]},{"entry":[{},"\u2003\u2003\u2003\u2002virtual std:string TOUPPER(std::string);"]},{"entry":[{},"}"]},{"entry":[{},"#endif TOUPPERImpl_h"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"By default, in some embodiments, each Tuxedo\u00ae service definition in the Tuxedo\u00ae Service Metadata Repository may generate one composite file, one component file, one abstract class header file and one implementation header file, and in some instances, may further generate an XSD schema for complex data types. However, with a large Tuxedo\u00ae Service Metadata Repository, this may not be ideal since a large number of files would be generated. In such a case, the user may specify a single composite file, component file, abstract class header file, and implementation header file separately. The composite file and component file would each contain multiple services.","As noted above, in the case of a complex data type, it may be desirable to generate an XSD schema. For instance, in the following example, ACCOUNTSVC has multiple parameters, ACCOUNT_ID, ACCOUNT_NAME and ACCOUNT_BALANCE. The XSD schema for this service may appear as follows:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<xsd:schema"},{"entry":"\u2009xmsns:xsd=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d"},{"entry":"\u2009xmlns:sdo=\u201ccommonj.sdo\u201d"},{"entry":"\u2009xmlns:sdoxml=\u201ccommonj.sdo\/xml\u201d >"},{"entry":"\u2003<xsd:element name=\u201cin_ACCOUNTSVC\u201d"},{"entry":"\u2003type=\u201cin_ACCOUNTSVCType\u201d\/>"},{"entry":"\u2003<xsd:element name=\u201cout_ACCOUNTSVC\u201d"},{"entry":"\u2003type=\u201cout_ACCOUNTSVCType\u201d\/>"},{"entry":"\u2003<xsd:complexType name=\u201cin_ACCOUNTSVCType\u201d>"},{"entry":"\u2003\u2003<xsd:sequence>"},{"entry":"\u2003\u2003\u2003<xsd:element name=\u201cACCOUNT_ID\u201d type=\u201cxsd:long\u201d\\>"},{"entry":"\u2003\u2003\u2003<xsd:element name=\u201cACCOUNT_NAME\u201d type=\u201cxsd:string\u201d\\>"},{"entry":"\u2003\u2003<\/xsd:sequence>"},{"entry":"\u2003<\/xsd:complexType>"},{"entry":"\u2003<xsd:complexType name=\u201cout_ACCOUNTSVCType\u201d>"},{"entry":"\u2003\u2003<xsd:sequence>"},{"entry":"\u2003\u2003\u2003<xsd:element name=\u201cACCOUNT_BALANCE\u201d"},{"entry":"\u2003\u2003\u2003type=\u201cxsd:float\u201d\\>"},{"entry":"\u2003\u2003\u2003<xsd:element name=\u201cACCOUNT_NAME\u201d type=\u201cxsd:string\u201d\\>"},{"entry":"\u2003\u2003<\/xsd:sequence>"},{"entry":"\u2003<\/xsd:complexType>"},{"entry":"<\/xsd:schema>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A typical flow of development in some embodiments utilizing Tuxedo\u00ae may be as follows:","(1) Define SCDL;","(2) Write implementation and abstract header files;","(3) Write XSD schema(s) for complex data types;","(4) Write program(s) using languages such as C++ and Java;","(5) Compile and link the program(s);","(6) Configure Tuxedo\u00ae; and","(7) Deploy the program(s) and or run client program(s).","In some embodiments, the tool solves (1), (2), (3) and part of (7) for SCA developers. Developers still write business logic in a programming language such as C++ or Java. Compiling and linking in (4) may be performed by a set of sister tools and (5) may also be performed by a companion to the tool using the output files as input. Using some embodiments of the tool, a developer does not need to know how to get deployed by Tuxedo\u00ae, how to communicate with Tuxedo\u00ae services (and vice versa), and how to create\/prepare Tuxedo\u00ae C-style data to be consumed by Tuxedo\u00ae services.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 1","b":["100","100","105","110","105","110","100","115","110","115","100","120","100"]},"Computer readable media may be any available media that can be accessed by processor  and includes both volatile and nonvolatile media, removable and non-removable media, and communication media. Communication media may include computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media.","Processor  is further coupled via bus  to a display , such as a Liquid Crystal Display (\u201cLCD\u201d), for displaying information to a user, such as server status information. A keyboard  and a cursor control device , such as a computer mouse, is further coupled to bus  to enable a user to interface with system .","In one embodiment, memory  stores software modules that provide functionality when executed by processor . The modules include an operating system  that provides operating system functionality for server . The modules further include an SCA generator  that is configured to identify and provide selected secure resources. Server  can be part of a larger system such as a cluster computing system, a distributed computing system, a cloud computing system, a \u201cserver farm\u201d or any other system having multiple servers and\/or computing devices. Server  will typically include one or more additional functional modules  to include additional functionality. In some embodiments, SCA generator  may be part of operating system  or part of one or more other functional modules included in other functional modules .","It should be noted that many of the functional features described in this specification have been presented as modules in order to more particularly emphasize their implementation independence. For example, a module may be implemented as a hardware circuit comprising custom very large scale integration (\u201cVLSI\u201d) circuits or gate arrays, off-the-shelf semiconductors such as logic chips, transistors, or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays, programmable array logic, programmable logic devices or the like.","Modules may also be at least partially implemented in software for execution by various types of processors. An identified unit of executable code in a software module may, for instance, comprise one or more physical or logical blocks of computer instructions which may, for instance, be organized as an object, procedure or function. Nevertheless, the executables of an identified module need not be physically located together, but may comprise disparate instructions stored in different locations that, when joined logically together, comprise the module and achieve the stated purpose for the module. Modules may be stored on a computer-readable medium, which may be, for instance, a hard disk drive, a flash device, random access memory (\u201cRAM\u201d), a tape drive, an optical drive, a compact disk having read-only memory (\u201cCD-ROM\u201d) or a digital video disk having read-only memory (\u201cDVD-ROM\u201d), or any other such medium used to store data. The medium may be read-only or read\/write.","Indeed, a unit of executable code could be a single instruction, or many instructions, and may even be distributed over several different code segments, among different programs, and across several memory devices. Similarly, operational data may be identified and illustrated herein within modules, and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set, or may be distributed over different locations including over different storage devices, and may exist, at least partially, merely as electronic signals on a system or network.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 2","FIG. 2"]},"In some embodiments, the process of  may be performed, for example, by server  of  via SCA generator . In , the process flow begins with SCA generator  being started at . The computer on which SCA generator  is running, such as a server, then awaits instructions from a user at . Such instructions may be command line instructions for generating SCDL files from a metadata repository and may include information such as a target root directory, the service name, the Tuxedo\u00ae client name, the Tuxedo\u00ae user name, the Java package name, the output SCDL file name, the output interface file name, the maximum number of interface arguments and various parameters regarding the types of files to be generated, for instance.","SCA generator  then periodically checks for instructions at . If instructions have not been received, and SCA generator  has not been closed at , SCA generator  continues to await instructions that are input by a user at . If the application has ended, the process ends at . If instructions have been received (the \u201cYES\u201d arrow of ), SCA generator  then proceeds to analyze the instructions at  to determine the Metadata repository that is to be used. Per the above, in Tuxedo\u00ae, the Metadata repository to be used may be a Tuxedo\u00ae Metadata Repository Runtime Service, a Tuxedo\u00ae Service Metadata Repository file or in a Tuxedo\u00ae Service Metadata Repository input file.","Once the Metadata repository is determined, SCA generator  matches a service identifier from the input instructions to service metadata stored in the appropriate metadata repository at  and retrieves parameters for the service at . SCA generator  then builds a parser tree for the service at . In some embodiments, the parser tree may be generated starting with a root directory, followed by a service group, the service and the service parameters.","An example of a parser tree is illustrated in . The tree contains a root node  and there is only a single root node in the parser tree. From the root, service group  , service group   and service group N  are child nodes of root node . Any number of service groups may be included in the tree. Two service definitions, SD   and SD  , are children of service group  . While further details of service group   and service group N  are not shown, there is at least one service definition per service group. Buffer definition  , buffer definition   and buffer definition   are children of SD   and buffer definition   is a child of SD  . In some embodiments, there is at most three buffer definitions per service definition. Parameter definitions Parm. Def.   and Parm. Def.   are children of buffer definition  . Parm. Def.   is a child of buffer definition  and Parm. Def.  is a child of buffer definition . Each buffer definition has at least one parameter definition. While not shown, each parameter definition may have a further associated buffer definition and in some embodiments, there is at most one further buffer definition as a child of a parameter definition. Each further buffer definition has one or more parameter definitions as child nodes. The inclusion of additional buffer nodes and parameter nodes as children\/grandchildren of a parameter may continue in this fashion as many times as is desired.","Once the parser tree is generated, SCA generator  then recursively walks through the parser tree at  and generates the target output files at . Per the above, the target output files may include a composite file, a component file, an abstract class header file, a implementation header file, and at least one XSD schema for complex data types. SCA generator  then once again awaits instructions from the user at .","As disclosed, an embodiment is an SCA generator that is configured to use data in a Metadata repository to generate files that can be used by an SCA server. The generated files are configured such that the SCA server can access services that have associated service metadata stored in the Metadata repository without having any information regarding the architecture of the Metadata repository. Using this tool, a developer does not need to learn the tedious SCA framework. The tool generates header files, composite files, component files, and in some cases, Extensible Markup Language (\u201cXML\u201d) Schema Definition (\u201cXSD\u201d) schema for complex data types to help a developer develop SCA applications interfacing with Tuxedo\u00ae more efficiently than was previously possible. The tool is capable of performing server-side conversion of service definitions in the Tuxedo\u00ae Service Metadata Repository into SCDL and\/or interface files for SCA, as well as generating interface and SCDL files that can be used by a client.","While the term \u201cserver\u201d has been used in the description of some embodiments of the present invention, the invention may be applied to many types of network computing devices. For purposes of this invention, the term \u201cserver\u201d includes rack computing systems, cloud computing systems, distributed computing systems, personal computers, laptops, cell phones, personal digital assistants, tablet computing devices, mainframes, any networked devices that perform computing operations, and any of these physical servers. A server may also be an application server, such as Oracle Tuxedo\u00ae, and may be run as software on a single physical server or distributed across multiple physical servers.","One having ordinary skill in the art will readily understand that the invention as discussed above may be practiced in a different order, and\/or with hardware elements in configurations that are different than those that are disclosed. Therefore, although the invention has been described based upon these preferred embodiments, it would be apparent to, and readily appreciated by, those of ordinary skill in the art that certain modifications, variations, and alternative constructions would be apparent, while remaining within the spirit and scope of the invention. In order to determine the metes and bounds of the invention, therefore, reference should be made to the appended claims.","It should be noted that reference throughout this specification to features, advantages, or similar language does not imply that all of the features and advantages that may be realized with the present invention should be or are in any single embodiment of the invention. Rather, language referring to the features and advantages is understood to mean that a specific feature, advantage, or characteristic described in connection with an embodiment is included in at least one embodiment of the present invention. Thus, discussion of the features and advantages, and similar language, throughout this specification may, but do not necessarily, refer to the same embodiment.","Furthermore, the described features, advantages, and characteristics of the invention may be combined in any suitable manner in one or more embodiments. One skilled in the relevant art will recognize that the invention may be practiced without one or more of the specific features or advantages of a particular embodiment. In other instances, additional features and advantages may be recognized in certain embodiments that may not be present in all embodiments of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order that the embodiments of the invention will be readily understood, a more particular description of the invention briefly described above will be rendered by reference to specific embodiments that are illustrated in the appended drawings. While it should be understood that these drawings illustrate only typical embodiments of the invention and are not therefore to be considered to be limiting of its scope, the invention will be described and explained with additional specificity and detail through the use of the accompanying drawings, in which:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
