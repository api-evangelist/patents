---
title: Methods and systems for generating availability management framework (AMF) configurations
abstract: Techniques for generating a system model for use by and availability management framework (AMF) are described. Inputs are received, processed and mapped into outputs which are further processed into a configuration file in an Information Model Management (IMM) Service eXternal Markup Language (XML) format which can be used as a system model by an AMF.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08006130&OS=08006130&RS=08006130
owner: Telefonaktiebolaget L M Ericsson (Publ)
number: 08006130
owner_city: Stockholm
owner_country: SE
publication_date: 20080930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 11\/961,849, filed on Dec. 20, 2007, and entitled \u201cMethods and Systems for Generating Availability Management Framework (AMF) Configurations\u201d, the disclosure of which is expressly incorporated here by reference. This application is also related to, and claims priority from, U.S. Provisional Patent Application Ser. No. 61\/085,583, filed on Aug. 1, 2008, entitled \u201cAutomatic Generation of AMF Compliant Configuration Top-Down Approach\u201d, the disclosure of which is also expressly incorporated here by reference.","The present invention generally relates to high availability (HA) systems (hardware and software) and, more particularly, to HA systems managed by an Availability Management Framework (AMF).","High availability systems (also known as HA systems) are systems that are implemented primarily for the purpose of improving the availability of services which the systems provide. Availability can be expressed as a percentage of time during which a system or service is \u201cup\u201d. For example, a system designed for 99.999% availability (so called \u201cfive nines\u201d availability) refers to a system or service which has a downtime of only about 0.44 minutes\/month or 5.26 minutes\/year.","High availability systems provide for a designed level of availability by employing redundant nodes, which are used to provide service when system components fail. For example, if a server running a particular application crashes, an HA system will detect the crash and restart the application on another, redundant node. Various redundancy models can be used in HA systems. For example, an N+1 redundancy model provides a single extra node (associated with a number of primary nodes) that is brought online to take over the role of a node which has failed. However, in situations where a single HA system is managing many services, a single dedicated node for handling failures may not provide sufficient redundancy. In such situations, an N+M redundancy model, for example, can be used wherein more than one (M) standby nodes are included and available.","As HA systems become more commonplace for the support of important services such as file sharing, internet customer portals, databases and the like, it has become desirable to provide standardized models and methodologies for the design of such systems. For example, the Service Availability Forum (SAF) has standardized application programming interfaces (APIs) to aid in the development of portable, highly available applications. As shown in the conceptual architecture stack of , the AIS  is intended to provide a standardized interface for the HA middleware  to support HA applications . As described below, each set of AIS functionality is associated with an operating system  and a hardware platform . The reader interested in more information relating to the AIS standard specification is referred to Application Interface Specifications (AIS), Release 5, which is available at www.saforum.org, the disclosure of which is incorporated here by reference.","Of particular interest for the present application is the Availability Management Framework (AMF), which is a software entity defined within the AIS specification. According to the AIS specification, the AMF is a standardized mechanism for providing service availability by coordinating redundant resources within a cluster to deliver a system with no single point of failure. The AMF provides a set of application program interface (API) functions which are used, among other things, to set the states of components within a cluster and to determine the health of those components. The components are also provided with the capability to query the AMF for information about their state. An application which is developed using the AMF APIs and following the AMF system model leaves the burden of managing the availability of its services to the AMF. Thus, such an application does not need to deal with dynamic reconfiguration issues related to component failures, maintenance, etc.","The AIS standard also defines the information model (IM) for applications to be controlled by AMF. According to this IM, a service unit (SU) as a logical entity that aggregates a set of components, thereby combining their individual functionalities to provide a higher level service. A service unit can contain any number of components, but a particular component can be configured in only one service unit. Since each component is always enclosed in a service unit, from the AMF's perspective, the service unit can be considered the incremental unit of redundancy in the sense that it is the smallest logical entity that can be organized into groups in a redundant manner to provide and protect the service instances.","A service group (SG) is defined within the AMF information model as a logical entity that groups one or more SUs in order to provide service availability for a particular set of service instances according to a particular redundancy model. The AMF information model also defines an application as being a logical entity that contains one or more SGs. An application combines the individual functionalities of the constituent service groups to provide a higher level of service. From a software administration point of view, this grouping into an application reflects the set of SUs and contained components that are delivered as a consistent set of software packages to the AMF environment. Within this environment, by introducing the software management framework (SMF), the AMF information model was extended with types that allow the characterization of software developed for SAF systems, e.g., software which is used to provide HA services managed by the AMF.","This software can typically be deployed in different configurations depending on, for example, the characteristics of the system it is deployed on, the number of nodes and their characteristics, the capabilities of the AMF implementation and the requirements put on the provided services. Thus, a software vendor can describe their software such that it would allow for the widest possible usage by describing various AMF related characteristics of the software. Based on this a system integrator has to produce a particular configuration for the system the software is deployed on. However, none of the current SAF specifications define how to generate the information model, i.e., the configuration to be used by an AMF implementation in a particular system for a particular application. Therefore, one option for creating an information model would be to create it manually. Considering the potential for an AMF configuration file to have hundreds if not thousands of lines of code to be properly defined, creating a configuration file in a manual manner will be time consuming and prone to errors.","Accordingly, it would be desirable to provide systems and methods automating the generation of configurations for an AMF system or process.","Systems and methods according to the present invention address this need and others by automating the generation of configurations for an AMF system or process.","According to an exemplary embodiment, a method for generating a configuration for an Availability Management Framework (AMF) includes the steps of selecting entity types from an entity types file which can provide a set of service instances by first evaluating entity types associated with an application type in the entity types file, generating entities associated with the selected entity types; and distributing at least some of the generated entities on nodes of a cluster.","According to another exemplary embodiment, a system includes a processor for generating a configuration for an Availability Management Framework (AMF), including performing the functions of: selecting entity types from an entity types file which can provide a set of service instances by first evaluating entity types associated with an application type in the entity types file, generating entities associated with the selected entity types; and distributing at least some of the generated entities on nodes of a cluster.","According to another exemplary embodiment a computer-readable medium contains instructions stored thereon which, when executed by a computer or a processor, perform the steps of: selecting entity types from an entity types file which can provide a set of service instances by first evaluating entity types associated with an application type in the entity types file, generating entities associated with the selected entity types; and distributing at least some of the generated entities on nodes of a cluster.","The following description of the exemplary embodiments of the present invention refers to the accompanying drawings. The same reference numbers in different drawings identify the same or similar elements. The following detailed description does not limit the invention instead, the scope of the invention is defined by the appended claims.","To provide some additional context for this discussion, consider an exemplary Availability Management Framework (AMF) controlled High Availability (HA) system as shown in . Therein, four nodes (A, B, C and D) are associated with two service groups (SG and SG). A service group is a group of service units (SUs) which provide service availability for one or more service instances (SIs) of particular services. For example, SG includes SU and SU which, in this example, support an instance of an e-mail service (hardware and software) and SG includes SU, SU and SU, which support two instances of a fax service (hardware and software). At runtime, for the email service instance SIA supported by SG, AMF  may select to assign SU the active state and SU the standby state.","Each of the exemplary service units in SG has two components associated therewith. A component is the smallest logical entity on which the AMF  performs error detection and isolation, recovery, and repair. Thus, a component typically includes all of the functions which cannot be clearly separated for error containment or isolation purposes. The component is also the logical entity that a portion of a workload is assigned within the provisioning of a service instance, e.g. the email service. Such a portion of the workload is called a component service instance (CSI). The email service instance SI A is composed of two component service instances CSI A and CSI A. Each of these can be assigned to a component within a service unit. Components can further be grouped into protection groups which reflect the redundancy associated with provisioning of the component service instances. For example, components C and C can form a first protection group for CSI A and components C and C can form a second protection group for CSI A, both of which are associated with the email service instance SI A. Thus if component C fails while being assigned active for CSI A and C assigned as standby, the AMF  could fail over CSI A to component C the active state and, similarly, if component C fails while being active for CSI A, then the AMF  could fail over CSI A to component C the active state. At the time of the fail over of CSI A, AMF  will switch over or will fail over CSI A as well so the entire service unit SU becomes assigned active for the entire service instance SI A.","Service group SG illustrates a slightly different configuration wherein two instances of a fax service are supported by three service units SU, SU and SU. For example, SU and SU could each be assigned by AMF  the active state such that each supports one instance of the fax service, while SU could be assigned the standby state and operate as their redundant backup. In this case, components C and C would form one protection group associated with one of the two fax service instances SI B and within that protect component service instance CSI B. Components C and C could form a second protection group to protect CSI C associated with the other SI C of the two fax service instances.","In the above described examples, service groups, service units and components can all considered to be logical entities associated with physical entities that perform work. These logical entities are assigned workloads in order to render the service, e.g., email or fax service. A component service instance (CSI) represents the workload that the AMF  can dynamically assign to a single component. Component service instances are grouped into a logical entity called a service instance (SI). A service instance aggregates all component service instances to be assigned to the individual components of the service unit in order for the service unit to provide that particular service instance, e.g., email or fax service. A service instance represents a single workload assigned to the entire service unit. As shown in , service instances are shown as well as their relationship with the components, service units and service groups on the four nodes. More specifically, for SIA , SU is assigned the active HA state and SU is assigned the standby HA state (as shown by the dashed connecting line). For SIA , two CSIs (A and A) are assigned to components C and C, and to C and C, respectively. Regarding SIB , SU is assigned the active HA state and SU is assigned the standby state (as shown by the dashed connecting line). Similar comments apply towards SIC .","For an AMF software entity  to operate in the above described exemplary manner, the AMF software entity  needs to receive from a configuration repository  an input, file or system model which describes what is to be managed. In a Service Availability Forum (SAF) cluster the Information Model Management Service (IMM) typically serves as the configuration repository . According to one exemplary embodiment, such configuration information can take the form of an XML (eXternal Markup Language) file, however it will be appreciated that the particular form or format of the configuration input is not critical. According to exemplary embodiments, a high level method for generating the configuration input an AMF application will now be described with respect to ). Initially an AMF Configuration Generator  receives inputs of entity types , e.g., as entity types files (ETFs) and services set\/user input  to perform a mapping function which creates a system model for future use. This system model is output by the AMF Configuration Generator  in the form, for example, an XML file according to the SAF Information Model Management (IMM) Service XML schema . This output code in an IMM XML file  is then stored in the configuration repository  in step . These various inputs and steps will be described in more detail below.","The first exemplary input is entity types  which describe, for example, various AMF related characteristics associated with application software to be controlled by the AMF system. These entity types  are AMF entity types described in XML entity types files, as described by the SAF Software Management Framework (SMF) specification SAI-AIS-SMF-A.01.01 which is available at www.saforum.org, the disclosure of which is incorporated here by reference. From the SAF specifications, there are currently two mandatory AMF entity types that need to accompany any application software intended for such systems. These two entity types are the component types (CompType) and their respective component service types (CST). Other entity types may also be provided as inputs , however, they do not have to be present in an entity types file if the software implementation has no restrictions related to them.","The second exemplary type of input is the services set\/user input . The services set\/user input  typically includes information related to the services the site provides for which the AMF configuration is being created. In the AMF environment the services set\/user input  is a set of service instances in which each service instance is described by a set of component service instances as well as other desired user inputs, e.g., a number of nodes provided with the system providing the service or services and the desired redundancy model to protect them. The services set\/user input  is typically site specific. This exemplary method involves using SI templates each of which describe a set of SIs that shall be protected by SGs of the same type. Within each SI template the CSIs are also defined via CSI templates. The SI templates are typically based on the service types (SvcType) provided as service set\/user input  or by the entity types files. The service type determines the composing CS types (CST) and any limits for the number of component service instances that an SI of the service type may contain. Accordingly, the CSI templates are based on the CS types provided with the software and the user input needs to indicate which CS types are used from these and how many instances of them are desired for the composition of an SI of the particular SI template. An SI template also defines the number of SIs to be configured based on this template and their grouping to SGs. Additionally, the desired redundancy model is typically input by a user and included in the SI template. Another input typically received by the AMF Configuration Generator  from the services set\/user input  is the number of nodes. The number of nodes input is used to assign the service units of the configuration to nodes according to different criteria (e.g. implement hardware redundancy, load balancing among cluster nodes, etc.) if necessary. This information may be provided as a user input to the AMF Configuration Generator , or collected from the target system by other SAF services.","These exemplary input entity types  and services set\/user input  are received at the AMF Configuration Generator  where the inputs are processed to generate a system model for a specific AMF configuration. A general discussion of the configuration generation will now be provided followed by a detailed (but purely exemplary) pseudo-code implementation. References to the pseudo code implementation are priced in the text below in parentheses.","Initially the exemplary configuration generation method (generateConf method) begins by matching each received SI template with the entity types  provided. A suitable SU type is selected from among those in the received input set (findSUType method). This selection method checks the SU types for the capability of providing the desired service type that the SI template refers to. If there are such SU types available, then one is selected by matching the capabilities of the component types of the SU type for each of the component service types with the capabilities required for providing the specified component service type by the CSI templates (findCompType method) in the required redundancy mode required by the enclosing SI template. According to one exemplary embodiment, the selection method finds the SU type(s) that provide the CSI(s) with the minimum number of components, i.e., the selection criterion results in maximizing the utilization of each component in the configuration. However, other selection criterion can be used as desired.","For the case where the selection criterion results in no SU types found that provide the desired composition of CSIs, this exemplary configuration generator  can determine whether the available component types can be grouped in another manner to construct a new, desired SU type. This can occur as part of the findSUType and findCompType pseudo-code functions described below, i.e., the findCompType method adds an appropriate component type from the complete set of component types to the newly constructed SU type for each set of CSIs that needs to be protected. This determination as to whether new SU types may be constructed is typically based upon a user input, e.g., a yes or no input regarding whether the AMF Configuration Generator  is permitted to perform new SU type construction. If a no is submitted then only the submitted types will be used. If a yes is submitted, then the submitted SU types will preferably be used, however, if the submitted SU types are found to be insufficient, the AMF Configuration Generator  will have the option to attempt to create an appropriate SU type. Once an SU type is found or constructed, this exemplary method chooses an appropriate SG type from the available set of SG types based on the features defined by the user for the desired redundancy model in the SI template. If no such appropriate SG type is available, a new SG type is created using input parameters found within the SI template.","Upon completion of finding the appropriate entity types, the AMF Configuration Generator  generates the entities, i.e., instances of these types (generateConf method) that can provide the desired services (createSis method). The configuration is populated so that both the active and the standby assignments of each SI protected by each SG can be satisfied. This is done by creating one SU with the required number of components so that the SU provides the required active and standby capabilities for all of the SIs as necessary and within them for all CSIs. Once all of the components of the first SU have been added, other SUs required by the redundancy model are copied from this first SU as desired for the HA environment to create a first SG. This procedure is then repeated for each SG necessary to protect all the service instances generated from an SI template in the configuration that is currently being created. Additionally, one exemplary method for creating this configuration uses equal ranking and equal load between all SUs. Alternatively, other exemplary methods can be used.","For example according to one exemplary embodiment, instead of using equal ranking and load, different ranks can be assigned to the different SUs within an SG. A global rank can be assigned as well as a per SI rank. If only the global rank is specified then for SIs this is the rank that would be used. According to another exemplary embodiment, other factors can be used in assigning rank such as, for example, SI load based upon different resource needs, e.g., a database application would be storage\/memory intensive. Also a collaboration of different applications, or the opposite, could be considered. According to one exemplary embodiment, populating this configuration can be complemented by using a method that generates, based on the previously generated SI and CSI templates, all (or a desired portion) of the SI and CSIs respective attributes.","The exemplary processing described above with respect to the AMF Configuration Generator  will now be summarized as shown in the exemplary flowchart of ). Initially, each received SI template is matched with the received entity types  in step . Matching also occurs in the follow on steps as needed. Processing then continues by finding a component type by selecting the component type within an SU type or among all component types (provided it is permitted to construct a new SU type) such that the component type provides a highest utilization for a specified redundancy model in step . Calculating required active capabilities for an SU type within an SG with respect to an SI template, wherein an SU of the SU type provides a group of SIs from a single template occurs in step . Similarly, calculating required standby capabilities for an SU type with respect to an SI template, wherein an SU of the SU type protects a group of SIs from a single template occurs in step . The Configuration Generator  then searches for a first SU type that can provide SIs based on one of the templates in step . This leads to searching for a first SG type that can provide SIs using a requested. SU type according to a specified redundancy model in step . Once the necessary entity types have been identified the configuration generation proceeds with populating the configuration with the entities of these types. This begins with generating all of the SIs and their respective CSIs to be protected by an SG based upon the templates in step . A first SU is created for the SG and then others are copied to create the complete SG. A next set of SIs and CSIs can then be generated for the next SG. If the SIs belong to the same SI template, the SG is just copied, until all the SIs required by the template have been assigned to an SG. For the next SI template the process can be repeated starting with the creation of a first SU. The process ends when all the SGs have been created for all SI templates.","The configuration, e.g., a file, generated by this exemplary process can, for example, be in an IMM XML format for use by an AMF via IMM. As mentioned above, the elements of this configuration can be generated by a type matching process which loops on the SI templates: for each SI template the SG type, the SU type and the component types are selected. Exemplary pseudocode illustrating this process in more detail is provided below. For the instance generation described above, there are additional loops as multiple entities are created for each selected type. The configuration, e.g., IMM XML, contains both the entity types and all the generated entities. During configuration generation, SUs can be assigned to nodes by setting the appropriate attributes. This is an optional attribute, so the AMF can use this attribute when it is provided, otherwise the AMF distributes the SUs in an implementation specific way. Note also that it may not always be desirable to assign an SU to a node, e.g., when the SU is assigned to a node it cannot be instantiated by AMF anywhere else, in which case, if the node is faulty, that SU would be lost with the node. If no node is specified AMF will pick a node from among those available.","Using the above described exemplary embodiments, the AMF Configuration Generator  generates a configuration which becomes an output of code in, for example, an IMM XML file . This output of an IMM XML file  is preferably provided in an acceptable format for use by an AMF system as described in, for example, SAF Information Model Management (IMM) specification SAI-AIS-IMM-A.02.01. This exemplary code is then stored in a Configuration Repository  (or other desirable computer readable medium or memory storage unit) in step  for future use by an AMF.","An additional process that occurs at the end of the exemplary generation of an AMF configuration is the method for distribution of the SUs on the cluster nodes. The AMF specification does not currently describe performance characteristics for entities, therefore an exemplary method for distribution of SUs can assume that each SU of the configuration produces equal workloads with respect to each other and with or without assignment. It is at this point that the number of nodes to be used needs to be known by the system as either a received user input or by the system knowing what is available, e.g., information provided by another SAF service. Based on this assumption, this exemplary method distributes the SUs among the nodes of the cluster by selecting for each SU the node that has the smallest load and that has no (or the fewest number of) SUs of the same SG that the current SU belongs to. These conditions can be provided by using a global round robin distribution of the SUs as the SUs are being created during the configuration process. Alternatively, this exemplary distribution method can be modified by assuming, based on performance characteristics of the system, different capacities for the different nodes and different load for the different SUs. Also, another exemplary alternative embodiment for configuration could be based upon the assumption of different failure scenarios desiring to avoid or minimize overload situations when one or more SUs\/nodes fail in the system.","To further illustrate the above described exemplary embodiments for generating an AMF configuration, a purely illustrative exemplary embodiment will now be described with respect to . In this exemplary system, the goal is to support file transfer protocol (FTP) services, simple mail transfer protocol (SMTP) services and hyper text transfer protocol (HTTP) services in an HA environment by creating a configuration file for use by an AMF to manage these services in an HA environment. For the input entity types  there are both component types and component service types. As can be seen in , there are two component types labeled CompType A  named Surge FTP and CompType B  named Apache. CompType A  can provide up to three active or six standby assignments for CST A  for FTP and, CompType A  can also provide up to one active or one standby assignments for CST B  for SMTP. Regarding CompType B , it is capable of providing up to three active and six standby assignments for CST C  for HTTP.","These various CSTs can have a number of different attributes associated with them as shown in . For example, CST A  for FTP is shown with two attributes  and  associated therewith. Attribute  could, for example, deal with IP ranges and attribute  could, for example, be associated with security levels. More or fewer attributes can be associated with a CST (as well as the other CSTs) as shown by CST B  for SMTP having three attributes and CST C  having just one attribute. These attributes associated with the CSTs are typically submitted as part of the input entity types  as they are determined by the way the software is implemented.","CSTs are also associated with service types. For example, as shown in , two service types are shown, SvcType A  representing the file transfers and email service and SvcType B  which represents the web page display service. Accordingly, SvcType A  is associated with CST. B  and CST A  representing the FTP and SMTP component service types. SvcType B is solely associated with CST C , with HTTP. These service types can be submitted as either entity types inputs  or as part of the services set\/user input . This then leads to the various templates submitted as part of the services set\/user input .","According to exemplary embodiments, the services set\/user input  includes templates. Continuing with the current example, SI templates, CSI templates and a node template are illustrated in . An SI template  includes the following: a name, e.g., SI-temp-a ; a redundancy model, e.g., N+M ; a service type, e.g., File Transfer and Mail ; the preferred number of active and standby assignments per SI, e.g., 1 Active+1 Standby ; the values for N and M SUs as appropriate for the redundancy model, e.g., 3+1 SUs ; and the desired number of SIs, e.g., 3 SIs. Associated with each SI template  are one or more CSI Templates  and . CSI template  includes a name, e.g., CSI-temp-A , a CST, e.g., FTP , and the number of CSIs in this case one . The other template is a node template  which includes a name  and the number of nodes  in the cluster. They are to be used for the distribution of the generated service units.","At some point after filling in the desired templates, these desired templates as well as the entity types  are processed by the AMF Configuration Generator . For example, as shown in , SI template  is being processed by the AMF Configuration Generator . Using the received inputs as well as other known information, such as specified constraints for an AMF, outputs are generated by the AMF Configuration Generator . In this case, populated SIs ,  and  are generated. Additionally, in this example, a first SU  is created of a (new) SU type to meet the desired needs associated with the SIs (,  and ) of the SI template . A new SU type was created if there was no acceptable available SU type and the orphan types allowed for the creation of new SU type as needed. Also, the Configuration Generator  determined that the best CompType for CST A and CST B is CompType A which allows the SU  to only use three components to support each of the SIs ,  and , which have three CSIs associated with them. To meet another need as specified by the SI template , e.g., the provision of three active SUs and one standby SU , four SUs are created and deployed as shown in  as part of the new SG .","According to exemplary embodiments, illustrative pseudo-code used for generating an AMF configuration is shown below. This illustrative pseudo-code is broken down into three sections: Inputs, Outputs and Configuration Generation, for ease of understanding. The Inputs section of pseudo-code corresponds to the various inputs that may be received by the AMF Configuration Generator . Some of them are mandatory (e.g. component type, component service type, SI templates), others may be generated by the configuration generator (e.g. SU type). The Outputs are building blocks of the final configuration created from the Inputs by the Configuration Generation. The Outputs together with some of the Inputs presented to an AMF implementation via IMM in an XML file providing this way the complete AMF information model.","Inputs","The first group of inputs described are from the entity types  subset. A component service type is a set as described by\n\n",{"@attributes":{"id":"p-0058","num":"0060"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"compCap","mo":"=","mrow":{"mo":"{","mrow":{"mrow":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["x_active","_and","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]}}},{"mtd":{"mrow":{"mi":["x_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]}}},{"mtd":{"mrow":{"mi":["l_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]}}},{"mtd":{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mi":["_active","_or","_l","_standby"]}}},{"mtd":{"mi":"x_active"}},{"mtd":{"mi":"l_active"}}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mi":"maxAct"},{"mo":"{","mrow":{"mrow":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_and","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"x"},{"mi":"x","mo":"\u2265","mn":"1"}],"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"x"},{"mi":"x","mo":"\u2265","mn":"2"}],"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["l_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mi":["l_active","_or","_l","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":[{"mi":["x_active","x"],"mo":"\u21d2"},{"mi":"x","mo":"\u2265","mn":"2"}],"mo":","}}},{"mtd":{"mrow":{"mi":"l_active","mo":"\u21d2","mn":"1"}}}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mi":"maxStdb"},{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_and","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"1"}],"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"1"}],"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["l_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"2"}],"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":["l_active","_or","_l","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mi":"x_active","mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mi":"l_active","mo":"\u21d2","mn":"0"}}}]}}],"mo":"="}}],"mo":"="}}}}},"br":{},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["ct={csCapability; 0<=i<|ct|, all the component service (CS) types provided by the component type ct}\n\nAll component types compose the set as described by\n","CT={ct; 0<=i<|CT|}."]}},"A second type of inputs may belong either to the entity types  or to the services set\/user input  subset.","A member CS type is a tuple as described by",{"@attributes":{"id":"p-0060","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["memCst=<cst, maxCsi>, where cst \u03b5 CST;\n\nmaxCsi is the number of CSIs of type cst that a service instance of a particular type may contain.\n\nA service type is a set\n","st={memCst; 0<=i<|st| component service instances that compose the service type st}.\n\nAll the service types compose the set\n","ST={st; 0<=i<|ST|}."]}},"A third type of inputs may belong either to the entity types  or to the services set\/user input  subset or completely omitted as an input. In this latter case the configuration generation is creating these types.","Service Unit Types","The services of a service unit type is a set as described by sutServices={st; 0<=i<|sutServices|, all the service types the service unit provides and it is a subset of ST}.","A member component type is a tuple",{"@attributes":{"id":"p-0062","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["memCt=<ct, maxComp>where ct \u03b5 CT;\n\nmaxComp is the maximum number of instances of this component type an SU of this type may contain.\n\nThe component types of an SU type is a set\n","sutCt={memCt; 0<=i<|sutCt|, all the component types the service unit may contain and |sutCt|<=|CT|}.\n\nA service unit type is a tuple\n","sut=<sutCt, sutServices>\n\nAll the service unit type compose the set\n","SUT={sut; 0<=i<|SUT|}\n\nThis set may be empty (SUT={ }) at the beginning of the configuration generation.\n\nService Group Types\n"]}},"The service unit types of a service group type is a set as described by sgtSut={sut; 0<=i<|sgtSut|, all the service unit types the service group may contain and it is a subset of SUT}","A service group type is a tuple",{"@attributes":{"id":"p-0064","num":"0000"},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":"sgt=<sgtSut, redMod>, where"}},{"@attributes":{"id":"p-0065","num":"0074"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"redMod","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"n"}}},{"mtd":{"mi":"nplusm"}},{"mtd":{"mi":"nway"}},{"mtd":{"mi":"nwayactive"}},{"mtd":{"mi":"noredundancy"}}]}}}}},"br":{},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":"SGT={sgt; 0<=i<|SGT|}\n\nThis set may be empty (SGT={ }) at the beginning of the configuration generation.\n"}},"A fourth type of inputs is the services set\/user input  which, as described according to exemplary embodiments above, includes Service Instance templates for the service instances and Component Service Instance templates for their component service instances that need to be protected by Service Groups. Pseudo-code for a variety of services set\/user input  is shown below.","CSI Templates","A CSI template is a tuple",{"@attributes":{"id":"p-0067","num":"0000"},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":["csiTemp=<cst, numCsi>, where cst \u03b5 CST;\n\nnumCsi is the number of CSIs of type cst created based on this template.\n\nAll CSI templates compose the set\n","CSIT={csiTemp; 0<=i<|CSIT|}.\n\nSI Templates\n\nA SI template is a tuple\n","siTemp=<st, sicsTemps, redMod, numSIs, numAct, numStdb, numSUs>,\n\nwhere\n","st \u03b5 ST;","sicsiTemps={csiTemp; 0<=i<|sicsiTemps| \u2200csiTemp.cst\u2261st.cst and csiTemp.numCsi\u2266st.maxCsi};\n\nnumSIs is the number of SI that is created using this template\n"]}},{"@attributes":{"id":"p-0068","num":"0082"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"numAct","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2260"},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mi":"x","mo":";","mrow":{"mi":"x","mo":"\u2265","mn":"2"}},"mo":","}}}]}}}}},"br":{}},{"@attributes":{"id":"p-0069","num":"0083"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"numStdb","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["redMod","nway"],"mo":"\u2261"},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"1"}],"mo":";"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mn":"1","mo":","}}}]}}}}},"br":{},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":"numSUs=<sus, susAct, susStdb, susSpare>, where\n\nsus the total number of SUs in the SG protecting the SIs generated from this template; sus>=susAct+susStdb+susSpare;\n"}},{"@attributes":{"id":"p-0070","num":"0085"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"numAct","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["redMod","nplusm"],"mo":"\u2261"},"mo":"\u21d2","mi":"z"}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mi":"z"},{"mi":"z","mo":">","mn":"1"}],"mo":";"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mi":"numSIs"}}},{"mtd":{"mrow":{"mrow":{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":"\u2062","mi":"n"}},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["redMod","nway"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"},"mo":","}}}]}}}}},"br":{}},{"@attributes":{"id":"p-0071","num":"0086"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["susStbd","numStdb"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["redMod","nplusm"],"mo":"\u2261"},"mo":"\u21d2","mi":"w"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":"\u2062","mi":"n"}},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nway"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}}]}}],"mo":"="}}},"br":[{},{},{}],"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":"SIT={siTemp; 0<=i<|SIT|}."}},"The final type of input is the number of nodes. Number of nodes can be an optional separate input, or defined elsewhere, e.g., read from the system for which the configuration is being generated. The number of nodes can be described using pseudo-code as a node template as follows. Each node template characterizes a distinct set of nodes that share characteristics. Currently only one template is used that represents all the nodes of the cluster.","The node template is a tuple",{"@attributes":{"id":"p-0073","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["nodeTemp=<numNodes>, where\n\nnumNodes is the number of nodes created based on the template.\n\nAll node templates compose the set\n","NodeTemp={nodeTemp; 0<=i<|NodeTemp|}."]}},"Outputs are a result of processing by the AMF Configuration Generator  to be used in the final configuration file. The pseudo-code used to describe and generate these Outputs is described below.","Outputs","Components","A component has a name and belongs to component type. It is a tuple coop=<safComp, ct>, where ct \u03b5 CT;",{"@attributes":{"id":"p-0075","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":["safComp is a tuple safComp=<safSu, rdn>, where\n\nsafSu is a SAF compliant LDAP distinguished name of the SU the component belongs to and\n\nrdn is a relative distinguished name of the component, which is unique within the SU.\n\nService Units\n\nA service unit is a tuple\n","su=<safSu, sut, memComps>, where","safSu is a tuple safSu=<safSg, rdn>, where\n\nsafSg is a SAF compliant LDAP distinguished name of the SG the service unit belongs to and\n\nrdn is a relative distinguished name of the SU which is unique within the SG; sut \u03b5 SUT;\n","memComps={memComp; 0<=i<|memComps|, \u2200memComp.safComp.safSu\u2261safSu;}\n\nmemComp={ } at the start of the configuration generation.\n\nService Groups\n\nA service group is a tuple\n","sg=<safSg, sgt, memSus, nodeGroup>, where","safSg is a tuple safSg=<safApp, rdn>, where\n\nsafApp is a SAF compliant LDAP distinguished name of the application the service group belongs to, and\n\nrdn is a relative distinguished name of the SG, which is unique within the application; sgt \u03b5 SGT;\n","memSus={memSu; 0<=i<|memSus|, memSu.sut \u03b5 sgt.sgtSut and \u2200 memSu.safSu.safSg\u2261safSg;}","memSUs={ } at the start of the configuration generation","nodeGroup={node; 0<=i<|nodeGroup|,}; the nodeGroup  Cluster on which the SG is distributed.\n\nComponent Service Instances\n\nA component service instance is a tuple\n","csi=<safCsi, cst, attrValues>, where","safCsi is a tuple safCsi=<safSi, rdn>, where\n\nsafSi is a SAF compliant LDAP distinguished name of the service instance the component service instance belongs to, and\n\nrdn is a relative distinguished name of the CSI, which is unique within the service instance;\n\ncst \u03b5 CST;\n","attrValues={attrValue; 0<=i<|cst|}","attrValue=<attr, value>, where","\u2200attrValue.attr \u03b5 cst.attr;\n\nattrValue.value is a value set for the attribute\n","attrValues={ } the method does not currently include the generation of attribute values.\n\nService Instances\n\nA service instance is a tuple\n","si=<safSi, st, sg, memCsis>, where\n\nsafSi is a tuple safSi=<safApp, rdn>, where\n\nsafApp is a SAF compliant LDAP distinguished name of the application the service instance belongs to, and\n\nrdn is a relative distinguished name of the Si, which is unique within the application;\n\nst \u03b5 ST;\n","memCsis={memCsi; 0<=i<|memCsis|, \u2200memCsi.cstst.cst; and \u2200memCsi.safCsi.safSi\u2261safSi;}","memCsis={ } at the start of the configuration generation","sgSis={si; 0<=i<|sgSis|, \u2200si.sg\u2261sg} the set of SIs protected by the same service group, they specify the same service group.\n\nApplication\n\nThe application for which the configuration is generated is a tuple\n","app=<safApp, memSgs, memSis>, where\n\nsafApp is a distinguished name of the application;\n","memSgs={memSg; 0<=i<|memSgs|, \u2200memSg.safSg.safApp\u2261safApp;} memSgs={ } at the start of the configuration generation.","memSis={memSi; 0<=i<|memSis|, \u2200memSi.safSi.safApp\u2261safApp;}","memSis={ } at the start of the configuration generation.\n\nNodes\n","node=<safAmfNode, hostedSus>, where\n\nsafAmfNode is a distinguished name of the node;\n","hostedSus={hostedSu; 0<=i<|hostedSus|}","hostedSus={ } at the start of the configuration generation.\n\nAll nodes compose the cluster:\n","Cluster={node; 0<=i<|Cluster|}"]}},"findCompType Method","Input",{"@attributes":{"id":"p-0077","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":{"@attributes":{"id":"ul0012-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":["sut, the service unit type within which the search is performed, it may be empty","cst, the component service type that needs to be provided","redMod, the redundancy model within which cst is provided\n\nOutput\n","chosenCompType, the selected component type\n\nFunctional Description\n"]}}}},"The find CompType method selects the component type within the service unit type or among all component types that can provide the highest utilization for the given redundancy model.","validCompTypes is the set of component types that can provide a required component service type cst within the service unit type sut or among all the component types:",{"@attributes":{"id":"p-0080","num":"0126"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"validCompTypes","mo":"=","mrow":{"mo":"{","mrow":{"msub":{"mi":["vct","i"]},"mo":";","mrow":{"mo":"{","mrow":{"mrow":[{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"sut","mo":"\u2260","mrow":{"mo":["{","}"]}},{"mo":"\u2200","mrow":{"mrow":{"mi":["sut","cst"],"mo":[".",".","."],"msub":[{"mi":["sutCt","j"]},{"mi":["csCapability","k"]}]},"mo":"\u2261"}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mi":"cst","mo":"\u21d2","msub":{"mi":["vct","i"]}}}}]}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":"sut","mo":"\u2261","mrow":{"mrow":[{"mo":["{","}"]},{"mo":"\u2200","mrow":{"mrow":{"msub":{"mi":["ct","j"]},"mo":[".","."],"mi":["csCapability","cst"]},"mo":"\u2261","mi":"cst"}}],"mo":"\u2062"}},"mo":"\u21d2","msub":{"mi":["vct","i"]}},"mo":","}}}]},"mo":["\u2062","\u2062","\u2062"],"mstyle":[{"mtext":{}},{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}}],"msub":{"mi":["ct","i"]}},{"mi":"CT","mo":"."}],"mo":"\u2208"}}}}}}}},{"@attributes":{"id":"p-0081","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"begin"]},{"entry":[{},"MaxMin = 0"]},{"entry":[{},"chosenCompType = { }"]},{"entry":[{},"i = 0"]},{"entry":[{},"while (i < |validCompTypes|) \/\/ for each valid component type"]},{"entry":[{},"vct"]},{"entry":[{},"begin"]},{"entry":[{},"\u2003j = 0"]},{"entry":[{},"\u2003while (j < |vct.csCapability|) \/\/ for each CS type it provides"]},{"entry":[{},"\u2003begin"]},{"entry":[{},"\u2003\u2003if redMod == 2n OR redMod == nplusm"]},{"entry":[{},"\u2003\u2003\u2003\u2003Min = min(vct.csCapability.maxAct,"]},{"entry":[{},"vct.csCapability.maxStandby)"]},{"entry":[{},"\u2003\u2003if redMod == nway"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ x_active_and_y_stanby is the mandatory capability"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ for nway"]},{"entry":[{},"\u2003\u2003\u2003\u2003if vct.csCapability== x_active_and_y_standby"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Min=min(vct.csCapability.maxAct,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003vct.csCapability.maxStandby)"]},{"entry":[{},"\u2003\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Min = 0 \/\/ cannot be used for nway"]},{"entry":[{},"\u2003\u2003if redMod == nwayactive OR redMod == noredundancy"]},{"entry":[{},"\u2003\u2003\u2003\u2003Min= vct.csCapability.maxAct"]},{"entry":[{},"\u2003\u2003if Min > 0 AND Min > MaxMin"]},{"entry":[{},"\u2003\u2003begin"]},{"entry":[{},"\u2003\u2003\u2003\u2003MaxMin = Min"]},{"entry":[{},"\u2003\u2003\u2003\u2003chosenCompType = ct"]},{"entry":[{},"\u2003\u2003end"]},{"entry":[{},"\u2003\u2003j = j + 1"]},{"entry":[{},"\u2003end"]},{"entry":[{},"\u2003i = i + 1"]},{"entry":[{},"end"]},{"entry":[{},"if chosenCompType == { }"]},{"entry":[{},"\u2003return cst cannot be provided"]},{"entry":[{},"else"]},{"entry":[{},"\u2003return chosenCompType"]},{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"suActCap Methods","Input",{"@attributes":{"id":"p-0083","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":{"@attributes":{"id":"ul0014-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":["siTemp, an SI template\n\nOutput\n","suActCap, the required active capability for the SU type or an SU with respect to the Si template\n\nFunctional Description\n"]}}}},"The required SU active capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil( ) is used to round up to the nearest integer.",{"@attributes":{"id":"p-0085","num":"0132"},"maths":[{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}},"mo":"\u2062","mi":"return"}}},{"@attributes":{"id":"MATH-US-00008-2","num":"00008.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"suActCap","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nway"],"mo":"\u2261"},{"mi":"ceil","mo":["(",")"],"mfrac":{"mrow":{"mi":["siTemp","numSIs"],"mo":"."},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["siTemp","numSUs","sus"],"mo":[".","."]},"mo":"-"}}},{"mtd":{"mrow":{"mi":["siTemp","numSUs","susSpare"],"mo":[".","."]}}}]}}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nwayactive"],"mo":"\u2261"},{"mi":"ceil","mo":["(",")"],"mfrac":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["siTemp","numSIs"],"mo":"."},"mo":"\u00d7"}}},{"mtd":{"mrow":{"mi":["siTemp","numAct"],"mo":"."}}}]},"mrow":{"mi":["siTemp","numSUs","susAct"],"mo":[".","."]}}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":["redMod","noredundancy"],"mo":"\u2261"},{"mi":["siTemp","numSIs"],"mo":"."}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":"\u2062","mi":"n"}},{"mi":["siTemp","numSIs"],"mo":"."}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nplusm"],"mo":"\u2261"},{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mi":["siTemp","numSIs"],"mo":"."},{"mi":["siTemp","numSUs","susAct"],"mo":[".","."]}]}}}],"mo":"\u21d2"}}}]}}}}}]},"suStdbCap Methods","Input",{"@attributes":{"id":"p-0087","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":{"@attributes":{"id":"ul0016-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["siTemp, an Si template\n\nOutput\n","suStdbCap, the required standby capability for the SU type or an SU with respect to the SI template\n\nFunction Description\n"]}}}},"The required SU standby capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil( ) is used to round up to the nearest integer.",{"@attributes":{"id":"p-0089","num":"0137"},"maths":[{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},"mo":"\u2062","mi":"return"}}},{"@attributes":{"id":"MATH-US-00009-2","num":"00009.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"suStdbCap","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nway"],"mo":"\u2261"},{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["siTemp","numSIs"],"mo":"."},"mo":"\u00d7"}}},{"mtd":{"mrow":{"mi":["siTemp","numStdb"],"mo":"."}}}]},{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["siTemp","numSUs","sus"],"mo":[".","."]},"mo":"-"}}},{"mtd":{"mrow":{"mi":["siTemp","numSUs","susSpare"],"mo":[".","."]}}}]}]}}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":[{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":"\u2062","mi":"n"}},{"mi":["siTemp","numSIs"],"mo":"."}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nplusm"],"mo":"\u2261"},{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mi":["siTemp","numSIs"],"mo":"."},{"mi":["siTemp","numSUs","susAct"],"mo":[".","."]}]}}}],"mo":"\u21d2"}}}]}}}}}]},"findSUType Method","Input",{"@attributes":{"id":"p-0091","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":{"@attributes":{"id":"ul0018-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":["siTemp, an Si template\n\nOutput\n","chosenSuType, the selected service unit type\n\nFunctional Description\n"]}}}},"This function searches for the first SU type that can provide the SIs of the given template siTemp. Optimization may be added depending on other requirements.","validSuTypes is the set of service unit types that can provide the required service type siTemp.st among all the service unit types:",{"@attributes":{"id":"p-0094","num":"0143"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"validSuTypes","mo":"=","mrow":{"mo":"{","mrow":{"msub":{"mi":["vsut","i"]},"mo":";","mrow":{"mi":"SUT","mo":"\u2260","mrow":{"mrow":[{"mo":["{","}"]},{"mo":"{","mrow":{"mrow":{"mrow":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["siTemp","redMod"],"mo":"."},"mo":"\u2260","mi":"nway"},{"mo":"\u2200","mrow":{"mrow":{"msub":{"mi":["sut","j"]},"mo":".","mi":"st"},"mo":"\u2261"}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":{"mi":["siTemp","st"],"mo":"."},"mo":"\u21d2","msub":{"mi":["vsut","i"]}}}}]}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["siTemp","redMod"],"mo":"."},"mo":"\u2261","mi":"nway"},"mo":"\u21d2"}}},{"mtd":{"mtable":{"mtr":[{"mtd":{"mrow":{"mo":"\u21d2","mrow":{"mo":"\u2200","mrow":{"mrow":{"msub":{"mi":["sut","j"]},"mo":[".",".","."],"mi":["memCt","csCapability","compCap"]},"mo":"\u2261"}}}}},{"mtd":{"mrow":{"mi":["x_active","_and","_y"],"mo":["\u2062","\u2062","\u2062"],"mrow":{"mi":"_standby","mo":"\u22c0"}}}}]}}},{"mtd":{"mrow":{"mrow":{"mo":"\u22c0","mrow":{"mo":"\u2200","mrow":{"mrow":[{"msub":{"mi":["sut","j"]},"mo":".","mi":"st"},{"mi":["siTemp","st"],"mo":"."}],"mo":"\u2261"}}},"mo":"\u21d2","msub":{"mi":["vsut","i"]}}}}]},"mo":["\u2062","\u2062","\u2062"],"mstyle":[{"mtext":{}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}}],"msub":{"mi":["sut","j"]}},"mo":"\u2208","mi":"SUT"},"mo":";"}}],"mo":"\u2062"}}}}}}}},"It may be an empty, set in which case a new SU type is created if it is permitted by limited.",{"@attributes":{"id":"p-0096","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"begin"]},{"entry":[{},"chosenSuType = { }"]},{"entry":[{},"if validSuTypes \u2260{ }"]},{"entry":[{},"begin"]},{"entry":[{},"\u2003i = 0"]},{"entry":[{},"\u2003while(i < |validSUTypes|) \/\/ find an SU type that"]},{"entry":[{},"\u2003begin"]},{"entry":[{},"\u2003\u2003j = 0"]},{"entry":[{},"\u2003\u2003while(j < |siTemp.sicsiTemp|) \/\/ supports all CSI templates"]},{"entry":[{},"\u2003\u2003begin"]},{"entry":[{},"\u2003\u2003\u2003\/\/ use findCompType to find an appropriate component"]},{"entry":[{},"\u2003\u2003\u2003if"]},{"entry":[{},"NOT("]},{"entry":[{},"\u2203k,l  \u2009siTemp.csiTemp.cst \u2261 vsut.memCt.csCapability.cst"]},{"entry":[{},")"]},{"entry":[{},"\u2003\u2003\u2003\u2003j = j + |siTemp.sicsiTemp|"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ make it break by being too big"]},{"entry":[{},"\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003if ((vsut.memCt.csCapability.maxAct x"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003x vsut.memCt.csCapability.maxComp) <"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003< (siTemp.csiTemp.numCsi x"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003suActCap(siTemp))) OR"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003((vsut.memCt.csCapability.maxStdb"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003x vsut.memCt.csCapability.maxComp) <"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003< (siTemp.csiTemp.numCsi x"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003suStdbCap(siTemp)))"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003j = j + |siTemp.sicsiTemp|"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ make it break by being too big"]},{"entry":[{},"\u2003\u2003\u2003j = j + 1"]},{"entry":[{},"\u2003\u2003end"]},{"entry":[{},"\u2003\u2003\/\/ next condition is only true if break occurred,"]},{"entry":[{},"\u2003\u2003\/\/ if so go for next SU type"]},{"entry":[{},"if j > |siTemp.sicsiTemp|"]},{"entry":[{},"\u2003\u2003\u2003i = i + 1"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003begin"]},{"entry":[{},"\u2003\u2003\u2003chosenSuType = vsut"]},{"entry":[{},"\u2003\u2003\u2003return chosenSuType"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\/\/ returns the first appropriate SU type"]},{"entry":[{},"\u2003\u2003end"]},{"entry":[{},"\u2003end"]},{"entry":[{},"end"]},{"entry":[{},"if chosenSuType == { }"]},{"entry":[{},"\u2003\u2003\/\/ if nothing is found or no valid SU types"]},{"entry":[{},"begin"]},{"entry":[{},"\u2003chosenSuType = <{ }, siTemp.st> \/\/ create a new SU type"]},{"entry":[{},"\u2003i = 0"]},{"entry":[{},"\u2003while(i < |siTemp.sicsiTemp|)"]},{"entry":[{},"\u2003\u2003\u2003\/\/ that supports all CSI templates"]},{"entry":[{},"\u2003begin"]},{"entry":[{},"\u2003\u2003vct = { }"]},{"entry":[{},"\u2003\u2003vct = findCompType(chosenSuType,"]},{"entry":[{},"\u2003\u2003\u2003siTemp.csiTemp.cst,siTemp.redMod)"]},{"entry":[{},"\u2003\u2003if vct == { }"]},{"entry":[{},"\u2003\u2003\u2003return { } \/\/ cst cannot be provided"]},{"entry":[{},"\u2003\u2003if vct \u2209 sut.sutCt"]},{"entry":[{},"\u2003\u2003\u2003chosenSuType.sutCt ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003chosenSuType.sutCt \u222a {<vct, NoLimit>}"]},{"entry":[{},"\u2003\u2003i = i + 1"]},{"entry":[{},"\u2003end"]},{"entry":[{},"\u2003SUT = SUT \u222a { chosenSuType }"]},{"entry":[{},"\u2003return chosenSuType"]},{"entry":[{},"end"]},{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"findSGType Method","Input",{"@attributes":{"id":"p-0098","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":{"@attributes":{"id":"ul0020-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":["sut, an SU type","redMod the required redundancy model\n\nOutput\n","chosenSgType, the selected service group type\n\nFunctional Description\n"]}}}},"This function searches for the first SG type that can protect the SIs using the requested service unit type sut according to the requested redundancy model redMod. Optimization may be added depending on other requirements.",{"@attributes":{"id":"p-0100","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"begin"]},{"entry":[{},"chosenSgType = { }"]},{"entry":[{},"i = 0"]},{"entry":[{},"while(i < |SGT|)"]},{"entry":[{},"begin"]},{"entry":[{},"\u2003\/\/ the SG type allows for the SU type and the redundancy"]},{"entry":[{},"model"]},{"entry":[{},"\u2003if sgt.redMod == redMod AND \u2203k  \u2009sgt.sut\u2261 sut"]},{"entry":[{},"\u2003begin"]},{"entry":[{},"\u2003\u2003chosenSgType = sgt"]},{"entry":[{},"\u2003\u2003return chosenSgType"]},{"entry":[{},"\u2003end"]},{"entry":[{},"\u2003i = i + 1"]},{"entry":[{},"end"]},{"entry":[{},"if chosenSgType == { }"]},{"entry":[{},"begin"]},{"entry":[{},"\u2003chosenSgType = <sut, redMod>"]},{"entry":[{},"\u2003SGT = SGT \u222a { chosenSgType }"]},{"entry":[{},"\u2003return chosenSgType"]},{"entry":[{},"end"]},{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"createSis Method","Input",{"@attributes":{"id":"p-0102","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":{"@attributes":{"id":"ul0022-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":["siTemp, an SI template for which the SIs are being generated","sg, the sg that shall protect this set of SIs\n\nOutput\n","sgSis, the set of service instances protected by a service group\n\nFunctional Description\n"]}}}},"Based on the provided SI template, this method generates all the service instances and their component service instances that shall be protected by a service group Currently this function does not include the generation of CSI attributes.",{"@attributes":{"id":"p-0104","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"begin"]},{"entry":[{},"sgSis = { }"]},{"entry":[{},"i = 0"]},{"entry":[{},"while(i < |siTemp.numSIs|)"]},{"entry":[{},"begin"]},{"entry":[{},"\u2003si = <\u201dsafSi=...\u201d, siTemp.st, sg, { } >"]},{"entry":[{},"\u2003j = 0"]},{"entry":[{},"\u2003while (j < |siTemp.sicsiTemps|) \/\/ for each CS type in the SI"]},{"entry":[{},"\u2003begin"]},{"entry":[{},"\u2003\u2003k = 0"]},{"entry":[{},"\u2003\u2003while (k < |siTemp.csiTemp.numCsi|)"]},{"entry":[{},"\u2003\u2003\/\/ create the specified number of CSIs"]},{"entry":[{},"\u2003\u2003begin"]},{"entry":[{},"\u2003\u2003\u2003si.memCsis = si.memCsis U {<\u201dsafCsi=...\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2009siTemp.csiTemp.cst, { } >}"]},{"entry":[{},"\u2003\u2003\u2003k = k + 1"]},{"entry":[{},"\u2003\u2003end"]},{"entry":[{},"\u2003\u2003j = j + 1"]},{"entry":[{},"\u2003end"]},{"entry":[{},"\u2003sgSis = sgSis U {si}"]},{"entry":[{},"\u2003i = i + 1"]},{"entry":[{},"end"]},{"entry":[{},"return sgSis"]},{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Final configuration generation will now be described using the pseudo-code as described below.","generateConf Method","Input",{"@attributes":{"id":"p-0107","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":{"@attributes":{"id":"ul0024-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":["CT all component types","CST all component service types","ST all service types","SIT all service instance templates","CSIT all component service instance templates","SUT service unit types, may be empty","SGT service group types, may be empty","nodeTemp the node template","userPreference is a set of preferences that guides the configuration generation. They allow for different options and optimization and can be extended accordingly. The pseudo-code does not reflect them.\n\nOutput\n","AMF entities for a single application distributed on the nodes of a cluster, i.e. app=<safApp, memSgs, memSis>. Since the application refers to the SG set and the SI set, and they all refer to their children in turn, only the application itself is defined in this example as an output. This \u201capp\u201d is thus a tree with all the instances according to the Output section.\n\nFunctional Description\n"]}}}},"This is the main function which, after determining the required entity types using the findSUType and findSGType methods, populates the configuration with all the instances listed as outputs. It also distributes the generated service units on the nodes.",{"@attributes":{"id":"p-0109","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"begin"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"app = < \u201csafApp=. . . \u201d, { }, {} > \/\/ create an application instance"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"of the output"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i = 0"]},{"entry":[{},"m = 0"]},{"entry":[{},"while(i < |SIT|) \/\/ for each SI template"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sut = { }"]},{"entry":[{},"sut = findSUType(siTemp) \/\/ find appropriate SU type"]},{"entry":[{},"if sut == { }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return \/\/ no configuration can be generated"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sgt = { }"]},{"entry":[{},"sgt = findSGType(sut, siTemp.redMod)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ find appropriate SG type"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sg = <\u201csafSg=. . . \u201d, sgt, { }, {},{} >"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ a first SG instance of the output set is created"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"app.memSis = createSis(siTemp, sg)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ create the protected SIs instances and assigned"]},{"entry":[{},"\/\/ them to that SG instance"]},{"entry":[{},"\/\/ create first SU in the SG"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"su = < \u201csafSu=. . . \u201d, sut, { } >"]},{"entry":[{},"sg.memSus = su.memSus U {su}"]},{"entry":[{},"sg;nodeGroup = sg.nodeGroup U {node}"]},{"entry":[{},"node.hostedSus = node.hostedSus U {su}"]},{"entry":[{},"m = (m + 1) mod |Cluster|"]},{"entry":[{},"j = 0"]},{"entry":[{},"ct_set = { } \/\/ component types in use"]},{"entry":[{},"su_act = suActCap(siTemp)"]},{"entry":[{},"su_stdb = suStdbCap(siTemp)"]},{"entry":[{},"while(j < |siTemp.sicsiTemps|) \/\/ for all CS types"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{}]},{"entry":[{},{"maths":[{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"ct","mo":"=","mrow":{"mi":"findComType","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"sut","mo":[",",","],"mrow":[{"msub":[{"mi":["siTemp","i"]},{"mi":["csiTemp","j"]}],"mo":[".","."],"mi":"cst"},{"msub":{"mi":["siTemp","i"]},"mo":".","mi":"redMod"}]}}}}}},{"@attributes":{"id":"MATH-US-00011-2","num":"00011.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"N","mo":"=","mrow":{"mi":"max","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mi":"su_act","mo":"\u00d7","mrow":{"msub":[{"mi":["siTemp","i"]},{"mi":["csiTemp","j"]}],"mo":[".","."],"mi":"numCsi"}},{"mi":["ct","csCapability","maxAct"],"mo":[".","."]}]}}},{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mi":"su_act","mo":"\u00d7","mrow":{"msub":[{"mi":["siTemp","i"]},{"mi":["csiTemp","j"]}],"mo":[".","."],"mi":"numCsi"}},{"mi":["ct","csCapability","maxStdb"],"mo":[".","."]}]}}}],"mo":","}}}}}}]}]},{"entry":[{},{}]},{"entry":[{},"mem_ct = <ct, N>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ number of instances of a component type"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if mem_ct \u2209\u2002ct_set"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ct_set = ct_set U {mem_ct}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ remember the number of instances"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"k = 0"]},{"entry":[{},"while (k < N)"]},{"entry":[{},"\/\/ create the needed number of components"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"su.memComps ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"su.memComps U {<\u201csafComp =. . . \u201d, ct >}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/components are created and added to the first SU"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"k = k + 1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},"else"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ find how many components are now in the SU"]},{"entry":[{},"\u2203l \u2009mem_ct.ct \u2261 ct, mem_ct, \u2208 ct_set"]},{"entry":[{},"If mem_ct.N < N \/\/ if not enough"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"k = 0"]},{"entry":[{},"while (k < N - mem_ct.N)"]},{"entry":[{},"\/\/ create the needed number of components"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"su.memComps = su.memComps U"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{<\u201csafComp = . . . \u201d, ct >}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"k = k + 1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},"mem_ct.N = N"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},"j = j + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},"k = 1"]},{"entry":[{},"while (k < siTemp.numSus.sus)"]},{"entry":[{},"\/\/ clone the needed number of SUs"]},{"entry":[{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new_su = < \u201csafSu= . . . \u201d, su.sut, su.memComps>"]},{"entry":[{},"sg.memSus = su.memSus U {new_su}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/second, third etc. SUs are created and added to the SG"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"k = k + 1"]},{"entry":[{},"sg.nodeGroup = sg.nodeGroup U {node}"]},{"entry":[{},"node.hostedSus = node.hostedSus U {su}"]},{"entry":[{},"m = (m + 1) mod |Cluster|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},"app.memSgs = app.memSgs U {sg}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/the SG is added to the application"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"i = i + 1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The exemplary embodiments described above provide methods and systems for generating an output of code for an IMM XML file  by an AMF Configuration Generator  for use by an AMF via IMM, typically in a HA environment. An exemplary node  which can act as an AMF Configuration Generator  will now be described with respect to . Node  can contain a processor  (or multiple processor cores), memory , one or more secondary storage devices  and an interface unit  to facilitate communications between node  and the rest of the network, i.e., sources of input and receiver of the output. Additionally, the node  can contain control instructions for automating the generation of the system model based upon received inputs. The memory (or the secondary storage) can be used for storage of exemplary inputs such as user inputs or known required entity types  as defined by current AMF standards. Thus, a node  according to an exemplary embodiment may include a processor for generating a system model according to the format of an IMM XML schema for future (or current) use by an AMF.","Utilizing the above-described exemplary systems according to exemplary embodiments, a method for generating a configuration file is shown in the flowchart of . Initially a node receives inputs, associated with at least one service to be managed by the AMF and software used to provide the at least one service in step . The node then processes the inputs to support the at least one service in step . The node then generates a configuration using the processed inputs in step , if possible. It will be appreciated that it is possible that no configuration can be generated if, for example, the required services cannot be provided by the system or software with the desired level of protection (redundancy).","It will be appreciated that the foregoing exemplary embodiments are merely illustrative and that numerous variations and permutations thereof are within the scope of this document. For example, although the configuration generated by these exemplary embodiments is described as an IMM XML, it will be appreciated by those skilled in the art that this is the input format for IMM, and not necessarily that which is provided directly to an AMF implementation. An AMF implementation may instead have other, non-standard input formats. The configuration which is generated by these exemplary embodiments may be presented in such format(s).","Top Down Approach","The foregoing exemplary embodiments describe systems, methods, devices and software for generating an AMF configuration based on, for example, user requirements and entity types provided by the vendor. Some of these exemplary embodiments employ a \u201cbottom up\u201d approach for selecting an SU type and component type as part of the AMF configuration generation process. That is, some of these exemplary embodiments search for a suitable SU type and component type set in an entities type file  based on the inputs which are provided to the configuration process and then generate compatible higher level type(s), e.g., an SG type, as part of the AMF configuration generation process. However, according to another exemplary embodiment described below, it may first be useful to look at the constraints (if any) associated with the higher level types in the input entity types file  as part of the search for a suitable SU type and component type in order to avoid generating unnecessary higher level types and\/or higher level types which are inconsistent with such constraints.","Consider, for example, the conceptual view of an entity types file  illustrated as  which has been input to an AMF configuration generation process according to this exemplary embodiment. Therein, the entity types file  from, e.g., a vendor, has specified one complete group of types, e.g., an app type, an SG type, an SU type and a component type represented by column  (each of which may have several instances associated therewith). The remaining types, e.g., represented by columns ,  and  are incompletely specified in the entity types file . The circled types in these columns are referred to herein as \u201corphaned\u201d types because they are not supported by higher level types in the entity types file .","According to this exemplary embodiment, searching for a service unit type and a component type to support a service can be performed in an order which involves first evaluating those groups of types which are more fully specified and then evaluating those groups of types which are less fully specified. This enables, for example, such a search to consider the constraints which may be provided by the vendor for the higher level types and\/or to avoid creating higher level types when a service may be supported by a service unit type and component type which are already supported by higher level types. In this context, such restrictions or constraints may include, for example, one or more of: relations between types, limitations, capabilities dependencies, or other constraints. An example of such a constraint is a redundancy type associated with the SG type. An example of a search process for selecting a service unit type and component type in support of a service according to an exemplary embodiment is illustrated in the flowchart of .","For a given set of service instance template requirements , the process first evaluates an application type in an entity types file at step  to determine whether that application type has a constraint which conflicts with one of the inputs to the configuration generation process, e.g., a user input requirement associated with redundancy. Stated differently, step  evaluates the existing application type to determine whether it satisfies the requirements associated with this service instance template. Using, as an exemplary reference, the entity types file shown in , the application type in column  could, for example, be evaluated initially at step . If a conflict exists, then the flow follows the \u201cNo\u201d path from block  to select another application type from the entity types file at step . Alternatively, if the first selected application type satisfies the requirements for this service instance template, then the flow moves on to step , wherein a service group type associated with the first selected application type in column  is checked to see if it meets the requirements. If so, then the flow moves down to the next lower level at step  wherein a service unit type associated with that service group type is checked to see if it satisfies the requirements for this service. If so, then that SU type, SG type and application type are selected for this service instance template at step . If, however, a conflict is detected at the service group type level or the service unit type level, then another entity type at the same level can be evaluated (if one exists in the entity types file) by following the \u201cNo\u201d path from the respective decision blocks  or , and looping back through blocks  or .","If the AMF configuration generator according to this exemplary embodiment cannot find a set of SU type, SG type and application type among those in the entity types file which satisfy the requirements for this service template, then the flow exits the \u201cYes\u201d path from block  to consider the orphaned service group type(s) (if any) in the entity types file. For example, if the types associated with the application type in the column  did not provide a suitable set of types for the service instance template of interest, then the process could move on to column  which includes an orphan service group type. This orphan service group type is then evaluated at step  to determine if it has a conflict with the requirements, e.g., related to redundancy. If not, then the flow moves on to step  wherein one or more service unit types associated with this service group type are checked to see if they can satisfy the requirements. If a set of SU type and an orphan SG type from the entity types file satisfy the requirements for this service instance template, then those entity types are selected and an application type can be created at step  to support the SU type and SG type.","If the orphan service group type satisfies the requirements for this service instance template, but the first checked service unit type does not, then other service unit types associated with this service group type (if any exist) may be evaluated by looping back to step  through step . If none of the service unit types associated with this orphan service group type satisfy the requirements, then the flow can follow the \u201cYes\u201d path from decision block  wherein other orphan service group types can then be evaluated, if any exist in this entity types file. Otherwise, if this is the last orphan service group type in this entity type file, then the flow can follow the \u201cYes\u201d path from block  to block  wherein orphan service unit types are evaluated, e.g., the orphan service unit type shown in column  of . If this (or another via the loop including step ) orphan service unit type fulfills the requirements associated with the service instance template , then that orphan service unit type is selected in step  and an SG type and application type are created to support that SU type.","Otherwise, if no orphan service unit types satisfy the requirements imposed by the service instance template , then the flow follows the \u201cYes\u201d branch from step  to step . Therein, it can be checked to see whether a suitable service unit type can be constructed from orphan component types. If so, then a supporting SU type, SG type and application type are created at step . If not, then the service instance template cannot be satisfied at step  and the process terminates. Note that, in steps ,  and , new types may be created or existing types can be checked to see if they satisfy the SI requirements in which case they can \u201cadopt\u201d the orphaned type which is being selected.","It should be appreciated that the particular order of search is not critical to these exemplary embodiments and, therefore, the SU types found in an entity types file may be evaluated in any desired order as part of the AMF configuration process. However, according to some exemplary embodiments, the AMF configuration generator tool may not be permitted to generate new instances of higher level types, e.g., App types and SG types, unless the SU type under consideration is an orphan, i.e., is not supported by the higher level types in an entities file. Thus, using again the exemplary entity types file  conceptually illustrated in , an AMF configuration tool according to one exemplary embodiment would be permitted to create the types illustrated above the circled, orphaned types in , but would not be permitted to create, e.g., another SG type in column .","This latter possibility is exemplified in  wherein an AMF configuration generator (or a type finder portion  thereof) according to this exemplary embodiment first searches for an appropriate SU type among the type groups which have higher level types in the entities file, e.g., as represented by rows  and  and the overlaid arrows therein, in the manner discussed above with respect to . The search is, as described above, based on the calculated parameters returned from calculator portion , e.g., in a manner similar to that described above and in the exemplary pseudocode below. Having not found a suitable SU type in these type groups, the type finder  then evaluates SU type  and finds it to be suitable for supporting the service of interest. To support a new SU type , the type creator portion  of the AMF configuration generator then creates an App type and SG type in column , e.g., in the manner described above with respect to the \u201cbottom up\u201d embodiments. All of these processes are described in more detail below.","Thus, an overall method for generating an AMF configuration according to this exemplary embodiment is illustrated in the flow diagram of . Each of these steps will be described in some detail. Therein, at step , the data to be used in the configuration process is collected. Generally speaking, such inputs include two different parts, e.g., the entity types describing the software applications, and the set of services that the particular system should provide using this software. Regarding the entity types, these are typically provided by the software vendor as an XML entity types file. The XML schema for an entity types file is specified by the SAF SMF specification as described above. Accordingly, there are two mandatory entity types that the entity types file must contain for the software, i.e., the component types and the component service types they provide. Other entity types may also be provided, however these types do not have to be present in an entity types file if there are no restrictions or constraints related to them. On the other hand, an AMF configuration contains all of the entity types defined by AMF, therefore these higher level types are also one of the expected outputs of these exemplary embodiments. The entity types in the entity types file can be classified to find those types that are not referenced by any other type, i.e., the orphan types described above. More specifically, the orphan component types are not referenced by any service unit type, the orphan service unit types are not referenced by any service group type, and the orphan service group types are not referenced by any application type. As mentioned earlier, according to some exemplary embodiments, orphaned types have no limitations on how they are used with respect to, other higher level types whereas unorphaned types may be not be permitted to have higher level types created therefor.","The second part of the inputs which are collected at step  are the services that the site will provide for which the AMF configuration is being created. As mentioned above, the AMF specification defines the services as a set of service instances in which each service instance is described by a set of component service instances. This is site specific information and will be entered into the AMF configuration generation tool according to exemplary embodiments by a user, e.g., a site designer. To ease this task this exemplary embodiment provides for service instance (SI) templates that characterize sets of service instances which are similar and that shall be protected in a similar manner. Therefore each template specifies a set of SIs that are protected by service groups (SG) of the same type. Within each service instance template the participating component service instances (CSI) are also defined via templates. These CSIs are based on the component service types provided by the software, and indicate how many instances are necessary for the composition of a service instance. An SI template also defines, for example, to which service type it belongs, the desired redundancy model, the number of service instances based on this template and their grouping of SIs to service groups. Based on the set of the SI templates, the corresponding set of service instances and their component service instances is generated by this exemplary embodiment. This can be complemented, according to some exemplary embodiments, by a procedure which generates all of the service and component service instances with their exact attribute settings.","The configuration generator (e.g., the generateConf method in the pseudocode below) loops through the SI templates specified by the user. Returning to , for each SI template, the entity types that can provide the service instances are selected at step , e.g., by finding them among the existing types and\/or creating new types. The type selection step  starts with matching an SI template with the entity types provided as input. According to this exemplary embodiment, first the service group types of the existing application types are checked, e.g., to determine if the redundancy model of the service group type matches the one required by the SI template. If it does, then the service unit types of this service group type are checked (e.g., using the findSut method in the pseudocode below) to determine if they can (a) provide the required service type and (b) support the load of SIs expected to be assigned to them. If both of these conditions are met then, according to this exemplary embodiment, the service unit type, the service group type and the parent application are chosen for the service instances of the SI template.","On the other hand, if none of service group types of any application type can provide the service, then the \u201corphan service group types\u201d are checked in the same way as described above. However, since these service group types are not referenced by any application type, when a suitable service unit type is found, an application type needs to be created. To perform application type creation, the already created application types are checked to determine whether any of them has the service group type as a member or can be extended with that service group type (e.g., using the findAppt method in the pseudocode below). If not, a new application type is created (e.g., using the createAppType method in the pseudocode below) and added to the set of created application types (createdAPPTs). If none of the orphan service group types can provide the service, then the \u201corphan service unit types\u201d are checked in a similar way. Again, when a service unit type is found, a service group type is either created (e.g., using the createSgType method in the pseudocode below) or found (e.g., using the findSgt method in the pseudocode below to search the set of createdSGTs) among the already existing created service group types to adopt the orphan service unit type. If a new service group type needs be created (it is added to the set of created service group types createdSGTs), then the appropriate application type also needs to be found or created. If none of the orphan service unit types can provide the service, then a service unit type is created (e.g., using the createSuType in the pseudocode below), and then adopted by a found\/created service group type, that in turn will be adopted by a found\/created application type.","Once all of the appropriate entity types have been found for an SI template, this exemplary embodiment then generates the entities of these types (e.g., within the generateConf in the pseudocode below) that would provide the service instances needed to support the requested services at step . That is the AMF configuration is populated so it can provide for both the active and the standby assignments of each service instance protected by each service group. This can be accomplished by creating one service unit with the required number of components so that it provides the required active and standby capabilities for all the component service instances. Once all of the components of the first SU have been added, other SUs required by the redundancy model are copied from this first SU. If more than one service group is required for the SI template, the first service group is copied until all service instances can be served. This exemplary embodiment assumes equal ranking for all of the service units within each service group. However the present invention is not so limited and, for example, a ranking procedure can be added to dictate an ordered handling of service units within the service groups. Additionally, the entity types may be refined or optimized by tailoring the parameters of the type instances to their use based on the created entity instances.","Since the AMF specification does not currently cover performance characteristics for entities, this exemplary embodiment assumes that each service unit of the configuration produces equal load and that each cluster node provides the same capacity, although it will be appreciated by those skilled in the art that the present invention is not so limited. As a result this exemplary embodiment distributes the SUs among the nodes, at step  in , of the cluster by selecting, for each SU, the node that has the smallest load in terms of number of service units assigned and that has no SU (or a smallest number of) associated with the same SG that the current SU belongs to. These conditions can be implemented by, for example, performing a global round robin distribution of the SUs as they are being created. Moreover, this exemplary distribution method can be further optimized or enhanced, e.g., based on performance characteristics of the system by assuming different capacities for the different nodes and different load for the different service units and or service instances and\/or based on the assumption of different failure scenarios to avoid overload situations when one or more SUs\/nodes fail in the system. These additional conditions will result in a non-round robin distribution of the SUs on the nodes. The process associated with steps ,  and  continues until all of the SI templates are processed and the configuration is populated with entities to provide their service instances in the SAF system.","As a result of applying the method illustrated in , and described above, to the inputs, an AMF configuration is generated by this exemplary embodiment that specifies all of the instances for all of the entity types and their entities. The result can then be stored or saved, e.g., in a memory device or recordable medium, in any desired format as indicated by step . For example, this output can be presented and\/or stored in accordance with the AIS specifications as an XML file created according to the IMM schema, which contains the description of the instances as specified in the UML model of AMF. In this way, an SAF compliant AMF implementation can be provided with the information model of all of the entities which it needs to manage as an input. Due to the potential complexity of AMF managed systems, this provides an automated approach to a complex and error prone task.","The following pseudo-code describes, at a high level, an exemplary implementation of the afore-described exemplary embodiment. Other implementations are also possible.","Component Service Types","A component service type is a set",{"@attributes":{"id":"p-0131","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":["cst={att; 0<=i<|cst|, any number of attributes}.\n\nAll component service types compose the set\n","CST={cst; 0<=i<|CST|}.\n\nThis set is a mandatory input and remains constant. It is provided typically by the software vendor.\n"]}},"Component Types","A component capability is a tuple of",{"@attributes":{"id":"p-0133","num":"0000"},"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":"csCapability=<cst, compCap, maxAct, maxStdb>, where cst \u03b5 CST;"}},{"@attributes":{"id":"p-0134","num":"0197"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["compCap",{}],"mo":["=","\u2062"],"mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mi":["x_active","_and","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]}}},{"mtd":{"mrow":{"mi":["x_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]}}},{"mtd":{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mi":["_active","_or","_y","_standby"]}}},{"mtd":{"mrow":{"mn":["1","1"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["_active","_or","_","_standby"]}}},{"mtd":{"mi":"x_active"}},{"mtd":{"mrow":{"mn":"1","mo":"\u2062","mi":"_active"}}}]}}}}},{"mtd":{"mrow":{"mrow":[{"mi":["max","Act"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_and","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"x"},{"mi":"x","mo":"\u2265","mn":"1"}],"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"x"},{"mi":"x","mo":"\u2265","mn":"2"}],"mo":","}}},{"mtd":{"mrow":{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mi":["_active","_or","_y","_standby"]},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mn":["1","1"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["_active","_or","_","_standby"]},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":[{"mi":["x_active","x"],"mo":"\u21d2"},{"mi":"x","mo":"\u2265","mn":"2"}],"mo":","}}},{"mtd":{"mrow":{"mrow":{"mn":"1","mo":"\u2062","mi":"_active"},"mo":"\u21d2","mn":"1"}}}]}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mrow":[{"mi":["max","Stdb"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_and","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"1"}],"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["x_active","_or","_y","_standby"],"mo":["\u2062","\u2062","\u2062"]},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"1"}],"mo":","}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mi":["_active","_or","_y","_standby"]},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"2"}],"mo":","}}},{"mtd":{"mrow":{"mrow":{"mn":["1","1"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["_active","_or","_","_standby"]},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mi":"x_active","mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mn":"1","mo":"\u2062","mi":"_active"},"mo":"\u21d2","mn":"0"}}}]}}],"mo":["=","\u2062"],"mi":{}}}}]}}},"br":{},"ul":{"@attributes":{"id":"ul0028","list-style":"none"},"li":"ct={csCapability; 0<=i<|ct|, all the component service types provided by the component type ct}"}},"Component Type Sets","All component types compose the set",{"@attributes":{"id":"p-0136","num":"0000"},"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":"CT={ct; 0<=i<|CT|}.\n\nThis set is a mandatory input and remains constant. It is provided typically by the software vendor.\n\norphanCTs is the subset of component types that are not referenced by any SU type in the input set (orphanCTs  CT). Note that even when they are adopted by created service unit types, orphan component types remain in the set of orphanCTs\n"}},"Service Types","A member CS type is a tuple",{"@attributes":{"id":"p-0138","num":"0000"},"ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":["memCst=<cst, maxCst>, where cst \u03b5 CST;","maxCsi is the number of CSIs of type est that a service instance of a particular type may contain.\n\nA service type is a set\n","st={memCst; 0<=i<|st| component service instances that compose the service type st}.\n\nAll the service types compose the set\n","ST={st; 0<=i<|ST|}.\n\nThis set is a mandatory input and remains constant.\n"]}},"Service Unit Types","The services of a service unit type is a set",{"@attributes":{"id":"p-0140","num":"0000"},"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":["sutServices={st; 0<=i<|sutServices|, all the service types the service unit provides and it is a subset of ST}\n\nA member component type is a tuple\n","memCt=<ct, maxComp>where ct \u03b5 CT;","maxComp is the maximum number of instances of this component type an SU of this type may contain.\n\nThe component types of an SU type is a set\n","sutCt={memCt; 0<=i<|sutCt|, all the component types the service unit may contain and |sutct|<=|CT|}.\n\nA service unit type is a tuple\n","sut=<sutCt, sutServices>"]}},"Service Unit Type Sets","All the service unit type compose the set",{"@attributes":{"id":"p-0142","num":"0000"},"ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":["SUT={sut; 0<=i<|SUT|}","This set may be empty (SUT={ }) at the beginning of the configuration generation.\n\norphanSUTs is the subset of service unit types that are not referenced by any SG type in the input set (orphanSUTs  SUT). Note that even when they are adopted by created service group types, they remain in the set of orphanSUTs\n\ncreatedSUTs is initially an empty set (createdSUTs\u2212{ }). It is the collection of service unit types that are created during the process of generating a configuration. It is also a subset of the service unit types set (createdSUTs  SUT).\n"]}},"Service Group Types","The service unit types of a service group type is a set",{"@attributes":{"id":"p-0144","num":"0000"},"ul":{"@attributes":{"id":"ul0033","list-style":"none"},"li":["sgtSut={sut; 0<=i<|sgtSut|, all the service unit types the service group may contain and it is a subset of SUT}\n\nA service group type is a tuple\n","sgt=<sgtSut, redMod>, where"]}},{"@attributes":{"id":"p-0145","num":"0218"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"redMod","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mn":"2","mo":"\u2062","mi":"n"}}},{"mtd":{"mi":"nplusm"}},{"mtd":{"mi":"nway"}},{"mtd":{"mi":"nwayactive"}},{"mtd":{"mi":"noredundancy"}}]}}}}}},"Service Group Type Sets","All service group types compose the set",{"@attributes":{"id":"p-0147","num":"0000"},"ul":{"@attributes":{"id":"ul0034","list-style":"none"},"li":"SGT={sgt; 0<=i<|SGT|}\n\nThis set may be empty (SGT={ }) at the beginning of the configuration generation.\n\norphanSGTs is a collection of service group types that are not referenced by any SU type in the input set (orphanSGTs  SGT). Note that even when they are adopted by created application types, they remain in the set of orphanSGTs.\n\ncreatedSGTs is initially an empty set (createdSGTs={ }). It is the collection of service group types that are created during the process of generating a configuration. It is also a subset of the service group types set (createdSGTs  SGT).\n"}},"Application Types","An application type is a set described by",{"@attributes":{"id":"p-0149","num":"0000"},"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":"appt\u2014{sgt; 0<=i<|SGTs|; all the service group types the application type may contain}"}},"Application Type Sets","All application types compose the set",{"@attributes":{"id":"p-0151","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":"APPT={appt; 0<=i<|APPT|}.\n\nThis set may be empty (APPT={ }) at the beginning of the configuration generation.\n\ncreatedAPPTs is initially an empty set (createdAPPTs={ }). It is the collection of application types that are created and added to this set during the process of the configuration generation. It is a subset of the application types set (createdAPPTs  APPT).\n"}},"CSI Templates","A CSI template is a tuple",{"@attributes":{"id":"p-0153","num":"0000"},"ul":{"@attributes":{"id":"ul0037","list-style":"none"},"li":["csiTemp=<cst, numCsi>, where cst \u03b5 CST;\n\nnumCsi is the number of CSIs of type cst created based on this template.\n\nAll CSI templates compose the set\n","CSIT={csiTemp; 0<=i<|CSIT|}.\n\nThis set is a mandatory input and remains constant. It is provided by the site designer.\n"]}},"SI Templates","A SI template is a tuple",{"@attributes":{"id":"p-0155","num":"0000"},"ul":{"@attributes":{"id":"ul0038","list-style":"none"},"li":["siTemp=<st, sicsTemps, redMod, numSIs, numAct, numStdb, numSUs>, where st \u03b5 ST;","sicsiTemps={esiTemp; 0<=i<|sicsiTemps| \u2200csiTemp.cst\u2261sti.cst and csiTemp.numCsi\u2266st.maxCsi};\n\nnumSIs is the number of SI that is created using this template\n"]}},{"@attributes":{"id":"p-0156","num":"0231"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"numAct","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2260"},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mi":"x","mo":";","mrow":{"mi":"x","mo":"\u2265","mn":"2"}},"mo":","}}}]}}}}},"br":{}},{"@attributes":{"id":"p-0157","num":"0232"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"numStdb","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["redMod","nway"],"mo":"\u2261"},"mo":"\u21d2","mi":"y"},{"mi":"y","mo":"\u2265","mn":"1"}],"mo":";"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mn":"1","mo":","}}}]}}}}},"br":{},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":"numSUs=<sus, susAct, susStdt,susSpare>, where\n\nsus the total number of SUs in the SG protecting the SIs generated from this template; sus=susAct+susStdb+susSpare;\n"}},{"@attributes":{"id":"p-0158","num":"0234"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"numAct","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["redMod","nplusm"],"mo":"\u2261"},"mo":"\u21d2","mi":"z"}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mi":"z"},{"mi":"z","mo":">","mn":"1"}],"mo":";"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mi":"numSIs"}}},{"mtd":{"mrow":{"mrow":{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":"\u2062","mi":"n"}},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["redMod","nway"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"},"mo":","}}}]}}}}},"br":{}},{"@attributes":{"id":"p-0159","num":"0235"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["susStbd","numStdb"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["redMod","nplusm"],"mo":"\u2261"},"mo":"\u21d2","mi":"w"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":"\u2062","mi":"n"}},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nway"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}}]}}],"mo":"="}}},"br":{},"ul":{"@attributes":{"id":"ul0040","list-style":"none"},"li":["susSpare is the number of spare SUs.\n\nAll SI templates compose the set\n","SIT={siTemp; 0<=i<|SIT|}.\n\nThis set is a mandatory input and remains constant. It is provided by the site designer.\n"]}},"Node Templates","The node template is a tuple",{"@attributes":{"id":"p-0161","num":"0000"},"ul":{"@attributes":{"id":"ul0041","list-style":"none"},"li":["nodeTemp=<numNodes>, where\n\nnumNodes is the number of nodes created based on the template.\n\nAll node templates compose the set\n","NodeTemp={nodeTemp; 0<=i<|NodeTemp|}.\n\nThis set is a mandatory input and remains constant. It is provided by the site designer.\n"]}},"Outputs to Generate","Components","A component has a name and belongs to component type. It is a tuple comp=<safComp, ct>, where ct \u03b5 CT;",{"@attributes":{"id":"p-0164","num":"0000"},"ul":{"@attributes":{"id":"ul0042","list-style":"none"},"li":["safComp is a tuple safComp=<safSu, rdn>, where","safSu is a SAF compliant LDAP distinguished name of the SU the component belongs to and rdn is a relative distinguished name of the component, which is unique within the SU."]}},"Service Units","A service unit is a tuple",{"@attributes":{"id":"p-0166","num":"0000"},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":["su=<safSu, sut, memComps>, where","safSu is a tuple safSu=<safSg, rdn>, where","safSg is a SAF compliant LDAP distinguished name of the SG the service unit belongs to and rdn is a relative distinguished name of the SU which is unique within the SG;","sut \u03b5 SUT;","memComps={memComp; 0<=i<|memComps|, \u2200memComp.safComp.safSu\u2261safSu;}","memComp={ } at the start of the configuration generation."]}},"Service Groups","A service group is a tuple",{"@attributes":{"id":"p-0168","num":"0000"},"ul":{"@attributes":{"id":"ul0044","list-style":"none"},"li":["sg=<safSg, sgt, memSus, nodeGroup>, where","safSg is a tuple safSg=<safApp, rdn>, where","safApp is a SAF compliant LDAP distinguished name of the application the service group belongs to and","rdn is a relative distinguished name of the SG, which is unique within the application; sgt \u03b5 SGT;","memSus={memSu; 0<=i<|memSus|, memSu.sut \u03b5 sgt.sgtSut and \u2200memSu.safSu.safSg\u2261safSg;}","memSUs\u2014{ } at the start of the configuration generation","nodeGroup={node; 0<=i<|nodeGroup|,}; the nodeGroup  Cluster on which the SG is distributed"]}},"Component Service Instances","A component service instance is a tuple",{"@attributes":{"id":"p-0170","num":"0000"},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":["csi=<safCsi, cst, attrValues>, where","safCsi is a tuple safCsi=<safSi, rdn>, where","safSi is a SAF compliant LDAP distinguished name of the service instance the component service instance belongs to and","rdn is a relative distinguished name of the CSI, which is unique within the service instance; cst \u03b5 CST;","attrValues={attrValue; 0<=i<|cst|}","attrValue=<attr, value>, where","\u2200attrValue.attr \u03b5 cst.attr;","attrValue.value is a value set for the attribute","attrValues={ } the method does not cover the generation of attribute values. This is a potential future enhancement."]}},"Service Instances","A service instance is a tuple",{"@attributes":{"id":"p-0172","num":"0000"},"ul":{"@attributes":{"id":"ul0046","list-style":"none"},"li":["si=<safSi, st, sg, memCsis>, where","safSi is a tuple safSi=<safApp, rdn>, where","safApp is a SAF compliant LDAP distinguished name of the application the service instance belongs to and","rdn is a relative distinguished name of the SI, which is unique within the application; st \u03b5 ST;","memCsis={memCsi; 0<=i<|memCsis|, \u2200memCsi.cst\u2203st.cst; and \u2200memCsi.safCsi.safSi\u2261safSi;}","memCsis={ } at the start of the configuration generation","sgSis={si; 0<=i<|sgSis|, \u2200si.sg\u2261sg} the set of SIs protected by the same service group, they specify the same service group."]}},"Applications","The application for which the configuration is generated is a tuple",{"@attributes":{"id":"p-0174","num":"0000"},"ul":{"@attributes":{"id":"ul0047","list-style":"none"},"li":["app=<safApp, memSgs, memSis>, where","safApp is a distinguished name of the application;","memSgs={memSg; 0<=i<|memSgs|, \u2200memSg.safSg.safApp\u2261safApp;} memSgs={ } at the start of the configuration generation.","memSis={memSi; 0<=i<|memSis|, \u2200memSi.sajSi.safApp\u2261safApp;}","memSis={ } at the start of the configuration generation.\n\nAll applications compose the set\n","Apps={app; 0<=i<|Apps|}"]}},"Nodes\n\n","Configuration Generation","calculateSuActLoad Method","Input",{"@attributes":{"id":"p-0178","num":"0000"},"ul":{"@attributes":{"id":"ul0049","list-style":"none"},"li":{"@attributes":{"id":"ul0049-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0050","list-style":"none"},"li":["siTemp, an SI template\n\nOutput\n","suActCap, the required active capability for the SU with respect to the SI\n\nFunctional Description\n"]}}}},"The required SU active capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil( ) is used to round up to the nearest integer.",{"@attributes":{"id":"p-0180","num":"0296"},"maths":[{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},"mo":"\u2062","mi":"return"}}},{"@attributes":{"id":"MATH-US-00018-2","num":"00018.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"suActLoad","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nway"],"mo":"\u2261"},{"mi":"ceil","mo":["(",")"],"mfrac":{"mrow":{"mi":["siTemp","numSIs"],"mo":"."},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["siTemp","numSUs","sus"],"mo":[".","."]},"mo":"-"}}},{"mtd":{"mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["siTemp","numSUs","susSpare"],"mo":[".","."]},"mo":"\u2261","mn":"0"},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mo":"\u21d2","mrow":{"mi":["siTemp","numSUs","susSpare"],"mo":[".","."]}}}}]}}}}]}}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nwayactive"],"mo":"\u2261"},{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mrow":[{"mi":["siTemp","numSIs"],"mo":"."},{"mi":["siTemp","numAct"],"mo":"."}],"mo":"\u00d7"},{"mi":["siTemp","numSUs","susAct"],"mo":[".","."]}]}}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mrow":[{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":"\u2062","mi":"n"}},{"mi":["siTemp","numSIs"],"mo":"."}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nplusm"],"mo":"\u2261"},{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mi":["siTemp","numSIs"],"mo":"."},{"mi":["siTemp","numSUs","susAct"],"mo":[".","."]}]}}}],"mo":"\u21d2"}}}]}}}}}]},"calculateSuStdbLoad Method","Input",{"@attributes":{"id":"p-0182","num":"0000"},"ul":{"@attributes":{"id":"ul0051","list-style":"none"},"li":{"@attributes":{"id":"ul0051-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0052","list-style":"none"},"li":["siTemp, an SI template\n\nOutput\n","suStdbCap, the required standby capability for the SU with respect to the SI\n\nFunction Description\n"]}}}},"The required SU standby capabilities are calculated with respect to the SI template with the assumption that an SU provides a group of SIs from a single template. In the formula ceil( ) is used to round up to the nearest integer.",{"@attributes":{"id":"p-0184","num":"0301"},"maths":[{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mi":"return"}},{"@attributes":{"id":"MATH-US-00019-2","num":"00019.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"suStdbLoad","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nway"],"mo":"\u2261"},{"mi":"ceil","mo":["(",")"],"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["siTemp","numSIs"],"mo":"."},"mo":"\u00d7"}}},{"mtd":{"mrow":{"mi":["siTemp","numStdb"],"mo":"."}}}]},{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":["siTemp","numSUs","sus"],"mo":[".","."]},"mo":"-"}}},{"mtd":{"mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":{"mi":["siTemp","numSUs","susSpare"],"mo":[".","."]},"mo":"\u2261","mn":"0"},"mo":"\u21d2","mn":"1"}}},{"mtd":{"mrow":{"mo":"\u21d2","mrow":{"mi":["siTemp","numSUs","susSpare"],"mo":[".","."]}}}}]}}}}]}]}}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","nwayactive"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":{"mi":["redMod","noredundancy"],"mo":"\u2261"},"mo":"\u21d2","mn":"0"}}},{"mtd":{"mrow":{"mrow":[{"mi":"redMod","mo":"\u2261","mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"n"}},{"mi":["siTemp","numSIs"],"mo":"."}],"mo":"\u21d2"}}},{"mtd":{"mrow":{"mrow":[{"mi":["redMod","nplusm"],"mo":"\u2261"},{"mi":"ceil","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mi":["siTemp","numSIs"],"mo":"."},{"mi":["siTemp","numSUs","susStdb"],"mo":[".","."]}]}}}],"mo":"\u21d2"}}}]}}}}}]},"createAppType Method","Input",{"@attributes":{"id":"p-0186","num":"0000"},"ul":{"@attributes":{"id":"ul0053","list-style":"none"},"li":{"@attributes":{"id":"ul0053-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0054","list-style":"none"},"li":["sgt, an service group type\n\nOutput\n","appt, an application type\n\nFunction Description\n"]}}}},"This function creates an application type that supports a given service group type.","Begin","Create a new application type appt={sgt}","ADD appt TO createdAPPTs","End","createSgType Method","Input",{"@attributes":{"id":"p-0191","num":"0000"},"ul":{"@attributes":{"id":"ul0055","list-style":"none"},"li":{"@attributes":{"id":"ul0055-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0056","list-style":"none"},"li":["sut, an service unit type","siTemp.redMod, the redundancy model required by the SI template\n\nOutput\n","sgt, a service group type\n\nFunction Description\n"]}}}},"This function creates a service group type that supports a given service unit type, and sets the redundancy model of this service group to same one of the SI template",{"@attributes":{"id":"p-0193","num":"0313"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BEGIN"]},{"entry":[{},"\u2003\u2003\u2003Create a new service group type sgt = <sgtSut, redMod>"]},{"entry":[{},"\u2003\u2003\u2003ADD sut TO sgt.sgtSut"]},{"entry":[{},"\u2003\u2003\u2003SET sgt.redMod TO siTemp.redMod"]},{"entry":[{},"\u2003\u2003\u2003ADD sgt TO createdSGTs"]},{"entry":[{},"END"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"createSuType Method","Input",{"@attributes":{"id":"p-0195","num":"0000"},"ul":{"@attributes":{"id":"ul0057","list-style":"none"},"li":{"@attributes":{"id":"ul0057-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0058","list-style":"none"},"li":["siTemp, an SI template\n\nOutput\n","sut, a service unit type\n\nFunction Description\n"]}}}},"This function creates a service unit type that supports a given service type.",{"@attributes":{"id":"p-0197","num":"0318"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BEGIN"]},{"entry":[{},"\u2003\u2003\u2003Create a new service unit sut=<sutCt, sutServices>"]},{"entry":[{},"\u2003\u2003\u2003ADD siTemp.st TO sut.sutServices"]},{"entry":[{},"\u2003\u2003\u2003FOR every csiTemp IN siTemp. sicsTemps"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003CALL findOrphanCT WITH siTemp.csiTemp, siTemp"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURNING foundCT \/\/foundCT is the found"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003component type"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003IF foundCT IS Null THEN"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET sut TO Null \/\/ Delete the created SU Type"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ELSE"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET memCT.ct TO foundCT"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET memCT.maxComp TO no limit"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD memCT TO sut.sutCt"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD sut TO createdSUTs"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"]},{"entry":[{},"\u2003\u2003\u2003ENDFOR"]},{"entry":[{},"\u2003\u2003\u2003RETURN sut"]},{"entry":[{},"END"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"findAppt Method","Input",{"@attributes":{"id":"p-0199","num":"0000"},"ul":{"@attributes":{"id":"ul0059","list-style":"none"},"li":{"@attributes":{"id":"ul0059-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0060","list-style":"none"},"li":["givenSgt, service group type\n\nOutput\n","appt an application type\n\nFunction Description\n"]}}}},"This function searches for the first created application type that can support the given SG type. This function is NOT used for finding application types that are not created Modifications to this function are possible based of preferences regarding the extensibility of created application types",{"@attributes":{"id":"p-0201","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BEGIN"]},{"entry":[{},"\u2003\u2003\u2003BOOLEAN found = false"]},{"entry":[{},"\u2003\u2003\u2003FOR every appt IN createdAPPT"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003FOR every sgt IN appt"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF sgt = givenSgt THEN"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURN appt"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET found TO true"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK out of createdAPPT"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"]},{"entry":[{},"\u2003\u2003\u2003ENDFOR"]},{"entry":[{},"\u2003\u2003\u2003IF found = false THEN"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003RETURN Null"]},{"entry":[{},"\u2003\u2003\u2003ENDIF"]},{"entry":[{},"END"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"findSgt Method","Input",{"@attributes":{"id":"p-0203","num":"0000"},"ul":{"@attributes":{"id":"ul0061","list-style":"none"},"li":{"@attributes":{"id":"ul0061-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0062","list-style":"none"},"li":["givenSut service unit type","redMod, a redundancy model\n\nOutput\n","sgt, a service group type\n\nFunction Description\n"]}}}},"This function searches for the first created SG type that can support the given SU type. This function is NOT used for finding SG types that are not created.",{"@attributes":{"id":"p-0205","num":"0329"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BEGIN"]},{"entry":[{},"\u2003\u2003\u2003BOOLEAN found = false"]},{"entry":[{},"\u2003\u2003\u2003FOR every sgt IN createdSGTs"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003IF sgt.redMod = redMod THEN"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR every sut IN sgt.sgtSut"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF sut = givenSut THEN"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURN sgt"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET found TO true"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK out of createdSGTs"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"]},{"entry":[{},"\u2003\u2003\u2003ENDFOR"]},{"entry":[{},"\u2003\u2003\u2003if found = false THEN"]},{"entry":[{},"\u2003\u2003\u2003RETURN Null"]},{"entry":[{},"END"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"findSut Method","Input",{"@attributes":{"id":"p-0207","num":"0000"},"ul":{"@attributes":{"id":"ul0063","list-style":"none"},"li":{"@attributes":{"id":"ul0063-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0064","list-style":"none"},"li":["siTemp, an SI template","sutSet, a set of SU types  SUT\/\/ we could be looking in orphanSUTs or sgt.sgtSut or createdSUTs\n\nOutput\n","sut, a service unit type\n\nFunction Description\n"]}}}},"This function searches for the first SU type that can support the SIs of the given template siTemp. Optimization may be added depending on other requirements.",{"@attributes":{"id":"p-0209","num":"0335"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"BEGIN"},{"entry":"\u2003\u2003\u2003BOOLEAN found = false"},{"entry":"\u2003\u2003\u2003FOR every sut IN sutSet"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003FOR every st IN sut.Services"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF st = siTemp.st THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR every csiTemp in siTemp.sicsTemps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET found TO false"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findCT WITH siTemp,csiTemp,sut RETURNING foundCt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF foundCt = Null"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003THEN \/\/this sut is not valid"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CONTINUE and GO TO next sut in the sutSet"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ELSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET found TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF found = true THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURN sut \/\/the sut in the current"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003sutSet iteration"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK from the sutSet loop"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003IF found = false THEN\/\/all the su types are not valid"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003RETURN Null"},{"entry":"\u2003\u2003\u2003ENDIF"},{"entry":"END"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"findCt Method","Input",{"@attributes":{"id":"p-0211","num":"0000"},"ul":{"@attributes":{"id":"ul0065","list-style":"none"},"li":{"@attributes":{"id":"ul0065-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0066","list-style":"none"},"li":["siTemp, an SI template","csiTemp, a CSI template","sut, a service unit type\n\nOutput\n","ct, a component type\n\nFunction Description\n"]}}}},"This function searches for the first component type that can support the CSIs of the given template csiTemp. Optimization may be added depending on other requirements.",{"@attributes":{"id":"p-0213","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"BEGIN"},{"entry":"\u2003\u2003\u2002BOOLEAN found = false"},{"entry":"\u2003\u2003\u2002FOR every memCt IN sutCt"},{"entry":"\u2003\u2003\u2003\u2003\u2003IF memCt.ct.csCapability.cst = csiTemp.cst THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CASE siTemp.redMod OF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003nway:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002IF memCt.ct.csCapability.compCap = x_active_and_y_standby THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL calculateSuActLoad WITH siTemp RETURNING suActLoad"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL calculateSuStandbyLoad WITH siTemp RETURNING"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003suStandby"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF memCt.maxComp * memCt.ct.csCapability.maxActive >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2003\u2003\u2003\u2003csiTemp.numCsi * suActLoad"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2003\u2003\u2003\u2003AND"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2003\u2003\u2003\u2003memCt.maxComp * memCt.ct.csCapability.maxStandby >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2003\u2003\u2003\u2003csiTemp.numCsi * suStandbyLoad THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET found TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURN memCt.ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK from the sutCt loop"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2003\u2003\u2003\u2003ELSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003GO to next memCt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003OTHERS: \/\/in case of other redundancy models"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL calculateSuActLoad WITH siTemp RETURNING suActLoad"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL calculateSuStandbyLoad WITH siTemp RETURNING suStdbLoad"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF memCt.maxComp * memCt.ct.csCapability.maxActive >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002csiTemp.numCsi * suActLoad"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002AND"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002memCt.maxComp * memCt.ct.csCapability.maxStdby >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002csiTemp.numCsi * suStdbLoad THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003found = true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002RETURN memCt.ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK from the sutCt loop"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ELSE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003GO to next memCt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDCASE"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2002IF found = false THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003RETURN Null"},{"entry":"\u2003\u2003\u2002ENDIF"},{"entry":"END"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"findOrphanCt Method","Input",{"@attributes":{"id":"p-0215","num":"0000"},"ul":{"@attributes":{"id":"ul0067","list-style":"none"},"li":{"@attributes":{"id":"ul0067-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0068","list-style":"none"},"li":["siTemp, an SI template","csiTemp, a CSI template\n\nOutput\n","ct, a component type\n\nFunction Description\n"]}}}},"This function searches for the first component type in orphanCTS that can support the CSIs of the given template csiTemp. Optimization may be added depending on other requirements.",{"@attributes":{"id":"p-0217","num":"0348"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"BEGIN"},{"entry":"\u2003\u2003\u2003BOOLEAN found = false"},{"entry":"\u2003\u2003\u2003For every ct IN orphanCTS"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003CASE siTemp.redMod OF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003nway:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF ct.csCapability.compCap IS NOT x_active_and_y_standby THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CONTUNUE and GO TO next ct in orphanCTs"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ELSEIF ct.csCapability.cst = csiTemp.cst THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURN ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET found TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK out of orphanCTs"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003OTHERS:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF ct.csCapability.cst = csiTemp.cst THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURN ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET found TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK out of orphanCTs"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDCASE"},{"entry":"\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003IF found = false"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003RETURN Null"},{"entry":"\u2003\u2003\u2003ENDIF"},{"entry":"END"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"calculateNumOfComp Method","Input.",{"@attributes":{"id":"p-0219","num":"0000"},"ul":{"@attributes":{"id":"ul0069","list-style":"none"},"li":{"@attributes":{"id":"ul0069-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0070","list-style":"none"},"li":["ct, a component type","siTemp, an SI template","csiTemp, an CSI template\n\nOutput\n","numOfComp, an integer reflecting the number of component\n\nFunction Description\n"]}}}},"This function calculates the number of components of a given component type that need to be created inside a particular service unit",{"@attributes":{"id":"p-0221","num":"0355"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"BEGIN"},{"entry":"\u2003\u2003\u2003FOR every csCapability IN ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003IF csCapability.cst = csiTemp.cst THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL calculateSuActLoad WITH siTemp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURNING suActLoad"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL calculateSuStandbyLoad WITH siTemp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURNING suStdbLoad"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003numOfComp = CEIL ( MAX ( (csiTemp.numCsi *"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003suActLoad )\/csCapability.maxAct,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(csiTemp.numCsi *"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003suStdbLoad )\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003csCapability.maxAct))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003RETURN numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003BREAK out of ct loop"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003ENDFOR"},{"entry":"END"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"assigntoNode Method","Input",{"@attributes":{"id":"p-0223","num":"0000"},"ul":{"@attributes":{"id":"ul0071","list-style":"none"},"li":{"@attributes":{"id":"ul0071-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0072","list-style":"none"},"li":["su, an service unit","nodeGroup, a node group\n\nOutput\n","No output\n\nFunction Description\n"]}}}},"This function will assign the given service unit to a node that have the smallest number of service units assigned to it.",{"@attributes":{"id":"p-0225","num":"0361"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"BEGIN"},{"entry":"\u2003\u2003\u2003BOOLEAN assigned = false"},{"entry":"\u2003\u2003\u2003FOR every node IN the cluster"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF |node.hostedSus| < |firstnode.hostedSus|"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003THEN \/\/ first node is the first node in the cluster"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD su TO node.Sus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD node TO nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET assigned TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003BREAK out of cluster"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003IF assigned = false THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ADD su TO firstnode.Sus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ADD first node TO nodeGroup"},{"entry":"\u2003\u2003\u2003ENDIF"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"generateConf Method","Input",{"@attributes":{"id":"p-0227","num":"0000"},"ul":{"@attributes":{"id":"ul0073","list-style":"none"},"li":{"@attributes":{"id":"ul0073-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0074","list-style":"none"},"li":["CT all component types","CST all component service types","ST all service types","SIT all service instance templates","CSIT all component service instance templates","SUT service unit types","SGT service group types","APPT application types","nodeTemp the node template","userPerference is a set of preferences that guides the configuration generation. They allow for different options and optimization and can be extended accordingly. The pseudo-code does not reflect them.\n\nOutput\n","Apps, i.e. AMF entities for all applications distributed on the nodes of a cluster. Note that the sets of types provided as input are also updated with the created entity types.\n\nFunction Description\n"]}}}},"This is the main function that is responsible for creating all the entities in AMF configuration, and populate their attributes.",{"@attributes":{"id":"p-0229","num":"0375"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"BEGIN"},{"entry":"\u2003\u2003\u2003BOOLEAN foundSut = false"},{"entry":"\u2003\u2003\u2003FOR every siTemp IN SIT"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002foundSut = false"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002FOR every appt IN APPT"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR every sgt IN appt.sgt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002IF sgt.redMod = siTemp.redMod THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findSut WITH siTemp, sgt.sgtSut RETURNING sut"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF sut IS NOT Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002SET foundSut TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002Create new application app = <\u201dsafApp=...\u201d, appt, memSgs, memSis>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002Create new service group sg=< \u201dsafSg=... \u201d, sgt, memSus,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002nodeGroup>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD sg TO app.memSgs"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002Create new service unit su = <\u201dsafSu=... \u201d, sut, memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD su TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR every siTemp.csiTemp in siTemp.sicsTemps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findCt WITH sut, siTemp, csiTemp RETURNING ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL calculateNumOfComp WITH ct, siTemp, csiTemp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003RETURNING numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002Create component comp = < \u201dsafComp=... \u201d, ct >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD comp TO su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL assigntoNode WITH su, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR siTemp.numSUs\u22121\/\/cloning the created su."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new service unit newSu = <\u201dsafSu=... \u201d, sut,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR every comp IN su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002create component newComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002< \u201dsafComp=... \u201d,comp.ct>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD newComp TO newSu.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL assigntoNode WITH newSu, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD newSu TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD app TO Apps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CONTINUE and GO to next SI template"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003IF foundSu = false THEN \/\/no application type was found"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002FOR every sgt IN orphanSGT"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF sgt.redMod = siTemp.redMod THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL findSut WITH siTemp, sgt.sgtSut RETURNING sut"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002IF sut IS NOT Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET foundSut TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findAppt WITH sgt RETURNING appt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF appt = Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL createApptype WITH sgt RETURNING appt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new application app = <\u201dsafApp=...\u201d, appt, memSgs, memSis>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new service group sg=< \u201dsafSg=... \u201d, sgt, memSus,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003nodeGroup>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD sg TO app.memSgs"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new service unit su = <\u201dsafSu=... \u201d, sut, memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD su TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR every siTemp.csiTemp in siTemp.sicsTemps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL findCt WITH sut, siTemp, csiTemp RETURNING ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002calculateNumOfComp WITH ct, siTemp, csiTemp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002RETURNING numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create component comp = < \u201dsafComp=... \u201d, ct >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD comp TO su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL assigntoNode WITH su, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR siTemp.numSUs\u22121\/\/cloning the created su."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002Create new service unit newSu = <\u201dsafSu=... \u201d, sut,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR every comp IN su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003create component newComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002< \u201dsafComp=... \u201d,comp.ct>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD newComp TO newSu.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL assigntoNode WITH newSu, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD newSu TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD app TO Apps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CONTINUE and GO to next SI template"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003IF foundSu = false THEN \/\/no sg type was found"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002CALL findSut WITH siTemp, orphanSUTs RETURNING sut"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002IF sut IS NOT Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET foundSut TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findSgt WITH sut, siTemp.redMod RETURNING sgt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF sgt = Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL createSgtype WITH sut, siTemp.redMod RETURNING sgt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findAppt WITH sgt RETURNING appt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF appt = Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL createApptype WITH sgt RETURNING appt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new application app = <\u201dsafApp=...\u201d, appt, memSgs, memSis>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new service group sg=< \u201dsafSg=... \u201d, sgt, memSus,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003nodeGroup>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD sg TO app.memSgs"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new service unit su = <\u201dsafSu=... \u201d, sut, memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD su TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR every siTemp.csiTemp in siTemp.sicsTemps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL findCt WITH sut, siTemp, csiTemp RETURNING ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL calculateNumOfComp WITH ct, siTemp, csiTemp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002RETURNING numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create component comp = < \u201dsafComp=... \u201d, ct >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD comp TO su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL assigntoNode WITH su, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR siTemp.numSUs\u22121\/\/cloning the created su."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002Create new service unit newSu = <\u201dsafSu=... \u201d, sut, memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR every comp IN su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003create component newComp < \u201dsafComp=... \u201d,comp.ct>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD newComp TO newSu.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL assigntoNode WITH newSu, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD newSu TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD app TO Apps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CONTINUE and GO to next SI template"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003IF foundSu = false THEN \/\/no su type was found"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002CALL findSut WITH siTemp, createdSUTs RETURNING sut"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002IF sut = Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL createSutype WITH siTemp RETURNING sut"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002IF sut IS NOT Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003SET foundSut TO true"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findSgt WITH sut, siTemp.redMod RETURNING sgt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF sgt = Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL createSgtype WITH sut, siTemp.redMod RETURNING sgt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL findAppt WITH sgt RETURNING appt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003IF appt = Null THEN"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL createApptype WITH sgt RETURNING appt"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new application app = <\u201dsafApp=...\u201d, appt, memSgs, memSis>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new service group sg=< \u201dsafSg=... \u201d, sgt, memSus, nodeGroup>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD sg TO app.memSgs"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create new service unit su = <\u201dsafSu=... \u201d, sut, memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD su TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR every siTemp.csiTemp in siTemp.sicsTemps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL findCt WITH sut, siTemp, csiTemp RETURNING ct"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL calculateNumOfComp\u2003\u2003\u2003WITH ct, siTemp, csiTemp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002RETURNING numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR numOfComp"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Create component comp = < \u201dsafComp=... \u201d, ct >"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD comp TO su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CALL assigntoNode WITH su, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FOR siTemp.numSUs\u22121\/\/cloning the created su."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002Create new service unit newSu = <\u201dsafSu=... \u201d, sut, memComps>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002FOR every comp IN su.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003create component newComp < \u201dsafComp=... \u201d,comp.ct>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD newComp TO newSu.memComps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002CALL assigntoNode WITH newSu, sg.nodeGroup"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002ADD newSu TO sg.memSus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ENDFOR"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ADD app TO Apps"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CONTINUE and GO to next SI template"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ENDIF"},{"entry":"\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2003\u2003IF foundSu = false THEN\/\/ no types were found to support the si template"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002MESSAGEBOX (\u201cSorry no types were found to support the current siTemplate\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002GO TO next SI template"},{"entry":"\u2003\u2003\u2003ENDIF"},{"entry":"\u2003\u2002ENDFOR"},{"entry":"\u2003\u2002ADD createdAPPTs TO APPT"},{"entry":"\u2003\u2002ADD createdSGTs TO SGT"},{"entry":"\u2003\u2002ADD createdSUTs TO SUT"},{"entry":"END"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Note that although the foregoing, exemplary pseudo-code performs evaluations between SI requirements and type capabilities in a strict sense, i.e., checking to see if each value in type's capabilities tuple or set is equal to a corresponding value in the SI requirements tuple or set to determine if a type supports those requirements, other evaluation metrics can be used to determine the suitability of a type. For example, for created application types an AMF configuration generator according to exemplary embodiments may decide that it is sufficient that the required set of SG Type is present as a subset. This allows for the extension of existing created types. As a result the configuration will have different numbers of application types and therefore different number of applications, which reflects different strategies of grouping, e.g., grouping by functionality. Strict equivalence results in a 1:1 relation between created SU types, created SG types and created application types. Allowing subsets without other strategies results in a single APPT as it was done in the bottom-up approach.","The foregoing description of exemplary embodiments of the present invention provides illustration and description, but it is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. The following claims and their equivalents define the scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of the specification, illustrate one or more embodiments and, together with the description, explain these embodiments. In the drawings:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3(","i":"a"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3(","i":"b"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
