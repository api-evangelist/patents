---
title: Secure processing systems and methods
abstract: This disclosure relates to systems and methods for enabling the use of secret digital or electronic information without exposing the sensitive information to unsecured applications. In certain embodiments, the methods may include invoking, by a client application executing in an open processing domain, a secure abstraction layer configured to interface with secret data protected by a secure processing domain. Secure operations may be securely performed on the secret data by the secure abstraction layer in the secure processing domain based on an invocation from a client application running in the open processing domain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08874896&OS=08874896&RS=08874896
owner: Intertrust Technologies Corporation
number: 08874896
owner_city: Sunnyvale
owner_country: US
publication_date: 20110617
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","COPYRIGHT AUTHORIZATION","BACKGROUND AND SUMMARY","DETAILED DESCRIPTION","APPENDIX A","Example Code"],"p":["This application claims priority under 35 U.S.C. \u00a7119(e) to U.S. Provisional Patent Application No. 61\/356,524, filed Jun. 18, 2010, and entitled \u201cSECURE PROCESSING SYSTEMS AND METHODS,\u201d which is hereby incorporated by reference in its entirety.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The present disclosure relates generally to systems and methods for the secure processing of digital or electronic information. More specifically, the present disclosure relates to systems and methods for enabling the use of secret digital or electronic information without exposing the sensitive information to unsecured applications.","Computer systems are commonly used to store and process digital information that a user may wish to keep secret or secure. For example, a user may wish to prevent secret information related to their identity, financial accounts, passwords, and the like from being accessed by and\/or exposed to potential attackers who may desire to exploit such secret information. Further, information (e.g., cryptographic keys, certificates, licenses, control programs, etc.) utilized in digital rights management (\u201cDRM\u201d) implementations designed to prevent unauthorized access and\/or use to secure and\/or proprietary content may also need to be kept secret to maintain the integrity of the DRM implementation. Accordingly, systems and methods to manage the processing of secret information by a computer system in a secure manner are desirable.","To prevent unauthorized access to and\/or exposure of secret or secure information, a processing environment may be established on a computer system having a plurality of processing domains with different levels of security. For example, a secure processing domain may be established where secret information is securely processed and protected from exposure to applications executing outside the secure processing domain. An open processing domain may be established where less-sensitive and\/or less-secure operations and applications may be performed and\/or executed. Potential attackers may gain access to the open processing domain by virtue of its less secure nature, but will be substantially impeded from accessing the secret or secure information processed within the secure processing domain given its higher level of security.","In some circumstances, applications running in the open processing domain may need to use secret information protected within the secure processing domain. Consistent with embodiments disclosed herein, a secure programmatic abstraction layer may operate as a boundary between the secure processing domain and the open processing domain allowing applications running in the open processing domain to utilize secret information protected within the secure processing domain without compromising the security of the secret information. The secure programmatic abstraction layer may be invoked by the application running in the open processing domain and used to perform required operations on the secret information in a secure environment.","Secure operations performed on and\/or using secret information consistent with embodiments disclosed herein may initate when a client application executing in an open processing domain of a system invokes a secure abstraction layer. The secure abstraction layer may be configured to interface with secret data protected by a secure processing domain of the system. In some embodiments, the secure processing domain may include a secure processor unit having integrated support for symmetric and asymmetric cryptographic algorithms Further, in certain embodiments, before invoking the secure abstraction layer, the system may determine that the secure abstraction layer is trusted. Determining that the secure abstraction layer is trusted may be based on, for example, a successful signature verification operation.","Once invoked, the secure abstraction layer may perform one or more secure operations on the secret information based on an invocation from a client application. The secure operations may include, for example, loading a cryptographically wrapped key into the secure abstraction layer, performing encryption\/decryption operations utilizing the secret information, performing cryptographic signing and\/or signature verification utilizing the secret information, encrypting secret fields within a larger piece of data utilizing the secret information, and\/or performing digest calculations. By performing secure operations in the secure processing domain, the secret information may not be exposed to the less-secure client application running the open processing domain.","In certain embodiments, secret information may be exported and\/or persisted from the secure processing domain in a secure manner. To export or persist secret information, the secret information may first be encrypted using a persistent (e.g., permanent) encryption key. In certain embodiments, the persistent encryption key may be associated with hardware components of the secure processing domain and be configured to persist between system reboots. The secret information may, in addition or alternatively, be encrypted using a cycling encryption key that may not be configured to persist between system reboots. Once encrypted by the persistant and\/or cycling encryption key, the secret information may then be exported from the secure abstraction layer to the client application running in the open processing domain.","A detailed description of the systems and methods consistent with embodiments of the present disclosure is provided below. While several embodiments are described, it should be understood that disclosure is not limited to any one embodiment, but instead encompasses numerous alternatives, modifications, and equivalents. In addition, while numerous specific details are set forth in the following description in order to provide a thorough understanding of the embodiments disclosed herein, some embodiments can be practiced without some or all of these details. Moreover, for the purpose of clarity, certain technical material that is known in the related art has not been described in detail in order to avoid unnecessarily obscuring the disclosure.","Systems and methods are presented for facilitating the secure processing of secret, proprietary, and\/or other information (e.g., secure electronic content). In certain embodiments, the systems and methods described herein can, for example, be used in connection with digital rights management (\u201cDRM\u201d) technologies such as that described in commonly assigned, co-pending U.S. patent application Ser. No. 11\/583,693, filed Oct. 18, 2006 (\u201cthe '693 application\u201d), and\/or service orchestration technologies such as those described in commonly assigned U.S. patent application Ser. No. 10\/863,551 (\u201cthe '551 application\u201d) (the contents of both the '693 application and the '551 application hereby being incorporated by reference in their entireties) as well as in other contexts. It will be appreciated that these systems and methods are novel, as are many of the components, systems, and methods employed therein.","DRM engines (e.g., such as those described in the '693 application) and other software can benefit from leveraging the security and\/or media acceleration functionality of certain system on a chip (\u201cSoC\u201d) based devices. Leveraging integral secure components of a SoC can simplify and optimize the development process, especially with respect to achieving compliance with security and robustness rules of a particular content protection implementation.","Embodiments of the systems and methods described herein can be used to provide a minimal programmatic abstraction layer that confines the handling of secret information (e.g., cryptographic keys) to a relatively small and verifiable secure code module. Depending on the system architecture, this secure code module may directly interact with a secure processor integrated on the SoC operating in a secure processing domain. With this level of integration, cryptographic keys and other secret information can be isolated from applications running on a general purpose CPU integrated on the SoC operating in an open processing domain, and be protected from exposure to potential attackers by the security processor. Secret information (e.g., cryptographic keys) may only be exposed within the protected memory space of the security processor (i.e., within the secure processing domain), and encryption, decryption, signing, and verification functions may be executed on the security processor. By preventing the secret information from being exposed to the general purpose CPU and\/or the open processing domain, the security of the secret information may be maintained.","Device makers may benefit from this approach by limiting their porting effort to mapping the native security functionality of their platform under this abstraction layer. This may allow the port to be completed with only minimal knowledge of the content protection system being deployed. In the case of SoC based systems that include an integral secure processor, the effort needed to harden the system so as to comply with desired or mandated robustness requirements may be simplified.","To implement a secure and robust DRM system (e.g., embodiments of the DRM system described in the '693 application) and\/or other content protection systems, only basic and commonly supported security capabilities may be required. From these basic primitives, higher-level functions can be implemented that may provide consistent behavior across different underlying hardware architectures. For example, in some embodiments, the basic security capabilities of the underlying platform might include a secret device key (e.g., a symmetric or asymmetric secret device key), basic cryptographic primitives, and\/or an integrity protected bootstrap.","Secure Key Box (\u201cSKB\u201d)","In certain embodiments, an application programming interface (\u201cAPI\u201d) is provided, an abstraction of which may be an SKB configured to operate as a secure programmatic abstraction layer. The SKB may be realized by the presence of a secured secret device key (or keys) that, in certain embodiments, may be referred to as a Master Key. In some embodiments, the Master Key may be securely embedded in a hardware security element (e.g., One Time Programmable [\u201cOTP\u201d] memory) such as a SoC or Trusted Platform Module (\u201cTPM\u201d). In some embodiments, the Master Key may comprise a white-box cipher key, or other type of key that is sufficiently protected so as to act as a root of trust used to enable the secure marshalling of other keys and credentials into the Secure Key Box.","In one embodiment, when a device boots, or prior to loading a DRM (and\/or other relevant) software application, the SKB software code module may be verified to determine if it is trusted. The mechanism by which this is accomplished can be a platform specific function. In certain embodiments, verification of whether the SKB software code module is trusted may be performed through signature verification of the SKB software module. In certain embodiments, having a Master Key embedded within a hardware security module (e.g., SoC or TPM) enables this verification step to be very robust.","In some embodiments, the Master Key can be used directly to verify the integrity of the code, while in other embodiments, a more flexible approach can be employed, in which the Masker Key can be used to marshal an integrity-protected trust anchor or a confidentiality-protected symmetric key from a secondary storage (e.g., non-volatile random-access memory (\u201cNVRAM\u201d)). This technique of storing secrets and trusted information may be referred to as a Vault. Once this trust anchor or key has been securely loaded from secondary storage, it can then be used by a integrity protected bootstrap to verify the signature over the SKB code module.","Other than the secure storage of the Master Key, some embodiments of an SKB need no additional secure storage, and may rely on a Vault to securely store any trusted data that may be necessary in secondary storage. That is, in such embodiments, secret and trusted information may be stored in secondary storage so long as the information at rest is protected by the Master Key or some other key that is confidentiality protected by the Master Key.","In one embodiment, the SKB API provides an interface in support of the following functions:\n\n","In certain embodiments, an SKB can be used to enable an application executing in an open processing domain to use cryptographic keys without directly exposing the value of the cipher key to the application (i.e., keeping the value of the cipher from being exposed in the clear or the open processing environment). The SKB API may provide a mechanism to load cryptographically wrapped keys (e.g., keys encrypted with another key) into the SKB and then to use the loaded key in cryptographic operations. The first key loaded into the SKB may be unwrapped with the Master Key and other keys can be then loaded and unwrapped accordingly.","In some embodiments, the SKB API may expose common cryptographic methods to encrypt\/decrypt, sign\/verify and digest buffers that may possibly include secret data to applications executing in the open processing domain. In some embodiments, the SKB implementation may support one or more cryptographic algorithms. For example, the SKB implementation may support one or more of the following cryptographic algorithms:\n\n","The SKB API may implement additional cipher modes of operation such as cipher-block chaining (\u201cCBC\u201d) and counter (\u201cCTR\u201d). In certain embodiments, given their inherent security, these cipher modes could be safely implemented outside of the SKB in an open processing domain. It will be appreciated that the aforementioned algorithms are just examples, and that any suitable algorithm(s) could be supported.","SoC Based System Architecture",{"@attributes":{"id":"p-0031","num":"0037"},"figref":"FIG. 1","b":["100","102","102","100","104","104","106","108","110","100","112","104","112"]},"The system architecture  may further include media processing blocks  that may incorporate a central processing unit (\u201cCPU\u201d) , a graphics processing unit (\u201cGPU\u201d) , decoder , and input\/output (\u201cI\/O\u201d)  functionality. An operating system (\u201cOS\u201d)  may also be included to manage and coordinate in part system hardware resources and provide for common services for execution of various applications.","Firmware  may be included that can supply the SoC specific interfaces to the media  and security  processing components. In certain embodiments, this firmware  may be trusted. In some embodiments, the SoC boot sequence may verify the integrity and authenticity of the firmware . The security  and media  processing components may be exposed to applications (e.g., media application ) by the operating system  as devices. Drivers , that may be trusted, can be configured to interface with these devices. Additional trusted software components included in the system architecture  may include an SKB and a DRM client binary. In certain embodiments, mechanisms may be included to verify the integrity and trustworthiness of these components. In some embodiments, the system architecture  integrates some degree of sandboxing that may ensure that unauthorized applications cannot access secure resources including, for example, system memory or a media-processing pipeline.","Secure Key Box API","As discussed above, a secure programmatic abstraction layer may function as an SKB API . Consistent with some embodiments, the SKB API  may provide a simple programmatic interface to enable the use of cryptographic keys without exposing this sensitive information to a calling application operating in an open processing domain (e.g., media application ). For example, in one embodiment, the SKB API  supports common cryptographic functions such as unwrapping a key inside the SKB and then using this key to decrypt bulk data within the secure environment of the SKB.","SKB_Engine","An SKB_Engine object may be initialized via an SKB API  that represents an instance of a secure processor engine that can manage and operate on secret data (e.g., cryptographic keys and the like). In certain embodiments, the secret data may not otherwise be accessed by a calling application. A client application may execute a calling operation to obtain an SKB_Engine and a releasing operation to release the SKB_Engine. In some embodiments, an SKB_Engine may provide at least the following categories of functionality:\n\n","In some embodiments, the abstractions exposed by the SKB API  may include SKB_SecureData, SKB_Transform, and SKB_Cipher objects. Exemplary SKB_Engine methods relating to these abstractions may include:",{"@attributes":{"id":"p-0037","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SKB_Engine_CreateCipher","Creates an SKB_Cipher Object"]},{"entry":["SKB_Engine_CreateDataFromExported","Creates an SKB_SecureData object from"]},{"entry":[{},"previously exported data"]},{"entry":["SKB_Engine_CreateDataFromWrapped","Creates an SKB_SecureData object for data"]},{"entry":[{},"resulting from unwrapping (e.g.,"]},{"entry":[{},"decrypting) previously wrapped data, or for"]},{"entry":[{},"data that was not wrapped"]},{"entry":["SKB_Engine_CreateTransform","Creates an SKB_Transform object"]},{"entry":["SKB_Engine_GetDataByName","Creates an SKB_SecureData object for data"]},{"entry":[{},"referenced by name"]},{"entry":["SKB_Engine_GetInfo","Obtains information about the engine, such"]},{"entry":[{},"as its major and minor version numbers"]},{"entry":["SKB_Engine_GetInstance","Obtains an SKB_Engine instance"]},{"entry":["SKB_Engine_Release","Releases the SKB_Engine object"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"An SKB_SecureData object may allow a calling application to refer to and operate on data ensconced, secured and protected within the SKB that may not otherwise by accessed by the calling application (e.g., cipher keys or arbitrary byte sequences). In one embodiment, SKB_Secure Data objects may be named so that a calling application can locate a specific secret within the SKB. For example, an application can query the SKB for the Master Key  by its name (e.g. \u201cOTPKey0\u201d) so that it can load and unwrap cryptographic key material that may be stored external to the SoC.","In some embodiments, an SKB_SecureData object can be created for each secret data to be operated on by the SKB. In certain embodiments, to create an SKB_SecureData object, an appropriate SKB_Engine method may be called. For example, calling SKB_Engine_CreateDataFromWrapped may create an SKB_SecureData object that represents secret data created from unwrapping (i.e., decrypting) specified cryptographically wrapped data.","As described above, an SKB_SecureData object may be used to represent secret data having values that are not exposed to client applications executing in an open processing environment but can be operated on by the SKB API implementation . Client applications may ask for data characteristics of secret data referenced by an SKB_SecureData object, such as its size in bites and its type, and can call the SKB API  to operate on the secret data. Client applications may further reference secret data within the SKB via an SKB_SecureData object. Methods relating to SKB_SecureData objects may include:",{"@attributes":{"id":"p-0041","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SKB_SecureData_Derive","Derives a new SKB_SecureData object"]},{"entry":[{},"from an existing one"]},{"entry":["SKB_SecureData_Export","Exports the data represented by the"]},{"entry":[{},"SKB_SecureData object to a protected"]},{"entry":[{},"form"]},{"entry":["SKB_SecureData_GetInfo","Retrieves information about the secret data"]},{"entry":[{},"represented by the SKB_SecureData object"]},{"entry":["SKB_SecureData_Release","Releases the SKB_SecureData object"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0042","num":"0051"},"figref":"FIG. 2","b":["200","202","204"]},"Exporting and Persisting SKB_SecureData","In some embodiments, SKB_SecureData can be persisted. For example, if a client application needs some secret data to be persistent, so that it is available across reboots and\/or resets, or if the client application wishes the secret data to be available outside the secure processing domain, the client application may ask the SKB API  for a protected form of the secret data that can be exported or persistently stored, since client applications may not obtain the secret data bytes in the clear. When the persisted data is needed later, the client application may request to have the exported or persisted data \u201cimported\u201d (e.g., unencrypted) and, in certain embodiments, referenced by a new SKB_SecureData object.","In certain embodiments, persisting SKB_SecureData across reboots and\/or resets returns a serialized form of the SKB_SecureData object encrypted using a permanent key (e.g., Master Key  or a derivative thereof). In some embodiments, this persisted serialized form will be an encrypted representation of the secret data. Using a built-in permanent key (e.g., the Master Key  or a derivative thereof) that the SKB API  implementation supports, the persisted encrypted representation can be unwrapped upon a restart.","In some embodiments, upon boot or the first time an SKB-Engine is created after a boot, the SKB API  may generate a random number called a transient export key. When the SKB API  is called by a client application to export data outside the secure processing domain that does not need to be persistent across reboot, a serialized form of the SKB_SecureData may be created. For example, data to be exported, along with information regarding the data type, size, and the like may be exported after encryption by the transient export key. Later, when the client application requests that the exported data be imported back into the SKB, the transient export key may be used to decrypt the exported data.",{"@attributes":{"id":"p-0046","num":"0055"},"figref":"FIG. 3","b":["300","302","112","304"]},"SKB_Cipher","An SKB_Cipher object may encapsulate attributes and parameters used to perform cryptographic operations on SKB_SecureData objects. Particularly, SKB_Cipher objects may be called by client applications through the SKB API  to encrypt or decrypt data. In some embodiments, an SKB_Cipher object may be created by calling an appropriate SKB_Engine. Methods relating to SKB_Cipher objects may include:",{"@attributes":{"id":"p-0048","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SKB_Cipher_ProcessBuffer","Outputs the result of performing a cipher"]},{"entry":[{},"operation on a specified buffer of data"]},{"entry":["SKB_Cipher_Release","Releases a SKB_Cipher object"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"When an SKB_Engine is called to create an SKB_Cipher object, the calling application may indicate whether the cipher operation is an encryption or a decryption operation, the relevant encryption\/decryption algorithm, any flags indicating cipher usage, any parameters required by the algorithm, the SKB_SecureData holding the encryption or decryption key used by the SKB_Cipher method, and\/or the address of a pointer that the method will set to refer to the SKB-Cipher object that is created.","SKB_Transform","An SKB_Transform object may be called by a client application through the SKB API  to perform operations on secret data included in a secure processing domain, such as calculating a digest, signing data, or verifying a signature and returning a result to a client application. Methods relating to SKB_Transform objects may include:",{"@attributes":{"id":"p-0051","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SKB_Transform_AddBytes","Adds caller-supplied bytes to the"]},{"entry":[{},"transform"]},{"entry":["SKB_Transform_AddSecureData","Adds the payload of an"]},{"entry":[{},"SKB_SecureData object to the"]},{"entry":[{},"transform"]},{"entry":["SKB_Transform_GetOutput","Retrieves the result of the transform"]},{"entry":["SKB_Transform_Release","Releases the SKB_Transform object"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The SKB_Transform object may encapsulate attributes and parameters to perform cryptographic operations on and with SKB_SecureData objects. In one embodiment, the SKB_Transform supports any of the cryptographic operations described above. Using the SKB_Transform and SKB_SecureData objects, the underlying SKB API  implementation may operate on secret data as desired using the integral security functions of the secure processor  and\/or the secure processing domain.","Cloaking SKB_SecureData","The SKB API  may support cloaking fields within an SKB_SecureData object. In some embodiments, SKB_Data_Cloak methods may provide mechanisms to process encrypted data that ensconces other secrets. The cloaking mechanism may ensure that secrets continue to be protected by the SKB while enabling a client application operating in the open processing domain to process the decrypted (e.g., encapsulating) data structure. For example, an application may need to process encrypted complex XML content that contains keys or other secrets within child elements. However, merely decrypting the encrypted XML and returning the plaintext to the application would expose these encapsulated secrets.","In some embodiments, cloaked data represents secret data that appears inside a data structure that is cloaked in-place before the data structure is returned to a calling client application executing in an open processing domain. This enables the caller to parse the public part of the data structure and extract the cloaked fields from it in order to feed them back to the SKB API  for performing secure operations. In this manner, the value of the cloaked or secret fields in the data structure may not be revealed to the calling application operating and the security of the secret data contained in these fields is preserved.",{"@attributes":{"id":"p-0055","num":"0064"},"figref":"FIG. 4","ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["(a) The calling application passes an encrypted data structure containing secret fields .","(b) The SKB decrypts this data structure , locates the secret fields, and replaces them in-situ (no size change) with a new field containing enough information for the SKB to reconstruct or regain access to this secret data later .","(c) The application obtains the decrypted data structure with the cloaked fields. It can parse and process this data structure and calls the SKB API  to create an SKB_Data object for the cloaked secrets ."]}}}},"The client application can now have the SKB perform any operations and transformations on the decrypted data structure that require use of the cloaked secret data.",{"@attributes":{"id":"p-0057","num":"0069"},"figref":"FIG. 5","b":"500"},"The exemplary system  may comprise a general purpose computing device such as a personal computer or a network server, or a specialized computing device such as a cellular telephone, personal digital assistance, portable audio or video player, television set-top box, kiosk, gaming system, other embedded device, or the like. As illustrated in , the system  may include: a processing unit ; system memory , which may include high speed random access memory (RAM), non-volatile memory (ROM), and\/or one or more bulk non-volatile computer-readable storage mediums (e.g., a hard disk, flash memory, etc.) for storing programs and other data for use and execution by the processing unit ; a port  for interfacing with removable memory  that may include one or more diskettes, optical storage mediums (flash memory, thumb drives, USB dongles, compact discs, DVDs, etc) and\/or other computer-readable storage mediums; a network interface  for communicating with other systems via a network  such as, for example, the Internet, a local area network, a virtual private network, and the like using one or more communication technologies (e.g., wireless, Ethernet, and\/or the like); a user interface  that may include a display and\/or one or more input devices such as, for example, a touchscreen, a keyboard, a mouse, a track pad, and the like; and one or more busses  for communicatively coupling the elements of the system .","In some embodiments, the system  may, alternatively or in addition, include a secure processing unit (\u201cSPU\u201d)  that is protected from tampering by a user of system  or other entities by utilizing secure physical and\/or virtual security techniques. An SPU  can help enhance the security of sensitive operations such as key management, signature verification, and other aspects of the digital rights management process. In certain embodiments, the SPU  may operate in a logically secure processing domain and be configured to protect and operate on secret information as described herein. In some embodiments, the SPU  may include internal memory storing executable instructions or programs configured to enable to the SPU  to perform secure operations as described herein.","The operation of the system  may be generally controlled by a processing unit  and\/or  operating by executing software instructions and programs stored in the system memory  (and\/or other computer-readable media, such as removable memory ). The system memory  may store a variety of executable programs or modules for controlling the operation of the system . For example, the system memory  may include an OS  that may manage and coordinate in part system hardware resources and provide for common services for execution of various applications and a DRM engine  for implementing DRM functionality. The system memory  may further include communication software  configured to enable in part communication within and by the system , applications  (e.g., media applications), and data and\/or content .","The systems and methods disclosed herein are not inherently related to any particular computer or other apparatus and may be implemented by a suitable combination of hardware, software, and\/or firmware. Software implementations may include one or more computer programs comprising executable code\/instructions that, when executed by a processor, may cause the processor to perform a method defined at least in part by the executable instructions. The computer program can be written in any form of programming language, including compiled or interpreted languages, and can be deployed in any form, including as a standalone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. Further, a computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network. Software embodiments may be implemented as a computer program product that comprises a non-transitory storage medium configured to store computer programs and instructions, that when executed by a processor, are configured to cause the processor to perform a method according to the instructions. In certain embodiments, the non-transitory storage medium may take any form capable of storing processor-readable instructions on a non-transitory storage medium. A non-transitory storage medium may be embodied by a compact disk, digital-video disk, a magnetic tape, a Bernoulli drive, a magnetic disk, a punch card, flash memory, integrated circuits, or any other non-transitory digital processing apparatus memory device.","Although the foregoing has been described in some detail for purposes of clarity, it will be apparent that certain changes and modifications may be made without departing from the principles thereof. It should be noted that there are many alternative ways of implementing both the processes and apparatuses described herein. Accordingly, the present embodiments are to be considered as illustrative and not restrictive, and the invention is not to be limited to the details given herein, but may be modified within the scope and equivalents of the appended claims.","An illustrative example of code implementing an SKB API consistent with embodiments of the present disclosure is provided below:",{"@attributes":{"id":"p-0064","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/** Secure Key Box **\/"},{"entry":"#ifndef _SKB_SECURE_KEY_BOX_H"},{"entry":"#define _SKB_SECURE_KEY_BOX_H"},{"entry":"#define SKB_API_VERSION_MAJOR 0"},{"entry":"#define SKB_API_VERSION_MINOR 1"},{"entry":"#define SKB_API_VERSION_REVISION 0"},{"entry":"#define SKB_API_VERSION_STRING \u201c0.1.0\u201d"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SKB_DATA_FLAG_KEY_USAGE_UNWRAP","1 \/*<< Can be used to unwrap wrapped data*\/"]},{"entry":["#define SKB_DATA_FLAG_KEY_USAGE_ENCRYPTION","2 \/*<< Can be used with an SKB_Cipher for encryption *\/"]},{"entry":["#define SKB_DATA_FLAG_KEY_USAGE_DECRYPTION","4 \/*<< Can be used with an SKB_Cipher for decryption *\/"]},{"entry":["#define SKB_DATA_FLAG_EXTERNAL_DATA","8 \/*<< Data comes from external cleartext *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define SKB_SUCCESS 0"},{"entry":"#define SKB_FAILURE (\u22121)"},{"entry":"#define SKB_ERROR_BASE (\u221280000)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SKB_ERROR_INTERNAL","((SKB_ERROR_BASE) \u2212 1)"]},{"entry":["#define SKB_ERROR_INVALID_PARAMETERS","((SKB_ERROR_BASE) \u2212 2)"]},{"entry":["#define SKB_ERROR_NOT_SUPPORTED","((SKB_ERROR_BASE) \u2212 3)"]},{"entry":["#define SKB_ERROR_OUT_OF_RESOURCES","((SKB_ERROR_BASE) \u2212 4)"]},{"entry":["#define SKB_ERROR_BUFFER_TOO_SMALL","((SKB_ERROR_BASE) \u2212 5)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef int SKB_Result;"},{"entry":"typedef unsigned char SKB_Byte;"},{"entry":"typedef unsigned int SKB_Size;"},{"entry":"typedef struct {"},{"entry":"\u2003struct {"},{"entry":"\u2003\u2003unsigned int major;"},{"entry":"\u2003\u2003unsigned int minor;"},{"entry":"\u2003\u2003unsigned int revision;"},{"entry":"\u2003} api_version;"},{"entry":"\u2003const char* name;"},{"entry":"\u2003unsigned int flags;"},{"entry":"} SKB_EngineInfo;"},{"entry":"typedef enum {"},{"entry":"\u2003SKB_DATA_TYPE_BYTES,"},{"entry":"\u2003SKB_DATA_TYPE_SYMMETRIC_KEY,"},{"entry":"\u2003SKB_DATA_TYPE_RSA_PRIVATE_KEY,"},{"entry":"\u2003SKB_DATA_TYPE_RSA_PUBLIC_KEY,"},{"entry":"\u2003SKB_DATA_TYPE_DH_PUBLIC_KEY,"},{"entry":"\u2003SKB_DATA_TYPE_DH_PRIVATE_KEY"},{"entry":"} SKB_DataType;"},{"entry":"typedef struct {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003SKB_DataType type;","\/** Data type *\/"]},{"entry":["\u2003unsigned int flags;","\/** Data flags *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SKB_DataInfo;"},{"entry":"typedef enum {"},{"entry":"\u2003SKB_TRANSFORM_TYPE_DIGEST_SHA1,"},{"entry":"\u2003SKB_TRANSFORM_TYPE_DIGEST_SHA256,"},{"entry":"\u2003SKB_TRANSFORM_TYPE_DIGEST_MD5,"},{"entry":"\u2003SKB_TRANSFORM_TYPE_TLS_RECORD"},{"entry":"} SKB_TransformType;"},{"entry":"typedef enum {"},{"entry":"\u2003SKB_CIPHER_ALGORITHM_NULL,"},{"entry":"\u2003SKB_CIPHER_ALGORITHM_AES_128_ECB,"},{"entry":"\u2003SKB_CIPHER_ALGORITHM_AES_128_CBC,"},{"entry":"\u2003SKB_CIPHER_ALGORITHM_AES_128_CTR,"},{"entry":"\u2003SKB_CIPHER_ALGORITHM_RSA_1_5,"},{"entry":"\u2003SKB_CIPHER_ALGORITHM_RSA_OAEP"},{"entry":"} SKB_CipherAlgorithm;"},{"entry":"typedef enum {"},{"entry":"\u2003SKB_CIPHER_DIRECTION_ENCRYPT,"},{"entry":"\u2003SKB_CIPHER_DIRECTION_DECRYPT"},{"entry":"} SKB_CipherDirection;"},{"entry":"typedef enum {"},{"entry":"\u2003SKB_DATA_FORMAT_RAW,"},{"entry":"\u2003SKB_DATA_FORMAT_PKCS8"},{"entry":"} SKB_DataFormat;"},{"entry":"#if defined(_cplusplus)"},{"entry":"extern \u201cC\u201d {"},{"entry":"#endif"},{"entry":"\/** @defgroup SKB_Datan SKB_Data Class * @{ *\/"},{"entry":"\/**An SKB_Data object represents secret data that cannot be accessed directly by the caller. Secret"},{"entry":"data is typed: it can represent cipher keys as well as arbitrary byte sequences.**\/"},{"entry":"typedef struct SKB_Datan SKB_Data;"},{"entry":"\/** An SKB_Transform object represents a data transform. The purpose of such transforms is to be able"},{"entry":"to transform data supplied by the caller as well as secret data and return to the caller the output"},{"entry":"of the transform, which does not reveal any of the secret data used as input to the transform. **\/"},{"entry":"typedef struct SKB_Transform SKB_Transform;"},{"entry":"\/**An SKB_Cipher object can encrypt or decrypt data supplied by the caller.**\/"},{"entry":"typedef struct SKB_Cipher SKB_Cipher;"},{"entry":"\/** @defgroup SKB_Cloak SKB_Cloak Class * @{ *\/"},{"entry":"\/*An SKB_Cloak object manages cloaked data. Cloaked data is secret data that appears inside a data"},{"entry":"structure and cloaked in-place before the data structure is returned to the caller. This enables the"},{"entry":"caller to parse the public part of the data structure and extract the cloaked fields from it in order"},{"entry":"to feed them back to the engine and obtain a data object in return. This way, the value of the secret"},{"entry":"fields in the data structure is never revealed to the caller.*\/"},{"entry":"typedef struct SKB_Cloak SKB_Cloak;"},{"entry":"\/** @defgroup SKB_Engine SKB_Engine Class * @{ *\/"},{"entry":"\/**An SKB_Engine object represents an instance of an engine that can manage and operate n secret data"},{"entry":"that cannot be accessed by the caller.**\/"},{"entry":"typedef struct SKB_Engine SKB_Engine;"},{"entry":"\/** Obtain an engine instance.\u2003\u2002This instance can be released by calling SKB_Engine_Release when no"},{"entry":"longer needed. **\/"},{"entry":"SKB_Result"},{"entry":"SKB_GetEngine(SKB_Engine** engine);"},{"entry":"\/** Release an SKB_Engine object.\u2003\u2002The object can no longer be used by the caller after this call"},{"entry":"returns.\u2003\u2002All SKB_Data objects returned by this engine can be released before"},{"entry":"calling this method.\u2003\u2002@param self The SKB_Engine to release. **\/"},{"entry":"SKB_Result"},{"entry":"SKB_Engine_Release(SKB_Engine* self);"},{"entry":"SKB_Result"},{"entry":"SKB_Engine_GetInfo(const SKB_Engine* self, SKB_EngineInfo* info);"},{"entry":"\/**Obtain a named data object from an SKB_Engine object.\u2003\u2002@param self The SKB_Engine to obtain the"},{"entry":"data object from. @param name The name of the data object to obtain.\u2003\u2002@param data Address of a"},{"entry":"pointer to an SKB_Data object where the object pointer will be returned.\u2002@result SKB_SUCCESS if the"},{"entry":"data object was found, SKB_ERROR_NO_SUCH_ITEM if no such data object exists, or another error code if"},{"entry":"the call could not be completed successfully. **\/"},{"entry":"SKB_Result"},{"entry":"SKB_Engine_GetDataByName(SKB_Engine* self, const char* name, SKB_Data** data);"},{"entry":"SKB_Result"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["SKB_Engine_CreateDataFromWrapped(SKB_Engine*","self,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"const SKB_Byte*","wrapped,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SKB_Size","wrapped_size,"]},{"entry":[{},"SKB_DataType","wrapped_type,"]},{"entry":[{},"SKB_DataFormat","wrapped_format,"]},{"entry":[{},"SKB_CipherAlgorithm","wrapping_algorithm,"]},{"entry":[{},"const SKB_Data*","wrapping_key,"]},{"entry":[{},"SKB_Data**","data);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SKB_Result",{}]},{"entry":["SKB_Engine_CreateDataFromExported(SKB_Engine*","self,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003const SKB_Byte*","exported,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003SKB_Size","exported_size,"]},{"entry":[{},"SKB_Data**","data);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SKB_Result",{}]},{"entry":["SKB_Engine_CreateDataFromFrozen(SKB_Engine*","self,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"const SKB_Byte*","frozen,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SKB_Size","frozen_size,"]},{"entry":[{},"SKB_Data**","data);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**Create an SKB_Data object with random bytes.\u2003\u2002The object will have the data type"},{"entry":"SKB_DATA_TYPE_BYTES. **\/"},{"entry":"SKB_Result"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["SKB_Engine_CreateDataFromRandom(SKB_Engine*","self,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002SKB_Size","size,"]},{"entry":[{},"\u2002SKB_Data**","data);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**Creates an SKB_Transform object **\/"},{"entry":"SKB_Result"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["SKB_Engine_CreateTransform(SKB_Engine*","self,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SKB_TransformType","type,"]},{"entry":[{},"void*","params,"]},{"entry":[{},"SKB_Transform**","transform);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/** Creates an SKB_Cipher object **\/"},{"entry":"SKB_Result"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["SKB_Engine_CreateCipher(SKB_Engine*","self,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SKB_CipherAlgorithm","type,"]},{"entry":[{},"SKB_CipherDirection","direction,"]},{"entry":[{},"SKB_Data*","key,"]},{"entry":[{},"SKB_Cipher**","cipher);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/** @ingroup SKB_Cloak\u2003@{ *\/"},{"entry":"SKB_Result"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["SKB_Cloak_CreateData(SKB_Cloak*","self,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const SKB_Byte*","cloaked_data,"]},{"entry":[{},"SKB_Size","cloaked_data_size,"]},{"entry":[{},"SKB_Data**","data);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SKB_Result"},{"entry":"SKB_Cloak_Release(SKB_Cloak* self);"},{"entry":"\/** @ingroup SKB_Data * @{ *\/"},{"entry":"\/**Release an SKB_Data object. The object can no longer be used by the caller after this call"},{"entry":"returns.\u2002@param self The SKB_Data to release.**\/"},{"entry":"SKB_Result"},{"entry":"SKB_Data_Release(SKB_Data* self);"},{"entry":"\/**Get information about the data represented by an SKB_Data object.\u2003\u2002@param self The SKB_Data whose"},{"entry":"info is obtained. **\/"},{"entry":"SKB_Result"},{"entry":"SKB_Data_GetInfo(const SKB_Data* self, SKB_DataInfo* info);"},{"entry":"\/**Get the exported serialized payload of an SKB_Data object.\u2003Data in an exported form can be stored"},{"entry":"and reloaded at a later time in the the same or different SKB_Engine, as long as the SKB_Engines are"},{"entry":"considered to be compatible (they can share some common state, which typically does not persist"},{"entry":"across a CPU or security processor shutdown or reset.)\u2003@param self The SKB_Data whose frozen"},{"entry":"serialized payload is obtained. @param buffer Memory buffer where the exported data is to be"},{"entry":"written. The memory buffer must be large enough to hold the number of bytes specified by the"},{"entry":"buffer_size parameter.\u2003If buffer_size points to a zero value, this parameter may be NULL. @param"},{"entry":"buffer_size Pointer to the size of the memory buffer.\u2003This parameter is in\/out: the caller sets the"},{"entry":"value pointed to to the size of the memory buffer, and upon return the value pointed to will be equal"},{"entry":"to the number of bytes written (or the number of bytes that would be written, if the value passed was"},{"entry":"too small).\u2003@return SKB_SUCCESS if the call succeeds, SKB_ERROR_BUFFER_TOO_SMALL if there is not"},{"entry":"enough space in the buffer to write the exported data, or a different error code if some other"},{"entry":"failure occurred. **\/"},{"entry":"SKB_Result"},{"entry":"SKB_Data_Export(const SKB_Data* self, SKB_Byte* buffer, SKB_Size* buffer_size);"},{"entry":"\/**Get the frozen serialized payload of an SKB_Data object. Data in a frozen form can be stored and"},{"entry":"reloaded at a later time in the the same or different SKB_Engine instance, even after a complete"},{"entry":"shutdown or reset of the CPU or security processor.\u2003@param self The SKB_Data whose frozen serialized"},{"entry":"payload is obtained. * *\/"},{"entry":"SKB_Result"},{"entry":"SKB_Data_Freeze(const SKB_Data* self, SKB_Byte* buffer, SKB_Size* buffer_size);"},{"entry":"\/** Get the cloaked payload of an SKB_Data object and an SKB_Cloak object that can be used"},{"entry":"subsequently to uncloak the data. Only data of the following types can be cloaked: SKB_DATA_TYPE_XXX"},{"entry":"* @param self The SKB_Data whose cloaked payload is obtained. *\/"},{"entry":"SKB_Result"},{"entry":"SKB_Data_Cloak(const SKB_Data* self, SKB_Byte* buffer, SKB_Cloak** cloak);"},{"entry":"\/** @ingroup SKB_Transform @{ **\/"},{"entry":"\/** Adds caller-supplied bytes to the transform **\/"},{"entry":"SKB_Result"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["SKB_Transform_AddBytes(SKB_Transform* ","self,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"const SKB_Byte*","data,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SKB_Size","data_size);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**Adds the contents of a data object to the transform.\u2003Only data objects of the following types can"},{"entry":"be used: SKB_DATA_TYPE_BYTES * SKB_DATA_TYPE_SYMMETRIC_KEY **\/"},{"entry":"SKB_Result"},{"entry":"SKB_Transform_AddData(SKB_Transform* self, const SKB_Data* data);"},{"entry":"\/**Gets the output size of the transform**\/"},{"entry":"SKB_Size"},{"entry":"SKB_Transform_GetOutputSize(const SKB_Transform* self);"},{"entry":"\/**Get the output of the transform**\/"},{"entry":"SKB_Result"},{"entry":"SKB_Transform_GetOutput(SKB_Transform* self, SKB_Byte* output);"},{"entry":"SKB_Result"},{"entry":"SKB_Transform_Release(SKB_Transform* self);"},{"entry":"\/** @ingroup SKB_Cipher **\/"},{"entry":"SKB_Result"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["SKB_Cipher_ProcessBuffer(SKB_Cipher*","self,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"const SKB_Byte*","in_buffer,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SKB_Size","in_buffer_size,"]},{"entry":[{},"SKB_Byte*","out_buffer,"]},{"entry":[{},"SKB_Size*","out_buffer_size,"]},{"entry":[{},"unsigned\u2002int","flags);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"371pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SKB_Result"},{"entry":"SKB_Cipher_Release(SKB_Cipher* self);"},{"entry":"#if defined(_cplusplus)"},{"entry":"}"},{"entry":"#endif"},{"entry":"#endif \/* _SKB_SECURE_KEY_BOX_H_ *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The inventive body of work will be readily understood by referring to the following detailed description in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
