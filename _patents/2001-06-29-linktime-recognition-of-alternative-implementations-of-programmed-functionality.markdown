---
title: Linktime recognition of alternative implementations of programmed functionality
abstract: A method and apparatus are disclosed for optimizing the runtime behavior of database or other applications by allowing selection of alternative code segments during linking of pre-compiled object modules. A macro-preprocessor inserts a declaration for a global variable in the source code in response to an occurrence of a command of interest. The linker selects object modules for executing other commands based on the presence or absence of the declaration for the global variable in the preprocessed source code. The method and apparatus are useful in implementing programming language statements including non-procedural programming languages such as the Embedded Structured Query Language (ESQL).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07757225&OS=07757225&RS=07757225
owner: Microsoft Corporation
number: 07757225
owner_city: Redmond
owner_country: US
publication_date: 20010629
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates generally to generating an efficient executable corresponding to a program written in a higher-level computer programming language, and more particularly to use indicators that change the executable code to take into account the context in implementing a particular command.","The advent of databases and e-commerce requires the ability to request services from a variety of databases without knowing the exact implementation of the database or of the statements used to request the services. These request statements are made in a non-procedural programming language that does not provide an explicit implementation. Instead, the developers of particular databases or non-procedural programming language statements provide proprietary implementations for the statements rendered in the non-procedural language.","Structured Query Language (\u201cSQL\u201d) is an illustrative example of a non-procedural language. SQL differs from a procedural language like FORTRAN in that it does not specify how a particular request is carried out, but instead allows the database manager to provide the relevant details. Thus, a command in SQL merely states a request and not how it is carried out.","SQL includes: a Data Development Language (\u201cDDL\u201d) for creating databases and data structures, but not necessarily data itself; a Data Manipulation Language (\u201cDML\u201d) facilitating database maintenance and actual operations on data; and a Data Control Language (\u201cDCL\u201d) for specifying security requirements. Some examples of SQL commands include the DDL commands CREATE, ALTER and DROP, DML statements and functions such as INSERT, UPDATE, DELETE, SELECT, COUNT, SUM and the like, and DCL commands such as COMMIT, ROLLBACK, GRANT and REVOKE.","SQL permits interactions with a database in an atomic manner, i.e. only one user may access a unit of data, to prevent other users from changing the database between operations constituting a transaction. The code used to implement these commands and functions is the responsibility of the database developer or vendor. Of course, universal support for SQL commands ensures that any user can access and use a SQL compliant database regardless of the database vendor and particular implementation details.","SQL commands such as COMMIT and ROLLBACK are of interest in an exemplary embodiment of the invention. These SQL commands protect a database against inadvertent corruption. To this end the database itself is not affected until the COMMIT command is given. If an error occurs then a ROLLBACK command restores the state of the system to that at the conclusion of the previous COMMIT command. A transaction is terminated by either a COMMIT command or ROLLBACK command combined with allowing other users access to the data. A ROLLBACK command requires buffering of all operations following a COMMIT command to permit restoration of the state following the COMMIT command.","If the transaction fails or a user cancels a transaction, a ROLLBACK results in clearing the buffered operations and removing access restrictions to restore the database to its state prior to the initiation of the now failed transaction. On the other hand, a COMMIT command results in updating the database followed by clearing of the buffered operations.","Another SQL command, SAVEPOINT, enables restoring the system to an earlier defined state that need not be the state at the conclusion of the previous COMMIT command. Like the COMMIT command in the context of the ROLLBACK command, SAVEPOINT provides a prior state of the system for the ROLLBACK command. Unlike the COMMIT command, however, the SAVEPOINT command does not require changes to the database. Instead SAVEPOINT enables specification of a defined state for system restoration. In some embodiments the SAVEPOINT command specifies multiple earlier states distinguished by their respective identifiers. If desired, the system can be restored to one of the specified earlier states by executing a ROLLBACK to the specified state. If a COMMIT command is given then all buffered operations are cleared along with the states specified by the SAVEPOINT command.","Implementing the SAVEPOINT or ROLLBACK commands requires considerable overhead since other commands must therefore provide buffering. On the other hand, it is not necessary to support buffering if the SAVEPOINT or ROLLBACK commands are not used. A typical application includes SQL statements in several files and a compiler compiles only one file at a time. Thus, it is not possible to decide when compiling a particular file whether buffering-related code is needed due to a statement in another file.","SQL applications written using SQL statements and functions can be combined with source code in a programming language such as C++ in Embedded SQL (\u201cESQL\u201d). An ESQL application can include several source code files. The source files for an ESQL application are preprocessed by a macro-preprocessor. Typically, the macro-preprocessor generates code for the various embedded SQL statements or introduces additional statements followed by a compiler compiling the output of the macro-preprocessor. Compiling a source file generates an object module corresponding to the source file. The linker links object modules to generate the executable program.","Compiling a source code file includes several operations. A compiler parses the source code, carries out several checks to ensure conformity with the programming language specifications and then translates the parsed code to generate a lower level code such as machine code for execution on a computer. In some instances, the code is assembly or byte code that needs further translation for actual execution on a particular computer. A compiler allocates memory for each variable to properly translate source code to generate executable code. The compiler allocates memory for each variable in accordance with a \u201ctype\u201d specification for the variable in question.","Type information is specified in a \u201cdeclaration\u201d statement. Each variable is assigned a particular type. The compiler enters the type information for each variable into a symbol table associated with an object module. When several object modules in the same executable share a variable it is important to ensure that only one module actually allocates memory for the variable. The compiler allocates memory in response to a \u201cdefinition\u201d statement for a particular variable. However, the declaration and\/or definition statements are allowed to be implicit in many programming languages.","The \u201cC\u201d programming language permits an \u201cextern\u201d declaration in a source file that tells the compiler that memory for the specified variable is allocated in another file. Consequently, a C compiler only creates a variable entry in the symbol table that serves as a place holder for the variable but leaves the actual memory allocation to another file. The variable merely points to its entry in the symbol table and is redirected to the actual memory allocation following identification of the intended memory location. Thus, there are several declarations for a variable but there can be only one definition. No value can be assigned to a variable unless the variable is defined because there is no memory allocated to store it.","Following compilation, a linker links the resultant object files to generate the executable for the application. The linking may be static or dynamic. In static linking the object files identified by the linker for the resolution of all variables are copied to generate an executable file. In contrast, dynamic linking allows fetching an object file at either load time or at runtime. Consequently, the same object module is used by several applications. As is evident, typically dynamic linking results in lower memory requirements and smaller executable sizes. Furthermore, a programmer can modify and recompile a dynamically-linked module independent of another module, thus making software maintenance easier and less expensive.","Declaring a variable with an \u201cextern\u201d keyword requires the linker to identify the actual memory allocated for the variable in other object modules. To this end the linker searches symbol tables associated with object modules or libraries for a module providing a definition for the variable in question. This process is termed resolving the variable. Proper resolution of a variable is required before it can actually be used in an executable file.","In software development projects a software application is refined over the life of the project. Through the development process, concepts concerning various problems and solutions are often revised, and the functions and features of the final software application are often quite different from those at the beginning of the project. Support for additional features supporting execution of other statements in a non-procedural language statement reduces the execution efficiency of programs that do not use these additional features. On the other hand, adding distinct commands to provide the additional features results in complex programming languages with many statements differing only in the context in which they should be used. For example, if there is at least one command that requires buffering prior changes to a database in an SQL-based application, then implementations of other commands affecting the database need to support buffering. On the other hand, if no command requiring buffering is used in an application then the program overhead for buffering unnecessarily slows down the application.","As a programming language evolves to develop specific commands for a particular context, developers have to learn different commands for accomplishing similar tasks rather than preserving their existing familiarity with the programming tool. Similar sounding commands that differ in subtle but significant details increase the risk that a programmer inadvertently uses the less effective command. Such errors are difficult to identify since some may only sporadically result in bugs. Therefore, it is desirable to have a system and method for providing contextually efficient implementations for a programming language command that can be invoked automatically without requiring the programmer to use different commands to invoke optimized implementations for different contexts.","In view of the foregoing, the present invention provides a method and system for selecting one of several implementations of a higher level programming language statement in response to the occurrence or non-occurrence of another statement in a computer program. The invention enables transparent selection of contextually efficient code. Thus, users and developers need not use different higher language statements to invoke a context-specific implementation.","A macro-preprocessor enables choosing a context sensitive implementation for a higher language statement. The macro-preprocessor introduces a first global variable declaration in response to identifying a specific context. In an embodiment, the specific context is defined by the presence of one or more specified statements in a source file processed by the macro-preprocessor. In an embodiment of the invention, the first global variable enables setting a desired value for a second variable by introducing the second variable in a first object module supplying the definition for the first global variable. This strategy provides for a level of indirection to include the first object module in response to identifying a specified context. In the event the linker does not include the first object module, an alternative definition for the second variable is provided in a second object module.","In an embodiment of the invention a linker library object module is loaded using a wrapper based upon the first global variable. Moreover, an embodiment of the invention enables conditionally executing a first program sequence in response to the second variable value specifying a context of interest.","For instance, the need to support the underlying implementation of a RESTORE command may require a DELETE command to include buffering deleted data. However, if no RESTORE command is used in a program then there is no need to incur the overhead of buffering extensive information in the implementation of the DELETE command.","It should be noted that the invention, while illustrated with SQL, is not limited to SQL or even non-procedural languages, but instead includes higher-level languages and scripts. Such higher-level languages and scripts can benefit from using different binary, byte-code or macro implementations for the same command depending on a particular context.","Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments, which proceeds with reference to the accompanying figures.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed in a computing environment. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general-purpose or special-purpose computing system environments or configurations. Examples of well-known computing systems, environments, and configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and distributed computing environments that include any of the above systems or devices.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general-purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus, also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and include both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media may include computer storage media and communications media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media include, but are not limited to, random-access memory (RAM), read-only memory (ROM), EEPROM, flash memory, or other memory technology, CD-ROM, digital versatile disks (DVD), or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage, or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communications media typically embody computer-readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communications media include wired media such as a wired network and a direct-wired connection and wireless media such as acoustic, RF, and infrared media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and nonvolatile memory such as ROM  and RAM . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and program modules that are immediately accessible to or presently being operated on by processing unit . By way of example, and not limitation,  illustrates an operating system , application programs , other program modules , and program data . Often, the operating system  offers services to applications programs  by way of one or more application programming interfaces (APIs) (not shown). Because the operating system  incorporates these services, developers of applications programs  need not redevelop code to use the services. Examples of APIs provided by operating systems such as Microsoft's \u201cWINDOWS\u201d are well known in the art.","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk interface  that reads from and writes to non-removable, nonvolatile magnetic media, a magnetic disk drive , which may be internal or external, that reads from and writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from and writes to a removable, nonvolatile optical disk  such as a CD ROM. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, DVDs, digital video tape, solid state RAM, and solid state ROM. The hard disk drive , which may be internal or external, is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer-readable instructions, data structures, program modules, and other data for the computer . In , for example, hard disk drive  is illustrated as storing an operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from the operating system , application programs , other program modules , and program data . The operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that they may be different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball, or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, and scanner. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device, or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user-input interface , or via another appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device , which may be internal or external to the remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains them at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data are maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.","An embodiment of the present invention illustrated in  enables a software developer to efficiently develop applications suitable for particular applications, including those for accessing, managing and otherwise utilizing databases. During step  a programmer or developer generates program code comprising procedural and non-procedural programming languages. Examples of suitable programming languages include ESQL that allows embedding SQL commands in programs written in the C programming language. The program code is pre-processed by a macro-preprocessor during step . During step  the macro-preprocessor examines the source code for an occurrence of one or more specified statements. During step  any one of the specified statements is detected. Then the macro-preprocessor introduces a declaration for a first variable that is explicitly not defined. In the case of ESQL the first variable is declared using the \u201cextern\u201d key word to indicate to a compiler that no storage should be allocated since it would be allocated in another module. The macro-preprocessor also inserts statements that are in the form of function calls compliant with the Open Data Base Connectivity (\u201cODBC\u201d) standard during step , but may include other mechanisms. Step  provides the proprietary implementations for a particular database since, as explained earlier, the actual implementation of a non-procedural language statement is not specified.","During step  a compiler converts the macro-preprocessor output to low-level instructions. Next, during step  a linker starts to resolve references using a library having a first object module that includes a definition for the first variable introduced by the macro-preprocessor at step . If the linker detects during step  that the variable introduced by the macro-preprocessor has to be resolved then control transfers to step . During step  the linker links the first object module having a definition for the declared variable introduced by the macro-preprocessor from the appropriate library. On the other hand, during step  if the linker does not detect the variable introduced by the macro-preprocessor then control is transferred to step . During step  the linker does not link in the first object module since the first variable does not need to be resolved. As is readily apparent, the presence or absence of the first module in the executable is strictly dependent on the presence or absence of the specified statement tested in step .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 3","FIG. 3","FIG. 2"],"b":["300","305","225","230","305","310","310"]},"If the linker does not encounter a declaration for the first variable, i.e., the macro-preprocessor did not detect the specified statement, then there is no first variable to resolve and control passes to step  from step . During step , the linker bypasses the first module because the first variable does not have to be resolved. During step  the linker includes a second object module to carry out a command, such as a DELETE command, in the source code. If the second object module includes a declaration for the second variable without a definition, as determined in step , then the control shifts to step .","The determination of the second variable declaration during step  results from the second variable's presence in a symbol table for the second object module and the absence of a corresponding memory allocation. During step  the linker continues to scan the linker libraries in an effort to resolve the second variable. Step  includes inclusion of a third module by the linker to resolve the second variable. The third object module, that is also the last module in the linker library, provides a definition setting a default value, e.g., 0, for the second variable. This value is in contrast with the non-default value set in the first object module. The linker did not include the first module since the first object module was encountered prior to the entry of the unresolved reference to the second variable included during step .","It should be noted that while the linker encounters the first module prior to the second module, the third object module is encountered after the second module. On the other hand, during step  if the linker does not detect a second variable to be resolved, then control passes to step . During step  the linker continues without resolving the second variable or including the third object module.","A software application includes one or more object modules that often correspond to source code files as is shown in . A software program  has one or more source files  corresponding to the object modules. Some of the source files include commands in a higher-level language, such as function calls or even instructions in scripted language. Code corresponding to each of these commands is substituted to actually implement the instruction. Thus, a macro-preprocessor  converts the computer program  having files  in  to yield preprocessed program code comprising files  and possibly additional statements  in a compilable language.","An example of such a system is the SQL language and its extension in ESQL. SQL ensures that some standardized tasks can be performed without locking users into particular implementations. ESQL enables embedding SQL statements in one or more higher-level languages. A macro-preprocessor replaces the embedded SQL statements by implementation-specific code compiled along with the higher-level language statements. Thus, an exemplary ESQL processor works by reading C language statements with interspersed Structured Query Language (SQL) statements. The SQL statements are converted into Open Database Connectivity (ODBC) compliant calls. The resulting source code is compiled and linked. For illustration purposes,  shows the result of compiling the preprocessed program code  by compiler  to generate object code. This object code includes, in the various object modules contained therein, unresolved references , compiled code  corresponding to the files  and the compiled macro-preprocessor introduced statements .","This object code is subsequently, acted upon by a linker . Linker  supplies additional object modules to resolve unresolved references  by providing object code from libraries  and additional object files  that are included by the user. The linker  also ensures that the different object modules have the proper offsets relative to each other to allow execution of a single executable . The executable  is executed in an environment similar to computing environment .","In an embodiment of the present invention, a first statement, such as SAVEPOINT, in a program requires a different implementation for a second statement such as DELETE. Two possible implementations for the second statement independently designate performance characteristics at runtime. These implementations are provided in different object modules corresponding to the same instruction or statement. Thus, it is desirable that the code that actually implements the additional program instructions including the second statement should be sensitive to the occurrence or non-occurrence of the first statement.","Instead of requiring developers to examine all source code files to discover an occurrence of the first statement, a macro-preprocessor discovers an occurrence of the first statement. The macro-preprocessor is designed to respond to a context defined by the occurrence or non-occurrence of one or more statements of interest. Furthermore, modified linker libraries include object modules for resolving variables introduced by the macro-preprocessor. Additional modifications to the linker libraries allow object modules in the linker libraries to use one or more of the global variables representing a context while selecting code for execution at runtime.","Exemplary embodiments in accordance with the invention are described herein below without intending to limit the invention to these embodiments. In an embodiment of the invention the fact that a variable that is declared but not defined is set to default value, e.g., 0, is used to select code for execution. Thus, if the variable is given a non-default value upon encountering a statement of interest then code relevant to the statement of interest is executed. Selecting code based on the value of the variable results in faster code although without reduction in the footprint of the executable. The following pseudo-code illustrates such a variable to conditionally execute a code segment:","IF (_FIRST_STATEMENT_DETECTED==0) THEN","{Execute efficient code for implementing second statement because the first statement is not being used}","ELSE","{Execute the code with the overhead for implementing the second statement because the first statement was detected}","END","The variable _FIRST_STATEMENT_DETECTED is declared and defined in a statement introduced by the macro-preprocessor if the macro-preprocessor encounters the first statement in any of the program files.","In the context of ESQL the implementation of the SQL statement, SAVEPOINT, provides an illustration of a global variable to flag a particular context. SAVEPOINT allows restoration of an earlier state, i.e., undoing a set of operations on a database. Therefore, if SAVEPOINT is used then the various state defining parameters need to be saved as other commands\/statements are executed. Upon detecting SAVEPOINT the ESQL processor injects a declaration into the C stream of the form:\n\n","The \u201cextern\u201d keyword informs the compiler that storage for _OCC_SAVEPOINT_USED is allocated in another file. Therefore, the compiler does not initialize _OCC_SAVEPOINT_USED. The linker uses two or more libraries such that the first library used by the linker contains as its first object module compiled code corresponding to the source code:\n\n","and the second library contains in its last object module compiled code corresponding to the source code:\n\n","In the linking process, if the macro-preprocessor injects a declaration for variable _OCC_SAVEPOINT_USED, the linker includes the first object module to provide a definition. The first object module provides a declaration and a value for _OCC_SAVEPOINT_ENABLED as illustrated. Subsequently, other object modules in the library include instructions that test variable _OCC_SAVEPOINT_ENABLED to flag whether SAVEPOINT has been used in any of the source files. If _OCC_SAVEPOINT_ENABLED is set, processing for SAVEPOINT will proceed. If _OCC_SAVEPOINT_USED is not set, the other object modules will not incur processing for SAVEPOINT.","In another embodiment of the invention, any program object module using the SAVEPOINT feature includes the declaration:\n\n","A variable declaration assumes that upon first encountering the variable the compiler sets the variable to zero by default unless the contrary is indicated. However, this is not a requirement. And, multiple declarations in other object modules are harmless. The linker uses a library containing an object module having compiled code corresponding to the following code:\n\n","The macro-preprocessor declares _OCC_SAVEPOINT_NOT_USED resulting in the linker including the library object module setting _OCC_SAVEPOINT_NOT_USED to 1 only if _OCC_SAVEPOINT_NOT_USED is not declared elsewhere in the main program. (Note carefully the logical NOT: if the variable is not used in the main program, it is set to one or TRUE.) Then any other object module in the library can test _OCC_SAVEPOINT_NOT_USED to decide if SAVEPOINT is used in any module in the program.","In another embodiment of the invention, a program object module using the SAVEPOINT feature will include a series of declarations having a global scope:\n\n","The first object module in the library contains compiled code corresponding to\n\n",". . . and so on up to the number of separate object modules containing code dedicated for implementing SAVEPOINT. Each of the separate object modules for implementing SAVEPOINT contain a matching definition\n\n","The first object module is included in the executable program In this way, those object modules containing code for SAVEPOINT can be included in the executable when required.","The invention uses well known rules for preprocessing, compiling and linking computer programs, particularly programs using the C or C++ programming language to improve the development of application programs. It provides a method for developing a computer program using a non-procedural programming language. The method includes declaring at least one first variable in a first source file responsive to detecting a first statement conforming to the non-procedural programming language. A macro-preprocessor examining the source code introduces a declaration statement for the first variable. A compiler compiles the first source file to generate a first object module followed by linking using at least one library. The linker includes a second object module containing a definition for the first variable to resolve the first variable. The second object module includes access to code to support implementation of the first statement. This access includes references to functions that are invoked by other statements to ensure proper execution of the first statement.","Furthermore, an additional non-procedural programming language is used to provide a third statement conforming to the additional non-procedural programming language.","The flowchart in  describes an embodiment of the invention that enables including object modules from linker libraries to support additional overhead in the implementation of a DELETE statement. The additional overhead is required by the execution of one or more additional specified statements such as SAVEPOINT. In step  a computer program having the DELETE non-procedural programming language statement is pre-processed. However, the additional buffering overhead needs to be incurred only if the SAVEPOINT command or the ROLLBACK command is used in the computer program.","To flag the need for incurring an overhead the pre-processor introduces a declaration for a variable _VAR as being an \u201cextern\u201d upon encountering a ROLLBACK or SAVEPOINT statement during step . Declaring the variable to be \u201cextern,\u201d in a C like programming language, informs the compiler that the variable definition is in another file external to the file being compiled. Consequently, the compiler does not initialize the variable during compilation in step .","Following compilation, the object files generated by the compiler during step  are linked in step  using a linker program that resolves variable references in the object files. The linker detects if _VAR lacks a definition during step . If _VAR lacks a definition then the linker resolves _VAR by examining the linker libraries for an object module having a definition for _VAR, i.e., specifying memory for _VAR. A value for a variable can be specified only after memory allocation for storing the variable value. During step  the linker encounters a first linker library Vhaving an object module Mthat provides a definition setting _VAR to 1 along with a definition setting an additional global variable _VAR to a non-default value of 1. During step  inclusion of object module Mby the linker results in automatically including _VAR in a symbol table for the program being created by the linker. Other object modules included by the linker can include instructions to test the value of _VAR to detect if object module Mhas been included. Notably, _VAR does not occur in the computer program, but is used in one or more of the additional object modules included in the linker libraries.","In the absence of an unresolved occurrence of _VAR in the pre-processed code, the linker does not include object module M. Instead control is transferred to step . During step , the occurrence of _VAR in other object modules included by the linker results in the linker including an object module Mto provide a declaration for _VAR. The object module Mand Mcan be given the same name but are not in the same linker library, V. Thus, the linker includes only one of modules Mor M. In other words, the linker includes object module Mprior to encountering object module Mif a SAVEPOINT or ROLLBACK command is encountered. Otherwise, object module Mis included, thus precluding any need to include object module M(step ). The executable constructed by this procedure differs in its size based on whether SAVEPOINT or ROLLBACK commands are being used.",{"@attributes":{"id":"p-0081","num":"0091"},"figref":["FIG. 6","FIG. 6"],"b":["600","605","610","605","615","600","630","620","625","1","640","650","615","600","615","645","655"],"sub":["1 ","1 ","2 "]},{"@attributes":{"id":"p-0082","num":"0092"},"figref":"FIG. 7","b":["1","2","700","705","1","710","715","720","725","710","715"]},"Following compilation, the linker does not locate a definition of _VAR because it does not occur elsewhere in the computer program. Consequently, during step , which follows step , the linker does not include the first object module M. Object module Mhas a definition for _VAR and a declaration and definition setting another variable _VAR to a non-default value where _VAR is found in object modules in the linker libraries but not in the computer program. On the other hand, introduction of _VAR by the macro-preprocessor results in the inclusion of object module Mby the linker during step , which follows step , since the linker encounters the object module Mprior to the object module M. Note that object module Mis the last object module in each linker library used by the linker and introduces a default value, such as 0 for _VAR.","Following inclusion of object module Mthe linker does not include object module M. In contrast, since object module Mincludes a definition of _VAR, it is included if object module Mis not included to resolve references to _VAR in other object modules. Thus, the inclusion of Mand Mby the linker is on a mutually exclusive basis. Mprovides access to code supporting added functionality required by the statement AA if statement BB occurs in the computer program. M, on the other hand, has no such functionality.","In an embodiment of the invention, an application uses a global variable to alter its behavior based on the use or non-use of a feature. Because the detection of the value of the global variable's value occurs at run-time, the code supporting both cases is linked into the application as illustrated below:",{"@attributes":{"id":"p-0086","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (_FEATURE_XYZ_USED) {\/* Or, if(!_FEATURE_XYZ_NOT_USED) *\/"},{"entry":"do_thing_the_XYZ_way( );"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {\u2003\u2003\/* feature XYZ not used *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"do_thing_the_other_way( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The application is not linked against either library. Instead, statically linked wrappers with those function names are provided. These wrappers explicitly load the correct library and obtain the address of the requested function within that library. Thereafter, they merely forward all calls to the dynamically loaded function.","In order to produce an executable, the linker must include both do_thing_the_XYZ_way( ) and do_thing_the_other_way( ). In order to reduce the runtime footprint the implementations of do_thing_the_XYZ_way( ) and do_thing_the_other_way( ) are placed in separately named dynamically loaded libraries. The program itself makes calls to do_thing_the_XYZ_way( ) with that entry-point resolved at link-time from a library containing the wrapper described immediately above. The first time the wrapper is invoked at run-time, the wrapper loads the appropriate dynamically loaded library, finds and stores the entry-point of the same-name function within that library, and invoked that entry-point. At subsequent invocations of the wrapper, the stored entry-point is used immediately with no additional overhead.","In an exemplary embodiment of the invention, given that a stub routine do_thing( ) is statically linked into the executable, a dynamically-linked version of the code is as follows:",{"@attributes":{"id":"p-0090","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int first_call = 0;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if( first_call) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"first_call = 1;"]},{"entry":[{},"proper_routine = choose_thing( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"proper_routine( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"where choose_thing( ) consists of the following code:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"choose_thing( ) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if(_FEATURE_XYZ_USED) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"open_dynamic_library(XYZ);"]},{"entry":[{},"return pointer to do_thing_the_XYZ_way( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"open_dynamic_library(not_XYZ);"]},{"entry":[{},"return point to do_thing_the_other_way( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In other words, in the first instance where invoking either do_thing_the_XYZ_way( ) or do_thing_the_other_way( ) results in the actual call being to the general choose_thing( ) function. In turn, choose_thing( ) checks the _FEATURE_XYZ_USED flag, opens the appropriate version of the dynamic library and loads the correct version of the routine. The choose_thing( ) routine returns the correct version, that overloads some other name, such as proper_routine( ). Then, upon calling the proper_routine( ) results in aliasing it to the correct version of the routine from the correct library.","In an alternative exemplary embodiment of the invention, very early in the executable program, the following code is executed:",{"@attributes":{"id":"p-0093","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"main( ) {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},". . ."]},{"entry":[{},"if(_FEATURE_XYZ_USED ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"load_dl(do_XYZ_things);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"load_dl(do_other_things);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"1"},"In another embodiment of the invention, the wrapper includes a check on the global variable's state and reports an error if the application attempts to call the function in the wrong state. For instance, the do_thing_the_XYZ_way( ) would report an error if it found _FEATURE_XYZ_USED was false.","By avoiding the implicit link to both versions of the do_thing functionality (in separate libraries), \u201csnapping\u201d the links to the library with known entrypoints that are not going to be used based on link-time recognition is avoided with a reduction in the start-up overhead and memory consumption.","\u201cSnapping\u201d the links refers to run-time resolution of entry-points left unresolved at load-time. Entry-points flagged at load-time for resolution at run-time are stored in a special area of the program image file. When the program image file is loaded into memory at run-time, the entry-point linkages in this special area are filled with the correct addresses of the actual function entry-points in the dynamically loaded library containing the entry point linkages. This differs from load-time linking, where the address of the actual function is known at load-time. The operating system's program loader handles the \u201csnapping\u201d of links responsible for loading a program image into memory for execution.","Another embodiment indirectly calls the wrapper function through a function pointer-table entry. After the wrapper dynamically loads the appropriate library, it changes the function pointer-table entry to point directly to the matching function in the loaded library. The wrapper appears in a statically-linked library (i.e. its address is resolved at load-time). Following initialization of the above-described table, an entry \u201cn\u201d contains the address of the wrapper. If a program built in accordance with this embodiment wants to perform do_thing( ), then rather than directly invoking an entry-point (that is resolved at load time or snapped from some dynamic library at run time), the program invokes the function pointed to by entry \u201cn\u201d of the table. The first time this invocation occurs, the entry is pointing at the wrapper described above. This wrapper replaces the entry with a pointer to the correct function (i.e. the one indicated by the value of _FEATURE_XYZ_USED) and then calls that function. On subsequent invocations (invocation via entry \u201cn\u201d in the table), the correct function is called directly and without invoking the wrapper.","A \u201chelper\u201d function appears in the statically-linked library. This helper performs the functions of the aforementioned wrapper function for every entry in the table. The helper function checks the appropriate _FEATURE_xxxx_USED variables, loads the matching library, finds the matching function name, and places the address of that entry-point into the appropriate table entry. If a program built in accordance with this embodiment wants to perform do_thing( ), then rather than directly invoking an entry-point (that is resolved at loadtime or snapped from some dynamic library at run time), the program invokes the function pointed to by entry \u201cn\u201d of the table. The first time any function available through this table is invoked (say, entry \u201ci\u201d), the entry is pointing at the wrapper described above. The wrapper invoked helper function replaces each entry in the table with a pointer to the correct function. The wrapper then calls the function via entry \u201ci.\u201d On subsequent invocations (invocation via any entry \u201cj\u201d in the table), the correct function is called directly without the need to invoke the wrapper.","The preceding description illustrates the selection of different object modules by the linker to allow the same command to use two different implementations in a manner responsive to the program code environment. The invention is not limited to the embodiment described above or to the proposed implementation of the SAVEPOINT command. Other commands of interest can be similarly handled. The earlier illustrations of other ways for the macro-preprocessor to introduce statements are also easily adapted to result in the context-sensitive exclusion or inclusion of a particular object module.","Moreover, implementations of the invention include computer-readable medium having computer executable instructions for performing the steps of a method for constructing a computer program developed. The computer-readable medium has computer executable instructions for performing the step of declaring the first variable in the first source file by insertion of a first variable declaration statement by a macro-preprocessor responsive to the detection of the first statement of the non-procedural programming language.","The design of suitable linker libraries is modified in accordance with the invention.  illustrates an embodiment of linker libraries with object modules and libraries corresponding to the order in which the libraries are used to resolve references. Naturally, first the unresolved references in the source program code are resolved followed by references that need to be resolved due to object modules so included. In  a first linker library V has a first object module M and a second object module M. The first object module M has a definition for _VAR  and another variable _VAR with a non-default value . The definition for _VAR implicitly introduces a declaration because memory allocation requires knowledge of the type for the variable. Another linker library V has object modules M. In particular, linker library V has an object module M having a definition  setting _VAR to a default value.","Typically, the linker encounters the object module M earlier than any other object module, particularly object module M. Advantageously, object module M is implemented as the last object module in a linker library to ensure the correct order of processing.","In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiments described herein with respect to the drawing FIG.s is meant to be illustrative only and should not be taken as limiting the scope of invention. For example, those of skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
