---
title: Efficient incremental parsing of context sensitive programming languages
abstract: Many integrated development environments provide “intelligent feedback” to developers. Current “intelligent feedback” techniques may not work well with source code files comprising context sensitive programming languages because edits to one place in the code may change the meaning of arbitrary other places in the code, thus requiring additional full semantic parses to maintain correctness of the system. As provided herein, context-free “name” parsing may be performed to support entity candidate recursive semantic parsing in determining the meaning of the entity. A name parse may be performed to build and/or update a name table and a range table comprising names of entities and their positions within a source code file. Upon receiving a request to determine the meaning of a selected entity within the source code file, the tables may be queried to determine entity names and locations that are to be semantically parsed to determine a selected entity meaning.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08364696&OS=08364696&RS=08364696
owner: Microsoft Corporation
number: 08364696
owner_city: Redmond
owner_country: US
publication_date: 20090109
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Software development projects have become increasingly complex, comprising multiple files, directories, classes, functions, etc. Integrated development environments (IDEs) may provide additional information and functionality to aid in the development of these complex software projects. For example, an IDE may provide auto completion, access to descriptions of entities (functions, parameters, lists of functions, etc.), and\/or additional information through dynamic tooltips during programming. These techniques mitigate ambiguity in variable names, functions, and\/or other entities the developer may be inputting. The time to reference declarations to these entities may be mitigated because the information is directly presented to the user, without the user searching through code files to find declarations of entities.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Among other things, a technique for determining a meaning of an entity within a source code file is disclosed herein. The source code file may comprise syntax from context sensitive programming languages. An entity meaning request comprising a selected entity data is received. The selected entity data may comprise a selected entity, a selected entity position (e.g., entity range), and\/or other entity data. The entity may comprise a function, method, class, variable, object, and\/or any other entity within a source code file. The position may comprise the character position of the entity from the beginning of the source code file. A range table is queried to determine a set of entities (e.g., a set of entity candidates) corresponding to the selected entity data. The range table may comprise a set of ranges (e.g., beginning and ending positions within the source code file) and entities corresponding to the ranges. Upon determining a set of entities corresponding to the selected entity position, a name table is queried to determine a set of positions (e.g., beginning positions and ending positions, entity ranges, etc.) of the set of entities. The name table may comprise entity names with their corresponding ranges.","A recursive semantic parse may be performed upon the set of entities based upon their ranges within the source code file. A parse tree is built based upon the recursive semantic parse. The parse tree may be indexed based upon positions within the parse tree corresponding to entities within the source code file. An entity meaning may be presented based upon querying a parse tree index of the parse tree. For example, a tooltip may be presented with additional information about a function (e.g., parameter types) a developer is currently inputting.","A technique for name parsing is also disclosed herein. A name table may be built based upon a name parse of a source code file. The name parse determines names of entities and locations of entities. The names and locations are used to build a name table comprising names of entities, beginning positions, and ending positions of the corresponding entities. A range table may be built based upon the name table. The range table may comprise a position column configured to store positions from the name table and an entity column configured to store entities corresponding to the positions in the position column. The range table may be sorted by the position column. An incremental name parse may be performed to update the name table and\/or range table based upon entities affected by an edit within the source code file. The name table and range table may be used to determine the location of entities that are to be semantically parsed when determining a meaning of an entity.","To the accomplishment of the foregoing and related ends, the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects, advantages, and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.","The claimed subject matter is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, structures and devices are illustrated in block diagram form in order to facilitate describing the claimed subject matter.","Integrated development environments (IDEs) may provide tools and resources for a robust software development experience. An IDE may provide a source code editor, a compiler, a builder, a debugger, class browsers, object inspectors, and\/or other tools used to improve a software developer's experience in developing source code. Some IDEs provide \u201cintelligent feedback\u201d to aid developers. The \u201cintelligent feedback\u201d may present additional information regarding classes, variables, functions, and\/or other useful information for developing source code. This technique enhances the developer's experience by providing useful suggestions, additional understanding of old and new source code, locations of correct objects and statements, and\/or enhanced navigation. The technique may also provide a greater understanding of functions, their parameters, and types of variables.","To provide a meaning of an entity (e.g., provide \u201cintelligent feedback\u201d regarding a function, variable, and\/or other entities that a developer expresses interest in), current techniques may perform a top-level semantic parse. The semantic parse may skip source code in function bodies, but may determine the full meaning of declared entities (e.g., distinguishing function declarations, object declarations, class declarations, etc.). The semantic parse may determine the beginning point and ending point of entities. For example, a semantic parse of a source code file may determine that \u201cFunc\u201d is a function with one parameter of type \u201cnt\u201d and a return type of \u201cC::Cint\u201d and that \u201cFunc\u201d has a beginning position of  and an ending position of .","Performing a top-level semantic parse may be impractical when source programs become large, complex, and\/or are developed in a context sensitive language. In context sensitive programming languages, an edit to an entity within a source code file may affect multiple portions of the source program; in fact a small edit may affect the entire source program. Current techniques for providing meanings of entities may not be effective for context sensitive programming languages because a top-level semantic parse of the entire source program may have to be performed after every edit to maintain consistency. Some current techniques may choose to present inaccurate (e.g., out of date) entity meanings to users to avoid repeating top-level semantic parsing of the entire source program.","As set forth herein, name parsing may be performed to gather data which may be used during semantic parsing to determine the meaning of an entity. Name parsing may be performed by a name parse component. The name parse component may be configured to parse ranges within a source code file to determine a set of entity candidates that exist within that range (e.g. a range may include the entire source code file). It may be appreciated that a source code file may be interpreted as at least one data structure that may comprise source code (e.g., a translation unit). The set of entity candidates may comprise the potential names of entities that are declared within the source code and their respective beginning and ending positions within the source code.","The name parse may differ from the semantic parse because the name parse does not determine the exact meaning of the entity (e.g., in the C++ declaration X Y(Z), it is not determined if Y is a function declaration or an object declaration). The name parse may not be powerful enough to distinguish between multiple names that may be declared in a single range, and so reports all names that may be declared (e.g., in the C++ declaration X(Y), X and Y are both entity candidates, because either one may be the declared entity, depending on the surrounding context of the declaration). The name parse may comprise the property where an edit anywhere in a program has no affect on the consistency of the data outside the direct range of the edit. The data resulting from the name parse, the name table, allows the semantic parse to be deferred until a request for a meaning of an entity is received, thus mitigating resources and time because a full semantic parse may not be used to maintain consistency whenever an edit occurs. It may be appreciated that a name parse may be performed incrementally, so the name parse may be used to maintain consistency whenever an edit occurs.","A semantic parser may be modified to create an entity candidate recursive semantic parser. An entity candidate recursive semantic parser may query the name table in addition to an internal symbol table at any time during the semantic parse that a name lookup may be desired. The name table may provide a set of entity candidates that may satisfy the query from the entity candidate recursive semantic parser. The entity candidate recursive semantic parser may determine that an entity candidate may be preferred over entities obtained from its internal symbol table. The entity candidate recursive semantic parser may recursively perform a full semantic parse upon at least one of the entity candidates, which may add new entities to its internal symbol table. The entity candidate recursive semantic parser may thereafter perform name lookup again. The entity candidate recursive semantic parser may determine that an entity from its internal symbol table may be preferred over any entities obtained from the name table, and may proceed with the semantic parse. Otherwise, it may query the name table and\/or its internal symbol table further as prescribed by the rules of the language. It may be appreciated that an entity candidate recursive semantic parser may parse a small fraction of the entire source code in response to an entity meaning request.","A name table may be built by a table building component. The table building component may be configured to request the name parse component to perform a name parse on the source code file. The result of the name parse may be used to build the name table comprising columns configured to store names of entities, beginning positions, and ending positions of the entities. A range table may be built based upon the name table. The range table may comprise a column of positions (e.g., ending positions and beginning positions) designated in the name table. The range table may comprise an entity column configured to store entities corresponding to positions within the position column. For example, an entry within the range table may comprise position  and entities \u201cfunc\u201d and \u201cCClass\u201d because \u201cfunc\u201d begins at position  and \u201cCClass\u201d spans the position . It may be appreciated that a position may not comprise an entity associated with that position. The name table and the range table may be used when a meaning of an entity is determined by a semantic parse. For example, a semantic parser (e.g., the entity candidate recursive semantic parser) may query the range table and\/or name table to determine entities (e.g., entity candidates) that are to be parsed and respective entity locations (e.g., entity ranges).","One embodiment of determining a meaning of an entity within a source code file is illustrated by an exemplary method  in . At , the method begins. At , an entity meaning request comprising selected entity data is received. For example an entity meaning request may originate when a user within an IDE places the cursor over an entity within a source code file, and the selected entity data comprises the position of the cursor within the source code file. In another embodiment of act , the selected entity data comprises the text of an expression in the evaluation window of a source code debugger. Selected entity data may comprise text, positions, ranges, and\/or other information regarding an entity within a source code file.","At , a set of entity candidates corresponding to the selected entity data may be determined. The term set of entities may be interpreted as a set of entity candidates. In one example a range table may be queried to determine the set of entity candidates. The range table comprises ranges within the source code file (e.g., beginning positions and ending positions). Entities may be associated with the ranges within the source code file. A query of the range table may be performed to determine the set of entity candidates that correspond to the selected entity data. For example, a selected entity data may comprise a selected entity position corresponding to an entity selected within source code. The selected entity (selected entity position ) may be declared within a function declaration (positions  to ) within a class declaration (positions  to ). The function and\/or class may be associated with the selected entity position , because the range between their beginning positions and ending positions span the selected entity position. A set of entity candidates associated with the selected entity position of  may comprise the function, class, and selected entity. It may be appreciated that act  may be optional. That is, the method may be carried out successfully without performing that which is described at .","At , a set of positions corresponding to the set of entity candidates may be determined. The set of positions may be an entity range (e.g., beginning and ending positions) of respective entities. In one example a name table may be queried to determine the set of positions. The set of positions may be used by an entity candidate recursive semantic parser to parse the set of entity candidates. For example, a set of entity candidates may comprise a function, class, and selected entity because they correspond to a selected entity position within a selected entity data. The entity names may be used to query the name table to determine their beginning positions and ending positions. It may be appreciated that act  may be optional. That is, the method may be carried out successfully without performing that which is described at .","At , a recursive semantic parse may be performed upon a set of entity candidates based upon a set of positions to determine an entity meaning. It may be appreciated that a set of positions may be interpreted as a set of ranges. The set of positions may be used to reference where in the source code file the entity candidate recursive semantic parse is to be performed initially. The recursive semantic parse may encounter additional named entities whose meanings have not been determined, and whose meanings may be determined for the semantic parse to continue. The entity candidate recursive semantic parser may query the name table to determine additional entity candidate positions corresponding to the named additional entities. A recursive semantic parse may be performed upon the additional entity candidate positions to determine the meaning of any entities defined therein.","It may be appreciated that a recursive semantic parse may be interpreted as an entity candidate recursive semantic parse. In another embodiment of act , an entity candidate recursive semantic parse based upon a selected entity data may be performed to determine an entity meaning. The selected entity data may be received within an entity meaning request. The selected entity data may be used to determine entity candidates that the entity candidate recursive semantic parse is to parse to determine the entity meaning. The entity candidate recursive semantic parse may be performed upon respective undefined entities encountered during parsing (e.g., entities within source code whose meaning is unknown and\/or undefined, entity candidates, etc.). For respective undefined entities, an entity candidate range may be determined and the entity candidate recursive semantic parse may be performed upon the entity candidate range to determine a defined entity.","After recursively parsing the additional entity candidate positions, an entity candidate recursive semantic parser may perform a verification to determine whether it produced an expected named entity desirable in determining the meaning of a selected entity. If the semantically parsed entity candidate did not produce an expected named entity, then a name table may be queried further to determine a new set of entity candidates that an entity candidate recursive semantic parse may be performed upon to determine an entity meaning. At , the method ends.","It may be appreciated that a parse tree and\/or collection of parse trees may be built based upon the recursive semantic parse. It may be appreciated that a parse tree may be interpreted as a representation of source code in binary form. The parse tree may be indexed by positions of entities within the source code file. A parse tree index may be queried based upon the selected entity position to determine a node or nodes within the parse tree corresponding to the selected entity. An entity meaning may be extracted from the node. The entity meaning may be presented based upon the query of the parse tree index of the parse tree.","In yet another embodiment of performing a recursive semantic parse of act , a semantic parser may be modified to perform the recursive semantic parse based upon at least one entity candidate. Because the recursive semantic parse may have been deferred until a request to determine an entity's meaning is received, a previous context-free parse (e.g., a name parse) may have been performed to determine names of entities and\/or their respective locations within a source code file. Entities discovered within the context-free parse may be designated as entity candidates because they might not actually exist at the determined location.","The recursive semantic parser (e.g., the modified semantic parser) may begin parsing at an arbitrary place in the source code file as requested by a client system (e.g., a request comprising an entity position may be received from a user to determine a meaning of an entity). During parsing, the recursive semantic parser may encounter a named entity within the source code. When the named entity is encountered, the name may be looked up simultaneously in an internal symbol table and a name table according to the name lookup rules of the source code language. The name lookup rules of the source code language may prefer an entity candidate found in a name table over an entity found in an internal symbol table, whereupon the current parse may be suspended.","A recursive semantic parse may be performed on a range associated with the entity candidate. Upon a return from the recursive semantic parse, the internal symbol table may be queried again (but not the name table) to verify that the preferred entity was defined by the recursive semantic parse. If the preferred entity is found, then the semantic parsing of the selected entity continues. Otherwise, name lookup proceeds to the next step as prescribed by the name lookup rules of the source code language. It may be appreciated that this technique may iterate based upon the source code language rules.","In yet another embodiment, a context-sensitive parser may be modified to create a context-free parser. For respective execution points in the context-sensitive parser where name lookup is performed in order for the parse to proceed, the name lookup is omitted. The parse may be bifurcated, whereby a respective sub-parse may assume a possible legal outcome of the omitted name lookup at that execution point. A sub-parse may continue parsing until a parsing error is encountered or an entity is declared. An entity candidate is created based upon a sub-parse determining an entity that may be declared.","It may be appreciated that other techniques may be employed to create a context-free parser to produce entity candidates for a context-sensitive language, including creating a new context sensitive parser to do so. It may also be appreciated that entity candidates in a source code file may be created before the recursive semantic parse or during the recursive semantic parse.","It may be appreciated that a name parser for a context-free language may be created using parsing techniques less powerful or robust than context-free parsing (e.g., regular expression parsing). That is, a streamlined context-free name parser may be created. It may be appreciated that the name parser thus created may outperform or otherwise provide advantages not available from its corresponding context-free parser (e.g., may require fewer resources and\/or operate more quickly since it is streamlined). It may be appreciated that one or more of the methods and\/or systems described herein also have application to and thus benefit parsers for context-free languages.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2","b":["200","212","212","202","200","204","204","202","204","206","204","208"]},"Because edits may occur within the source code file , positions of entities may be adjusted based upon an edit list and\/or a sequence of range tables comprising range tables with corresponding timestamps. Positions may comprise timestamps corresponding to the time the position was created or updated. Range tables in the range table sequence may comprise timestamps corresponding to the time the range table was created. Range tables may also comprise the edit list being processed when the name table was created. When a new edit is processed, the sequence of range tables is traversed, starting with the range table having the newest timestamp. When traversing between two range tables in the sequence, the position of the edit is adjusted accounting for edits between the two range tables. When a range table in the sequence is found to contain the edit (adjusting for intervening edits), the entities in the name table associated with the edit are determined. For respective entities, respective positions are updated accounting for respective edits having timestamps newer than the timestamp of the position, whereupon the timestamp of the position is updated to the timestamp of the newest edit. A name parse is performed upon the updated ranges and a new range table is created, comprising the results of the name parse, the new edit, and the timestamp of the new edit. The new range table is added to the range table sequence. It may be appreciated that the meaning determination component  may operate incrementally, thus the positions that are adjusted may be less than the total number of positions\/ranges.","A recursive semantic parser  may be configured to perform an entity candidate recursive semantic parse based upon the set of positions. For example a recursive semantic parse may be performed upon the set of entities (e.g., set of entity candidates) and\/or additional entities encountered (e.g., undefined entities required by but not yet defined in the current semantic parse). The set of entities may comprise the beginning positions and ending positions of entities that are to be parsed. If additional entities are encountered, the recursive semantic parser  may query the range table  and\/or a name table  to determine additional entity positions. The beginning and ending positions may be utilized by the recursive semantic parser  to mitigate the time used to determine the meaning of the selected entity by parsing only those entities that are used to define the selected entity.","The recursive semantic parser  may be configured to build a parse tree  based upon the recursive semantic parse. The parse tree  may comprise nodes corresponding to entities and their entity meanings. An index component  may be configured to index the parse tree based upon positions of the entities within the source code file . The index component  may traverse the parse tree  to build a parse tree index. It may be appreciated that a collection of parse trees may be created, thus indexing the collection of parse tress allows meaningful information to be determined and extracted without tying them together.","The meaning determination component  may be configured to present the entity meaning of the selected entity based upon a query of the parse tree index of the parse tree . The meaning determination component  may extract the entity meaning from a node or nodes within the parse tree .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["300","308","306","312","302","300","304","310","312","312","304","312","302"]},"The name parse component  may be configured to perform the name parse to determine the set of entity data comprising a set of entity names and a set of entity positions. It may be appreciated that the name parse component  may not perform a semantic parse to determine the meaning of entities (e.g., determine if an entity is a class, function, or object declaration). The name parse may be performed (e.g., the name table  and the range table  are created and maintained) in lieu of a full semantic parse, thus mitigating resources and\/or time used in performing semantic parses and\/or maintaining the result of the semantic parses (e.g., performing additional full semantic parses in response to edits). The name parse may be performed incrementally. The name table  and the range table  may be built based upon the name parse using the set of entity data. These tables provide entity names and their locations within the source code file , which may be used in determining an entity's meaning.","The table building component  may be configured to build the name table  comprising an entity column configured to store names of entities within the source code file , a begin column configured to store positions corresponding to the beginning positions of entities within the source code file , and an end column configured to store positions corresponding to the ending positions of entities within the source code file . The name table  may be queried to determine locations of entities within the source code file . It may be appreciated that the name table may comprise additional information regarding entities (e.g., attributes, class, namespace, etc.).","The table building component  may be configured to build the range table  based upon at least one entry within the name table . The range table  may comprise a position column configured to store positions from the begin column and\/or end column of the name table . The range table  may comprise an entity column configured to store entities corresponding to the positions in the position column. For example, the position column may comprise the character position . Three entities (e.g., a class, function, and object) may begin at, end at, and\/or span across the character position , therefore the entity column may comprise the entity names of the three entities. In another example, the position column may comprise the character position , corresponding to an end position within the name table. No entities may span from character position  to the next position in the table, therefore the entity column may comprise no entities.","The table building component  may be configured to sort the range table  based upon the positions within the position column (e.g., smallest character disposition to largest character disposition). It may be appreciated that sorting the position column of the range table may optimize queries upon the range table. The range table  may be queried to determine what entities may correspond to a location (e.g., a selected entity position) within the source code file . During a determination of an entity meaning, entities that are to be initially parsed may be determined based upon querying the range table  to determine entities that may be defined within a selected entity position. During an entity candidate recursive semantic parse, entities whose meanings are required to determine the meanings of the initially parsed entities may be determined based upon querying the range table .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4","b":["400","412","402","402","412","408","406"]},"The system  comprises a table updating component  and a name parse component . The table updating component  may be configured to determine at least one edit occurred within an edit range of the source code file . For example, the table updating component  may determine a user added source code to the source code file  within the programming environment . The table updating component  may update an edit list based upon keystrokes and\/or corresponding positions of the keystrokes, thus allowing a merger of adjacent keystrokes for optimization.","The table updating component  may be configured to query a sequence of range tables (e.g., the range table ) to determine whether at least one affected entity exists (e.g., the edit may change the position of an entity; the edit may remove an entity; etc.). Querying the range table  may comprise querying the name table  to determine the positions of the affected entities because the positions may be used to locate the affected entities when an incremental name parse is performed. Upon determining at least one affected entity exists within the range table , the at least one affected entity is removed from the name table . The table updating component  may request the name parse component  to perform an incremental name parse upon the range of any affected entity within the source code file . If no affected entities exist within the range table , then the incremental name parse is performed upon that range in the source code file . The incremental name parse may determine entity names, beginning positions, and\/or ending positions of entities within ranges thus parsed in the source code file .","The table updating component  may be configured to update the name table  and\/or the range table  based upon the incremental name parse. The range table  may be updated based upon the updated name table . Updating the range table  may comprise maintaining a sorted order of the range table  based upon positions within a position column of the range table . It may be appreciated that during update, entities that may be affected from an edit may be updated, while other entities within the range table are not.","In another embodiment, the table updating component  may be configured to update the name table  and the range table  in response to an edit at an edit position within the source code file . The table updating component  may query the range table  to determine a set of ranges associated with the edit position. The table updating component  may perform an incremental name parse upon the set of ranges. The name table  and the range table  are updated during the incremental name parse.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":["500","504","506","502","502","502","506","504","504","506"]},"The result of the name parse may be used to create the name table  comprising a name column, a begin pos column, an end pos column, and\/or additional context free information. The name column comprises the names of entities within the source code file  discovered through the name parse. The begin pos column comprises the character position of the beginning position of the entity declaration. The end pos column comprises the character position of the ending position of the entity declaration. For example, the declaration for the entity \u201cC\u201d begins at character position  and ends at character position . The declaration for the entity \u201cCint\u201d begins at character position  and ends at character position , thus \u201cCint\u201d is within the declaration for the entity \u201cC\u201d.","Once the name table  is created, then the range table  may be created and\/or sorted by position. It may be appreciated that the range table may be built simultaneously with the name table, or independent of the name table. It may be appreciated that a range table may be based upon an inversion of the entities, having overlapping ranges, within the name table, wherein positions may be used to create non-overlapping ranges that entities may be associated with, thus allowing quick lookup based on positions. The range table  may comprise a column of positions extracted from the name table  (e.g., begin pos and end pos). The range table  may also comprise a column configured to store entities corresponding to respective positions within the position column. It may be appreciated that at least one position may be interpreted as a range that entities may be associated with. Positions may be sorted for non-overlapping sub ranges and entities may be associated with ranges between positions. For example, \u201cC\u201d and \u201cCint\u201d correspond to the character positions (e.g., range) between the position  and the position . In another example, \u201cfunc\u201d corresponds to the character positions between the position  and the position . In yet another example, no entities correspond to the character positions between the position  and position . The range table  may be used to efficiently determine entities that correspond to a specified position within the source code file . Using the range table  and the name table , a location of an entity within the source code file  may be determined, thus allowing a recursive semantic parse to quickly determine portions of the source code file  that are to be parsed to determine a meaning of an entity within the source code file .",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 6","b":["600","602","604","0","602","606","602","35","65","610","606","602","610","1","604"]},"In one embodiment of updating a name table and a range table, an incremental update may be performed after an edit within a source code file. An edit within the source code file may affect the position of at least one entity occurring after the edit position. Because positions may be located in range tables, name tables, and\/or other places, it may be undesirable to update all of the affected entity positions after each edit (e.g., there may be a large number of entity positions created by a name parse of the source code file). To mitigate the resources used to update the affected entity positions, a technique to incrementally update the positions may be employed.","In one example of incrementally updating positions in range tables and name tables due to an edit, an initial name parse may be performed to create an initial name table and an initial range table within a range table sequence. For respective keystrokes performed after the initial name parse, a timestamp greater than previous keystroke timestamps is accorded to the keystroke. Respective entries in the range table sequence are created for the respective keystrokes, and comprise the entities and positions affected by the keystrokes, the keystroke, and the timestamp of the keystroke. For respective entities within the name table, a timestamp may be created corresponding to the last time an entity's begin position and end position were update (e.g., during the processing of a keystroke). It may be appreciated that the timestamp within the initial range table may have to be less than the timestamp of any keystroke.","For respective keystrokes performed after the initial name parse, a timestamp greater than previous keystroke timestamps is accorded to the keystroke. For respective range tables within the range table sequence, beginning with the range table having the newest timestamp, a query may be performed to determine if the keystroke falls within any range therein. If no range is found, then the next range table in the range table sequence is queried, after first adjusting the query position by the affect of the keystroke stored in the range table just queried. It may be appreciated that the query of respective range tables may be repeated until a resulting range is determined. The range may be determined because the initial range table may comprise all ranges within the source code file.","For respective entities within the resulting range, a begin position and end position of the respective entity may be needed within the name table. The begin position and end position of the respective entity may be translated into current positions by adjusting for keystrokes newer than the timestamp. The adjusted begin and end positions may be added to a range list to be used in the following act. The respective entity may be removed from the name table.","In anticipation of a name parse to be performed upon the range list, a new range table may be created with the timestamp of the current keystroke, and added to the range table.","For respective begin and end positions of the range list, an incremental name parse may be performed from the begin position to the end position. For respective new entities encountered, the new entity may be added to the name table with a timestamp of the current keystroke. The entity and its respective begin and end positions may be added to the new range table with the timestamp of the current keystroke.","Once updated, the range table sequence may be used in determining entities that may be associated with a position of an entity meaning request. In one example of starting a recursive semantic parse, respective range tables within a range table sequence may be queried starting with the range table with the newest timestamp. If no range is found then the next range table in the range table sequence may be queried upon first adjusting the query position by the appropriate keystrokes. This may be repeated within a loop until a resulting range of the query is determined. The range may be determined because the initial range table may comprise all ranges within the source code file. Positions associated with the resulting range and\/or its corresponding entities may be translated into current positions by adjusting based upon keystrokes newer than the timestamp of the resulting range.","It may be appreciated that adjacent keystrokes may be combined to mitigate the number of updates to the range table sequence and name table, and the number of range tables in a range table sequence. It may also be appreciated that entities may be updated within a name table rather than being removed and re-added.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 7","FIG. 1"],"b":["700","706","702","702","704","702","706"]},"It may be appreciated that the subject matter presented herein may be implemented in various ways. For example the determination of a meaning of an entity may be implemented within a non-interactive command-line complier, edit-and-continue environments, intelligent feedback, interactive code debugging, etc.","Still another embodiment involves a computer-readable medium comprising processor-executable instructions configured to implement one or more of the techniques presented herein. An exemplary computer-readable medium that may be devised in these ways is illustrated in , wherein the implementation  comprises a computer-readable medium  (e.g., a CD-R, DVD-R, or a platter of a hard disk drive), on which is encoded computer-readable data . This computer-readable data  in turn comprises a set of computer instructions  configured to operate according to one or more of the principles set forth herein. In one such embodiment , the processor-executable instructions  may be configured to perform a method, such as the exemplary method  of , for example. In another such embodiment, the processor-executable instructions  may be configured to implement a system, such as the exemplary system  of , for example. Many such computer-readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims.","As used in this application, the terms \u201ccomponent,\u201d \u201cmodule,\u201d \u201csystem\u201d, \u201cinterface\u201d, and the like are generally intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a controller and the controller can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Furthermore, the claimed subject matter may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed subject matter. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 9","FIG. 9"]},"Although not required, embodiments are described in the general context of \u201ccomputer readable instructions\u201d being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media (discussed below). Computer readable instructions may be implemented as program modules, such as functions, objects, Application Programming Interfaces (APIs), data structures, and the like, that perform particular tasks or implement particular abstract data types. Typically, the functionality of the computer readable instructions may be combined or distributed as desired in various environments.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 9","FIG. 9"],"b":["910","912","912","916","918","918","914"]},"In other embodiments, device  may include additional features and\/or functionality. For example, device  may also include additional storage (e.g., removable and\/or non-removable) including, but not limited to, magnetic storage, optical storage, and the like. Such additional storage is illustrated in  by storage . In one embodiment, computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage  may also store other computer readable instructions to implement an operating system, an application program, and the like. Computer readable instructions may be loaded in memory  for execution by processing unit , for example.","The term \u201ccomputer readable media\u201d as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory  and storage  are examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, Digital Versatile Disks (DVDs) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .","Device  may also include communication connection(s)  that allows device  to communicate with other devices. Communication connection(s)  may include, but is not limited to, a modem, a Network Interface Card (NIC), an integrated network interface, a radio frequency transmitter\/receiver, an infrared port, a USB connection, or other interfaces for connecting computing device  to other computing devices. Communication connection(s)  may include a wired connection or a wireless connection. Communication connection(s)  may transmit and\/or receive communication media.","The term \u201ccomputer readable media\u201d may include communication media. Communication media typically embodies computer readable instructions or other data in a \u201cmodulated data signal\u201d such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.","Device  may include input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, infrared cameras, video input devices, and\/or any other input device. Output device(s)  such as one or more displays, speakers, printers, and\/or any other output device may also be included in device . Input device(s)  and output device(s)  may be connected to device  via a wired connection, wireless connection, or any combination thereof. In one embodiment, an input device or an output device from another computing device may be used as input device(s)  or output device(s)  for computing device .","Components of computing device  may be connected by various interconnects, such as a bus. Such interconnects may include a Peripheral Component Interconnect (PCI), such as PCI Express, a Universal Serial Bus (USB), firewire (IEEE 1394), an optical bus structure, and the like. In another embodiment, components of computing device  may be interconnected by a network. For example, memory  may be comprised of multiple physical memory units located in different physical locations interconnected by a network.","Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example, a computing device  accessible via a network  may store computer readable instructions to implement one or more embodiments provided herein. Computing device  may access computing device  and download a part or all of the computer readable instructions for execution. Alternatively, computing device  may download pieces of the computer readable instructions, as needed, or some instructions may be executed at computing device  and some at computing device .","Various operations of embodiments are provided herein. In one embodiment, one or more of the operations described may constitute computer readable instructions stored on one or more computer readable media, which if executed by a computing device, will cause the computing device to perform the operations described. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further, it will be understood that not all operations are necessarily present in each embodiment provided herein.","Moreover, the word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as advantageous over other aspects or designs. Rather, use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application, the term \u201cor\u201d is intended to mean an inclusive \u201cor\u201d rather than an exclusive \u201cor\u201d. That is, unless specified otherwise, or clear from context, \u201cX employs A or B\u201d is intended to mean any of the natural inclusive permutations. That is, if X employs A; X employs B; or X employs both A and B, then \u201cX employs A or B\u201d is satisfied under any of the foregoing instances. In addition, the articles \u201ca\u201d and \u201can\u201d as used in this application and the appended claims may generally be construed to mean \u201cone or more\u201d unless specified otherwise or clear from context to be directed to a singular form.","Also, although the disclosure has been shown and described with respect to one or more implementations, equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components (e.g., elements, resources, etc.), the terms used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., that is functionally equivalent), even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition, while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes\u201d, \u201chaving\u201d, \u201chas\u201d, \u201cwith\u201d, or variants thereof are used in either the detailed description or the claims, such terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
