---
title: Dispatching application steps of an application running on an application server in a client/server environment
abstract: A method for dispatching steps of an application running on an application server which can be accessed from client terminals. Users select user interaction elements on client terminals, and the interactions are transmitted to the application server executing a main part of an application, which creates output that contains the next set of possible user interactions. Calling application steps can be addressed and invoked by other application steps in order to reuse software components necessary for processing said other application steps. Nesting programming commands used to call another application step are arbitrarily nested and serve as a called sub-routine within the calling application step. Values are returned to the calling application step, and nesting paths of called application steps are discarded in case a user switches to another application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07398527&OS=07398527&RS=07398527
owner: Sony Deutschland GmbH
number: 07398527
owner_city: Cologne
owner_country: DE
publication_date: 20030514
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD AND BACKGROUND OF THE INVENTION","BRIEF DESCRIPTION OF THE PRESENT STATE OF THE ART","PROBLEMS ADDRESSED BY THE INVENTION","OBJECT OF THE UNDERLYING INVENTION","SUMMARY OF THE INVENTION","BRIEF DESCRIPTION OF THE CLAIMS","DETAILED DESCRIPTION OF THE UNDERLYING INVENTION"],"p":["The underlying invention generally relates to the field of client\/server architectures and distributed processing systems. It pertains e.g. to mobile service portals, application servers and transaction system in heterogeneous telecommunication networks where these applications are employed.","In this context, the invention encompasses research and development issues that are especially directed to client\/server architectures enabling users to indirectly interact with an application running on a remote application server by selecting user interaction elements on their terminals with the aid of a client program. These interactions are then transmitted via Internet and\/or any corporate network to the application server where the main part of the application is executed, and the application creates output that contains the next set of possible user interactions.","Thereby, an application is defined as a program that executes cycles in which output is transferred to the users and cycles in which it waits for user interactions. It is split up into different parts that are able to handle single user interactions either directly or by using other parts, which are called \u201csteps\u201d.","The spread of distributed computing systems has immensely increased over the past years. Distributed computing systems are becoming more and more important, in everyday life as well as in industrial and scientific domains. The Internet and its capabilities enable people to communicate and cooperate all over the world, while high-performance parallel computers or networks of workstations allow to solve scientific and commercial problems faster than ever. Distributed computing environments open up a large spectrum of possibilities for new and exciting applications. Since multimedia is relevant to a wide range of application domains, such as entertainment, information retrieval and business systems, and potentially deployable on a magnitude of end systems, the problem of supporting multimedia is a substantial one. In a distributed environment, the structural description of a multimedia document can be stored apart from the media object content.","Conventional distributed applications are specially designed to be executed on a wide range of platforms ranging from fast desktop computers to mobile laptops and hand-held Personal Digital Assistants (PDAs), spanning several orders of magnitude in processing, storage, and communication capabilities. They reside on (mobile) clients and access or update information from remote servers, thereby using wire-bound and\/or wireless telecommunication networks.","However, development and deployment still represent a major problem of distributed applications since these applications often exhibit a diverse and unpredictable performance due to their complex and heterogeneous architectures and communication mechanisms. Approaches to simplify the development and deployment processes are the usage of middleware platforms on the one hand, and the integration of online tools on the other hand. In this connection, middleware environments are intended to hide the heterogeneity of distributed systems and provide a platform for enabling the communication between distributed components. Online tools, in contrast, are intended to assist developers and users of distributed environments by supporting the analysis or control of running applications. They can advantageously be used to support the complete \u201conline life cycle\u201d of distributed applications, ranging from development tasks like debugging to subsequent deployment tasks like management of running applications.","With the increased computing and communication power, networks that connect a plurality of distributed workstations are becoming of interest for problem solutions which were formerly reserved to classical parallel computers. Another benefit of distributed computing systems is the permanent and location-transparent accessibility of information, which allows users to cooperate or share information all over the world. From the structural point of view, there are several ways to organize distributed computing systems. An often used paradigm is the client\/server principle, which distinguishes one of the participating computers as a server that provides pre-defined services to its clients. More recent approaches have abandoned the client\/server principle as the server represents a central point of failure, which decreases the reliability and availability of the overall system. Instead, peer-to-peer computing systems that do not distinguish any of the participating hosts represent a new trend for the development of distributed computing environments. Furthermore, new aspects of distributed computing have arisen with the availability of mobile devices that dynamically connect to networks via wireless communication. Despite the technological advances and independent of the architecture of distributed systems, the development of software remains complex in comparison to software development for stand-alone systems. On the one hand, this complexity results from the diversity of components used for the construction of distributed systems, while, on the other hand, complexity arises from the inherent distribution of the applied components. Important issues in this context are the management of the available resources, the localization of available functionality, the communication between distributed components, and the handling of failure situations. Due to rapid technology transitions and constantly growing requirements for distributed applications, mechanisms for an efficient and reliable building of applications have to be developed. A major contribution to the reduction of development efforts is the usage of middleware platforms. These platforms provide adequate mechanisms to abstract from the underlying computing infrastructure and enable a more or less transparent interaction between application components. Nevertheless, despite the benefits of middleware platforms, further assistance is required in order to rapidly and efficiently develop and deploy distributed applications. For example, during software development, communication between components needs to be traced for debugging or performance analysis purposes. Besides, during the subsequent software deployment, distributed applications need to be managed, and failure situations have to be detected.","In the field of client\/server architectures and distributed computing systems, a plurality of methods and technologies, which are closely related to the topic of the underlying invention, has been developed. In order to understand the main idea of the underlying invention, it is necessary to briefly explain the main aspects and principles of distributed processing and the concept of processing remote procedure calls.","Distributed processing offers a plurality of advantages in performance, availability and resource sharing. However, managing applications in a distributed environment is a complex task and the lack of integrated performance management facilities is an impediment to large-scale deployment. The Open Distributed Processing Reference Model (RM-ODP), which is a joint standardization effort of the International Standards Organization (ISO) and the International Telecommunications Union (ITU), captures the basis for the evolution of open systems. RM-ODP is a family of general standards and can therefore be utilized for specifying distributed systems. The model is targeted for architecture designers, standardization bodies, and vendor consortia, to guide them in the design of software architectures. The aim of RM-ODP is the development of standards for distributed information processing systems that can be exploited in heterogeneous environments and under multiple organizational domains. In addition to the requirement of using published and standardized interfaces, distributed processing systems are required\n\n","In distributed processing, the employed object model differs from object models represented for object-oriented programming languages, object-oriented design methodologies, and distributed object management systems. The major differences include\n\n","The communication model between distributed processing objects improves the communication primitives offered to programmers by introducing selective distribution transparency. The communication model is realizable through the binding model of objects. Characteristic of reference models for distributed processing is the use of structuring concepts of community, domain and federation. These concepts can be considered to be either static concepts exploitable at design time, or dynamic concepts exploitable at operation time. The conformance statements are mainly required by standardization activities: further standards have to claim suitable conformance testing methods. However, the classification of reference points restricts the areas of conformance testing in such a way that all implementation decisions can not be revealed.","In the following sections, two fundamental approaches a plurality of modern distributed system architectures rely on shall briefly be introduced: the Remote Procedure Call (RPC) concept, standardized by the Internet Engineering Task Force (IETF) standard RFC 1831, and the concept of distributed computing environments.","The concept of a remote procedure call is based on the syntax of local procedure calls. Aside from its unique calling mechanism, the main advantage of a remote procedure call is its easy parameter handling that allows static type checking at compile time, a feature that is not given with pure socket communication. The drawback of remote procedure calls is, though, that despite the syntactical identity with local procedure calls the semantics is not identical. The reason for the different semantics results from the different address spaces, run-time environments, and potentially different life times of the communicating processes. For example, it is not possible to pass pointers as parameters as in local C procedure calls due to separate address spaces. The implementation of remote procedure calls is based on a description of the interface with the remote procedure call language, from which stubs and skeletons for both the client side and the server side are generated by means of a remote procedure call compiler, which take over the arranging and rearranging of parameter sets on both sides, and care for the communication that relies on the Transmission Control Protocol (TCP), the Internet Protocol (IP) or the User Datagram Protocol (UDP). With remote procedure calls, a certain degree of access and location transparency can be reached.","Distributed Computing Environment (DCE) is a recent development of the Open Group. Its purpose is to provide a distribution platform for client\/server applications. Thereby, DCE defines an architecture model for applications that is placed on top of the local operating systems. It defines a set of services that are hierarchically structured, so that higher level services are able to use lower level services. The lowest-level service on top of the local operating system is the so-called \u201cThread Service\u201d; it is based on the POSIX standard 1003.1c and defines an application programming interface (API) for lightweight processes. This API contains functions for creating, manipulating, synchronizing, and deleting threads, and serves as a basis for asynchronous communication. The basic communication service placed above the Thread Service is the remote procedure call described in the previous section. On top of said remote procedure calls, several higher-level services like Time Service, Directory Service, Security Service, and Distributed File Service are available. These services provide functionality for different kinds of general purpose tasks required in most distributed applications. Distributed computing environments themselves are divided into so-called cells, which represent administrative units comprising users, machines, or applications in any arbitrary configuration. The main drawbacks of distributed computing environments are their reliance on remote procedure calls as the only communication mechanism, and its non-object-oriented design (although there are object-oriented extensions to distributed computing environments). Nevertheless, an important contribution of distributed computing environments is their concept of splitting middleware functionality into a set of variably usable services. Moreover, the decentralized and therefore scaleable approach of building organizational cells is of importance for subsequent developments.","Another important, but very different form of middleware are parallel programming environments used for High-Performance Computing and Networking (HPCN). The main goal of these platforms is an efficient communication between parallel processes, while transparency and ease of use originally play a secondary role. First implementations of parallel programming environments are based on a message-passing paradigm\u2014an approach with which all communication is based on exchanging messages. The only fundamental communication operations are the sending and receiving of messages. Later systems pick up the Distributed Shared Memory (DSM) paradigm, which provides an illusion of shared memory within a distributed environment. DSM systems provide the advantage of an improved location transparency and are therefore easier to program, but have problems to reach the efficiency of message-passing systems.","The main objects of both message-passing and DSM systems are efficient execution and communication on heterogeneous hardware, while interoperability and portability have to be maintained. Therefore, parallel programming environments can be classified as low-level middleware, providing only a low degree of transparency regarding the interaction of distributed components. This holds true particularly for message-passing systems, but also in case DSM systems transparency is only achieved at a rather low level of memory access. Higher-level services, for example for dynamically looking up distributed components, are missing.","By contrast, meta-computing infrastructures extend the parallel high-performance computing paradigm to geographically distributed resources. This is either necessary when local resources are no more sufficient for solving hard problems, or when the distribution of resources is inherent, for example in multidisciplinary collaboration environments. The resulting infrastructures are often referred to as grids, which represent higher-latency and lower-bandwidth wide-area inter-connections. The object of meta-computing systems is not to replace parallel computers, but to extend the parallel programming model for usage within geographically distributed environments. To achieve this, they provide services supporting specific requirements of meta-computing, e.g. including resource management, security protocols, information services, fault-tolerance mechanisms, or communication services. These services are adapted to common problems of distributed resource usage, which include authentication and authorization problems due to different administrative domains, resource management and allocation problems in large environments, or communication problems arising from different latency, bandwidth, and reliability within the grid. Thereby, meta-computing infrastructures lift parallel high-performance computing to a higher level of abstraction by adding services in geographically distributed systems.","In the following, a number of commonly used protocols, tools and programming languages according to the state of the art shall be mentioned that are employed for processing remote procedure calls and exchanging data between an application server and its system environment:\n\n","Notwithstanding their advantages described above, there are several problems conventional scripting languages and software tools according to the state of the art do not solve, e.g. problems that might arise if symbolic steps or method-call-like mechanisms are used to call the next expected step. In the following, these problems and their consequences shall be explained in detail.","Despite the problematic possibilities that the user decides to start another application between two steps and the fact that steps are stateless, the application programmer wants to call the next step that would be started if the application continues in a method-call-like way while retaining the possibility to allow other applications to call some steps. This poses some problems when using solutions for programming steps according to the state of the art. These problems can be categorized according to the need of a call-like mechanism regarding passing parameters, returning a result and nesting step calls.","For example, there might be a number of expected steps that can follow a given step. Some steps are called directly by the given step in the same way as subroutines in a program (direct calling). Other steps depend on specific user interactions; therefore, the programmer of the given step specifies which step should be called in case of which user interaction (indirect calling). Calling steps can be executed by conventional software tools according the state of the art, direct calls by means of a conventional programming language and indirect calls by means of CGI programs, servlets, etc.","For direct and indirect calling, the calling step might want to retain control back and receive a possible return value after the called step is finished (which is called a \u201cgosub\u201d call, in contrast to \u201cgoto\u201d calls where returning from the called step to the calling step is not expected). As steps are stateless, this can not happen in a transparent way by using the programming language of a subroutine call, but the calling step has to be called again after the called step has finished indicating this fact and using some data that puts the calling step in the correct state to continue its task and that delivers the possible return value of the called step. For example, a \u201ccompose message\u201d step requires an address book step to acquire the receiver of the message. The address book step might also choose to call another step in order to fulfill its task, which leads to a nested call path.","For \u201cgosub\u201d calls, this nesting can only take place as long as the same application is used by the respective user. If during a session in which an application is used the user chooses to switch to another application, the nesting of the step calls of the old application needs to be discarded, and a new nested call path might be built. However, nesting \u201cgosub\u201d calls is not possible when conventional solutions according to the state of the art are employed.","For a direct call the programmer of the calling step wants to specify a set of parameters and, in the case of a \u201cgosub\u201d call, to process the results of the called step. In conventional solutions according to the state of the art, parameters can be passed by using a common session data space. Thus, the state of the art allows passing parameters and returning results for direct calling.","For each of the expected following steps, the programmer of the given step wants to specify a set of parameters and, in some cases, to process the results of calling these steps. In conventional solutions according to the state of the art, step parameters are encoded within the client document (e.g. as HTTP GET or POST parameters), then returned by the client and put together by the system in the common session data space. The part, where these data can then be retrieved by the called step differs from the part where the step retrieves the data passed by another step that would call it directly. Thus, the state of the art allows passing parameters and returning results for indirect calling.","However, the problem here is that the step parameters are encoded within the client document, which results in a number of problems:\n\n","Sometimes, a step programmer wants to specify a following step that he\/she does not know yet, but which depends on things like the usage history of the system, or a specification of the current application. Such cases might include\n\n","For example, Struts offers symbolic steps for direct calling of steps, but neither for indirect calls nor is there a possibility to pass parameters to the called steps. Due to the lack of the possibility of nesting \u201cgosub\u201d calls, there is also no means to use symbolic steps that depend on the nesting of calls.","The following table shows that conventional solution according to the state of the art tackle none of the problems described above:",{"@attributes":{"id":"p-0031","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Nested","Solution for Problems",{}]},{"entry":[{},"\u201cgosub\u201c","at Passing Parameters","Symbolic"]},{"entry":[{},"Calls","for Indirect Calls","Steps"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CGI Scripts","no","no","no"]},{"entry":["Servlets","no","no","no"]},{"entry":["Action\/Events","no","no","no"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"In view of the explanations mentioned above, it is the object of the underlying invention to propose a technology that solves the problem of re-using application steps in a uniform way. Furthermore, the inventions deals with the problem of automatically calling these steps according to user interactions in an HTTP-independent way and\/or the problem of allowing a nested usage of said steps.","This object is achieved by means of the features of the independent claims. Advantageous features are defined in the dependent claims. Further objects and advantages of the invention are apparent in the following detailed description.","The underlying invention is basically dedicated to the idea of supporting client\/server architectures and distributed processing systems in a distributed computing environment capable of processing multiple, nested, synchronous and concurrent remote procedure calls. In particular, it can pertain to mobile service portals, application servers and transaction systems in heterogeneous telecommunication networks where these application environments are employed.","The independent claim  and the claims  to  are related to a method for dispatching steps of at least one application running on an application server of a service portal in a client\/server system of a distributed computing environment which can be accessed from client terminals connected to said service portal, wherein users interact with an application running on a remote application server by selecting user interaction elements on their client terminals with the aid of a client program, interactions are then transmitted to the application server where the main part of said application is executed, and the application creates output that contains the next set of possible user interactions. Thereby, the following steps are performed:\n\n","Next, the dependent claim  is directed to a service portal for a client\/server architecture in a distributed computing environment configured for implementing a method according to anyone of the claims  to .","Moreover, the dependent claim  pertains to a method executed by a request dispatcher, which is integrated in said service portal according to claim .","Besides, the dependent claim  is directed to a software program running on an application server of a service portal in a client\/server system of a distributed computing environment which executes a method according to anyone of the claims  to .","Finally, the dependent claim  refers to a client\/server architecture of a distributed computing environment enabling users to indirectly interact with an application running on a remote application server, in which a service portal according to claim  configured for implementing a method according to anyone of the claims  to  is applied.","In the following, a preferred embodiment of the underlying invention as depicted in  shall be explained in detail. The meaning of the symbols designated with reference signs in  can be taken from Table 3.","The proposed approach underlying invention refers to a system which is able to split up applications into a number of reusable parts (the steps -). For example, a messaging application is decomposed into a \u201ccompose message\u201d step  and a \u201csend message\u201d step. Thereby, said system allows to reuse the parts outside of application boundaries. Other applications are free to incorporate those parts into their own overall application flow at any time.","A formalized view of the solution is shown in . Herein, it is assumed that before a user interaction can take place a rule set exists that states which step -with which parameters has to be called in case of different user interactions. This rule set can either exist explicitly in the system, or it is encoded in the client document (e.g. in case of HTML documents or special client programs), or a combination of both (see Table 1). As shown in , the rule set for a certain step i is either created or at least modified by the previous step i-. In case no rule set exists, a default rule set is deployed. It should be noted that the action associated with a certain rule is not static and might change according to the respective client context or server context. For example, the entry \u201cid=5\u201d might only be equal to \u201cparameter a=1, b=3\u201d if the user has a certain location but might change it if the situation differs.",{"@attributes":{"id":"p-0050","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Different Cases for Rule Sets and Client Document"},{"entry":"Combinations"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Client Document","Rule Set"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Case 1","element 1 \u2212> step 1,","None"]},{"entry":[{},"parameter a = 1, b = 3"]},{"entry":[{},"element 2 \u2212> BACK,"]},{"entry":[{},"parameter c = 4"]},{"entry":["Case 2","element 1 \u2212> step 1, id = 5","id = 5 \u2212> parameter a = 1,"]},{"entry":[{},"element 2 \u2212> BACK, id = 6","b = 3"]},{"entry":[{},{},"id = 6 \u2212> parameter c = 4"]},{"entry":["Case 3","element 1 \u2212> id = 5","id = 5 \u2212> step 1, parameter"]},{"entry":[{},"element 2 \u2212> id = 6","a = 1, b = 3"]},{"entry":[{},{},"id = 6 \u2212> BACK, parameter"]},{"entry":[{},{},"c = 4"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"On the client terminal the user selects an interaction element (e.g. by pressing a button). The message that is associated with that user interaction is now sent to the client gateway  on the server. The message occurs in a client-specific format and is translated into the client-independent format used by the request dispatcher . In the first case, the underlying client-specific message already contains the step name and the parameters. In the second case, the client-specific message already contains the step name and an identity number (id). The client gateway  replaces this id by the corresponding parameters. In the third case, the client-specific message contains an identity number only. The client gateway  replaces this identity number by the corresponding step name and the parameters.","Afterwards, the translated request message is sent to the request dispatcher . This message now consists of a pair (step name, parameters). If the pair which has been generated in that way contains a symbolic step name like PARENTSTEP, MAIN MENU, etc., the dispatcher  replaces the symbolic step name by a pair from the step stack If PARENTSTEP e.g. denotes the step that called the actual step the top-of-stack element is fetched and used. If MAIN MENU denotes the top-level step of the system, the complete stack is emptied and the first step name is used.","Now the dispatcher  knows a step name and some parameters. It calls the corresponding step using the corresponding parameters. This step is now started. Before the step finishes, it may (but does not need to, see below) create parts of the next client document and the next rule set so the system knows how to handle the next user interaction. In addition, it can access (i.e. read and\/or write) the step stack thus creating the next step stack state ","Before it is finished, the step can also call other steps (which can, recursively, also call other steps). These steps may also create parts of the client document and the next rule set The steps to be called can be references either by naming them or by specifying again a symbolic step name like PARENTSTEP or MAIN MENU.","In general, there are two types of calling a step. The first type, \u201cgoto\u201d, passes the control to the called step and finishes the execution of the calling step. The second type, \u201cgosub\u201d, calls the next step, but returns control after the called step has finished. In this case, the calling step can also evaluate possible results the called step might return. In case of a \u201cgosub\u201d call, the calling step is asked for some parameters, and the step name and its parameters are pushed on the stack.","If a step which has been called by a \u201cgosub\u201d call is finished, it specifies the symbolic step name PARENTSTEP, if appropriate. In this case, the first element of the stack is taken from the stack and used for execution (thereby using the parameters this step specified when \u201cgosub\u201d-calling the step to be finished).","The response to the initiating request is then delivered to the client terminal Finally, the whole process starts again after the user has selected an interaction element.","Using this mechanism, there are two ways to realize an application workflow. The application workflow is the controlling scheme that determines how the steps of one application relate under the aspect that the application is in one step and the user selects a specific interaction element.","The first way is to employ a Distributed Application Workflow scheme  as depicted in  wherein each step contains the partial workflow determining the following steps that can be reached from the current step. In this scheme, a step has to contain workflow parts of multiple applications if it is used in multiple applications ","The second way is using a Central Application Workflow scheme  as depicted in  wherein the workflow is kept inside a special step. In this scheme, during one application always this special step, the application controller is called by the request dispatcher . The application controller then calls the adequate step directly. In this scheme, a step does not have to be modified if said step is used in different applications ","In the following sections, a number of methods shall be proposed which can advantageously be applied to realize the invention. Thereby, an implementation of a step-based system as already introduced in the above section shall be presented. This system uses a pure dispatcher  or step structure as shown in  and does not deploy any additional application controller Applications are free to implement this controller on their own if they need it.","Thereby, applications offer steps to other applications. While an interface is just a collection of method calls without any user interaction, a step may embody more complex functionality that includes user interaction. As an example, the retrieval of some context information from a context service is covered in an interface, while the sending of a message by a messaging service is implemented as a step since it involves user interaction.","In , all required components are shown. Some interconnections and\/or support components were omitted to simplify explanations. Every part and its relations to any other part will be explained in the following.\n\n","Since one step might invoke other steps in order to complete certain tasks, a mechanism is needed that allows to return to the calling instance after completion in case \u201cgosub\u201d calls are applied. For instance, a community\/messaging application might invoke a \u201csend message\u201d step and a \u201ccompose message\u201d step . After the message has been send, the application flow should lead back to the community\/messaging application. For that purpose, the request dispatcher  maintains a step invocation trace, or, in short, a \u201cstep stack \u201d. Whenever a new step is invoked, it is put on top of the stack. If a step needs to reference the parent step, it does so by using a reserved keyword for the reference In case, the request dispatcher  encounters this keyword, pops the top element from the stack, and invokes the according step.","Each step might produce output elements and interact with the user. However, since the output is adapted towards the client terminal and back again into the system by the processing chain as outlined in , one can abstract from the concrete interaction with the user for the following considerations.","The step stack for the community\/messaging application interaction mentioned above is shown in . Here, a step for selecting certain members of a community wants to use a means for sending a message to the currently selected user. It therefore references a step from the community\/messaging application. At this moment, the \u201cCommunity Select User\u201d step  is the top element of the step stack and therefore the one that is currently executed (). If the user interaction results in a branch to the messaging step, the request dispatcher  adapts the step stack accordingly by making the messaging step the top element in the step stack and thus the one that has to be executed (). Once the underlying community\/messaging application has finished execution and wishes to return to the calling instance, it references the parent step. Since this step does not have any knowledge on which step it has been invoked, it will reference the parent step not by using the parent step name itself but by a reserved keyword that is recognized and accordingly resolved by the request dispatcher . In this case, the reference to the parent step name will lead to the removal of the top element in the stack by the request dispatcher , hence making the \u201cCommunity Select User\u201d step  from the community\/messaging application again the top element and therefore the one that is executed (). At this point, the community\/messaging application can check the return value of the messaging step to determine if the step execution was successful.","If an error occurs, an adequate output is created either by the request dispatcher  or by the step that failed. The request dispatcher  can then choose to remove or to re-execute the step on top of the stack. In case of low level, non-application-specific errors (e.g. empty step stack ), the request dispatcher  returns to a default state, e.g. the main menu step.","Steps are assumed to be stateless within this embodiment of the underlying invention and are therefore not able to store any information within any internal storage area. To circumvent this shortcoming, a step context is introduced. A step context is a storage area that is kept persistent as long as a step is available within the step stack Furthermore, a dedicated step context is only visible to a certain step. Once a step is discarded because it finished execution and is removed from the step stack the according step context is also disposed.","Aside from the step-specific step context, there is also an application context available for storing information beyond the life time of the stateless step. The application context is available for the life time of an application which normally exceeds the one of a certain step by far.","In the following sections, technical details of the proposed step implementation, the procedure of resolving different step names, passing and returning values from steps, and the \u201cgoto\u201d and \u201cgosub\u201d calling of steps according to the proposed embodiment of the underlying invention shall be described in detail.","Each step is referenced by a unique symbolic name. For each incoming request, the request dispatcher  resolves the request string to the according class and invokes a dedicated method in it. Thereby, each step is per definition stateless, which means that it is created for each request and disposed afterwards. This simplifies the implementation to some degree but could also be solved differently in any other systems.","The request dispatcher  holds the mapping from symbolic step names to the real implementation of them. In addition there are some symbolic step names (e.g. \u201cPARENTSTEP\u201d) that are not mapped directly to a step implementation but assigned to different steps according to the current application's state. Depending on the respective implementation, calling the parent step equals the back functionality in the application flow. For example, if the system puts every step in any case on top of the step stack the parent step is equivalent to invoking the previous (back) step. In case a \u201ccommunity step\u201d  calls a \u201ccompose message\u201d step , the \u201ccompose message\u201d step  will reference the \u201ccommunity step\u201d  by \u201cPARENTSTEP\u201d in case it wishes to return to the calling instance. The request dispatcher  will resolve this to the step implementation of the parent step without consulting the step to an implementation mapping by simply taking the previous element from the step stack ","In some cases, it is required to pass parameters and retrieve return values from a step. For instance, for a \u201ccompose message\u201d step  it is useful to preset a default message and return a status flag indicating if the message delivery was successful or not. For that purpose, the system allows to pass parameters either directly when invoking a step directly by \u201cgosub\u201d or \u201cgoto\u201d calls or by setting it indirectly via step-internal methods. The request dispatcher  will then take care that the parameter is passed to the next step. The same is true for return values: They can either be returned directly to the calling instance in case of a \u201cgosub\u201d or \u201cgoto\u201d call or accessed via step-internal methods. In the latter case, they have accordingly to be set by the request dispatcher  to allow later access.","So far, calling other steps was associated with certain user interaction. In some cases, however, it might be useful to call a step directly from within a step to include certain user interface elements or to pass control to another step that should continue with the execution.","Therefore, the system allows two ways to invoke other steps from within one step: \u201cgoto\u201d and \u201cgosub\u201d calls. When a step uses a \u201cgosub\u201d call to include another step, the called step is invoked and the control flow is returned afterwards to the calling instance. In case of \u201cgoto\u201d calling of another step, the control flow is completely passed to the called step\u2014for example, the called step becomes the top element in the step stack and the invoking step is removed from it.","The proposed technology according to the underlying invention can be implemented in any system that supports a request-and-response scheme with the additional possibility to influence the overall process. However, some existing platforms seem to be more suitable than others. In the following, some of these technologies will be introduced, and the benefit of deploying them for implementing the system is outlined.\n\n","The main advantageous differences between the herewith proposed approach according to the underlying invention and conventional solutions according to the state of the art can be summarized as follows:\n\n",{"@attributes":{"id":"p-0078","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Used Terminology"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Term","Definition"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["\u201cGosub\u201d Call","If a step calls another step by means of a \u201cgosub\u201d"]},{"entry":[{},"call, the calling step passes the control to the"]},{"entry":[{},"called step and stops. Then the called step is"]},{"entry":[{},"executed. Afterwards, the calling step is executed"]},{"entry":[{},"again, possibly using some execution result of the"]},{"entry":[{},"called step."]},{"entry":["\u201cGoto\u201d Call","If a step calls another step by means of a \u201cgoto\u201d"]},{"entry":[{},"call, the calling step passes the control to the"]},{"entry":[{},"called step and does not expect to get this con-"]},{"entry":[{},"trol back."]},{"entry":["Application","An application is a program that can be started on"]},{"entry":[{},"a portal by a user, offering some functionality."]},{"entry":[{},"Applications consist of a number of steps in this"]},{"entry":[{},"invention."]},{"entry":["Client","A client program is any means that allows a user"]},{"entry":["Program","to interact with parts of the applications by exe-"]},{"entry":[{},"cuting a client document. Examples for client pro-"]},{"entry":[{},"grams are HTML browsers, WAP browsers, and Java"]},{"entry":[{},"programs."]},{"entry":["Client","A client document is a piece of data that is used"]},{"entry":["Document","by the client to display user interaction elements"]},{"entry":[{},"and other elements like text and graphic. It can"]},{"entry":[{},"contain information like the type and number of"]},{"entry":[{},"the user interaction elements, but also informa-"]},{"entry":[{},"tion about how the elements shall look like."]},{"entry":["Client","The client terminal denotes the system where the"]},{"entry":["Terminal","client is executed. It is connected to the application"]},{"entry":[{},"server of a portal by some communication means."]},{"entry":["Direct Call","If a step calls another step directly, no user in-"]},{"entry":[{},"teraction decouples the two executions. This call"]},{"entry":[{},"corresponds to procedure calls in programming lan-"]},{"entry":[{},"guages."]},{"entry":["Indirect Call","If a step calls another step indirectly, the call-"]},{"entry":[{},"ing step declares that the called step could be"]},{"entry":[{},"started in case of a corresponding user interac-"]},{"entry":[{},"tion. There might be other steps called due to"]},{"entry":[{},"other user interactions."]},{"entry":["Portal and","A portal or server in this document denotes the"]},{"entry":["Server","role of the system where the applications are exe-"]},{"entry":[{},"cuted using the described invention. The applica-"]},{"entry":[{},"tion server of a portal is connected to a client"]},{"entry":[{},"terminal by means of a telecommunication network."]},{"entry":["Step","A step is a part of an application. It may involve"]},{"entry":[{},"side effects (such as storing some data in a"]},{"entry":[{},"file), and\/or create some output (in form of parts"]},{"entry":[{},"of the client document)."]},{"entry":["User","A user interaction element allows a user to interact"]},{"entry":["Interaction","with an application. The result of a user interacting"]},{"entry":["Element","with a user interaction element is a state"]},{"entry":[{},"change that shall initiate a certain behavior"]},{"entry":[{},"of the application. Examples for user interaction"]},{"entry":[{},"elements are buttons, sliders, text fields,"]},{"entry":[{},"menus, keyboard input, and mouse input."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0079","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Depicted Features and their Corresponding"},{"entry":"Reference Signs"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["No.","Feature"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["100","overview diagram which illustrates the general mechanism"]},{"entry":[{},"for dispatching application steps 109a-i in a client\/"]},{"entry":[{},"server system according to the underlying invention"]},{"entry":["101","user\/client request"]},{"entry":["102a","client terminal connected to the service portal 102b via"]},{"entry":[{},"the Internet and\/or any corporate network"]},{"entry":["102b","(mobile) service portal or transaction system connected to"]},{"entry":[{},"the Internet and\/or any corporate network"]},{"entry":["102c","Web application server of a service portal 102b"]},{"entry":["104","client gateway connected to the Internet and\/or any corpor-"]},{"entry":[{},"ate network"]},{"entry":["106","request dispatcher of the service portal 102b"]},{"entry":["108a","step rule set at discrete time t"]},{"entry":["108b","step rule set at discrete time t"]},{"entry":["109a","1application step of a first application 202a (X)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109b","2application step of said first application 202a (X)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109c","3application step of said first application 202a (X)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109d","1application step of a second application (Y) 202b"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109e","2application step of said second application 202b (Y)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109f","3application step of said second application 202b (Y)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109g","1application step of a third application 202c (Z)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109h","2application step of said third application 202c (Z)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["109i","3application step of said third application 202c (Z)"]},{"entry":[{},"running on the Web application server 102c at discrete"]},{"entry":[{},"time t"]},{"entry":["110a","step stack at discrete time t"]},{"entry":["110b","step stack at discrete time t"]},{"entry":["112a","terminal document at discrete time t"]},{"entry":["112b","terminal document at discrete time t"]},{"entry":["114a","step parameter set at discrete time t"]},{"entry":["114b","step parameter set at discrete time t"]},{"entry":["116a","reference to a \u201cCompose Message\u201d step 608"]},{"entry":["116b","reference to the parent step"]},{"entry":["200","Distributed Application Workflow scheme for three applica-"]},{"entry":[{},"tions, wherein each step of an application contains the"]},{"entry":[{},"partial workflow determining the next steps that can be"]},{"entry":[{},"reached from this step"]},{"entry":["202a","first application (X) running on the Web application"]},{"entry":[{},"server 102c"]},{"entry":["202b","second application (Y) running on the Web application"]},{"entry":[{},"server 102c"]},{"entry":["202c","third application (Z) running on the Web application"]},{"entry":[{},"server 102c"]},{"entry":["300","Central Application Workflow scheme for three applica-"]},{"entry":[{},"tions, wherein the workflow is kept inside a special step"]},{"entry":["302a","application controller for the first application 202a (X)"]},{"entry":["302b","application controller for the second application 202b (Y)"]},{"entry":["302c","application controller for the third application 202c (Z)"]},{"entry":["400","simplified block diagram showing the required system com-"]},{"entry":[{},"ponents according to the underlying invention"]},{"entry":["402","client adaptation block"]},{"entry":["404","service and service support block"]},{"entry":["406","rendering and transcoding component"]},{"entry":["408","session management unit"]},{"entry":["500","block diagram that illustrates the overall process of the"]},{"entry":[{},"requested dispatcher working principle according to the"]},{"entry":[{},"underlying invention"]},{"entry":["600","three step stack examples for a so-called community\/"]},{"entry":[{},"messaging application interaction, wherein"]},{"entry":[{},"the \u201cCommunity Select User\u201d step 602 is the top ele-"]},{"entry":[{},"ment of said stack to be executed first (FIG. 6a),"]},{"entry":[{},"the \u201cCompose Message\u201d step 608 is the top element of"]},{"entry":[{},"said stack (FIG. 6b) to be executed first, and"]},{"entry":[{},"the \u201cCommunity Select User\u201d step 602 is again the top"]},{"entry":[{},"element of said stack (FIG. 6c) after the removal of the"]},{"entry":[{},"\u201cCompose Message\u201d step 608 by the request dispatcher 106"]},{"entry":[{},"to be executed first"]},{"entry":["602","\u201cCommunity Select User\u201d step"]},{"entry":["604","\u201cCommunity Main\u201d step"]},{"entry":["606","\u201cApplication Browser\u201d step"]},{"entry":["608","\u201cCompose Message\u201d step"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Further advantages and possible applications of the underlying invention will become evident from the following description of the preferred embodiment of the invention, which is depicted in the following drawings:",{"@attributes":{"id":"p-0041","num":"0068"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0042","num":"0069"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0043","num":"0070"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0044","num":"0071"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0045","num":"0072"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0046","num":"0073"},"figref":"FIG. 6","ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["the \u201cCommunity Select User\u201d step is the top element of said stack to be executed first (),","the \u201cCompose Message\u201d step is the top element of said stack () to be executed first, and","the \u201cCommunity Select User\u201d step is again the top element of said stack () after the removal of the \u201cCompose Message\u201d step by the request dispatcher to be executed first."]}}}}]},"DETDESC":[{},{}]}
