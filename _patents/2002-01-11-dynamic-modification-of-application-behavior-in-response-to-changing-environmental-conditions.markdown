---
title: Dynamic modification of application behavior in response to changing environmental conditions
abstract: Methods, systems, and computer program products for dynamically modifying an application program's behavior in response to changing environmental conditions (such as network changes, system changes, and so forth). The application may solicit such information, and/or may receive unsolicited environmental change notifications. In response to a change notification, the application may take one or more of the following approaches to adapt to the changing conditions: (1) alter its execution; (2) modify its use of, or control of, other cooperating application; and (3) modify the selection of application execution threads. (An application might also decide to make no changes in its behavior.)
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667165&OS=08667165&RS=08667165
owner: International Business Machines Corporation
number: 08667165
owner_city: Armonk
owner_country: US
publication_date: 20020111
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to computer systems, and deals more particularly with methods, systems, and computer program products for dynamically modifying an application program's behavior in response to changing environmental conditions (such as network changes, system changes, and so forth).","2. Description of the Related Art","Today's global network is a complex interweaving of multiple network technologies, server platforms, client capabilities, and application requirements. A key application requirement is the ability to provide differing Quality of Service (hereinafter, \u201cQoS\u201d) values, such as priority specification for specific units of work, such that more important traffic receives favored status in the allocation of server and network resources.  depicts a representative modem distributed computing environment , in which two classes ,  of servers have been chosen arbitrarily on which to anchor the portrayed configuration. Note that there are many more types of servers than those shown, and that in reality, modem computing networks tend to be significantly more complex than the one shown. Nonetheless, environment  is sufficient to demonstrate the current networking environment and to illustrate advantages of the present invention.","The server classes ,  shown in  represent (a) two multimedia servers  on which reside real-time, or near-real-time, applications and (b) one clustered server complex  with server instances  which support multiple differing applications. (The clustered server complex  is shown as having three instances , for purposes of illustration only. An actual clustered server complex might have more or perhaps fewer instances.) The applications which execute on these servers ,  may perform a number of different types of functions, including transactions, queries, and large file transfers. The applications executing on the multimedia servers, for example, might transmit large amounts of data in the form of video streams or audio streams.","Client access to the servers and server complex is provided by a multiplicity of network media. In addition to being of various types, these media are also often separated by organizational boundaries. For example, one branch office of an enterprise might use Token Ring local area networks (\u201cLANs\u201d) for connecting user devices, while a branch office with mobile personnel might rely more heavily on wireless media. The clients in the figure are shown as being connected by three different types of local network media attachment, and the clients having these types of attachment are designated in the figure as \u201ccabled stations\u201d (\u201cCS\u201d), \u201cwide-area networking stations\u201d (\u201cwS\u201d), and \u201cwireless stations\u201d (\u201cWS\u201d). As the terms are used herein, cabled stations are those connected by a LAN, and wide-area networking stations are those connected by a wide-area networking (\u201cWAN\u201d) protocol. Representative examples of WAN protocols include: Frame Relay; Asynchronous Transfer Mode (\u201cATM\u201d); variations of Digital Subscriber Line (\u201cDSL\u201d), also referred to collectively as \u201cxDSL\u201d; and so forth. Wireless stations are those connected using a wireless protocol.","Revisiting the discussion of the classes of servers which are accessible in the network, it is observed that the collective set of applications running on these servers transmits and receives data with varying characteristics. These characteristics include an aggregate amount of data sent\/received per unit of time, whether the application has real-time requirements, sizes of data objects typically processed by the application, etc. Furthermore, within the course of a single logical unit of work, a single application may require the transmission\/reception of data in multiple formats, where each of these formats may have its own attributes.","In some cases, QoS values are used as the subject matter of service contracts; in other cases, QoS values may simply represent user expectations. Processing data streams which have varying characteristics (such as those described above) in a manner that successfully meets QoS expectations requires the introduction of various workload management prioritization schemes. Consider the following broad classifications of data streams:","Real-Time Data: Real-time, or time-sensitive, data must be delivered in an ordered and highly predictable manner, such that data reception by the client is perceived as a single uniform stream. An example of real-time data is transmission of a digital video file.","Mission-Critical Data: Mission-critical data may be a customer transaction, an interactive inventory control program, or any other operation deemed critical to the successful operation of a particular business. For example, a customer's order to purchase goods or services may be considered mission-critical for an e-commerce business.","Non-critical Data Transfers: Non-critical data transfer does not imply that the data stream is not important. It simply implies a lower need for immediate delivery and processing of the data, as opposed to mission-critical or real-time data transfer. An example of non-critical data transfer may be downloading an image from an on-line catalog.","As will be obvious, the detailed definition of these rather broad classifications (i.e., what type of data falls into each category) may vary from one enterprise to another. It will generally be true, however, that all enterprises will require that servers and networks order the processing of data such that higher-priority data is processed and transferred ahead of lower-priority data. The term \u201cQuality of Service\u201d is often used to describe this ordering requirement, and ordering or prioritization techniques are generally applicable to both server-based technologies and network technologies.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2","b":["200","105","110","1","2","3","4","220","1","3","105","2","4","110","215","225","1","220"]},"In the example scenario of , suppose that the high packet volume for the multimedia traffic sent to clients C. and C. completely overwhelms the capabilities of the router gateway , or perhaps of the LAN . In this situation, the traffic flow for application data sent to clients C. and C. will be degraded, and some data may even be discarded before it reaches the clients. Client C. might be interacting with an application program that performs some type of relatively low-priority function, for which this traffic degradation is not a serious issue. However, client C. might be performing a mission-critical transaction. Thus, it is necessary for a QoS strategy to be in place to ensure that the differing requirements of the clients are met.","Both server-based and network-based prioritization technologies are commonly used in the prior art to provide traffic ordering in this type of environment in order to allow the mission-critical transactions to flow ahead of lower-priority traffic without disruption of the real-time video stream.","Regarding server-based mechanisms, there exists a set of services that allow the user (such as a systems administrator) to specify which task is to receive priority utilization of system resources, e.g. storage, central processing unit (\u201cCPU\u201d) share, etc. These prioritization services are typically platform-specific and vendor-specific, and are generally more sophisticated on more advanced platforms, such as OS\/390\u00ae, AIX\u00ae, Solaris\u2122, etc. In addition, the techniques used to assign resources to a task are generally non-standard and vary with the platform and vendor. (\u201cOS\/390\u201d and \u201cAIX\u201d are registered trademarks of the International Business Machines Corporation, hereinafter \u201cIBM\u201d, and \u201cSolaris\u201d is a trademark of Sun Microsystems, Inc.)","Network-based prioritization mechanisms generally act to associate a given traffic stream, connection, or individual packet with a user-requested and system-approved transmission priority. These prioritization mechanisms may be media-specific (such as ATM QoS specification techniques) or network protocol-specific. Examples of the latter case include Advanced Peer-to-Peer Networking (\u201cAPPN\u201d) class of service (\u201cCOS\u201d) features and the Transmission Control Protocol\/Internet Protocol (\u201cTCP\/IP\u201d) differentiated services protocol (which is sometimes referred to as \u201cDiffServ\u201d). APPN COS values are derived from a mode name specified by a session initiator, and DiffServ values are specified by setting a bit pattern of a particular field in IP packet headers.","Typically, the combination of server-based (or, equivalently, \u201csystem-based\u201d) and network-based prioritization mechanisms act in concert to ensure that higher-priority network traffic is processed ahead of lower-priority traffic. These mechanisms may also act to ensure that required data stream attributes are realized. For example, the reduction of jitter in real-time data streams is an attribute that may be controlled in this manner. (In this context, the term \u201cjitter\u201d refers to non-uniform time intervals for delivery of real-time data streams. Bad cases of jitter may result in video or audio interference.) Because the various mechanisms use vendor-specific, media-specific, and\/or network protocol-specific techniques, however, as discussed above, there is a huge administrative burden placed on system providers and network providers to coordinate and control the mechanisms to ensure that the result is a properly-tuned system. Dynamic, often unpredictable changes to the environment make this task even more daunting.","Therefore, even with the constantly-improving technologies which are being deployed in today's servers and networks, improvements are required to achieve optimal QoS control, and in particular to ensure that user expectations, including contracted system and network service levels, can be met.","An object of the present invention is to define techniques for improving quality of service.","Another object of the present invention is to provide improved application traffic delivery.","An additional object of the present invention is to provide improvements in traffic delivery which incorporate input regarding network conditions as well as server-based input data.","A further object of the present invention is to provide improvements in traffic delivery by dynamically modifying an executing application's behavior.","Still another object of the present invention is to provide techniques which allow application behavior to be modified based on network conditions and\/or server-based information.","Other objects and advantages of the present invention will be set forth in part in the description and in the drawings which follow and, in part, will be obvious from the description or may be learned by practice of the invention.","To achieve the foregoing objects, and in accordance with the purpose of the invention as broadly described herein, in a first aspect the present invention provides methods, systems, and computer program products for improving data transfer in computing networks. Preferably, the technique of this aspect comprises: detecting a changed environmental condition; generating a notification of the detected condition; analyzing the generated notification by consulting one or more criteria; and determining, based on the analysis, whether a currently-executing application should modify its behavior. The technique preferably further comprises the currently-executing application then modifying its behavior.","A number of types of modifications made be made, including (by way of illustration): reducing (or increasing) a size of one or more data objects generated by the currently-executing application; reducing (or increasing) data retrieval by the currently-executing application; dropping one or more connections with the currently-executing application; changing thread assignments of the currently-executing application; and changing the currently-executing application's use of one or more other applications.","The changed environmental condition may pertain to system-related conditions, network-related conditions, or client-related conditions in one or more clients of the currently-executing application.","The changed environmental condition may occur internally to a system in which the currently-executing application is executing, or externally to such a system. In the former case, the generated notification may pertain to (inter alia) a condition of a local network protocol stack, or to a condition of the system in which the currently-executing application is executing. In the latter case, the generated notification may pertain to (inter alia) a condition of a client of the currently-executing application, a condition of a remote network platform, or to a condition of a remote server with which the currently-executing application is communicating (in which case the modification may comprise making adjustments pertaining to the remote server).","The analyzing may be done by a policy manager component of the system in which the currently-executing application is executing.","In another aspect, the present invention comprises methods, system, and computer program products for dynamically modifying behavior of an executing application in response to changing environmental conditions, comprising: exchanging information among multiple components of a network as to each component's support for environmental awareness; detecting, by a selected one of the components, an environmental change; determining, responsive to the detecting, those other ones of the components which indicated an interest in the detected environmental change during the exchange; notifying those other ones of the detected environmental change; and dynamically modifying behavior of an application currently executing at one or more of the notified components, in order to account for the detected environmental change.","The present invention may also be used advantageously in methods of doing business, for example to provide improved service provider offerings whereby data transfer rates are improved.","The present invention will now be described with reference to the following drawings, in which like reference numbers denote the same element throughout.","The present invention discloses novel and advantageous techniques for controlling the performance of a computing system to ensure that user expectations can be met (including those expectations that form the subject matter of QoS agreements, which are sometimes known as \u201cService Level Agreements\u201d or \u201cSLAs\u201d). According to the present invention, an executing application dynamically modifies its behavior in response to changing environmental conditions. These changing conditions include network changes and system changes. Network changes include whether the network is experiencing congestion, whether there are outages in the network, and so forth. System changes include things such as buffer shortages, thread scheduling problems, and other resource shortages. (Note that while discussions herein are primarily in terms of detecting problems of one type or another, \u201cchanging conditions\u201d may also be interpreted in a positive sense, such as when a problem has been alleviated and a network or system is returning to more normal operations. These types of positive changes are also included within the scope of the present invention. Furthermore, it should be noted that the conditions or problems described herein are merely illustrative, and the description is not intended to provide an exhaustive list.)","An executing application may solicit information about current environmental conditions, and\/or it may receive unsolicited change notifications. In response to a change notification, the application may take one or more of the following approaches to adapt to the changing conditions: (1) alter its execution; (2) modify its use of, or control of, other cooperating application; and (3) modify the selection of application execution threads. Or, depending on the particular change, the application might alternatively make no changes in its behavior.","As one example of how an application might alter its execution, according to the techniques disclosed herein, suppose an executing application receives notice that the network is currently severely congested. If the application continues to send large amounts of data to its clients, the congestion problem is likely to get even worse\u2014and the data might be discarded (e.g., as a particular device in the network experiences an overrun situation). Therefore, the application may determine to produce less data, or not retrieve certain data, for sending to one or more of its clients until the congestion problem is alleviated.","To expand on this example in more detail, suppose that the multimedia server  from the scenario illustrated in  is sending its video stream to clients C. and C. (and possibly to many other clients as well) using the well-known MPEG transmission format. To achieve a high-quality picture, server  may be transmitting some number \u201cn\u201d of cells or frames per second. If the network path to one or more of the receiving clients becomes congested, or perhaps a remote router between the server  and particular clients experiences overrun, then an appropriate notification back to the multimedia application which is generating the video stream may result in the application deciding to begin sending on \u201cn\u2212p\u201d frames per second. The actual values of \u201cn\u201d and \u201cp\u201d are not significant to the present discussion; what is of importance is that some reduction in the amount of data being generated will occur. Thus, the application is able to impact the delivery of traffic at the traffic source.","Commonly-assigned U.S. Pat. No. 6,138,156, which is titled \u201cSelecting and Applying Content-Reducing Filters Based on Dynamic Environmental Factors\u201d, discloses techniques whereby dynamic environmental factors can be used to filter message content, with the aim of reducing the amount of data to be transmitted under certain conditions. A plurality of filters is available for reducing message content. Depending on the current conditions, one of these filters is selected and applied. As an example, content reduction may be achieved by transcoding a file containing a full-color image file to create a smaller gray-scale image. Preferred embodiments account for conditions such as the user's device type; billing information about the user's connection to the network; current conditions on the workstation, including its available storage capacity; this user's behavior patterns; or any combination of these or similar factors, and it was filed Nov. 17, 1999","Commonly-assigned U.S. patent application Ser. No. 09\/442,015, filed Nov. 17, 1999), which is titled \u201cContext-Sensitive Data Delivery Using Active Filtering\u201d, discloses techniques whereby a server pre-filters data to be delivered to a client based upon factors such as the client device type, preferences of a user of that device, and the user's current location. By pre-filtering the data, it can be made available to the user more efficiently. As an example, an application may be creating content for a general audience, or may have already created that content (e.g. as in the case of static Web pages which are created and stored for subsequent transmission to requesters), expecting that content to be received at a full-function computer. According to U.S. patent application Ser. No. 09\/442,015, the server may create one or more alternative versions of this content for transmission to requesters who do not have a full-function computer, such as for those users requesting the content from a network-accessible cellular phone or a handheld computing device.","The techniques disclosed by these two U.S. patents modify an already-generated file or traffic stream, This is in contrast to the present invention, where the file or traffic stream is adapted for the current environmental conditions during its creation\u2014that is, by the application which originally creates the data.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIGS. 3A and 3B","FIG. 3A","FIG. 3A"],"b":["305","310","315","320","325","330","335","335","340","345"]},"In the present invention, as illustrated by , a user application  still generates or retrieves data for eventual transmission to a user. However, a component which is referred to herein as a \u201cpolicy manager\u201d  provides input to an application-layer component  as to current environmental conditions, and application  considers this input during its execution. Therefore, when application  has outbound data to send  through API  for forwarding ,  to network  for delivery to the user, this data is already modified. (Policy manager  may also receive information from the application-layer component , as indicated by flow . This will be described in more detail below.) Note that the application-layer component  which is depicted as interacting , with the policy manager  is not necessarily a stand-alone component, as it has been illustrated in . The functions of such a component, which will be described below, may be included directly within an application  if desired.","It may happen that the output generated from using the present invention reaches a system or component which performs transcoding, including a system or component which implements the techniques of the two U.S. patents which have been discussed. When the application  operating according to the present invention learns from the policy manager  that (by way of example) the network is congested and therefore determines that it should send less outbound data, however, the need for applying a subsequent transcoding operation may be eliminated. (Or, it might happen that the data is still transcoded, but that a \u201cless severe\u201d type of content reduction can be performed in that transcoding operation.) Some transcoding operations may be relatively expensive to perform, in terms of processing time, CPU consumption, etc. Therefore, avoiding the need for transcoding by transmitting less data from the source (i.e. from the application) provides a very advantageous approach to an overall traffic infrastructure.","Adequate provisioning of a robust traffic management scheme may be likened to the tripod shown in . Current technology is providing the system  and network  \u201clegs\u201d for the provisioning of the establishment of a robust and stable QoS infrastructure . What is missing, and what is provided by the present invention, is the third \u201cleg\u201d of the tripod, whereby the application  also participates in ensuring that traffic management operates efficiently and effectively.","Consider the nature of the problem that occurs without application participation. Returning to the prior art scenario which was discussed with reference to , if network congestion increases to a point where existing QoS levels can no longer be met, there is no alternative other than the discard of data and the negation of existing QoS agreements. Because QoS agreements may be tied to service pricing (e.g. in SLAs), this is a very undesirable situation. The existing technology provides no means by which the ultimate traffic \u201cgenerator\u201d, i.e. the application, may be alerted so that it can potentially modify its execution with the goal of reducing the traffic that enters the system and\/or network. Hence, in the example of , there is no means to automatically reduce the video stream being generated by the multimedia server  for delivery to clients C. and C., based on dynamic conditions, when using prior art solutions. If the low-priority function being performed by client C. is requesting delivery of a Web page, there is no means to automatically modify the contents of that Web page (or perhaps to decide that some embedded content should not even be requested by the application). And, finally, there is no way to automatically reduce the contents of a transaction record size for the mission-critical transaction being performed by client C..","In summary, without the ability to modify the behavior of the application which generates the traffic, there is no total solution to the traffic management problem available in the prior art. The present invention provides novel and advantageous techniques for solving this problem. Using the disclosed techniques, more informed decisions can be made regarding tradeoffs between the utilization of server, network, and application resources.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 5","FIG. 5"],"b":["500","510","500","515","520","515","520","510","510","505","500","530","505","510","540","570","560"]},"Intermediate server  is depicted as including a \u201cfeedback component\u201d , and client device  is also shown as having a feedback component . (The feedback component may alternatively be referred to as a \u201cpolicy agent\u201d or \u201cremote policy agent\u201d.) This feedback component represents one or more functions which gather information about current conditions, and provide notifications to selected other components (which preferably includes, but is not limited to, application server ). The notifications may be sent automatically, in response to a triggering condition such as exceeding a particular defined threshold. Or, the notifications may be sent in response to an explicit request for another component (such as application server ). Support for these functions may be provided in selected components within the networking environment. Client support, while shown in , is optional. A particular implementation of the present invention may communicate with some clients which provide this support, and simultaneously with others which do not. Similarly, it is not strictly required that the feedback component is present in all intermediate servers or in the entire collection of other devices (such as routers and switches) which support the network. The example structure shown in  is therefore to be considered as illustrative and not as limiting.","Preferably, a feedback component sends outbound notifications of at least one of the following types of conditions: the local application has changed its resource prioritization (which may, in turn, impact the application's ability to process inbound traffic); the local system has a changed capacity (for example, due to higher-than-normal local processing demands); capacity changes have been detected in the network (which may, in turn, impacts the local device's ability to receive and\/or forward traffic). A feedback component may also serve as a policy manager for the local application, and therefore may communicate inbound environmental information to its local application. This inbound information may comprise locally-detected conditions of the type just discussed, or similar information which has been received from other components in the network.","It should be noted that while the discussions herein are primarily in terms of notifications being received (or conditions being detected) that result in communicating to the executing application, a particular implementation may optionally provide rules or filters which first evaluate those notifications or conditions, and make a decision about whether to notify the application. For example, a policy manager in an application server might be communicating with a large number of client devices. An outage or degradation notification that pertains to only one, or some limited number, of these devices might not warrant changing the application's behavior. The policy manager may thus incorporate additional knowledge, such as a knowledge of how many other clients are currently being served and perhaps anticipated changes in that workload, before deciding to notify the application of a problem. (Alternatively, such information can be used as input to a decision made by the executing application.)","When an application has been notified of a problem, the action(s) it takes may vary. The application may reduce the amount of data it sends to one or more clients, as has been discussed. Or, the application might completely drop one or more connections. And in some cases, the application might choose to ignore the notification. The appropriate response to a particular notification that may be received according to the present invention is application-dependent, and is outside the scope of the present invention. For ease of reference, the term \u201cprioritization action\u201d is used hereinafter to refer to the action or actions taken by the executing application in response to receiving a notification; a prioritization action may be any of the actions just described, or any other type of behavior change that is taken in response to a notification.","The mechanisms with which problems are detected in a system or in a network protocol or device also do not form part of the present invention. Such mechanisms are generally known in the art. Use of the present invention enables conveying environmental condition information among entities using protocols and data structures which are system-neutral, platform-neutral, and vendor-neutral. Processing that occurs within various network components to support the flows of this protocol will now be described with reference to the flowcharts in  and the data structures, or vectors, in .","Each component which is adapted to perform functions of the present invention (or a subset of those functions) preferably generates an \u201cinternal capabilities vector\u201d when that component performs its initialization process for the present invention. The vectors (or a functional equivalent thereof) are used to store information about the component's capabilities; when the component is subsequently queried as to its capabilities, the vector may be used to create a response message. The information in the vectors therefore forms the basic unit of information exchange when communicating among components as to their capabilities (whether those components are located within a single system or are located in multiple systems). The process of creating these vectors in a user application (or its supporting middleware which acts on its behalf), a local policy manager, a local network protocol, a remote server, and a network platform, respectively, is depicted in .","As the user application or its supporting middleware initiates its activation (Block ) of the present invention, it creates its version of the \u201cinternal capabilities\u201d vector. (References hereinafter to the user application should be interpreted as pertaining alternatively to its middleware, if the middleware provides this support on behalf of the application.) In the case of the user application, this vector may more correctly be termed an \u201cinternal request\u201d vector, as it stores information about what capabilities should be requested from other components.","In preferred embodiments, a user such as a network administrator defines which components the user application should monitor\/consider when making decisions regarding prioritization actions. This information may be obtained by prompting the user from a user interface, by reading data values which have been stored in a configuration file, or in other similar manners. In addition, the information may be supplied programmatically, for example by intelligent middleware which is adapted for this purpose. (As an alternative to obtaining this type of information dynamically, the information could be specified directly within the application code; however, preferred embodiments use the more flexible approach described herein.) Furthermore, a user preferably configures each component that is to participate in the dynamic application modification process disclosed herein. This component-level configuration preferably comprises specifying what types of information each component can provide, and may include more detailed information where appropriate. (For example, the user might configure a remote server to indicate that it can provide congestion information. If the server can provide information on several different degrees of congestion, then the user preferably specifies that as well.)","Returning to the discussion of , the user application's internal capabilities\/request vector will subsequently be used to create a request message that will be transmitted as a query to the policy manager to request information about what support is available. Upon receiving the request message, the policy manager will then create a response message which preferably comprises a revised version of the vector. This revised version preferably includes a response to each requested field from the application's request message, where the response indicates whether each of the requested capabilities is available. (Logic that may be used to implement this request and response processing is described below.) Therefore, the processing in  determines those things for which the user has configured the application to request support. Beginning at Block , a test is performed as to whether this application wishes to receive information about its clients. This is represented in  as \u201cclient awareness requested?\u201d. If this test has a positive result, then Block  sets a value  in the application's internal capabilities vector . Optionally, Block  may also set one or more values in field .  provides an example format and content for the internal capabilities vector, as will now be described.","Preferably, the internal capabilities vector is structured in functional areas which correspond to client information (see element ), network platform information (element ), remote server information (element ), network protocol information (element ), and system information (element ). Within each of these functional areas, a similar field layout is preferably used. In preferred embodiments, three fields are used within each functional area The first field represents availability of information from the corresponding entity (e.g. availability of client information from one or more clients, in field ; availability of remote server information from one or more remote servers, in field ; etc.). The value of this field will be set in the user application's internal capabilities\/request vector in response to learning that the corresponding support is available. This availability field may be implemented as a binary value when only a yes\/no value is deemed necessary. The second field represents that the corresponding information is requested by the entity having this internal capabilities\/request vector (i.e. by the application, with reference to the processing in ), and may also be implemented as a binary value. For example, when field  is set to \u201c1\u201d, this indicates that the application wishes to receive information from the policy manager about the local system. The third field may be used to represent one or more options, and may be implemented as a bit string or as particular groups of bits. The fields in the internal capabilities vector are referred to hereinafter as the \u201cavailable\u201d, \u201crequested\u201d, and \u201coptions\u201d fields, respectively.","Use of these fields with reference to client support will now be described. During operation of Blocks  and , if the user application wishes to receive client input, then a bit in field  is set to \u201c1\u201d. In a subsequent transmission of the user application's internal capabilities vector to the local policy manager, the policy manager sets a bit in field  to a \u201c1\u201d to indicate that clients are able to send information on their conditions to this user application. (Therefore, field  should be initialized to false or \u201c0\u201d during operation of Block .) Various types of information can be conveyed through field , such as whether client congestion is currently present (or, alternatively, varying degrees of congestion); QoS requirements of this application's clients; device classes supported by this application's clients; etc. The type of information which is deemed useful in field  may vary from one implementation to another. An enterprise-wide scope for further defining this field may therefore be adopted. Or, for operation in a more wide-reaching environment, a particular interpretation may be prescribed.","The user application may also set values in options field , regarding information it wishes to query from the policy manager about the corresponding entity's support or current status (depending on the semantics of the particular values). For example, the application may set a bit defined as congestion yes\/no to \u201c1\u201d within field  to indicate that when the policy manager receives vector , its response should leave this bit set to \u201c1\u201d if clients are experiencing congestion (or perhaps congestion beyond some defined threshold), but that this bit should be set to \u201c0\u201d if the clients are not congested. Similarly, if one or more \u201ccongestion level\u201d bits are used to convey degrees of congestion, the application may set one (or more) of this bits to indicate that it wishes to query the policy manager about what the clients' current congestion level is. The policy manager may then set all the congestion level bits to \u201c0\u201d if congestion is not currently a problem, or may use other bit patterns to indicate differing levels of client congestion.","The fields within the network platform functional area  are preferably structured in an analogous way to those of the client functional area . That is, three fields are preferably used, where the first is an available field, the second is a requested field, and the third is an options field. (The other functional areas , ,  are also preferably structured in this same way.) The semantics of the first two fields ,  are preferably identical to those which have been described for fields  and . (The semantics of the first two fields in the other functional areas are also preferably identical to those which have been described.) Options field  may indicate various information which is pertinent to the network platform, including its current congestion, the type of network (such as LAN or WAN), and so forth.","Options field  in the remote server functional area  may indicate various information which is pertinent to the remote server, including its current congestion, any storage constraints, any processor constraints, etc. Options field  in the network protocol functional area  may indicate various information which is pertinent to the network protocol, including its current congestion, any system constraints, any buffers constraints, active connection limits, etc. Finally, options field  in the system functional area  may indicate various information which is pertinent to the system, including its current congestion, any system storage constraints, any processing constraints, etc.","Applications may use the options field within any of the vectors described herein to fine tune their reaction(s) to changing conditions. A bit mask or other suitable programming technique may be used for analyzing contents of the options field. Preferably, each functional area supports \u201ccongestion\u201d or \u201clevels of congestion\u201d in its options field, and when the bit(s) for congestion is\/are set to zero, this is an indication of no congestion.","Returning again to the discussion of , Block  checks to see if this application wishes to receive information from the network. If so, Block  preferably sets values ,  to indicate this request. (Alternatively, the logic in  may be modified to perform separate determinations as to (1) the network platform, e.g. switches and routers in the network, represented by functional area  of the internal capabilities vector ; and (2) the network protocol in the application server, represented by functional area .)","Next, Block  checks to see if this application wishes to receive information from the local server. If so, Block  sets value  to indicate this request. Finally, Block  checks to see if this application wishes to receive information from the remote server. If so, Block  sets value  to indicate this request. The user application's initialization of its internal capabilities vector is then complete (as indicated by Block ).","The policy manager and other components preferably use the same structure shown in  for their own internal capabilities vector, as stated earlier. If one or more functional areas are not pertinent for a particular component, the functional area may be omitted from the vector; or, the vectors may all be implement in a uniform manner. Furthermore, while a number of different capabilities are supported by the tests in  (and in ) and the corresponding vectors , a particular implementation may alternatively choose to support a subset of these capabilities. In that case, the vectors are modified accordingly.","The logic in  shows how the policy manager creates it own internal capabilities vector  as the policy manager initiates its activation (Block ) of the present invention. In preferred embodiments, this vector is created to reflect the settings as configured by the user, or as configured by intelligent middleware, specifying what this policy manager should be \u201cinterested\u201d in, as was discussed above. (The vectors created by other components according to  are also preferably based on user-configured settings or settings specified by intelligent middleware.) The policy manager's internal capabilities vector (and the internal capabilities vectors of the other components represented by ) is similar to that described for the user application, and preferably uses the same structure .","Creating the policy manager's version of the internal capabilities vector begins at Block , where a test is performed as to whether the policy manager can support receiving information from clients. This is represented in  as \u201cclient awareness capable?\u201d. If this test has a positive result, then Block  sets a value  in the policy manager's internal capabilities vector . Optionally, Block  may also set one or more values in field , as has been described with reference to Block  of .","Next, Block  checks to see if the policy manager can support receiving information from the network. If so, Block  preferably sets values ,  to indicate this information. (As was described with reference to Block  of , this logic may be modified to perform separate determinations as to the network platform, represented by area  of the internal capabilities vector , and as to the network protocol, represented by area .)","Block  then checks to see if the policy manager can support receiving information from the local server. If so, Block  sets value  to indicate this information. Finally, Block  checks to see the policy manager can support receiving information from the remote server. If so, Block  sets value  to indicate this request. The policy manager's initialization of its internal capabilities vector is then complete (as indicated by Block ).","The logic in  shows how the network protocol component (i.e. the protocol stack) of the local application server creates it own internal capabilities vector  as the network protocol component initiates its activation (Block ) of the present invention.","Creating the network protocol component's version of the internal capabilities vector begins at Block , where a test is performed as to whether the network protocol component can support receiving information from the network. If so, Block  preferably sets value  to indicate this information.","Block  then checks to see if the network protocol component can support receiving information from the remote server. If so, Block  sets value  to indicate this information. The network protocol component's initialization of its internal capabilities vector is then complete (as indicated by Block ).","Note that the logic in  does not test for as many types of support as were tested in  (for example, client awareness has been omitted). This is because such information is not deemed pertinent to network protocol. Similarly,  specify processing only for the components which are deemed pertinent for that particular case.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 9","b":["2100","900"]},"Creating the remote server's version of the internal capabilities vector begins at Block , where a test is performed as to whether the remote server can support receiving information from clients. If so, Block  preferably sets value  to indicate this information.","Block  then checks to see if the remote server can support receiving information from the network. If so, Block  sets value  to indicate this information. The remote server's initialization of its internal capabilities vector is then complete (as indicated by Block ).",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 10","b":["2100","1000"]},"Creating the network platform component's version of the internal capabilities vector begins at Block , where a test is performed as to whether the network platform component is intelligent protocol capable. If so, Block  preferably sets value  to indicate this information.","The logic in Blocks - performs checks regarding options which may be supported. Block  then checks to see if the network platform component has external network awareness capability. If so, Block  preferably sets a value in options field  to indicate this information. Next, Block  checks to see if the network platform component has internal awareness capability. (That is, the network platform component asks whether it can understand its own internals.) If so, Block  preferably sets a value in options field  to indicate this information. The network platform component's initialization of its internal capabilities vector is then complete (as indicated by Block ).","At this point, the components have each activated, and created internal vectors that represent their capabilities\/requests. The flowcharts in  illustrate logic that may be used in preferred embodiments to exchange information among components, thereby enabling the executing application to dynamically take an appropriate prioritization action.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 11"},"The policy manager initiates (Block ) the query process, as may be required, and then sends (Block ) the broadcast message to policy agents or feedback components (referred to hereinafter as \u201cremote policy agents\u201d residing in the remote servers and\/or network platform components. In preferred embodiments, this query message comprises a copy of the application server's internal capabilities vector, which was created according to the logic in .","The processing in Blocks - is performed in each of the receiving remote servers and network platforms. Upon receiving the query from the policy manager, a test is performed (Block ) to see if this remote component is capable of internal awareness. If this test has a negative result, this is typically an indication that the component does not understand the query, and therefore does not support the techniques of the present invention. Thus, in Block , a \u201cnot supported\u201d response is returned to the querying policy manager, and the processing for  in the remote component ends. Otherwise, when the test in Block  has a positive result, another test is made in Block  to see if this remote component currently supports the status reporting functions of the present invention. If so, then Block  sends a reply message indicating this remote component's support; otherwise, Block  sends a reply message indicating that, although the query message was understood, the support is not presently available or is not currently active. (This latter case may happen, for example, when the user has configured the remote component not to participate.) The reply messages sent from Blocks  and  are described in more detail below.","The policy agent receives each inbound response (Block ), and the process completes (Block ).","The reply message sent by each remote component at Block  or , as appropriate, is preferably structured as an \u201cexternal capabilities vector\u201d of the form illustrated by example in  (see element ). Use of this vector  enables communication among systems to determine cross-system capabilities. As can be seen by inspection, the primary difference between the external capabilities vector  and the internal capabilities vector  is the presence of the \u201csystem identifier\u201d functional area . This system identifier information is used by the receiving policy manager to create a list of systems comprising the intelligent network (i.e. those remote components which can respond to the policy manager's query messages). The remaining fields of the vector  may be structured in the same manner as in the internal capabilities vector ; alternatively, the external capabilities vector  can be re-structured such that only those fields that apply to a particular remote component are included. (That is, component-specific forms of the vector may be used, if desired.)","Optionally, an implementation of the present invention may include this vector  within an existing packet in order to avoid an additional network flow.","To create its outbound version of vector , a remote component fills in the received query vector such that the component's available functions and options are identified to the requester. In preferred embodiments, all applicable functions are indicated in the outbound vector, regardless of which \u201crequested\u201d fields were set by the policy manager in its query. The remote component also fills in fields , , , indicating its system type (e.g. whether it is a remote server or a network platform); its identifier type (e.g. whether the identifier in field  is a name, an address, or some other type of information); and its actual system identifier, respectively. (In alternative embodiments, the remote component may respond only to those fields for which the \u201crequired\u201d indicator is set.)",{"@attributes":{"id":"p-0097","num":"0096"},"figref":["FIGS. 12-15","FIG. 8"],"b":["1200","1205","1210","1215","1220"]},"When the middleware receives the network protocol component's response, it saves a copy of the vector from that response (Block ) and modifies that copy to indicate its own capabilities. That is, the vector received from the network protocol component will have values set in the network protocol component functional area . The middleware then sets values in functional area , using its own internal capabilities vector (see the discussion of ) as input. In this manner, the vector resulting from Block  shows what the policy manager can support for internal information.","Note that the processing in  shows a logical flow of what preferably occurs. If the middleware and application have access to the same storage, then the middleware may update that storage in place without passing a separate \u201ccopy\u201d to the application. Note also that an application may have many active connections at a point in time. Thus, it will look at all returned vectors to determine what was requested and what is actually available for that particular responding component.","Upon receiving the combined vector, the vector is saved (Block ), and processing then continues to Block , which indicates that an explicit request will be made for determining what services\/support are currently available.  shows this process in more detail.","At Block , the explicit services which are to be queried are selected. Blocks - show one example of how this selection can be made. (Alternatives include consulting a fixed list or perhaps a user-specified list.) Block  checks to see if client awareness is both requested and available, with reference to the vector received at Block . If so, Block  sets a client query indicator to indicate this request.","An \u201cexplicit service request\u201d vector is preferably built for this purpose during the processing of . (See element  in .) The explicit service request vector is used to request that notification of specific environmental changes are transmitted to the user application (or, as stated earlier, to the intelligent middleware acting on it's behalf). As in the case of the capabilities vectors , , multiple functions and options may be requested in the explicit service request vector . The primary difference between the capabilities vectors ,  and the explicit service request vector  is the replacement of the \u201cavailability\u201d field as the first field of each functional area with a \u201creturn code\u201d field, where the return codes are used to indicate whether the request was successful. (Note that this technique supports a \u201cpartial success\u201d approach, whereby selected return codes may be positive while others are negative. An implementation may choose to proceed when mixed return codes are present. Alternatively, an implementation may choose to proceed only when all return codes indicate success.) In addition to adding return codes, vector  uses a system identifier field  (which is preferably analogous to system identifier field ) and an application identifier field . This application identifier  is a unique identifier, and preferably comprises a type field  (indicating whether the identifier value in field  is a name, address, etc.) and a field  in which the actual identifier is present.","Referring again to , the processing of Block  preferably sets field  to indicate that another entity (in this case, the application server) is requesting this function.","Block  tests to see if network awareness is requested and available. If so, then Block  preferably sets fields  and . Next, Block  tests to see if local server awareness is requested and available. If so, then Block  preferably sets field . Finally, Block  tests to see if remote server awareness is requested and available. If so, then Block  preferably sets field .","At that point, the external request vector  is complete (Block ), and Block  tests to see if any services are currently available. For example, if the application wants to have client awareness, but the policy manager cannot provide that support, then that service is not currently available. Both the application and the policy manager must currently support a service for it to be considered \u201cavailable\u201d at Block . Thus, if the test in Block  has a negative result, then the process exits (Block ) because no information can be obtained. Otherwise, processing continues at Block  to perform the request for explicit services, as described in more detail in .",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIGS. 14 and 15","FIG. 13"],"b":["1400","1360","2300"]},"Note that the application knows before sending this request whether the requested functional support is available, because of the polling which has occurred according to previous exchanges of information.","When the policy manager receives this request, it, in turn, broadcasts a request for capabilities to all participating network platforms (Block ) and remote servers (Block ). The request is preferably created as copy of the vector  received from the application, into which a unique identifier for each request is preferably added. This identifier may be created in implementation-specific ways, but preferably comprises a unique name, network address, and random identifier, or any combination thereof. This identifier enables the policy manager to determine how to correlate responses. The set of target destinations used in Blocks  and  may be determined statically or dynamically, in the same manner previously described with reference to Block  of .","The processing which occurs in the remote network platforms and remote servers will be described below with reference to .","Continuing with the discussion of , in Block , the policy manager requests capabilities information from the local network protocol component. Upon receiving that request, the network protocol component returns a copy of the vector (Block ), in which it confirms the requested capabilities. (That is, for each request in field  and  of the vector it receives, the network protocol component leaves the settings if it can provide that support, but turns off the settings for those which it cannot support.)","Note that it may happen in some cases that the network protocol component is unable to respond successfully to the policy manager's request. (For example, the network protocol component might be already at capacity for the number of application instances it can support.) Thus, the return code support defined for vector  (see field ) is used to indicate whether the response has been completed or not.","When the policy manager receives the response from the network protocol component, it passes that information (Block ) back to the application. (Preferably, some amount of time passes before the policy manager returns this response to the application, so that the remote component has time to reply.) The application then preferably saves this information (Block ), after which the processing of  exits (Block ).","It should be noted that while discussions herein are in terms of complete vectors being transmitted among components, in alternative embodiments only the component-specific parts of the vectors might be used.",{"@attributes":{"id":"p-0114","num":"0113"},"figref":["FIG. 15","FIG. 14","FIG. 11"],"b":["1405","1410","1500","1505","2320"]},"Upon receiving the policy manager's request, a policy agent of the remote component checks (Block ) to see if this request can be satisfied. If not, then in Block , a response message indicating that the request cannot be honored is returned. Otherwise, Block  sends a successful response in which a reply vector indicates the remote component's support of the requested functions. It may happen that a request can be partially fulfilled, or it may be possible to completely fulfill all the requested functions. Therefore, the return code fields ,  are preferably set, along with the options fields , , to indicate the particular remote component's current support capabilities. The remote policy agent also preferably adds the requesting application's identifying information, along with the functions it has requested, to a local storage structure of some form. This stored information will be used by the remote policy agent to determine who has \u201cregistered\u201d to receive notifications of this component's environmental changes.","Referring now to , logic is shown which may be used to implement processing of an inbound connection request from a client. At Block , the client initiates this request, and upon receiving that request at a remote server or network platform, Block  checks to see if this client is capable of sending intelligent environmental awareness information for purposes of the present invention. If not, then optionally an applet may be sent to the client (Block ) to enable it to provide such support. In that case, the client preferably installs the applet (Block ), as processing proceeds.","In Block , the remote server or network platform forwards the client's connection request to the network protocol component executing in the application server of interest (that is, the application server on which the application whose behavior may be dynamically modified is executing). Block  indicates that the network protocol component forwards the connection request to the executing user application.","In Block , the remote server or network platform preferably sends a notification to the policy manager in the application server of interest, informing it of this newly-active client. The notification is received by the network protocol component of the application server of interest, which forwards it (Block ) to its local policy manager. Upon receiving the forwarded notification, the policy manager logs information that there is a new client (Block ), and passes the notification on to the executing application.","In Block , the executing application receives the client's connection request, as well as the notification from the local policy manager, and processes the connection request in synchronization with the policy manager, as shown in more detail in .",{"@attributes":{"id":"p-0120","num":"0119"},"figref":"FIG. 17","b":["1700","1705","1710","1715","1720","1725"]},"The user application determines whether to accept this connection request (Block ). If the answer is to not accept the request, then Block  informs the local network protocol component to reject the request, and processing then completes (Block ). Otherwise, when the connection is being accepted, Block  informs the local network protocol component to accept the request, and processing then completes (Block ).",{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 18","b":"1800"},"If the application decides to accept the client's connection request, then at Block , the local network protocol component completes the connection setup processing, and passes a connection accepted response message to the remote server or remote network platform. That component, in turn, receives the response and completes the connection, and the remote policy agent preferably notifies the client application of the completion (Block ). The client then continues its processing of some type of application-specific operation or transaction (Block ).","On the other hand, if the application decides (in Block ) to reject the client's connection request, then at Block , the local network protocol component drops the connection and passes a connection rejected response message to the remote server or remote network platform. That component, in turn, receives the response and also drops the connection locally, and the remote policy agent preferably notifies the client application of the rejection (Block ). The client then restarts or aborts its processing of the operation or transaction (Block ).","The user application may also notify the local policy manager (in Block ) of the connection's status. Upon receiving this notification, the policy manager logs the notification (Block ) and returns a response to the application indicating that the information has been logged.",{"@attributes":{"id":"p-0126","num":"0125"},"figref":["FIGS. 19 and 20","FIG. 19","FIG. 20"]},"Block  of  indicates that the user application may \u201csleep\u201d while awaiting a notification of an internal change. This is for purposes of illustrating that the change notification process may be invoked periodically, upon occurrence of some trigger, and is not meant to imply that the application halts if no notifications are received. Upon receiving a notification, Block  checks to see if the notification pertains to a valid connection. If not, then no further processing is done, as shown by transferring control to Block  where the application again returns to sleep (i.e. its change-notification processing suspends to await the next incoming notification).","If this notification is for a valid connection, then Block  checks to see if this is a notification of a network-related change. If so, then Block  preferably evaluates network-specific logic to determine whether, and in what way, the network traffic should be adjusted. As has been described earlier, examples of such adjustments include creating less data to be transmitted, requesting less data input, and\/or dropping connections. Or, if the notification indicates a positive change, such as when network congestion is decreasing, then the application may choose to increase its data traffic.","Block  checks to see if the change notification indicates a system-related change. (Note that a single notification message may indicate both network-related and system-related changes, including more than one type of each.) If so, then Block  preferably evaluates system-specific logic to determine whether, and in what way, usage of system resources should be adjusted. As has been described earlier, examples of such adjustments include changing how threads are assigned, how storage is allocated, and so forth. The size of data objects being created by the application may also be altered. For example, the application may reduce the size of the data objects if a client has constraints that prevent it from supporting the current content level, or may increase the data object size when such constraints are lessened.","Following operation of Blocks  and , the user application's change-notification processing suspends to await the next incoming notification (Block ).","A change notification may also be received by the local policy manager. Processing to handle this situation is provided in Blocks -. As with the user application, the policy manager's change-notification processing may be considered as sleeping until it receives a notification (Block ). Such changes may be sent by one or more components of the local system, including the local network protocol component (Block ) and the local system (Block ). Upon detecting a network-related change or system-related change, respectively, Blocks  and  send a notification to the policy manager.","Upon receiving the change notification at the policy manager, Block  verifies that this is actually a change notification. If it is not, then control transfers to Block , where the policy manager's change-notification processing suspends to await the next incoming notification. If this is a change notification, as determined in Block , then Block  checks to see if the user application should be notified. If so, then a notification is sent, as shown by arrow .","As was discussed earlier, a number of implementation-specific factors may be used in making a determination as to whether an executing application should be notified of any particular conditions that arise, and these factors are taken into consideration during the processing at Block .","In preferred embodiments, the mechanism used to notify the application and\/or policy manager of an environmental change in  is by sending an \u201cenvironmental change notification\u201d vector. See vector  in  for an example of the structure and content that may be used. This vector may be used to send a notification of changes in the internal environment (i.e. a change affecting a component of the local system), corresponding to the processing in , or of changes in the external environment (such as changes in a remote server, network platform, etc.), corresponding to the processing in . Both uses will be described together, for purposes of conciseness.","Each environmental change notification vector identifies the notification source, preferably by transmitting its system identifying information in field . The current congestion level at the source may also be provided (see element ). Implementation-specific semantics may be attributed to this field. For example, an absence of congestion level information may be taken as an indication of severe congestion. Additional information about a congestion condition (or other type of condition, alternatively) may be indicated through use of options codes . As one example of how this additional information may be used, settings may be defined that allow specification the cause(s) or likely cause(s) of the current environmental change.","The notification vector may also include function-specific codes when appropriate. For example, a network platform might provide a code indicating that a high-speed connection has been lost, thus necessitating the use of lower-speed lines. Field  may be used to provide information about one or more current conditions, whereby an option code may be specified for each condition (preferably in a separate instance of field , which may occur multiple times within an environmental change notification vector ). Note that a compound congestion condition or other type of compound condition may be indicated by providing more than one option code.","Preferably, when a system or network component determines that a change has occurred, where this change is of the type to be reported according to the present invention, that component notifies its local policy agent\/manager. This notification may be communicated within the internal system using a notification vector , or using other analogous means (such as by setting values in shared storage, where other components are adapted to searching this storage for notifications). The policy agent then searches its local list to determine which systems (and their associated applications) are capable of processing these environmental notifications (and which have preferably registered with the local system according to the logic in ). For each system found, the policy agent constructs a notification vector , and the vector is sent to the policy manager resident on that application server. The application identifier of each application within that server which is registered as being interested in the notification is also preferably included in the transmitted vector. See field , which may be repeated in a particular instance of vector . The vector processing may proceed as in , for those cases where the notification is sent internally, or as in , when vectors are sent externally. (Note that more than one application within a particular target system may be notified in response to a single vector, when both are co-resident on a single application server.)","After a policy manager receives an environmental change notification (whether as a notification vector  or as some other type of internally-communicated notification, as discussed above), it preferably logs that information within a local data structure of some type before forwarding a corresponding environmental change notification vector on to all the applications (including one or more the local applications as well as remote applications) that requested such information.","The logic in  may be used to support external change notifications (that is, notifications which are generated in components that are external to the server that receives such notifications, and in which a determination is made as to whether an executing application should modify its behavior). For example, external notifications may be generated by clients, network platforms, and\/or remote servers.","This processing begins at Block , where the user application receives an externally-generated change notification and therefore interrupts a suspended change-notification processor (similar to Block  of ). Block  checks to see if this notification pertains to a valid connection, and if not, the change-notification processing operation preferably returns to a suspended state (Block ).","When the notification is for a valid connection, Block  checks to see if this notification contains client information. (Preferably, this is determined by consulting the system type field .) If so, then Block  determines whether, and in what manner, traffic being sent to that client should be adjusted.","Block  checks to see if the notification contains network platform information. If this test has a positive result, then Block  determines whether, and in what manner, the network traffic should be adjusted. (Note that a single received vector contains information from a single system type when using the vector format  shown in . However, in alternative embodiments, a vector format may be used which may gather information from multiple sources, in which case more than one of the tests , ,  may have a positive result.)","Block  checks to see if the notification contains information from a remote server. If so, then Block  determines whether, and in what manner, adjustments pertaining to the remote server should be made.","Following each type of adjustment, the user application's change-notification processing suspends to await the next incoming notification (Block ).","An externally-generated change notification may also be received by the local policy manager. Processing to handle this situation is provided in Blocks -. As with the user application, the policy manager's change-notification processing may be considered as sleeping until it receives a notification (Block ). Such changes may be sent by one or more types of external components, including clients (Block ), network platforms (Block ), and remote servers (Block ). Upon detecting a client-related, network platform-related, or remote system-related change, respectively, Blocks , , and  send a notification that is received by the policy manager of the system depicted in .","Upon receiving the change notification at the policy manager, Block  verifies that this is actually a change notification. If it is not, then control transfers to Block , where the policy manager's change-notification processing suspends to await the next incoming notification. If this is a change notification, as determined in Block , then Block  checks to see if the user application should be notified. If so, then a notification is sent, as shown by arrow . A number of implementation-specific factors may be used in making the determination in Block .","An example scenario illustrating use of the present invention will now be provided with reference to the diagram in . The environment in this example is a relative simply network  where remote wireless stations (denoted as \u201cWS\u201d ,  in the figure) are connected to a server farm or cluster  first through a LAN  and then by a WAN . In this example, suppose that one of the wireless workstations  is either moving away from the transmitter it is using or is undergoing battery drain. Therefore, it is losing its capability to receive information from the server cluster and\/or its ability to process the information it has already received.","A monitoring component  (shown as \u201cQoSWM\u201d in the figure, for \u201cQoS Wireless Monitor\u201d) in the workstation  detects the loss of capability, using techniques which do not form part of the present invention. However, this monitoring component is adapted for sending notifications of the type disclosed herein. Therefore, the monitoring component notifies a policy agent  of the changed environmental conditions of workstation . This policy agent, in the example, resides in the wireless application gateway (\u201cWAG\u201d)  of a remote server  (\u201cES\u201d in the figure). (In the example, the remote server  is an IBM WebSphere\u00ae Edge Server. \u201cWebSphere\u201d is a registered trademark of IBM.) The monitoring component  might alternatively be located in the WAG .","Upon receiving the environmental change notification (which is preferably an environmental change notification vector ), the policy agent  notifies the policy agents\/managers  which are resident on the server instances in the server cluster . (Note that policy agents and managers preferably keep track of all remote agents\/managers, so they know where the notifications should be sent, as has been described.) Upon receiving the notification, the policy agents\/managers in the server instances determine whether to forward this information on to a locally-executing application, using decision-making criteria of some form. An application may then decide to close the connection to workstation , or to send less data to the workstation, etc. (It may be possible for the workstation client to continue operating under the changed relationship with the server application. This might, for example, allow the user to request a graceful close of the client application before all battery power is lost.)","As has been demonstrated, the present invention provides advantageous techniques for improving traffic management, wherein an executing application responds to current environmental conditions to alter the traffic it generates. By reducing the amount of traffic sent to a system and\/or network, it becomes possible to provide an overall solution to traffic management, thereby ensuring that user QoS expectations can be met. The disclosed techniques may be adapted to conveying many different types of changing conditions. The protocol disclosed for exchanging information among components may be used for internal communications within a particular system and\/or for external communications among different components of the network. The vectors which have been described provide a flexible, extensible means for communicating information internally as well as externally.","As will be appreciated by one of skill in the art, embodiments of the present invention may be provided as methods, systems, and\/or computer program products. Accordingly, the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment, or an embodiment combining software and hardware aspects. Furthermore, the present invention may take the form of a computer program product which is embodied on one or more computer-usable storage media (including, but not limited to, disk storage, CD-ROM, optical storage, and so forth) having computer-usable program code embodied therein.","The present invention has been described with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems), and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, embedded processor or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer-readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable memory produce an article of manufacture including instruction means which implement the function specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions specified in the flowchart and\/or block diagram block or blocks.","While preferred embodiments of the present invention have been described, additional variations and modifications in those embodiments may occur to those skilled in the art once they learn of the basic inventive concepts. Therefore, it is intended that the appended claims shall be construed to include the described preferred embodiments and all such variations and modifications as fall within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIGS. 6-20"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIGS. 21-24"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 25"}]},"DETDESC":[{},{}]}
