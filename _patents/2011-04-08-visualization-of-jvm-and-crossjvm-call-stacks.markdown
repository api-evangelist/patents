---
title: Visualization of JVM and cross-JVM call stacks
abstract: A method for diagnosing problems in a computer system by visualizing flows through applications and other subsystems in a directed graph on a user interface. The user interface represents multiple instances of each application or other subsystem by a respective node, and edges indicate which nodes depend on one another. Aggregate metrics which are based on the multiple instances, and associated alerts, can be provided for the nodes and edges. An aging process can indicate which nodes have not been recently invoked. The user interface can also indicate which nodes and edges are associated with a given business transaction. In a summary view, a node hides the identity of invoked components such as servlets of the application, while in a detailed view these details are provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782614&OS=08782614&RS=08782614
owner: CA, Inc.
number: 08782614
owner_city: Islandia
owner_country: US
publication_date: 20110408
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention is directed to technology for performance monitoring software in a computing environment.","2. Description of the Related Art","The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e-commerce, education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives, and devote considerable resources to ensuring that they perform as expected. To this end, various application management techniques have been developed.","One approach involves monitoring the infrastructure of the application by collecting application runtime data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example, using instrumentation of the software, a thread or process can be traced to identify each component that is invoked, as well as to obtain runtime data such as the execution time of each component. Tracing refers to obtaining a detailed record, or trace, of the steps a computer program executes. One type of trace is a stack trace. Traces can be used as an aid in debugging.","However, diagnosis of problems continues to be difficult and time-consuming. For example, when a transaction or application is failing, the provider wants to know what exactly is going wrong, and why. Improved diagnostic techniques are needed.","The present invention provides a method for diagnosing performance problems in a computer system by visualizing flows through applications or other subsystems of a computing system.","In one embodiment, tangible, non-transitory computer readable storage having computer readable software embodied thereon is provided for programming at least one processor to perform a method for visualizing flows through at least a first application. The method performed comprises accessing a data store to access data regarding the first application, where the data is obtained from an agent associated with the first application using instrumentation which is installed in the first application, and the data represents multiple instances of the first application. The method performed further includes displaying a dependency graph on a user interface. The dependency graph graphically depicts: (a) a first node which represents the multiple instances of the first application, (b) a second node which represents one subsystem on which the first application depends, and (c) at least one edge which represents a dependency of the first application on the one subsystem.","In another embodiment, tangible, non-transitory computer readable storage having computer readable software embodied thereon is provided for programming at least one processor to perform a method for visualizing flows through respective applications. The method performed includes accessing a data store to access data which is obtained from respective agents associated with the respective applications, where the respective agents provide the data using instrumentation which is installed in the respective applications, and the data represents multiple instances of each of the respective applications. The method performed further includes displaying a dependency graph on a user interface. The dependency graph graphically depicts: (a) a first node which represents multiple instances of one of the respective applications, (b) a second node which represents multiple instances of another of the respective applications, and (c) at least one edge which represents a dependency of the one of the respective applications on the other of the respective applications.","In another embodiment, tangible, non-transitory computer readable storage having computer readable software embodied thereon is provided for programming at least one processor to perform a method for visualizing flows through respective applications. The method performed includes accessing a data store to access data which is obtained from respective agents associated with the respective applications, where the respective agents provide the data using instrumentation which is installed in the respective applications, and the data represents multiple instances of each of the respective applications. The method performed further includes displaying a dependency graph on a user interface. The dependency graph graphically depicts: (a) a first identifier which represents a first business transaction in which the first application is invoked, (b) a node which represents the multiple instances of the first application, (c) a node which represents one subsystem on which the first application depends, in connection with the first business transaction, and (d) at least one edge which represents a dependency of the first application on the one subsystem, in connection with the first business transaction.","Corresponding methods, systems and computer- or processor-readable storage devices which include a storage media encoded with instructions which, when executed, perform the methods provided herein, may be provided.","The present invention provides a method for diagnosing problems in a computer system by visualizing flows through applications or other subsystems of the computer system.","A tool is provided for monitoring application performance by collecting metrics for applications with the help of respective agents for the applications. The metric data which is collected provides an agent-centric view of all the applications (including multiple instances of the same application) that are being monitored. Further, the tool makes it easier for the business user to interact in business-centric terms by providing a graphical dependency graph, or application graph, which shows the dependency relationship between an application or business process and its logical infrastructure components.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1","b":["100","106","110","114","106","110","114","120","120","106","110","114","104"]},"For example, a corporation running an enterprise application such as a web-based e-commerce application may employ a number of application servers at one location for load balancing. Requests from users, such as from an example web browser  of a user, are received via a network cloud  such as the Internet, and can be routed to any of the computing devices ,  and . The web browser  typically accesses the network cloud  via an Internet Service Provider, not shown. Agent software running on the computing devices ,  and , denoted by Agent A (), Agent A () and Agent A (), respectively, gather information from an application, middleware or other software, running on the respective computing devices ,  and , in one possible approach. Such information may be obtained using instrumentation, one example of which is byte code instrumentation. However, the gathered data may be obtained in other ways as well. The agents essentially live in the computing device being monitored and provide a data acquisition point. The agents organize and optimize the data communicated to the manager . In one implementation, an instance of an Application A executes at the computing device  and an instance of an Application B executes at the computing device .","The manager  can be provided on a separate computing device such as a workstation which communicates with a user interface , such as a monitor, to display information based on data received from the agents. The manager can also access a database  to store the data received from the agents. In the example provided, the computing devices can communicate with the manager  without accessing the network cloud . For example, the communication may occur via a local area network. In other designs, the manager  can receive data from the agents of a number of computing devices via the network cloud . For instance, some large organizations employ a central network operations center where one or more managers obtain data from a number of distributed agents at different geographic locations. To illustrate, a web-based e-commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders, from servers that process payments, from servers at warehouses for tracking inventory and conveying orders, and so forth. The manager  and user interface display  might be provided at a corporate headquarters location. Other applications which are not necessarily web-based or involve retail or other sales, similarly employ agents and managers for managing their systems. For example, a bank may use an application for processing checks and credit accounts. Moreover, in addition to the multi-computing device arrangements mentioned, a single computing device can be monitored as well with one or more agents.","Various approaches are known for instrumenting software to monitor its execution. For example, as mentioned at the outset, tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Patent Application Publication No. 2004\/0078691, titled \u201cTransaction Tracer,\u201d published Apr. 22, 2004, incorporated herein by reference. In one approach discussed therein, object code or bytecode of an application to be monitored is instrumented, e.g., modified, with probes. The probes measure specific pieces of information about the application without changing the application's business or other logic. Once the probes have been installed in the bytecode of an application, it is referred to as a managed application. The agent software receives information from the probes and may communicate the information to another process, such as at the manager , or process the information locally, such as to determine whether the information indicates an abnormal condition. The agent thus collects and summarizes information received from the probes. The probes collect information as defined by a directives file. For example, the information from the probes may indicate start and stop times of a transaction or other execution flow, or of individual components within a transaction\/execution flow. This information can be compared to pre-established criteria to determine if it within bounds. If the information is not within bounds, the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents ,  and  are typically aware of the software executing on the local computing device ,  and , respectively, with which they are associated.","The probes can report a standard set of metrics which include: CORBA method timers, Remote Method Invocation (RMI) method timers, Thread counters, Network bandwidth, JDBC update and query timers, Servlet timers, Java Server Pages (JSP) timers, System logs, File system input and output bandwidth meters, Available and used memory and EJB (Enterprise JavaBean) timers. A metric is a measurement of a specific application activity.","An agent reports information about transactions, which identifies resources which are accessed by an application. In one approach, when reporting about transactions, the word Called designates a resource. This resource is a resource (or a sub-resource) of a parent component, which is a consumer. For example, assume that Servlet A is the first component invoked in a transaction. Under the consumer Servlet A (see below), there may be a sub-resource Called EJB. Consumers and resources can be reported by the agent in a tree-like manner. Data for a transaction can also be stored according to the tree. For example, if a Servlet (e.g. Servlet A) is a consumer of a network socket (e.g. Socket C) and is also a consumer of an EJB (e.g. EJB B), which in turn is a consumer of a JDBC (e.g. JDBC D), the tree might look something like the following:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Servlet A"]},{"entry":[{},"\u2003\u2003Data for Servlet A"]},{"entry":[{},"\u2003\u2003\u2003\u2003Called EJB B"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Data for EJB B"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Called JDBC D"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Data for JDBC D"]},{"entry":[{},"\u2003\u2003\u2003\u2003Called Socket C"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Data for Socket C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, the above tree is stored by the Agent in a stack, called the Blame Stack. When transactions are started, they are pushed onto the stack. When transactions are completed, they are popped off the stack. In one embodiment, each transaction on the stack has the following information stored: type of transaction, a name used by the system for that transaction, a hash map or dictionary of parameters, a timestamp for when the transaction was pushed onto the stack, and sub-elements. Sub-elements are Blame Stack entries for other components (e.g. methods, process, procedure, function, thread, set of instructions, etc.) that are started from within the transaction of interest. Using the tree as an example above, the Blame Stack entry for Servlet A would have two sub-elements. The first sub-element would be an entry for EJB B and the second sub-element would be an entry for Socket Space C. Even though a sub-element is part of an entry for a particular transaction, the sub-element will also have its own Blame Stack entry. As the tree above notes, EJB B is a sub-element of Servlet A and also has its own entry. The top (or initial) entry (e.g., Servlet A) for a transaction, is called the root component. Each of the entries on the stack is an object.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 2A","b":["130","132"]},{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameters","Appears in","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UserID","Servlet, JSP","The UserID of the end-user invoking"]},{"entry":[{},{},"the http servlet request."]},{"entry":["URL","Servlet, JSP","The URL passed through to the"]},{"entry":[{},{},"servlet or JSP, not including the"]},{"entry":[{},{},"Query String."]},{"entry":["URL Query","Servlet, JSP","The portion of the URL that specifies"]},{"entry":[{},{},"query parameters in the http request"]},{"entry":[{},{},"(text that follows the \u2018?\u2019 delimiter)."]},{"entry":["Dynamic","Dynamic JDBC","The dynamic SQL statement, either"]},{"entry":["SQL","Statements","in a generalized form or with all"]},{"entry":[{},{},"the specific parameters from the"]},{"entry":[{},{},"current invocation."]},{"entry":["Method","Blamed Method","The name of the traced method. If the"]},{"entry":[{},"timers (everything","traced method directly calls another"]},{"entry":[{},"but Servlets,","method within the same component,"]},{"entry":[{},"JSP's and","only the \u201coutermost\u201d first"]},{"entry":[{},"JDBC Statements)","encountered method is captured."]},{"entry":["Callable","Callable JDBC","The callable SQL statement, either"]},{"entry":["SQL","statements","in a generalized form or with all"]},{"entry":[{},{},"the specific parameters from the"]},{"entry":[{},{},"current invocation."]},{"entry":["Prepared","Prepared JDBC","The prepared SQL statement, either"]},{"entry":["SQL","statements","in a generalized form or with all"]},{"entry":[{},{},"the specific parameters from the"]},{"entry":[{},{},"current invocation."]},{"entry":["Object","All non-static","toString( ) of the this object of the"]},{"entry":[{},"methods","traced component, truncated to some"]},{"entry":[{},{},"upper limit of characters."]},{"entry":["Class Name","All","Fully qualified name of the class of"]},{"entry":[{},{},"the traced component."]},{"entry":["Param_n","All objects with","toString( ) of the nth parameter"]},{"entry":[{},"WithParams","passed to the traced method of"]},{"entry":[{},"custom tracers","the component."]},{"entry":["Primary Key","Entity Beans","toString( ) of the entity bean's"]},{"entry":[{},{},"property key, truncated to some upper"]},{"entry":[{},{},"limit of characters."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Parameters can include query, cookie, post, URL and session type name\/value pairs.","In step , the system acquires a timestamp indicating the current time. In step , a stack entry is created. In step , the stack entry is pushed onto the Blame Stack. In one embodiment, the timestamp is added as part of step . The process is performed when a transaction is started. A similar process is performed when a sub-component of the transaction starts (e.g., EJB B is a sub-component of Servlet A\u2014see tree described above).",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 2B","FIG. 1"],"b":["140","142","144","146","142","148","148","146","150","150","152","154","120"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 2B"},"Note, in one embodiment, if the transaction tracer is off, the system will still use the Blame Stack; however, parameters will not be stored and no component data will be created. In some embodiments, the system defaults to starting with the tracing technology off. The tracing only starts after a user requests it, as described above.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 3","FIG. 1","FIG. 1"],"b":["300","300","310","320","330","340","310","350","310","330","350","350"]},"The database  may be included in the storage device  when the storage device  is part of a computing device  such as an application server, manager and\/or user interfaces. The storage device  can represent one or more storage devices which store data received from one or more agents, and which can be accessed to obtain data to provide a user interface as described herein. The storage device  can represent a data store.","Further, the functionality described herein may be implemented using hardware, software or a combination of both hardware and software. For software, one or more non-transitory, tangible processor readable storage devices having processor readable code embodied thereon for programming one or more processors may be used. The non-transitory, tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media, removable and non-removable media. For example, non-transitory, tangible computer readable media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Examples of non-transitory, tangible computer readable media include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer. In alternative embodiments, some or all of the software can be replaced by dedicated hardware including custom integrated circuits, gate arrays, FPGAs, PLDs, and special purpose processors. In one embodiment, software (stored on a storage device) implementing one or more embodiments is used to program one or more processors. The one or more processors can be in communication with one or more tangible computer readable media\/storage devices, peripherals and\/or communication interfaces.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 4A","FIG. 1","FIG. 4E"],"b":["106","1","1","1"]},"In the transaction trace, the horizontal direction represents time, while the vertical direction indicates call stack depth or position. A transaction trace, also referred to as a call stack, identifies instrumented components which have been called or invoked during the execution of one or more programs, processes or threads. Trace data of instrumented components can be used along with dependency data to understand and debug an application. In particular, a separate transaction trace can be provided for each agent, such that different threads are separated out into different transaction traces.","In a graphical representation which can be provided on a user interface display and\/or stored in a data store, an external vertex  is the first or root component of the transaction trace. A Servlet A , a Plain Old JAVA\u2122 Object (POJO) A , a Java Database Connectivity (JDBC) driver call  and a socket call  are at successively lower layers of the transaction trace. A POJO is a JAVA object which is not a special object such as an Enterprise JavaBean (EJB). The external vertex  can be any component that calls Servlet A in Application A from outside Application A.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 4B","FIG. 1"],"b":["106","370","360","2","372","374","376","370","2"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 4C","FIG. 1"],"b":["110","380","360","370","1","382","384","386","380","1"]},"The transaction traces of  provide a basis for the discussion of .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 4D","FIGS. 4A-4C"],"b":["106","110","400","1","402","2","404","1","406","408","110","420","1","412","414"]},"A dependency graph can be provided based on this example (See ). A dependency graph displays a dependency relationship (map) between various software components of an application or business transactions as a directed graph (digraph). The software components can be Servlets, EJBs, Databases, message queues (MQs) and so forth.","Specifically, a graph G=(V, E) includes a set V of vertices (also called nodes), and a set E of edges. Each edge represents an ordered pair of vertices. The edges in a directed graph are ordered pairs, i.e., the two vertices the edge connects are ordered. A directed graph edge can be drawn as an arrow pointing from one vertex (source) to another (target). Thus, the head of the arrow is at the target vertex and the tail of the arrow is at the source vertex. Further, a simple path from v1 to vk is a sequence of vertices v1, v2 . . . vk that are connected by edges (v1, v2), (v2, v3) . . . (vk\u22121, vk). If an application is represented by a directed graph, then a business transaction can be considered as a simple path through that graph. A subgraph S of a graph G is a graph whose vertices and edges are a subsets of vertices and edges of graph G. A subgraph S is called edge induced subgraph of G, if it consists of a subset of edges of graph G. A business service can be considered as an edge-induced subgraph of that graph. The logical view of the dependency graph is the union of all physical dependencies between various components across agents. Potentially, an application dependency graph may depict multiple business transactions.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 4E","FIGS. 4A-4C"],"b":["1","402","1","406","401","2","404","403","104","1","412","1","431","1","1","1","2","2","1","2","1","1","1"]},"Generally, the agent can track components of every transaction passing through an application\/web server. The software components (such as class-method pairs) involved in a transaction are pushed inside a call stack in the order in which they are invoked. A component is popped out of the call stack when a control flow returns to it. However, a transaction call stack includes a number of components which may or may not be of interest to a user. To prevent unnecessarily complex dependency graphs, the agent may only collect dependencies between nodes of interest. A component which is the first interesting element in the call stack or a component that makes a call outside its own JVM (Java Virtual Machine) call can be considered for the dependency graph.","The first component pushed in the call stack may not always be an interesting component. The first interesting component in the call stack is marked as a frontend. A call outside the JVM typically involves a socket. A socket appearing as the last component in a transaction may not always be interesting to the user. We can provide a mechanism for marking any component before the socket call as a component of interest. The interesting component which is before the socket call, closest to the socket call, is marked as a backend. We can provide a few predefined interesting component types, e.g., Servlet, EJB, JDBC\/database and so forth in a baseline configuration. A user can extend the interesting types by a tracer extension capability.","Further, in the dependency graph, an edge consists of source and target vertices, and the starting edge is between an external vertex and the front end component. The starting vertex is usually represented either by a cloud or an external component.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 4F","FIG. 4A"],"b":["1","1","405","1","402","1","406","1","408","408","410"]},"The call stack for BTA  includes a Servlet A stack element , a POJO A stack element , a JDBC driver stack element  and a Socket stack element . Based on these stack elements, edges between the elements can be defined for use in creating the dependency graph. These include an edge  which indicates that Servlet A depends on POJO A, an edge  which indicates that POJO A depends on the JDBC driver, and an edge  which indicates that JDBC driver depends on a socket call.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIGS. 4G and 4H","FIG. 4F","FIG. 4G","FIG. 4H"],"b":["1","472","1","1","473","1","470","1406","410"]},{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 4I","FIGS. 4B and 4C"],"b":["2","440","2","402","442","2","1","412","444","490","2","452","2","450","448","446","481","2","480"]},"For BTB, the external vertex  can represent the incoming call from Application A. This invokes Servlet B , which in turn calls a JDBC driver . The JDBC driver  makes a call to Database Y via socket . The call stack for BTB  includes a Servlet B stack element , a JDBC driver stack element  and a Socket stack element . Based on these stack elements, edges between the elements can be defined for use in creating the dependency graph. These include an edge  which indicates that Servlet B depends on a JDBC driver, and an edge  which indicates that the JDBC driver depends on a socket call. Note that the database call from Servlet B to Database Y is not only part of a single JVM Business Transaction BTB but also part of the cross-JVM Business Transaction BTA. Thus, a given component\/subsystem can be part of one or more Business Transactions.","In one example, the edges to the Sockets in both the Business Transactions BTA and BTB are not considered important due to the appearances of backend markers before the Sockets. In this case, edges  and  can be pruned, leaving the edges  and .",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIGS. 4J and 4K","FIG. 4I","FIG. 4J"],"b":["444","464","460","442"]},{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 5A","FIGS. 4H and 4K"],"b":["1","2","1","2","1","1","402","2","404","502"]},"The detailed dependency graph view of an application shows all its relationships\/edges with all the called backends, including any cross-JVM relationship with other applications, such as depicted by the Application B node . The edges are also shown, including an edge  between Servlet A  and Database X , and edge  between Servlet A  and Web Service Client , and an edge  between Web Service Client  and Application B . The vertices for Servlet B and Database Y and the edges between Servlet B and Database Y are not shown as a default, in one option, since the focus is on Application A. Optionally, these items can be shown based on a user command, for instance, as depicted in . A common generalized external vertex  is depicted for Application A and Application B, showing an edge  to Servlet A, an edge  to Servlet A  and an edge  to Application B .",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 5B","FIGS. 4H and 4K"],"b":["412","431","1","526","1","412","431","1","1","504"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 6A","FIGS. 4H and 4K"],"b":["600","602","1","1","601","604","601","606"]},"A Business Service can include multiple Business Transactions interacting with each other to accomplish a common shared goal such as to execute a stock trade for a stock trading web site, buy a book for a book-selling web site, or enroll in benefits for a company's benefits program. In our example, BTA and BTA are Business Transactions which are part of the same Business Service (Business Service ). The summary of a Business Service can be defined by a dependency graph which provides a union of all vertices and edges included in BTA and BTA. Moreover, additional placeholder nodes  and  can be provided to represent BTA and BT, respectively. In this view, no special highlighting is provided for the edges and nodes.","The dependency graph can be geared towards first and second level triagers, whose roles include monitoring applications\/transactions and notifying appropriate business and IT owners if any problems are encountered by a particular application\/transaction. For these purposes, it can be sufficient to identify an application without specifying a component of the application. Since the detailed view of an application may become complicated with the increase in the number of applications and interesting software components, the summary dependency graph view of an application is helpful because it reduces the complexity by hiding lower level details from the user.","In the summary view, all the front end components of an application are hidden in the application node. The edges coming out from an application to its back end components are depicted, in addition to cross-JVM edges. Further, the application nodes can be decorated with application metrics, while the edges (e.g., between applications and their backends, and between applications and cross-JVM applications) can be decorated with backend relational metrics. The edges between an application node and certain backend types (e.g., Web Service and EJB back ends) can be grouped together to reduce the complexity of the summary dependency graph view. Users are allowed to create alerts on these nodes and edges to monitor the health of an application and its relationship with its back ends. An alert icon for a vertex or an edge shows up if an alert is set on their performance metric. The alert icon is an indicator of an application's performance and helps the user monitor and diagnose the health of an application and its back ends. In one approach, the alert icon is a color coded circle which can appear in one of several states: normal (green), caution (yellow) or danger (red). For simplicity, a dark circle here indicates a danger or abnormal state and an open circle indicates a normal state.","For example, the Application B node  has an alert icon  indicating a normal state for the metrics of Application B. The Application A node  has an alert icon  indicating a danger state for the metrics of Application A. As a result, the BTA node  and the BTA node  also have alert icons  and , respectively, which also indicate a danger state for these Business Transactions as a whole. The alert icon  is set based on aggregated metrics across multiple instances of Application A, such as an average response time. Similarly, the alert icon  is set based on aggregated metrics across multiple instances of Application B.","Metrics can also be displayed within, or proximate to, a node. See  for an example.","The user can select one of the Business Transactions to cause the dependency graph to be modified to provide information which is specific to the selected Business Transaction, as discussed in connection with . This selection can be made, e.g., by using a pointing device such as a mouse which is placed over one of the nodes  and , or via the tree in region .","The dependency graph  graphically depicts: (a) a first node (such as node ) which represents multiple instances of a first application (such as Application A), (b) a second node (such as node ,  or ) which represents one subsystem on which the first application depends (such as Application B, Database X or Database Y, respectively) and (c) at least one edge\/arrow which represents a dependency of the first application on the one subsystem. For example, edges  and  represent a dependency of Application A on Application B, edge  represents a dependency of Application A on Database X and edges ,  and  represent a dependency of Application B on Database Y. One subsystem can depend on another subsystem directly, such as when the one subsystem calls the another subsystem, or indirectly, such as when the one subsystem calls an intermediate subsystem that calls the another subsystem (or the intermediate subsystem calls another intermediate subsystem that calls the another subsystem, and so forth). Generally, a subject subsystem can be said to depend on any downstream subsystem in an execution flow or sequence of invoked resources.","The first node can represent different instances of the first application which have different front end components. For example, one instance of Application A can have the front end component Servlet A and another instance of Application A can have the front end component Servlet A (see ).","The first node can represent different instances of the first application which are invoked in different business transactions. For example, one instance of Application A can be invoked in BTA (but not BTA) and another instance of Application A be invoked in BTA (but not BTA) (see ).","The first node can represent different instances of the first application which are called by different external components. For example, one instance of Application A can be called by the external vertex  () and another instance of Application A can be called by external vertex  ().","The first node can represent one instance of the first application which depends on one subsystem, and another instance of the one of the respective applications which does not depend on the one subsystem. For example, one instance of Application A may depend on Database X while another instance of Application A does not access Database X such as due to an error or network failure or availability.","The dependency graph can also graphically depict: (d) a third node which represents another subsystem, and (e) at least one edge which represents a dependency of the first application on the another subsystem. For example, consider the first node as node  of Application A as a first application, the second node  of Application B as one subsystem which Application A depends on, and the third node  of Database X as another subsystem which Application A depends on. The edges  can represent a dependency of Application A on Database X . It is possible for one instance of Application A to depend on Application B but not Database X, and for another instance of Application A to depend on Database X but not Application B.","Further, the dependency graph can graphically depict: (a) a first node (e.g., node ) which represents multiple instances or deployments of one application (e.g., Application A) of a number of respective applications, (b) a second node (e.g., node ) which represents multiple instances of another application (e.g., Application B) of the respective applications, and (c) at least one edge (e.g., , ) which represents a dependency of the one of the respective applications on the another of the respective applications.","At least one instance of the one of the respective applications can call at least one instance of the another of the respective applications via a web service (e.g., Web Service Client ), and the dependency graph graphically depicts the web service.","At least one instance of the one of the respective applications can call at least one instance of the another of the respective applications via a cross-JVM call (e.g., the call from Application A to Application B is a cross-JVM call\u2014see ).","The first node can represent at least one instance of the one of the respective applications (e.g., Application A) which calls the another of the respective applications (e.g., Application B), and another instance of the one of the respective applications which does not call the another of the respective applications. For example, as mentioned, due to an error or network availability, one subsystem may or may not call another subsystem at different times.","The dependency graph  advantageously aggregates multiple instances of BTA and BTA to provide a view of all paths and subsystems which are invoked in a given time period.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 6B","FIG. 6A"],"b":["1","1","602","608","502","401","627","525","610","1","603","523","502","442","524","442","504","1","1","627","525","1","1","504","431"]},"The highlighting can be achieved using various visual techniques such as different colors, thicker node borders and edges (as is done here) and so forth.","The dependency graph  advantageously aggregates multiple instances of BTA to provide a view of all paths and subsystems which are invoked in a given time period for BTA.","In the dependency graphs which are specific to a selected Business Transaction, alert icons and metrics can be provided which are also specific to the selected Business Transaction. For example, a metric or alert icon for Application A can be aggregated over instances of Application A which were invoked in connection with BTA, but not over instances of Application A which were invoked in connection with another Business Transaction such as BTA.","The dependency graph can graphically depict: (a) a first identifier (e.g., BTA in node ) which represents a first business transaction (BTA) in which a first application (e.g., Application A) is invoked, (b) a node (e.g., ) which represents multiple instances of the first application, (c) a node (e.g., ) which represents one subsystem (e.g., Database X) on which the first application depends, in connection with the first business transaction, and (d) at least one edge (e.g., ) which represents a dependency of the first application on the one subsystem, in connection with the first business transaction. The instances of Application A and Database X may be connected to BTA because they are invoked in execution flows which are associated with BTA by virtue of one of more Business Transaction Components being invoked in the execution flows (see also ).","The first identifier can be graphically depicted by a node (e.g., ) connected by at least one edge (e.g., ) to the node (e.g., ) which represents the multiple instances of the first application.","The first application can also be invoked in a second business transaction (e.g., BTA\u2014see ). In this case, the dependency graph can graphically depict: (e) a second identifier (e.g., BTA in node ) which represents the second business transaction, (f) a node (e.g., Application B) which represents another subsystem on which the first application depends, in connection with the second business transaction, and (g) at least one other edge (e.g., , ) which represents a dependency of the first application on the another subsystem, in connection with the second business transaction.","Responsive to a user selection of the first business transaction (e.g., node ), the dependency graph visually distinguishes the first identifier over the second identifier, and possibly other Business Transaction identifiers, the node which represents the one subsystem over the node which represents the another subsystem, and the at least one edge over the at least one other edge, as shown in .","The first application can be invoked by the first business transaction by virtue of at least a first preselected component (e.g., Servlet A\u2014see ) of the first application being invoked, and the first application can also be invoked by the second business transaction by virtue of at least a second preselected component (e.g., Servlet A\u2014see ) of the first application being invoked.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":["FIG. 6C","FIG. 6A","FIG. 6B"],"b":["2","2","602","620","605","2","2","612","502","442","504","431","527","523","524","526","526","504","431","1","525","502","401","2"]},"The dependency graph  advantageously aggregates multiple instances of BTA to provide a view of all paths and subsystems which are invoked in a given time period for BTA.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 6D","FIG. 6A"],"b":["1","1","602","630","607","1","1","614","504","431"]},"The dependency graph  advantageously aggregates multiple instances of BTB to provide a view of all paths and subsystems which are invoked in a given time period for BTB.","FIG. A depicts a user interface which provides a summary view based on the pruned dependency digraphs of , where an Application A is selected in a front end view. This selection can be made by clicking on the Application A node  or via the tree region , where the selection is indicated by the highlighting of the Application A node. In the UI , the dependency graph  provides a front end view for Application A by identifying all nodes which it depends on, and the edges between these nodes, without regarding to a Business Transaction definition. An additional region  of the UI  can provide information for the selected node in the tree region . For example, the additional information includes the components of Application A and the components that they call. Specifically, Application A includes Servlet A which calls Database X, and Servlet A which calls a Web Service Client. Each component name can be a hyperlink which can be selected by the user to obtain additional component-specific information.","FIG. A depicts an aging process applied to the user interface of FIG. A. An aging process can be applied in any of the dependency graphs to remove components which are less relevant because they have not been invoked recently. This helps to focus the user's diagnosis effort on alive transactions. The aging of vertices and edges can be based on the age of a last invoked edge. The age can be an elapsed time from the current time or from another reference time. If the age of an edge is older than a first threshold age, that edge can be rendered to have an aged appearance which is a different visual appearance compared to the nominal case where the age does not exceed the first threshold age. A vertex can be depicted with an aged appearance if all its incoming and outgoing edges have an aged appearance. Further, the vertices and edges can be removed from the dependency graph completely if the age exceeds a second threshold age, higher than the first threshold age. These threshold ages can be user-configurable. In the UI , in the dependency graph , a dotted line indicates that Database X,  and the edge  to it from Application A  indicates an aged appearance. Thus, the Database X node  and the edge  are older than the first threshold age. In this example, the (Application A, Database X) edge is still included in the view as its last reported date still falls within the removal window. That is, the age of the edge is greater than the first threshold age but less than the second threshold age.","In one scenario, consider Application A as a first application (represented by a first node ) and Database X as one subsystem (represented by a second node ) which Application A depends on. When an elapsed time since the first application (Application A) called the one subsystem (Database X) exceeds a threshold (first threshold age), the dependency graph graphically depicts aging of the second node (). Or, when an elapsed time since the first application called the one subsystem exceeds a threshold (second threshold age), the dependency graph is updated to remove the second node.","FIG. A depicts another example of an aging process applied to the user interface of FIG. A. The UI  provides a dependency graph . In another scenario, consider Application A as a first application (represented by a first node ), Application B as one subsystem (represented by a second node ) which Application A depends on, and Database Y as another subsystem (represented by a third node ) which Application B depends on. The dependency graph can graphically depict: (d) the third node () which represents another subsystem, and (e) at least another edge () which represents a dependency of the one subsystem on the another subsystem. When an elapsed time since the first application called the one subsystem exceeds an associated threshold (first threshold age), and an elapsed time since the one subsystem called the another subsystem exceeds an associated threshold (first threshold age), the dependency graph can graphically depict aging of the second node. This aging is shown by the dotted border of the Application B node .","In another approach, when an elapsed time since the first application called the one subsystem exceeds an associated threshold (second threshold age), and an elapsed time since the one subsystem called the another subsystem exceeds an associated threshold (second threshold age), the dependency graph can be updated to remove the second node. This is indicated by FIG. A. FIG. A depicts a further example of an aging process applied to the user interface of FIG. A. The UI  provides a dependency graph . When a node is removed due to aging, all of the downstream nodes and edges can also be removed, in one approach. Further, a Web Service call to the node can be removed.",{"@attributes":{"id":"p-0124","num":"0123"},"figref":["FIG. 7B","FIG. 7A"],"b":["710","606","703","502","1","402","2","404","504","1","412"]},"The dependency graph can thus be alternatively provided in a summary view or a detailed view based on a user selection, where in the summary view, a first node (such as node ) represents multiple instances of one application (e.g., Application A) of a number of respective applications without identifying invoked components of the multiple instances of the one of the respective applications, and in the detailed view, the first node represents the multiple instances of the one of the respective applications while identifying invoked components (e.g., Servlets A, Servlet S) of the multiple instances of the one of the respective applications.",{"@attributes":{"id":"p-0126","num":"0125"},"figref":["FIG. 7C","FIG. 4K"],"b":["720","705","504","431","526","702","1"]},{"@attributes":{"id":"p-0127","num":"0126"},"figref":["FIG. 7D","FIG. 7C"],"b":["730","606","707","504","1","412","526","1","504"]},{"@attributes":{"id":"p-0128","num":"0127"},"figref":["FIG. 7E","FIG. 7A"],"b":["7","602"]},"The response time can be an average over multiple invocations of multiple instances of Application A in a time interval. The remaining metrics are similarly aggregated over the time interval.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIG. 8A"},"A top level of the hierarchy is a domain level  named \u201cDomain.\u201d A next level of the hierarchy is a Business Service level . An example of a Business Service relates to trading involving a stock or other financial instrument using a web site. Thus, \u201cTrading\u201d can be the name of a node at the Business Service level of the hierarchy. A specific instance of the Trading Business Service occurs, e.g., when a particular user executes a trade. Other example Business Services include \u201cBuy Book\u201d for a book-selling web site, and \u201cEnroll in benefits\u201d for a employees enrolling in a benefits program.","A next level of the hierarchy is a Business Transaction level. As mentioned, a Business Transaction can represent a task from a client perspective, such as logging into a web site, ordering an item, and so forth. A Business Service can be made up of a number of Business Transactions. For example, for Trading, the Business Transactions can include: Login  (e.g., login to the web site), Balances  (e.g., obtain a balance of an account), Account Summary  (e.g., obtain a report of recent buy\/sell activity), Place Order  (e.g., place an order to buy or sell a security such as a stock or bond-something other than an option) and Options Trading  (perform an action such as researching and\/or making an options trade). A specific instance of Login occurs when a user attempts to login to an account.","Further, a Business Transaction can be associated with one or more Business Transaction Components. A Business Transaction Component can be any type of component of an application, such as a servlet or EJB. In one approach, one of the components of an application is set as a Business Transaction Component, which is an identifying transaction component for a Business Transaction. An individual transaction that the Business Transaction Component is associated with the identifying transaction. A transaction can represent a sequence of software components which are invoked in response to a request from a client, to provide a corresponding response to the client. For example, a Business Transaction Component can be identified by determining when component data reported by an agent matches a set of rules. This definition can include, e.g., a specified URL host name, URL parameters, HTTP post parameters, cookie and\/or session manager parameters. Additionally, or alternatively, the definition may require a transaction to start with a specified URL host name. The agent or manager, for instance, can compare the component data against the set of rules to determine when a Business Transaction Component is present in a Business Transaction. If a Business Transaction Component is detected, then the associated Business Transaction is of a specified type. For example, if the Business Transaction Component , , ,  or  is detected, then the associated Business Transaction is Login , Balances , Account Summary , Place Order  or Options Trading , respectively.","For a transaction which is associated with a web page, the Business Transaction Component might be invoked in connection with a low level component used in a web page, such as an image (e.g., .gif file), cascading style sheet (e.g., .css file), JavaScript code component (e.g., .js file) and so forth. For a transaction which is associated with a servlet, a Business Transaction Component might be invoked in connection with a JavaServer Page (JSP) that is loaded into a secondary frame.","Typically, each instance of a Business Transaction involves execution of code of a sequence of one or more of applications or other subsystems. The subsystems depend on one another, e.g., call one another, in a serial or branched chain. Different Business Transactions can sometimes use a common subsystem. A subsystem can include one or more software components which perform a specific task.","The example subsystems include instrumented subsystems which are represented by dashed line boxes, and which are typically front end subsystems, as well as un-instrumented subsystems which are represented by dotted line boxes, and which are typically back end subsystems. A front end subsystem can call another front end subsystem, such as via a Web Services call. Or, a frontend subsystem can call a backend subsystem. A full range of performance metrics can be obtained from an instrumented subsystem. Limited information may be obtained regarding an un-instrumented subsystem from the methods that are used to call out to them from the instrumented subsystems. In the case of un-instrumented databases, for example, a JDBC driver (located in the same Java Virtual Machine (JVM) as the calling front end) provides metrics that give us an idea of the responsiveness of the database. In the case of un-instrumented mainframes, there is usually a method that calls out to the mainframe on a specified port on the mainframe, and we can measure how long that call takes or if it stalls or reports an error.","In many cases, an un-instrumented subsystem is a back end subsystem such as a mainframe, database or some other un-instrumented computing device. These are unknown components\/destinations. The instrumented subsystems include: TradeService , OrderEngine , AuthenticationEngine , ReportingService , AuthenticationService  and ReportingEngine . The un-instrumented subsystems include: OrderRecordsSQL , ReportRecordsSQL , a system caDBHost , which is accessed via its port number , a system caSAPHost , which is accessed via its port number  and CustRecordsSQL . A subsystem which includes SQL in its name is a Structured Query Language (SQL) database. A \u201c?\u201d indicates that the subsystems  and  are unknown.","Component-oriented programming models are useful in allowing the programmer to assemble an application or other program from building blocks referred to as components. Each component can perform a specific function which fits in with an overall functionality of the software. Furthermore, a component can call other components, as well as calling itself, in a recursive call, so that a sequence of components is invoked in a program. One example of a component oriented programming model is J2EE, which can employ components such as a Java Server Page, an Enterprise Java Bean (EJB), a servlet, and a Java Database Connectivity (JDBC) component. JDBC is an Application Programming Interface (API) for the JAVA\u2122 programming language that defines how a client may access a database. It provides methods for querying and updating data in a database. However, other component oriented programming models such as .NET may also be used. Moreover, the programming model need not be object oriented.","In one possible implementation, a component is a class-method (CM) pair. For example, a servlet is one example of a JAVA class. It is an object that receives a request and generates a corresponding response. A class-method pair can be represented by the notation class.method. An example format of a class-method pair is: ServletA.EnterOrder.",{"@attributes":{"id":"p-0140","num":"0139"},"figref":["FIG. 8B","FIG. 8A"],"b":["840","842"]},"In response to this selection, a number (one or more) of associated Business Transactions, subsystems of the Business Transactions, and edges which show dependencies among the subsystems, are displayed in the dependency graph . The oval-shaped nodes , , ,  and  on the left hand side identify the Business Transactions. Edges indicate which subsystem is first invoked for a Business Transaction, and the subsystems which are subsequently invoked. In some cases, a common subsystem is invoked for different Business Transaction instances. The components which are invoked for a given Business Transaction instance can be separately tracked using unique identifiers, even when the components are at the same subsystem. Moreover, it is possible for separate instances of a component or application to be invoked at a subsystem in different Business Transaction instances. Again, these separate instances can be separately tracked.","Also, note that separate instances of the same Business Transaction need not invoke the same subsystems. For instance, due to an error or network failure or availability, a Business Transaction instance may not invoke a particular subsystem which would otherwise be invoked when no error occurs. Or, due to the time of day or available resources, separate instances of the same Business Transaction can invoke different subsystems. Many variations are possible.","The border of the nodes is used to depict whether the node is highlighted, and in some cases, a type of highlighting. Highlighting is one way to visually distinguish a node or edge from other nodes or edges, respectively. Different colors may also be used. In one approach, a dotted or dashed line border indicates no highlighting, while a solid line indicates highlighting. The highlighting of a node can be responsive to a user selection in the region  and to a user selection of the node itself in the UI. Various highlighting, color coding and other visual effects can be provided to convey information to the user. Some of the subsystem nodes include: (a) a symbol such as two overlapping screens which represents a front end or aggregated front end (e.g., all servlets that share the same application context), (b) a cylinder-shaped symbol that represents a database or (c) a symbol that represents an unknown (un-instrumented) subsystem which is the destination of a socket call, to identify a type of the subsystem.","Other types of notations involve metrics and alerts. Alerts are available for Business Transactions (based on the associated component data), for a front end's overall performance (\u201cHealth\u201d), and for back end calls made by the front end to an un-instrumented back end or to another front end. Calls made to another front end can be made through Web Services or EJB Clients to appear as such on the graph. As mentioned, these alerts can be created and configured by a user. Thus, any given Business Transaction, front end, or back end call might or might not have an alert defined for it.","The front end subsystems can make a call out of the application server through a socket. Those calls could be Web Services calls, JDBC driver calls or other types of calls. Web Services are typically application programming interfaces (API) or Web APIs that are accessed via Hypertext Transfer Protocol (HTTP) and executed on a remote system hosting the requested services. These calls, and others such as the JDBC driver calls, are still in the application server so we can detect them and obtain metrics regarding them, but since they call out of the application server, they are referred to as back end calls. The destinations of these back end calls are either other front ends (in the case of Web Services and some EJB calls) or un-instrumented back end components. Most of these un-instrumented components can be at least partially identified from the back end call; for instance, JDBC driver calls are labeled with their destination database name, and the default socket calls are labeled with the destination host and port. In other cases, the user may have defined custom calls and labeled them with their destination. In all these cases, the UI can provide a box representing the back end destination, labeled appropriately and with an icon depicting a database or other appropriate type of component.","For instance, if there is a call through a socket and we have instrumented the call and knew that it took 56 milliseconds, but we do not know its destination (what subsystem it called), we can display that time metric in the UI alongside a back end node showing an \u201cunknown component\u201d icon and labeled with the system hostname and port. The back ends , , ,  and  are essentially dummy nodes in the graph because they represent a destination which is not instrumented and for which we therefore have no information reported by the destination. For a call from one front end to another, full instrumentation is available. The call may be made, e.g., via Web Services or an EJB client. All Web Services calls originating from a single front end are aggregated and represented as a single \u201cWeb Services\u201d back end call; thus, unlike other types of calls, a Web Services call may have more than one destination. In this case, the back end call will appear as a forking or branching arrow in the graph. Web Services  and  (represented by \u201cW\u201d) represent two such forking Web Services calls; contrast these with the call between AuthenticationService  and AuthenticationEngine , which is also a Web Services call, but with a single destination.","The TradeService node , for instance, can represent a summary of multiple instances of the TradeService subsystem which run across multiple machines. The Web Services  are associated with one or more computing device\/machines on which the TradeService  subsystem runs, and the Web Services  are associated with one or more computing device\/machines on which ReportingService  subsystem runs. The metric or alert icons for Web Services  and  represent the performance or health of the method call(s) that were made from one computing device to a next computing device.","In one approach, the alert relates to a time metric such as a response time. The alerts can be configured based on any type of performance metric. For example, instrumentation can yield many types of performance metrics, including an average execution or response time of a component, an invocation rate per second or per interval, a count of invocations, a concurrency metric indicating a number of invocations that have started but not finished per interval, and a stalled metric indicating a number of invocations that have started whose method invocation times have exceeded a specific threshold per interval. Further, the data can identify a garbage collection heap size, a bandwidth metric indicating file and socket activity, a number of threads, system logs, exceptions, memory leaks and component interactions. These are examples of component data obtained at application runtime and reported by an agent. Alerts can be provided for any of the items.","Moreover, an alert can be configured based on one or more performance metrics for a Business Transaction Component. For example, an alert can represent an average response time of a subsystem over a specified period of time.","Based on the alerts and metrics icons, the user can take various steps to obtain further information regarding the Business Transactions, subsystems and calls depicted in the UI. In one approach, the user is guided by the presence of the alerts and metrics icons and seeks to obtain further information regarding the associated Business Transactions, subsystems and calls, such as to diagnose a problem.","Referring to the specific Business Transactions and their subsystems, the UI indicates that Place Order  and Options Trading  both invoke the front end application\/subsystem, TradeService . In an example scenario, a user initiates Place Order  by defining an order which is to be placed, e.g., to buy or sell a stock or bond. All user inputs, and information or instructions presented to the user, can be provided via a web page or other UI. Or, a user initiates Options Trading  by defining a trade involving an option, such as a put or call. In either case, TradeService is used. TradeService calls System caSAPHost , such as to obtain additional information to process the order\/trade. Little is known about the System caSAPHost  because it is not instrumented, so the node for it is merely a placeholder. The port of the computing device  which is called by the instance of TradeService is known (e.g., port ), and this information is used to decorate the node . System caSAPHost  could call another host or resource (not shown) as well, but this would not be depicted.","In computer networking, a port is an application-specific or process-specific software construct serving as a communications endpoint. It is used, e.g., by Transport Layer protocols of the Internet Protocol Suite, such as Transmission Control Protocol (TCP) and User Datagram Protocol (UDP). A specific port is identified by its number, commonly known as the port number, the IP address with which it is associated, and the protocol used for communication. TCP and UDP specify a source and destination port number in their packet headers. A process associates its input or output channel file descriptors (sockets) with a port number and an IP address, a process known as binding, to send and receive data via a network. The operating system's networking software has the task of transmitting outgoing data from all application ports onto the network, and forwarding arriving network packets to a process by matching the packets IP address and port numbers.","Processes create associations with transport protocol ports by means of sockets. A socket is the software structure used as the transport end-point. It is created by the operating system for the process and bound to a socket address which consists of a combination of a port number and an IP address. Sockets may be set to send or receive data in one direction at a time (half duplex) or simultaneously in both directions (full duplex).","TradeService  uses one or more Web Services (aggregated into a Web Services nodes ) to request the order\/trade. Web Services  in turn call: (a) the OrderEngine subsystem , which processes the order\/trade, and\/or (b) the AuthenticationEngine subsystem , which authenticates the order\/trade, such as by verifying the user's credentials. The graph does not necessarily indicate that TradeService calls both of these other subsystems at approximately the same time or at different times (e.g., maybe it was after the call to the OrderRecordsSQL database was made); as part of the same Business Transaction or as part of different Business Transaction (there are two Business Transactions associated with TradeService, after all); etc. It's also possible they were both called as part of the same Business Transaction but during different instances of it. The graph tells us that at some point in a specified time period, TradeService called both of these front ends, using Web Services .","The OrderEngine subsystem  calls two back ends to service one or more calls from Web Services : the OrderRecordsSQL database , which stores order records using SQL, and System caDBHost . System caDBHost  may be used to obtain additional information to process the order\/trade. The AuthenticationEngine subsystem  calls the CustRecordsSQL database , which stores customer records, such as to confirm that the user\/customer is authorized to place the order\/trade.","The Business Transaction of Login  involves the front end subsystem, AuthenticationService . In an example scenario, Login invokes the AuthenticationService subsystem  which in turn calls the AuthenticationEngine subsystem , which could be on the same server, or a different server, than the AuthenticationService subsystem . The AuthenticationEngine subsystem  calls the CustRecordsSQL database  to access customer records to confirm that the user login matches the password. The control flow returns to the AuthenticationService subsystem  at which point the instance of the Login Business Transaction ends.","Both Balances  and Account Summary  invoke a common front end application\/subsystem, ReportingService . In an example scenario, a user initiates Balances by making a request to obtain an account balance, e.g., to learn the amount of funds in a particular account. Or, a user initiates Account Summary  by making a request to obtain a report (e.g., statement) of recent transactions, e.g., orders\/trades, fund transfers and so forth. In either case, ReportingService  processes the report request by calling the Web Services , which in turn calls the AuthenticationEngine subsystem , which may call the CustRecordsSQL database  to access customer records to confirm that the user\/customer is authorized to obtain a report.","In one implementation, the control flow returns to the ReportingService , which makes another call via the Web Services  to the ReportingEngine subsystem , which fulfills the report request by calling the ReportRecordsSQL database , to obtain records which are used to provide the report. This call to Web Services  may include information which specifies the type of report desired, an account identifier, a time frame involved and so forth.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":["FIG. 8C","FIG. 8B"],"b":["850","803","810","820","821","844","826","832","820","820","821","853","851","852","810","820","855","853"]},"The edge  is thus decorated with at least one of: an aggregate metric \u201c200 msec.\u201d and an alert  based on the aggregate metric, and the node  is a first node which is decorated with at least one of an aggregate metric \u201c1200 msec.\u201d and an alert  based on the aggregate metric.","Due to the highlighting of nodes and edges, the user can quickly identify the subsystems that are associated with a given Business transaction even when a subsystem is associated with multiple Business Transactions. Further, due to the use of metrics and alerts, the user can quickly ascertain that a given subsystem within a Business Transaction is a problem and focus the diagnosis on that subsystem. The severity of an alert can also guide the user. The metrics which are provided on the UI can be based on data from a managed application in a specified time interval.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":["FIG. 8D","FIG. 8B"],"b":["860","807","812","820","844","826","834","828","836","820","854","852","812","820"]},"Note that the alert and metrics for a node or edge can be specific to the selected Business Transaction.","The data which is used to provide the dependency graph can be for a selected time period. In one approach, the user selects a \u201cLive\u201d button  so that the data used to provide the dependency graph is constantly updated as time progresses, and the dependency graph itself is updated as the underlying data changes. For example, the data can be selected to represent a rolling window of the last fifteen minutes (or some other default or user-configurable period). In another approach, the user selects the \u201cHistorical\u201d button  so that the data used to provide the dependency graph is for a fixed, historical time period and is not updated as time progresses. Furthermore, the historical time period can be easily configured by the user by dragging a slider tool  on a time bar , which represents hours, minutes and seconds in an HH:MM:SS format. In the current configuration of the slider tool, a time period from 13:35:00 to about 13:42:00 is encompassed. For example, the user can use a mouse to drag the entire slider tool, or to extend the right and\/or left edges of the slider tool to encompass a larger time period. The slider tool identifies the historical time period, e.g., by its width, when the slider tool is arranged horizontally, or by its height, when the slider tool is arranged vertically.",{"@attributes":{"id":"p-0165","num":"0164"},"figref":["FIG. 9","FIG. 1","FIG. 3"],"b":["118","310"]},"At step , the data can be accessed for a specified time interval under analysis which can be set to a live time period or a historical time period, as discussed in connection with . The data can be accessed once, or repeatedly, from a data store, for instance. Step  identifies subsystems which were invoked in the time period and their dependencies. The association of subsystems to a Business Transaction can be achieved using special map tracers that report back information about transactions that are occurring; if the transaction matches a Business Transaction Component, then that transaction is labeled with that Business Transaction Component name and all the lower-level components invoked during that transaction are associated with that Business Transaction Component (and thus its Business Transaction). Those lower-level components later get aggregated into \u201csubsystems\u201d based on certain rules. Within the transaction trace, the front end and back end-calls that appear in the graph and the tree are associated with specific metric paths (identifiers) that are appear associated with a segment when that component is hit as part of a traced transaction. So we identify transactions by looking for the selected Business Transaction Component or front end identifier\u2014as the initial segment of the thread. Once a subsystem identifier is found in the transaction trace, we know we're \u201cinside\u201d that subsystem. All the calls made from that point on in the transaction are then necessarily part of the same subsystem (given the level at which we aggregate things in the graph)\u2014until the next recognized subsystem (front end or back end call) is invoked.","Step  calculates performance metrics such as average response time, concurrent invocations, errors per interval, responses per interval and stall count. The metrics can be calculated for each Business Transaction, transaction and component. Step  determines the alert levels, such as by comparing the performance metrics to respective alert thresholds. Step  includes displaying or updating the user interface with the relevant information for the time interval under analysis. Step  can also include includes updating the user interface based on user commands.","The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 4A","FIG. 1"],"b":"106"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 4B","FIG. 1"],"b":"106"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 4C","FIG. 1"],"b":"110"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4D","FIGS. 4A-4C"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 4E","FIGS. 4A-4C"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4F","FIG. 4A"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIGS. 4G and 4H","FIG. 4F"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 4I","FIGS. 4B and 4C"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 4J and 4K","FIG. 4I"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 5A","FIGS. 4H and 4K"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 5B","FIGS. 4H and 4K"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 6A","FIGS. 4H and 4K"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 6B","FIG. 6A"],"b":"1"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 6C","FIG. 6A"],"b":"2"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 6D","FIG. 6A"],"b":"1"},"FIG. A depicts a user interface which provides a summary view based on the pruned dependency digraphs of , where an Application A is selected in a front end view.","FIG. A depicts an aging process applied to the user interface of FIG. A.","FIG. A depicts another example of an aging process applied to the user interface of FIG. A.","FIG. A depicts a further example of an aging process applied to the user interface of FIG. A.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 7B","FIG. 7A"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 7C","FIG. 4K"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 7D","FIG. 7C"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 7E","FIG. 7A"],"b":"7"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 8B","FIG. 8A"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 8C","FIG. 8B"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 8D","FIG. 8B"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
