---
title: Method and apparatus for enabling parallel processing during execution of a Cobol source program using two-stage compilation
abstract: A method and apparatus is disclosed for compilation of an original Cobol program and building an executable program with support for improved performance by increased parallelism during execution using multiple threads of processing. The approach includes a compilation (or translation) step utilizing a first compiler or translating program which is a parallel aware translating first compiler. The parallel aware first compiler is a specialized compiler/translator which takes as input a Cobol source program, and produces as output an intermediate computer program in a second computer programming language, the intermediate program including parallelization directives, the intermediate program intended for further compilation utilizing an existing selected second compiler, the second compiler providing support for parallelism for programs described in the second programming language. The approach optionally allows for use of pragmas serving as parallelization directives to the compiler in the original Cobol program or in the intermediate program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08370820&OS=08370820&RS=08370820
owner: 
number: 08370820
owner_city: 
owner_country: 
publication_date: 20091020
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","THE NAMES OF PARTIES TO A JOINT RESEARCH AGREEMENT","INCORPORATION-BY-REFERENCE OF MATERIAL SUBMITTED ON A COMPACT DISC","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Overview","DISCUSSION OF FIGURES"],"p":["NONE","NONE","NONE","NONE","1. Field of the Invention","This invention is related to the fields of: computing machines; parallel processing; parallel computing; multiple thread program execution; the computer language Cobol; the computer languages JAVA, C\/C++ and Fortran; computer program compilers; computer languages, and other closely related computer art.","2. Description of the Related Art","In the field of computing machines and computing performance, computer users have become accustomed to computer performance increasing steadily over the years as a result of technological innovation in the hardware of computers. However, there are limits on technology which tend to limit continued increases in computer hardware performance. For example, certain technical limitations tend to limit how fast a computer program can run on a single computer.","An alternative to increasing performance of a program on a single or small number of processing units is to spread the work to be done across multiple processors or multiple computers. Innovation and technical advancement in this area have provided for increasing computer program performance by developing techniques for spreading work across a plurality of computers or central processing units. A common term for this spreading of work is \u201cparallelization\u201d. There are many forms of parallelization and ways of achieving parallelization which are discussed at length in literature surrounding the art and which will not be discussed here. One particular area of research and significant development which is of particular interest in the field of parallelization is a standard for describing and enabling parallelization called OpenMP Architecture (Open Multi-Processing Architecture). \u201cOpenMP\u201d is a trademark of the OpenMP Architecture Review Board, and the standard is described on the internet at a website \u201cOpenMP.org\u201d and specifically within that website at the webpage: \u201chttp:\/\/openmp.org\/wp\/about-openmp\/\u201d. The OpenMP Architecture is described within this webpage as \u201cAPI Specification for Parallel Programming\u201d. Wikipedia.org (@ http:\/wikipedia.org) further describes OpenMP as:\n\n","OpenMP as a project was initiated in 1997 at a major conference on High Performance Computing Networking, and Storage held in San Jose, Calif. The conference was named \u201cSupercomputing 1997\u201d. The proposal for a parallel programming \u201cstandard\u201d grew out of a \u201cbirds of a feather\u201d session to unveil new portable programming interfaces for shared memory parallel computers. Following the conference a company was set up to own and maintain the new informal standard and it was called the OpenMP Architectural Review Board (ARB).","The OpenMP architecture provides a methodology and programming language enhancements that enable processing with parallel threads of processing. OpenMP requires support within (or \u201cby\u201d) a compiler, that is, it is not just a library that is called; it requires support by the compiler itself. OpenMP today is supported by several major compilers (GNU C compiler, Intel, Microsoft) for computer programs written in the languages of C\/C++, and Fortran. There are books and classes on parallel programming based upon OpenMP.","However, OpenMP architectural support for programs written in other computer languages such as Cobol, Pascal and other either \u201colder\u201d or less common computer programming languages is not provided by major computer program compiler manufacturers such as Intel, Microsoft, or by providers of open source compilers such as GNU.org. As a result, the benefits of programming utilizing OpenMP to achieve parallelism are not currently available for programs written in these older languages, and support is not likely to be provided in the future by major compiler manufacturers because most new program development is done in more modern languages.","However, Cobol is still the programming language for many large computer business applications that are in production use today, and the performance of these programs or applications is often critical to operation of a business. Therefore, it would be beneficial if these large computer applications could be made to benefit from parallel programming in order to improve their performance during execution. Improvement in performance of what are commonly called \u201cbatch\u201d programs might be especially important. The term \u201cBatch\u201d is used to describe a job, often run at night, that typically processes a large amount of data from a day of recorded transactions. Oftentimes \u201cbatch\u201d programs are run at night and oftentimes must be completed before more transaction data can be accumulated (the next day for example).","Providing support for parallelization techniques by a compiler for a language such as Cobol is a very significant task for several reasons. First of all, developing a new compiler or significantly enhancing an existing compiler for any purpose can be a large task. Second, providing for parallelization enabling concepts within generated code from a compiler is a difficult job, and would be a very significant development task. Third, one major component of \u201cgood\u201d compilers is providing a facility\/mechanism\/capability for carrying out very extensive optimization of generated code in order to achieve good performance during execution, and support for OpenMP would typically have impact on those optimizations. For these reasons and others such as lack of limited resources, innovation, financial burdens etc., major compiler builders have not provided a Cobol compiler that supports parallelism such as the OpenMP architecture.","Because of the business nature of most Cobol applications, existing Cobol compilers used by large businesses are very carefully maintained by vendors in providing for backwards compatibility and to avoid any possible introduction of bugs or flaws in the code generation process. The importance of producing correct calculations is emphasized and thus, even the smallest changes are typically verified carefully by running large numbers of test programs. As a result, changes and improvements to Cobol compilers are made slowly and carefully, possibly even reluctantly.","Another reason parallelization support has not been provided for the Cobol programming language is that the language of Cobol is not necessarily well suited to parallelization. The Cobol language, because it is quite \u201cold\u201d, has typically been used to describe a program that exists statically in memory with static memory variables, and oftentimes without the use of \u201cmodern\u201d programming constructs such as \u201cstacks\u201d or automatic memory allocation and de-allocation. This tends to create conflicts in the use of memory based variables when attempts are made to parallelize program execution, because parallelization typically requires at least some degree of isolation of memory between the units of parallelized code. Also, there are no OpenMP library facilities available which directly provides OpenMP support for the Cobol language.","But, improving the performance of programs written in Cobol is potentially important, and improving performance by providing for support of parallel processing in the execution of a Cobol program would result in a potentially significant increase in performance by enabling application and utilization of multiple processors or computing cores to a single program or problem which was normally run, in the prior art, as a single-thread process or procedure. The same is also true for other languages such as Pascal, PL\/1, or other possibly \u201colder\u201d languages where no support for parallelism is currently provided by major compiler providers.","The state of the art has also evolved such that parallelization or multithreading of programs now has some increased potential for being automated, or at least done with more help by tools than in the past. One company that is exploring this area of research is a Swedish company called Nema Labs which is developing a tool called \u201cFasThread\u201d. Nema Labs has a website at: \u201chttp:\/\/NemaLabs.com\u201d. From the company's website is the statement:\n\n","Nema Labs provides a tool which attempts to semi-automate the parallelization of programs written in \u201cC\u201d and is currently working on a version of the tool which also supports \u201cC++\u201d. The FasThread's analysis and processing tool includes a mechanism for inserting OpenMP pragmas into programs in the \u201cC\u201d language based upon analysis by the tool. This type of tool provides the potential of being useful in achieving parallelization. It utilizes OpenMP and is not applicable to a source program described in any language except its \u201cnative\u201d input language of C.","A Cobol programmer may thus now be motivated to look at the potential for parallelization of certain, possibly large, Cobol programs, in spite of the possibility that parallelization of these programs may not have been feasible in the past.","It would therefore be an advantage to provide a method and\/or apparatus for compilation of a program written in a source computer language not normally supported for OpenMP, which enables parallelization during execution of the generated code (either object or executable). It is also an advantage to provide a method of compilation designed to eliminate need for development of a Cobol compiler with integrated parallelization support, and with the method further providing for minimal maintenance effort in the support of providing such a method and\/or apparatus.","An illustrated embodiment of the present invention provides support for a method and apparatus for carrying out compilation of an original Cobol program which produces an executable program that supports multiple threads of processing, improving performance of the original Cobol program during execution.","The method according to an illustrated embodiment implements a two-step or two-phase approach in performing a compilation of an original Cobol program. In the illustrated embodiment, a first compiler or translator is utilized in a first phase of the two phase approach to analyze, process, and translate the original Cobol program source into an intermediate source form in a second computer programming language. This intermediate source produced in the first phase is in a form for describing a program in a manner suited for parallelization through the use of parallelization directives such as the type used by the OpenMP architecture. In a subsequent second phase of the two phase approach, a second selected compiler, which provides support for the parallelization of an input program described in that second computer language, is utilized to compile the intermediate source and produce as an output, a multithread executable program for running on multiple processors or computing cores.","More specifically, as described with reference to the illustrated embodiment, a first compiler translates in a special way a Cobol source program into an intermediate program. A second selected compiler reads the intermediate program and produces, as an output file or files, an executable program having functionality described by the original Cobol source, and which further includes code containing directives that enables parallelism within at least some regions of processing when the resulting executable program is run or executed. The second compiler may also as an alternative produce an object file which is used, typically with other object files, in producing an executable program. In one illustrated embodiment, the first compiler translates in a special way a Cobol program into an intermediate program in the \u201cC\u201d programming language. A second compiler reads as input the intermediate \u201cC\u201d program and builds an executable (object file or executable program file) with parallelization enabled (processing by multiple threads). (Executable program being meant to describe in general terms any sort of file that may be used in processing. Examples of this type of file are an actual executable file, or an object file that can be used to produce an executable file, or a DLL (Dynamic Link Library) file, or any file which at run-time can be loaded or processed and loaded into memory for execution).","In this manner, an executable (or executable program) is produced based upon the input Cobol program, the executable program providing parallelism by utilizing multiple threads of processing during execution. Because of multi-threaded execution or processing, the executable program is typically capable of running observably faster than a program run with no parallelism (single thread). That is, the rate of observable work completed in a given time will typically be improved (i.e. be made greater) when the executable program is processed by multiple processing threads, in comparison to a standard approach in which the executable program (or at least the main part of the executable program) is processed by only one thread. In some cases, the rate of work being completed can be seen to increase at a rate related almost directly proportional to the number of threads used.","The compilation, analysis and translation by a compiler in the first stage of the illustrated embodiment is a specialized translation resulting in an output in a specific syntax, style and having an ordering of output statements and declarations supportive of parallelization. The compiler in the first stage or first phase analyzes the original Cobol program and produces as output, a translated or intermediate program (typically in C\/C++ of Fortran) which is specifically organized so as to enable the building of an executable program which provides for parallelism using multiple threads, and whose organization is the same or similar to the organization typically required by a parallelization standard such as OpenMP. That is, the style (constructs chosen for use in the translation) and syntax of the translated output from the first compiler is dependent on the specific parallelization desired and the style necessary in order for the intermediate program to be processed by a second, parallel capable compiler of the illustrated embodiment.","As discussed, the compiler of the first stage produces an intermediate program in a second computer program language, that intermediate program is translated in a manner organized to accommodate and include within the intermediate program parallelization directives that are in form suitable to be processed in a second stage of compilation by a selected second compiler; the second compiler is specifically selected to provide support for parallelization directives such as the exemplary OpenMP standard. The second compiler is utilized to build the executable program, that executable program providing for processing by multiple threads of operation during its execution. The organization, syntax, and style of the components of the intermediate program and the parallelization directives which are generated by the first stage of processing are constrained and designed so as to be compatible and in a form suitable for processing by the second stage (standard) compiler.","The method(s) and approach of the present invention have the potential or opportunity to provide the following several specific improvements and advantages over the above discussed approaches of the prior art:\n\n","The first improvement is achieved through use of the two-step (or two phase, or two stage) approach of the present invention described briefly above. That is, as described with reference to one illustrated embodiment, translating a Cobol source program into C, and then compiling the C program with a second compiler to produce an executable program, the two-step process providing throughout such process provisions for both describing parallelism and for building an output executable program which includes parallelism during execution. This will be described in more detail later herein.","The second improvement is also provided, as part of the two-step approach, by choosing or selecting as the second stage compiler that produces an executable program that is highly performant. That is, since the second compiler is the program that actually builds an executable program, it is very important, in terms of achieving best performance, to choose or select as a second compiler, a compiler that generates as an output, a well optimized, highly performant executable program. This \u201cbest\u201d choice of compiler is likely to result in selecting a compiler from a company that is a manufacturer or designer of the processor itself, (such as Intel Corporation), or from a large company such as Microsoft Corporation with many resources in terms of personnel and expertise, and with good relations with the hardware designers. It is possible also that an Open Source compiler such as GNU C\/C++ would be a good choice because of the large amount of effort expended by many people to make it a good compiler. The point is that using a very good compiler such as that from Intel Corporation in a second stage of compilation results in producing an executable program that is likely to perform better on that company's hardware than using a methodology based upon development of a single stage compiler.","With regards to the third improvement described above, these maintenance benefits are achieved by utilizing, in the manner just discussed, a \u201cbest choice\u201d or \u201cmajor\u201d compiler as the second compiler. Further, when new hardware evolves, or new compilation or programming efficiencies are developed, the first compiler can be adapted (if necessary) or maintained with very minimal support because it is translating a program into a standard language (such as \u201cC\u201d) and therefore changes in technology which are developed are likely to be provided in that standard language, or accommodated by the second compiler. Thus, only small changes to the first compiler are likely to be needed to support advancement; the larger part of the changes most likely to be provided by the \u201cstandard\u201d second compiler.","Considering the above again but in more detail, with reference to an illustrated embodiment of the invention, parallelism is achieved by a method that implements a two phase approach. The first phase is a translation performed by a special compiler that operates to translate a Cobol program to an intermediate computer program which is in a second computer language. The translation includes the operations of the ordering of the Cobol statements and the translation of the Cobol statements into a form specifically designed for parallelism which are recognizable by a selected or chosen second compiler.","The second phase is a compilation step, performed by the chosen second compiler, for building an executable program utilizing the intermediate computer program in the second language (i.e. generated from the first phase) as input to the second compiler. The second compiler is utilized to build the actual output executable program or object file. The second compiler is a carefully selected already existing (standard) compiler that supports parallelization (such as OpenMP architecture). The specialized first compiler is designed specifically for the purpose of preparing input in a manner acceptable to the selected second compiler, with the input to the second compiler including description of the program including variables and program flow, description of parallelism, with the program variables and program flow being in form which accommodates the description of parallelism.","This approach provides for parallelism without requiring developing or procuring a compiler designed with both direct OpenMP architectural support and direct support for Cobol as an input programming language. Moreover, this approach overcomes the need for developing such a compiler when a compiler which supports OpenMP architecture is not available in the marketplace for a Cobol source program, and, even if such a compiler were to be available, this approach provides for improvements such as reduced maintenance, improved performance, and better support for outside tools such as debug tools developed by other companies for a common language such as C\/C++.","It will be appreciated that it is not just a lack of the availability of any general compiler for achieving parallelism in Cobol that enables an improvement over the prior art. The invention also satisfies a need for performance, a desire for broad machine support, good debug tools, measurement and analysis tools and other similar advantages which are offered by using commercial vendors tools with these features provided in best form on \u201cimportant\u201d modern languages, such as, C\/C++ and Fortran. With application of the method of present invention, some or all of these advantages are provided for a program written in Cobol while also providing for parallelization utilizing multiple threads of processing during execution of the resulting executable program.","In order to further appreciate how the method of the present invention differs from the typical prior art approach, it is helpful to compare in greater detail, the method of the present invention with the typical approach of providing a parallelizing Cobol compiler through development of a single pass Cobol compiler which directly supports the OpenMP architecture. (While to the inventor's knowledge, no such single pass compiler exists, this approach would be typical of development approaches known in the prior art) This prior art approach, without requiring a very major investment, would likely not achieve the quality, robustness, and broad base of tool support provided by the utilization of a major commercial compiler as a second step in the processing of the Cobol program. In fact, without an intimate knowledge of the hardware and software, it would be likely that even with considerable investment both the performance and the features provided by a single pass compiler would not be as good. Further, support for ever evolving hardware\/software platforms and features would require continued maintenance, whereas with the approach and method of the present invention, as improvements are made to the selected commercial compiler, these improvements will be naturally provided without any or with minimal added development on the first compiler.","Because of close and intimate knowledge of the workings of their own company's hardware and software, and because of partnerships with other major commercial vendors, companies such as Microsoft Corporation or Intel Corporation can develop compilers which provide for better optimization and more features than what is likely to be provided by individual developers or developers in smaller or less connected companies. For example, utilizing a major compiler such as a C\/C++ compiler from Intel Corporation as a second compiler provides the benefits of good optimization and continued improvement as hardware changes and evolves. According to the teachings of the present invention, using the special compiler in a first phase to perform a special translation of Cobol as for example which includes capability for expressing and describing parallelism within a Cobol program provides for that parallelism in the first phase, and relies on use of an already existing compiler from a major vendor in a second phase and takes advantage of features of both compilers.","The OpenMP standard for parallel processing in C\/C++ or Fortran programs already provides directives specifically designed to accommodate the languages of C\/C++ and Fortran. Thus, the OpenMP standard provides an opportunity for accomplishing parallelization which is an alternative to building a compiler with completely automatic parallelization, such approach having been shown in the past to be a difficult task for a compiler. Other exemplary prior art approaches for describing or providing parallelization include \u201cMPI\u201d which is a Message Passing Interface\u201d, and \u201cPThreads\u201d which IEEE POSIX standard (Institute of Electrical and Electronic Engineers, and Portable Operating System Interface).","The OpenMP standard itself can be found on the OpenMP.org website at:","\u201chttp:\/\/OpenMP.org\/http:\/\/openmp.org\/wp\/openmp-specifications\u201d with the latest version at this being Version 3.0 dated May 2008. As discussed, OpenMP architecture provides a way for a runtime entity to perform processing using multiple threads, with \u201cthreads\u201d being an entity that is able to independently execute a stream of computer instructions. Multiple threads may interact, but can also run independently. OpenMP architecture provides for a single set of source files that can be run as a single thread or for enabling multiple threads of operation. Multiple threads may be executed on a single processor, or on a machine with multiple processors and\/or multiple \u201ccores\u201d. Multiple threads typically work concurrently to accomplish the work of executing a parallel program.","Also, OpenMP architecture provides directives to create teams of threads for parallel execution, to specify how to share work among the threads, to declare and describe both shared and private variables, and also to provide means for synchronization and communication between the threads. OpenMP architecture provides these directives for programs written in the C\/C++ and Fortran computer programming languages. According to the teachings of the present invention, and in order to take advantage of utilizing the OpenMP architecture approach and the OpenMP library to create and manage parallel processing in a Cobol program, the Cobol program is analyzed and \u201ctranslated\u201d by a special compiler with specific regard to accommodating the generation of a parallel executable program by a second compiler. That is, the translation performed by the special compiler includes an analysis of the Cobol program and generation of intermediate program code that is specifically designed to be in a form recognizable by the second compiler. A general straight-forward translation of Cobol to C as typically performed in the prior art will not provide for C\/C++ (or Fortran) in a form that will allow or enable parallelization. Further, the straight-forward approach of performing a simple translation also does not provide for an intermediate program for which parallelization directives could be inserted as for example, by hand (e.g. by the programmer).","It will be noted that OpenMP architecture provides a fairly small number of directives for describing parallelization in a C\/C++ program. A \u201cParallel Construct\u201d defines a region of code in which parallelization is allowed. \u201cWork Sharing Constructs\u201d provide a mechanism for describing parallelization of loops, single threading of specific sections within a region of parallelized code, and splitting of work into \u201cSections\u201d. OpenMP architecture also provides synchronization constructs such as \u201cBarriers\u201d, \u201cCritical\u201d areas, \u201cAtomic\u201d constructs, \u201cLocks\u201d and defining a \u201cMaster\u201d thread. The Cobol to C translator developed and utilized according to the teachings of the present invention provides for describing multiple threads in a manner which can be applied to a Cobol program, with the translator transforming the Cobol program to express parallelization in a related C\/C++ (or Fortran) transformed program, with this transformed program being written to an intermediate program file for further compilation by a selected second compiler.","Considering as an example, the Cobol programming language provides a statement called a \u201cPERFORM\u201d statement which describes repeated execution (looping) of a specified section of code. In Cobol, a PERFORM statement may describe looping of code that is described in a different area of the program (not immediately following the PERFORM statement). The PERFORM statement works in a manner somewhat similar to that of invoking a subroutine or macro in the C language. The PERFORM statement in a simple translation might be translated to a sequence of code that increments a loop variable and tests for conclusion or termination of the loop with an IF statement, with the work of the PERFORM block being handled as a subroutine call. This translation approach, in general, does not however provide for C\/C++ code which allows for parallelization.","As another example, A COBOL PERFORM statement might be translated, in the manner of the prior art (e.g. the OpenCobol.org compiler), into a C \u201cWHILE\u201d statement. This approach however produces C code which is not supported by OpenMP architecture for parallelization because, for example, the \u201cWHILE\u201d construct is not supported by OpenMP for parallelization). Therefore, according to the teachings of the present invention, the first stage of translation is carried out in a manner with the specific intent of producing intermediate program code that is in an order, style, organization and supportive of compilation by a chosen or selected second compiler, that produces parallelization in the output executable program.","The present invention provides a method for compilation of an original Cobol program, that method providing for building an executable program with support for multiple threads of processing during execution or running of the executable program. Multiple threads of operation provide in some cases for significantly improved performance in the execution of the Cobol program in comparison to using a single thread of execution. The improvements achieved can potentially provide for a performance improvement approaching 2\u00d7, 3\u00d7 or more as two, three or more threads of processing are applied, in comparison to the performance achieved by the use of a single thread.","As described herein, in an illustrated embodiment of the present invention with reference to , a special purpose compiler is utilized to read an original Cobol source program from a computer file system into an addressable memory of a computer system. The variable declarations and the structure of the Cobol program are analyzed in memory and as a result of the analysis specific regions of the Cobol program are identified as having potential for application of multiple threads to the processing in the manner of the original Cobol source program. Regions for potential parallelization may also be identified based upon user input, or embedded content within the Cobol source program itself.","The special purpose compiler provides several functions, the first of which is to translate the Cobol source program into a substantially equivalent program expressed in a second computer language, with the translated output written to a file on the computer system. In this illustrated embodiment, the second language is either C\/C++ or Fortran. The special purpose compiler further provides analysis of the input original Cobol program and utilizes the results of analyzing the structure, program order, variable types and other such information based on analysis of the Cobol source program to define regions of parallelization or regions for potential parallelization. Again, selection and determination of these regions may be further based upon both programmer input to help guide the compiler in determining or locating the potential\/possible or the best regions for parallelization.","As part of the translation process, the special purpose compiler organizes and arranges the program statements in the second language in an order and in a form suitable for describing regions of potentially parallelizable code to a second compiler; the second compiler being a compiler supporting generation of an executable program which enables parallelism through the use of multiple threads of execution. In this illustrated embodiment, the intermediate program is written to a file operatively coupled to or included within the computer system, and then the intermediate program given to the second compiler program for processing. The parallelization directives may for this illustrated embodiment be in the form of the OpenMP standard. The second compiler reads the intermediate program file, processes it in the memory of the computer system (the same computer system, or a different one), and builds an executable program which is written as output into another computer file, that file being in a special format and marked as intended for execution. The compiler may optionally produce either an \u201cobject\u201d file, or an executable file, the object file being a file which can be combined with other objects to build an executable program. The executable program can be specified to be prepared for execution on the same computer on which it is compiled or on another computer, or on different model of a computer.","The method and system of the invention provides for significant potential improvement in the execution time performance of a Cobol program by enabling parallel processing using multiple threads of processing during execution of the Cobol program.","The method and system of the invention provides further advantage in that development of a compiler with direct support for Cobol for example is not required, thus reducing development time and cost, debug time and cost, maintenance time and cost, and significantly increasing potential for reliability of the parallelism constructs in the generated program code.","The method and system of the invention also optionally provides potential for use of existing debug, performance measurement, and program analysis tools which already exist for the already supported form or language, that supported form typically being C\/C++, or Fortran, and also typically with the OpenMP approach.","It is a further advantage of the method and system of the invention to provide for Cobol language support, for example, in a generated executable program for debug and application of debug tools and debug environments in the manner currently provided for C\/C++ and\/or Fortran.","It is a further advantage of the method and system of the invention to provide measurement tools for analyzing performance as an aid to a programmer in determining areas best suited for parallelization.","It is a further optional advantage of the method and system of the invention to provide as part of the overall Cobol compilation process for inclusion of code in the output executable program which would aid in verifying correctness of any multi-threaded execution of a Cobol program.","Translation of a source program described in one computer language to a second source program described in a second source language is not unique or novel. Indeed there are a number of programs that provide for some manner of Cobol to C translation. However, simple translation in the manner described in the prior art does not provide support for parallelization constructs, and further, as discussed above, support for parallelization cannot be provided using the output from a simple translation. Consideration of specific constructs, proper choice of variable types, specific structure and ordering of the code, and other such requirements are necessary to enable parallelism. Thus, in view of the above, it is seen that it is not currently feasible for Cobol programs of any significant complexity to use a simple Cobol to C translation as it exists in the prior art to achieve parallelism in an output executable program. The translation techniques of the prior art are unable to translate Cobol to C in a manner that allows use of OpenMP architectural or parallelization constructs. Further, the prior art manner of translation does not lend itself to the introduction of parallelization constructs such as those used in OpenMP architecture, even if those constructs were to be added by hand by a programmer after to the intermediate file after the translation was made.","In one illustrated embodiment, the present invention provides for translation by a first compiler of an original Cobol source program to an intermediate source program in C\/C++ in a specialized manner designed to provide for including for specification, in the manner of OpenMP architecture, of parallelization constructs to be then applied by passing the intermediate source program through a second compiler; the second compiler typically being available from a major vendor, and producing an output executable program that provides for multiple threads of execution, with such multiple threads providing for observably improved performance during subsequent execution of the output executable program wherein the improvement in performance is achieved during execution of instructions within regions of the program designated as supporting multiple threads and the improvement in each region being related to the number of threads utilized during its execution.","A two stage approach of compiling a Cobol program utilizing a known (typically commercial) compiler (second compiler) means that the input format recognized by the known compiler is specified by the manufacturer of that compiler. That is, the input source program to the \u201cknown\u201d compiler is provided in a specific form in order to be properly processed by the known compiler. More specifically, according to an illustrated embodiment of the present invention, the input to the second compiler is a C\/C++ program, properly formed for processing by the second compiler. In order for parallelization to be enabled, the source to that second compilation further provides for the specification of parallelization constructs in the manner specified by the manufacturer of the known second compiler. And also, the program code is generated such that the parallelization constructs can be successfully applied to enable multiple threads of processing in the output executable program.","For purposes of further illustration of the above, let us assume that the Intel C\/C++ compiler is chosen as a \u201cknown\u201d second compiler, and that it is to be run with provision in the input source files for OpenMP \u201cpragmas\u201d. These \u201cpragmas\u201d are typically processed when enabled by a compiler option. In an illustrated embodiment of the present invention, an original Cobol source program is processed (translated) by a first compiler program according to the teachings of the present invention, and the output of that processing is an intermediate source program in the C\/C++ language. This C\/C++ intermediate source program is then processed by the Intel C\/C++ compiler to produce an output executable or object file. The translation by the first compiler program includes provision for generating OpenMP pragmas in a proper form and includes them in the intermediate source program. The intermediate source program is then submitted for processing by the Intel C\/C++ (ICC) compiler, for example, to produce an executable or object file that enables parallelism through the use of multiple threads during program execution.","An important factor in realizing the potential for success using the two stage translation\/compilation approach of the present invention is determining and expressing precisely the details of style, ordering, and selection of constructs to be utilized in the expression of the Cobol source program in the intermediate (second) form in order to enable application of parallelization constructs by the second compiler (e.g. example, Intel C\/C++ compiler). It is essential that there is correctness in the translation of the original Cobol source program into an intermediate program having the same relative functionality as the original Cobol source program, but expressed or defined in a second language (for example, C\/C++), and that the intermediate form generated by the first compiler enables parallelization in a manner that is supported by the second compiler (e.g. Intel ICC compiler). Achieving this requires consideration of a broad number of factors in determining the specifics of the translation process. These factors include utilization of one or more of the following rules or guidelines:","1) providing a method of translating variable names as declared in the original Cobol source program into variable names that meet the requirements of the second language; (for example, changing \u201c-\u201d hyphens to \u201c_\u201d underscores because Cobol allows hyphens in names and C\/C++ does not)","2) providing a method of translating variable names as declared in the original Cobol source program so as to preserve recognition by a human when those names are observed after the first translation process; (for example, translating \u201cSAMS-CASH-VALUE\u201d to \u201cSAMS_CASH_VALUE\u201d rather than into a \u201ccomputer generated\u201d name which is less recognizable by a human such as \u201cX126\u201d)","3) providing allowance for translated variable names which \u201ccollide\u201d meaning that alternative naming is to be provided to prevent two variable names in the original Cobol source program from being translated into the same variable name in the second language (C\/C++);","4) providing for \u201cCobol like\u201d parallelization directives such as \u201cOMP PERFORM\u201d (for a Cobol \u201cPERFORM\u201d statement) translated into C\/C++ OMP pragmas such as \u201c#pragma omp parallel for\u201d (for a C\/C++ \u201cfor\u201d statement);","5) providing for declaration of variables in a manner so that the variables can be instantiated in memory with proper scope so that during execution, processing can be performed by multiple threads without interference between memory references from different threads to the same variables; and,","6) providing for locating the declaration of some variables within the structure of the intermediate source program so as to provide for declaration of the variables within the limited scope of a parallelized region of the code, thus providing isolation of variable data between multiple threads.","The techniques of providing for the translation of a Cobol source program in a manner that enables parallelization to be described utilizing directives such as those provided in OpenMP architecture, through an intermediate program language such as C\/C++ or Fortran is further illustrated with reference to examples of the current state of the art described in contrast to the teachings of the present invention.","By way of background, in the prior art, utilizing a single stage compiler without support for parallelization, a Cobol source file describing a Cobol program is typically read in during a first pass of the single stage compiler, and at that time, internal tables are built to describe within the first compiler, the Cobol variables, the Cobol program statements, and optionally the comments within the Cobol source program. These internal tables are then examined during subsequent passes of the first compiler to determine and organize the desired functionality, the desired Cobol variables and their data types and other such information as is standard in a computer program compiler. Once these internal tables are completed, the functionality and flow of the Cobol source program can be understood and analyzed further by the compiler.","Typically, in a standard way, the compiler generates an executable program file that includes machine code or assembly language instructions which implement the desired Cobol program functionality, including initialization and preparation of the data structures. Providing support for many different hardware platforms and operating system software platforms however may require significant development and verification when this approach is used.","It is noted that in the OpenMP standard a region of code is defined within the standard as \u201call code encountered during a specific instance of the execution of a given OpenMP construct or library routine. A region includes any code in called routines, as well as any implicit code introduced by the OpenMP implementation\u201d.",{"@attributes":{"id":"p-0088","num":"0094"},"figref":["FIG. 1","FIG. 1"],"b":["101","102","103"]},"Another approach of the prior art for providing compilation of a Cobol program is illustrated in . This prior art method provides for generation of an executable program using two distinct phases of processing. The first phase provides for compilation by a first compiler to translate a program from a first language into a second language, (instead of outputting of machine code or assembly language). Then, the computer program in the second language is fed into a second compiler, which supports (understands) the second language, to produce an output executable. That is, a first compiler produces a second computer program in a second language instead of an executable, with the second computer program describing the functionality of the Cobol program in that different or second computer programming language. This second language is then compiled by a second compiler to produce in a standard way, an output executable. This output executable from the second compiler will perform functionally as described by the programmer in the original Cobol source program, even if the second compiler did not provide support for input in the first language of Cobol. This approach to translation of a Cobol source file to a second source file, the second source file being in an intermediate language, followed by compilation of that second source file with a second compiler to produce an output executable, has been described and implemented in an open source compiler from the organization OpenCobol.org. OpenCobol.org offers a compiler that translates Cobol to C (or C++). The OpenCobol compiler is used to read in a Cobol source program and perform a translation to C which is written to an intermediate output file. The intermediate output file is then provided as input to a second compiler which is typically a standard C compiler such as GCC (GNU Compiler). The second compiler reads and compiles the C language description in the intermediate file and generates either an output executable, or an object file that can be used to build an executable. The output executable performs the functions described in the original Cobol source program. The approach used by OpenCobol.org in their OpenCobol compiler is described on the OpenCobol.org website as follows:\n\n",{"@attributes":{"id":"p-0090","num":"0098"},"figref":["FIG. 2","FIG. 2"],"b":["101","210","211","212","210","220","230","240"]},"The standard language translation approach as implemented by OpenCobol.org shown in  does not however provide any support for parallel programming, and in fact generates intermediate C code that is not suited for the addition of parallel programming constructs or directives, even by hand, in the intermediate output.","In the translation approach of OpenCobol.org and computer language translation approaches of the prior art, assumptions are made for ease of programming, and techniques of translation are chosen which expedite implementation of the translator, and\/or efficiency of the generated code. These approaches and assumptions typically result in a translated output that is not suitable for the addition or inclusion of parallelization constructs, even if attempted by hand, because the translated code, although functionally operative and correct, is not expressed in a form to which parallelization constructs can be applied. The \u201cproblems\u201d posed in trying to adapt a translator of the prior art for an application enabling parallel programming are not readily apparent until an attempt is made to use the intermediate code and to try to accomplish parallelization.","As a first example, it can be observed using the OpenCobol.org compiler that variables in the original Cobol program are translated to variable names which are unrelated to the original Cobol variable names. For example, Cobol variables \u201ctotal-amount\u201d, \u201cfinal-value\u201d and \u201cbalance\u201d may be translated to C variables such as \u201ca5\u201d, \u201ca6\u201d and \u201ca7\u201d respectively. This does not affect the functionality of the executable output, because the internal variable names used in describing an application program or any computer program in Cobol (or any other language) are typically invisible to the actual user of that application program. However, parallelization oftentimes requires detailed study and analysis of the variables within a program, both during a first step of designing and describing proposed parallelization, and also in debugging an application in which parallelization may not be producing expected results. It is a significant improvement to provide variable names which are readily understood by the programmer with reference to the original Cobol variable names rather than creating and utilizing \u201ccomputer generated\u201d names which make little sense at first glance.","Continuing with a discussion of variables and variable names, the word \u201cscope\u201d is typically used as a general term describing the visibility or accessibility to a variable in a program. For example, an index variable in a program loop may or may not be \u201cvisible\u201d outside the code of the loop itself. In attempting parallelization, it is often important to analyze a variable's scope, for example, when multiple threads may either share or make private certain specified variables when the code referencing those variables is to be executed by multiple threads. Tools for analyzing variables by name are available, one example being a tool called \u201cThreadChecker\u201d available from Intel Corporation.","As a second example, the Cobol language typically provides for variable types which exist statically in memory. That is, Cobol variables which are visible only inside a subroutine are typically not created on entry to the subroutine and then released upon exit from the subroutine. This simplistic approach is both good and bad in that it may require more memory to \u201cpersist\u201d or always keep static variables in memory, but less time is taken in creating and releasing variables on a memory stack. With modern hardware, memory stacks are often accommodated quite efficiently with hardware support for a stack approach, so the benefits or disadvantages of not utilizing a stack are not necessarily predictable; it depends on the specifics of the program itself. For parallelization, a stack approach may be preferable because variables that are used only within a parallelized region can be created as threads are created and these variables are then automatically isolated from each other (between threads). Standard translation of Cobol to C as, in the manner of OpenCobol, does not provide for this alteration in variable scope and\/or type.","As a third example, variables in Cobol which are independently named may be translated into variables which are simply references to locations in memory or an array in memory. For example, Cobol variables \u201cX\u201d, \u201cY\u201d, and \u201cZ\u201d may be translated to references to array locations \u201cARRINT[122]\u201d, \u201cARRINT [125]\u201d and \u201cARRINT[321]\u201d. This choice prevents a programmer from choosing parallelization which keeps \u201cX\u201d in static memory, for example, and which would put \u201cY\u201d in private stacked memory because the C programming language does not allow one location in an array to be defined with a different memory management type than another location in the same array.","A fourth example regards optimization typically done by standard compilers to provide for more efficient (faster) execution. Optimization by a compiler may combine the processing of several statements into one piece of generated machine code. Optimization may also move code in and out of loops if the compiler\/optimizer decides that is both beneficial and still correct. There are many types of optimization. For parallelism to succeed however, optimization cannot be applied across the boundaries defined for parallelization. For example, initialization of a variable which is described inside a PERFORM block of Cobol code might be moved outside the PERFORM block and done instead just prior to entering the PERFORM code, if the compiler determines that will still result in correct operation. However, when \u201cparallelized\u201d, it might be a requirement for correct operation to retain initialization within every thread of execution utilized in parallelizing a PERFORM statement. Therefore, the translator should be prevented from making certain optimizations which \u201ccross\u201d parallelization boundaries.","A fifth example is the choice of constructs chosen for use in the translation of Cobol source code to another language. For example, a \u201cPERFORM VARYING\u201d construct in Cobol might in the prior art be translated \u201ccorrectly\u201d to C code which might implement the checking for completion of the loop using a C \u201cWHILE\u201d construct. However, although functionally correct, a C \u201cWHILE\u201d construct is not supported for parallelization by OpenMP. Another approach may be to break down a PERFORM statement into a more primitive form in a second language and express the functionality of the PERFORM using simple compute statements and IF statements. For example, a PERFORM n TIMES in Cobol could be translated into a series of statements in the C\/C++ language such as:",{"@attributes":{"id":"p-0099","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"index = 0;"]},{"entry":[{},"LOOP:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IF( index < n ) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"process body of perform;"]},{"entry":[{},"index = index + 1;"]},{"entry":[{},"goto Loop;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else . . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},". . . proceed with following code . . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Another more complex example is illustrated with the Cobol same \u201cPERFORM n TIMES\u201d construct. This construct causes looping of the code a specified number (\u201cn\u201d) times. Outside the loop, and typically just prior to the loop, variables which vary with each pass through the looping code are initialized, and then within the loop, typically at the beginning or end of the loop, these variables are modified. When a construct such as this is parallelized, the code for determining the value of a variable during each pass through the loop is required to be based upon a variable which is related to the pass number for the loop. This may require that a variable be created by the translation program that does not exist within the original Cobol source, and that created variable is used as the basis for determining the value of variables as passes are made through the code by each of a plurality of threads.","Therefore, in order for parallelization to be successful a translation approach is utilized which implements a COBOL \u201cPERFORM n TIMES\u201d using the C\/C++ construct of a C\/C++ \u201cFOR\u201d loop.","Often, it may also be true that it is not until the details of proposed parallelization are analyzed by a programmer that it can be decided precisely which approach to translation will provide the most benefit in terms of enabling parallelization. Therefore it is a further advantage in accomplishing parallelization if the programmer is provided with constructs to \u201csuggest\u201d a proper method of translation. These \u201csuggestions\u201d would probably be implemented as new \u201cpragmas\u201d for influencing the translation process. Of course other methods of providing these guidelines or \u201csuggestions\u201d to the translation process would be readily apparent to one skilled in the art.",{"@attributes":{"id":"p-0103","num":"0111"},"figref":"FIG. 3","b":["101","320","101","330","330","101","330","340","330","350","351","101","350","355"]},"The intermediate C\/C++ program  is then given over for processing by a second compiler  such as the Intel C\/C++ Compiler, which provides for parallelization of programs using OpenMP. The Intel compiler then produces as its output, an Executable Program file  which is an executable that provides for multiple threads of processing when that executable program is executed (run). As mentioned previously, the executable can also be in the form of an \u201cobject\u201d file.","An alternative approach to achieving parallelization in another illustrated embodiment according to the teachings of the present invention is illustrated in . In this illustration, parallelization is achieved by having the first stage Special Compiler  analyze a Cobol Source Program and \u201csuggest\u201d parallelization regions, that is, regions where the special compiler suggests parallelization might be achievable based upon analysis of the Cobol program flow. The special compiler produces a C\/C++ intermediate Program  which includes within it, suggested OpenMP pragmas defining potential or suggested regions of parallelization within the C\/C++ program . The Special Compiler  also optionally produces a report describing in more detail information related to each suggested region of the Parallelization Report . As indicated in block , the programmer can then examine the C\/C++ intermediate Program  and make the selection of parallelization regions for processing by marking that selection in a file . This file  is then processed in a normal manner by the second compiler  to build an output executable  with parallelization. With this approach, the special first compiler serves as an aid to the programmer in looking for and identifying potential regions for parallelization, the special compiler basing its suggestions on analysis of the Cobol program statements and variable declarations.",{"@attributes":{"id":"p-0106","num":"0114"},"figref":["FIG. 5","FIG. 5"],"b":["511","514","520","540"]},{"@attributes":{"id":"p-0107","num":"0115"},"figref":["FIG. 6","FIG. 5","FIG. 6","FIG. 6","FIG. 6"],"b":["601","624","611","619"]},{"@attributes":{"id":"p-0108","num":"0116"},"figref":["FIG. 7","FIG. 7","FIG. 6"],"b":["500","700","700","600","430"]},"In , it can be seen that the prior art compiler generates a \u201cwhile\u201d loop (i.e. shown in reference line ). This while loop could not be parallelized because OpenMP does not support the \u201cwhile\u201d construct.","It can be seen also that an \u201cIF\u201d statement (i.e. shown in reference line ) is used to evaluate the looping variable for exit from the loop. This manner of loop control is also not supported by OpenMP.","It can also be observed that the variable names within the code designated as  reference line  are not related to the variable names used in the Cobol program of . Further, some variables are provided as pointer variables or intermediate pointer variables (i.e. shown in  reference line ). These constructs are not easily maintained in implementing parallelization using OpenMP.","It is also noted that the translation illustrated in  does not provide a human predictable translation of variable names so that parallelization directives which relate to variables specified by Cobol variable names can be easily applied to the C\/C++ code in the generated code.",{"@attributes":{"id":"p-0113","num":"0121"},"figref":["FIG. 7","FIG. 5"],"b":["700","701","732","718","719","725","726","18","718","700","19","719","25","725","26","726","725"]},{"@attributes":{"id":"p-0114","num":"0122"},"figref":["FIG. 8","FIG. 8","FIG. 7","FIG. 8","FIG. 3"],"b":["800","829","802","811","718","719","725","726","813","814","821","815","355"]},{"@attributes":{"id":"p-0115","num":"0123"},"figref":["FIGS. 9A","FIG. 9","FIGS. 10A","FIG. 10","FIG. 11","FIG. 9A","FIG. 9B","FIG. 9C"],"b":["9","9","10","10","900","901","924","925","954","955","970"]},{"@attributes":{"id":"p-0116","num":"0124"},"figref":"FIG. 9A","b":["902","903","904","905","906","924","900","905","911","916","921","906","907","909"]},{"@attributes":{"id":"p-0117","num":"0125"},"figref":["FIGS. 9B and 9C","FIG. 9B","FIG. 9C","FIG. 9C"],"b":["925","900","900","933","938","941","946","949","954","960","965","921"]},{"@attributes":{"id":"p-0118","num":"0126"},"figref":["FIGS. 10A","FIGS. 9A","FIG. 9","FIG. 10"],"b":["10","10","900","9","9","1000"],"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["[ Reference lines -;",{"@attributes":{"id":"ul0010-0002","num":"0128"},"figref":"FIG. 10B","b":["1026","1054"]},{"@attributes":{"id":"ul0010-0003","num":"0129"},"figref":["FIG. 10C","FIG. 10A","FIG. 9A","FIG. 10B","FIG. 9B","FIG. 10C","FIG. 9C","FIGS. 9A"],"b":["1055","1079","9","9"],"br":{}}]}}}},"In , variable declaration statements in the C\/C++ programming language included in reference lines -, -, - are shown which relate to the Working Storage Section of the Cobol source program. Tables A, B, and C are translated from Cobol form to a C \u201cSTRUCT\u201d which contains within it these three tables in the same memory format as would be defined by a normal single pass Cobol compiler (such as MicroFocus Cobol compiler). The variable names are translated in a human predictable manner as in this example from a name such as \u201cTABLE-A\u201d in Cobol reference line  into \u201cTABLE_TABLE_A\u201d in \u201cC\u201d reference line . In similar manner, a \u201cBINARY\u201d type variable in Cobol is translated from \u201cI-BUMP\u201d reference line  into \u201cI_BUMP\u201d in the \u201cC\u201d code reference line . The \u201clevel\u201d or \u201cscope\u201d of the variables declared in the \u201cC\u201d code may be or are dependent on the parallelization directives in the original Cobol source program.","In , and B executable \u201cC\u201d program code of reference lines -, - is illustrated as being produced by translation of the Procedure Division of the original C program, in a manner supportive of the application of parallelization directives, shown for exemplary purposes as being translated into OpenMP style parallelization pragmas.","Within , and C inserted parallelization directives (reference lines     ) are shown illustrating Cobol parallelization directives which are translated by the first compiler into related illustrative OpenMP parallelization directives (reference lines      respectively) which are in the form of pragmas. In the manner and style of OpenMP for \u201cC\u201d, according to the teachings of the present invention, Cobol parallelization directives have been defined which are translated by the first compiler into OpenMP pragmas, and the program code is further translated by a second compiler in a manner that supports the application of the OpenMP pragmas. Within , reference line  illustrates a Cobol parallelization directive, expressed in Cobol comment form (pragma) which is then translated in a related way into an OpenMP pragma as shown in reference lines - in . In similar manner, reference lines -, -, and - in  are translated in a related way into OpenMP pragmas as shown in reference lines -, -, and - respectively in .","It will be noted that the executable \u201cC\u201d code as shown in reference lines , , and  in  are \u201cC\u201d \u201cFOR\u201d statements expressed in a form suitable for application of the preceding OpenMP Pragma statements in reference lines , , and  respectively. Note also that the paired braces (\u201c{ . . . }\u201d) surrounding the \u201cC\u201d code of each \u201cFOR\u201d loop on reference lines -, -, and - in  correspond to the regions of code defined by the corresponding \u201cPERFORM\u201d and \u201cEND-PERFORM\u201d statements in the original Cobol source code, to which the parallelization directives have been applied.",{"@attributes":{"id":"p-0123","num":"0134"},"figref":["FIG. 11","FIG. 9","FIG. 10"],"b":["1101","1127","900","1102","1103","1107","1107","1110","1112","1118","1118","1121","1123"]},{"@attributes":{"id":"p-0124","num":"0135"},"figref":["FIG. 12","FIG. 12"],"b":["1200","1210","1220","1230","1240","1250","1250","1240","1230","1250","1250","1260","1200","1220","1260"]},{"@attributes":{"id":"p-0125","num":"0136"},"figref":"FIG. 13","b":["1310","1320","1320","1330","1310","1330","1340","1340"]},"A User , typically a programmer, selects for inclusion (further processing)  via (for example) a workstation or terminal device, one or more of the regions of potential parallelization. The selection might be made by deleting (or commenting out) parallelization directives that are not selected or selection might be made in many ways readily apparent as could be easily determined by one skilled in the art of programming.","After the selection has been completed, a C\/C++ program file , which includes the selected pragmas presented in a manner so that they will be processed, is applied as input to a standard compiler  such as the GCC or Intel compiler . This compiler  includes the requisite support for generating an executable program  that provides for multiple threads of processing within the executable code, achieving the goal to improve performance of the program over the performance that which would be achieved without parallelism (or without multiple threads of processing). The various files of the overall compilation process are stored on a file storage device(s) such as a disk drive , which are accessed typically through a CPU I\/O System . The overall computer system which includes memory, the I\/O system, file storage space and other hardware can then be used to \u201crun\u201d or execute the resulting executable program. The executable program could also be moved to another computer system for execution or processing. In order to gain significant benefit in performance, CPU hardware which includes multiple cores  is best suited in performing the processing, although improvement with multiple threads might even be possible running on a machine having a single processing unit.",{"@attributes":{"id":"p-0128","num":"0139"},"figref":"FIG. 14","b":["1310","1420","1430","1420","1310","1430","1450","1460","1470"]},"The C\/C++ program , which includes the pragmas, is then presented as input to a standard compiler  such as the GCC or Intel compiler . This compiler  includes the requisite support for generating an executable program  that provides for multiple threads of processing within the executable code, achieving the goal of improving performance of the program over that which would be achieved without parallelism (or without using multiple threads of processing).","The various files of the overall compilation process are stored on a file storage device(s) such as a disk drive , which are accessed typically through a CPU I\/O System . The overall computer system which includes memory, the I\/O system, file storage space and other hardware can then be used to \u201crun\u201d or execute the executable program. The executable program could also be moved to another computer system for execution or processing. In order to gain significant benefit in performance, CPU hardware which includes multiple cores  is best suited in performing the processing, although improvement with multiple threads might even be possible when run on a machine having a single processing unit.",{"@attributes":{"id":"p-0131","num":"0142"},"figref":"FIG. 15","b":["1550","1560","1310","1520","1570","1380"]},"Considering  in greater detail, it is seen that a Cobol Source Program  is annotated by a user , typically a programmer, to form an Annotated Cobol Source Program . The Annotated Cobol Source Program  includes both the original Cobol Source Program code , and designations of potential regions for parallelization within the Cobol program . This Annotated Cobol Source Program  is then translated by a special first compiler , which is another form of a special compiler\/translator program, into a C\/C++ program  (intermediate computer program in a second computer programming language). The translation is performed so that in whatever regions identified as a potential region for parallelization, the annotated Cobol program  is translated so that parallelization directives can be applied to at least those related regions of the intermediate computer program. If analysis by the translator program  determined that this was not possible, an error message could be issued by the translator program as described above.","Then, in the same manner as described in connection with , the intermediate C\/C++ program  including the defined regions for parallelization is run through the Intel or GCC C\/C++ Compiler  producing a multithreaded  program for execution on the computer system that includes a CPU I\/O System , multiple cores for processing  and the appropriate files stored on a disk subsystem .","The techniques described above for providing improvements in parallelization, and other techniques, which may be defined by those skilled in the art, are not necessarily all that is required to achieve any parallelization, but by combining a plurality of techniques according to the teachings of the present invention improves the likeliness of success, that is, the goal of achieving higher performance.","As a further example of the above, the ordering of the program statements in the second language is also important. Compilers oftentimes \u201cmove\u201d or change the order of generated code to provide for efficiencies in execution or other reasons. When contemplating parallelization, it is important that the generated code in the second language be divided and ordered in a predictable way so that the second compiler can apply parallelization without destroying or affecting the overall functionality of the program. Some optimization can be done by the first compiler, but overall program flow between Cobol \u201cparagraphs\u201d is best maintained for success in parallelization. That is, statements can be combined or re-ordered when it makes no difference in the resulting functionality relative to any entry points into a procedure, but re-ordering should not be done across boundaries in the program which are subject to change when parallelization is being considered or implemented.","Describing parallelization in a manner that makes the description available to the second compiler also requires special techniques. In the prior art, parallelization is often described to a compiler using what are called \u201cpragmas\u201d as previously indicated. Pragmas are \u201ccomments\u201d that are optionally interpreted by the compiler which may describe constructs and information not generally provided in the standard computer language. The OpenMP language is based upon the use of pragmas, these pragmas providing for \u201cnormal\u201d single thread compilation if the pragmas are ignored, and providing for parallelism or multi-thread operation in the executable when they are considered by the compiler. Some compilers may choose to ignore some pragmas while providing support for other pragmas.","In providing a two stage approach which supports parallelization according to the teachings of the present invention, an improvement results by providing for processing of the pragmas in the source files of the first language (Cobol) as they are being translated into the second language. First, provision must be made for passing any comments at all from the source files of the Cobol program to the intermediate form. Normally (or typically) comments are ignored by translation programs. That is, comments are simply discarded meaning they are left completely out of the translated code, or they might be maintained in basically the same form as in the original source files. For parallelization to be successful, it is an improvement to provide at least some recognition and processing of comments in the original Cobol source, especially those which can be recognized as being related to parallelization or those which are actual parallelization \u201cpragmas\u201d.","For example, pragmas may reference variable names, the variable names possibly being altered as the translation is made from the first language to the second language. In the prior art, pragmas which are typically \u201cjust\u201d comments, might be ignored, discarded, or left in original form. Providing improved support for parallelization however suggests that any variable names in the pragmas be translated into variable names in the second language in the same manner as variable names are translated in the normal source of the program. In other words, it is an improvement to have the first compiler actually \u201ctranslate\u201d comment statements (pragmas) in the same manner that the normal program statements are translated.","It is also a further improvement to maintain the order of comments, especially those comments recognized as relating to parallelization, relative to the normal Cobol source statements. That is, for example, it is beneficial to maintain a comment statement that describes the next line of the Cobol program as being a parallelizable construct such as a potential \u201cFOR\u201d loop (in the C language) in the same relative location as in the translated intermediate form in order to provide that parallelization description properly to the second compiler.",{"@attributes":{"id":"p-0140","num":"0151"},"figref":["FIG. 16","FIG. 14","FIG. 16","FIG. 16"],"b":["1651","1650","1651","1650","1660","1660","1430","1651","1670"]},"Thus, while the principles of the invention have now been made clear and described relative to a number of illustrative embodiments or implementations, it will be immediately obvious to those skilled in the art the many modifications or adaptations which can be made without departing from those principles. While the invention has been shown and described with reference to specific illustrated embodiments, it should be understood by those skilled in the art that various changes in form and detail may be made such implementations without departing from the spirit and scope of the invention as defined by the following claims.","Having described the preferred embodiments of the invention, it will now become apparent to one of skill in the arts that other embodiments or implementations incorporating the teachings of the present invention may be used. Accordingly, these embodiments should not be limited to the disclosed embodiments or implementations but rather should be limited only by the spirit and scope of the following claims.",{"@attributes":{"id":"p-0143","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"APPENDIX A"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PRIOR ART -"},{"entry":"Complete Program Listing after Translation by Cobol-IT.org Compiler"},{"entry":"of exemplary Cobol program presented in FIGURE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["1","\/* Generated by ","cobc 1.2.10c-standard-64.0 *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2","#include <stdio.h>"]},{"entry":["3","#include <stdlib.h>"]},{"entry":["4","#include <string.h>"]},{"entry":["5","#include <math.h>"]},{"entry":["6","#include <libcob.h>"]},{"entry":["7","\/* Global variables *\/"]},{"entry":["8","\/* Source variables *\/"]},{"entry":["9","#include \u201cmatrix3pCOBOLIT.c.h\u201d"]},{"entry":["10","#include \u201cmatrix3pCOBOLIT.c.d.h\u201d"]},{"entry":["11","static void"]},{"entry":["12","cob_decimal_set_int (cob_decimal *d, const int n)"]},{"entry":["13","{"]},{"entry":["14","\u2003\u2003mpz_set_si (d->value, n);"]},{"entry":["15","\u2003\u2003d->scale =0;"]},{"entry":["16","}"]},{"entry":["17","\/* Function prototypes *\/"]},{"entry":["18","int matrix3P (void);"]},{"entry":["19","int matrix3p (void);"]},{"entry":["20","static int matrix3P_ (const int);"]},{"entry":["21","\/* Functions *\/"]},{"entry":["22","main ( )"]},{"entry":["23","{"]},{"entry":["24","\u2003cob_init(0, NULL); \/\/ <==required for COBOL-IT"]},{"entry":["25","\u2003matrix3P( ); \/\/ <==same name as the cobol program-id"]},{"entry":["26","\u2003return(0);"]},{"entry":["27","}"]},{"entry":["28","int"]},{"entry":["29","matrix3P ( )"]},{"entry":["30","{"]},{"entry":["31","\u2003return matrix3P_ (0);"]},{"entry":["32","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0144","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["33","int"]},{"entry":["34","matrix3p ( )"]},{"entry":["35","{"]},{"entry":["36","\u2003return matrix3P_ (1) ;"]},{"entry":["37","}"]},{"entry":["38","static int"]},{"entry":["39","matrix3P_ (const int entry)"]},{"entry":["40","{"]},{"entry":["41","\u2003\/* Local variables *\/"]},{"entry":["42","\u2003#include \u201cmatrix3pCOBOLIT.c.1.h\u201d"]},{"entry":["43","\u2003static int initialized = 0;"]},{"entry":["44","\u2003signed long long si0;"]},{"entry":["45","\u2003signed long long si1;"]},{"entry":["46","\u2003signed long long si2;"]},{"entry":["47","\u2003signed long long si3;"]},{"entry":["48","\u2003static cob_field *cob_user_parameters [COB_MAX_FIELD_"]},{"entry":[{},"\u2003PARAMS];"]},{"entry":["49","\u2003cob_module module = {NULL, NULL, NULL, NULL, cob_user_"]},{"entry":[{},"\u2003parameters, 0,"]},{"entry":["50","\u2003\u2003\u2003\u2032.\u2032, \u2032$\u2032, \u2032,\u2032, 1, 1, 1, 0, \u201cmatrix3P\u201d, COB_SOURCE_FILE, COB_"]},{"entry":[{},"\u2003\u2003\u2003SOURCE_FILE, 0, 0,"]},{"entry":["51","\u2003\u2003\u2003\u2003NULL, NULL, NULL, 0, NULL, 0};"]},{"entry":["52","\u2003\/* Start of function code *\/"]},{"entry":["53","\u2003\/* CANCEL callback handling *\/"]},{"entry":["54","\u2003if (unlikely(entry < 0)) {"]},{"entry":["55","\u2003\u2003if (!initialized) {"]},{"entry":["56","\u2003\u2003\u2003\u2003return 0;"]},{"entry":["57","\u2003\u2003}"]},{"entry":["58","\u2003\u2003cob_decimal_clear (&d0);"]},{"entry":["59","\u2003\u2003si0 = 0;"]},{"entry":["60","\u2003\u2003cob_decimal_clear (&d1);"]},{"entry":["61","\u2003\u2003si1 = 0;"]},{"entry":["62","\u2003\u2003cob_decimal_clear (&d2);"]},{"entry":["63","\u2003\u2003si2 = 0;"]},{"entry":["64","\u2003\u2003cob_decimal_clear (&d3);"]},{"entry":["65","\u2003\u2003si3 = 0;"]},{"entry":["66","\u2003\u2003initialized = 0;"]},{"entry":["67","\u2003\u2003return 0;"]},{"entry":["68","\u2003}"]},{"entry":["69",{}]},{"entry":["70","\/* Initialize frame stack *\/"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0145","num":"0156"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"char"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["71","frame_ptr = &frame_stack[0];"]},{"entry":["72","frame_ptr->perform_through = 0;"]},{"entry":["73",{}]},{"entry":["74","cob_module_enter(&module);"]},{"entry":["75","if (unlikely(initialized == 0))"]},{"entry":["76","\u2003{"]},{"entry":["77","\u2003\u2003if (!cob_initialized) {"]},{"entry":["78","\u2003\u2003\u2003cob_fatal_error (COB_FERROR_INITIALIZED);"]},{"entry":["79","\u2003\u2003}"]},{"entry":["80","\u2003\u2003cob_check_version (COB_SOURCE_FILE, "]},{"entry":[{},"\u2003\u2003COB_PACKAGE_VERSION, COB_PATCH_LEVEL);"]},{"entry":["81","\u2003\u2003cob_set_cancel ((const char *) \u201cmatrix3P\u201d, (void *), matrix3P, "]},{"entry":[{},"\u2003\u2003(void *)matrix3P_);"]},{"entry":["82","\u2003\u2003\/* Initialize decimal numbers *\/"]},{"entry":["83","\u2003\u2003cob_decimal_init (&d0);"]},{"entry":["84","\u2003\u2003si0 =0;"]},{"entry":["85","\u2003\u2003cob_decimal_init (&d1);"]},{"entry":["86","\u2003\u2003si1 =0;"]},{"entry":["87","\u2003\u2003cob_decimal_init (&d2);"]},{"entry":["88","\u2003\u2003si2 =0;"]},{"entry":["89","\u2003\u2003cob_decimal_init (&d3);"]},{"entry":["90","\u2003\u2003si3 =0;"]},{"entry":["91","\u2003\u2003(*(int *) (b_1)) = 0;"]},{"entry":["92","\u2003\u2003memset (b_5, 0, 4);"]},{"entry":["93","\u2003\u2003memset (b_6, 0, 4);"]},{"entry":["94","\u2003\u2003memset (b_7, 0, 4);"]},{"entry":["95","\u2003\u2003memset (b_8, 0, 4);"]},{"entry":["96","\u2003\u2003memset (b_9, 0, 4);"]},{"entry":["97","\u2003\u2003memset (b_10, 0, 4);"]},{"entry":["98","\u2003\u2003for (i1 = 1; i1 <= 200; i1 ++)"]},{"entry":["99","\u2003\u2003\u2003{"]},{"entry":["100","\u2003\u2003\u2003\u2003for (i2 = 1; i2 <= 5000; i2++)"]},{"entry":["101","\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["102","\u2003\u2003\u2003\u2003\u2003\u2003(float temp = 0.0; memcpy (b_11 + 4 * (i2 \u2212 1) +"]},{"entry":["103","\u2003\u2003\u2003\u2003\u2003\u200320000 * (i1 \u2212 1), (char *)&temp, sizeof(temp));}"]},{"entry":["104","\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["105","\u2003\u2003\u2003}"]},{"entry":["106","\u2003\u2003for (i1 = 1; i1 <= 200; i1++)"]},{"entry":["107","\u2003\u2003\u2003{"]},{"entry":["108","\u2003\u2003\u2003\u2003for (i2 = 1; i2 <= 5000; i2++)"]},{"entry":["109","\u2003\u2003\u2003\u2003\u2003{"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0146","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["110","\u2003\u2003\u2003\u2003\u2003\u2003(float temp = 0.,0; memcpy (b_15 + 4 * (i2 \u2212 1)"]},{"entry":["111","\u2003\u2003\u2003\u2003\u2003\u2003+ 20000 * (i1 \u2212 1), (char *)&temp, sizeof(temp));}"]},{"entry":["112","\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["113","\u2003\u2003\u2003}"]},{"entry":["114","\u2003\u2003for (i1 = 1; i1 <= 200; i1++)"]},{"entry":["115","\u2003\u2003\u2003{"]},{"entry":["116","\u2003\u2003\u2003\u2003for (i2 = 1; i2 <= 5000; i2++)"]},{"entry":["117","\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["118","\u2003\u2003\u2003\u2003\u2003\u2003{float temp = 0.0; memcpy (b_19 + 4 * (i2 \u2212 1) +"]},{"entry":["119","\u2003\u2003\u2003\u2003\u2003\u2003\u200320000 * (i1 \u2212 1), (char *)&temp, sizeof(temp));}"]},{"entry":["120","\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["121","\u2003\u2003\u2003}"]},{"entry":["122","\u2003\u2003initialized = 1;"]},{"entry":["123","\u2003}"]},{"entry":["124","cob_save_call_params = cob_call_params;"]},{"entry":["125","\/* Entry dispatch *\/"]},{"entry":["126","switch (entry)"]},{"entry":["127","{"]},{"entry":["128","\u2003case 0:"]},{"entry":["129","\u2003\u2003goto 1_2;"]},{"entry":["130","\u2003case 1:"]},{"entry":["131","\u2003\u2003goto 1_3;"]},{"entry":["132","\u2003}"]},{"entry":["133","\/* This should never be reached *\/"]},{"entry":["134","cob_fatal_error (COB_FERROR_CHAINING);"]},{"entry":["135",{}]},{"entry":["136",{}]},{"entry":["137","\/* PROCEDURE DIVISION *\/"]},{"entry":["138","\/* Entry matrix3P *\/"]},{"entry":["139","1_2:;"]},{"entry":["140","\/* Entry matrix3P *\/"]},{"entry":["141","1_3:;"]},{"entry":["142","\/* MAIN SECTION *\/"]},{"entry":["143","\/* matrixCBL-start *\/"]},{"entry":["144","f"]},{"entry":["145","\u2003cob_display (0, 1, 1, &c_1);"]},{"entry":["146","}"]},{"entry":["147","{"]},{"entry":["148","\u2003cob_setswp_s32_binary (b_7, 1);"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0147","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["149","\u2003\u2003while (1)"]},{"entry":["150","\u2003\u2003\u2003{"]},{"entry":["151","\u2003\u2003\u2003\u2003if (((int) cob_cmpswp_s32_binary (b_7, 200) == 0))"]},{"entry":["152","\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["153","\u2003\u2003\u2003{ \u2003{"]},{"entry":["154","\u2003\u2003\u2003\u2003\u2003cob setswp s32_binary (b_5, 1);"]},{"entry":["155","\u2003\u2003\u2003\u2003\u2003\u2003while (1)"]},{"entry":["156","\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["157","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (((int)cob_cmpswp_s32_binary (b_5, 200) > 0))"]},{"entry":["158","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["159","\u2003\u2003\u2003\u2003\u2003\u2003\u2003{ \u2003{"]},{"entry":["160","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003cob_setswp_s32 binary (b_6, 1);"]},{"entry":["161","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003while (1)"]},{"entry":["162","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["163","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (((int) cob_cmpswp_s32_binary (b_6, "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20035000) > 0))"]},{"entry":["164","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["165","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["166","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["167","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["168","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["169","cob_ decimal_set_int (&d0, ((int)COB_BSWAP_32 (*(int *) (b_5))));"]},{"entry":["170 ","cob_decimal_set_int (&d1, ((int)COB_BSWAP_32 (*(int *) (b_6))));"]},{"entry":["171","cob_decimal_add (&d0, &d1);"]},{"entry":["172","cob_decimal_get_field (&d0, (f0.size = 4, f0.data ="]},{"entry":["173","\u2003b_11 + 4 * (((int)COB_BSWAP_32(*(int *) (b_6))) \u2212 1) +"]},{"entry":["174","\u200320000 * (((int)COB_BWAP_32(*(int *) (b_5))) \u2212 1), f0.attr = "]},{"entry":[{},"&a_2, &f0), 4);"]},{"entry":["175","\u2003\u2003}\u2003 } \u2003} \u2003}"]},{"entry":["176","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_6, 1);"]},{"entry":["177","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["178","\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["179","\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["180","\u2003\u2003\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_5, 1);"]},{"entry":["181","\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["182","\u2003\u2003\u2003}"]},{"entry":["183","\u2003\u2003\u2003{"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0148","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["184","\u2003\u2003\u2003cob_setswp_s32_binary (b_5, 1);"]},{"entry":["185","\u2003\u2003\u2003\u2003while (1)"]},{"entry":["186","\u2003\u2003\u2003\u2003{"]},{"entry":["187","\u2003\u2003\u2003\u2003\u2003if (((int) cob_cmpswp_s32_binary (b_5, 200) > 0))"]},{"entry":["188","\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["189","\u2003\u2003\u2003\u2003{"]},{"entry":["190","\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["191","\u2003\u2003\u2003\u2003\u2003\u2003cob_setswp_s32_binary (b_6, 1);"]},{"entry":["192","\u2003\u2003\u2003\u2003\u2003\u2003\u2003while (1)"]},{"entry":["193","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["194","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (((int) cob_cmpswp_s32_binary (b_6, 5000) > 0))"]},{"entry":["195","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["196","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{ { { {"]},{"entry":["197","cob_decimal_set_int (&d0 , ((int) COB_BSWAP_32 (* (int *) (b_5))));"]},{"entry":["198","cob_decimal_set_int (&d1, ((int) COB_BSWAP_32(* (int *) (b_6) )));"]},{"entry":["199","cob_decimal_add ( &d0 , &d1) ;"]},{"entry":["200","cob_decimal_get_field (&d0, (f 0 . size = 4, f 0 . data ="]},{"entry":["201","\u2003b_15 + 4 * (((int) COB_BSWAP_32 (* (int *) (b_6))) \u2212 1) +"]},{"entry":["202","\u200320000 * (((int) COB_BSWAP_32 (* (int *) (b_5 ))) \u2212 1) , f0. attr = &a_"]},{"entry":[{},"\u20032, &f0 ) , 4);"]},{"entry":["203","\u2003} } } }"]},{"entry":["204","\u2003\u2003\u2003\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_6, 1);"]},{"entry":["205","\u2003\u2003\u2003\u2003\u2003\u2003} } }"]},{"entry":["206","\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_5, 1);"]},{"entry":["207","\u2003\u2003\u2003\u2003} }"]},{"entry":["208","\u2003\u2003{"]},{"entry":["209","\u2003\u2003\u2003cob_setswp_s32_binary (b_5, 1);"]},{"entry":["210","\u2003\u2003\u2003\u2003while (1)"]},{"entry":["211","\u2003\u2003\u2003\u2003{"]},{"entry":["212","\u2003\u2003\u2003\u2003\u2003\u2003if (((int) cob_cmpswp_s32_binary (b_5, 200) > 0) )"]},{"entry":["213","\u2003\u2003\u2003\u2003\u2003\u2003\u2003break ;"]},{"entry":["214","\u2003\u2003\u2003\u2003{"]},{"entry":["215","\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["216","\u2003\u2003\u2003\u2003\u2003\u2003cob_setswp_s32_binary (b_6, 1);"]},{"entry":["217","\u2003\u2003\u2003\u2003\u2003\u2003\u2003while (1)"]},{"entry":["218","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0149","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["219","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (((int) cob_cmpswp_s32_binary (b_6, "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20035000) > 0))"]},{"entry":["220","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["221","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{ { { {"]},{"entry":["222","cob_decimal_set_int (&d0, 0);"]},{"entry":["223","cob_decimal_get_field (&d0, (f0.size = 4, f0.data ="]},{"entry":["224","\u2003b_19 + 4 * (((int)COB_BSWAP_32(*(int *)(1, 6))) \u2212 1) +"]},{"entry":["225","\u200320000 * (((int) *) \u2212 1), f0.attr = &a_2, &f0) , 4);"]},{"entry":["226","} } } }"]},{"entry":["227","\u2003\u2003\u2003\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_6, 1);"]},{"entry":["228","\u2003\u2003\u2003\u2003\u2003\u2003} } }"]},{"entry":["229","\u2003\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_5, 1);"]},{"entry":["230","\u2003\u2003\u2003\u2003} }"]},{"entry":["231","\u2003\u2003{"]},{"entry":["232","\u2003\u2003\u2003cob_setswp_s32_binary (b_5, 1);"]},{"entry":["233","\u2003\u2003\u2003\u2003while (1)"]},{"entry":["234","\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["235","\u2003\u2003\u2003\u2003\u2003\u2003if (((int)cob_cmpswp_s32_binary (b_5, 200) > 0))"]},{"entry":["236","\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["237","\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["238","\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["239","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003cob_setswp_s32_binary (b_6, 1);"]},{"entry":["240","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003while (1)"]},{"entry":["241","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":["242","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (((int)cob_cmpswp_s32_binary (b_6, "]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20035000) > 0))"]},{"entry":["243","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":["244","\u2003{ { { {"]},{"entry":["245","cob_decimal_field (&d0, (f0.size = 4, f0.data ="]},{"entry":["246","\u2003b_11 + 4 * (((int)COB_BSWAP_32(*(int *)(b_6))) \u2212 1) +"]},{"entry":["247","\u200320000 * (((int)COB_BSWAP_32(*(int *) (b_5))) \u2212 1), f0.attr = "]},{"entry":[{},"\u2003&a_2, &f0));"]},{"entry":["248","cob_decimal_set_field (&d3, (f0.size = 4, f0.data ="]},{"entry":["249","\u2003b_15 + 4 * (((int)COB_BSWAP_32(*(int *) (b_6))) \u2212 1) +"]},{"entry":["250","\u20032000 * (((int)COB_BSWAP_32 (*(int *) (b_5))) \u2212 1), f0.attr = "]},{"entry":[{},"\u2003&a_2, &f0));"]},{"entry":["251","cob_decimal_add (&d0, &d3);"]},{"entry":["252","cob_decimal_set_field (&d2, cob_intr_sin ((f0.size = 4, f0.data ="]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0150","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["253","\u2003b_11 + 4 * (((int)COB_BSWAP_32(*(int *) (b_6)) \u2212 1) + "]},{"entry":["254","\u200320000 * (((int)COB_BSWAP_32(*(int *) (b_5)));"]},{"entry":["255","\u2003\u2003\u2003\u2003\u2003\u2003cob_decimal_add (&d0, &d2); "]},{"entry":["256","cob_decimal_set_field (&d1, cob_intr_cos ((f0.size = 4, f0.data ="]},{"entry":["257","\u2003b_15 + 4 * (((int)COB_BSWAP_32(*(int *) (b_6))) \u2212 1) +"]},{"entry":["258","\u200320000 * (((int)COB_BSWAP_32(*(int *)(b 5))) \u2212 1), f0.attr = "]},{"entry":[{},"\u2003&a 2, &f0)));"]},{"entry":["259","\u2003\u2003\u2003\u2003\u2003\u2003cob_decimal_ add (&d0, &d1);"]},{"entry":["260","cob_decimal_get_field (&d0, (f0.size = 4, i.data ="]},{"entry":["261","\u2003b_19 + 4 * (((int)COB_BSWAP_32(*(int *) (b_6))) \u2212 1) +"]},{"entry":["262","\u200320000 * (((int)COB_BSWAP_32(*(int *)(b_5))) \u2212 1), f0.attr = "]},{"entry":[{},"\u2003&a_2, &f0), 4);"]},{"entry":["263","\u2003\u2003} } } }"]},{"entry":["264","\u2003\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_6, 1);"]},{"entry":["265","\u2003\u2003} } }"]},{"entry":["266","\u2003\u2003\u2003\u2003cob_addswp_s32_binary (b_5, 1);"]},{"entry":["267","\u2003\u2003} } }"]},{"entry":["268","cob_addswp_s32 binary (b 7, 1);"]},{"entry":["269","\u2003\u2003} } \/* END-PROGRAM *\/"]},{"entry":["270","{ cob_display (0, 1, 2, &c_2, (f0.size = 4, f0.data ="]},{"entry":["271","\u2003\u2003\u2003b_19 + 4 * 4998 + 20000 * 198, f0.attr = &a_2, &f0)); }"]},{"entry":["272","\u2003\u2003{ cob_display (0, 1, 1, &c_3); }"]},{"entry":["273","\u2003\u2003{ cob_stop_run ((*(int *) (b_1))); }"]},{"entry":["274","\u2003\u2003\/* Program exit *\/"]},{"entry":["275","\u2003\u2003\/* Pop module stack *\/"]},{"entry":["276","\u2003\u2003cob_module_leave (&module);"]},{"entry":["277","\u2003\u2003\/* Program return *\/"]},{"entry":["278","\u2003\u2003return (*(int *) (b_1));"]},{"entry":["279","} \/* End functions *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"280"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The subject matter of the invention is particularly pointed out and distinctly claimed in the concluding portion of the specification. The invention, however, both as to organization and method of operation, may better be understood by reference to the following description taken in conjunction with the subjoined claims and the accompanying drawings in which:",{"@attributes":{"id":"p-0047","num":"0053"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0048","num":"0054"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0049","num":"0055"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0050","num":"0056"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0051","num":"0057"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0052","num":"0058"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0053","num":"0059"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0054","num":"0060"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0055","num":"0061"},"figref":["FIGS. 9A","FIGS. 9A","FIG. 9"],"b":["9","9","9","9"]},{"@attributes":{"id":"p-0056","num":"0062"},"figref":["FIGS. 10A","FIGS. 10A","FIG. 10","FIGS. 9A"],"b":["10","10","10","10","9","9"]},{"@attributes":{"id":"p-0057","num":"0063"},"figref":["FIG. 11","FIG. 9"]},{"@attributes":{"id":"p-0058","num":"0064"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0059","num":"0065"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0060","num":"0066"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0061","num":"0067"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0062","num":"0068"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
