---
title: Method and system for object-oriented management of multi-dimensional data
abstract: Methods and systems for managing and analyzing multi-dimensional data are provided. Example embodiments provide a Meta-Object Data Management System “MODMS,” which enables users to arrange and to rearrange hierarchical relationships of the data on an ad-hoc basis and allows the data to be analyzed using any set of attributes (dimensions) while the system is running. The MODMS represents heterogeneous data in a normalized (standardized) fashion using an object type management system that allows the arbitrary coercion of one type of object into another different type of object and automatically resolves attribute dependencies. In one embodiment, the MODMS comprises an object type management subsystem; a meta-object instantiation subsystem; one or more data repositories; and an input/output interface. These components cooperate to allow the creation, management, and analysis of relationships between many different types of single and multi-dimensional data. The MODMS may be used to implement an enterprise portfolio management system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07853508&OS=07853508&RS=07853508
owner: Serena Software, Inc.
number: 07853508
owner_city: Redwood City
owner_country: US
publication_date: 20030703
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention relates to methods and systems for managing multi-dimensional data and, in particular, to methods and systems for creating, maintaining, and analyzing portfolios of multi-dimensional data, such as project, asset, and product investments, using an object-oriented paradigm.","2. Background Information","Today's companies, institutions, and other organizations are plagued by the vast amount of data which is now stored electronically and often needs to be analyzed by a variety of persons within the organization relative to business or organizational goals. The need to determine efficiently what data is available for analysis and how to analyze disparate data across organizational management boundaries is an ever-increasing problem as the data being tracked increases and as organizations implement more specialized or distributed functions. Managers, executives, employees, and other personnel, each with possibly differing needs for particular content and detail, need to analyze how different changes might effect the projects, products, resources, finances, and assets that each are responsible for. Rapid planning cycles, optimizing the use of critical resources, eliminating low value, non-strategic, redundant, and poorly performing assets and projects, and real time visibility of results are common goals in today's organizations.","The idea of \u201cportfolio management\u201d has evolved within such organizations as a way to emphasize that all assets of an organization, be they financial, human, equipment resources, human resources or other assets, require management and oversight in the same manner as traditional investments such as real property, commercial paper, and equity investments. Managing a group of assets as a portfolio encourages decision makers to view the member investments as a whole but also be able to analyze and scrutinize each discrete investment. Portfolio-based management of IT assets, such as technology investments, has become a popular example of applying portfolio management in a modern day organization. With portfolio-based management, IT information such as inventory lists, spreadsheets, and project management data are managed as assets that need to be analyzed as to how well they are meeting IT and organizational level objectives.","Traditionally, discrete systems have been developed to handle the data management and analysis needs of various entities within an organization. This phenomenon has grown out of the situation that the data for each entity is typically stored in its own subsystem and analysis tools have been developed that are targeted for the specific needs of that entity. Thus, to date, portfolio management systems have been created to separately manage each type of investment. For example, extensive financial management and analysis systems have been developed and used to analyze the financial assets of an organization such as stocks, bonds, and other commercial paper. Classically, the data for these systems is stored in a variety of (typically) relational data base management systems (RDBMS) so that queries can be executed to gain historical insight into the data. \u201cWhat-if\u201d scenarios are often handled by separate analysis packages that are specific to the type of data being analyzed and the type of analysis conducted. On-line analysis processing packages (OLAP packages) have been developed to support such \u201cwhat-if\u201d analysis with data that have a large number of axes\/variables (often referred to as multi-dimensioned data). For example, an inventory control system of a geographical distributed company may have resource data that can be viewed, analyzed, and sorted by geographic location, region, type of resource, date placed in operation, organization, responsible party, etc. An OLAP package attempts to collect and store such data according to how the data is expected be analyzed so as to optimize analysis efficiency (by reducing search times). In order to analyze the same data according to different views, the system is taken off-line and the data structures are recalculated to prepare for additional analysis. This can be a very time consuming and burdensome process if the data set is very large, as is typical.","Similarly, to handle project management, separate project management and analysis systems have been developed to aid managers and other executives in the project planning and execution lifecycles of projects within an organization. For example, there are systems that offer extensive milestone, critical path, and resource analysis for organization data that can be defined as a project. There exist tools today that allow a group of projects to be viewed as \u201cinvestments\u201d within a portfolio. These tools provide a way for project managers and other executives within an organization to analyze the costs and benefits of such projects in a similar manner to how financial analysts analyze financial investments.","Embodiments of the present invention provide enhanced computer- and network-based methods and systems for managing and analyzing multi-dimensional data. Multi-dimensional data is data having a large plurality of attributes, such as data found in enterprise management systems. Example embodiments provide a Meta-Object Data Management System (\u201cMODMS\u201d), which enables users to arrange and to rearrange the hierarchical relationships of the data on an ad-hoc basis so that the data may be analyzed using any set of attributes (dimensions) while the system is running. The MODMS stores heterogeneous data in a normalized (standardized) fashion using an object type management system, which allows the arbitrary coercion of one type of object into another different type of object and automatically resolves attribute dependencies. The arbitrary coercion of one type of object into another different type of object permits and supports a system whereby any type of investment can be contained within any other type of investment, so investments can be moved within and across portfolios at will.","The Meta-Object Data Management System provides techniques for creating, managing, and analyzing relationships between, typically, heterogeneous, multi-dimensional data. In one example embodiment, the Meta-Object Data Management System comprises one or more functional components\/modules that work together to implement an enterprise portfolio management system.","According to one approach, a Meta-Object Data Management System comprises an object type management subsystem, a meta-object instantiation subsystem, one or more data repositories that hold the data used to populate objects and object type definitions (for whatever other data is being managed), and an input\/output interface. For example, the data repositories may store the financial investment data and the project management (investment) data of the enterprise. The object type management subsystem is used to define objects that correspond to the various data types (e.g., investment types) that will be created and managed by the MODMS. The meta-object instantiation subsystem is used to create instances of object types defined by the object type management system. The input\/output interface represents any interface to the components of the MODMS and make take the form of a user command interface or a programmatic interface, such as an application programming interface definition.","In one aspect, each meta-object comprises an object identifier, an object type, and an attribute block. In another aspect, each object type is a collection of attributes defined from a global attributes data structure. An object type definition can be dynamically and automatically changed, by modifying one of the global attributes associated with that object type. When an object type definition is changed, the MODMS automatically adjusts each instantiated meta-object that is associated with that object type without recompiling or recreating the meta-objects. In yet another aspect, meta-objects do not obey traditional inheritance rules, and thus each meta-object can be type cast into a different object type. In another aspect, an attribute block stores all of the attribute values for a single meta-object. Each attribute value is stored between a beginning attribute tag and an ending attribute tag that identifies the attribute. The attribute tag-value pairs are stored in a serialized single variable within the meta-object. In one of these aspects, the tags are XML tags.","In another aspect, multi-dimensional views of the data can be dynamically created through the use of datasheets. A datasheet attribute specification is defined, and a corresponding datasheet is computed based upon the object instance associated with the datasheet. When datasheets are moved and copied to different locations, their resultant data and presentation is automatically adjusted for the new location. In one of these aspects, a datasheet is represented using a virtual object tree. A virtual object is generated for each grouping of data that matches a discrete combination of values of the attributes identified by the datasheet attribute specification. Then, a virtual object is generated for each specified group of groups, until all groupings and sub-groupings have been associated with virtual objects.","In yet another aspect, charts that represent multi-dimensional views of the data can also be dynamically created. Each chart is associated with a datasheet and the structure of the chart can automatically reflect the dimensions of the datasheet, or be manually controlled. Once a chart structure has been created, the presentation displayed by the chart structure can be automatically modified by selecting a different axis of the data to be presented. The resulting chart is then automatically populated using values of the underlying datasheet.","According to another approach, a portfolio management system is created using the MODMS. The portfolio management system comprises a portfolio manager for instantiating meta-objects to correspond to portfolio data and a portfolio analyzer for displaying instantiated meta-objects whose attribute values match an attribute specification.","In an example portfolio management system, heterogeneous investment data, for example financial investments and project management resource investments are managed and analyzed using a single abstraction, a meta-object. In addition, each investment data item can be converted to a different type of investment data item without reentering the original data. Investment data can be dynamically organized within other investment data irrespective of the type of investment data.","All of these approaches and aspects and other approaches and aspects are supported by the methods and systems of a Meta-Object Data Management System.","Embodiments of the present invention provide enhanced computer- and network-based methods and systems for managing and analyzing multi-dimensional data. Multi-dimensional data is data having a large plurality of attributes, such as data found in enterprise management systems. Example embodiments provide a Meta-Object Data Management System (\u201cMODMS\u201d), which enables users to arrange and to rearrange the hierarchical relationships of the data on an ad-hoc basis and allows the data to be analyzed using any set of attributes (dimensions) while the system is running. Thus, analysis of the data can appear to occur concurrently with transactions on the underlying data. The MODMS represents heterogeneous data in a normalized (standardized) fashion using an object type management system that allows the arbitrary coercion of one type of object into another different type of object and automatically resolves attribute dependencies. Attribute dependencies occur when the values of attributes of one object are calculated or dependent upon attribute values of another object. Such dependencies are useful in portfolio management applications where, for example, values that correspond to a cost attribute of multiple investment line items are aggregated (rolled-up) into a summary line item that represents the cost attribute of the portfolio as a whole. The arbitrary coercion of one type of object into another different type of object permits and supports a system whereby any type of object can be contained within any other type of object, so, for example, investments in a portfolio management system can be moved within and across portfolios at will.","The Meta-Object Data Management System provides techniques for creating, managing, and analyzing relationships between, typically heterogeneous, multi-dimensional data. In one example embodiment, the Meta-Object Data Management System comprises one or more functional components\/modules that work together to implement an enterprise portfolio management system. One skilled in the art will recognize, however, that the techniques of a MODMS may be used for the creation, management, and analysis of relationships between many different types of single and multi-dimensional data, and is not limited to use with portfolio management.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1","b":["101","102","103","104","105","103","104","101","102","101","105"]},"More specifically, the object type management subsystem  defines and manages global attributes and creates and manage object type definitions, which are each a collection of one or more global attributes. An excerpt from an example set of global attribute definitions for an example enterprise portfolio management system is attached as Appendix B, which is herein incorporated by reference in its entirety. Example global attributes may include characteristics of the data to be stored and analyzed such as a description, cost to date, tangible benefits, intangible benefits, etc., or any other definable characteristic whose value can be specified. Global attributes can be added, deleted, and modified while the MODMS is running. Once an object type definition is created, its collection of attributes can be adjusted. For example, attributes can be added to or deleted from an object type definition. Further, when an attribute definition is adjusted, any changes are percolated throughout the object type definitions that include that attribute.","The meta-object instantiation subsystem  supports the creation of instances of objects that are defined by the object type management system . The meta-object instantiation subsystem  implements an abstraction of a \u201chigher level\u201d object, known as a meta-object, that is not tied to a particular object type, but rather implements a broader object concept that is used to unify the creation and management of all object types that correspond to user data. For example, within a portfolio management system, a meta-object is instantiated (created) to correspond to each \u201cinvestment\u201d type in the system, including, for example, portfolios, projects, products, financial assets, equipment, initiatives, operations, applications, processes, activities, human resources, other resources, other assets, etc. A representation of a hierarchy of investments is created based upon the relationships desired between investments by instantiating a meta-object that corresponds to one investment as a child of another meta-object that corresponds to another investment. The object type definitions themselves do not define the containment or inheritance relationships as common in other object-oriented systems. Rather, the containment hierarchy of instantiated meta-objects defines the relationships between the investments. Once meta-objects are instantiated, they can be moved, copied, deleted, and their attributes changed. When a meta-object is moved or copied, the attribute values of the original parent meta-object instance and the new parent meta-object instance that are dependent upon children meta-object instances are automatically adjusted (rolled up) to reflect the new containment structure. Thus, for example, when an instantiated investment object is moved to a new portfolio, the attributes of the original parent portfolio and the new parent portfolio are automatically recomputed. Similarly, when an object type definition is changed, instantiated meta-objects of the modified object type are automatically adjusted to reflect changes to the object type definition. Thus, for example, if the definition of a human resource object type is changed to add an \u201cage\u201d characteristic, then instances of human resource objects already created by the meta-object instantiation system  are automatically updated to include an \u201cage\u201d attribute with a default value.","In addition to defining representations for types of objects and for managing the data associated with them, the MODMS supports the concurrent analysis of data (e.g., investment data) through the use of datasheets. A datasheet is a multi-dimensional view of the underlying instance hierarchy based upon a datasheet attribute specification (e.g., a property sheet). For example, a new multi-dimensional view of the portfolio investment hierarchy can be formed dynamically by instantiating a new datasheet based upon specified properties. In one embodiment, the datasheet properties (the attribute specification) specify axes (data columns of interest), grouping, sorting, and filtering. A corresponding datasheet is then determined (calculated) by the system and displayed. Once a datasheet is generated, its properties can be adjusted, thereby causing an automatic adjustment and recalculation of the resultant datasheet. In one example embodiment, a datasheet is associated with a particular meta-object in the instance hierarchy and relates to the objects within that sub-tree of the containment hierarchy. A datasheet (or more precisely, its attribute specification) can be deleted, moved, or copied, thereby automatically causing adjustments to be made to the resultant datasheet dependant upon revised location and adjustments to be made to the associated meta-object if applicable.","Although the techniques of a Meta-Object Data Management System are generally applicable to any type of investment, the terms \u201cinvestment\u201d and \u201casset\u201d are used generally to imply any type of data having one or more attributes whose cost or benefit can be assessed. One skilled in the art will recognize that an investment is not limited to traditional investment types such as real property, commercial paper, and equity investments. Rather, a MODMS can be used to support the creation, management, and analysis of any type of data object, whether commonly considered an \u201cinvestment\u201d or not.","Also, although the examples described herein often refer to portfolio management and enterprise portfolio management, one skilled in the art will recognize that the subsystems (components) of a MODMS are defined generically and that the techniques of the present invention can also be used in any system that desires to create and manage different types of data objects whose relationships to each other may change over time. In addition, the concepts and techniques described are applicable to other data management systems, including other types of applications that use data repositories to store related information, for example, inventory control systems, product databases, manufacturing systems, corporate finances, etc. Essentially, the concepts and techniques described are applicable to any data management environment. In the following description, numerous specific details are set forth, such as data formats and code sequences, etc., in order to provide a thorough understanding of the techniques of the methods and systems of the present invention. One skilled in the art will recognize, however, that the present invention also can be practiced without some of the specific details described herein, or with other specific details, such as changes with respect to the ordering of the code flow.","In addition, although certain terms are used primarily herein, one skilled in the art will recognize that other terms could be used interchangeably to yield equivalent embodiments and examples. For example, it is well known that equivalent terms could be substituted for such terms as \u201cobject,\u201d \u201cattribute,\u201d \u201cdimension,\u201d etc. In addition, terms may have alternate spellings which may or may not be explicitly mentioned, and one skilled in the art will recognize that all such variations of terms are intended to be included.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 2","b":["201","202"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["if dimensioned, a type of dimension (e.g., target, plan, baseline, scenario, actual);","an indication of whether the attribute value can be rolled up to a corresponding parent attribute value and, if so, the type of roll-up function associated with that value;","an indication of whether the attribute value is calculated, and, if so, the calculation function for that attribute value;","an indication of whether the attribute value is a time-phased attribute and, if so, then the type of time-phased attribute is indicated.\n\nGenerally, time-phased attributes are attributes that have discrete values or ranges of values over periods of time, and described in more detail with reference to . Other fields and types of values (not shown) may also be defined in an attribute value definition and in an attribute definition. In step , meta-objects are instantiated using the created object types to correspond to the data that is to be managed and analyzed. In step , these meta-objects are persisted into storage. Then in step , a command interpreter is invoked to handle requests to manipulate the instantiated meta-objects and to manage the object type management subsystem.\n"]}}}},"An administrator of an application that incorporates the MODMS typically uses an interface to the object type management system to define object types for the data to be manipulated by the application. The administrator creates a new object type (using well-known types of interfaces such as dialog boxes, tables, forms, Q&A etc.) by determining which of the global attributes are grouped together to form the new object type.  is an example block diagram abstraction of an object type definition created and managed by an example object type management component of a Meta-Object Data Management System. Each object type definition  created by the object type management component of a MODMS comprises at least an object type identifier  and a collection of one or more attributes . Each attribute of the collection  is an indicator to an attribute definition  stored in the MODMS, for example as one or more rows of a table similar to the table described in Appendix B. The data structures shown in  are abstract representations of the data, and one skilled in the art will recognize that any well-known method for storing tabular or linked information may be used. An attribute definition  defines all of the fields that comprise the attribute. As described with reference to , each attribute definition  typically comprises a descriptive name field , an identification tag name field , and an indicator to one or more attribute value definitions, for example, attribute value definition . When the attribute definition  defines a dimensioned attribute, then an indicator  is present that refers to multiple attribute value definitions  through a dimensioned attribute table . Specifically, for each value set that comprises a dimension of the attribute, there is an indicator, such as indicators - in the dimensioned attribute table  that refers to an attribute value definition . The different value sets for a dimensioned attribute may correspond, for example, to target values , plan values , baseline values , actual values , and other such value sets . These different dimensions of an attribute are present to convey the concept that a single attribute may have different values depending upon its purpose, lifecycle state, or for other reasons. Each attribute value definition  or  comprises, for example, a type of value; an indication of whether the attribute value roles up to a parent node and, if so, a rollup function; an indication of whether the value is a calculated value and, if so, a calculation function; and an indication of whether the attribute is a time-phased attribute and, if so, the type of time phased attribute, etc. One skilled in the art will recognize that even if the attribute is not a dimensioned attribute, the attribute value definition  may be stored in the table  using the same mechanism as for a dimensioned attribute instead of being stored directly in the attribute definition  as shown in . (Although attribute value definition  can be represented by the same structure as , storing the attribute value definition outside of the dimensioned attribute table may yield processing efficiencies.)","Once the object type definitions have been created using the object type management component of the MODMS, then a user of the application that incorporates the MODMS can instantiate meta-objects using a meta-object instantiation component of the MODMS.  is an example block diagram of an example meta-object. Meta-object  includes an identifier of the type of object that is instantiated , a name , an identifier of the instantiated object , and an attribute block , which stores the collection of attribute values for all of the attributes defined for the object type denoted by object type identifier . The attribute value definitions of each attribute (such as those described with reference to ) are used to determine how each attribute value in attribute block  is to be interpreted and treated. In one embodiment, the attribute block is implemented as a \u201ctagged\u201d data structure of, typically, alphanumeric text that represents the value for each attribute between a set of tags, such as XML tags. So, as shown in , the first attribute value is delimited with the beginning tag \u201c<Attribute 1>\u201d and with the ending tag \u201c<\/Attribute 1>.\u201d The tag used in the attribute block  corresponds to the tag defined as tag name  in . Each meta-object  typically includes other fields, such as: an indicator  to a table of methods  that define the behavior of each meta-object ; an indication of a parent meta-object  in an instance hierarchy; a flag  that indicates whether the object has any associated children meta-objects; indicators  to the children meta-objects of meta-object  in the instance hierarchy; lifecycle information ; and other fields (not shown) .","One perspective of the attribute block  is that of a serialized \u201ccache\u201d of attribute values within an instantiated object. Because the attribute block  contains serialized data and stores each attribute value in a normalized (standard) fashion, the values of the attributes can be easily persisted, for example, using well-known database management technology. In addition, the tag methodology of the block  allows the attribute cache to be searched efficiently. Because a meta-object is an abstraction provided by the MODMS, one skilled in the art will recognize that the abstraction can be physically implemented according to a variety of techniques. For example, when an already instantiated meta-object is read and assembled from persistent storage to be manipulated by the MODMS, the various implementations of an MODMS may temporarily store the attribute values of attribute block  information as discrete data structures using traditional object-oriented techniques that instantiate objects for each value based upon the attribute type, etc. Other techniques, such as more traditional monolithic programming techniques may also be employed to implement a meta-object abstraction. From the perspective of a user of an application built upon MODMS, however, each meta-object looks and acts the same regardless of the type of object that is instantiated.","If one of the attribute values of the attribute block  is a time-phased value, then the value is more specifically described as a series of time-phased values, where each time-phased value is in effect over a range of time. For example, a time-phased attribute may have a discrete value for each week over a three-year period.  is an example block diagram of an in-memory data structure representation of time-phased attribute. Each time-phased attribute  has an associated time-phased attribute type ; an indicator  to a collection of one or more time-phased buckets ; and pointers to the methods  that can be used to manipulate the type of time-phased attribute denoted by type . For example, a time-phased attribute typically defines methods for getting and setting values for a particular range. Each time-phased bucket  is a data structure that indicates the range over which a value is effective. For example, each bucket  may comprise a bucket type , a value  for the range indicated, a start time period indication , a duration  that defines the range (for example, in number of hours, days, quarters, years, etc.), and an indicator  to the next bucket in the collection or that signifies the end of the list.","Note that the values of a time-phased attribute can be stored in the attribute block  delimited by tags in a manner that is similar to every other attribute value. In this case, a bucket collection is delimited by a pair of tags, which in turn contains nested tags that define the values (value, start time period, duration) for each time bucket. For example, if \u201cAdministration\u201d is the tag name of a time-phased (labor) attribute type, then the cache for the time buckets may read as:",{"@attributes":{"id":"p-0060","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Administration>"]},{"entry":[{},"\u2003\u2003\u2002<Bucket Collection>"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002< Bucket>"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002\u2003\u2003\u2002100, 1\/1\/2003, 30"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002<\/Bucket>"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002<Bucket>"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002\u2003\u2003\u2002250, 2\/1\/2003, 28"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002<\/Bucket>"]},{"entry":[{},"\u2003\u2003\u2002\u2003\u2003\u2002. . ."]},{"entry":[{},"\u2003\u2003\u2002<\/Bucket Collection>"]},{"entry":[{},"<\/Administration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Since a typical application that incorporates a MODMS creates and manages a very large collection of data, the physical representation of meta-objects can effect the efficiency of the application. In a typical implementation of a MODMS, each meta-object is stored as records in a multitude of tables, which are accessed by the management and analysis components of the MODMS as needed.  is a block diagram of an example storage representation of a meta-object. In , instantiated meta-object  is an abstract data structure representation of the meta-object  shown in  and contains the same fields: name ; an object identifier ; an identification of the object type ; an attribute block , and other fields (not shown). The instantiated meta-object  is shown stored as records in object table  and native attribute tables  and . Only some of the tables used to represent meta-object  are shown in . For each object, the MODMS stores a record in object table  that contains the object identifier , the name of the object , an identifier of the object type , and an indicator  to the (tagged) attribute block. One skilled in the art will recognize that instead of an indicator to the attribute block, the tagged text may be stored in the object table itself. The fields in each record in object table  thus correspond to the meta-object data structure . For each attribute indicated by the attribute block indicator , the MODMS also stores a record in a table that corresponds to the \u201cnative\u201d type of the attribute, thus cross-referencing the meta-objects by native attribute type. For example, if the attribute block contains an attribute that ultimately resolves to a \u201cnumber,\u201d then a record is created in a number attribute table  that indexes the meta-object . Or, for example, if the attribute block contains an attribute that is of a type that is ultimately a money attribute, then a record is created in a money attribute table . Example native attribute types include such types as numbers, dates, money, text, flags, and time-phase attributes, although one skilled in the art will recognize that depending upon the use of the MODMS, different native types may be useful. Storage of each attribute in these various native attribute type tables allows attributes to be indexed and accessed efficiently based upon their types, as opposed to searching each instantiated meta-object for instances that have attributes of a specific type. This capability may be useful, for example, when an attribute definition is changed and all of the objects that have been instantiated using that definition need to be updated accordingly. Thus, each record in a native type attribute table indicates the object identifier  of the corresponding instantiated meta-object  that contains an attribute value of that type. For example, each record in number attribute table  stores the attribute name ; an identifier of the attribute (sub)type ; the identifier of the corresponding instantiated meta-object ; and the value  specified for that attribute in the instantiated meta-object.","As previously mentioned, a meta-object is instantiated as part of a hierarchy of object instances.  is a block diagram of an abstraction of an example meta-object instance hierarchy created using an example Meta-Object Data Management System. The meta-object instance hierarchy defines the containment relationships of the instantiated meta-objects and is independent of the object type definitions. That is, any meta-object can be a child of any other meta-object providing it is instantiated as a child of that meta-object. This allows, for example, different types of investments to become part of other types of investments and to \u201cbehave\u201d like they belong to the parent investment without worrying about the strict inheritance rules of traditional object-oriented programming techniques. (Using traditional object-oriented techniques, an object can be manipulated using the same methods as its \u201cparent\u201d object of a different object type only if the child object type definition is derived when it is created from the parent object type definition.) So, in , for example, a portfolio \u201cA\u201d meta-object  contains a portfolio \u201cB\u201d meta-object ; two product \u201cF\u201d and \u201cG\u201d meta-objects  and ; and an asset \u201cI\u201d meta-object . Further, the portfolio \u201cB\u201d meta-object  contains a project collection \u201cE\u201d meta-object ; program \u201cC\u201d meta-object , and program \u201cD\u201d meta-object . The program \u201cC\u201d meta-object  further contains a project collection \u201cF\u201d meta-object . Conversely, project collection \u201cE\u201d meta-object  contains a program \u201cJ\u201d meta-object . Thus, in one case a program type meta-object is a parent of a project collection type meta-object; whereas, in the other case, a project collection meta-object is a parent of a program meta-object. Thus, the containment relationships define the object ancestral relationships and not the object definitions themselves.","Once meta-objects have been instantiated to correspond to the initial data set, a command interpreter is invoked to manage the data and to provide analysis functions.  is an example overview flow diagram of a command interpreter for an example Meta-Object Data Management System. In step , the MODMS allows a user (for example, an administrator of an application that incorporates the MODMS) to add, modify, or delete global attributes. An example global attributes table was described with reference to . In step , the MODMS allows a user to add, modify, or delete an object type definition such as that described with reference to . In step , the MODMS allows a user to add, modify, or delete instantiated meta-objects from the meta-object instance hierarchy, for example, the hierarchy shown with reference to .","One skilled in the art will recognize that there are many well-known methods for implementing the addition, deletion, and modification of global attributes and the addition and deletion of object type definitions and of instantiated meta-objects. For example, an interface such as a dialog box-based interface, a form based application, or a direct manipulation interface can be used to modify tables that store global attributes, object type definitions, and meta-objects. As mentioned previously, modifications to an object type definition, however, result in automatic adjustments to instantiated objects. Thus, when an object type definition is modified, the MODMS preferably locates all instantiated objects of that object type and modifies their contents accordingly to bring them up to date.  describe some of the routines used to modify object type definitions and to automatically adjust instantiated objects as a result. Analysis routines are typically tied to the applications that incorporate the MODMS and so are discussed as they relate to datasheet capabilities of an example portfolio management system embodiment described with reference to .",{"@attributes":{"id":"p-0065","num":"0068"},"figref":"FIG. 9"},"Specifically, in step , the MODMS retrieves the object type definition designated by the object_type_ID input parameter. In step , the MODMS modifies the retrieved object type definition by adding the new attribute definition that was designated as an input parameter to the routine. This new attribute definition is typically provided, for example, by an I\/O interface to an administrator that is permitted to change the definition of attributes in a global attribute table. Next, in step , the MODMS queries the meta-object instantiation hierarchy to locate all of the instantiated objects of the designated object type. Since each stored meta-object includes an indication of its object type, the instantiation hierarchy is searched based upon that field. Steps - execute a loop that, for each matching meta-object, updates the meta-object with the new attribute definition and adjusts attributes that have rollup characteristics as necessary. More specifically, in step , the routine determines whether there are more meta-objects to process and, if so, continues in step , else continues in step . In step , the next instantiated meta-object is determined. Then, in step , an Update Meta-Object routine is invoked to add the new attribute definition to the current instantiated meta-object being processed and to perform any specified calculations, and the routine returns to the beginning of the loop in step . The Update Meta-Object routine is described further with reference to . In step , once all of the meta-objects that need to be updated have been updated, an Adjust Rollups routine is invoked to update the entire instantiation tree by adjusting any attributes with rollup values, since the definitions of instantiated meta-objects may have changed. The Adjust Rollups routine described further with reference to .",{"@attributes":{"id":"p-0067","num":"0070"},"figref":["FIG. 10","FIG. 10"]},"More specifically, in step , if a new attribute is to be added to the meta-object instance indicated by the designated object identifier, then the routine continues in step , else continues in step . In step , the designated new attribute tag and a corresponding ending tag are added to the attribute block (for example, attribute block  in ). In step , the attribute definition that corresponds to the designated tag is retrieved from, for example, the global attributes table. In step , if the retrieved attribute definition indicates that the value of the attribute is to be calculated, then in step  the calculation is performed and the resultant value stored in the attribute block of the indicated meta-object instance. Otherwise, in step , a default value indicated by the retrieved attribute definition is stored between the attribute tag pair in the attribute block. In step , if an attribute is to be removed from the meta-object instance indicated by the designated object identifier, then the routine continues in step , else returns. In step , the attribute tag\/value pair that corresponds to the designated attribute tag is removed from or somehow nullified in the attribute block, and the routine then returns.",{"@attributes":{"id":"p-0069","num":"0072"},"figref":"FIG. 11"},"Specifically, in step , the routine obtains a graph of all the objects in the meta-object instance hierarchy from the designated sub-tree pointer downward to the leaf nodes. One skilled in the art will recognize that the implementation of this step is typically dependent upon the storage representation for the instantiation hierarchy. In step , the routine determines a list of the leaf nodes of that sub-tree. In steps -, the routine executes a loop for each leaf node to determine whether it has a rolled-up attribute and, if so, adds an event corresponding to that rollup to a list of rollup events to be executed. After the list is accumulated, the rollup events are executed in the order that they were added to the list, thus insuring proper aggregation. More specifically, in step , the routine determines whether there are any more leaf nodes in the graph, and, if so, continues in step , else continues in step . In step , the routine gets the next leaf node indicated by the sub-tree graph. In step , the routine determines from the object type system whether the current node corresponds to a type of object which has rolled-up attributes. In one embodiment, each object type has a list of the attributes it contains (an object-specific rollup attribute list) that have values that roll up (referred to for convenience as rollup attributes). Alternatively, a list of attributes that need to be rolled-up for that object type can be dynamically generated. Steps - execute a loop for each of these rollup attributes to add a rollup event to the roll up list. Specifically, in step , if there are more rollup attributes for that object to be processed, then the routine continues in step , else returns to look at the next leaf node in step . In step , the routine gets the next rollup attribute from the object-specific rollup attribute list. In step , the routine adds a rollup event that corresponds to that rollup attribute to the rollup event list. A rollup event includes, for example, an indication of the current node in the instantiation sub-tree and a pointer to an attribute that needs to be rolled up so that, when the event is executed, the correct rollup function can be found and the corresponding value(s) of the attribute can be determined. Example code for an example rollup event is described with reference to . In step , once the routine determines that there are no more leaf nodes to process, the routine executes the Execute_Rollup_List routine (not shown) to execute all of the rollup events on the rollup event list that have been accumulated thus far, and then returns. Note that it is only necessary to examine the leaf nodes initially and to add rollup events for the leaf nodes, because each rollup event for a leaf node in turn will add rollup events for the parent node of each of these nodes (see ). These nodes will in turn add rollup events for their parent node, and the entire process will bubble up similarly so that eventually all necessary rollup events from the leaf node all the way to the highest parent node across each level of the instantiation sub-tree will be added and executed.","As described, rollup event code is executed for each rollup event that has been added to the rollup event list.  is an example flow diagram of steps executed by a typical rollup event. One skilled in the art will recognize that other code are possible and that this is just one example for ensuring that attributes are rolled up from the leaf nodes all the way to the root node of the designated sub-tree. In step , the rollup event code determines, based upon a designated attribute and node pointer, the particular rollup function for the designated attribute. In step , if there is no rollup function specified (the definition is incomplete) then the code returns, other continues in step . In step , the rollup event code determines a list of the children of the current designated node and the parent node of the designated node. In steps -, the routine executes a loop to aggregate the corresponding attribute values of the designated attribute of the children nodes with the designated node so that the aggregated value can be stored in the parent node. The code also adds a rollup event corresponding to the parent node and the designated attribute so that the process can bubble up the hierarchy. More specifically, in step , the routine determines whether there are more children nodes of the designated node, and, if so, continues in step , else continues in step . In step , the routine gets the next child node to process. In step , the routine updates an (accumulating) aggregated value with the corresponding attribute value from the current child and saves it until all of the values are retrieved from all the children of the designated node. For example, if the total cost is the attribute being computed and the rollup function is a summation function, then step  contains a temporary variable for collecting a sum of the total cost attribute of each of the children nodes. The routine then returns to step  to look for the next child node to process. In step , when there are no more children nodes of the designated node to process, the routine adds a rollup event to correspond to the parent node of the designated node and designates the current attribute being processed, and then returns.",{"@attributes":{"id":"p-0072","num":"0075"},"figref":"FIG. 13","b":["1300","1310"]},"In the embodiment shown, computer system  comprises a computer memory (\u201cmemory\u201d) , an optional display , a Central Processing Unit (\u201cCPU\u201d) , and Input\/Output devices . The Meta-Object Data Management System (\u201cMODMS\u201d)  is shown residing in the memory . The components of the MODMS  preferably execute on CPU  and manage the generation, management, and use of meta-objects, as described in previous figures. Other downloaded code  and potentially other data repositories  also reside in the memory , and preferably execute on one or more CPU's . In a typical embodiment, the MODMS  includes an object type management subsystem , a meta-object instance management subsystem , input\/output interfaces , and one or more data repositories , including, for example, investment data.","In an example embodiment, components of the MODMS  are implemented using standard programming techniques. One skilled in the art will recognize that the components - lend themselves to distributed, object-oriented implementations and can be implemented to use relational database management systems, web-based (Internet or internet) interfaces, etc. However, any of the MODMS components - may be implemented using more monolithic programming techniques as well. In addition, programming interfaces to the data stored by the MODMS process can be available by standard means such as through C, C++, C#, and Java API and through scripting languages such as XML, or through web servers supporting such interfaces. The data repositories  and  are preferably implemented for scalability reasons as database systems rather than as text files, however any method for storing the application data and for storing the instantiated meta-objects may be used. In addition, some routines of the object type management subsystem  and the meta-object instance management subsystems may be implemented as stored procedures, or methods attached to table \u201cobjects,\u201d although other techniques are equally effective.","One skilled in the art will recognize that the MODMS  may be implemented in a distributed environment that is comprised of multiple, even heterogeneous, computer systems and networks. For example, in one embodiment, the object type management subsystem , the meta-object instance management subsystem , and the data repositories - are all located in physically different computer systems. In another embodiment, the type and instance subsystem components  and  of the MODMS  are hosted each on a separate server machine and may be remotely located from the instantiated object and attribute tables which are stored in the data repositories -. Different configurations and locations of programs and data are contemplated for use with techniques of the present invention. In example embodiments, these components may execute concurrently and asynchronously; thus the components may communicate using well-known message passing techniques. One skilled in the art will recognize that equivalent synchronous embodiments are also supported by an MODMS implementation. Also, other steps could be implemented for each routine, and in different orders, and in different routines, yet still achieve the functions of the MODMS.",{"@attributes":{"id":"p-0076","num":"0079"},"figref":["FIGS. 14 and 15","FIG. 14"]},"So, for example, in , the web services interfaces , which are typically structured application programming interfaces (\u201cAPI\u201d), communicate through encapsulated data access (data abstractions) to various databases. The layers in a data access layer bind the data abstractions into the various databases physically used in the system in order to manage the physical storage. For example, the web services interfaces  communicate (eventually) through an accessor layer  to a data access layer , which communicates to lower level data access libraries  (for example, ADO.NET). These access libraries  provide interfaces to the various physical database management systems such as a relational database management systems -. The web services layer  contains web service interfaces (API)  which are used by the presentation tier  to access the various web services.","The web service layer  provides support for the MODMS functions. The various capabilities of a MODMS are implemented as services, such as object services , licensing services , and user permissions and related services . Access to the MODMS services is provided by web services framework  through calls to the web services interfaces .","As continued in , presentation tier  ( in ) interfaces with the MODMS services through calls to the various web services - using the web service interfaces . In addition, various connectors  to other third-party environments can interface through the web service interfaces  to take advantage of the underlying technology. For example, connectors to programs such as Microsoft Project Server, and Pacific Edge's Project Office can interface through the web services interfaces  to import data into the MODMS and to export data to those the third-party programs.","The presentation tier  provides the input\/output interface between, for example, a client web browser  and the web services layer  of the MODMS. The presentation layer  typically comprises some type of page server  (for example, ASP.NET); a navigation and user interface framework ; and various page definitions  which are transported through the page server  to the client web browser . The pages  may reference various class libraries provided by the system . In addition, in some embodiments, the presentation layer  may provide charting support  and other application-specific modules (not shown).","In an example embodiment, the majority of the functions that were described with respect to  are implemented in the object services layer  of the web services .  is an example block diagram of components of an example object services layer of a Meta-Object Data Management System used to implement an example Enterprise Portfolio Management System. To implement an MODMS, the object services  comprises a command layer ; and various engines\/subsystems - for implementing the functionality of the object type system and meta-object instantiation systems described earlier. For example, a typical object services layer  may comprise an object instance system ; an object type system  with an administration module  for modifying object types; a time-phased subsystem ; a milestone subsystem ; and a math engine . As described earlier, administrators use the type system module  to define and manage object types in the system. The instance system  is used to instantiate meta-objects of those types. The math engine , time-phased subsystem , and milestone subsystem  are shown as supplemental components; however, one skilled in the art will recognize that their functionality may be incorporated into the other modules as appropriate.","As described in , a meta-object data management system may be used to create applications such as an enterprise portfolio management system. In an enterprise portfolio management system, object types are created for each \u201cinvestment\u201d type to be managed by the system and, as portfolios are added to the system that contain investments, corresponding objects (meta-objects) are instantiated appropriately.",{"@attributes":{"id":"p-0083","num":"0086"},"figref":["FIG. 17","FIG. 14","FIGS. 14 and 15"],"b":["1700","1702","1703","1704","1705","1702","1704","1701","1701","1706","1701","1706","1701"]},{"@attributes":{"id":"p-0084","num":"0087"},"figref":["FIG. 18","FIG. 18","FIG. 18"],"b":["1810","1811","1812","1813","1810","1813","1832","1840","1841","1842","1832","1841","1853","1840","1850"]},"As described with respect to , the example enterprise portfolio management system comprises portfolio management functions, portfolio analysis functions, and portfolio administrative functions. Example screen displays of some of the functionality provided by these components are illustrated in Appendices A and C, which are herein incorporated by reference in their entirety. Appendix A includes screen displays from a portfolio management interface and a portfolio analysis interface to an executing portfolio management system. Appendix C illustrates screen displays that exemplify the capabilities of a charting subsystem, which allows multi-dimensional data to be redisplayed in a chart using modified sets of axes, without rebuilding the underlying chart definition. In the examples shown, the charting system is integrated into the portfolio analysis interface such that each chart is associated with a designated multi-dimensional view of the data.",{"@attributes":{"id":"p-0086","num":"0089"},"figref":["FIGS. 19-28","FIG. 17"]},{"@attributes":{"id":"p-0087","num":"0090"},"figref":["FIG. 19","FIG. 19","FIG. 20","FIG. 22","FIG. 21","FIG. 23"],"b":["1901","1902","1903","1904","1903","1901","1904","1905","1906","1905","1901","1906","1907","1908","1907","1901","1908","1909","1910","1909","1901","1910","1911","1901","1911"]},{"@attributes":{"id":"p-0088","num":"0091"},"figref":["FIG. 20","FIG. 11"],"b":["2001","2002","2003"]},{"@attributes":{"id":"p-0089","num":"0092"},"figref":["FIG. 21","FIG. 11"],"b":["2101","2102","2103","2104","2105","2106","2107","2107"]},{"@attributes":{"id":"p-0090","num":"0093"},"figref":["FIG. 22","FIG. 11"],"b":["2201","2202"]},{"@attributes":{"id":"p-0091","num":"0094"},"figref":["FIG. 23","FIG. 11"],"b":["2301","2302","2304","2302","2303","2305","2303","2304","2305"]},{"@attributes":{"id":"p-0092","num":"0095"},"figref":["FIG. 24","FIG. 24","FIG. 25","FIG. 27","FIG. 28"],"b":["2401","2402","2403","2404","2403","2401","2404","2405","2406","2405","2401","2406","2407","2408","2407","2401","2408","2409","2401","2409"]},{"@attributes":{"id":"p-0093","num":"0096"},"figref":["FIG. 25","FIG. 26"],"b":["2501","2502","2503","2504","2505","2501","2504"]},{"@attributes":{"id":"p-0094","num":"0097"},"figref":["FIG. 26","FIG. 26"]},"Specifically, in step , the routine queries the investment object instance hierarchy at the designated sub-tree according to the designated parameters specified in the datasheet attribute specification (see input parameter list) to determine a results table. Specifically, the query locates objects of the designated object type that have the designated columns and that correspond to the grouping, filtering, and sorting rules previously indicated and designated as input parameters. The designated group list is a list of each grouping of matching instances. For example, investments may be grouped by \u201crank\u201d and then by geographic region. Once grouped, then the designating sorting rules are used to order matching instances within a group (the results of the query). Appendix A shows examples of resultant datasheets with attribute specifications having multiple groups and sorting rules.","In step , the routine filters the resulting table of instances based upon the security roles that are indicated by the designated security roles. For example, different security roles can be defined for different users and organziational groupings, etc., and the roles can be used to filter the data users have access to and what types of investment data can be viewed via the datasheets. Different security roles may be defined that correspond to modification access permissions as well as what data may be viewable. The security roles may directly correlate to the organizational hierarchy, which may also be reflected in the actual containment hierarchy of the investment instances.","In step , a new virtual object tree root node (a virtual object) is created. In step , a Build_VO_Tree routine is invoked to build a virtual object tree from the resultant table of instances that was returned as a result of the query. The pseudo code for an example Build_VO_Tree routine is described further with reference to Table 1. In step , the routine invokes the Adjust Rollups routine described with reference to  on the newly created virtual object tree so that rollups can be properly computed for the datasheet. The routine then returns the instantiated virtual object tree, which corresponds to the datasheet.",{"@attributes":{"id":"p-0098","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"266pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20021","Build_VO_Tree (root, group_list, query_string) {"]},{"entry":"\u20022"},{"entry":["\u20023","\u2003\u2003\u2003curr_group = head (group_list);"]},{"entry":["\u20024","\u2003\u2003\u2003new_grp_list = rest (group_list);"]},{"entry":["\u20025","\u2003\u2003\u2003# for each value in current group, starting with the first, ending with the last"]},{"entry":["\u20026","\u2003\u2003\u2003for value = first_value (curr_group), next (curr_group, last_value (curr_group) {"]},{"entry":"\u20027"},{"entry":["\u20028","\u2003\u2003\u2003\u2003\u2003\u2003subroot = create_new_virtual_object;"]},{"entry":"\u20029"},{"entry":["10","\u2003\u2003\u2003\u2003\u2003\u2003if (new_grp_list = null) {"]},{"entry":["11","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# find all data that matches current sent of group values"]},{"entry":["12","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003leaf_table = query_results_table (concat (query_string,"]},{"entry":["13","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003curr_group, value));"]},{"entry":["14","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003for row in leaf_table {"]},{"entry":["15","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# add pointers from subroot to all data that matches"]},{"entry":["16","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003add_row_as_child (subroot, row);"]},{"entry":["17","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# update subroot attributes based on row data"]},{"entry":["18","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003update_subroot_attributes (subroot, row);"]},{"entry":["19","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003};"]},{"entry":["20","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (result != 0) {"]},{"entry":["21","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# integrate new leaf node (virtual object) into VO tree"]},{"entry":["22","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003add_child (root, subroot);"]},{"entry":["23","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# update root attributes based upon those of new VO"]},{"entry":["24","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003update_root_attributes (root, subroot);"]},{"entry":["25","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003} # no data exists with current group value"]},{"entry":["26","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003else delete (subroot);"]},{"entry":["27","\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":["28","\u2003\u2003\u2003\u2003\u2003\u2003else{"]},{"entry":["29","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# recurse to build a child sub-tree with current group = value"]},{"entry":["30","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003child = Build_VO_Tree (subroot, new_grp_list,"]},{"entry":["31","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003concat (query_string, curr_group, value));"]},{"entry":["32","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# add the newly built child into the current sub-tree"]},{"entry":["33","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003add_child (root, child);"]},{"entry":["34","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003# update root attributes based upon those of child"]},{"entry":["35","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003update_root_attributes (root, child);"]},{"entry":["36","\u2003\u2003\u2003\u2003\u2003\u2003};"]},{"entry":["37","\u2003\u2003\u2003}; # end loop on current group values"]},{"entry":"38"},{"entry":["39","\u2003\u2003\u2003return (root);"]},{"entry":["40","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 1 contains pseudo code for an example Build_VO_Tree routine. As illustrated, the Build_VO_Tree routine implements a recursive process for building up a virtual object tree from the results of a query of the investment instance hierarchy based up a datasheet attribute specification. It is assumed that the results of the query are in tabular form, or otherwise easily decomposed, and that the results are grouped and sorted in the order that they should be displayed. One skilled in the art will recognize that this is not a requirement and that the pseudo code for the Build_VO_Tree routine could be modified appropriately. Also, iterative equivalents of the recursive process could be equivalently substituted.","In summary, the routine builds a virtual object tree whose leaf nodes point to investment data. The routine operates from the \u201cinside\u201d out (leaf nodes up). That is, the datasheet is effectively a tree turned sideways, where the innermost groupings are the leaf nodes, the investment data that matches the innermost grouping are indicated in these leaf nodes, and the next level of grouping is the next \u201clevel\u201d of intermediate virtual object nodes in the tree, and so forth. Virtual objects need to be created for each intermediate (group) node in the tree, since instantiated objects exist only for investment data. Thus, examining a datasheet excerpt shown in a Summary View of the Portfolio Analyzer display screens in Appendix A, a subset of which is also displayed in Table 2 below, the investment data results are grouped first by Region values and grouped second by Score values. Under each combination of Region\/Score values, there are 0 to N investment objects instances with those values. There are M levels of virtual objects for each M levels of groups. Thus, a virtual object is preferably created for each grouping (combination) value, with indicators to the instantiated investments, and a virtual object is needed for each discrete value (or combined value) of each group of groups, and so on.",{"@attributes":{"id":"p-0101","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Name","Budget","Region","Score","Status","Total Cost"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Region:2","$81,000","2",{},{},"$72,000"]},{"entry":["Score:2","$27,000",{},"2",{},"$24,000"]},{"entry":["Project 3","$13,000","2","2","Green","$12,000"]},{"entry":["Project 2","\u2002$9,000","2","2","Red","\u2002$8,000"]},{"entry":["Project 1","\u2002$5,000","2","2","Green","\u2002$4,000"]},{"entry":["Score:3","$26,000",{},"3",{},"$23,000"]},{"entry":["Project A","$11,000","2","3","Yellow","$10,000"]},{"entry":["Project 4","\u2002$8,000","2","3","Green","\u2002$7,000"]},{"entry":["Region:1",{},"1"]},{"entry":["Score:1",{},{},"1"]},{"entry":[". . .",{},"1","1"]},{"entry":["Score:3",{},{},"3"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}}},"For example, looking at Table 2, a virtual object is created for a [region=2; score=2] leaf node; a [region=2; score=3] leaf node; a [region=1; score=1] leaf node; and a [region=1; score=3] leaf node. Each of these become children of an \u201cintermediate\u201d virtual object node, in this case, on the outermost grouping level: a virtual object is created for a [region=2] node and a virtual object is created for a [region=1] node, and so on. Thus, the resulting virtual object tree has 2 levels (since there are 2 levels of groups) with a topmost root, the first level corresponding to region values, and the second level corresponding to score\/region values.","The pseudo code of Table 1 demonstrates an implementation of this approach. The loop of lines 6-37, examines each value of a current group. If the innermost group (leaf nodes) has not yet been reached, then the routine is invoked recursively in line 30 to build a virtual object tree starting with a newly created virtual object sub-tree and the rest of the group list. This process continues until the innermost group is reached, in which case line 10 is true. At that point, all of the matching investment instances for that combination of group values is determined (line 12), each matching instances is added to the virtual object leaf node (line 16), and the attributes of the virtual object leaf node are determined (line 18). Once all of the matching instances have been referenced by the virtual object leaf node (line 20), then the newly created leaf node is added into the virtual object sub-tree whose root is the next closest intermediate node (the parent virtual object of the leaf node) (line 22). The attribute values of the current root (the parent virtual object) are then updated based upon the attributes of the newly created virtual object leaf node (line 24). When the current invocation of the routine then pops back up to a prior recursive invocation (line 30 results), then the newly build virtual object sub-tree is added a child node to the current root of that sub-tree (line 33). The attributes of the current root are then updated to reflect the built sub-tree (line 35). In the example shown in Table 2, the current root at that point is the root of the datasheet\u2014the entire virtual object tree. One skilled in the art will recognize that other implementations, such as those that actually persist the virtual objects that correspond to a datasheet are also feasible.","As described earlier with respect to , once a datasheet is created, it can be moved or copied to another investment object. In one embodiment, datasheets are associated with portfolio objects only; however, one skilled in the art will recognize that it is possible to associate datasheets with other investment objects as well.  is an example flow diagram of a Move\/Copy Multi-Dimensional View routine for moving\/copying a multi-dimension view. The routine takes as input a virtual object tree, an indication of a source node, and an indication of a target (destination) node. Note that, if more than one datasheet can be associated with a node, then an indication of which datasheet is also an input parameter. In step , the designated virtual object tree is associated with the designated target node so that the datasheet will become part of that investment object. The property sheet that defines the datasheet is also copied as appropriate to the properties of the designated target node so that the target node then has access to maintain the datasheet. In step , the routine invokes the Build Presentation routine described with reference to  so that a new virtual object tree that corresponds to the moved datasheet can be created for the target node. This step is necessary since the values of the datasheet typically depend upon the sub-tree of nodes associated with the datasheet. In step , if the portfolio analyzer interface has specified that the datasheet is to be moved, then the routine continues in step , otherwise returns. In step , the routine calls a Delete Multi-Dimensional View routine to delete the datasheet associated with the designated source node, and then returns.",{"@attributes":{"id":"p-0105","num":"0108"},"figref":["FIG. 28","FIG. 11"],"b":["2801","2802","2803"]},"In addition to creating and managing datasheets, the example portfolio analyzer also supports dynamic charting capabilities. Appendix C shows detailed display screens for a charting sequence from a charting subsystem of an example enterprise portfolio management system. A chart \u201cvector,\u201d which defines all of the potential axes for a particular set of charts is associated with a datasheet. The axes thus preferably correspond to all of the dimensions viewable in the datasheet. Once a chart vector is created for a particular chart type (e.g., a bubble chart), the axes that correspond to the currently displayed presentation are dynamically selectable. Thus, the charts can redisplay the underlying datasheet investment data, without having to be rebuild the chart structure.","All of the above U.S. patents, U.S. patent application publications, U.S. patent applications, foreign patents, foreign patent applications and non-patent publications referred to in this specification and\/or listed in the Application Data Sheet, including but not limited to U.S. Provisional Patent Application No. 60\/471,811, entitled \u201cMETHOD AND SYSTEM FOR OBJECT-ORIENTED MANAGEMENT OF MULTI-DIMENSIONAL DATA,\u201d filed May 19, 2003, is incorporated herein by reference, in its entirety.","From the foregoing it will be appreciated that, although specific embodiments of the invention have been described herein for purposes of illustration, various modifications may be made without deviating from the spirit and scope of the invention. For example, one skilled in the art will recognize that the methods and systems for creating, managing, and analyzing heterogeneous investment data discussed herein are applicable to other types of data management systems other than enterprise portfolio management. For example, the techniques used herein can be applied to homogeneous data such as streamlined inventory control systems or project management systems. One skilled in the art will also recognize that the methods and systems discussed herein are applicable to differing network protocols other than the Internet and web-based communication, communication media (optical, wireless, cable, etc.) and devices (such as wireless handsets, electronic organizers, personal digital assistants, portable email machines, game machines, pagers, navigation devices such as GPS receivers, etc.)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 14 and 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 28"}]},"DETDESC":[{},{}]}
