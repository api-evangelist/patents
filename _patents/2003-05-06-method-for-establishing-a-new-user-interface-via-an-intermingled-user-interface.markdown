---
title: Method for establishing a new user interface via an intermingled user interface
abstract: A method of separating a function of the business logic of an application from a user interface of the application where the business logic and user interface of the application are intermingled is provided. The method includes providing a wrapper interface for the application. The method also includes providing a function of the business logic of the application separated from the user interface of the application through the wrapper interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07461385&OS=07461385&RS=07461385
owner: QAD Corporation
number: 07461385
owner_city: Carpinteria
owner_country: US
publication_date: 20030506
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates to interacting with an application, and more particularly to interacting with an application that is wrapped with an interface wrapper.","Certain data resource systems include data and associated applications that are developed over extended periods of time (e.g., decades). For example, various enterprise resource planning (i.e., ERP) systems utilize legacy based systems (e.g., MFG\/PRO, SAP, etc.). Such legacy systems often include thousands of programs, many of which are in a programming language that may be used in a legacy system (e.g., Oracle, Progress, etc.). Many of these programs offer numerous functions (e.g., report, enquiry, and maintenance functions).","In some legacy systems, the purpose of the maintenance functions is to take data (e.g., through an interface), apply certain rules to the data (through business logic), and to then store the result in a database (persistence). Typically, each maintenance program performs all three of these functions without distinction, whether user driven or business document driven (i.e., EDI (electronic data interchange), XML).","With the current state of technological advances, it is often desirable for legacy systems to accept and interact with data from multiple interfaces (e.g., user entry, the Internet, EDI, XML, other ERP systems, etc.). In hindsight, the task of providing multiple interfaces to legacy systems could have been accomplished by separating the business logic from the interface during creation of each application or program. Such an approach could allow multiple interfaces to be exchanged seamlessly. Unfortunately, such an approach was typically not considered during the development of the library of applications included in legacy systems.","As such, existing legacy systems include thousands of programs including an intermingled user interface and business logic. In order to separate the user interface from the business logic, all of the existing legacy system applications could be rewritten using new coding techniques and using the most up-to-date technologies. Alternatively, each piece of code in the legacy system could be modified in order to manually remove the user interface and to replace the interface with input parameters.","Unfortunately, each of these alternatives is undesirable in that re-writing or modifying an existing legacy system code base is a very substantial undertaking.","As such, it would be desirable to provide an improved method for separating the user interface and business logic of legacy based system applications.","In an exemplary embodiment of the present invention, a method of separating a function of business logic of an application from a user interface of the application where the business logic and user interface of the application are intermingled is provided. The method includes providing a wrapper interface for the application. The method also includes providing a function of the business logic of the application separated from the user interface of the application through the wrapper interface.","According to certain exemplary embodiments of the present invention, a user interface and\/or an external system can interact with the business logic of the application through an exposed API.","In another exemplary embodiment of the present invention, a computer readable carrier including computer program instructions which cause a computer to implement a method of separating a function of business logic of an application from a user interface of the application, where the business logic and user interface of the application are intermingled, is provided. The method includes providing a wrapper interface for the application. The method also includes providing a function of the business logic of the application separated from the user interface of the application through the wrapper interface.","In yet another exemplary embodiment of the present invention, a wrapped application is provided. The wrapped application includes an application having an intermingled user interface and business logic. The wrapped application also includes a wrapper for wrapping the application such that a function of business logic of the application is separated from the user interface of the application.","Preferred features of selected embodiments of this invention will now be described with reference to the figures. It will be appreciated that the spirit and scope of the invention is not limited to the embodiments selected for illustration. Also, it is contemplated that any of the configurations described hereafter can be modified within the scope of this invention.","In order to clarify certain aspects of the present invention, various definition of terms used herein are now defined.","A wrapper (or a wrapper interface) is code which is combined with another piece of code to determine how that code is executed. The wrapper acts as an interface between its caller and the wrapped code. This may be done for compatibility (e.g., if the wrapped code is in a different programming language or uses different calling conventions) or for security (e.g., to prevent the calling program from executing certain functions). The implication is that the wrapped code can only be accessed via the wrapper.","An API (i.e., application programming interface) is an interface (calling conventions) by which an application program accesses operating system and other services. An API is defined at source code level and provides a level of abstraction between the application and the kernel (or other privileged utilities) to ensure the portability of the code. An API can also provide an interface between a high level language and lower level utilities and services which were written without consideration for the calling conventions supported by compiled languages. In this case, the API's main task may be the translation of parameter lists from one format to another and the interpretation of call-by-value and call-by-reference arguments in one or both directions.","Business logic is the code that implements the functionality or business rules of an application.","A user interface refers to the aspects of a computer system or program which can be seen (or heard or otherwise perceived) by the human user, and the commands and mechanisms the user uses to control its operation and input data. A graphical user interface emphasizes the use of pictures for output and a pointing device such as a mouse for input and control whereas a command line interface requires the user to type textual commands and input at a keyboard and produces a single stream of text as output.","The present invention relates to applications and groups of applications whose business logic and user interface are \u201cintermingled.\u201d As used herein, the term intermingled relates to a non-layered relationship between the business logic and user interface of an application.","Generally, the present invention relates to a method of separating the business logic from the user interface in applications of a legacy system. The invention preferably provides for such a method while minimizing changes to the legacy system code base. Additionally, in certain embodiments, the present invention provides multiple interfaces (and custom code) to the applications in the legacy system.","To separate the business logic from the user interface, the legacy system is wrapped with a new interface that models an end user. This artificial user hides the complexities of its task by providing the outside world with a set of simple methods to perform various functions including data entry, data retrieval, and error notification. The method utilizes the business logic from existing, unmodified, legacy system character code by emulating data entry, navigation, and error detection. As such, the business logic of the applications is exposed through the new interface, for example, as an API.","In an exemplary embodiment of the present invention, the legacy system is wrapped with a Java interface that renders a screen in HTML. Certain new features may be provided because of the HTML screen, for example, related to the changing the look & feel of screens, standardization of user navigation, and the ability to hide fields.","In another embodiment of the present invention, existing business logic of a legacy system is encapsulated such that a common gateway for multiple interfaces can be provided (e.g., HTML Interface, Hand-Held-Device Interface, API Interface, etc.).","As detailed herein, the present invention may be viewed as a group of components including a processing engine (e.g., including a Java interface or a Java wrapper), connection managers, and adapters.","According to an exemplary embodiment of the present invention, the processing engine emulates a user and thereby provides methods to interface with the underlying legacy system (e.g., MFG\/PRO, SAP, etc.). Responsibilities of the processing engine may include, for example: launching of the legacy system session; maintaining the state of a session (i.e., busy, idle, disconnected); launching of applications\/programs within the legacy system; retrieving data from a legacy system program; submission of data to a legacy system program; navigation of a legacy system program; error capturing and notification; and authentication of requests.","Although the processing engine (e.g., including a Java Interface) may have the responsibility to provide methods of communication with the legacy system, the processing engine is typically not responsible for controlling the flow in which these methods are called. As such, flexibility of different processing flows for different interfaces is provided. (i.e., HTML, hand held devices, APIs, etc.).","According to an exemplary embodiment of the present invention, data submitted to and from the processing engine is via XML, including non-critical error messages. (i.e., legacy system error & warning messages).","As described herein, connection managers provide a link between the legacy system interface (e.g., a Java Interface) and external adapters. The external adapter components provide a link between the outside world (e.g., a Web browser, a hand held device, etc.) and the internal system of the present invention.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["106","106","106","106"]},"In order to separate the business logic from the user interface, legacy system  is wrapped with wrapper\/interface . For example, wrapper\/interface  may be a Java interface. UI client\/external system  desires to have an interaction (e.g., data entry, data retrieval, data update, etc.) with an application within legacy system . For example, UI client\/external system  may be an actual user interface client (e.g., connecting through a web browser), or UI client\/external system  may be an external system (e.g., an electronic messenger). UI client\/external system  connects to adapter . Adapter  connects with wrapper\/interface . Wrapper\/interface  sends the desired information (e.g., connection information, data, instructions, etc.) to adapter . The desired information includes certain business logic of an application of legacy system  that is exposed to adapter  as an API. For example, the desired information may be sent to adapter  in XML format. Adapter  may be, for example, an HTML adapter that converts the desired information from a first format (e.g., XML) to a second format (e.g., HTML).","It also may be desirable to provide this desired information in a given layout and with particular attributes. As such, adapter  retrieves layout and format information from Rules  (e.g., XSL, style sheet, etc.) and combines this layout and format information with the desired information sent to adapter , for example, in XML format. The desired information is then formatted according to Rules  by adapter . The formatted information (e.g., in HTML format) is then sent to UI client\/external system .",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIG. 2"],"b":["200","200","208","200"]},"UI Client  may have some combination of the following exemplary responsibilities: render a functional user interface compatible with a display device (e.g., PDA, browser, hand held terminal, mobile phone, etc.); provide a mechanism for the user to enter data; provide a mechanism for the entered data to be submitted to a user interface adapter component (e.g., HTTP post for browsers, socket to socket call, native program call (i.e., Java-to-Java), web-services, etc.); provide a mechanism to store an identity reference to the allocated instance of the processing engine; provide a mechanism for the user interface to display error\/information messages; provide a representation for the user of functions like submit, go back, delete, insert, etc.; and to provide a mechanism for the user interface to be closed.","UI Client  makes requests from user interface adapter . User interface adapter  interprets the requests from UI Client , and formulates appropriate responses. User interface adapter  also makes requests and handles responses (e.g., API calls) to and from processing engine .","User interface adapter  may have some combination of the following exemplary responsibilities: interpret requests from UI client ; basic validation of a request from UI client ; convert a request from UI Client  into something recognizable by processing engine ; re-match the client request with the original allocated processing engine  (via connection manager \u2014not for initial requests and when a pool is being used); provide the ability to launch new programs; control the process flow of API calls made to processing engine  (e.g., submit data and then get the screen, etc.); handle errors; formulate responses from processing engine into a format recognizable by UI client  (e.g., HTML, WML, etc.); and ensure UI client  and adapter integrity (i.e., no duplicate submits, recovery from system failures, etc.).","Connection manager  holds a pool of sessions for processing engine . Though the system could operate by creating a new processing engine  for every new program request, this could be inefficient. This is particularly true if there is an overhead in starting up the legacy application. Therefore, using connection manager  may provide for re-use of processing engine .","Connection manager  may have some combination of the following exemplary responsibilities: start and stop a pool of processing engines  (wrapping the legacy application); maintain a state for each individual processing engine  (e.g., idle, busy, initializing, disconnected, etc.); maintain the transition of the states; provide a mechanism to obtain an idle processing engine ; provide a mechanism to obtain a busy processing engine  using an identity; provide a mechanism for timing out a busy session when inactive for a period of time; perform house keeping on the pool (i.e., clear up disconnected processing engines ), timeouts, etc.; and maintenance and management of an individual processing engine (i.e., ending, re-setting, etc.).","Processing engine  exposes a set of APIs into a legacy application, where the business logic of the given application is intermingled with the user interface. This provides the outside world the illusion of dealing directly with the business logic of the legacy application.","Processing engine  may have some combination of the following exemplary responsibilities: wrap the underlying legacy application with an API layer; expose a set of generic APIs that can represent all possible actions required by the legacy system (e.g., start program, stop program, submit data, get errors, get display (screen), get field, etc.); interact with the legacy application without (where possible) making any modifications to the existing code, for example using a hidden user interface (e.g., using a character interface like Telnet, DOS window, or other types of client interface); provide a veneer over the legacy application (possibly written in the legacy application code) that understands requests from processing engine  (this may be used for generating a data representation of the legacy system user interface, providing confirmations of processing engine  requests and so forth); maintain the integrity of the legacy application (e.g., ensure transactions are completed, error detection and recovery, processing timeouts, legacy application termination (graceful and forced)); maintain the state of the legacy application (e.g., idle, busy, initializing, etc.); provide a mechanism for generating a structured data representation of the screen including identities for data entry points (e.g., field names); provide a mechanism for taking submitted data and cross referencing data points with their respective identities in the legacy application (e.g., matching the data submitted with the corresponding legacy application field); provide a transformation of data type formats (e.g., date format, time format, Boolean (true\/false or yes\/no), etc.) between the legacy application and the submitted data (e.g., dd\/mm\/yy converted to mm\/dd\/yy); provide a mechanism for capturing errors from the legacy application; support multiple legacy application data entry types (e.g., fill-in, combo-box, radio-set, selection lists, etc.); allow the data flow of the legacy application to drive the data entry process (e.g., only send data to the legacy application when asked, don't submit a batch of fields at once); provide a mechanism to control or default navigation through the legacy application user interface (hiding this fact from the outside world) (e.g., hit return for every field, etc.); and ensure that a processing sequence tag generated for screen data is validated against the submitted data before sending the data into the legacy system (e.g., ensure legacy systems and client submitted data is not out of sink).","Unmodified legacy application user interface  is the user interface of an application in the underlying legacy system where the business logic and user interface of the application are intermingled.","Although one single UI client  has been illustrated and described by reference to , it is intended that multiple UI clients  may have interactions with the legacy system at the same time.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 3","FIG. 3"],"b":["208","300","300","300","302","302"]},"In a modified version of the exemplary embodiment illustrated in , the interface that API adapter  exposes to external system  is fixed. In such an embodiment, some other component, ahead of external system , is used to translate. External system  may be, for example, a messaging system (JMS), a mail client (SMTP), EDI (Electronic Data Interchange messages), a native language call (i.e., Java to Java), data files, web-services (SOAP over HTTP), HTTP tunneling, XML messaging, etc.","API adapter  interprets requests from, and formulates responses to, external system . API adapter  also makes requests and handles responses to and from processing engine .","API adapter  may have some combination of the following exemplary responsibilities: interpret requests from external system ; basic validation of a request from external system ; identify the identity of a request from external system  and obtain the correct legacy program to run the identified request; convert a request from external system  into a format that is recognizable by processing engine ; obtain an idle processing engine  (e.g., through a connection manager); control the process flow of API calls made to the processing engine  (e.g., get field then submit data, etc.); handle errors; formulate responses from processing engine  into a format that is recognizable by external system  (as defined in the specific external system component) (e.g., XML, SOAP responses, SMTP, etc.); ensure external system  and adapter integrity (i.e., recovery from system\/connection failures, etc.); use the processing rules to control the entry of data from an electronic message into the legacy system; maintain a position of reference within an electronic message relevant to the processing stage of the legacy system; and use the processing rules to replace any decisions that a physical user would have made if a physical user was processing the message through a user interface.","API adapter  works with processing rules  in order to make decisions that would be made by an actual physical user if the session utilized an actual physical user interface. Processing rules (events)  provide a method of representing key processing stages within the legacy application to replace the decision a user would have made. For example, such processing stages include when to delete data, the submission of data, iterative block in the legacy application, how iterative blocks in the legacy application correlate against the electronic message, and alternate navigation.","Processing rules  may have some combination of the following exemplary responsibilities: control the whole process interaction between the legacy application (including unmodified legacy application user interface ) and processing engine ; emulate the decisions a user would have made when going through a user interface; cross reference iterative sections of a legacy application with the corresponding representation in the electronic message; and maintain a default set of rules across the system (i.e., submit data on every field).","Connection manager , processing engine , and unmodified legacy application user interface  have similar functionality as described above with respect to .","Although one single external system  has been illustrated and described by reference to , it is intended that multiple external system devices  may have interactions with the legacy system at the same time.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 4","FIG. 4","FIGS. 2-3","FIGS. 2-3"],"b":["200","300","200","300"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 5","b":["500","502"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6-8","FIGS. 6-8"]},"More specifically,  relates to launching a new program\/application within a legacy system, where the program\/application has been wrapped to partition the business logic and user interface of the program\/application.","At step , a client requests to launch a new program in the legacy system. For example, the program may be a Progress based application in MFG\/PRO. The client can be any device or software that is able to render a user interface, such as a web-browser, a mobile phone, a hand held terminal, a PDA, etc. The client request includes a method of identifying the program with which to launch from the legacy system. For example, this method may relate to a program name, description, etc.","At step , a server adapter obtains an idle processing engine and makes a request to launch the new program. The server adapter interprets the requests from the client based on the particular client server protocol being used. For example, such protocols could be HTTP\/HTML (web-browsers, hand held terminals, PDA's), WML (mobile phones), XML, etc.","In obtaining an idle processing engine, it may be desirable to pre-start the legacy application and hold numerous idle sessions in a pool to improve performance. Therefore, at step , the server adapter would either start a new processing engine (which starts the legacy system) or would obtain an idle processing engine from a pool of pre-started systems. After an idle session is obtained, a request is made to the processing engine to launch a new program.","At step , the obtained processing engine launches the new program via a hidden user interface into the legacy system. In order to interact with the core of an unmodified legacy application it is desirable to access functionality via a programmatically hidden user interface. For example, the programmatically hidden user interface could be based in Telnet, DOS window, or any other type of client interface. The underlying legacy application may also require minor modification in order to process requests from the processing engine. An exemplary method of sending a request from the processing engine utilizes a character sequence (or a trigger).","According to an exemplary embodiment of the present invention, the processing engine sends a request that is recognizable by the hidden user interface to launch the desired program. Once the task of launching the desired program is complete, the hidden user interface notifies the processing engine of its status. Exemplary methods for performing the response from the hidden user interface could utilize control character sequences, messages, reading specific information from the hidden user interface, or any other protocol available to link the processing engine and the hidden user interface.","At step , a determination is made as to whether a response indicating that the program has been launched has been received. More specifically, to maintain the integrity of the processing engine and hidden user interface, every request has an expected response. If the desired response (indicating that the program has launched) is not received within a give period of time (i.e., a timeout period), the processing engine performs error management at step .","The error management at step  is only encountered if some unexpected eventuality has occurred within the processing engine or the hidden user interface. It is a responsibility of step  to ensure the integrity of the underlying legacy application and also to notify the calling system that an error has occurred.","Exemplary actions at step  include reversing transactions within the legacy application (e.g., via a reset command through the hidden user interface), exiting the hidden user interface, and providing a notification to all callers of the processing engine that an error has occurred.","If it is determined at step  that the program has launched, the server adapter requests appropriate screen data at step . The request from the server adapter for the screen data is a request to the processing engine. This request could be in any structured form that can represent a screen. For example, appropriate types of structured data include XML, SVG (a sub-set of XML), objects, relational tables, etc.","Exemplary types of data that could be obtained from the screen data could be: field names; labels; field values; data-types; formatting; screen coordinates; mandatory data; colors; size; display type (i.e., toggle-box, selection list, drop down list, etc.); and so forth.","At step  the processing engine requests screen data for the legacy hidden user interface. The processing engine sends this request to the hidden user interface similarly to the launch described above at step . During step , if the predetermined process timeout period (i.e., no response is received from the hidden user interface) elapses, error management is performed at step . The error management performed is similar to the error management described above that resulted from a negative response at step .","At step , the legacy user interface generates a data representation of the screen. More specifically, upon receiving a request from the processing engine, via one of the exemplary methods described above with respect to step , a modified piece of code will be invoked on the legacy system which generates a data representation of the screen in a format as requested in step . Exemplary methods for obtaining the screen data from the legacy application may be to perform a memory walk of the screen handles, scan the runtime object code, or any other programmatic method available (dependent on the underlying programming language used).","Once the data representation of the screen is complete the structured data is transferred to the processing engine. Exemplary methods of data transfer may be via the exiting user interface, direct socket to socket connect (i.e., a point to point connection), writing to file, and so forth.","At step , the server adapter converts the data representation of the legacy screen into a format that is desirable to the client. More specifically, based on a predefined set of rules, the screen data structured object is converted into a format desirable to the client. The conversion process is dictated, for example, by the methods by which the screen data is stored and the type of client. Exemplary methods for performing the conversion could be XSLT (eXtensible Stylesheet Language-Transformations), programmatic conversion, etc.","At step , the screen data is sent to the client. More specifically, based on the original request and client type from step , the resultant new screen is sent to the client. The look and feel of the new client screen may look vastly different to the user of the legacy system user interface.","After completing the launch of a new program\/application of the legacy system as illustrated in , it may be desirable to perform any of a number of interactions with the legacy system.  illustrates an exemplary interaction process flow with the legacy system relating to submitting and\/or updating data included in the legacy system through the wrapper interface once an application has been launched.","At step , the client populates the user interface with data and submits the populated user interface. As with the exemplary process illustrated in , the client can be any device or software that is able to render a user interface, such as a web-browser, a mobile phone, a hand held terminal, a PDA, etc.","The client, having populated the user interface with data, submits the data to the server adapter. For example, the data includes a cross-reference to the corresponding data objects within the legacy system.","At step , the server adapter obtains the current clients allocated processing engine and requests to submit data. The server adapter converts the submitted data into a form that is compatible with the processing engine. For example, this format could be XML, data objects, relational tables, etc.","If the legacy system requires a stateful connection (i.e., a connection that remains active between stateless user requests), then the server adapter retrieves from a connection manager the present allocated processing engine. This may be accomplished, for example, by utilizing session references, unique keys, etc. Once a valid processing engine is obtained by the server adapter, the server adapter makes the request to submit data.","At step , the processing engine obtained by the server adapter requests the present focus object of the legacy hidden user interface. More specifically, the processing engine sends a request to the legacy application via the hidden user interface for the present focus object. This process is similar to the process described above with respect to step  of . For example, the present focus object may be a data field, a button, a radio-button, a selection list, a check box, a drop down list, etc.","During step , if the predetermined timeout period elapses, error management will be performed at step . The error management at step  is only encountered if some unexpected eventuality has occurred within the processing engine or hidden user interface. As described above, the error management is performed to ensure the integrity of the underlying legacy application, and also to notify the calling system that an error has occurred. Exemplary actions at step  include reversing transactions within the legacy application (e.g., via a reset command through the hidden user interface), exiting the hidden user interface, and providing a notification to all callers of the processing engine that an error has occurred.","Assuming a timeout has not altered the process flow to the error management at step , the legacy user interface identifies and notifies the present focus object at step . More specifically, upon receiving a request from the processing engine, via one of the methods described above with respect to step  of , a modified piece of code will be invoked on the legacy system which will identify the present focus object.","Once the focus object has been identified, a notification to the processing engine is performed. For example, the processing engine notification may be accomplished using one of the exemplary methods described above by reference to step  of .","At step , a determination is made as to whether the identified focus object is valid. The system will repeat around this step until an invalid focus object is identified. Exemplary events that would result in the identification of an invalid focus object are: new focus objects that were not enabled as part of the last screen data request; focus objects encountered twice; unrecognized\/unknown focus object; etc.","If it is determined that the identified focus object is valid at step , the focus object is cross referenced with submitted data and sent to the legacy hidden user interface with navigation. More specifically, using the identifier provided by step , a cross reference against the focus object and the submitted data is made. If an updated value is found, the value is sent down into the user interface (using normal key action commands). Any transformation of data may also be performed at this step (e.g., date transformation from dd\/mm\/yyyy to mm\/dd\/yy).","Along with the cross referenced submitted data, the corresponding navigation that is utilized to move the legacy application onward is also sent to the user interface. For example, the correct navigation could be obtained from the legacy application (e.g., as part of step ), the focus object type list, the general focus object type rules, etc.","If it is determined at step  that the focus object is invalid, the server adapter requests screen data at step . The request from the server adapter for the screen data is a request to the processing engine. This request could be in any structured form that can represent a screen. As indicated above, exemplary types of structured data include XML, SVG (sub-set of XML), objects, relational tables, etc. As above, exemplary types of data that could be obtained from the screen data include: field names; labels; field values; data-types; formatting; screen coordinates; mandatory data; colors; size; display type (i.e., toggle-box, selection list, drop down list, etc.); and so forth.","At step , the processing engine requests screen data for the legacy hidden user interface. The processing engine sends this request to the hidden user interface similarly to the launch described above with respect to step  of . During step , if the predetermined process timeout period (i.e., no response is received from the hidden user interface) elapses, error management is performed at step .","At step , the legacy user interface generates a data representation of the screen. That is, upon receiving a request from the processing engine, via one of the exemplary methods described above with respect to step  of , a modified piece of code will be invoked on the legacy system which generates a data representation of the screen in a format as requested in step  of . Exemplary methods for obtaining the screen data from the legacy application may be to perform a memory walk of the screen handles, scan the runtime object code, or any other programmatic method available (dependent on the underlying programming language used). Once the data representation of the screen is complete the structured data is transferred to the, processing engine. Exemplary methods of data transfer may be via the exiting user interface, direct socket to socket connect (point to point connection), writing to file, and so forth.","At step , the server adapter converts the data representation of the legacy screen into a format desirable for the client. More specifically, based on a predefined set of rules, the screen data structured object is converted into a format desirable to the client. The conversion process is dictated, for example, by the methods by which the screen data is stored and the type of client. Exemplary methods for performing the conversion could be, XSLT (extensible Stylesheet Language-Transformations), programmatic conversion, etc.","At step , the screen data is sent to the client. More specifically, based on the original request and client type from step , the resultant new screen is sent to the client. The look and feel of the new client screen may look vastly different to the user of the legacy system user interface.","Although the interaction described with respect to , between the user interface and the wrapped legacy system, related to the submission and update of data in the legacy system, these are only exemplary interactions. Any interactions conducted between the user interface and the wrapped legacy system are within the scope of this embodiment of the present invention. For example, the interaction may relate to data entry, data retrieval, data update, data removal, error notification, and data contention between the business logic of the application and a user of the application.","The processes described by reference to  relate to interactions between a user interface and the wrapped legacy system; however, it may also be desirable to have interactions between an external system and the wrapped legacy system. For example, the external system may be a messaging system (JMS), a mail client (SMTP), an EDI (Electronic Data Interchange messages), a native language call (i.e., Java to Java), data files, web-services (SOAP over HTTP), HTTP tunneling, XML messaging, etc.",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 8","b":"800"},"At step , the server adapter determines the identity of the message and correlates the identity of the message to the legacy application (or a portion of a legacy application in the legacy system). For example, the identity of the electronic message may include at least one of a name of the message and a version number of the message. The server adapter provides a mechanism for accepting electronic messages from an external system. Such methods of accepting messages could be in the form of web-services, HTTP tunneling, SMTP, JMS, etc.","The server adapter interprets the electronic message (which could be in XML, EDI, etc.) and determines the identity of the message. This identity is used to cross-reference the legacy application that the message will be processed against. The identity of the message may also be used to ensure the particular request is permitted on this system (for purposes of security). As such, the rules for conducting am interaction between the application within the legacy system and the electronic message are determined based on the identity of the electronic message.","At step , a determination is made as to whether the electronic message is a valid message. The electronic message is validated to ensure its structure conforms to a predetermined structure. For example, validation techniques include versioning, XML schema validation, XML DTD validation, check sums, etc.","If it is determined that the electronic message is invalid at step , the request is rejected and sent to error management at step . Step  is only encountered if some unexpected eventuality has occurred within the processing engine or hidden user interface. It is the responsibility of step  to ensure the integrity of the underlying legacy application, and also to notify the calling system that an error has occurred.","Exemplary actions at step  include reversing transactions within the legacy application (e.g., via reset command through the hidden user interface), exiting the hidden user interface, and providing a notification to all callers of the processing engine that an error has occurred. Additionally, a corresponding error electronic message is generated at step .","If it is determined that the electronic message is valid at step , the server adapter obtains an idle processing engine and requests to launch a new program at step . More specifically, it may be desirable to pre-start the legacy application and hold idle sessions in a pool to improve performance. Therefore, at step , the server adapter either starts a new processing engine (which starts the legacy system) or obtains an idle processing engine from a pool of pre-started systems.","Once an idle processing engine session is obtained by the server adapter, a request to the processing engine to launch a new program is made at step . The processing engine launches the new program via a hidden user interface into the legacy system. In order to interact with the core of an unmodified legacy application it is desirable to access functionality via a programmatically hidden user interface. Examples of interfaces that provide this functionality include Telnet, DOS window, or other types of client interface. The underlying legacy application may also require minor modifications in order to process requests from the processing engine. An exemplary method for sending a request may be a character sequence (or trigger).","In order to launch the desired program, the processing engine sends a request that is recognizable by the hidden user interface. Once the launching task is complete, the hidden user interface notifies the processing engine of its status. Exemplary methods for performing such status notification responses include formats such as control character sequences, messages, reading specific information from the hidden user interface, or any other protocol available to link the processing engine and the hidden user interface.","At step , the server adapter obtains the process rules (events) based on an identity obtained at step . The processing rules (events) relate to a method of representing key processing stages within the legacy application to replace the decision a user would have made if the interaction included a user interface. For example, such processing stages include: when data can be deleted, submitting data, iterative blocking in the legacy application, correlating the iterative block against the electronic message, and alternate navigation.","At step , a determination is made as to whether the program has been launched. In order to maintain the integrity of the processing engine and the hidden user interface, every request typically has an expected response.","If it is determined that the program has not been launched at step , or if the desired response is not received within a predetermined period of time (i.e., a timeout period), the processing engine performs error management at step .","If it is determined that the program has been launched at step , the processing engine requests the present focus object of the legacy hidden user interface at step . More specifically, the processing engine sends a request to the legacy application via the hidden user interface for the present focus object. This process is similar to that described above with respect to . Exemplary present focus objects include a data field, a button, a radio-button, a selection list, a check box, a drop down list, etc.","At step , the legacy user interface identifies the present focus object and notifies the processing engine. More specifically, upon receiving a request from the processing engine (via one of the methods described above by reference to step  of ), a modified piece of code will be invoked on the legacy system which will identify the present focus object. Once the focus object has been identified a notification to the processing engine is performed (e.g., using one of the exemplary methods described above with respect to step ).","At step , a determination is made as to whether the focus object is valid and, and also to determine if more data is available to process in the electronic message. The system will repeat around this step until an invalid focus object is identified or until there is no further data available to process in the electronic message. Exemplary events that may result in an invalid focus object are: focus objects encountered twice, unrecognized\/unknown focus object, etc.","If it is determined that the focus object is valid at step , or if it is determined that there is additional data to process in the electronic message, processing rules (events) are applied based on the focus object identity at step . More specifically, using the focus object identity, a cross-reference is made against the processing rules. Exemplary processing rules (events) that may be performed at step  include: start iteration, submit data, request delete, alternate navigation, update data, or any possible action required to process data into the underlying legacy application.","The processing rules can be defined with defaults, for example, every focus object in the legacy application could require a send data event. Exemplary types of controlling events include, for example, an iteration event and a send data event. An iteration event is a type of event that mirrors iterative data sets within the legacy application. This is used to maintain a reference of where to obtain the respective data from in the electronic message. A send data event is used to take data from the electronic message, reformat the data (where necessary), and submit the data to the legacy application along with navigation. Typically, events may be viewed as being similar to a scripting tool for the legacy application.","If it is determined that the focus object is invalid at step , or if it is determined that there is no additional data to process in the electronic message, a response message is generated for the external system at step . Depending upon the method by which the external system interacts with the server adapter, the response message may be generated to indicate either of success or failure. Exemplary response message types include XML, SOAP, HTTP, echo of original message, etc.","Types of information that could be of importance in a response message are, turnaround data (key values from original message, transaction ids, trading partner id, etc), error messages, the relationship between an error message and the original message, success\/failure, information messages, and processing information (e.g., time, date, processing time, etc.).","The various exemplary embodiments of the present invention may also be implemented through a computer readable carrier including computer program instructions which cause a computer to implement the method of separating business logic of an application from a user interface of the application, where the business logic and user interface of the application are intermingled. For example, the computer readable carrier may comprise a packaged silicon device, a solid state memory, an optical disc, a magnetic disc, a radio frequency carrier wave, and an audio frequency carrier wave.","Although this invention has been described with reference to interactions with applications\/programs within a legacy system, it is not limited thereto. The present invention is applicable to any application where the business logic and user interface are intermingled.","It will be appreciated that other modifications can be made to the illustrated embodiments without departing from the scope of this invention, which is separately defined in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Exemplary embodiments of the invention will be described with reference to the drawings, of which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
