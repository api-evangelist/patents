---
title: Device-independent control of storage hardware using SCSI enclosure services
abstract: A SES API is disclosed as an interface between SES protocol code and non-SCSI storage enclosure hardware to abstract the SES protocol code from the control of the hardware. To control the hardware, SES commands are sent to the SES protocol code. The SES protocol code is responsive to the SES commands, but has no knowledge of the hardware. The SES protocol code converts the SES command to a series of function calls. When the SES API receives the function calls, it executes the corresponding functions. The SES API includes a customer-tailored interface library of functions. The library allows the end user to provide the hardware interface routines necessary for SES to control the hardware. The functions are written as templates, separate from the SES protocol code, so that end users can modify the functions to control the hardware without having to modify or understand the SES protocol code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07590770&OS=07590770&RS=07590770
owner: Emulex Design & Manufacturing Corporation
number: 07590770
owner_city: Costa Mesa
owner_country: US
publication_date: 20041210
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates, generally, to the configuration of hardware in storage enclosures, and in particular embodiments, to the abstracted control of storage enclosure hardware using the Small Computer System Interface (SCSI) Enclosure Services (SES) protocol.","2. Description of Related Art",{"@attributes":{"id":"p-0005","num":"0004"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","104","106","108","106","112","110","114","132","124","126","128","124","132","114"]},"The RAID controllers  virtualize the SBODs  such that an initiator  on a front end  of a RAID controller  need not be concerned with how the RAID  is configured on a back end  of the RAID controller . For example, the host  may send a command  to the front end  of a RAID controller , such as a request to store data. The RAID controller  responds to this command  by initiating one or more write commands  on the back end  of the RAID controllers  according to a protocol such as a FC Arbitrated Loop (FCAL) protocol, wherein one command is required for each drive in one or more SBODs  that will store some of the requested data. Each command in the series of commands must pass serially through each crossbar switch  on each SBOD , which are daisy-chained together using dedicated FC lines , until the crossbar switch connected to the targeted drive is located.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","204","206","208","206","212","234","210","214","232","234","224","226","228","224","214"]},"The RAID controllers  virtualize the JBODs  such that an initiator  on a front end  of a RAID controller  need not be concerned with how the RAID  is configured on a back end  of the RAID controller . For example, the initiator  may send a command  to the front end  of a RAID controller , such as a request to store data. The RAID controller  responds to this command  by initiating one or more write commands  on the back end  of the RAID controllers  according to a protocol such as FCAL, wherein one command is required for each drive in one or more JBODs  that will store some of the requested data. Dual FC lines  may be provided for each connection (e.g. channel A and B) for redundancy. Each command in the series of commands must pass through crossbar switch  in root switch , which then makes the proper connection to route the commands directly the JBOD containing the targeted drive. The commands are then routed serially through each of the drives  in a loop in the JBOD  until the proper drive is located.","The various devices in the SBODs  of  or the root switch  of  need to be configured, including the non-SCSI storage enclosure hardware. In addition, these devices and hardware may store configuration information, statistics, and other information that may be of use to an end user of the storage system. Therefore, the SBODs  in  and the root switch  in  may include Ethernet ports (see reference character  in  and reference character  in ) and perhaps RS-232 serial ports (see reference character  in  and reference character  in ) to provide a management interface. However, in either case, an external connector and an external connection are required to configure the elements in the storage systems.","SCSI Enclosure Services (SES) is a protocol that has been developed to enable both SCSI and non-SCSI devices to be configured, monitored and controlled over a FC link. Essentially, SES comprises SCSI commands embedded in the FC protocol. The SES protocol is extensible and flexible to support the configuration and control of many different SCSI devices in an enclosure. Through the use of SES commands, an end user may operate a SES initiator such as a RAID controller or an HBA separate from the RAID controller to configure, monitor and control the devices within the SBODs  in  or the root switch  in  over the FC connections between the RAID controller and the SBODs or root switch.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 3"],"b":["300","302","326","332","372","314","328","348","350","352","354"]},"To configure the hardware , SES commands  are sent from a SES initiator such as a RAID controller  over the FC connection  directly to one of two FC ports  on the Vitesse\u00ae VSC120 enclosure management controller . The FC ports  allow the VCS 120 to function as a SES device provided that the appropriate software is loaded. The SES commands  are SCSI commands embedded in the FC protocol, and configure, monitor and control the hardware  within the SBOD . SES protocol code  executed by the processor  converts the SES commands  into signaling that may be sent over pre-defined hardware interface  for configuring, monitoring and controlling the non-SCSI hardware . However, because the SES protocol code  requires special code to configure, monitor and control the non-SCSI hardware , the SES protocol code  must be modified with specific knowledge of the actual non-SCSI hardware in the storage enclosure and an understanding of SES protocols. No pre-defined template for controlling non-SCSI hardware is provided, other than a very rudimentary set of functions that must be used when writing the special code to control the non-SCSI hardware. In addition, this Vitesse\u00ae VSC120 implementation allows no flexibility in the choice of processor, and does not allow for the defining of a new hardware interface if a previously unknown non-SCSI hardware device was inserted into the storage system.","Therefore, there is a need to abstract the SES protocol code from the control, monitoring and configuration of the non-SCSI storage enclosure hardware, to allow a choice of processor, and to enable the defining of new hardware interfaces.","The present invention is directed to abstracting the configuration, monitoring and control of non-SCSI storage enclosure hardware from SES protocol code. This is accomplished using a SES API as an interface between the SES protocol code and the non-SCSI storage enclosure hardware to abstract the SES protocol code from the configuration, monitoring and control of non-SCSI storage enclosure hardware.","A storage enclosure typically includes a non-blocking crossbar switch, devices such as disk drives, a processor, and non-SCSI storage enclosure hardware. The processor includes a switch API, which is source code and hardware drivers that allows the processor to make and receive function calls, control the crossbar switch, and generally communicate with the crossbar switch. The processor also includes a customer application for controlling the operation of the crossbar switch.","To configure, monitor and control the non-SCSI storage enclosure hardware, SES commands are sent from a SES initiator over a FC connection to the crossbar switch via a FC port. The SES commands are SCSI commands embedded in the FC protocol, and may be used to manage and sense the state of the non-SCSI storage enclosure hardware. The SES commands are then routed to an internal port on crossbar switch, which is connected to the switch API in the processor. The switch API then receives the SES commands from the crossbar switch, and forwards the SES commands to SES protocol code being executed by the processor.","In general, the SES protocol code enables the processor to appear as a SES device to the SES initiator. The SES protocol code understands the SCSI protocol and how to transport information across a FC link, and is responsive to the SES commands. In particular, the SES protocol code defines  devices with specific operational capabilities that can be controlled. There are also a group of end user defined devices that the end user can tailor to configure, monitor and control any type of hardware in the storage enclosure.","The SES protocol code has no knowledge of the specific non-SCSI storage enclosure hardware, and is therefore not capable of directly configuring, monitoring or controlling the non-SCSI storage enclosure hardware. However, this specific knowledge is not necessary. To perform the operation specified by a SES command, the SES protocol code converts the SES command to a series of C function calls. This set of C function calls make up the SES API. When the SES API C function is called from the SES protocol code, it executes the corresponding functions, which have been tailored for the specific hardware in the storage enclosure. For example, the functions may request certain data from a specific piece of non-SCSI storage enclosure hardware. When the data is returned by the C function, the data is passed back to the SES protocol code, which then prepares SES commands containing the data. These SES commands are sent back to the SES initiator via the switch API and the crossbar switch.","The SES API is a customer-tailored interface library of C functions. This library allows the end user to specify to the SES protocol code what non-SCSI hardware devices are supported and what state they are in (e.g. alerts, values, existence). The library also allows the end user to provide the hardware interface routines necessary for SES to control their implementation in the storage enclosure. The functions in the SES API are written as templates or starting points, separate from the SES protocol code, so that end users can modify the functions in the SES API to communicate with and control the particular non-SCSI storage enclosure hardware in the hardware enclosure, without having to modify or even understand the SES protocol code. In addition to a set of defined function calls, there is a group of get and set vendor-defined functions that can be modified for use with any type of hardware. When data is returned from one of these functions, the SES protocol code does not know what the data represents, but it sends it back anyway.","One of the advantages of this invention (the user-configurable SES API) is its upgradeability. Once the end user has invested the time to modify the template and generate functions specific to particular hardware, the processor and crossbar switch may be upgraded, and yet the same tailored SES API can be used with those upgraded devices to configure, monitor and control the same storage enclosure hardware. Another advantage is that the SES protocol code further allows an end user to verify that the SES initiator \u201csees\u201d the processor as a SES device. Once the storage enclosure is connected to the SES initiator, an end user can verify that the processor appears as a SES device to the SES initiator. This step enables the end user to verify that a functioning SES device exists, and that the FC link to that device is also operational. Thereafter, functionality can be added to the SES API to enable it to control and configure the non-SCSI storage enclosure hardware, confident that the SES protocol code is operational. Yet another advantage is that because the processor relies on the crossbar switch to provide a connection to the FC link, the processor need not have FC ports, and it can be substantially less expensive than other processors previously used. In addition, because the control of the non-SCSI storage enclosure hardware is implemented in firmware, a processor may be chosen for the hardware enclosure that fits the particular application.","In the following description of preferred embodiments, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the preferred embodiments of the present invention.","Embodiments of the present invention are directed to abstracting the configuration, monitoring and control of non-SCSI storage enclosure hardware from SES protocol code. This is accomplished using a SES API as an interface between the SES protocol code and the non-SCSI storage enclosure hardware.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 4","FIG. 4"],"b":["400","424","434","424","468","478","428","428","448","450","452","454","480","424","484","432","414","470","432","472"]},"Processor  includes a switch API , which is source code and hardware drivers that allows the processor  to make and receive function calls, control the crossbar switch , and generally communicate with the crossbar switch . Processor  also includes a customer application  for controlling the operation of the crossbar switch  and the root switch  or SBOD .","To configure, monitor and control the non-SCSI storage enclosure hardware , SES commands  are sent from a RAID controller  over a FC connection  to the crossbar switch  via a FC port . The SES commands  are SCSI commands embedded in the FC protocol, and may be used to manage and sense the state of the non-SCSI storage enclosure hardware . The SES commands  are then routed to internal port  on crossbar switch . Note that when the SES protocol code comes on-line it negotiates for an address on the loop. This address is referred to as an AL_PA. The internal port  in the switch is configured to recognize and respond to this AL_PA so when a frame is sent by the SES initiator to the SES device, the internal port  sees its AL_PA and grabs the frame. Thus, internal port  is directly connectable to the FC port , just like any other external port in the crossbar switch .","The connection between the internal port  and the processor  may be a serial bus  internal to the enclosure that provides a communication link between integrated circuits, such as the Inter-Integrated Circuit (IC) protocol, or it may be a parallel connection. Note that previous systems did not contain an internal port , making it impossible to access the processor  through the FC link , and making it impossible to respond to SES commands in the processor . The switch API  then receives the SES commands  from the crossbar switch , and forwards the SES commands  to SES protocol code .","In general, the SES protocol code  enables the processor  to appear as a SES device to the RAID controller . For a SCSI device to appear on a FC loop, it needs to understand and process certain SCSI level protocol operations. For example, a HBA may send a \u201ctest unit ready\u201d command to a SCSI device, and the SCSI device must be able to return either a yes or no. The SES protocol code  understands the SCSI protocol and how to transport information across a FC link, and is responsive to the SES commands . In particular, the SES protocol code  defines 21 devices with specific operational capabilities that can be controlled, such as temperature sensors, cooling elements, power supplies, door locks, uninterruptible power supplies, keypads, displays, and the like. For example, a temperature sensor may provide a storage enclosure temperature, a power supply may provide an undervoltage or overvoltage indication, and a door lock can be commanded to lock or unlock. There are also a group of end user defined devices that the end user can tailor to configure, monitor and control any type of hardware in the storage enclosure. Note that there is no link between the customer application  and the SES protocol code , and therefore there is no control of the SES protocol code  from the customer application .","The SES protocol code  has no knowledge of the specific non-SCSI storage enclosure hardware , and is therefore not capable of directly configuring, monitoring or controlling the non-SCSI storage enclosure hardware . However, this specific knowledge is not necessary. To perform the operation specified by a SES command , the SES protocol code converts the SES command  to a series of C function calls, such as \u201cget temperature,\u201d or \u201cget speed of fan,\u201d or the like. These C function calls make up the SES API . For example, if a SES command  seeks to read the temperature within the storage enclosure , the SES protocol code  issues a series of SES API  C function calls.","The SES API  includes a customer-tailored interface library of C functions. This library allows the end user to specify to the SES protocol code  what non-SCSI hardware devices  are supported and what state they are in (e.g. alerts, values, existence). The library also allows the end user to provide the hardware interface routines necessary for SES to control their implementation in the storage enclosure . In addition to interfacing to hardware, the SES API  allows an end user to create vendor-defined mode, inquiry, and diagnostic pages as well as fill vendor-defined fields on other pages. Note that there are certain commands in SCSI that allow an initiator to read back information from the target. One of these is the MODE SENSE command. The information that can be returned by the MODE SENSE command is separated into logical groups of related data named pages. The initiator specifies which page of data it wishes to have returned. The INQUIRY command and the READ DIAGNOSTICS RESULTS command also support this. Pages are logical groupings of data.","In general, the SES API  may include functions to (1) query the existence of an enclosure element, (2) query the status of an enclosure element, (3) control an enclosure element, (4) query the existence of a sub-enclosure, and (5) query and control elements in a sub-enclosure. To support additional vendor-defined mode pages, the SES API  may include functions to (5) query the existence of vendor-defined mode pages, (6) read vendor-defined mode pages, (7) write vendor-defined mode pages, and (8) fill in various vendor-defined fields in standard mode pages. To support additional vendor-defined diagnostics pages, the SES API  may include functions to (9) query the existence of vendor-defined diagnostics pages, (10) read vendor-defined mode pages, and (11) write vendor-defined mode pages. To support additional vendor-defined inquiry pages, the SES API  may include functions to (12) query the existence of vendor-defined Inquiry pages, and (13) read vendor-defined Inquiry pages.","When the SES API  C functions are called from the SES protocol code , it executes the corresponding functions, which have been tailored for the specific hardware in the storage enclosure . For example, the functions may request temperature data from a specific temperature sensor  in the storage enclosure . When the temperature data is returned to the function, the data is passed back to the SES protocol code , which then prepares SES commands containing the temperature reading. These SES commands are sent back to the RAID controller  via the switch API  and crossbar switch .","The functions in the SES API  are written as templates or starting points, separate from the SES protocol code , so that end users can modify the functions in the SES API  to communicate with and control the particular non-SCSI storage enclosure hardware  in the hardware enclosure , without having to modify or even understand the SES protocol code . As noted above, previous systems integrated the SES API functionality within the SES protocol code, making it extremely difficult for end users to modify the SES protocol code in accordance with the particular non-SCSI storage enclosure hardware in the hardware enclosure.","However, embodiments of the present invention separate the SES API  from the SES protocol code , so that end users need not understand the SES protocol. The SES protocol code  is FC and SES protocol specific, and defines the format of each frame and field and record that comes across the FC link. On the other hand, the non-SCSI storage enclosure hardware  may not conform to any protocol, yet may require a particular format for enabling communications with that hardware  via hardware commands . By separating the SES API  from the SES protocol code , the SES protocol code  need not know the particular format for the hardware , and the hardware  need not understand the SES protocol code .","For example, suppose there is a 4-byte representation of a temperature level that has been requested in a SES command . When the SES protocol code  receives the SES command , it issues a series of SES API  function calls, requesting the temperature level from a temperature sensor. The C function calls , which have been previously tailored by the end user for the specific temperature sensor  employed in the storage enclosure , will retrieve the temperature level from the temperature sensor  and return a 32-bit entity referred to as an \u201cunsigned long\u201d that indicates the temperature level to the SES protocol code . The SES protocol code  takes this unsigned long and puts it back in the record in the proper location. It should be understood that the end user does not have to know this format. The end user only needs to be able to modify the functions in the SES API  in accordance with the specific non-SCSI storage enclosure hardware .","The SES API  supports everything that the SES protocol code  can control, and the SES protocol code  is very flexible. In addition to a set of defined function calls, there is a group of get and set vendor-defined functions that can be modified for use with any type of hardware. When data is returned from one of these functions, the SES protocol code  does not know what the data represents, but it sends it back anyway. An exemplary set of C function calls is provided in Table I below.",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE I"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SES API FUNCTIONS"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["sapi_initializeElementClasses","This function will be called during initialization. The"]},{"entry":[{},"purpose of this function is to allow the Vendor the"]},{"entry":[{},"opportunity to register all of the element classes with the"]},{"entry":[{},"SES code."]},{"entry":["sapi_modePageExists","This function is called to determine if a particular mode page"]},{"entry":[{},"exists (i.e., supported)."]},{"entry":["sapi_readVendorSpecific","Mode pages 0x00 and 0x20-0x3E are vendor specific. This"]},{"entry":["ModePage","function is called to read one of these mode pages."]},{"entry":["sapi_writeVendorSpecific","Mode pages 0x00 and 0x20-0x3E are vendor specific. This"]},{"entry":["ModePage","function is called to write one of these mode pages."]},{"entry":["sapi_inquiryPageExists","This function is called to determine if a particular inquiry"]},{"entry":[{},"page exists (i.e., supported)."]},{"entry":["sapi_readVendorSpecific","Inquiry pages 0xC0-0xFF are vendor specific. This"]},{"entry":["InquiryPage","function is called to read one of these inquiry pages"]},{"entry":["sapi_getSESDeviceInfo","This function is used to gather information about the SES"]},{"entry":[{},"Device for the Standard Inquiry Data Page."]},{"entry":["sapi_readStdInquiryDataVendor","This function is called to fill in the second Vendor Specific"]},{"entry":["SpecificField2","field in the Standard Inquiry Data Page (starting at byte 96 of"]},{"entry":[{},"the Standard Inquiry page)."]},{"entry":["sapi_getFRUInformation","This function is used to gather information for the ASCII"]},{"entry":[{},"Information page, INQUIRY pages 0x01-0x7f. The ASCII"]},{"entry":[{},"information page contains information for the field"]},{"entry":[{},"replaceable unit code returned in the REQUEST SENSE"]},{"entry":[{},"data."]},{"entry":["sapi_getProductSerialNumber","This function is used to gather information for the Unit"]},{"entry":[{},"Serial Number page, INQUIRY page 0x80. This should be"]},{"entry":[{},"the serial number of the SES Device and not the enclosure's"]},{"entry":[{},"serial number."]},{"entry":["sapi_getOperatingDefinition","This function is used to gather the ASCII Implemented"]},{"entry":["Description","Operating Definition data used to fill in the Inquiry page"]},{"entry":[{},"0x82."]},{"entry":["sapi_getOperatingVendor","This function is used to gather the Vendor Specific"]},{"entry":["SpecificDescription","Information used to fill in the Inquiry page 0x82."]},{"entry":["sapi_getDeviceID","This function is used to gather information for the Device"]},{"entry":[{},"Identification page, INQUIRY page 0x83. The device"]},{"entry":[{},"identification page provides the means to retrieve zero or"]},{"entry":[{},"more identification descriptors applying to the logical unit."]},{"entry":["sapi_runSelfTest","This function is called when the SelfTest bit is set to one in"]},{"entry":[{},"the Send Diagnostic command. Perform the target's default"]},{"entry":[{},"self test."]},{"entry":["sapi_diagnosticPageExists","This function is called to determine if a particular diagnostic"]},{"entry":[{},"page exists (i.e. supported)."]},{"entry":["sapi_getEnclosurelnfo","This function is used to gather information about the sub-"]},{"entry":[{},"enclosures for the Configuration page. Diagnostic page"]},{"entry":[{},"0x01."]},{"entry":["sapi_getTypeDescriptorText","This function is used to gather information about the element"]},{"entry":[{},"classes for the Configuration page. Diagnostic page 0x01."]},{"entry":["sapi_getHelpText","The enclosure services help text page contains a string of"]},{"entry":[{},"characters from the enclosure that describes the present state"]},{"entry":[{},"of the enclosure and provides text indicating what corrective"]},{"entry":[{},"actions, if any, are desirable to bring the enclosure to its fully"]},{"entry":[{},"operational state."]},{"entry":["sapi_stringOut","The enclosure services string out page transmits an enclosure"]},{"entry":[{},"dependent binary string from the application client to the"]},{"entry":[{},"enclosure services process."]},{"entry":["sapi_stringIn","The enclosure services string in page transmits an enclosure"]},{"entry":[{},"dependent binary string from the enclosure services process"]},{"entry":[{},"to the application client."]},{"entry":["sapi_setThresholds","The threshold out page is transmitted to the enclosure"]},{"entry":[{},"services process to establish threshold values for those"]},{"entry":[{},"elements that have limit sensing capability, for example"]},{"entry":[{},"voltage sensors, current sensors, and temperature sensors."]},{"entry":[{},"This function is used to set the threshold for a particular"]},{"entry":[{},"element class."]},{"entry":["sapi_getThresholds","The threshold in page is transmitted from the enclosure"]},{"entry":[{},"services process to the application client to report the actual"]},{"entry":[{},"threshold values for those elements that have limit sensing"]},{"entry":[{},"capability, for example voltage sensors, current sensors, and"]},{"entry":[{},"temperature sensors."]},{"entry":["sapi_getElementDescriptorText","This function is called to fill in the Element Descriptor Page"]},{"entry":[{},"(Page 0x07)."]},{"entry":["sapi_getShortStatus","This function is called to fill in the enclosure Status of the"]},{"entry":[{},"Short Enclosure Status Page (Page 0x08)."]},{"entry":["sapi_readVendorSpecific","Diagnostic pages 0x80-0xFF are vendor specific. This"]},{"entry":["DiagPage","function is called to read one of these diagnostic pages."]},{"entry":["sapi_writeVendorSpecific","Diagnostic pages 0x80-0xFF are vendor specific. This"]},{"entry":["DiagPage","function is called to write one of these diagnostic pages."]},{"entry":["sapi_setUnspecified","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cUnspecified\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID and elementNumber."]},{"entry":["sapi_getUnspecified","This function sets the control variables for the \u201cUnspecified\u201d"]},{"entry":["ElementStatus","Element specified by the elementClassID, subEnclosureID"]},{"entry":[{},"and elementNumber."]},{"entry":["sapi_setDeviceElementControl","This function sets the control variables for the \u201cDevice\u201d"]},{"entry":[{},"Element specified by the elementClassID, subEnclosureID"]},{"entry":[{},"and elementNumber."]},{"entry":["sapi_getDeviceElementStatus","This function gets the status of control variables for the"]},{"entry":[{},"\u201cDevice\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setDeviceElement","This function sets the control variables for the \u201cDevice\u201d"]},{"entry":["ArrayControl","Element Array specified by the elementClassID,"]},{"entry":[{},"subEnclosureID and elementNumber."]},{"entry":["sapi_getDeviceElement","This function gets the status of control variables for the"]},{"entry":["ArrayStatus","\u201cDevice\u201d Element Array specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setPowerSupply","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cPower Supply\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID and elementNumber."]},{"entry":["sapi_getPowerSupply","This function sets the control variables for the \u201cPower"]},{"entry":["ElementStatus","Supply\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setCooling","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cCooling\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_getCoolingElementStatus","This function sets the control variables for the \u201cCooling\u201d"]},{"entry":[{},"Element specified by the elementClassID, subEnclosureID,"]},{"entry":[{},"and elementNumber."]},{"entry":["sapi_setTemperature","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cTemperature\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_getTemperature","This function sets the control variables for the"]},{"entry":["ElementStatus","\u201cTemperature\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setDoorlockElementControl","This function gets the status of the control variables for the"]},{"entry":[{},"\u201cDoorlock\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_getDoorlockElementStatus","This function sets the control variables for the \u201cDoorlock\u201d"]},{"entry":[{},"Element specified by the elementClassID, subEnclosureID,"]},{"entry":[{},"and elementNumber."]},{"entry":["sapi_setAudibleAlarm","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cAudible Alarm\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_getAudibleAlarm","This function sets the control variables for the \u201cAudible"]},{"entry":["ElementStatus","Alarm\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setESController","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cEnclosure Services Controller\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_getESController","This function sets the control variables for the \u201cEnclosure"]},{"entry":["ElementStatus","Services Controller\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_setSCCController","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cECC Controller\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID and elementNumber."]},{"entry":["sapi_getSCCController","This function sets the control variables for the \u201cSCC"]},{"entry":["ElementStatus","Controller\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setNVCacheElementControl","This function gets the status of the control variables for the"]},{"entry":[{},"\u201cNonvolatile Cache\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_getNVCacheElementStatus","This function sets the control variables for the \u201cNonvolatile"]},{"entry":[{},"Cache\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setUninterruptiblePS","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cUninterruptible Power Supply\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID, and elementNumber."]},{"entry":["sapi_getUninterruptiblePS","This function sets the control variables for the"]},{"entry":["ElementStatus","\u201cUninterruptible Power Supply\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_setDisplayElementControl","This function gets the status of the control variables for the"]},{"entry":[{},"\u201cDisplay\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_getDisplayElementStatus","This function sets the control variables for the \u201cDisplay\u201d"]},{"entry":[{},"Element specified by the elementClassID, subEnclosureID,"]},{"entry":[{},"and elementNumber."]},{"entry":["sapi_setKeypadElementControl","This function gets the status of the control variables for the"]},{"entry":[{},"\u201cKeypad\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_getKeypadElementStatus","This function sets the control variables for the \u201cKeypad\u201d"]},{"entry":[{},"Element specified by the elementClassID, subEnclosureID,"]},{"entry":[{},"and elementNumber."]},{"entry":["sapi_setPortTransElementControl","This function gets the status of the control variables for the"]},{"entry":[{},"\u201cSCSI Port\/Transceiver\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID, and elementNumber."]},{"entry":["sapi_getPortTransElementStatus","This function sets the control variables for the \u201cSCSI"]},{"entry":[{},"Port\/Transceiver\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setLanguageElementControl","This function gets the status of the control variables for the"]},{"entry":[{},"\u201cLanguage\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_getLanguageElementStatus","This function sets the control variables for the \u201cLanguage\u201d"]},{"entry":[{},"Element specified by the elementClassID, subEnclosureID,"]},{"entry":[{},"and elementNumber."]},{"entry":["sapi_setCommunicationPort","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cCommunication Port\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_getCommunicationPort","This function sets the control variables for the"]},{"entry":["ElementStatus","\u201cCommunication Port\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID, and elementNumber."]},{"entry":["sapi_setVoltageSensor","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cVoltage Sensor\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID and elementNumber."]},{"entry":["sapi_getVoltageSensor","This function sets the control variables for the \u201cVoltage"]},{"entry":["ElementStatus","Sensor\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setCurrentSensor","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cCurrent Sensor\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID and elementNumber."]},{"entry":["sapi_getCurrentSensor","This function sets the control variables for the \u201cCurrent"]},{"entry":["ElementStatus","Sensor\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setTargetPort","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cSCSI Target Port\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_getTargetPort","This function sets the control variables for the \u201cSCSI Target"]},{"entry":["ElementStatus","Port\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setInitiatorPort","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cSCSI Initiator Port\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_getInitiatorPort","This function sets the control variables for the \u201cInitiator"]},{"entry":["ElementStatus","Port\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setSimpleSubEnclosure","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cSimple Sub-Enclosure\u201d Element specified by the"]},{"entry":[{},"elementClassID, subEnclosureID and elementNumber."]},{"entry":["sapi_getSimpleSubEnclosure","This function sets the control variables for the \u201cSimple Sub-"]},{"entry":["ElementStatus","Enclosure\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, and elementNumber."]},{"entry":["sapi_setVendorSpecific","This function gets the status of the control variables for the"]},{"entry":["ElementControl","\u201cVendor Specific\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, elementNumber, and elementType."]},{"entry":["sapi_getVendorSpecific","This function sets the control variables for the \u201cVendor"]},{"entry":["ElementStatus","Specific\u201d Element specified by the elementClassID,"]},{"entry":[{},"subEnclosureID, elementNumber, and elementType."]},{"entry":["sapi_vendorlmplemented","This function is called for all SCSI commands received that"]},{"entry":["ScsiCmd","are not implemented by the SES code. This allows the"]},{"entry":[{},"vendor to implement additional SCSI commands if desired."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"One of the advantages of this invention (the user-configurable SES API) is its upgradeability. Once the end user has invested the time to modify the template and generate functions specific to particular hardware, the processor and crossbar switch may be upgraded, and yet the same tailored SES API can be used with those upgraded devices to configure, monitor and control the same storage enclosure hardware.","Another advantage is that the SES protocol code  further allows an end user to verify that the RAID controller  \u201csees\u201d the processor  as a SES device. Once the storage enclosure  is connected to the RAID controller , an end user can verify that the processor  appears as a SES device to the RAID controller . This step enables the end user to verify that a functioning SES device exists, and that the FC link to that device is also operational. Thereafter, functionality can be added to the SES API  to enable it to control and configure the non-SCSI storage enclosure hardware , confident that the SES protocol code  is operational.","Yet another advantage is that because the processor  relies on the crossbar switch  to provide a connection to the FC link, the processor  need not have FC ports, and it can be substantially less expensive than other processors previously used such as the Vitesse\u00ae VSC120. In addition, because the control of the non-SCSI storage enclosure hardware  is implemented in firmware, a processor may be chosen for the hardware enclosure  that fits the particular application.","Although the present invention has been fully described in connection with embodiments thereof with reference to the accompanying drawings, it is to be noted that various changes and modifications will become apparent to those skilled in the art. Such changes and modifications are to be understood as being included within the scope of the present invention as defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
