---
title: Arrangement for application message decompression
abstract: A transport layer stream with application messages, including application messages compressed according to a signalling compression method, is received and transferred to an application client, which transfers unidentified application messages to a decompression entity configured to identify and decompress application messages compressed according to the signalling compression method. The application messages compressed according to the signalling compression method are decompressed and transferred back to the application client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08452896&OS=08452896&RS=08452896
owner: Nokia Corporation
number: 08452896
owner_city: Espoo
owner_country: FI
publication_date: 20040526
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF DESCRIPTION OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to application message decompression, and more particularly to application messages compressed according to SigComp compression.","Many application protocols, like SIP (Session Initiation Protocol) or RTSP (Real-Time Streaming Protocol), used for multimedia communications are text-based and engineered for links having wide bandwidth. As a result, their messages have not been optimized in terms of size. For example, typical SIP messages range from a few hundred bytes up to two thousand bytes or more. With the planned usage of these protocols in wireless handsets as part of 2.5 G and 3 G cellular networks, the large message size is problematic. With low-rate IP connectivity the transmission delays are significant. Taking into account retransmissions and the multiplicity of messages that are required in some flows, at least call setup and feature invocation are adversely affected.","To eliminate this problem, Signaling Compression (SigComp) architecture has been defined for robust, lossless compression of application messages. In terms of the OSI model, SigComp architecture can be interpreted as an enhancement to transport layer. Thus, SigComp provides the higher layer applications for both transmission and compression of the messages. Due to its usefulness in mobile communication, 3Generation Partnership Project (3GPP) has recommended the use of SigComp at least for compressing SIP messages. Therefore, the future 3G mobile terminals must support SigComp.","The transmitting side of the SigComp architecture comprises the entities of a compressor dispatcher, one or more compressors and a state handler. The compressor dispatcher serves as the interface from the application. The application supplies the compressor dispatcher with an application message and a compartment identifier (i.e an identifier that is used for application-specific grouping of messages). The compressor dispatcher invokes a particular compressor, which returns a SigComp message to be forwarded to the remote endpoint. State handler stores and retrieves state information that is stored between SigComp messages in order to avoid the need to upload the data on a per-message basis.","The receiving side of the SigComp architecture comprises the entities of a decompressor dispatcher, an Universal Decompressor Virtual Machine (UDVM) and a state handler. The decompressor dispatcher serves as the interface towards the application. The decompressor dispatcher receives a SigComp message from the transport layer and invokes an instance of the UDVM, which decompresses the SigComp messages. The decompressor dispatcher then forwards the resulting decompressed message to the application, which may return a compartment identifier if it wishes to allow state to be saved for the message. During the decompression process the UDVM may invoke the state handler to access existing state or create new state.","The SigComp messages are transmitted as data packet flow on the transport layer along with other application messages, e.g. uncompressed SIP and RTSP messages. The SigComp messages are identified with own five-bit delimiters, i.e. they start with 11111 bits and end with 0xFFFF bits. Thus, the transport layer data stream is directed to the decompressor dispatcher, which must be arranged to identify the SigComp messages for decompression and to pass the non-SigComp messages to a particular application client, like SIP stack or RTSP.","One of the disadvantages associated with the above arrangement is that the decompressor dispatcher must be aware of all application clients and the delimiters they use. Thus, every time when a new client is introduced, the decompressor dispatcher logic must be updated. A further major problem is involved with the binary content of the application messages. The delimiters of SigComp messages may appear also in application messages, e.g. 11111 bit pattern may be found in a SIP message. This may lead to misinterpretations of delimiters in the decompressor dispatcher and result in malfunction of the dispatcher.","An object of the present invention is thus to provide a simplified method and an apparatus for implementing the method so as to overcome the above problems while simultaneously remaining compatible with the SigComp architecture. The objects of the invention are achieved by a system, methods, terminal and software products, which are characterized by what is stated in the independent claims. The preferred embodiments of the invention are disclosed in the dependent claims.","A first aspect of the invention is based on the idea of decompressing application messages, wherein a transport layer data packet stream including application messages, at least one of the application messages being compressed according to a signalling compression method, such as SigComp compression, is received. The received transport layer data packet stream is transferred to at least one application client, wherein the uncompressed application messages directed to said application client are identified. The unidentified application messages are transferred to a decompression entity configured to identify and decompress application messages compressed according to said signalling compression method, such as SigComp compression. If application messages compressed according to said signalling compression method, such as SigComp compression, are found, they are decompressed and transferred back to said application client.","According to a preferred embodiment of the first aspect of the invention, the uncompressed application messages and the application messages compressed according to SigComp compression are identified by their message delimiters.","According to a further preferred embodiment of the first aspect of the invention, a protocol layer interface is provided from said decompression entity only towards said at least one application client.","According to a further preferred embodiment of the first aspect of the invention, in said at least one application client, each of the decompressed application messages is linked to a compartment class instance.","According to a further preferred embodiment of the first aspect of the invention, said decompression entity is implemented in Symbian OS, whereby at least the following interfaces are provided from said decompression entity to Symbian OS: API to security management functionalities of Symbian OS; API to application framework of Symbian OS and API to Symbian OS Base.","A second aspect of the invention is based on the idea of compressing application messages, wherein from at least one application client at least one application message is transferred to a compression entity configured to compress application messages according to a signalling compression method, such as SigComp compression. The application message is compressed according to said signalling compression method, such as SigComp compression, and transferred back to said application client. The at least one compressed application message is then transferred to a transport layer to form a transport layer data packet stream, which thus includes at least one application message compressed according to said signalling compression method, such as SigComp compression.","According to a preferred embodiment of the second aspect of the invention, said compression entity is provided for a plug-in capability for introducing new compressors.","According to a further preferred embodiment of the second aspect of the invention, in said at least one application client, a compartment class is created for identifying the compressed application messages for the communication with a particular endpoint and a compartment class instance is allocated for each compressed application message.","An advantage of the methods and the arrangement of the invention is that the dispatchers are no longer needed. Thus, the implementation is simplified and the problem of the dispatcher logic updating is bypassed. A further advantage of the invention is that, since the responsibility of monitoring the transport layer stream is shifted to the application clients, the binary content of the application message delimiters does not cause any confusion in interpretation. A further advantage of the invention is that, since the dispatchers are not used, neither are compartment identifiers. Thus, the implementation is even more simplified. A further advantage of the invention is that due to the plug-in architecture for compressor, new compressors can be fluently introduced to the compression entity without affecting the operation of the application clients.","The invention will now be discussed by referring to the SigComp architecture as an example of the signalling compression method, in conjunction of which the invention can be implemented. The invention is, however, not restricted to the SigComp architecture, but it can be implemented in signalling compression architecture, which includes the similar elements disclosed in the enclosed claims.","Referring now to , the SigComp architecture will be further illustrated for its relevant elements. For a more detailed description of the SigComp architecture, a reference is made to IETF document 3320, ()\u201d, January 2003.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","140","150"],"i":["RFC ","RFC "]},"The SigComp architecture is designed for bi-directional message transfer. Therefore, the endpoints of the message transfer (e.g. user equipments UE of a mobile network) typically comprise all necessary elements for both compression and decompression of the SigComp messages.  shows an overview of such SigComp endpoint. The SigComp layer () is decomposed into the compressor and decompressor dispatchers (, ), one or more compressors (, ), the Universal Decompressor Virtual Machine UDVM (, i.e. the decompressor functionality) and the state handler ().","The compressor dispatcher () serves as the interface from the application (). The application supplies the compressor dispatcher with an application message and a compartment identifier (). A compartment is a group of messages that relate to a certain peer endpoint, whereby the grouping is performed by the application. Depending on the signaling protocol, this grouping may relate to application concepts such as \u201csession\u201d, \u201cdialog\u201d, \u201cconnection\u201d, or \u201cassociation\u201d. The application allocates state memory on a per-compartment basis, and determines when a compartment should be created or, closed. The compartment identifier identifies the compartment uniquely. The compressor dispatcher comprises a routing table, wherein the compartment identifiers and the compressors are linked together.","The compressor dispatcher () invokes a particular compressor (, ), which performs the actual conversion of the application messages into SigComp messages. Distinct compressors are invoked on a per-compartment basis, using the compartment identifiers supplied by the application. A compressor receives an application message (, ) from the compressor dispatcher, compresses the message, and returns a SigComp message (, ) to the compressor dispatcher. Each compressor chooses a certain algorithm to encode the data. The selected compressor returns a SigComp message to be forwarded () to the remote endpoint via the transport layer (). State handler () can store and retrieve (, ) state information (, ), i.e. information that is stored between SigComp messages, thus avoiding the need to upload the data on a per-message basis. For security purposes it is only possible to create new state with the permission of the application","The decompressor dispatcher (), in turn, forms the interface from the transport layer () towards the application (). The decompressor dispatcher receives a SigComp message () from the transport layer and invokes an instance () of the UDVM (), which provides the decompression functionality for SigComp. The UDVM is a virtual machine designed solely for the purpose of running decompression algorithms. The UDVM can be configured to understand the output of many well-known compressors, such as Deflate (disclosed in 1951). During the decompression process the UDVM may invoke () the state handler to access existing state or create new state. The decompressed application message is returned to the decompressor dispatcher to be forwarded () to the application, which may return a compartment identifier () if it wishes to allow state to be saved for the message.","When compressing a bidirectional application protocol, the choice to use SigComp can be made independently in both directions, and compression in one direction does not necessarily imply compression in the reverse direction. Moreover, even when two communicating endpoints send SigComp messages in both directions, there is no need to use the same compression algorithm in each direction.","From an application perspective the SigComp layer appears as a new transport, with similar behavior to the original transport used to carry uncompressed data (e.g. SigComp\/UDP behaves similarly to native UDP). The uncompressed application messages and SigComp messages are typically multiplexed on the same port, even though applications can reserve a new port specifically for SigComp messages.","If a particular endpoint wishes to be stateful then it needs to partition its decompressed messages into compartments under which state can be saved. SigComp relies on the application to provide this partition. So for stateful endpoints a new interface is required to the application in order to leverage the authentication mechanisms used by the application itself. When the application receives a decompressed message, it maps the message to a certain compartment and supplies the compartment identifier to SigComp. Each compartment is allocated a separate compressor and a certain amount of memory to store state information, so the application must assign distinct compartments to distinct remote endpoints.","Thus, the SigComp architecture sets several requirements of operation and implementation for both the applications and the SigComp dispatchers. While aiming to ensure the robustness of SigComp operation, these requirements, at the same time, impede the introduction of new applications and expect the dispatchers to be updated to correspond to the applications. Furthermore, the decompressor dispatcher is subject to misinterpretation of SigComp delimiters and bit patterns of uncompressed application messages multiplexed on the same data packet stream. These disadvantages are further emphasized in open platform environment, like in Symbian OS designed for mobile terminals, wherein new applications may be easily developed and introduced.","According to a preferred embodiment, these problems may be solved by a simplified SigComp architecture, wherein the primary responsibility for reading the transport layer data packet stream is allocated to the applications, and only if the application cannot recognize the content of the stream, the data packets are fed into the simplified SigComp implementation called SigComp subsystem SCSS.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2"},"For the communication with the clients (), the SCSS comprises SigComp API (Application Programming Interface) Implementation (), which is responsible for receiving application messages to be SigComp-compressed from the clients and for feeding the SigComp-compressed application messages to the clients, which deliver them to the transport layer for transmission. The compression takes place in a SigComp-compressor (), like Deflate compressor, which is advantageously introduced in the SCSS as a plug-in. Due to the plug-in architecture for the compressors, new compressors can be dynamically added to the SCSS.","For decompression purposes, the SCSS comprises the UVDM (). Thereby, the SigComp API Implementation is responsible for receiving the SigComp-compressed application messages from the clients (which have captured the messages from the transport layer stream) and for feeding the application messages decompressed by the UDVM back to the clients. The plug-in architecture for the compressors does not set any further requirements for the UVDM, since whatever compressor is used, the compressed data is always combined with a set of UVDM instructions, which allow the original data to be extracted by the UVDM.","Furthermore, in order to be fully SigComp compliant, the SCSS comprises the state handler () as a further component. For security reasons, the state of the client should not be revealed outside the peers. Therefore, the state identifier should always be encrypted with an encryption algorithm. Also the SCSS comprises an interface (, Crypto API) for the cryptography algorithms to be accessed by both the state handler and the UVDM.","If implemented in Symbian OS, said Crypto API interface () provides access to the security management functionalities of Symbian OS, wherein several encryption and hash algorithms are provided. For the Symbian OS implementation, some additional interfaces may be included in the SCSS: Plug-in Framework API () from the application framework of Symbian OS, whereby new compressor implementations can be introduced to the SCSS preferably as a plug-in, and File Server API () from Symbian OS Base, which provides the kernel, file server, device drivers, etc., which are required for the handling of application files.","As stated above, the dispatchers are not used in the SCSS configuration. Thus, neither compartment identifiers are used. The client only creates a separate compartment class instance for the communication for a particular endpoint. This is illustrated in , wherein the client () creates only one instance of CSigComp class () and as many instances of CSigCompCompartment class () as is needed. For the creation of a SigComp message, CSigCompCompartment class instance is aware of the compressor () that should be used for compression. The compressor, in turn, is aware of the state handler (), which supplies the states of the compartment, which requested the compression service for the creation of a stateful endpoint of communication. When the client creates the CSigComp class instance, it defines the compression algorithm to be used, which causes the loading of a particular plug-in compressor. The client further defines the SigComp parameters, such as memory size, cycles per bit, decompression memory size, to be used and optionally the static dictionary.","For decompression, the client forwards the received SigComp message to the CSigComp class instance and requests for decompression. The CSigComp class-instance invokes an instance of the UDVM (), which decompresses the message according to the UVDM instructions comprised by the message. The decompressed message is returned to the CSigComp class instance, which allows the client to save or deny the state. Then the decompressed message is returned to the respective application.","Thus, the usage of the dispatchers, and compartment identifiers as well, can advantageously be avoided. The routing table comprised by compressor dispatcher, in which the compartment identifiers and the compressors are linked together, is preferably not needed.","The benefits of the SCSS are further illustrated with a reference to , wherein the operation of the SCSS is linked between the application and transport protocol layers of the OSI model. For clarity reasons,  shows only a unidirectional application message flow from the first endpoint (e.g. user equipment UE of a mobile network) to the second endpoint (e.g. user equipment UE of a mobile network). It is clear that such endpoints, like mobile terminals, are typically capable of using bi-directional SigComp message transmission. It is also clear that using SigComp compression in one direction does not necessarily imply compression in the reverse direction. On the application layer, only two application protocols, SIP and RTSP, are shown as the examples. Likewise, on the transport layer only TCP is used to exemplify the implementation. Naturally, the implementation is not limited to these protocols.","The implementation is based on the principle that the applications, not the SCSS, are responsible for using the transport layer. Thus, both SIP and RTSP may deliver their uncompressed application messages (, , dash line arrows) with application-specific message delimiters directly to TCP for transmission. However, if the application messages require compression, as is often advantageous in wireless communication, the SigComp compression can be used. Then both SIP and RTSP deliver their uncompressed application messages (, ) to the SCSS for compression. The SCSS returns the SigComp messages (, , solid line arrows) with SigComp delimiters to the clients, which forward them to TCP for transmission from the first terminal UE (, ).","On the TCP layer, the uncompressed () and the SigComp compressed () messages are typically multiplexed on the same TCP stream for transmission. The second terminal UE receives the TCP stream and forwards both the uncompressed (, ) and the SigComp compressed (, ) messages to the application layer. The application clients, like SIP and RTSP, know their own application-specific message delimiters and can identify messages that belong to them. For instance, the SIP client can identify the start and the end of a SIP message, and determine the length of the message, whereby the possibly confusing binary content in the SIP message does not cause any misinterpretations.","If the application client cannot construe the content of the stream, the data packet stream (, ) is forwarded and buffered to the SCSS. The SCSS seeks to identify any SigComp messages with SigComp delimiters, and if found, it tries to decompress the messages. The decompressed application messages (, ) are returned to the particular application client. If the SCSS cannot decompress the message, then most probably the content of the stream is either corrupted or wrong, i.e. not a SigComp message. As a response, the SCSS delivers an error message to the client.","It is important to notice that the operation of the decompression functionality described above does not require that the SigComp messages included in the stream should be compressed with the SCSS, but the SCSS is fully compatible for the decompression of all SigComp messages, provided they are compressed properly with a set of UVDM instructions.","Thus, a flexible and easily updated configuration for the SigComp implementation is provided. The SCSS provides the application clients for just the necessary elements, which are needed to utilize the SigComp compression messages. The core SCSS configuration described herewith requires no updates even though the surrounding configuration, like the application clients, may be changed. For instance, if a new application client is introduced later on, no changes in the SCSS are advantageously needed, since the application clients are configured to know their own application-specific message delimiters and are thus capable of reading the TCP stream. On the other hand, new compressors can easily be added to the core SCSS due to the plug-in architecture.","The implementation of the SCSS is not restricted by the applications or the software operating system, wherein the SCSS could be implemented. As referred above, the SCSS is, however, especially useful in various open platform systems, like Symbian OS, which is an open operating system designed for mobile phone usage. Additional application message compression is often needed in wireless communication, and Symbian OS offers a flexible framework for application development, whereby new applications requiring application message compression will be introduced in the future.","Symbian OS is the operating system designed for the specific requirements of open, data-enabled 2G, 2.5 G and 3 G mobile phones. Symbian OS provides a core set of application programming interfaces (APIs) and technologies that is shared by all Symbian OS phones. The key features of Symbian OS v 7.0 are shown in . Symbian OS Base includes programming framework, i.e. kernel, user library, file server, etc., for all other components of Symbian OS. Various telephony (e.g. GSM, W-CDMA) and other communication services (e.g. TCP, IP, HTTP) are supported by Symbian OS. Separate APIs are available for multimedia and security functionalities. Application framework provides an access for user interface applications. Personal area framework includes client stacks for Bluetooth, IR and USB applications.","Symbian OS provides various application engines for contacts, schedule, messaging, browsing, etc. and integrated APIs for data management, text, clipboard and graphics. Messaging functionalities include multimedia messaging (MMS), enhanced messaging (EMS) and SMS, e-mail, file attachments and fax. Application development tools for Symbian OS include at least C++ and Java. For a more detailed description of Symbian OS, a reference is made to \u201c7.0\u201d, Rev. 2.0, April 2003, (www.symbian.com).","It should be noted that the functional elements of the SCSS according to the invention can advantageously be implemented as software, hardware or a combination thereof. The SCSS is particularly well suited for computer software implementation, which comprises computer-readable commands for controlling a processor of a user terminal, for instance, and for executing the functional steps of the invention. Advantageously the SCSS can be implemented as a program code stored on a storage medium and executed with a computer-like device, such as a personal computer (PC) or a mobile station, for providing the necessary SigComp functions with said device. Further, the SCSS functions of the invention can be loaded on the computer as a software update, whereby the functions according to the invention can be produced in the already known devices.","For the implementation of the various embodiments in a Symbian OS compatible user equipment (mobile terminal), the means for implementing the invention are preferably comprise software code for receiving transport layer data packet stream including application messages, at least one of the application messages being compressed according to SigComp compression, software code for transferring the received transport layer data packet stream to at least one application client, software code for identifying the uncompressed application messages directed to said at least one application client, software code for transferring unidentified application messages to a decompression entity configured to identify and decompress application messages compressed according to SigComp compression, software code for decompressing said at least one application message compressed according to SigComp compression, and software code for transferring the decompressed application messages back to said at least one application client.","Furthermore, said means may preferably comprise software code for transferring from at least one application client at least one application message to a compression entity configured to compress application messages according to SigComp compression, software code for compressing said at least one application message according to SigComp compression, software code for transferring the at least one compressed application message back to said at least one application client, and software code for transferring the at least one compressed application message to a transport layer to form a transport layer data packet stream including at least one application message compressed according to SigComp compression.","It will be obvious to a person skilled in the art that, as the technology advances, the inventive concept can be implemented in various ways. The invention and its embodiments are not limited to the examples described above but may vary within the scope of the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the following the invention will be described in greater detail by means of preferred embodiments with reference to the accompanying drawings, in which",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
