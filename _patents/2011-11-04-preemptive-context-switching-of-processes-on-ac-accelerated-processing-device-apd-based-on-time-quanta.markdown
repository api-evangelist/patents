---
title: Preemptive context switching of processes on ac accelerated processing device (APD) based on time quanta
abstract: Methods, systems, and computer readable media for preemptive context-switching of processes on an accelerated processing device are based upon a comparison of the running time of the process and a threshold time quanta. A method includes preempting a process running on an accelerated processing device based upon a running time of the process and a threshold time quanta.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507632&OS=09507632&RS=09507632
owner: Advanced Micro Devices, Inc.
number: 09507632
owner_city: Sunnyvale
owner_country: US
publication_date: 20111104
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION","CONCLUSION"],"p":["This application claims the benefit of U.S. provisional application No. 61\/423,488, filed on Dec. 15, 2010, which is hereby incorporated by reference in its entirety.","Field of the Invention","The present invention is generally directed to computer systems. More particularly, the present invention is directed to context-switching.","Background Art","The desire to use a graphics processing unit (GPU) for general computation has become much more pronounced recently due to the GPU's exemplary performance per unit power and\/or cost. The computational capabilities for GPUs, generally, have grown at a rate exceeding that of the corresponding central processing unit (CPU) platforms. This growth, coupled with the explosion of the mobile computing market (e.g., notebooks, mobile smart phones, tablets, etc.) and its necessary supporting server\/enterprise systems, has been used to provide a specified quality of desired user experience. Consequently, the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology.","However, GPUs have traditionally operated in a constrained programming environment, available primarily for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use, therefore, has been mostly limited to two dimensional (2D) and three dimensional (3D) graphics and a few leading edge multimedia applications, which are already accustomed to dealing with graphics and video application programming interfaces (APIs).","With the advent of multi-vendor supported OpenCL\u00ae and DirectCompute\u00ae, standard APIs and supporting tools, the limitations of the GPUs in traditional applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start, there are many hurdles remaining to creating an environment and ecosystem that allows the combination of a CPU and a GPU to be used as fluidly as the CPU for most programming tasks.","Existing computing systems often include multiple processing devices. For example, some computing systems include both a CPU and a GPU on separate chips (e.g., the CPU might be located on a motherboard and the GPU might be located on a graphics card) or in a single chip package. Both of these arrangements, however, still include significant challenges associated with (i) separate memory systems, (ii) efficient scheduling, (iii) providing quality of service (QoS) guarantees between processes, (iv) programming model, and (v) compiling to multiple target instruction set architectures (ISAs)\u2014all while minimizing power consumption.","For example, the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces (e.g., chip to chip) negatively affect memory latency and power consumption for cooperating heterogeneous processors, the separate memory systems (i.e., separate address spaces) and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.","Both the discrete and single chip arrangements can limit the types of commands that can be sent to the GPU for execution. This performance based limitation exists because the CPU may relatively quickly require the results of the operations performed by these computational commands. However, because of the high overhead of dispatching work to the GPU in current systems and the fact that these commands may have to wait in line for other previously-issued commands to be executed first, the latency incurred by sending computational commands to the GPU is often unacceptable.","For example, since processes cannot be efficiently identified and\/or preempted, a rogue process can occupy the GPU for arbitrary amounts of time. The occupying of the GPU by rogue processes for arbitrary amounts of time can prevent the effective utilization of the available system capacity, and can prevent or significantly reduce the processing progress of the system. In other cases, the ability to context switch off the hardware is severely constrained\u2014occurring at very coarse granularity and only at a very limited set of points in a program's execution.","What is needed, therefore, are methods and systems for efficiently preempting processes, such as rogue processes, from a GPU and context switching another process onto the GPU.","Although GPUs, accelerated processing units (APUs), and general purpose use of the graphics processing unit (GPGPU) are commonly used terms in this field, the expression \u201caccelerated processing device (APD)\u201d is considered to be a broader expression. For example, APD refers to any cooperating collection of hardware and\/or software that performs those functions and computations associated with accelerating graphics processing tasks, data parallel tasks, or nested data parallel tasks in an accelerated manner with respect to resources such as conventional CPUs, conventional GPUs, and\/or combinations thereof.","An embodiment of the present invention provides a system including at least one APD configured to preempt a process running on an accelerated processing device based upon a running time of the process and a threshold time quanta.","Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings, in which like reference characters identify corresponding elements throughout. In the drawings, like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit(s) in the corresponding reference number.","In the detailed description that follows, references to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","The term \u201cembodiments of the invention\u201d does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention, and well-known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example, as used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding,\u201d when used herein, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1A","b":["100","102","104","102","100","102","104","104","102","102","104"]},"In one example, system  also includes a memory , an operating system , and a communication infrastructure . The operating system  and the communication infrastructure  are discussed in greater detail below.","The system  also includes a kernel mode drive (KMD) , a software scheduler (SWS) , and a memory management unit , such as input\/output memory management unit (IOMMU). Components of system  can be implemented as hardware, firmware, software, or any combination thereof. A person of ordinary skill in the art will appreciate that system  may include one or more software, hardware, and firmware components in addition to, or different from, that shown in the embodiment shown in .","In one example, a driver, such as KMD , typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver, the driver issues instructions to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. In one example, drivers are hardware-dependent and operating-system-specific. They usually provide the interrupt handling required for any necessary asynchronous time-dependent hardware interface. Device drivers, particularly on modern Microsoft Windows\u00ae platforms, can run in kernel-mode (Ring 0) or in user-mode (Ring 3).","A benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand, user\/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user mode-drivers for low latency and high throughput requirements. Kernel space can be accessed by user module only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.","CPU  can include (not shown) one or more of a control processor, field programmable gate array (FPGA), application specific integrated circuit (ASIC), or digital signal processor (DSP). CPU , for example, executes the control logic, including the operating system , KMD , SWS , and applications , that control the operation of computing system . In this illustrative embodiment, CPU , according to one embodiment, initiates and controls the execution of applications  by, for example, distributing the processing associated with that application across the CPU  and other processing resources, such as the APD .","APD , among other things, executes instructions and programs for selected functions, such as graphics operations and other operations that may be, for example, particularly suited for parallel processing. In general, APD  can be frequently used for executing graphics pipeline operations, such as pixel operations, geometric computations, and rendering an image to a display. In various embodiments of the present invention, APD  can also execute compute processing operations (e.g., those operations unrelated to graphics such as, for example, video operations, physics simulations, computational fluid dynamics, etc.), based on commands or instructions received from CPU .","For example, commands can be considered a special instruction that is not defined in the instruction set architecture (ISA). A command may be executed by a special processor such a dispatch processor, command processor, or network controller. On the other hand, instructions can be considered as, for example, a single operation of a processor within a computer architecture. In one example, when using two sets of ISAs, some instructions are used to execute x86 programs and some instructions are used to execute kernels on APD compute unit.","In an illustrative embodiment, CPU  transmits selected commands and\/or other instructions to APD . These selected instructions can include graphics instructions and other commands amenable to parallel execution. These selected instructions, that can also include compute processing commands, can be executed substantially independently from CPU .","APD  can include its own compute units (not shown), such as, but not limited to, one or more single instruction multiple data (SIMD) processing cores. As referred to herein, a SIMD is a pipeline, or programming model, where a kernel is executed concurrently on multiple processing elements each with its own data and a shared program counter. All processing elements execute an identical set of instructions. The use of predication enables work-items to participate or not for each issued instruction.","In one example, each APD  compute unit can include one or more scalar and\/or vector floating-point units and\/or arithmetic and logic units (ALUs). The APD compute unit can also include special purpose processing units (not shown), such as inverse-square root units and sine\/cosine units. In one example, the APD compute units are referred to herein collectively as shader core .","Having one or more SIMDs, in general, makes APD  ideally suited for execution of data-parallel tasks such as those that are common in graphics processing.","Some graphics pipeline operations, such as pixel processing, and other parallel computation operations, can require that the same command stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core  in order to process such data elements in parallel. As referred to herein, for example, a compute kernel is a function containing instructions declared in a program and executed on an APD compute unit. This function is also referred to as a kernel, a shader, a shader program, or a program.","In one illustrative embodiment, each compute unit (e.g., SIMD processing core) can execute a respective instantiation of a particular work-item to process incoming data. A work-item is one of a collection is of parallel executions of a kernel invoked on a device by one or more instructions. A work-item can be executed by one or more processing elements as part of a work-group executing on a compute unit.","A work-item is distinguished from other executions within the collection by its global ID and local ID. In one example, a subset of work-items in a workgroup that execute simultaneously together on a single SIMD can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware of the compute unit (e.g., SIMD processing core). As referred to herein, a workgroup is a collection of related work-items that execute on a single compute unit. The work-items in the group execute the same kernel and share local memory and work-group barriers.","In the exemplary embodiment, all wavefronts from a workgroup are processed on the same SIMD processing core. Instructions across a wavefront are issued one at a time, and when all work-items follow the same control flow, each work-item executes the same program. Wavefronts can also be referred to as warps, vectors, or threads.","An execution mask and work-item predication are used to enable divergent control flow within a wavefront, where each individual work-item can take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work-items is not available at wavefront start time. For example, shader core  can simultaneously execute a predetermined number of wavefronts , each wavefront  comprising a multiple work-items.","Within the system , APD  includes its own memory, such as graphics memory  (although memory  is not limited to graphics only use). Graphics memory  provides a local memory for use during computations in APD . Individual compute units (not shown) within shader core  can have their own local data store (not shown). In one embodiment, APD  includes access to local graphics memory , as well as access to the memory . In another embodiment, APD  can include access to dynamic random access memory (DRAM) or other such memories (not shown) attached directly to the APD  and separately from memory .","In the example shown, APD  also includes one or \u201cn\u201d number of command processors (CPs) . CP  controls the processing within APD . CP  also retrieves instructions to be executed from command buffers  in memory  and coordinates the execution of those instructions on APD .","In one example, CPU  inputs instructions based on applications  into appropriate command buffers . As referred to herein, an application is the combination of the program parts that will execute on the compute units within the CPU and APD.","A plurality of command buffers  can be maintained with each process scheduled for execution on the APD .","CP  can be implemented in hardware, firmware, or software, or a combination thereof. In one embodiment, CP  is implemented as a reduced instruction set computer (RISC) engine with microcode for implementing logic including scheduling logic.","APD  also includes one or \u201cn\u201d number of dispatch controllers (DCs) . In the present application, the term dispatch refers to a instruction executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of work groups on a set of compute units. DC  includes logic to initiate workgroups in the shader core . In some embodiments, DC  can be implemented as part of CP .","System  also includes a hardware scheduler (HWS)  for selecting a process from a run list  for execution on APD . HWS  can select processes from run list  using round robin methodology, priority level, or based on other scheduling policies. The priority level, for example, can be dynamically determined. HWS  can also include functionality to manage the run list , for example, by adding new processes and by deleting existing processes from run-list . The run list management logic of HWS  is sometimes referred to as a run list controller (RLC).","In various embodiments of the present invention, when HWS  initiates the execution of a process from RLC , CP  begins retrieving and executing instructions from the corresponding command buffer . In some instances, CP  can generate one or more instructions to be executed within APD , which correspond with instructions received from CPU . In one embodiment, CP , together with other components, implements a prioritizing and scheduling of instructions on APD  in a manner that improves or maximizes the utilization of the resources of APD  resources and\/or system .","APD  can have access to, or may include, an interrupt generator . Interrupt generator  can be configured by APD  to interrupt the operating system  when interrupt events, such as page faults, are encountered by APD . For example, APD  can rely on interrupt generation logic within IOMMU  to create the page fault interrupts noted above.","APD  can also include preemption and context switch logic  for preempting a process currently running within shader core . Context switch logic , for example, includes functionality to stop the process and save its current state (e.g., shader core  state, and CP  state).","As referred to herein, the term state can include an initial state, an intermediate state, and\/or a final state. An initial state is a starting point for a machine to process an input data set according to a programming in order to create an output set of data. There is an intermediate state, for example, that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set","Preemption and context switch logic  can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD  may include instantiating the process, for example, through the CP  and DC  to run on APD , restoring any previously saved state for that process, and starting its execution.","APD  can also include a time quanta configuration  and a process timer . Time quanta configuration  can be a register or other storage available to APD . Time quanta configuration  can also include logic to receive and store one or more time quanta values, for example, from SWS  or KMD . Furthermore, time quanta configuration  can also include logic to change or adapt the stored time quanta values according to system conditions that are visible to the APD. The one or more time interval values stored in time quanta configuration  include a maximum time interval, herein referred to as time quanta, for which a process is allowed to be running on APD . Threshold time quanta values can be preconfigured based on various configuration parameters. In some embodiments, the time quanta configuration  can be dynamically changed in response to various factors such as system environment changes, e.g., system workload. According to an embodiment, a single time quanta configuration  applies to all processes that run on APD . According to another embodiment, separate time quanta configurations can be applied to respective processes based on criteria such as a type or priority of a process.","Process timer  can comprise one or more timers for timing the running time of processes on APD . According to an embodiment, when a process is dispatched to be run on the shader core , a corresponding timer  is started by initiating it to a time interval value in process time quanta configuration . Process timer  corresponding to the process is stopped when the process completes execution on the APD, when the process is preempted for any reason such as page faults, or when the process timer  expires after running for the duration of the configured time interval.","Memory  can include non-persistent memory such as DRAM (not shown). Memory  can store, e.g., processing logic instructions, constant values, and variable values during execution of portions of applications or other processing logic. For example, in one embodiment, parts of control logic to perform one or more operations on CPU  can reside within memory  during execution of the respective portions of the operation by CPU .","During execution, respective applications, operating system functions, processing logic instructions and system software can reside in memory . Control logic instructions fundamental to operating system  will generally reside in memory  during execution. Other software instructions, including, for example, kernel mode driver  and software scheduler  can also reside in memory  during execution of system .","In this example, memory  includes command buffers  that are used by CPU  to send instructions to APD . Memory  also contains process lists and process information (e.g., active list  and process control blocks ). These lists, as well as the information, are used by scheduling software executing on CPU  to communicate scheduling information to APD  and\/or related scheduling hardware. Memory  may also include a context save area . Access to memory  can be managed by a memory controller , which is coupled to memory . For example, requests from CPU , or from other devices, for reading from or for writing to memory  are managed by the memory controller .","Referring back to other aspects of system , IOMMU  is a multi-context memory management unit.","As used herein, context can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context can include a set of devices, the memory accessible to those devices, the corresponding memory properties and one or more command-queues used to schedule execution of a kernel(s) or operations on memory objects. On the other hand, process can be considered the execution of a program for an application that runs on a computer. The operating system can create data records and virtual memory address spaces for the program to execute. The memory and current state of the execution of the program can be called a process. The operating system may schedule tasks for the process to operate on the memory from an initial to final state.","Referring back to the example shown in , IOMMU  includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU  may also include logic to generate interrupts, for example, when a page access by a device such as APD  results in a page fault. IOMMU  may also include, or have access to, a translation lookaside buffer (TLB) . TLB , as an example, can be implemented in a content addressable memory (CAM) to accelerate translation of logical (i.e., virtual) memory addresses to physical memory addresses for requests made by APD  for data in memory .","In the example shown, communication infrastructure  interconnects the components of system  as needed, Communication infrastructure  can include (not shown) one or more of a Peripheral Component Interconnect (PCI) bus, extended PCI (PCI-E) bus, Advanced Microcontroller Bus Architecture (AMBA) bus, Advanced Graphics Port (AGP), or other such communication infrastructure. Communications infrastructure  can also include an Ethernet, or similar network, or any suitable physical communications infrastructure that satisfies an application's data transfer rate requirements. Communication infrastructure  includes the functionality to interconnect components including components of computing system .","In this example, operating system  includes functionality to manage the hardware components of system  and to provide common services. In various embodiments, operating system  can execute on CPU  and provide common services. These common services can include, for example, scheduling applications for execution within CPU , fault management, interrupt service, as well as processing the input and output of other applications.","In some embodiments, based on interrupts generated by an interrupt controller, such as interrupt controller , operating system  invokes an appropriate interrupt handling routine. For example, upon detecting a page fault interrupt, operating system  may invoke an interrupt handler to initiate loading of the relevant page into memory  and to update corresponding page tables.","Operating system  may also include functionality to protect system  by ensuring that access to hardware components is mediated through operating system managed kernel functionality. In effect, operating system  ensures that applications, such as applications , run on CPU  in user space. Operating system  also ensures that applications  invoke kernel functionality provided by the operating system to access hardware and\/or input\/output functionality.","According to an embodiment of the present invention, the operating system includes an OS memory scheduler . OS scheduler  can operate to manage scheduling of processes to be executed on APD .","By way of example, applications  include various programs or instructions to perform user computations that are also executed on CPU . CPU  can seamlessly send selected instructions for processing on the APD .","In one example, KMD  implements an application program interface (API) through which CPU , or applications executing on CPU  or other logic, can invoke APD  functionality. For example, KMD  can enqueue instructions from CPU  to command buffers  from which APD  will subsequently retrieve the instructions. Additionally, KMD  can, together with SWS , perform scheduling of processes to be executed on APD . SWS , for example, can include logic to maintain a prioritized list of processes to be executed on the APD.","In other embodiments of the present invention, applications executing on CPU  can entirely bypass KMD  when enqueuing instructions.","In some embodiments, SWS  maintains an active list  in memory  of processes to be executed on APD . SWS  also selects a subset of the processes in active list  to be managed by HWS  in the hardware. Information relevant for running each process on APD  is communicated from CPU  to APD  through process control blocks (PCB) .","Processing logic for applications, operating system, and system software can include commands and\/or other instructions specified in a programming language such as C and\/or in a hardware description language such as Verilog, RTL, or netlists, to enable ultimately configuring a manufacturing process through the generation of maskworks\/photomasks to generate a hardware device embodying aspects of the invention described herein.","A person of skill in the art will understand, upon reading this description, that computing system  can include more or fewer components than shown in . For example, computing system  can include one or more input interfaces, non-volatile storage, one or more output interfaces, network interfaces, and one or more displays or display interfaces.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1A","FIG. 1B"],"b":["104","124","124","124","124","124","125","124","162","124","124","160","166","128"],"i":["a","b","c","a","b ","c"]},"In , graphics pipeline  can include a set of blocks, referred to herein as ordered pipeline . As an example, ordered pipeline  includes a vertex group translator (VGT) , a primitive assembler (PA) , a scan converter (SC) , and a shader-export, render-back unit (SX\/RB) . Each block within ordered pipeline  may represent a different stage of graphics processing within graphics pipeline . Ordered pipeline  can be a fixed function hardware pipeline. Other implementations can be used that would also be within the spirit and scope of the present invention can be used.","Although only a small amount of data may be provided as an input to graphics pipeline , this data will be amplified by the time it is provided as an output from graphics pipeline . Graphics pipeline  also includes DC  for counting through ranges within work-item groups received from CP pipeline . Compute work submitted through DC  is semi-synchronous with graphics pipeline .","Compute pipeline  includes shader DCs  and . Each of the DCs  and  is configured to count through compute ranges within work groups received from CP pipelines and ","The DCs , , and , illustrated in , receive the input ranges, break the ranges down into workgroups, and then forward the workgroups to shader core .","Since graphics pipeline  is generally a fixed function pipeline, it is difficult to save and restore its state, and as a result, the graphics pipeline  is difficult to context switch. Therefore, in most cases context switching, as discussed herein, does not pertain to context switching among graphics processes. An exception is for graphics work in shader core , which can be context switched.","After the processing of work within graphics pipeline  has been completed, the completed work is processed through a render back unit , which does depth and color calculations, and then writes its final results to memory .","Shader core  can be shared by graphics pipeline  and compute pipeline . Shader core  can be a general processor configured to run wavefronts.","In one example, all work within compute pipeline  is processed within shader core . Shader core  runs programmable software code and includes various forms of data, such as state data.","A disruption in the QoS occurs when all work-items are unable to access APD resources. Embodiments of the present invention efficiently and simultaneously launch two or more tasks within an accelerated processing device , enabling all work-items to access to APD resources. In one embodiment, an APD input scheme enables all work-items to have access to the APD's resources in parallel by managing the APD's workload. When the APD's workload approaches maximum levels, (e.g., during attainment of maximum I\/O rates), this APD input scheme ensures that otherwise unused processing resources can be simultaneously utilized. A serial input stream, for example, can be abstracted to appear as parallel simultaneous inputs to the APD.","By way of example, each of the CPs  can have one or more tasks to submit as inputs to the APD , with each task can representing multiple wavefronts. After a first task is submitted as an input, this task may be allowed to ramp up, over a period of time, to utilize all the APD resources necessary for completion of the task. By itself, this first task may or may not reach a predetermined maximum APD utilization threshold. However, as other tasks are enqueued and are waiting to be processed within the APD , allocation of the APD resources can be managed to ensure that all of the tasks can simultaneously use the APD , each achieving a percentage of the APD's maximum utilization. This simultaneous use of the APD  by multiple tasks, and their combined utilization percentages, ensures that a predetermined maximum APD utilization threshold is achieved.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 2","FIGS. 1A and 1B"],"b":["200","200","100","200","200"]},"In step , a time quanta, or more particularly, a maximum time interval during which any particular process can be running on the APD, is configured. The time quanta can be configured as a single value which applies to any process that runs on the APD, or as a plurality of values comprising respective values for each type or priority level of processes that run on the APD. The configuration can be received from the user or may be otherwise set. In another embodiment, the time quanta can be determined by an OS or other application based on system considerations, such as, but not limited to, the current or predicted system workload. The configuration of the time quanta value can be performed by, or using, an application executing on a CPU.","In step , the CPU enqueues a process to be executed on the APD. More specifically, the CPU transmits one or more instructions to be executed on the APD. With respect to , the enqueuing of the process can include, for example, CPU  adding entries corresponding to the one or more transmitted instructions to active list  and process control blocks , as well as inputting the instructions to the corresponding command buffer . According to an embodiment, when the CPU enqueues the process to the APD, the CPU can also transmit to the APD the corresponding time quanta configuration. According to another embodiment, the time quanta configuration is common to multiple processes that execute on the APD and is therefore unnecessary for the CPU to transmit the corresponding time quanta to the APD along with information of the process to be run. The transmitting of the process information from the CPU to the APD is further described below in relation to .","In step , the APD starts running the process enqueued by the CPU. According to an example, with respect to , the running of the process on APD  may involve, the process being selected to run from the RLC , the CP  retrieving instructions of the selected process from the corresponding command buffers , the dispatch controller  dispatching the retrieved instructions to the appropriate processing pipeline of the APD  (e.g., compute pipeline , graphics pipeline ), and the running of the process on shader core  as a thread or wavefront . Graphics processing utilizes the graphics pipeline  of APD , and the compute processes utilize the compute pipeline . Both types of processes utilize shader core  of the APD for processing operations. The running of a process on the APD is farther described below in relation to .","In step , a timer corresponding to the selected APD process is started. According to an embodiment, substantially concurrently with starting to run the selected process on the APD (as described in relation to step  above), a corresponding process timer is initiated. The process timer, for example, process timer  in , is set to a maximum time interval that the selected process is allowed to run without preemption. The time interval is set to a time quanta threshold value that may have been preconfigured or dynamically determined.","According to an embodiment, the time quanta value is configured by the user or at the time of manufacture. According to another embodiment, the time quanta value is dynamically determined based upon the current system workload. For example, the system can select from among several threshold time quanta values based upon past workload or an estimation of the current and\/or future workload of the system as a whole, or of the APD.","The setting for the maximum running time for the process, such as process timer  in , may be determined based on one or more available configured time quanta values. According to another embodiment, the time quanta applied to each process can be determined based on a characteristic of the process such as its type or priority. According to yet another embodiment, a single time quanta value is applied to any process running on the APD.","In step , an expiration of the timer associated with the process currently running on the APD (i.e., the process started to run as described in step  above) is detected. For example, with respect to , the expiration of process timer  that was started substantially at the same time process  was started on shader core  is detected. The expiration of the timer can be detected, for example, when the timer reaches a value of 0 (i.e., counting down from the value set according to the corresponding time quanta). According to an embodiment, with respect to , the expiration of the timer can be notified to the CP  or other part of APD  by a message. According to an embodiment, the communication may be based upon an interrupt that may be directly or indirectly trapped by the APD. In another embodiment, the interrupt can be trapped by the operating system, such as operating system . In another embodiment, the interrupt is detected by APD  or a hardware-based scheduler such as HWS  or preemption and context switch logic .","In step , based upon the process timer expiry detected in step , preemption of the currently running process is initiated. Preemption can, for example, with respect to , be initiated by SWS  upon being invoked by an interrupt service routine servicing the interrupt generated due to the timer expiration. In one embodiment, SWS  is invoked by APD . In another embodiment, SWS  is invoked by OS . In yet another embodiment, APD  (e.g., using HWS  or preemption and context switch logic ) can detect the expiration of the timer and initiate the preemption of the current process. Preemption of the current process is further described in relation to  below.","In step , another process is context switched into running on the APD in place of the preempted process. The newly context switched process can be selected from the run list, and can be started to run within its own interval defined by a time quanta. According to an embodiment, a software-based scheduler, such as SWS , initiates the context switch of the new process. According to another example, a hardware-based scheduler, such as HWS  or preemption and context-switch logic , can initiate the context switch of the new process. Initiating the context switch may involve selecting a new process and starting to run the selected new process on APD , as described below in relation to .",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 3","FIGS. 1A and 1B"],"b":["204","204","100","302","308","204","204"]},"Step  can be performed upon, for example, an application executing on CPU  transmitting one or more instructions to be processed on APD . In step , according to an embodiment, the application calls KMD . KMD  includes logic to analyze the instruction input by the application and invokes SWS  if a process needs to be scheduled to be run on APD  to process the input instruction. For example, KMD  can determine if the input instruction relates to a process already scheduled for execution on APD , or if it relates to a instruction for which no process is currently scheduled. Already scheduled processes may have corresponding entries in the active list  and\/or RLC . If the corresponding process is already scheduled for execution on the APD, the input instruction is enqueued to the appropriate command ring . If the corresponding process if not already scheduled, then KMD  may invoke SWS  to schedule the process. SWS  can be implemented as part of KMD  or separately. According to another embodiment, the application can call a function other than KMD  to enqueue instructions to APD .","In step , the process to be scheduled is added to a list of processes to be executed by the APD. According to an embodiment, SWS  adds the process to active list . As described above, active list  may be a list of entries corresponding to respective processes to be run on APD  enqueued by a scheduler, such as SWS . Adding a process to active list  may also include adding process information to list of process control blocks . The entries corresponding to the process in active list  and process control block  may also include a pointer to one or more command buffers  that hold, or that are intended to hold, commands and other instructions associated with the process.","In step , a time quanta value is associated with the process to be run on the APD. According to an embodiment, SWS  may associate a time quanta value selected from among one or more threshold values. The time quanta value may be based upon characteristics of the process, such as process priority. The time quanta value can, for example, be associated with the entry in the process control blocks  that corresponds to the process.","In step , the process to be scheduled is sent to the APD. According to an embodiment, SWS  adds the process to a run list managed by the APD . According to an example, SWS  selects one or more entries from active list  to be added to RLC . As described above, APD  subsequently selects processes to be run from RLC .",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 4","FIG. 1"],"b":["206","206","100","402","414","206","206","206","100"]},"Step  can be performed, for example, when a APD selects a process to be run next. For example, step  can be performed when APD , or specifically a scheduler (e.g., SWS , HWS , or preemption and context switch logic ) associated with APD , selects a process from RLC , to be run on shader core . According to an embodiment, SWS  selects a process from RLC  and notifies CP  to run the selected process. According to another embodiment, a hardware-based scheduler, such as HWS  or preemption and context switch logic , selects the next process to be run from RLC . CP  and dispatch controller  dispatches instructions from command buffers  that correspond to the selected process to be executed.","In step , it is determined whether the selected process has a saved state. For example, CP  may determine if the selected process has a saved state in memory  from a previous run on shader core . The selected process may have previously been running on shader core  and may have been preempted and its state saved. The address in memory  at which the state is saved may be obtained from the corresponding entry in list of process control blocks .","If the selected process has a saved state, as determined in step , then in step  the saved state is restored. Restoring of the saved state may involve the retrieving the state information from system memory  and configuring the relevant registers and the like with the state of the selected process. Restoring of the saved state can include restoring the program counter, constant values, variable values, and the like. Restoring the state can involve restoring wavefront state (e.g., state common to all threads of a wavefront) such as program counter, and state of individual threads (e.g., variables, data). In general, graphics processes or processes that occupy the graphics pipeline can have a larger amount of state than a process occupying the compute pipeline.","In step , the time quanta to be configured for the current run of the process are determined. For example, the value of the time quanta with which time quanta configuration  is set to and from which timer  is initiated is determined in step . In one example, the time quanta value used is the threshold time quanta that is preconfigured for use with all processes or a group of one or more processes to which the selected process belongs. This, for example, is the case when the selected process has previously run for its full time quanta and was preempted. In another example, if the selected process was preempted in its previous run prior to the expiration of the time quanta, then the new time quanta value can be configured as the time remaining when the previously used up time is subtracted from the full time quanta value. The determined value is configured in time quanta configuration .","In step , the selected process is run on the shader core using the restored state. For example, CP  can start running of the selected process on the shader core . As described in relation to step  of , a timer  can be started substantially at the same time that the selected process begins to run. Timer  may expire when the configured time quanta is exceeded and the selected process has not yet completed running or has not otherwise been preempted from running on the APD .","If, in step , it is determined that the selected process has no previously stored state, then processing proceeds to step . In step , the value of the time quanta to be associated with the running time of the selected process is determined. The time quanta can be based upon a threshold value, or, as described above, can be determined based on the system environment. In an example, the SWS  can configure a time quanta for the selected process, which is then used by CP  to configure time quanta configuration .","Subsequent to configuring the time quanta in, for example, time quanta configuration , the selected process is run on shader core  in step . For example, CP  can start running of the selected process on the shader core .",{"@attributes":{"id":"p-0109","num":"0108"},"figref":["FIG. 5","FIGS. 1A and 1B","FIG. 2"],"b":["212","212","100","502","514","212","212","206","100"]},"In step , an interrupt generation mechanism detects the expiration of a timer. For example, interrupt generator  may detect the expiration of timer  when a process  has been running on shader core  for a time interval corresponding to time quanta configuration .","In step , the interrupt generator generates an interrupt indicating the expiration of the timer . As described above, interrupt generator  can be implemented as part of APD , as part of IOMMU , or separately.","In step , an interrupt handler in the OS  receives the interrupt. For example, interrupt controller  can trap the interrupt generated by the APD-associated interrupt generator . Interrupt controller  may identify the interrupt as one due to time quanta expiration on the APD and would invoke an interrupt handling routine to handle the interrupt.","In step , the OS initiates the preemption of the process currently running on the APD. According to an embodiment, OS  or OS scheduler  can invoke SWS  to initiate the preemption process. As described above, SWS  can be implemented as part of KMD  or as a separate module.","In step , SWS  transmits an instruction to the APD  to stop the current process. CP , upon receiving the instruction to stop the current process, can stop further dispatch of instruction for the process currently executing on the APD and then stop the execution of the process. According to an embodiment, there may be a time interval that the CP  waits for after the stop instruction before proceeding to the next steps.","In step , the context for the current process (i.e., process stopped in step ) is saved. Saving of the context can involve saving state that is common to a wavefront and also the state local to individual threads of that wavefront. The amount of state to be saved may differ between compute processes that occupy the compute pipeline and graphics processes that occupy the graphics pipeline.","Saving context may involve saving either or both, the wavefront state of the process and the individual thread state of the process, out to system memory. According to one embodiment, the preemption of a compute process involves saving the wavefront state and thread state of the current compute process executing on shader core  to a context save area  in system memory . Context saving for a graphics process may involve only the wavefront state (i.e., state common to all threads) being saved to the context save area  in system memory . Graphics processes, for example, can have very large amounts of thread-level state which can be time-consuming to save to system memory. The address in memory  at which the context is to be saved can be provided by the OS  or can be determined at runtime and can be recorded with process information in PCB .","In step , SWS  transmits an instruction to remove the current process from the sun list. For example, SWS  may monitor the context save completion of the current process, and upon determining that the context save is over, transmit a instruction to remove the process from the RLC .","Having completed the preemption of the current process from executing of the APD, SWS  can proceed to context switch a new process to execute on the APD, as described in relation to step  of .","The Summary and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor(s), and thus, are not intended to limit the present invention and the appended claims in any way.","The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.","The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can, by applying knowledge within the skill of the art, readily modify and\/or adapt for various applications such specific embodiments, without undue experimentation, without departing from the general concept of the present invention. Therefore, such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments, based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation, such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.","The breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents.","In an embodiment, a computer readable medium stores instructions, where the instructions, if executed cause, a method to set a threshold time quanta and preempt a process running on an accelerated processing device based upon a running time of the process and a threshold time quanta. In an embodiment, the preemption includes detecting a timer expiration indicating that the running time is equal to or greater than the threshold time quanta. In an embodiment, the preempting includes generating an interrupt corresponding to the timer expiration and initiating of the preemption by an operating system based on receipt of the interrupt. In an embodiment, the preempting includes detecting the timer expiration by a hardware-based scheduler and initiating of the preemption by the hardware-based scheduler based on receipt of the interrupt."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["The accompanying drawings, which are incorporated herein and form part of the specification, illustrate the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the pertinent art to make and use the invention. Various embodiments of the present invention are described below with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
