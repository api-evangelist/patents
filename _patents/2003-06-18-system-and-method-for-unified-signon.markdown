---
title: System and method for unified sign-on
abstract: A mechanism is provided for signing on a user of a first domain into an affiliate application in a second domain. When the user needs access to the affiliate application, the request for access causes a ticket to be generated. The ticket identifies the user and is passed to an adapter. The adapter, which ultimately will perform the sign on in the affiliate application, redeems the ticket for the user's credentials (e.g., a valid userID/password combination for the affiliate application), and then presents the credentials to the affiliate application. A service is provided that issues tickets, redeems tickets, manages the registration and de-registration of affiliate applications, manages the correlation between a user and the user's credentials with an affiliate application, and manages encryption of stored records.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07392536&OS=07392536&RS=07392536
owner: Microsoft Corporation
number: 07392536
owner_city: Redmond
owner_country: US
publication_date: 20030618
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates generally to the field of distributed computing. More particularly, the invention provides a mechanism whereby a user who has signed on in a first domain may sign on to a second domain without having to manually enter the sign-on credentials in the second domain.","In a distributed computing environment, resources or services that a user needs to access may be spread out across different computers. As one example, each employee in an enterprise may have a desktop or laptop computer, which accesses files stored in a central cluster of file servers. Each of these various computers may be controlled by a sign on procedure that requires presentation of credentials. For example, the user may have to enter a valid userID\/password combination in order to gain access to the computer. Typically, once a user is signed onto his or her desktop or laptop, he or she does not have to enter a userID\/password combination again in order to access the file server, because the file server and the user's computer are part of the same domain.","However, in some cases a user may be working in a first domain (e.g., an environment based on the MICROSOFT WINDOWS operating systems), and may need to access information in a second domain of a different type (e.g., a cluster of computers based on the UNIX operating system). The second domain may maintain its own userIDs and passwords, and may require that the user sign-on to the second domain separately. Conventionally, when the user attempts to access the second domain, the second domain will present the user with a prompt to enter a userID and password for the second domain, which is clearly an inconvenience to the user. It is desirable to allow the user to access the second domain seamlessly\u2014i.e., given that the user has signed onto the first domain, it is desirable to allow the user to access resources and services under his corresponding userID in the second domain, without having to manually enter the userID\/password combination for the second domain.","In view of the foregoing, there is a need for a system and method that overcome the drawbacks of the prior art.","The present invention provides a mechanism whereby a user who has signed onto a first domain can sign onto a second domain without having to explicitly tender his credentials. For example, the first domain may be an environment based on the MICROSOFT WINDOWS operating systems, and the second domain may be an environment based on the UNIX operating system. In order to use the second environment, the user will have to be signed onto the second environment, and generally must tender a user identifier (\u201cuserID\u201d) and password for that environment. In accordance with the invention, the user may use a service in the first domain to register a mapping between his persona in the first domain, and his corresponding userID\/password combination in the second domain. When the user attempts to access the second domain, an adapter in the first domain tenders the registered userID\/password combination on the user's behalf, without requiring the user's direct involvement. Thus, it may appear to the user as if he can seamlessly access the second domain merely by virtue of having signed on to the first domain. A mechanism that permits such access to the second domain is referred to herein as a single sign-on (\u201cSSO\u201d) system.","An SSO system in accordance with the invention operates in the first domain, and manages access to \u201caffiliate applications.\u201d An affiliate application is an environment to which access is controlled by credentials, and which the user may access from the first domain. Thus, a UNIX environment, access to which requires that the user login with a userID and password, is an example of an affiliate application. Similarly, an SAP application running in the UNIX environment is also an example of an affiliate application, since the SAP application may require that the user sign onto the SAP application, in addition to logging into the surrounding UNIX environment. Each affiliate application is associated with an \u201cadapter.\u201d An adapter presents the user's credentials to a particular application. For example, the adapter for a UNIX system may be configured to enter the user's userID and password in response to the prompts \u201clogin:\u201d and \u201cpassword:\u201d. Similarly, the adapter for an SAP application running in a UNIX environment may be configured to first log the user into a UNIX system (using a first userID\/password combination), and then sign the user onto the SAP system (using a second userID\/password combination). Preferably, each affiliate application has its own adapter that is configured to negotiate the presentation of the user's credentials with that particular affiliate application.","The adapters are used in the following manner. When a user requests to access an affiliate application, the request is sent to a middleware software object that handles certain types of requests (e.g., outbound HTTP requests, etc.) from the user. (Alternatively, the application that the user is using may function as the middleware object, in which case the request need not be sent to such object.) The middleware object determines that the user is requesting access to an affiliate application, and then contacts an SSO service to obtain a ticket for the user. The SSO service maintains a database, which contains tables that map each user to his corresponding credentials in affiliate applications, and also contains information relating to the management of affiliate applications. When the SSO service receives a ticket request, it issues a ticket for the user, which preferably contains the user's current domain, the user's userID in the current domain, and an expiration time. In a preferred embodiment, the ticket does not need to identify the external application that the user seeks to access, or the adapter that will be used to perform the access. Once the ticket is issued, the ticket is returned to the middleware object.","The middleware object then sends the ticket to the adapter that will negotiate the presentation of credentials to the affiliate application. The adapter then sends the ticket to the SSO service, with a request to redeem the ticket. The SSO service receives the ticket and redemption request, and then looks up the user's credentials for the affiliate application in the SSO service's database. Before looking up the credentials, the SSO service preferably determines that the userID under which the adapter is running is authorized to redeem tickets. Additionally, inasmuch as a user may have a different set of registered credentials for each of the different affiliate applications, the SSO service identifies a particular set of credentials based on which adapter is making the redemption request. Since each affiliate application preferably has its own adapter, the identity of the adapter making the request, combined with the identity of the user specified in the ticket, is sufficient to identify the particular set of credentials that are needed to access the affiliate application on the user's behalf. Preferably, the SSO service encrypts the ticket upon issuance, and decrypts the ticket when the SSO service receives the redemption request. In a preferred embodiment, an instance of the SSO does not persistently store the encryption\/decryption secret, but rather copies the secret from a server that maintains a master encryption secret to perform the encryption and decryption.","In a preferred embodiment, the privilege to control the SSO service, and the privilege to affect the contents of the database in which credentials are stored, is governed by a set of groups whose members have various different sets of privileges. Preferably, these groups include: (1) an admin group, whose members can perform any action within the SSO system; (2) an affiliate admin group, whose members can add and delete affiliate applications, and can define membership in lower-level groups; (3) for each affiliate application, an application admin group, whose members can affect the credential mappings relating to that particular affiliate application, and who can define membership in the user groups for that affiliate application; and (4) for each affiliate application, an application user group, whose members are registered to use that affiliate application.","Preferably, credential mappings are stored in the SSO service's database in a form encrypted by a secret. In some cases, it is desirable periodically to change the secret. In this case, a rolling re-encryptor runs through the credential mappings, decrypts the mappings with the old secret, and re-encrypts the mappings with the new secret. During the re-encryption process, credentials may be encrypted with either one of the two secrets. Thus, each secret has an identifier associated therewith, and each encrypted datum specifies the identifier of the secret with which it is encrypted. Thus, all of the encrypted data in the database can be decrypted, even while the process of re-encrypting the data with a new secret is underway.","Other features of the invention are described below.","Overview","When a user accesses various different computers in a single domain, the user signs on to a computer once and will then be recognized by other computers in the domain without having to sign on again. However, in many cases, a user may be working in one domain and need to access another domain, thereby requiring that the user enter a userId and password in the other domain. The present invention provides a mechanism whereby a user in one domain may have his credentials (e.g., userID and password) tendered in the other domain on his behalf, thereby making it appear to the user as if he is seamlessly signed onto both domains.","Exemplary Computing Environment",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, embedded systems, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules and other data may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit  may represent multiple logical processing units such as those supported on a multi-threaded processor. The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus). The system bus  may also be implemented as a point-to-point connection, switching fabric, or the like, among the communicating devices.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Sign-on Across Domains in a Multi-Domain Environment","The invention addresses the situation in which a user, who is signed on in one domain, may need to access an application that exists outside of the domain (an \u201caffiliate application\u201d), access to which is conditioned upon a set of sign-on credential.  shows an exemplary environment in which this situation may occur.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2","FIG. 2"],"b":["201","202","204","206","201","202","110","1","110","2","110","3","201","201","110","1","110","1","201"]},"Access to domain  (and to the resources that a particular user is permitted to access within that domain) is controlled by \u201ccredentials.\u201d In the example of , the credentials are a user identifier (\u201cuserID\u201d) and password combination. At the initiation of a session in domain , the user is asked to present a valid userId and password combination. If a valid combination is presented, then the user gains access; if a valid combination is not presented, then the user does not gain access. Even if the user presents a valid combination, the particular resources to which the user has access is typically based on which userId the user has presented to sign on. Thus, signing on as \u201chenry\u201d may give the user access to different resources (e.g., different files, different devices, etc.) than would be available if the user had signed on under another userId (e.g., \u201cjames\u201d).","The set of valid credentials is maintained in a credential record . In the example of , credential record  is a table that correlates each known userId with it's correct password. Credential record  shows that \u201chenry\u201d and \u201cjames\u201d are valid userIDs for domain , with passwords \u201cdog\u201d and \u201ccat,\u201d respectively. It should be understood that credential record  is merely exemplary, and a variety of other types of credential records are possible. For example, as an alternative to storing the actual password for a given userID, credential record  could store a hash of the password, a reference to a password stored elsewhere, or any other type of information that can be used to determine whether a userID\/passwords combination is valid. Additionally, credentials are not limited to userID\/password combinations, but may be based on any other type of authenticating information, such as a digital certificate stored on a smart card, biometric information such as fingerprints or retinal features, etc.","A user within domain  may need to access an affiliate application, such as a computer in a separate domain , or a specific application running on such a computer. For example, computer  may participate in domain , and a user who is signed onto domain  may need to access a service provided by computer . Domain  maintains its own credential record , which is different from credential record . Thus, a userID\/password combination that is valid in domain  may not be valid in domain . In this example, credential record  does not list \u201chenry\u201d and \u201cjames\u201d as valid users, but does list \u201cHSMITH\u201d and \u201cJJONES\u201d as valid users. In the example of , both domains  and  use userID\/password combinations as credentials, although it should be understood that two domains need not use the same type of credentials\u2014e.g., domain  might accept userID\/password combinations, and domain  might use digital cryptographic certificates.","It may be the case that a given person has a set of valid credentials in both domains  and . For example, a person named \u201cHenry Smith\u201d may have the userID \u201chenry\u201d in domain , and \u201cHSMITH\u201d in domain . Moreover, there may be some services that Henry Smith needs to access in domain  while working in domain . Thus, Henry Smith, while signed on as \u201chenry\u201d in domain  may use remote communications software to access domain  (e.g., by connecting to computer ), and may then use his valid credentials in domain  to gain access to those services. Conventionally, when Henry Smith contacts a computer in domain , he will be prompted to enter his userID\/password combination, at which time Henry Smith would enter \u201cHSMITH\u201d as the userID and \u201cfish\u201d as the password. The invention, however, provides a mechanism through which Henry Smith's persona in domain  (i.e., userID=\u201chenry\u201d) can be correlated with Henry Smith's persona in domain  (i.e., userID=\u201cHSMITH\u201d), so that software running in domain  can lookup Henry Smith's credentials for domain  and tender those credentials to the authentication process in domain .",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 3","FIG. 3","FIG. 2"],"b":["201","135","110","1","202","135","201","135","202","202","201","135","201","202","180","202","201","202","201","135","202"]},"In the example of , it is presumed that software  can: (1) determine which credentials in domain  correspond to the currently-signed-on user \u201chenry,\u201d (2) access \u201chenry's\u201d corresponding userID\/password combination for domain , and (3) negotiate the presentation of those credentials to the authentication process running in domain . Creating software that provides this functionality presents certain challenges, however. As described below, the invention provides various mechanisms that allow these functions to be achieved.","Architecture to Support Sign-On Across Domains",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 4","FIG. 4"],"b":["201","201","202","135","201","202","202","202"]},"In order to permit client application  to access the payroll records in domain , client application  communicates to middleware  a request to access domain . (Client application  may contain the functionality of middleware object , in which case the request need not be communicated to a separate object.) Middleware  may, for example, be the engine for a transport protocol, such as Hypertext Transfer Protocol (HTTP) or Secure Hypertext Transfer Protocol (HTTPS). Middleware  then issues a request  for a \u201cticket.\u201d The ticket, if ultimately issued, will be redeemable by adapter  for the credentials that will be needed to access domain  on \u201chenry's\u201d behalf; the manner in which the ticket can be redeemed is described in greater detail below. The ticket request  is issued to an SSO service , running on the computer on which middleware  operates. As one example, SSO service  may be implemented as a service of an operating system, although SSO service  may be implemented as any other type of software object with which middleware  can communicate. (As noted above, the functionality of middleware  may be contained within client application , in which case client application  communicates with SSO service  directly.) An exemplary structure of SSO service  is described in greater detail below in connection with .","When middleware  issues request , middleware  preferably \u201cimpersonates\u201d the user \u201chenry.\u201d Thus, middleware  is preferably not running as \u201chenry,\u201d but the underlying system in which the request is issued may have the capability to allow a process running under one userID to issue a request to a service as if the request came from a different userId. For example, in the WINDOWS operating systems, a service can impersonate a currently-logged-in user.","SSO service  receives ticket request , and issues a ticket for the user who has made the request. As noted above, middleware  impersonates the underlying user (\u201chenry,\u201d in this example), so SSO service  concludes that the request has come from \u201chenry,\u201d and issues a ticket  that will entitle adapter  to redeem ticket  for \u201chenry's\u201d credentials. (It should be noted that SSO service  only issues a ticket for the user making the request (or the user has been impersonated); since only valid, logged-in users can be impersonated, this scheme ensures that a ticket can only be issued for a user who has been authenticated and is logged in.) Preferably, ticket  includes an expiration time (e.g., two minutes into the future), so that it cannot be redeemed beyond its expiration time. In a typical scenario, it is expected that adapter  will perform the sign-on procedure with domain  in the very near future (e.g., within the next few seconds), so an attempt to redeem ticket  long after it was issued may be symptomatic of an attempt by a rogue party to learn a user's credentials. Imposing a relatively short expiration time on ticket  guards against this type of attempt to compromise the secrecy of user credentials. Additionally, the ticket is preferably encrypted with a key that is only known to a component accessible by an SSO service; this encryption of the ticket guards against the creation of counterfeit tickets.","Once middleware  has received ticket , middleware  sends ticket  to adapter . Adapter  issue a redemption request  to SSO service  in order to redeem ticket . Adapter  is a software component that runs on a computer in domain . One of the functions performed by adapter  is to negotiate the presentation of a user's credentials to an application in domain . Adapter  is running under a particular userId within domain . Typically, adapter  runs under the userID of a privileged user, who is known to SSO service  as someone who is entitled to redeem tickets. When SSO service  receives ticket  with redemption request , SSO service  determines whether the userId under which adapter  is running is entitled to redeem tickets. The manner in which SSO service  makes this determination is discussed in greater detail below in connection with . Assuming that the userID under which adapter  is running is entitled to redeem tickets, SSO service  retrieves, from credential store , the credentials  for the user identified in -ticket  (e.g., the credentials that user \u201chenry\u201d will need to gain access to his corresponding \u201cHSMITH\u201d account in domain ). Since ticket  is preferably encrypted, SSO service  decrypts ticket  in order to determine which user is identified in ticket . Before retrieving credentials , SSO service  preferably ensures that the expiration time specified in ticket  has not elapsed; if ticket  has expired, then SSO service  does not retrieve credentials . If redemption of a ticket fails (e.g., because of expiration date, or because the redemption request has come from a non-authorized entity), then in a preferred embodiment an appropriate error code is returned to the adapter, and an error log message is generated.","As discussed in greater detail below in connection with , a user in domain  may have several different sets of corresponding credential stored in credential store . These different sets of credentials may correspond to the various different affiliate applications (e.g., different domains, or different credential-controlled applications within a given domain) that a given user may need to access. In a preferred embodiment, a user (in domain ) may have a different set of credentials for each affiliate application. Additionally, each affiliate application has its own adapter\u2014i.e., one adapter may negotiate a user's access to affiliate application A (requiring one set of credentials), and another adapter may negotiate a user's access to affiliate application B (requiring a different set of credentials). Preferably, SSO service  determines which set of credentials to retrieve based on which adapter is making the request. Thus, SSO service  retrieves, from credential store , the particular set of \u201chenry's\u201d credentials that are associated with adapter . In an alternative embodiment, a single adapter may be designed to sign onto plural affiliate applications, in which case the adapter either requests the credentials for all affiliate applications that the adapter is designed to work with, or else requests the credentials for the particular affiliate application that the adapter needs to sign the user onto.","After credentials  have been retrieved from credential store , SSO service  provides credentials  to adapter . In a preferred embodiment, SSO service  caches the credentials, which facilitates efficient retrieval of those credentials if they are requested again in the near future. When credentials are cached, SSO service frequently (e.g., every 30 seconds) checks the cached credentials against a log of changes to credential store , in order to ensure that the credentials have not been changed since they were cached. (Preferably, changes to credential store  are stored in a log as they are made. This logging of changes not only facilitates cache validation, but also facilitates auditing of credentials store .)","After adapter  has received credentials , adapter  then uses credentials  to gain access to domain . For example, adapter  may contact a computer (e.g., computer ) in domain , and request to sign-on. Computer  then invokes its authentication process (i.e., the process by which it allows a user seeking access to tender credentials), and allows adapter  to use credentials  to sign on as the user identified in the credentials. In the case where credentials  comprise a userID\/password combination, computer  may present adapter  with prompts (e.g., the prompt strings \u201clogin:\u201d and \u201cpassword:\u201d), and adapter  will respond by presenting the userID and password specified in credentials . It should be noted that an adapter can be created to handle any type of authentication process that computer  may require, and thus the architecture of  can be used regardless of what type of system domain  might be (e.g., UNIX system, IBM Mainframe, Oracle database, etc.). In particular, it should be noted that in some cases the affiliate application to which the user is attempting to gain access is not merely a domain itself, but rather a particular application running in that domain\u2014e.g., an SAP application running in a UNIX environment. Thus, an adapter for the SAP application may: (1) sign the user onto the UNIX system, and (2) after gaining general access to the UNIX system itself, sign the user onto the SAP application. An adapter can be created to negotiate any type of credential-presentation, as required by the particular type of affiliate application to which access is sought.","It should be noted that  shows two separate instances of SSO service . An instance of SSO service  is typically provided on each computer at which SSO service 's functions may be required. In the architecture of , different software components that use SSO service  may be running on the same computer, or may be running on different computers. In the example of , middleware  and adapter  are each running on different computers, and thus each of these components communicates with its own instance of SSO service . However, if middleware  and adapter  are running on the same computer, they may each communicate with the same instance of SSO service .","Tickets","As described above, the architecture of  uses a ticket , which is a data item whose function is to be redeemable for a user's credentials. An exemplary structure for ticket  is shown in .","Ticket  preferably comprises fields for: a domain , a userID , and an expiration time . Ticket  may, optionally, comprise flags , which can be used to specify certain behaviors of SSO service  in the ticket redemption process.","Domain field  specifies the domain of the user account for which ticket  is requested. In the example of , the request for ticket  request is for the user named \u201chenry\u201d in the Redmond domain, so domain field  contains \u201cRedmond\u201d (or some other datum that identifies the \u201cRedmond\u201d domain).","UserID field  specifies the identity of the user on whose behalf ticket  was requested. In the example of , ticket  was requested on behalf of the user \u201chenry,\u201d so userID field  contains the string \u201chenry.\u201d","Expiration time field  specifies the time at which ticket  expires. For example, if ticket  was requested on Jan. 1, 2003 at 1344 h, then expiration time field  may contain Jan. 1, 2003 at 1346 h (two minutes after the ticket was requested).","It should be noted that the ticket need not contain the identity of the adapter that will ultimately retrieve the credentials. As noted above, each set of credentials is associated with a particular user and a particular adapter. Thus, when ticket  is redeemed, SSO service  will identify which credentials to provide based on: (1) the user identified in ticket , and (2) the adapter making the request. Thus, even though ticket  does not specify which adapter is expected to redeem the ticket, the adapter that redeems the ticket will receive only the credentials that relate to the affiliate application managed by that adapter, and not some other set of credentials for the user named in the ticket. In fact, when the exemplary structure of  is used for a ticket, the same ticket may be redeemed by different adapters for different sets of credentials.","In a preferred embodiment, tickets may be redeemed through a call to SSO service . In one example, SSO service  exposes a \u201cvalidate_and_redeem_ticket\u201d API (Application Programming Interface), which works as follows:","The ticket preferably contains the user for whom the host credential lookup needs to be done. The sender of the message to the adapter itself could be different. The sender of the message could send multiple copies of the same ticket. If the sender of the message is not the same as the user in the ticket, then host credentials cannot be looked up.","In the BizTalk system, a trusted BizTalk application can send a message to the adapter and \u201cact\u201d as if the sender is really the user.","Untrusted applications can also send a message to the adapter to do the host credential lookup and if the user in the ticket is same as the sender of the message, host credential lookup can be done. If not, access is denied.","The adapter will call SSO such that it passes the context of the message and the affiliate application name for which the host credentials need to be looked up. SSO exposes the API (\u201cvalidate_and_redeem_ticket\u201d) to the adapter writers. This API compares the sender of the message and the user in the ticket. If they are the same, the ticket is redeemed and the host credentials are returned to the user. If they are different, access is denied. This error is returned to the adapter and an event is logged.","Exemplary Structure for an SSO Service","SSO service  manages the information used by the single sign on process of the present invention, and exposes various functions that can be used by participants in the process. As described above in connection with  SSO service  exposes functionality that is used to issue and redeem tickets. In addition, SSO service  preferably exposes functionality that enables: the registration and deletion of affiliate applications; the mapping of user IDs in domain  into user IDs in domain ; and the definition of which users have various levels of privilege within the SSO system.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 6","FIG. 7"],"b":["408","408","604","402","410","408","408","408","408","408"]},"Information used by SSO service  is stored in database . For example, credential store  (shown in ), which correlates users in domain  with their corresponding credentials in other domains , is stored within database . Additionally, database  may store a table of registered affiliate applications, and tables of which users have various different levels of privilege with respect to the SSO system. Typically, each domain has one database . If SSO service  is running on a computer other than the one on which database  resides, then that instance of SSO service  accesses database  remotely. Alternatively, copies of the contents of database  may be stored on each machine that provides SSO service , and the various copies of database  may by synchronized frequently.","SSO service  may handle certain data in an encrypted form. For example, as noted above, tickets  are preferably encrypted. Additionally, the credentials stored in database  are preferably encrypted. The security of the information protected by encryption depends on the secret (e.g., the decryption key) that is used to decrypt the information not being divulged. To support this level of security, the secret preferably is not persistently stored on every instance of SSO service , but rather is kept by master secret server . Master secret server may be a special instance of an SSO service , which is adapted to provide the master secret to other instances of SSO service . In general, instances of SSO service  (other than the master secret server ) copy the master secret to themselves, and store the secret locally (but not persistently) to be used as necessary. The master secret server  may also perform various other functions relating to encryption or decryption. (One such \u201cother\u201d function\u2014rolling re-encryption\u2014is described below in connection with .)","One example use of master secret server  is in the ticketing\/redemption process. When a ticket request is issued to an instance of SSO service , SSO service  may generate the ticket and then copy secret  from master secret server  so that SSO service  can encrypt the ticket with secret . When the ticket is redeemed, the instance of SSO service  that receives the ticket copies secret  from master secret server , and then uses secret  to decrypt the ticket. Additionally, instances of SSO service  copy secret  from master secret server  when the secret is needed to encrypt the credentials that are stored in database , and to decrypt those credentials when necessary to redeem a ticket.","SSO service  may, for example, be embodied as a collection of one or more executable files. As noted above, SSO service  may be a service provided by an operating system, in which case these executables may be invoked when the operating system is started. In one embodiment, SSO service  comprises different executable files for the various functions that SSO service  provides\u2014e.g., one executable for ticketing functions, another to create and delete mappings, another for maintaining the master secret, and so on. (When a separate executable exists for maintaining the master secret, this executable is preferably run only in the instance of SSO service  that functions as the master secret server.)","Exemplary Privileges Hierarchy","As described above, an SSO system in accordance with the present invention handles user credentials in order to gain access to a computer system on behalf of a particular user. Credentials should thus be handled in a manner that ensures that they will not be revealed to other users, or used to gain access on behalf of an unauthorized user. Thus, in a preferred embodiment the SSO system of the present invention employs a hierarchy of permissions that governs which users are allowed to perform which functions with respect to the SSO system.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 7"},"Admin group  is at the top of the hierarchy. Admin group  contains users who are allowed to perform any function within an SSO system. For example, users in admin group  are permitted to access or change master secret , or to enable\/disable the SSO system. Users in admin group  are also permitted to define the membership in admin group  and affiliate admin group  (discussed below) (e.g., by adding or deleting members).","Affiliate admin group  contains users who are permitted to add and delete affiliate applications (e.g., affiliate applications (), (), and ()). Members of affiliate admin group  are also permitted to define membership in application admin groups, which are described below. Additionally, members of affiliate admin group  can perform any action that members of the various application admin groups and application user groups (described below) are permitted to perform.","Each affiliate application is associated with an application admin group. Thus, affiliate applications (), (), and () are associated with application admin groups (), (), and (), respectively. Each of the application admin groups (), (), and () has the ability to control the user mappings (), (), and (), respectively that relate to that group's affiliate application. (A mapping is an entry in the credential store that correlates a particular user with his credentials for a particular affiliate application.) Thus, members of application admin group () can add, delete, or change user mappings () that are used to access affiliate application (). Likewise, members of application admin groups () and () can add, delete or modify mappings () and (), respectively. It should be noted that members of an application admin group preferably do not have plenary access to the credential store, but only the ability to affect mappings related to a particular affiliate application. Members of application admin groups are also permitted to redeem tickets; as discussed below, the adapter, which needs to redeem tickets, must be run as a member of the application admin group. Additionally, members of an application admin group can define the membership of the corresponding affiliate application's application user group. The application user groups are described below.","Each affiliate application is further associated with an application user group. Thus affiliate applications (), (), and () are associated with application user groups (), (), and (), respectively. Members of an application user group are the users who are permitted to use the SSO system to sign on to the application user group's corresponding affiliate application. Thus, the membership of group () is the set of users for whom the SSO system has stored credentials for affiliate application (). Likewise, groups () and () contain the users for whom credentials have been stored for affiliate applications () and (), respectively.","In a preferred embodiment, a userID in an application admin group is used to run: (1) the adapter for application admin group's affiliate application, and (2) any software that allows admins to add, delete, and modify the credentials for an affiliate application. Thus, when the adapter for affiliate application () runs, it will preferably run under a userId in application admin group (). Additionally, there may be software that permits a user to change his credentials for affiliate application () (i.e., the user's entry in mapping ()); this software also preferably runs under a userID in application user group (). It should be noted that that the existence of application admin groups (), (), and () is advantageous, because it avoids having to run an adapter at the level of an administrator who may have plenary access to the entire SSO system. If an adapter had to be run at the level of a plenary administrator (e.g., admin group  or affiliate admin group ), then the adapter would be able to affect mappings for all affiliate applications, and would also be able to add or delete affiliate applications from the system. By defining application admin groups that can access the mappings for their own affiliate applications, but cannot access the mappings for any other applications, the potential for the system to be sabotaged by an adapter whose behavioral integrity has been compromised is reduced.","Similarly, the separate existence of admin group  and affiliate admin group  allows control over the master secret on the one hand, and the adding\/deleting of affiliate applications on the other hand, to be parceled out separately. Thus, a set of users can be given the power to add and delete affiliate applications by assigning those users to affiliate admin group , and a smaller number of users (e.g., one highly-trusted user) can be given access to master secret  by assigning those users (or that one user) to admin group .","Exemplary Structure for Storing Affiliate Credentials",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 8"},"The exemplary structure comprises two tables  and . Table  comprises four columns. The attributes of the columns are NTD (\u201cNT Domain\u201d), NTU (\u201cNT User\u201d), XA (\u201cexternal Application\u201d), and XU (\u201cexternal User\u201d). (The use of \u201cNT\u201d in the first two attributes refers to the fact that the originating domain (e.g., domain , shown in , , and ) is typically a MICROSOFT WINDOWS NT environment, or an environment based on a successor to the WINDOWS NT operating system, such as the WINDOWS 2000 or WINDOWS XP operating systems. However, it will be understood that the invention is not limited to the case where the originating domain is based on the WINDOWS operating system.) Each row of table  stores the name of the domain and user name of a user who will sign on to an affiliate application (columns NTD and NTU), the name of the affiliate application to which the user will be signed-on (column XA), and the user's corresponding userID for the external application. Thus, in the example of , table  contains a row for the user \u201chenry,\u201d indicating that he is in the \u201cRedmond\u201d domain, that he may use an affiliate application named \u201cUNIX,\u201d and that the user name that should be used for the UNIX affiliate application is \u201cHSMITH.\u201d Similarly, the user \u201cjames\u201d contains an entry indicating that he is in the \u201cRedmond\u201d domain, and will use the \u201cUNIX\u201d affiliate application with the userID \u201cJJONES.\u201d A user who is permitted to use more than one affiliate application may have more than one entry in table . For example, \u201cjames\u201d has a second entry indicating that he can use the affiliate application named \u201cIBM\u201d with the userID \u201cJJ\u201d.","Table  comprises three columns, with attributes XA, XU, and XP. XA and XU have the meanings explained above, and XP refers to the \u201ceXternal password.\u201d Table  contains a row for each XA\/XU combination, and lists the password that is to be used for the affiliate application in the XA column when signing on for the user in the XU column. Thus, table  lists \u201cfish\u201d as the password that should be used for the userID \u201cHSMITH\u201d in the \u201cUNIX\u201d affiliate application, \u201cbird\u201d as the password that should be used for the userID \u201cJJONES\u201d in the \u201cUNIX\u201d application, and \u201celephant\u201d as the password that should be used for the userID \u201cJJ\u201d in the \u201cIBM\u201d affiliate application. As noted above, some affiliate applications\u2014e.g., the case of an SAP application running in a UNIX environment\u2014may require more than one userID\/password combination. If, for example, the adapter will present a first userID\/password combination to sign onto a UNIX system, and then a second userID\/password combination to sign onto an SAP application within that UNIX system, then the second userID\/password may be stored in the XP column. In such a case, an entry in the XP column will contain: (1) the password for the UNIX system; (2) the userId for the SAP application; and (3) the password for the SAP application. (The userID for the UNIX system can still be stored in the XU field.) Table  can store any type of data in any column, and this data is passed verbatim to the adapter when the adapter redeems a ticket. Thus, an adapter for the above-mentioned UNIX-SAP combination will be configured to separate the three components contained in the XP field, and to use those components accordingly. In the most general case, the XP field can store any type of credentials that may be required by an affiliate application, and the adapter for that affiliate application will be configured to interpret and use the data contained in that field in a manner appropriate for the affiliate application.","When the credentials needed for a particular user to sign onto a particular affiliate application need to be retrieved (e.g., during a ticket redemption), SSO service  (shown in ) looks up the current domain\/user\/affiliate application combination in table . Based on the domain\/user\/affiliate application combination, table  is used to look up the user's userID (i.e., in the XU column) for the affiliate application that the user will be signed-on to. After retrieving the userId from the XU column, SSO service  uses the combination of affiliate application and affiliate-userID (i.e., the XA and XU columns) to lookup the user's password in the XP column of table . In effect, XA and XU together are a candidate key for table ; since there are (presumably) no two users with the same name in a given affiliate application, the combination of XA and XU should uniquely identify a row of table , and thus the user's password for the affiliate application can be looked up in table  based on the XA\/XU combination.","It should be noted that the structure shown in  is advantageous in the sense that it permits the decoupling of affiliate user names from affiliate passwords. Thus, if a user (such as \u201cHSMITH\u201d) should change his password on an affiliate application, then a change only needs to be made to table . As long as the user HSMITH in the affiliate application continues to correspond to the user \u201chenry\u201d in the \u201cRedmond\u201d domain, no change needs to be made to table .","When the SSO system is set up, the table may be initially populated with certain credential information. For example, password tables (e.g., for domain  and\/or domain ) may be exported into an XML (eXtensible Markup Language) structure, and then imported into the SSO database. Typically, the passwords will not be included in the XML structure, and users (or, possibly, administrators) can set the passwords in the SSO database at a later time. As another example, a software object may be used to retrieve the userIDs and passwords for all relevant systems, and can populate the SSO database with the userIDs and passwords.","Exemplary Process for Signing Onto an Affiliate Application",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 9"},"At step , a user (e.g., \u201chenry\u201d), who is signed onto a domain (e.g., domain , shown in , , and ) requests access to an affiliate application in a different domain (e.g., domain ). The request may be made explicitly by the user (e.g., the user may explicitly request access to domain ), or the request may be made on the user's behalf in a manner that is transparent to the user (e.g., the user may be using software in domain , and that software may, in the course of performing its normal function, automatically request contacts domain  to obtain some information on the user's behalf).","The user's request is sent to a piece of software that handles the request\u2014e.g., middleware  (shown in ). Middleware  then requests a ticket from the SSO service (step ). As described above in connection with , when middleware  requests a ticket, middleware  preferably impersonates the underlying user (e.g., \u201chenry\u201d) who seeks to access an affiliate application. As further described above, the functionality of middleware  may be incorporated into an application that the user is using, rather than being a separate component.","When the SSO service receives the ticket request, the SSO service issues a ticket for the user who made the request (step ). Since middleware  has preferably impersonated the underlying user who seeks to access an affiliate application when submitting the ticket request, SSO service concludes that the request came from that user (e.g., from \u201chenry\u201d), and thus issues a ticket for that user. Preferably, the ticket that is issued includes: the domain of the requesting user (e.g., \u201cRedmond\u201d), the userID of the requesting user (e.g, \u201chenry\u201d), and an expiration time (e.g., two minutes after the ticket is issued). Additionally, the ticket may include certain flags, as described above in connection with . When the SSO service issues the ticket, it provides the ticket to middleware .","When middleware has received the ticket, it passes the ticket to an adapter (step ). The particular adapter that receives the ticket is the one that handles sign on for the affiliate application that the user (e.g., \u201chenry\u201d) seeks to access. That adapter, in turn, contacts the SSO service to redeem the ticket (step ).","When the SSO service receives the ticket and the redemption request, it determines whether the request has come from a user who is entitled to redeem a ticket (step ). As described above in connection with , each affiliate application (and it's corresponding adapter) is associated with an \u201capplication admin group,\u201d and the adapter is generally run under one of the userIDs in that group. Members of the application admin groups are authorized to redeem tickets. When the SSO service receives a redemption request, it sees the userID of the process that is making the request, so the SSO service may verify that this userId is in the application admin group. (As described above in connection with , admin group  and affiliate admin group  have a superset of the privileges of the application admin groups; however, it is preferable to run the adapters under a particular application admin group instead of a higher-level group, so that the adapter cannot modify or access data relating to other adapters.)","If the SSO service determines that the user attempting to redeem the ticket is not authorized to redeem tickets, or if the ticket is expired, then the SSO service does not redeem the ticket, returns an error, and generates an error log message (step ). If, however, the SSO service determines that the redemption request does come from a valid user and is non-expired, then the SSO service looks up the credentials for the user identified in the ticket, and returns those credentials to the requesting adapter (step ). As described above in connection with , credentials are preferably unique to a particular combination of user and affiliate application, and thus the SSO service sends a particular set of credentials based on: (1) the user named in the ticket, and (2) the identity of the affiliate application for which the ticket is being redeemed. As further noted above, the ticket is preferably encrypted, so the SSO service typically obtains the decryption secret from the master secret server  (shown in ) in order to decrypt the ticket.","Once the adapter receives the credentials, it uses the credentials to sign on to the affiliate application (step ). For example, a computer in a different domain (e.g., computer  in domain , shown in ) may prompt the adapter to enter a userID and password, and the adapter may provide the userId and password in response to the prompt. The affiliate application then validates the credentials (step ). If the credentials are not valid (e.g., if the userID\/password combination is not listed in credential record , shown in ), then the sign on procedure fails (step ). Otherwise, the user is signed onto the affiliate application (step ), and can proceeds to access services and\/or resources provided by the affiliate application.","Rolling Encryption of Credential Records","As described above in connection with , certain data (e.g., tickets and the stored credential records) are protected by a secret  (e.g., an encryption\/decryption key) maintained by master secret server  (shown in ). As is known in the art of cryptography, when large amounts of encrypted data are available to observers for a long period of time, there is a significant opportunity for observers to analyze the encrypted data and deduce the key, or otherwise to break the encryption scheme. Therefore, it is desirable to change secret  from time to time. However, since database  (shown in ) stores credential records encrypted by secret , discarding the original secret  and replacing it with a new secret would make all of the encrypted records inaccessible, since they could no longer be decrypted. One solution is to decrypt all records with the old secret, re-encrypt the records with a new secret, and then discard the old secret. However, given the volume of data that may be stored in database , the process of decrypting and re-encrypting could take database  out of service for a significant amount of time.","In a preferred embodiment of the invention, when it is desired to change secret , credential records stored in database  can be re-encrypted with a new secret on a \u201crolling\u201d basis.  shows a mechanism for such rolling re-encryption of the credential records. In the example of , two secrets () and () are maintained, and each secret has a secret ID (secret ID and secret ID). Credential records  are associated with the secret ID of the particular secret that was used to encrypt the record. (For simplicity,  shows credential records as existing all in one table. However, as described above in connection with , credential records may be spread out in pieces across several tables. It will be understood that a secret ID can be associated with an entire credential as shown in , or with a piece of a credential table. In general, a secret ID may be associated with any blob of encrypted data that is decryptable with the secret corresponding to that secret ID.)","Re-rencryptor  traverses the encrypted credential records in some order. In the example of , all credential records are initially encrypted with the secret having ID and it is desired to re-encrypt those records with the secret having ID. Thus, as re-rencryptor  traverses credential records , it decrypts each record using the secret identified by ID, and then re-encrypts the records with the secret identified by ID. Each time that re-encryptor  re-encrypts a record, it associates the newly-encrypted record with secret ID. Thus, for any credential record, it can be determined upon examination of the record's associated secret ID whether the record is encrypted with the secret () or (). After all records have been re-encrypted with secret (), then secret () can be discarded.","It should be noted that secret  (shown in ) is also used to encrypt tickets. Thus, in a preferred embodiment in which secret  can be changed, a ticket may also include the ID of the secret that was used to encrypt a ticket.","A re-encryptor as described in  avoids having to take database  off-line while all of its data is re-encrypted, because both the old and new secrets can continue to be used during the re-encryption process. Additionally, re-encryptor  can be run as a \u201cbackground\u201d process, so that it works while demand for the system is low.","It is noted that the foregoing examples have been provided merely for the purpose of explanation and are in no way to be construed as limiting of the present invention. While the invention has been described with reference to various embodiments, it is understood that the words which have been used herein are words of description and illustration, rather than words of limitations. Further, although the invention has been described herein with reference to particular means, materials and embodiments, the invention is not intended to be limited to the particulars disclosed herein; rather, the invention extends to all functionally equivalent structures, methods and uses, such as are within the scope of the appended claims. Those skilled in the art, having the benefit of the teachings of this specification, may effect numerous modifications thereto and changes may be made without departing from the scope and spirit of the invention in its aspects."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
