---
title: System and method for testing memory power management modes in an integrated circuit
abstract: A memory controller, a method of testing memory power management modes in an integrated circuit and an integrated circuit. In one embodiment, the memory controller includes a power management mode test controller couplable to a test access port and at least one memory core and configured to respond to a signal provided via the test access port by providing an ordered signal-setting sequence to the at least one memory core to cause the at least one memory core to enter into and exit from at least one memory power management mode.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08090965&OS=08090965&RS=08090965
owner: LSI Corporation
number: 08090965
owner_city: Milpitas
owner_country: US
publication_date: 20080417
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF CERTAIN ASPECTS AND EMBODIMENTS","1. Introduction","2. Memory Power Management Modes","3. Power Management Mode Testing Issues","4. TAP-Based Testing","5. BIST Embodiments with Preset Measurement Time","6. BIST Embodiments with Adjustable Measurement Time","7. Enhanced BIST Embodiments for Diagnosis"],"p":["The invention is directed, in general, to integrated circuit (IC) testing using a test access port and, more specifically, to a system and method for testing memory power management modes in an IC.","Small, low-power integrated circuits (ICs), such as application-specific ICs (ASICs) and application-specific standard products (ASSPs), are finding ever-increasing application in a wide variety of battery-powered, mobile devices. This is likely to continue and accelerate. Not only have these ICs begun to employ embedded memories, those memories are occupying an ever-increasing percentage of the total area of the IC. Embedded memories, including static random access memories (SRAM), consume power even when they are inactive.","Modern memories are equipped with one or more memory power management modes (e.g., standby, retention and power down modes) to reduce the power they consume while they are inactive. Memories are placed in a low-power mode until needed again. While in a low-power mode, they consume considerably less power and can significantly increase the duration of a battery charge.","ICs should be tested following manufacture to ensure their proper operation. For this reason, ICs are typically provided with a test access port (TAP) that conforms to Institute of Electrical and Electronics Engineers, Inc., (IEEE) 1149.1, or Joint Test Access Group (JTAG), standard. JTAG specifies a \u201cboundary scanning\u201d technique in which a tester (also called automated test equipment, or ATE) connected to the TAP via a JTAG (serial) bus provides one or more patterns of zeroes and ones (a \u201ctest pattern\u201d) to the IC and receives a resulting (\u201coutput\u201d) pattern of responses by the IC to the test pattern. An output pattern that does not match expectations indicates a failed test. The output pattern may be analyzed to determine the nature of the IC failure and perhaps where in the IC the failure occurred.","Manufacturing testing should extend to the one or more low-power modes that IC memories may be able to attain. Unfortunately, testing memory power management modes involves strict timing, which JTAG's limited bandwidth may not be able to maintain as memory sizes expand and speeds increase. What is needed in the art is a better way of testing memory power management modes in an IC.","To address the above-discussed deficiencies of the prior art, one aspect of the invention provides a memory controller. In one embodiment, the memory controller includes a power management mode test controller couplable to a TAP and at least one memory core and configured to respond to a signal provided via the TAP by providing an ordered signal-setting sequence to the at least one memory core to cause the at least one memory core to enter into and exit from at least one memory power management mode.","Another aspect of the invention provides a method of testing memory power management modes in an IC. In one embodiment, the method includes: (1) providing a signal to a power management mode test controller via a TAP and (2) providing, with the power management mode test controller, an ordered signal-setting sequence to the at least one memory core to cause the at least one memory core to enter into and exit from at least one memory power management mode.","Yet another aspect of the invention provides an IC. In one embodiment, the IC includes: (1) functional logic, (2) a TAP coupled to the functional logic and (3) memory coupled to the functional logic and the TAP and including at least one memory core and a memory controller coupled thereto, the memory controller having a power management mode test controller configured to respond to a signal provided via the TAP by providing an ordered signal-setting sequence to the at least one memory core to cause the at least one memory core to enter into and exit from at least a retention mode and a power down mode.","The foregoing has outlined certain aspects and embodiments of the invention so that those skilled in the pertinent art may better understand the detailed description of the invention that follows. Additional aspects and embodiments will be described hereinafter that form the subject of the claims of the invention. Those skilled in the pertinent art should appreciate that they can readily use the disclosed aspects and embodiments as a basis for designing or modifying other structures for carrying out the same purposes of the invention. Those skilled in the pertinent art should also realize that such equivalent constructions do not depart from the scope of the invention.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1A","FIG. 1A","FIG. 1A"],"b":["120","110","120","120","121","120","122","121","122","122","121","122","122","122","122"]},"The IC  further has a TAP  coupled to the functional logic  and the memory . The TAP  may comply with any conventional or later-developed standard. In the embodiment of , the TAP  complies with the JTAG standard. Accordingly, the tester  couples via a JTAG bus to the TAP  and thereby to the functional logic  and the memory .","In various embodiments to be illustrated and described, a specialized controller, hereinafter called a power management mode test controller, is associated with, e.g., located within, the memory controller. The power management mode test controller is responsible for testing the memory in response to test patterns provided by the tester. In certain embodiments to be illustrated and described herein, the power management mode test controller:","fully tests the specs for entry and exit from the low power modes. More specifically, certain of the embodiments ensure that the memory remains in some intermediate states for no more than one clock cycle;","efficiently monitors the memory outputs during the low power modes;","either provides a preset duration or an adjustable duration for low power modes;","allows testing of a low power mode with or without its clock; and","allows the number of global wires to be reduced.","Various embodiments of the system and method described herein provide:","a power management mode test controller that is included in the IC to facilitate diagnosis; and","diagnostic techniques that use the power management mode test controller for diagnosis.","Certain embodiments allow a greater degree of diagnosis resolution than the prior art, determining not only that a memory has failed, but pinpointing a particular memory core within the memory that has failed. Other embodiments are capable of identifying multiple failing memory cores, perhaps spanning multiple memories. The power management mode test controller may take the form of a state machine capable of transitioning among a plurality of states depending upon signals provided to the controller.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1B"],"b":["124","122","120"]},"Additional pins, power management mode (PMM), retention (RET) and power down (PD), are provided for power management. These pins, along with ME, may be used as described below. Three power management modes are available in the memory core of : (i) stand-by, (ii) retention and (iii) power down mode.","In the stand-by mode, the internal (memory) clock is turned off. ME is set to 0, and PMM, RET, PD are set to 0. Turning off the internal clock eliminates dynamic power consumption. However, leakage currents continue to consume power. The stand-by mode was adequate by itself for older memory technologies where the leakage current component of overall power consumption was relatively low. In this example, the stand-by mode is not tested. Instead, the focus is on testing the other two modes of power management operation: the retention mode and the power down mode.","In the retention mode, dynamic power is completely eliminated by switching off the internal clock. In addition leakage power is reduced by turning off the power supply to the peripheral logic, such as address decoders. In the retention mode, the content of the memory is guaranteed to be retained once it exits from of the retention mode. To accomplish this while reducing leakage power, the supply voltage to the cells and the repair registers is reduced as far as possible. Thus, the total power consumption in the retention mode is substantially lower than the standby mode.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 2","FIG. 1B","FIG. 2"],"b":["124","124","210","220","230","240","250","260","210","124","124","220","124","220","220"]},"If PMM is set to 1 in the STAND-BY state , the memory core  makes a transition to the PM_INIT state . If RET is thereafter set to 1 a subsequent clock cycle, the memory core  enters the PM-RETAIN state . While in the PM-INIT and PM-RETAIN states , , the external memory clock can be on or off. Entry into the retention mode is now complete. The output of the memory core  is held at 0. The time taken to enter the PM-RETAIN state  from the NORMAL state  is referred to herein as \u201centry latency,\u201d symbolized in  by a left-hand brace . The PMM and RET signals are asynchronous signals. However, if a synchronous system changes the PMM and RET signals during a functional mode, the minimum entry latency is four functional clock cycles.","The memory core  may be kept in the PM-RETAIN state  indefinitely, but a sequence of state transitions must be undertaken if an exit from the PM-RETAIN state  back to the NORMAL state  is desired. To exit the PM-RETAIN state , RET is first set to 0, causing the memory core  to transition to the PM-RESTORE state . Then, PMM is set to 0, causing the memory core  to transition to the STAND-BY2 state . Finally, ME is set to 1, causing the memory core  to transition back to the NORMAL state . During this exit process, the external clock to the memory can be on or off, and the memory output is held at 0. In addition, the memory core  is required to remain in the STAND-BY2 state  for at least one clock cycle. The time taken to go from the PM-RETAIN state  to the NORMAL state  is referred to herein as \u201cexit latency,\u201d symbolized in  by a right-hand brace . Using the same assumptions for entry, the minimum exit latency is four functional clock cycles.","The third power management mode is the power down mode. In this mode, the internal clock is turned off to eliminate dynamic power consumption. In addition, the contents of the memory core  are not guaranteed to be retained when it comes out of the power down mode. Therefore, the power supply to the cells can be turned off, and all leakage currents in the memory core  are eliminated. The power down mode does, however, guarantee that for memories equipped with BISR the repair solution is retained, and the memory is functional once it comes out of the power down mode. The memory power consumption in the power down mode is the lowest.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 3","FIG. 1B","FIG. 2"],"b":["340","240","124","340"]},"In the following discussion, it is assumed that the memory core and BISR logic are taken into account while designing the power management modes. However, depending on what type of built-in self-test (BIST) logic may be provided, it could continue to drain power in the retention and power down modes.","Next, What constitutes a sufficient test of memory management modes should be defined. In brief, a sufficient test is deemed to be a parametric test in which the specifications outlined in  are tested for each memory core in the memory.","To test against these specifications fully, each memory core instance is made to enter and exit from the power management modes (into and out of PM-RETAIN and PMPwrDwn). Two passes of the transitions to enter into and exit out of PM-RETAIN, PMPwrDwn should be made: one with the external clock to the memory turned on and one without the external clock to the memory turned on.","While in the PM-RETAIN or PMPwrDwn modes, and while exiting from these states, the output of the memory core should be checked to ensure that it remains set to 0.","Finally, the entry and exit latencies should be as small as possible. It is preferable that each of the entry and exit latencies totals only four functional clock cycles. A different clock exists for each clock domain, and the functional clock above is assumed to be the clock for that domain. For example, to test a memory core instance in a 500 MHz clock domain, the shortest entry (or exit) latency during functional mode is 8 ns. If an external test clock of 100 MHz is used to enter and exit from the power management mode using four or more clock cycles, the entry and exit latencies are at least 40 ns each. Consequently, even if the memory core passes the test, it cannot be guaranteed to operate correctly in the functional mode. This test should therefore be considered inadequate.","Unlike a quantitative measure such as fault coverage, alternatives embodiments of testing power management modes should be evaluated qualitatively to ensure they adequately meet the above-described criteria for testing the power management modes. Two different testing embodiments will now be described and evaluated.","The first embodiment is a TAP-based test.  is a diagram of a typical prior art technique for testing memory in an IC using a TAP. Any TAP-based test needs to have access to the power management pins during testing. To effect this, multiplexers (not referenced) are added to ME, PMM, RET and PD as shown in . In addition, a number of signals (TAP_ME_CNT, TAP_ME_CNT_SEL, TAP_PMM, TAP_RET, TAP_PD and TAP_PMM_SEL) driven from the TAP are added.","In , the shaded region designates a memory assembly. The particular memory assembly of  includes at least two memory cores , . . . , . It also has a BISR controller  and a BIST controller . Four multiplexers (not referenced) are included with each memory assembly. All the memory cores , . . . , within a memory assembly are put in one of the memory power management modes concurrently. The two select signals drive the select lines of the multiplexers as  shows.","Globally, one TAP_ME_CNT signal could be provided for each memory assembly in an IC, one TAP_ME_CNT signal could be provided for each of multiple subsets of memory assemblies, or one TAP_ME_CNT signal could be shared by all of the memory assemblies. In the first case, memory cores belonging to a memory assembly may be powered down one assembly at a time. In the second case, memory cores belonging to a particular subset of memory assemblies may be powered down one subset at a time. In the third case all memory cores in the IC are powered down simultaneously. In the first and second cases, depending on the number of memory assemblies or subsets, the size of the TAP registers could increase drastically. Given that testing a memory assembly takes some time, if one memory assembly is powered down at a time, the total test time could be protracted. In the following discussion it is assumed that all memory assemblies share one TAP_ME_CNT signal, although the concept is valid for other cases.","The following TAP instructions are assumed to be available to provide an ordered signal-setting sequence that sets values of signals as follows:\n\n","The above set of TAP instructions may be used to derive a test for the power management modes. Table 1, below, shows one embodiment of a TAP-based test for the retention mode.",{"@attributes":{"id":"p-0056","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"TAP-Based Test Embodiment for the Retention Mode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NORMAL","BIST (start-pause)"]},{"entry":[{},{},"MEM CLK OFF"]},{"entry":[{},{},"TAPINST_ME = 0"]},{"entry":[{},"STAND-BY","TAPINST_PMM = 1"]},{"entry":[{},"PM-INIT","TAPINST_RET = 1"]},{"entry":[{},"PM-RETAIN","Measure Power"]},{"entry":[{},{},"TAPINST_RET = 0"]},{"entry":[{},"PM-RESTORE","TAPINST_PMM = 0"]},{"entry":[{},"STAND-BY2","TAPINST_ME = 1"]},{"entry":[{},"NORMAL","BIST (pause-pause)"]},{"entry":[{},"NORMAL","BIST (pause-end)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"It is assumed that the BIST controller  is able to partition the BIST sequence into three phases. Per Table 1, a start-pause phase of the BIST run is first initiated. After that, the external clock to the memory is turned off, and TAPINST_ME is set to 0, causing the memory to make a transition to the STAND-BY state. Next, setting TAPINST_PMM to 1 causes the memory to make a transition to the PM-INIT state. Next TAPINST_RET=1 forces the memory to transition to the PM-RETAIN state. The memory is kept in the PM-RETAIN state for a predetermined period of time. Power measurements are then made in the PM-RETAIN state. After that time has elapsed, the PM-RETAIN state is exited by setting TAPINST_RET to 0, TAPINST_PMM to 0 and TAPINST_ME to 1, in that order, as Table 1 shows. Note that the BIST run should be divided into at least two phases, since the BIST passes the memory only if the state it has after the start-pause phase is retained after exiting the PM-RETAIN state.","Table 2, below, shows one embodiment of a TAP-based test for the power down mode.",{"@attributes":{"id":"p-0059","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"TAP-Based Test Embodiment for the Power Down Mode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NORMAL","TAPINST_ME = 0"]},{"entry":[{},{},"MEM CLK OFF"]},{"entry":[{},"STAND-BY","TAPINST_PMM = 1"]},{"entry":[{},"PM-INIT","TAPINST_PD = 1"]},{"entry":[{},"PMPwrDwn","Measure power"]},{"entry":[{},{},"TAPINST_PD = 0"]},{"entry":[{},"PM-RESTORE","TAPINST_PMM = 0"]},{"entry":[{},"STAND-BY2","TAPINST_ME = 1"]},{"entry":[{},"NORMAL","BIST"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"It is assumed that the memory has been tested to be good and is initially in the NORMAL state. The memory is then driven to the PMPwrDwn state using the sequence of TAPINST_ME=0, TAPINST_PMM=1 and TAPINST_PD=1. The memory is then kept in the PMPwrDwn state for a predetermined amount of time, during which power measurements are made.","After the predetermined time has elapsed the memory is brought back to the NORMAL state through a sequence of TAP instructions TAPINST_PD=0, TAPINST_PMM=0 and TAPINST_ME=1. Once in the NORMAL state, memory BIST is run to determine if the memory if fully functional. For the power down mode, the BIST run does not need to be divided into two phases.","The TAP-based test will now be qualitatively evaluated based on the criteria discussed above in Section 3.","The criteria require two passes of the entry, retain (or power down) and exit process, once with MEM_CLK turned on and once with MEM_CLK turned off. The TAP-based test makes only one pass with MEM_CLK off.","The TAP-based test does not check if the output of the memory is set to 0 during the transition into and out of these modes.","The entry and exit latency of the TAP-based test is prohibitively high. Using the example of a memory in a 500 MHz clock domain, the entry and exit latencies of four clock cycles each imply entry and exit latencies of 8 ns each. If it is assumed that TCK is a 100 MHz clock, the clock cycle time is 10 ns. Even for a simple design, the number of bits that needs to be loaded into the TAP for each instruction will greatly exceed 50 bits. Using three such instructions to get into and out of the PM-RET state leads to an entry and exit latency much longer than 2 \u03bcs. This is considerably larger than the 8 ns latency required. For clock domains with higher clock frequency this discrepancy will be much higher.","The first two shortcomings can be rectified by modifying the TAP-based test described above. However, the third drawback cannot be eliminated.","In addition to the above shortcomings, six additional TAP signals have to be routed to all the memory assemblies. If the number of assemblies is small and physically located near each other and the TAP, this may not pose a problem. On the other hand, a large number of dispersed memory assemblies will add significantly to routing congestion. Section 5, below, introduces an alternative embodiment that addresses the above issues.","The first alternate test assumes that the time that the memory needs to be in the PM-RETAIN and PMPwrDwn sates are known. For the purposes of discussion, that time is assumed to be 500 ms, but the test does not depend on this value.","To address the routing congestion issue encountered by the TAP-based test, only two TAP signals (TAP_PMM, TAP_RET_PD) are routed to all of the memory assemblies. As in the TAP-based testing, it is assumed that all assemblies in a clock domain are placed in the power management modes simultaneously and power measurements made. However, if individual memory assemblies are to be tested serially, independent TAP_PMM signals for the individual memory assemblies are required.",{"@attributes":{"id":"p-0070","num":"0077"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIGS. 6 and 10"],"b":["510","510","122","122","122","122"],"i":["a","k","a","k "]},"To improve the testing of power management modes, the memory controller  is enhanced with the addition of a power management mode test controller, PMM_TEST_CTRL,  and a few unreferenced gates.  shows PMM_TEST_CTRL  and the gates and interconnect lines in bold lines. The memory controller  will now be described.","To gain control of the power management pins of the memory core during test, PMM_TEST_CTRL  generates the TEST_PMM, TEST_RET, TEST_ME and TEST_PD signals. Multiplexers (unreferenced) are used to select between the functional mode and test mode versions of the power management pins.  is a diagram of multiplexers, employable with the memory controller of , to select between functional and test modes. The BIST_ON signal drives the select lines of the multiplexers.",{"@attributes":{"id":"p-0073","num":"0080"},"figref":"FIG. 6","b":["122","122","122","122","511"],"i":["a","k","a","k "]},"In addition to the power management signals, a number of other signals are modified by the PMM_TEST_CNTRL . TEST_ME is either turned on by BIST_CNTRL or PMM_TEST_CNTRL using a multiplexer. PMM_ME and PMM_SEL signals generated by the PMM_TEST_CTRL  are set to 1\/0 (when ME has to be driven to the 1\/0 state) and 1 respectively during the power management test. For all other states PMM_SEL is 0 and TEST_ME is driven by BIST_ME. The BIST_ON signal generated by BIST_CTRL is modified by PMM_SEL.","To use CMP_STAT to determine whether or not the output of the memory is clamped at 0 during the power management modes, the power management mode test controller sets the CLEAR_DATA signal to 0, clearing the expected data provided by BIST_CTRL.","The power management mode test controller needs the ability to turn off the TEST_CLK during power management testing. For that the TEST_CLK signal is qualified with the FREEZE_CLK signal. In addition, instead of driving the memory cores with TEST_CLK, they are driven by BIST_CLK. FREEZE_CLK is 1 at all times except when PMM_SEL is on and a need exists to turn off the clock.",{"@attributes":{"id":"p-0077","num":"0084"},"figref":["FIG. 7","FIG. 7","FIGS. 2 and 3","FIG. 7"]},"MBIST_CMP_STAT from all the memory assemblies is assumed to be combined into one I\/O pin called CHIP_CMP_STAT. Since the number of clock cycles to enter one of the power management modes after the first TAP instruction was loaded is fixed, the exact number of clock cycles after which CHIP_CMP_STAT reflects the result of the comparison may be determined. The tester ( of ) can therefore monitor this pin to determine if the output of the memory cores is clamped at 0 or not.","The power management mode test controller is in a START state  when the power management mode testing is not being done, and the TAP holds TAP_PMM to 0. To initiate power management mode testing, TAP_PMM is set to 1 using two TAP instructions. If the retention mode is also to be tested, TAP_PMM_RD is also set to 1 (TAP instruction TAPINST_PMM_RET). If the power down mode is to be tested, TAP_RET_PD is set to 0 (TAP instruction TAPINST_PMM_PD). In both cases, a state transition to a START_RET_PD state  occurs, and PM_SEL and CLEAR_DATA are set to 1 and 0, respectively.","Transitions occur autonomously over the next two clock cycles. In the first clock cycle, PMM_ME is set to 0 (i.e., ME=0), and FREEZE_CLK is toggled, causing a transition to a STAND-BY state . Two passes are then made. For example, if FREEZE_CLK is initially 0, it is set to 1 in the first pass, and BIST_CLK is thus turned on. FREEZE_CLK is toggled to 0 in the second pass, and BIST_CLK is thus turned off. In this manner, the criterion of testing the power management modes with and without the BIST_CLK on is satisfied. In the subsequent clock cycle, the power management mode test controller sets TEST_PMM to 1 (i.e., PMM=1). The power management mode test controller then makes a transition to a PM_INIT state .","In the PM_INIT state , the value of TAP_RET_PD is checked. If TAP_RET_PD is 1, TEST_RET is set to 1 (i.e., RET=1), causing the memory to transition to the PM-RETAIN state . If TAP_RET_PD is 0, TEST_PD is set to 1 (i.e., PD=1), causing the memory to transition to the PMPwrDwn state . This completes the entry into the appropriate power management mode.","It is assumed that the same clock that drives BIST_CTRL, i.e., the TEST_CLK, prompts the transitions in . TEST_CLK is assumed to be derived from a phase-locked loop (PLL) for the corresponding clock domain, and the power management mode test controller runs at the functional speed, as is BIST_CTRL. Therefore, the entry latency is four functional clock cycles, which satisfies the minimum entry latency criterion.","Transitions again occur autonomously over the next few clock cycles. If in the PMPwrDwn state , a wait of 500 ms (i.e., an equivalent number of clock cycles) occurs, after which TEST_PD is set to 0 (i.e., PD=0), causing the memory to transition to a PM-RESTORE state . If in the PM-RETAIN state , TEST_RET is set to 0 (i.e., RET=0), causing the memory to transition to the PM-RESTORE state . In the next clock cycle, TEST_PMM is set to 0 (i.e., PMM=0), causing the memory to a transition to a STAND-BY2 state . In the next clock cycle, TEST_ME is set to 1 (i.e., ME=1), causing the memory to transition to the END_RET_PD state .","After loading the TAP instruction to initiate the power management mode, the next TAP instruction TAPINST_PMM is loaded, setting TAP_PMM to 0 (i.e., PMM=0). It is assumed that it takes more than one functional clock cycle to load a TAP instruction. Up to this point, the power management mode test controller ignored the value of TAP_PMM. When in the STAND-BY2 state , the power management mode test controller samples the value of TAP_PMM, which by now has been set to 1 (i.e., PMM=1). In the next clock cycle, the power management mode test controller sets CLEAR_DATA to 1, PMM_SEL to 0 and makes a transition to the START state . The power management mode test controller thus relinquishes control of the power management pins.","Table 3, below, describes the test that uses the power management mode test controller for testing the retention mode. As in Section 4, above, it is assumed that the BIST run can be broken down into phases. It is also assumed that the BIST run is divided into at least three phases. It is further assumed that FREEZE_CLK is 0 prior to executing this test. The test exhibits similar behavior if FREEZE_CLK is initially assumed to be 1.",{"@attributes":{"id":"p-0086","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test That Uses the Power Management Mode Test"},{"entry":"Controller to Test the Retention Mode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","BIST (start-pause)"]},{"entry":["2.","TAPINST_PMM_RET"]},{"entry":[{},"\u2003Assume initially, FREEZE_CLK = 0"]},{"entry":[{},"\u2003FREEZE_CLK is set to 1 after two clock cycles"]},{"entry":["3.","The tester starts monitoring CHIP_CMP_STAT after three clock"]},{"entry":[{},"cycles"]},{"entry":["4.","TAPINST_PMM"]},{"entry":["5.","Wait M + 3 \u2212 T clock cycles"]},{"entry":[{},"\u2003While waiting measure current\/power"]},{"entry":[{},"\u2003The tester stops monitoring CHIP_CMP_STAT after M + 2 \u2212 T "]},{"entry":[{},"clock cycles"]},{"entry":["6.","BIST (pause-pause)"]},{"entry":["7.","TAPINST_PMM_RET"]},{"entry":[{},"\u2003FREEZE_CLK is set to 0 after two clock cycles"]},{"entry":["8.","The tester starts monitoring CHIP_CMP_STAT after three clock"]},{"entry":[{},"cycles"]},{"entry":["9.","TAPINST_PMM"]},{"entry":["10.","Wait M + 3 \u2212 T clock cycles"]},{"entry":[{},"\u2003The tester measures current\/power"]},{"entry":[{},"\u2003The tester stops monitoring CHIP_CMP_STAT after M + 2 \u2212 T "]},{"entry":[{},"clock cycles"]},{"entry":["11.","BIST (pause-end)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"For purposes of the present discussion, the term \u201cclock cycle\u201d refers to the number of TEST_CLK clock cycles, and TEST_CLK is assumed to have the same frequency as the functional clock. T is defined as the number of clock cycles required to load a TAP instruction, and M is defined as the number of clock cycles that result in a 500 ms wait.","The total number of clock cycles required to traverse the states of  is M+6 after issuing TAPINST_PMM_RET. Since Step 3 of Table 3 requires three clock cycles, and loading TAPINST_PMM requires T clock cycles, ensuring that TEST_PMM_CTRL has gone through the complete sequence of transitions shown in  requires at least M+3-T clock cycles.","The relationship between T and M imposes a lower bound on the number of clock cycles that the power management mode test controller waits in the retention mode. TAP_PMM is monitored only when the END_RET_PD state is reached. Transitioning from the START_RET_PD state to the STAND-BY2 state requires a total of M+5 clock cycles. Given that TAPINST_PMM begins to load three clock cycles after issuing TAPINST_PMM_RET, T<M+5. It is assumed that this bound is satisfied.","Note that the test makes two passes through the state transition sequence of . During Pass I, from steps 2-5 FREEZE_CLK=1, i.e., BIST_CLK is on. During Pass II, from steps 7-10 FREEZE_CLK=0, i.e., BIST_CLK is off. Thus, the criterion for testing for the retention mode with and without the external clock turned on is satisfied.","Another assumption is that the result of the comparison encoded in MBIST_CMP_STAT propagates to the CHIP_CMP_STAT within the same clock cycle. However, several reasons exist as to why this may not be true. If the number of memory assemblies is large or multiple clock domains with widely varying frequencies exist, this criterion is difficult to meet.","For the purpose of testing no need exists to monitor the failure of the comparison on a clock-clock cycle-by-clock-clock cycle basis. The result of the comparison can be accumulated at-speed in a local register. After the test has concluded, the accumulated result is reflected in MBIST_CMP_STAT of individual assemblies and can be monitored at slow speed by the tester at the CHIP_CMP_STAT pin. Such an infrastructure is already available in commercially available memory BIST products; thus, one skilled in the pertinent art can modify Table 3 to take this into account. With this modification to the test, the power management mode test controller meets all the criteria set forth in Section 3, above.","The test for the power down mode is similar to the retention mode test and is shown in Table 4, below.",{"@attributes":{"id":"p-0094","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test That Uses the Power Management Mode Test"},{"entry":"Controller to Test the Power Down Mode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","TAPINST_PMM_PD"]},{"entry":[{},"\u2003Assume initially, FREEZE_CLK = 0"]},{"entry":[{},"\u2003FREEZE_CLK is set to 1 after two clock cycles"]},{"entry":["2.","TAPINST_PMM"]},{"entry":["3.","Wait M + 6 \u2212 T clock cycles"]},{"entry":[{},"\u2003The tester measures current\/power"]},{"entry":["4.","BIST"]},{"entry":["5.","Wait a few clock cycles for the MBIST_CMP_STAT from the"]},{"entry":[{},"slowest path to propagate to CHIP_CMP_STAT"]},{"entry":["6.","The tester checks the CHIP_CMP_STAT to be 1"]},{"entry":["7.","TAPINST_PMM_PD"]},{"entry":[{},"\u2003FREEZE_CLK is set to 0 after two clock cycles"]},{"entry":["8.","TAPINST_PMM"]},{"entry":["9.","Wait M + 6 \u2212 T clock cycles"]},{"entry":[{},"\u2003The tester measures current\/power"]},{"entry":["10.","BIST"]},{"entry":["11.","Wait a few clock cycles for the MBIST_CMP_STAT from the"]},{"entry":[{},"slowest path to propagate to CHIP_CMP_STAT"]},{"entry":["12.","The tester checks the CHIP_CMP_STAT to be 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"As discussed above, CHIP_CMP_STAT is no longer being monitored on a clock-clock cycle-by-clock-clock cycle basis but instead at the end of the test in Step 11 of Table 4. Also, as in Table 4, the BIST run is not being divided into phases but instead running twice, once with BIST_CLK on and once with BIST_CLK off.","The embodiments presented in the previous section assume a predetermined amount of time in the power management modes which has to be fixed during design time since the design of the power management mode test controller is based on this value. However, those skilled in the pertinent art may want to modify the duration during which the memory is in the power management modes. In addition, certain embodiments keep the memory in the two modes, retention and power down, for two different durations. The embodiments of Section 5 generally do not meet these requirements. However, the embodiment of  does allow for that flexibility.",{"@attributes":{"id":"p-0097","num":"0104"},"figref":["FIG. 8","FIG. 5","FIGS. 5 and 6","FIG. 8","FIG. 8","FIGS. 5 and 6"]},"First, two states conform to each of the power management states: a PMPwrDwn_In state  and a PMPwrDwn state  for the power down mode and a PM_RETAIN_In state  and a PM_RETAIN state  for the retention mode. These pairs of states may be viewed as the entry into and out of the corresponding power management modes. The tester controls the amount of time these two states persist. This provides the flexibility of programming the time the memory remains in the power management mode after entry.","Second, in the power management mode test controller description of  values of TAP_PMM went through a 0\u21921\u21920 transition. This sequence of values on the TAP_PMM signal marked the start and end synchronizing points of TAP_PMM_CNTRL. TAP instructions set the values. In the TAP_PMM_CTRL description of , the TAP_PMM signal goes through a 0\u21921\u21920\u21921\u21920 transition.","The first 0\u21921 transition marks the initial synchronization point. The second 1\u21920 transition controls the transition from the PMPwrDwn_In state  to the PMPwrDwn state  (or the PM-RETAIN_In state  to the PM-RETAIN state ). The next 0\u21921 transition controls the transition into the PM-RESTORE sate . The ability to program the separation between the last two 1\u21920 and 0\u21921 transitions provides the flexibility to determine the number of clock cycles that the memory resides in the power management modes. The final 1\u21920 transition is the last synchronizing point after which the power management mode test controller relinquishes control of the power management pins.","Table 5, below, describes one embodiment of a test for the retention mode.",{"@attributes":{"id":"p-0102","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test That Uses the Power Management Mode Test"},{"entry":"Controller to Test the Retention Mode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","BIST (start-pause)"]},{"entry":["2.","TAPINST_PMM_RET"]},{"entry":[{},"\u2003Assume initially, FREEZE_CLK = 0"]},{"entry":[{},"\u2003FREEZE_CLK is set to 1 after two clock cycles"]},{"entry":["3.","TAPINST_PMM = 0"]},{"entry":["4.","Wait n clock cycles"]},{"entry":["5.","TAPINST_PMM = 1"]},{"entry":[{},"\u2003The tester measures current\/power"]},{"entry":["6.","TAPINST_PMM = 0"]},{"entry":["7.","BIST (pause-pause)"]},{"entry":["8.","TAPINST_PMM_RET"]},{"entry":[{},"\u2003Assume initially, FREEZE_CLK = 0"]},{"entry":[{},"\u2003FREEZE_CLK is set to 1 after two clock cycles"]},{"entry":["9.","TAPINST_PMM = 0"]},{"entry":["10.","Wait n clock cycles"]},{"entry":["11.","TAPINST_PMM = 1"]},{"entry":[{},"\u2003The tester measures current\/power"]},{"entry":["12.","TAPINST_PMM = 0"]},{"entry":["13.","BIST (pause-end)"]},{"entry":["14.","Wait a few clock cycles for the MBIST_CMP_STAT from the"]},{"entry":[{},"slowest path to propagate to CHIP_CMP_STAT"]},{"entry":["15.","The tester checks the CHIP_CMP_STAT to be 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"TAPINST_PMM_RET is as defined in Section 5. Now, instead of having TAPINST_PMM which set TAP_PMM to 0, two TAP instructions TAPINST_PMM=0, TAPINST_PMM=1 are used. These TAP instructions set TAP_PMM to 0 and 1, respectively.","As in Section 5, if T is the number of clock cycles required to load a TAP instruction, the power management mode test controller is in the PMPwrDwn_In state  for T\u22123 clock cycles. In Step 10 of Table 5, n is the number of clock cycles the tester waits before loading the next TAP instruction that sets TAP_PMM to 1. Therefore, the power management mode test controller spends T+n clock cycles in the PMPwrDwn state . As a result, the memory remains in the power down state for a total of 2T\u22123+n clock cycles. Thus, by changing the value of n for the test, the total wait time can be modified in the power down mode. Note that this also means that a lower bound exists on the wait time in the retention mode which is given by 2T\u22123.","As discussed in Section 5, a limitation exists if CHIP_CMP-STAT is to be monitored in each clock cycle. Therefore, CHIP_CMP_STAT is monitored once after all steps in the test have completed.","The added flexibility of programming the wait time comes at a price in that the power management mode test controller spends T\u22122 clock cycles in the END_RET_PD state . Therefore, the embodiment of  does not satisfy the exit latency criterion of four clock cycles. However, its flexibility lends other advantages.","Table 6, below, describes one embodiment of a test for the power down mode.",{"@attributes":{"id":"p-0108","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test That Uses the Power Management Mode Test"},{"entry":"Controller to Test the Power Down Mode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","TAPINST_PMM_RET"]},{"entry":[{},"\u2003Assume initially, FREEZE_CLK = 0"]},{"entry":[{},"\u2003FREEZE_CLK is set to 1 after two clock cycles"]},{"entry":["2.","TAPINST_PMM = 0"]},{"entry":["3.","Wait n clock cycles"]},{"entry":["4.","TAPINST_PMM = 1"]},{"entry":[{},"\u2003The tester measures current\/power"]},{"entry":["5.","TAPINST_PMM = 0"]},{"entry":["6.","TAPINST_PMM_RET"]},{"entry":[{},"\u2003Assume initially, FREEZE_CLK = 0"]},{"entry":[{},"\u2003FREEZE_CLK is set to 1 after two clock cycles"]},{"entry":["7.","TAPINST_PMM = 0"]},{"entry":["8.","Wait n clock cycles"]},{"entry":["9.","TAPINST_PMM = 1"]},{"entry":[{},"\u2003The tester measures current\/power"]},{"entry":["10.","TAPINST_PMM = 0"]},{"entry":["11.","BIST"]},{"entry":["12.","Wait a few clock cycles for the MBIST_CMP_STAT from the"]},{"entry":[{},"slowest path to propagate to CHIP_CMP_STAT"]},{"entry":["13.","The tester checks the CHIP_CMP_STAT to be 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The test of Table 6 is similar to the test for the retention mode that Table 5 set forth above, with the same flexibility and limitation.","Three different embodiments and variations thereof for testing memory power management modes have been illustrated and described above. In this section, modifications to those embodiments and variations that allow power management mode failures to be diagnosed will be illustrated and described. These embodiments can be used with both versions of the power management mode test controller described in Sections 5 and 6, above.","Two power management test failures could occur: (i) the power measurement, when in the retention and\/or power down mode, is larger than the expected value and (ii) the output of one or more memories are not clamped to 0.","The first kind of failure is detected when the tester makes the power measurements, for example in Step 4 or Step 9 of Table 6, above. The goal is then to determine which one memory core or group of memory cores contribute to the elevated power consumption in the memory management modes.","The second kind of failure is detected in the last step of the test, for example in Step 13 of Table 6, above. In this case, the data bit in the memory core that has the error needs to be determined. Note that, unlike standard BIST memory failure, no need exists to identify the address location of the failure.",{"@attributes":{"id":"p-0114","num":"0121"},"figref":["FIG. 9","FIG. 5","FIG. 9"],"b":["511","511","910","910"],"i":["a","k ","a","k "]},{"@attributes":{"id":"p-0115","num":"0122"},"figref":["FIG. 10","FIG. 5","FIG. 10"],"b":"1010"},"Before running retention or power down diagnostic tests, the power management mode shift register may be loaded with any combination of zeroes and ones to test any subset of the memory cores. One embodiment involves running these diagnostic tests multiple times to narrow the failures down to a group of assemblies and then diagnosing each assembly down to individual memory cores. However, the power dissipation in the individual memory cores may be so small that it falls within the noise margin of the background leakage current. In that case, the failure may only be able to be diagnosed to a memory assembly.","The second type of failure may be able to be diagnosed down to the memory cores using a similar strategy. If more diagnostic resolution is required, the same patterns can be run in conjunction with the diagnostic BIST patterns of the existing memory BIST infrastructure.",{"@attributes":{"id":"p-0118","num":"0125"},"figref":"FIG. 11","b":"1110"},"In a step , a signal is provided to a power management mode test controller via a TAP. In a step , the power management mode test controller provides an ordered signal-setting sequence to the at least one memory core. In a step , the ordered signal-setting sequence causes the at least one memory core to enter into and exit from at least one memory power management mode. In a step , provision of the ordered signal-setting sequence to the at least one memory core is controlled to limit the provision to fewer than all of the at least one memory core. The step  is optional and for the purpose of conducting diagnostics to isolate a failure to a particular memory core, subset of memory cores or memory assembly, as desired. The method ends in an end step .","Those skilled in the art to which the invention relates will appreciate that other and further additions, deletions, substitutions and modifications may be made to the described embodiments without departing from the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the invention, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 2","FIG. 1B"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 1B"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 8","FIG. 5"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 9","FIG. 5"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 10","FIG. 5"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
