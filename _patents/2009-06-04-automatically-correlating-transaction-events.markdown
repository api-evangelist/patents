---
title: Automatically correlating transaction events
abstract: An API can be extended to automatically correlate events based on context. Started events for each context (e.g. threads of execution) are maintained on independent stacks. When an instrumented application starts a new transaction, the API generates a started event. A transaction correlation unit within the API can determine if the new transaction started during a previous transaction. If there is a previous started event on the stack, the new transaction started during the previous transaction. The transaction correlation unit can insert an outbound indicator into the new started event to associate the new transaction and the previous transaction. Then, the new started event can be pushed on the stack.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08479220&OS=08479220&RS=08479220
owner: International Business Machines Corporation
number: 08479220
owner_city: Armonk
owner_country: US
publication_date: 20090604
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DESCRIPTION OF EMBODIMENT(S)"],"p":["Embodiments of the inventive subject matter generally relate to the field of transaction tracking, and, more particularly, to automatically correlating transaction events.","Correlating events produced from transactions and their sub-transactions is a common issue in transaction tracking. Transaction tracking systems typically rely on explicitly providing common data in transaction events (e.g., correlator tokens in Application Response Measurement (ARM)). Correlating transaction events based on common data introduces a chance for error if one application fails to provide correct information.","Embodiments include a method that detects that a first transaction has started. A first started event is generated for the first transaction. It is determined if the first transaction started during a second transaction. An outbound indicator identifying the second transaction is inserted into the first started event to indicate that the first transaction is a sub-transaction of the second transaction, if it is determined that the first transaction started during the second transaction. The first started event is stored in a data structure.","Embodiments also include a computer program product for automatically correlating transaction events. The computer program product comprises a computer usable medium having computer usable program code embodied therewith. The computer usable program code comprises computer usable program configured to detect that a first transaction has started, and to generate a first started event for the first transaction. The computer usable program code is also configured to determine if the first transaction started during a second transaction. If the first transaction started during the second transaction, then the computer usable program code is configured to insert an outbound indicator identifying the second transaction into the first started event to indicate that the first transaction is a sub-transaction of the second transaction. The computer usable program code is configured to store the first started event in a data structure of started events.","Embodiments also include a computer program product for automatically correlating transaction events. The computer program product comprises a computer usable medium having computer usable program code embodied therewith. The computer usable program code comprises computer usable program code configured to detect that a first transaction is ending, and to generate a finished event for the first transaction. The computer usable program code is configured to determine if the first transaction started during a second transaction. If the first transaction started during the second transaction, then the computer usable program code is configured to insert an outbound indicator identifying the second transaction into the finished event to indicate that the first transaction is a sub-transaction of the second transaction. The computer usable program code is configured to remove the started event from a data structure of started events.","Embodiments also include an apparatus that comprises a processing unit, a network interface, and a transaction correlation unit. The transaction correlation unit is operable to detect that a first transaction has started, to generate a first started event for the first transaction, and to determine if the first transaction started during a second transaction. If the first transaction started during the second transaction, then the transaction correlation unit is operable to insert an outbound indicator identifying the second transaction into the first started event to indicate that the first transaction is a sub-transaction of the second transaction. The transaction correlation unit is operable to store the first started event in a data structure.","The description that follows includes exemplary systems, methods, techniques, instruction sequences, and computer program products that embody techniques of the present inventive subject matter. However, it is understood that the described embodiments may be practiced without these specific details. For instance, although examples refer to Application Response Measurement (ARM), embodiments may be implemented with other application programming interfaces (APIs), such as Oracle\u00ae Trace. In other instances, well-known instruction instances, protocols, structures, and techniques have not been shown in detail in order not to obfuscate the description.","Instrumented applications utilize APIs to send events marking the beginning and end of transactions to a transaction tracking system. The transaction tracking system correlates the events based on common data in the events, such as a process identifier and a thread identifier. However, the process and thread identifiers may be reused in a short period of time causing the transaction tracking system to erroneously associate events from two distinct transactions. An API can be extended to automatically correlate events based on context. Started events for each context (e.g. threads of execution) are maintained on independent stacks. When an instrumented application starts a new transaction, the API generates a started event. A transaction correlation unit within the API can determine if the new transaction started during a previous transaction. If there is a previous started event on the stack, the new transaction started during the previous transaction. The transaction correlation unit can insert an outbound indicator into the new started event to associate the new transaction and the previous transaction. Then, the new started event can be pushed on the stack.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["102","104","102","101","104","103","102","102","102","102","104","104","104","104","102","102","104","103","102","104","104","102"]},"At stage A, the instrumented third-party component  detects the start of a second transaction A. For example, the instrumented third-party component  detects a function call to the instrumented third-party component's module(s).","At stage B, the instrumented third-party component  requests generation of a second started event B. For example, the instrumented third-party component  requests generation of the second started event B through an ARM API function call.","At stage C, a transaction correlation unit  instantiated in accordance with an API of the instrumented third-party component  generates the second started event B.","At stage D, the transaction correlation unit  determines that the second transaction  started during a first transaction because a first started event B exists on a started event stack .","At stage E, the transaction correlation unit  inserts an outbound indicator that identifies the first transaction  into the second started event B to indicate that the second transaction  is a sub-transaction of the first transaction . For example, the first transaction  may be identified by a unique number generated by the instrumented application . The transaction correlation unit  may determine the first transaction's identifier based on the first started event B on the started event stack , a parameter passed in an API function call, etc. In addition, the transaction correlation unit  can insert an inbound indicator that identifies the second transaction  into the second started event B.","At stage F, the transaction correlation unit  pushes the second started event B onto the started event stack.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["201","203"]},"At block , it is determined if the new transaction started during a current transaction. Determining that the new transaction started during a current transaction comprises determining if a current started event exists on a started event stack. If a current started event exists on the started event stack, the new transaction has started during a current transaction, and the new transaction is a sub-transaction of the current transaction. If the new transaction started during a current transaction, flow continues at block . If the new transaction did not start during a current transaction, flow continues at block .","At block , the new transaction started during a current transaction, so an outbound indicator identifying the current transaction is inserted into the new started event. Inserting an outbound indicator comprises determining an identifier of the current transaction, and storing the identifier in a data member of the started event. For example, the current transaction's identifier can be determined based on examining a current inbound indicator of the current event on the stack. Flow continues at block .","At block , an inbound indicator identifying the new transaction is inserted into the new started event. Inserting the inbound indicator comprises determining an identifier of the new transaction, and storing the identifier in a data member of the started event. For example, the new transaction's identifier may be determined based on a parameter passed in an ARM API function call. Flow continues at block .","At block , the new started event is pushed onto the started event stack and flow ends.","In addition, to generating started events when a transaction starts, finished events are generated when a transaction ends.  is an example conceptual diagram of automatically correlating transaction finished events. A first transaction  and a second transaction  exist in the same context. For example, the first transaction  and the second transaction  are started within the same thread of execution. The first transaction  is handled by an instrumented application  and the second transaction  is handled by an instrumented third-party component . A circle A represents the beginning of the first transaction , and a circle D represents the end of the first transaction . A circle A represents the beginning of the second transaction , and a circle D represents the end of the second transaction .","At stage A, the instrumented third-party component  detects that the second transaction  is ending. For example, the instrumented third-party component  detects a return function call.","At stage B, the instrumented third-party component  requests generation of a finished event C. For example, the instrumented third-party component  requests generation of the finished event C through an ARM API function call.","At stage C, a transaction correlation unit  instantiated in accordance with an API of the instrumented third-party component , generates the finished event C.","At stage D, the transaction correlation unit  determines that the second transaction  started during the first transaction  based on an outbound indicator in a second started event C on a started event stack . If the outbound indicator identifies the first transaction , the second transaction started during the first transaction and the second transaction is a sub-transaction of the first transaction.","At stage E, the transaction correlation unit  inserting an inbound indicator identifying the first transaction into the finished event C to indicate that the second transaction  is a sub-transaction of the first transaction . For example, the transaction correlation unit  can determine the first transaction identifier based on the second outbound indicator in the started event C. In addition, the transaction correlation unit  can insert an outbound indicator that identifies the second transaction  into the finished event C.","At stage F, the transaction correlation unit  pops the second started event C off the started event stack .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["401","403"]},"At block , an outbound indicator that identifies the current transaction is inserted into the finished event. Inserting the outbound indicator comprises determining an identifier of the new transaction, and storing the identifier in a data member of the finished event. For example, the new transaction's identifier may be determined based on a parameter passed in an ARM API function call. Flow continues at block .","At block , it is determined if the current transaction started during a previous transaction. The current transaction started during a previous transaction if a previous outbound indicator of an event at the top of a started event stack identifies a previous transaction. The current transaction is a sub-transaction of the previous transaction if the previous outbound indicator identifies the previous transaction. If the current transaction started during a previous transaction, flow continues at block . If the current transaction did not start during a previous transaction, flow continues at block .","At block , the previous outbound indicator of a top event on the started event stack identified the previous transaction, so an inbound indicator that identifies the previous transaction is inserted into the finished event. Flow continues at block .","At block , the top event is popped off the started event stack.","Although examples refer to using stacks to store started events, embodiments are not so limited. Embodiments can use other data structures such as queues, linked lists, arrays, etc.","It should be understood that the depicted flowcharts are examples meant to aid in understanding embodiments and should not be used to limit embodiments or limit scope of the claims. Embodiments may perform additional operations, fewer operations, operations in a different order, operations in parallel, and some operations differently. For instance, the operation for inserting an inbound indicator identifying the new transaction into the new started event in  may be performed before the operation for determining if the new transaction started during a current transaction. Referring to , the operation for inserting an inbound indicator identifying the current transaction into the finished event may be performed before the operation for determining if a current outbound indicator of a top event on a started event stack identifies a current transaction.","Embodiments may take the form of an entirely hardware embodiment, a software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, embodiments of the inventive subject matter may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium. The described embodiments may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic device(s)) to perform a process according to embodiments, whether presently described or not, since every conceivable variation is not enumerated herein. A machine-readable medium includes any mechanism for storing or transmitting information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The machine-readable medium may include, but is not limited to, magnetic storage medium (e.g., floppy diskette); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; or other types of medium suitable for storing electronic instructions. In addition, embodiments may be embodied in an electrical, optical, acoustical or other form of propagated signal (e.g. carrier waves, infrared signals, digital signals, etc.), or wireline, wireless, or other communications medium.","Computer program code for carrying out operations of the embodiments may be written in any combination of one or more programming languages, including an object oriented programming language such as Java\u00ae, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on a user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN), a personal area network (PAN), or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 5","FIG. 5"],"b":["501","507","507","503","505","509","521","521","501","501","501","509","505","503","503","507","501"]},"While the embodiments are described with reference to various implementations and exploitations, it will be understood that these embodiments are illustrative and that the scope of the inventive subject matter is not limited to them. In general, techniques for automatically correlating transaction events as described herein may be implemented with facilities consistent with any hardware system or hardware systems. Many variations, modifications, additions, and improvements are possible.","Plural instances may be provided for components, operations, or structures described herein as a single instance. Finally, boundaries between various components, operations, and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the inventive subject matter. In general, structures and functionality presented as separate components in the exemplary configurations may bc implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the inventive subject matter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present embodiments may be better understood, and numerous objects, features, and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
