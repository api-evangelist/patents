---
title: Control system that elects a master controller instance for switching elements
abstract: Some embodiments provide a control system for managing a network that includes several switching elements managed by the control system. The system includes several controller instances for managing the switching elements. Each particular controller instance includes a coordination manager for communicating with the coordination managers of the other controllers in order to partition control of the plurality of switching elements by electing a master controller for different sets of switching elements. The particular controller instance also includes a storage for storing control data for controlling the set of managed switching elements managed by the controller instance, and a switch interface for passing the control data to the set of managed switching elements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08842679&OS=08842679&RS=08842679
owner: Nicira, Inc.
number: 08842679
owner_city: Palo Alto
owner_country: US
publication_date: 20110706
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF BENEFIT TO PRIOR APPLICATION","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims benefit to U.S. Provisional Patent Application 61\/361,912, filed on Jul. 6, 2010; U.S. Provisional Patent Application 61\/361,913, filed on Jul. 6, 2010; U.S. Provisional Patent Application 61\/429,753, filed on Jan. 4, 2011; U.S. Provisional Patent Application 61\/429,754, filed on Jan. 4, 2011; U.S. Provisional Patent Application 61\/466,453, filed on Mar. 22, 2011; U.S. Provisional Patent Application 61\/482,205, filed on May 3, 2011; U.S. Provisional Patent Application 61\/482,615, filed on May 4, 2011; U.S. Provisional Patent Application 61\/482,616, filed on May 4, 2011; U.S. Provisional Patent Application 61\/501,743, filed on Jun. 27, 2011; and U.S. Provisional Patent Application 61\/501,785, filed on Jun. 28, 2011. These provisional applications are incorporated herein by reference.","Many current enterprises have large and sophisticated networks comprising switches, hubs, routers, servers, workstations and other networked devices, which support a variety of connections, applications and systems. The increased sophistication of computer networking, including virtual machine migration, dynamic workloads, multi-tenancy, and customer specific quality of service and security configurations require a better paradigm for network control. Networks have traditionally been managed through low-level configuration of individual components. Network configurations often depend on the underlying network: for example, blocking a user's access with an access control list (\u201cACL\u201d) entry requires knowing the user's current IP address. More complicated tasks require more extensive network knowledge: forcing guest users' port  traffic to traverse an HTTP proxy requires knowing the current network topology and the location of each guest. This process is of increased difficulty where the network switching elements are shared across multiple users.","In response, there is a growing movement, driven by both industry and academia, towards a new network control paradigm called Software-Defined Networking (SDN). In the SDN paradigm, a network controller, running on one or more servers in a network, controls, maintains, and implements control logic that governs the forwarding behavior of shared network switching elements on a per user basis. Making network management decisions often requires knowledge of the network state. To facilitate management decision making, the network controller creates and maintains a view of the network state and provides an application programming interface upon which management applications may access a view of the network state.","Three of the many challenges of large networks (including datacenters and the enterprise) are scalability, mobility, and multi-tenancy and often the approaches taken to address one hamper the other. For instance, one can easily provide network mobility for virtual machines (VMs) within an L2 domain, but L2 domains cannot scale to large sizes. Also, retaining tenant isolation greatly complicates mobility. Despite the high-level interest in SDN, no existing products have been able to satisfy all of these requirements.","Some embodiments of the invention provide a system that allows several different logical data path sets to be specified for several different users through one or more shared network infrastructure switching elements (referred to as \u201cswitching elements\u201d below). In some embodiments, the system includes a set of software tools that allows the system to accept logical data path sets from users and to configure the switching elements to implement these logical data path sets. These software tools allow the system to virtualize control of the shared switching elements and the network that is defined by the connections between these shared switching elements, in a manner that prevents the different users from viewing or controlling each other's logical data path sets (i.e., each other's switching logic) while sharing the same switching elements.","In some embodiments, one of the software tools that allows the system to virtualize control of a set of switching elements (i.e., to allow several users to share the same switching elements without viewing or controlling each other's logical data path sets) is an intermediate data storage structure that (1) stores the state of the network, (2) receives and records modifications to different parts of the network from different users, and (3), in some embodiments, provides different views of the state of the network to different users. For instance, in some embodiments, the intermediate data storage structure is a network information base (NIB) data structure that stores the state of the network that is defined by one or more switching elements. The system uses this NIB data structure as an intermediate storage structure for reading the state of the network and writing modifications to the state of the network. In some embodiments, the NIB also stores the logical configuration and the logical state for each user specified logical data path set. In these embodiments, the information in the NIB that represents the state of the actual switching elements accounts for only a subset of the total information stored in the NIB.","In some embodiments, the system has (1) a network operating system (NOS) to create and maintain the NIB storage structure, and (2) one or more applications that run on top of the NOS to specify logic for reading values from and writing values to the NIB. When the NIB is modified in order to effectuate a change in the switching logic of a switching element, the NOS of some embodiments also propagates the modification to the switching element.","The system of different embodiments uses the NIB differently to virtualize access to the shared switching elements and network. In some embodiments, the system provides different views of the NIB to different users in order to ensure that different users do not have direct view and control over each other's switching logic. For instance, in some embodiments, the NIB is a hierarchical data structure that represents different attributes of different switching elements as elements (e.g., different nodes) in a hierarchy. The NIB in some of these embodiments is a multi-layer hierarchical data structure, with each layer having a hierarchical structure and one or more elements (e.g., nodes) on each layer linked to one or more elements (e.g., nodes) on another layer. In some embodiments, the lowest layer elements correspond to the actual switching elements and their attributes, while each of the higher layer elements serve as abstractions of the actual switching elements and their attributes. As further described below, some of these higher layer elements are used in some embodiments to show different abstract switching elements and\/or switching element attributes to different users in a virtualized control system.","In some embodiments, the definition of different NIB elements at different hierarchical levels in the NIB and the definition of the links between these elements are used by the developers of the applications that run on top of the NOS in order to define the operations of these applications. For instance, in some embodiments, the developer of an application running on top of the NOS uses these definitions to enumerate how the application is to map the logical data path sets of the user to the physical switching elements of the control system. Under this approach, the developer would have to enumerate all different scenarios that the control system may encounter and the mapping operation of the application for each scenario. This type of network virtualization (in which different views of the NIB are provided to different users) is referred to below as Type I network virtualization.","Another type of network virtualization, which is referred to below as Type II network virtualization, does not require the application developers to have intimate knowledge of the NIB elements and the links (if any) in the NIB between these elements. Instead, this type of virtualization allows the application to simply provide user specified, logical switching element attributes in the form of one or more tables, which are then mapped to NIB records by a table mapping engine. In other words, the Type II virtualized system of some embodiments accepts the logical switching element configurations (e.g., access control list table configurations, L2 table configurations, L3 table configurations, etc.) that the user defines without referencing any operational state of the switching elements in a particular network configuration. It then maps the logical switching element configurations to the switching element configurations stored in the NIB.","To perform this mapping, the system of some embodiments uses a database table mapping engine to map input tables, which are created from (1) logical switching configuration attributes, and (2) a set of properties associated with switching elements used by the system, to output tables. The content of these output tables are then transferred to the NIB elements. In some embodiments, the system uses a variation of the datalog database language, called nLog, to create the table mapping engine that maps input tables containing logical data path data and switching element attributes to the output tables. Like datalog, nLog provides a few declaratory rules and operators that allow a developer to specify different operations that are to be performed upon the occurrence of different events. In some embodiments, nLog provides a limited subset of the operators that are provided by datalog in order to increase the operational speed of nLog. For instance, in some embodiments, nLog only allows the AND operator to be used in any of the declaratory rules.","The declaratory rules and operations that are specified through nLog are then compiled into a much larger set of rules by an nLog compiler. In some embodiments, this compiler translates each rule that is meant to address an event into several sets of database join operations. Collectively the larger set of rules forms the table-mapping rules engine that is referred to below as the nLog engine. In some embodiments, the nLog virtualization engine also provides feedback (e.g., from one or more of the output tables or from NIB records that are updated to reflect values stored in the output tables) to the user in order to provide the user with state information about the logical data path set that he or she created. In this manner, the updates that the user gets are expressed in terms of the logical space that the user understands and not in terms of the underlying switching element states, which the user does not understand.","The use of nLog serves as a significant distinction between Type I virtualized control systems and Type II virtualized control systems, even for Type II systems that store user specified logical data path sets in the NIB. This is because nLog provides a machine-generated rules engine that addresses the mapping between the logical and physical domains in a more robust, comprehensive manner than the hand-coded approach used for Type I virtualized control systems. In the Type I control systems, the application developers need to have a detailed understanding of the NIB structure and need to use this detailed understanding to write code that addresses all possible conditions that the control system would encounter at runtime. On the other hand, in Type II control systems, the application developers only need to produce applications that express the user-specified logical data path sets in terms of one or more tables, which are then mapped in an automated manner to output tables and later transferred from the output tables to the NIB. This approach allows the Type II virtualized systems to forego maintaining the data regarding the logical data path sets in the NIB. However, some embodiments maintain this data in the NIB in order to distribute this data among other NOS instances, as further described below.","As apparent from the above discussion, the applications that run on top of a NOS instance can perform several different sets of operations in several different embodiments of the invention. Examples of such operations include providing an interface to a user to access NIB data regarding the user's switching configuration, providing different layered NIB views to different users, providing control logic for modifying the provided NIB data, providing logic for propagating received modifications to the NIB, etc.","In some embodiments, the system embeds some or all such operations in the NOS instead of including them in an application operating on top of the NOS. Alternatively, in other embodiments, the system separates some or all of these operations into different subsets of operations and then has two or more applications that operate above the NOS perform the different subsets of operations. One such system runs two applications on top of the NOS: a control application and a virtualization application. In some embodiments, the control application allows a user to specify and populate logical data path sets, while the virtualization application implements the specified logical data path sets by mapping the logical data path sets to the physical switching infrastructure. In some embodiments, the virtualization application translates control application input into records that are written into the NIB, and then these records are subsequently transferred from the NIB to the switching infrastructure through the operation of the NOS. In some embodiments, the NIB stores both the logical data path set input received through the control application and the NIB records that are produced by the virtualization application.","In some embodiments, the control application can receive switching infrastructure data from the NIB. In response to this data, the control application may modify record(s) associated with one or more logical data path sets (LDPS). Any such modified LDPS record would then be translated to one or more physical switching infrastructure records by the virtualization application, which might then be transferred to the physical switching infrastructure by the NOS.","In some embodiments, the NIB stores data regarding each switching element within the network infrastructure of a system, while in other embodiments, the NIB stores state information about only switching elements at the edge of a network infrastructure. In some embodiments, edge switching elements are switching elements that have direct connections with the computing devices of the users, while non-edge switching elements only connect to edge switching elements and other non-edge switch elements.","The system of some embodiments only controls edge switches (i.e., only maintains data in the NIB regarding edge switches) for several reasons. Controlling edge switches provides the system with a sufficient mechanism for maintaining isolation between computing devices, which is needed, as opposed to maintaining isolation between all switch elements, which is not needed. The interior switches forward data packets between the switching elements. The edge switches forward data packets between computing devices and other network elements (e.g., other switching elements). Thus, the system can maintain user isolation simply by controlling the edge switching elements because the edge switching elements are the last switches in line to forward packets to hosts.","Controlling only edge switches also allows the system to be deployed independent of concerns about the hardware vendor of the non-edge switches. Deploying at the edge allows the edge switches to treat the internal nodes of the network as simply a collection of elements that moves packets without considering the hardware makeup of these internal nodes. Also, controlling only edge switches makes distributing switching logic computationally easier. Controlling only edge switches also enables non-disruptive deployment of the system. Edge switching solutions can be added as top of rack switches without disrupting the configuration of the non-edge switches.","In addition to controlling edge switches, the network control system of some embodiments also utilizes and controls non-edge switches that are inserted in the switch network hierarchy to simplify and\/or facilitate the operation of the controlled edge switches. For instance, in some embodiments, the control system requires the switches that it controls to be interconnected in a hierarchical switching architecture that has several edge switches as the leaf nodes and one or more non-edge switches as the non-leaf nodes. In some such embodiments, each edge switch connects to one or more of the non-leaf switches, and uses such non-leaf switches to facilitate its communication with other edge switches. Examples of functions that such non-leaf switches provide to facilitate such communications between edge switches in some embodiments include (1) routing of a packet with an unknown destination address (e.g., unknown MAC address) to the non-leaf switch so that this switch can route this packet to the appropriate edge switch, (2) routing a multicast or broadcast packet to the non-leaf switch so that this switch can convert this packet to a series of unicast packets to the desired destinations, (3) bridging remote managed networks that are separated by one or more networks, and (4)bridging a managed network with an unmanaged network.","Some embodiments employ one level of non-leaf (non-edge) switches that connect to edge switches and in some cases to other non-leaf switches. Other embodiments, on the other hand, employ multiple levels of non-leaf switches, with each level of non-leaf switch after the first level serving as a mechanism to facilitate communication between lower level non-leaf switches and leaf switches. In some embodiments, the non-leaf switches are software switches that are implemented by storing the switching tables in the memory of a standalone computer instead of an off the shelf switch. In some embodiments, the standalone computer may also be executing in some cases a hypervisor and one or more virtual machines on top of that hypervisor. Irrespective of the manner by which the leaf and non-leaf switches are implemented, the NIB of the control system of some embodiments stores switching state information regarding the leaf and non-leaf switches.","The above discussion relates to the control of edge switches and non-edge switches by a network control system of some embodiments. In some embodiments, edge switches and non-edge switches (leaf and non-leaf nodes) may be referred to as managed switches. This is because these switches are managed by the network control system (as opposed to unmanaged switches, which are not managed by the network control system, in the network) in order to implement logical data path sets through the managed switches.","In addition to using the NIB to store switching-element data, the virtualized network-control system of some embodiments also stores other storage structures to store data regarding the switching elements of the network. These other storage structures are secondary storage structures that supplement the storage functions of the NIB, which is the primary storage structure of the system while the system operates. In some embodiments, the primary purpose for one or more of the secondary storage structures is to back up the data in the NIB. In these or other embodiments, one or more of the secondary storage structures serve a purpose other than backing up the data in the NIB (e.g., for storing data that is not in the NIB).","In some embodiments, the NIB is stored in system memory (e.g., RAM) while the system operates. This allows for fast access of the NIB records. In some embodiments, one or more of the secondary storage structures, on the other hand, are stored on disks, or other non-volatile memories, which can be slower to access. Such non-volatile disks or other non-volatile memories, however, improve the resiliency of the system as they allow the data to be stored in a persistent manner.","The system of some embodiments uses multiple types of storages in its pool of secondary storage structures. These different types of structures store different types of data, store data in different manners, and provide different query interfaces that handle different types of queries. For instance, in some embodiments, the system uses a persistent transactional database (PTD) and a hash table structure. The PTD in some embodiments is a database that is stored on disk or other non-volatile memory. In some embodiments, the PTD is a commonly available database, such as MySQL or SQLite. The PTD of some embodiments can handle complex transactional queries. As a transactional database, the PTD can undo a series of earlier query operations that it has performed as part of a transaction when one of the subsequent query operations of the transaction fails.","Moreover, some embodiments define a transactional guard processing (TGP) layer before the PTD in order to allow the PTD to execute conditional sets of database transactions. The TGP layer allows the PTD to avoid unnecessary later database operations when conditions of earlier operations are not met. The PTD in some embodiments stores an exact replica of the data that is stored in the NIB, while in other embodiments it stores only a subset of the data that is stored in the NIB. In some embodiments, some or all of the data in the NIB is stored in the PTD in order to ensure that the NIB data will not be lost in the event of a crash of the NOS or the NIB.","While the system is running, the hash table in some embodiments is not stored on a disk or other non-volatile memory. Instead, it is a storage structure that is stored in volatile system memory when the system is running. When the system is powered down, the contents of the hash table are stored on disk. The hash table uses hashed indices that allow it to retrieve records in response to queries. This structure combined with the hash table's placement in the system's volatile memory allows the table to be accessed very quickly. To facilitate this quick access, a simplified query interface is used in some embodiments. For instance, in some embodiments, the hash table has just two queries: a Put query for writing values to the table and a Get query for retrieving values from the table. The system of some embodiments uses the hash table to store data that the NOS needs to retrieve very quickly. Examples of such data include network entity status, statistics, state, uptime, link arrangement, and packet handling information. Furthermore, in some embodiments, the NOS uses the hash tables as a cache to store information that is repeatedly queried, such as flow entries that will be written to multiple nodes.","Using a single NOS instance to control a network can lead to scaling and reliability issues. As the number of network elements increases, the processing power and\/or memory capacity that are required by those elements will saturate a single node. Some embodiments further improve the resiliency of the control system by having multiple instances of the NOS running on one or more computers, with each instance of the NOS containing one or more of the secondary storage structures described above. Each instance in some embodiments not only includes a NOS instance, but also includes a virtualization application instance and\/or a control application instance. In some of these embodiments, the control and\/or virtualization applications partition the workload between the different instances in order to reduce each instance's control and\/or virtualization workload. Also, in some embodiments, the multiple instances of the NOS communicate the information stored in their secondary storage layers to enable each instance of the NOS to cover for the others in the event of a NOS instance failing. Moreover, some embodiments use the secondary storage layer (i.e., one or more of the secondary storages) as a channel for communicating between the different instances.","The distributed, multi-instance control system of some embodiments maintains the same switch element data records in the NIB of each instance, while in other embodiments, the system allows NIBs of different instances to store different sets of switch element data records. Some embodiments that allow different instances to store different portions of the NIB, divide the NIB into N mutually exclusive portions and store each NIB portion in one NIB of one of N controller instances, where N is an integer value greater than 1. Other embodiments divide the NIB into N portions and store different NIB portions in different controller instances, but allow some or all of the portions to partially (but not completely) overlap with the other NIB portions.","The hash tables in the distributed control system of some embodiments form a distributed hash table (DHT), with each hash table serving as a DHT instance. In some embodiments, the DHT instances of all controller instances collectively store one set of records that is indexed based on hashed indices for quick access. These records are distributed across the different controller instances to minimize the size of the records within each instance and to allow for the size of the DHT to be increased by adding other DHT instances. According to this scheme, each DHT record is not stored in each controller instance. In fact, in some embodiments, each DHT record is stored in at most one controller instance. To improve the system's resiliency, some embodiments, however, allow one DHT record to be stored in more than one controller instance, so that in case one instance fails, the DHT records of that failed instance can be accessed from other instances. Some embodiments do not allow for replication of records across different DHT instances or allow only a small amount of such records to be replicated because these embodiments store in the DHT only the type of data that can be quickly re-generated.","The distributed control system of some embodiments replicates each NIB record in the secondary storage layer (e.g., in each PTD instance and\/or in the DHT) in order to maintain the records in the NIB in a persistent manner. For instance, in some embodiments, all the NIB records are stored in the PTD storage layer. In other embodiments, only a portion of the NIB data is replicated in the PTD storage layer. For instance, some embodiments store a subset of the NIB records in another one of the secondary storage records, such as the DHT.","By allowing different NOS instances to store the same or overlapping NIB records, and\/or secondary storage structure records, the system improves its overall resiliency by guarding against the loss of data due to the failure of any NOS or secondary storage structure instance. For instance, in some embodiments, the portion of NIB data that is replicated in the PTD (which is all of the NIB data in some embodiments or part of the NIB data in other embodiments) is replicated in the NIBs and PTDs of all controller instances, in order to protect against failures of individual controller instances (e.g., of an entire controller instance or a portion of the controller instance).","In some embodiments, each of the storages of the secondary storage layer uses a different distribution technique to improve the resiliency of a multiple NOS instance system. For instance, as mentioned above, the system of some embodiments replicates the PTD across NOS instances so that every NOS has a full copy of the PTD to enable a failed NOS instance to quickly reload its PTD from another instance. In some embodiments, the system distributes the DHT fully or with minimal overlap across multiple controller instances in order to minimize the size of the DHT instance (e.g., the amount of memory the DHT instance utilizes) within each instance. This approach also allows the size of the DHT to be increased by adding additional DHT instances, and this in turn allows the system to be more scalable.","For some or all of the communications between the distributed instances, the distributed system of some embodiments uses coordination managers (CM) in the controller instances to coordinate activities between the different controllers. Examples of such activities include writing to the NIB, writing to the PTD, writing to the DHT, controlling the switching elements, facilitating intra-controller communication related to fault tolerance of controller instances, etc.","To distribute the workload and to avoid conflicting operations from different controller instances, the distributed control system of some embodiments designates one controller instance within the system as the master of any particular NIB portion (e.g., as the master of a logical data path set) and one controller instance within the system as the master of any given switching element. Even with one master controller, a different controller instance can request changes to different NIB portions and\/or to different switching elements controlled by the master. If allowed, the master instance then effectuates this change and writes to the desired NIB portion and\/or switching element. Otherwise, the master rejects the request.","The preceding Summary is intended to serve as a brief introduction to some embodiments of the invention. It is not meant to be an introduction or overview of all inventive subject matter disclosed in this document. The Detailed Description that follows and the Drawings that are referred to in the Detailed Description will further describe the embodiments described in the Summary as well as other embodiments. Accordingly, to understand all the embodiments described by this document, a full review of the Summary, Detailed Description and the Drawings is needed. Moreover, the claimed subject matters are not to be limited by the illustrative details in the Summary, Detailed Description and the Drawings, but rather are to be defined by the appended claims, because the claimed subject matters can be embodied in other specific forms without departing from the spirit of the subject matters.","In the following detailed description of the invention, numerous details, examples, and embodiments of the invention are set forth and described. However, it will be clear and apparent to one skilled in the art that the invention is not limited to the embodiments set forth and that the invention may be practiced without some of the specific details and examples discussed.","Some embodiments of the invention provide a method that allows several different logical data path sets to be specified for several different users through one or more shared switching elements without allowing the different users to control or even view each other's switching logic. In some embodiments, the method provides a set of software tools that allows the system to accept logical data path sets from users and to configure the switching elements to implement these logical data path sets. These software tools allow the method to virtualize control of the shared switching elements and the network that is defined by the connections between these shared switching elements, in a manner that prevents the different users from viewing or controlling each other's logical data path sets while sharing the same switching elements.","In some embodiments, one of the software tools that the method provides that allows it to virtualize control of a set of switching elements (i.e., to enable the method to allow several users to share the same switching elements without viewing or controlling each other's logical data path sets) is an intermediate data storage structure that (1) stores the state of the network, (2) receives modifications to different parts of the network from different users, and (3), in some embodiments, provides different views of the state of the network to different users. For instance, in some embodiments, the intermediate data storage structure is a network information base (NIB) data structure that stores the state of the network that is defined by one or more switching elements. In some embodiments, the NIB also stores the logical configuration and the logical state for each user specified logical data path set. In these embodiments, the information in the NIB that represents the state of the actual switching elements accounts for only a subset of the total information stored in the NIB.","The method uses the NIB data structure to read the state of the network and to write modifications to the state of the network. When the data structure is modified in order to effectuate a change in the switching logic of a switching element, the method propagates the modification to the switching element.","In some embodiments, the method is employed by a virtualized network control system that (1) allows user to specify different logical data path sets, (2) maps these logical data path sets to a set of switching elements managed by the control system. In some embodiments, the switching elements include virtual or physical network switches, software switches (e.g., Open vSwitch), routers, and\/or other switching elements, as well as any other network elements (such as load balancers, etc.) that establish connections between these switches, routers, and\/or other switching elements. Such switching elements (e.g., physical switching elements, such as physical switches or routers) are implemented as software switches in some embodiments. Software switches are switches that are implemented by storing the switching tables in the memory of a standalone computer instead of an off the shelf switch. In some embodiments, the standalone computer may also be executing in some cases a hypervisor and one or more virtual machines on top of that hypervisor","These switches are referred to below as managed switching elements or managed forwarding elements as they are managed by the network control system in order to implement the logical data path sets. In some embodiments described below, the control system manages these switching elements by pushing physical control plane data to them, as further described below. Switching elements generally receive data (e.g., a data packet) and perform one or more processing operations on the data, such as dropping a received data packet, passing a packet that is received from one source device to another destination device, processing the packet and then passing it a destination device, etc. In some embodiments, the physical control plane data that is pushed to a switching element is converted by the switching element (e.g., by a general purpose processor of the switching element) to physical forwarding plane data that specify how the switching element (e.g., how a specialized switching circuit of the switching element) process data packets that it receives.","The virtualized control system of some embodiments includes (1) a network operating system (NOS) that creates and maintains the NIB storage structure, and (2) one or more applications that run on top of the NOS to specify control logic for reading values from and writing values to the NIB. The NIB of some of these embodiments serves as a communication channel between the different controller instances and, in some embodiments, a communication channel between different processing layers of a controller instance.","Several examples of such systems are described below in Section I. Section II then describes the NIB data structure of some embodiments of the invention. Section III then describes a distributed, multi-instance architecture of some embodiments in which multiple stacks of the NOS and the control applications are used to control the shared switching elements within a network in a scalable and resilient manner. Section IV then provides a more detailed example of the NOS of some embodiments of the invention. Section V then describes several other data storage structures that are used by the NOS of some embodiments of the invention. Finally, Section VI describes the computer systems and processes used to implement some embodiments of the invention.","I. Virtualized Control System",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 1","b":"100"},"As shown in , the system  includes one or more switching elements , a network operating system , a network information base , and one or more applications . The switching elements include N switching elements (where N is a number equal to 1 or greater) that form the network infrastructure switching elements of the system . In some embodiments, the network infrastructure switching elements include virtual or physical network switches, software switches (e.g., Open vSwitch), routers, and\/or other switching elements, as well as any other network elements (such as load balancers, etc.) that establish connections between these switches, routers, and\/or other switching elements. All such network infrastructure switching elements are referred to below as switching elements or forwarding elements.","The virtual or physical switching elements  typically include control switching logic  and forwarding switching logic . In some embodiments, a switch's control logic  specifies (1) the rules that are to be applied to incoming packets, (2) the packets that will be discarded, and (3) the packet processing methods that will be applied to incoming packets. The virtual or physical switching elements  use the control logic  to populate tables governing the forwarding logic . The forwarding logic  performs lookup operations on incoming packets and forwards the incoming packets to destination addresses.","As further shown in , the system  includes one or more applications  through which switching logic (i.e., sets of logical data paths) is specified for one or more users (e.g., by one or more administrators or users). The network operating system (NOS)  serves as a communication interface between (1) the switching elements  that perform the physical switching for any one user, and (2) the applications  that are used to specify switching logic for the users. In this manner, the application logic determines the desired network behavior while the NOS merely provides the primitives needed to access the appropriate network state. In some embodiments, the NOS  provides a set of Application Programming Interfaces (API) that provides the applications  programmatic access to the network switching elements  (e.g., access to read and write the configuration of network switching elements). In some embodiments, this API set is data-centric and is designed around a view of the switching infrastructure, allowing control applications to read the state from and write the state to any element in the network.","To provide the applications  programmatic access to the switching elements, the NOS  itself needs to be able to control the switching elements . The NOS uses different techniques in different embodiments to control the switching elements. In some embodiments, the NOS can specify both control and forwarding switching logic  and  of the switching elements. In other embodiments, the NOS  controls only the control switching logic  of the switching elements, as shown in . In some of these embodiments, the NOS  manages the control switching logic  of a switching element through a commonly known switch-access interface that specifies a set of APIs for allowing an external application (such as a network operating system) to control the control plane functionality of a switching element. Two examples of such known switch-access interfaces are the OpenFlow interface and the Open Virtual Switch interface, which are respectively described in the following two papers: McKeown, N. (2008). (which can be retrieved from http:\/\/www.openflowswitch.org\/\/documents\/openflow-wp-latest.pdf), and Pettit, J. (2010). (which can be retrieved from http:\/\/openvswitch.org\/papers\/dccaves2010.pdf). These two papers are incorporated herein by reference.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 1","b":["135","125"]},"In order to define the control switching logic  for physical switching elements, the NOS of some embodiments uses the Open Virtual Switch protocol to create one or more control tables within the control plane of a switch element. The control plane is typically created and executed by a general purpose CPU of the switching element. Once the system has created the control table(s), the system then writes flow entries to the control table(s) using the OpenFlow protocol. The general purpose CPU of the physical switching element uses its internal logic to convert entries written to the control table(s) to populate one or more forwarding tables in the forwarding plane of the switch element. The forwarding tables are created and executed typically by a specialized switching chip of the switching element. Through its execution of the flow entries within the forwarding tables, the switching chip of the switching element can process and route packets of data that it receives.","To enable the programmatic access of the applications  to the switching elements , the NOS also creates the network information base (NIB) . The NIB is a data structure in which the NOS stores a copy of the switch-element states tracked by the NOS. The NIB of some embodiments is a graph of all physical or virtual switch elements and their interconnections within a physical network topology and their forwarding tables. For instance, in some embodiments, each switching element within the network infrastructure is represented by one or more data objects in the NIB. However, in other embodiments, the NIB stores state information about only some of the switching elements. For example, as further described below, the NIB in some embodiments only keeps track of switching elements at the edge of a network infrastructure. In yet other embodiments, the NIB stores state information about edge switching elements in a network as well as some non-edge switching elements in the network that facilitate communication between the edge switching elements. In some embodiments, the NIB also stores the logical configuration and the logical state for each user specified logical data path set. In these embodiments, the information in the NIB that represents the state of the actual switching elements accounts for only a subset of the total information stored in the NIB.","In some embodiments, the NIB  is the heart of the NOS control model in the virtualized network system . Under one approach, applications control the network by reading from and writing to the NIB. Specifically, in some embodiments, the application control logic can (1) read the current state associated with network entity objects in the NIB, (2) alter the network state by operating on these objects, and (3) register for notifications of state changes to these objects. Under this model, when an application  needs to modify a record in a table (e.g., a control plane flow table) of a switching element , the application  first uses the NOS' APIs to write to one or more objects in the NIB that represent the table in the NIB. The NOS then, acting as the switching element's controller, propagates this change to the switching element's table.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 2","FIG. 2"],"b":["110","205","215","210","205","230","235","240","220","225","230","235","220"]},"Next, in the third stage, the NOS uses the set of switch-access APIs to write a new set of values into the switch. In some embodiments, the NIB performs a translation operation that modifies the format of the records before writing these records into the NIB. This operation is pictorially illustrated in  by showing the values d, e, and f translated into d\u2032, e\u2032, and f\u2032, and the writing of these new values into the switch . Alternatively, in some embodiments, one or more sets of values are kept identically in the NIB and the switching element, which thereby causes the NOS  to write the NIB values directly to the switch  unchanged.","In yet other embodiments, the NOS' translation operation might modify the set of values in the NIB (e.g., the values d, e, and f) into a different set of values with fewer values (e.g., values x and y, where x and y might be a subset of d, e, and f, or completely different) or additional values (e.g., the w, x, y, and z, where w, x, y, and z might be a super set of all or some of d, e, and f, or completely different). The NOS in these embodiments would then write this modified set of values (e.g., values x and y, or values w, x, y and z into the switching element).","The fourth stage finally shows the switch  after the old values a, b, and c have been replaced in the switch control record  with the values d\u2032, e\u2032, and f\u2032. Again, in the example shown in , the NOS of some embodiments propagates NIB records to the switches as modified versions of the records were written to the NIB. In other embodiments, the NOS applies processing (e.g., data transformation) to the NIB records before the NOS propagates the NIB records to the switches, and such processing changes the format, content and quantity of data written to the switches.","A. Different NIB Views","In some embodiments, the virtualized system  of  provides different views of the NIB to different users in order (1) to ensure that different users do not have direct view and control over each other's switching logic and (2) to provide each user with a view of the switching logic at an abstraction level that is desired by the user. For instance, in some embodiments, the NIB is a hierarchical data structure that represents different attributes of different switching elements as elements (e.g., different nodes) in a hierarchy. The NIB in some of these embodiments is a multi-layer hierarchical data structure, with each layer having a hierarchical structure and one or more elements (e.g., nodes) on each layer linked to one or more elements (e.g., nodes) on another layer. In some embodiments, the lowest layer elements correspond to the actual switching elements and their attributes, while each of the higher layer elements serve as abstractions of the actual switching elements and their attributes. As further described below, some of these higher layer elements are used in some embodiments to show different abstract switching elements and\/or switching element attributes to different users in a virtualized control system. In other words, the NOS of some embodiments generates the multi-layer, hierarchical NIB data structure, and the NOS or an application that runs on top of the NOS shows different users different views of different parts of the hierarchical levels and\/or layers, in order to provide the different users with virtualized access to the shared switching elements and network.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 3","FIG. 1","FIG. 1"],"b":["300","300","100","300","105","105","120","105"],"i":["a","d "]},"In system , the NIB  stores sets of data records for each of the switching elements -. In some embodiments, a system administrator can access these four sets of data through an application  that interfaces with the NOS. However, other users that are not system administrators do not have access to all of the four sets of records in the NIB, because some switch logic records in the NIB might relate to the logical switching configuration of other users.","Instead, each non-system-administrator user can only view and modify the switching element records in the NIB that relate to the logical switching configuration of the user.  illustrates this limited view by showing the application  providing a first layered NIB view  to a first user  and a second layered NIB view  to a second user . The first layered NIB view  shows the first user data records regarding the configuration of the shared switching elements -for implementing the first user's switching logic and the state of this configuration. The second layered NIB view  shows the second user data records regarding the configuration of the shared switching elements -for implementing the second user's switching logic and the state of this configuration. In viewing their own logical switching configuration, neither user can view the other user's logical switching configuration.","In some embodiments, each user's NIB view is a higher level NIB view that represents an abstraction of the lowest level NIB view that correlates to the actual network infrastructure that is formed by the switching elements -. For instance, as shown in , the first user's layered NIB view  shows two switches that implement the first user's logical switching configuration, while the second user's layered NIB view  shows one switch that implements the second user's logical switching configuration. This could be the case even if either user's switching configuration uses all four switching elements -. However, under this approach, the first user perceives that his computing devices are interconnected by two switching elements, while the second user perceives that her computing devices are interconnected by one switching element.","The first layered NIB view is a reflection of a first set of data records  that the application  allows the first user to access from the NIB, while the second layered NIB view is a representation of a second set of data records  that the application  allows the second user to access from the NIB. In some embodiments, the application  retrieves the two sets of data records  and  from the NIB and maintains these records locally, as shown in . In other embodiments, however, the application does not maintain these two sets of data records locally. Instead, in these other embodiments, the application simply provides the users with an interface to access the limited set of first and second data records from the NIB . Also, in other embodiments, the system  does not provide switching element abstractions in the higher layered NIB views  and  that it provides to the users. Rather, it simply provides views to the limited first and second set of data records  and  from the NIB.","Irrespective of whether the application maintains a local copy of the first and second data records or whether the application only provides the switching element abstractions in its higher layered NIB views, the application  serves as an interface through which each user can view and modify the user's logical switching configuration, without being able to view or modify the other user's logical switching configuration. Through the set of APIs provided by the NOS , the application  propagates to the NIB  changes that a user makes to the logical switching configuration view that the user receives from the application. The propagation of these changes entails the transferring, and in some cases of some embodiments, the transformation, of the high level data entered by a user for a higher level NIB view to lower level data that is to be written to lower level NIB data that is stored by the NOS.","In the system  of , the application  can perform several different sets of operations in several different embodiments of the invention, as apparent from the discussion above. Examples of such operations include providing an interface to a user to access NIB data regarding the user's logical switching configuration, providing different layered NIB views to different users, providing control logic for modifying the provided NIB data, providing logic for propagating received modifications to the NIB structure stored by the NOS, etc.","The system of some embodiments embeds all such operations in the NOS  instead of in the application  operating on top of the NOS. Alternatively, in other embodiments the system separates these operations into several applications that operate above the NOS.  illustrates a virtualized system that employs several such applications. Specifically, this figure illustrates a virtualized system  that is similar to the virtualized system  of , except that the operations of the application  in the system  have been divided into two sets of operations, one that is performed by a control application  and one that is performed by a virtualization application .","In some embodiments, the virtualization application  interfaces with the NOS  to provide different views of different NIB records to different users through the control application . The control application  also provides the control logic for allowing a user to specify different operations with respect to the limited NIB records\/views provided by the virtualization application. Examples of such operations can be read operations from the NIB or write operations to the NIB. The virtualization application then translates these operations into operations that access the NIB. In translating these operations, the virtualization application in some embodiments also transfers and\/or transforms the data that are expressed in terms of the higher level NIB records\/views to data that are expressed in terms of lower level NIB records.","Even though  shows just one control application and one virtualization application being used for the two users, the system  in other embodiments employs two control applications and\/or two virtualization applications for the two different users. Similarly, even though several of the above-described figures show one or more applications operating on a single NOS instance, other embodiments provide several different NOS instances on top of each of which one or more applications can execute. Several such embodiments will be further described below.","B. Type I Versus Type II Virtualized System","Different embodiments of the invention use different types of virtualization applications. One type of virtualization application exposes the definition of different elements at different hierarchical levels in the NIB and the definition of the links between these elements to the control applications that run on top of the NOS and the virtualization application in order to allow the control application to define its operations by reference to these definitions. For instance, in some embodiments, the developer of the control application running on top of the virtualization application uses these definitions to enumerate how the application is to map the logical data path sets of the user to the physical switching elements of the control system. Under this approach, the developer would have to enumerate all different scenarios that the control system may encounter and the mapping operation of the application for each scenario. This type of virtualization is referred to below as Type I network virtualization.","Another type of network virtualization, which is referred to below as Type II network virtualization, does not require the application developers to have intimate knowledge of the NIB elements and the links in the NIB between these elements. Instead, this type of virtualization allows the application to simply provide user specified switching element attributes in the form of one or more tables, which are then mapped to NIB records by a table mapping engine. In other words, the Type II virtualized system of some embodiments accepts switching element configurations (e.g., access control list table configurations, L2 table configurations, L3 table configurations, etc.) that the user defines without referencing any operational state of the switching elements in a particular network configuration. It then maps the user-specified switching element configurations to the switching element configurations stored in the NIB.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 5","FIG. 3","FIG. 4"],"b":["300","400","500","110","105","105","400","500","520","525","110","520","525"],"i":["a","d"]},"More specifically, the control application  allows (1) a user to specify abstract switching element configurations, which the virtualization application  then maps to the data records in the NIB, and (2) the user to view the state of the abstract switching element configurations. In some embodiments, the control application  uses a network template library  to allow a user to specify a set of logical data paths by specifying one or more switch element attributes (i.e., one or more switch element configurations). In the example shown in , the network template library includes several types of tables that a switching element may include. In this example, the user has interfaced with the control application  to specify an L2 table , an L3 table , and an access control list (ACL) table . These three table specify a logical data path set  for the user. In some embodiments a logical data path set defines a logical switching element (also referred to as a logical switch). A logical switch in some embodiments is a simulated\/conceptual switch that is defined (e.g., by a user) to conceptually describe a set of switching behaviors for a switch. The control application of some embodiments (such as the control application  illustrated in ) implements this logical switch across one or more physical switches, which as mentioned above may be hardware switches, software switches, or virtual switches defined on top of other switches.","In specifying these tables, the user simply specifies desired switch configuration records for one or more abstract, logical switching elements. When specifying these records, the user of the system  does not have any understanding of the switching elements -employed by the system nor any data regarding these switching elements from the NIB . The only switch-element specific data that the user of the system  receives is the data from the network template library, which specifies the types of network elements that the user can define in the abstract, which the system can then process.","While the example in  shows the user specifying an ACL table, one of ordinary skill in the art will realize that the system of some embodiments does not provide such specific switch table attributes in the library . For instance, in some embodiments, the switch-element abstractions provided by the library  are generic switch tables and do not relate to any specific switching element table, component and\/or architecture. In these embodiments, the control application  enables the user to create generic switch configurations for a generic set of one or more tables. Accordingly, the abstraction level of the switch-element attributes that the control application  allows the user to create is different in different embodiments.","Irrespective of the abstraction level of the switch-element attributes produced through the control logic application, the virtualization application  performs a mapping operation that maps the specified switch-element attributes (e.g., the specific or generic switch table records) to records in the NIB. In some embodiments, the virtualization application translates control application input into one or more NIB records  that the virtualization application then writes to the NIB through the API set provided by the NOS. From the NIB, these records are then subsequently transferred to the switching infrastructure through the operation of the NOS. In some embodiments, the NIB stores both the logical data path set input received through the control application as well as the NIB records that are produced by the virtualization application.","In some embodiments, the control application can receive switching infrastructure data from the NIB. In response to this data, the control application may modify record(s) associated with one or more logical data path sets (LDPS). Any such modified LDPS record would then be translated to one or more physical switching infrastructure records by the virtualization application, which might then be transferred to the physical switching infrastructure by the NOS.","To map the control application input to physical switching infrastructure attributes for storage in the NIB, the virtualization application of some embodiments uses a database table mapping engine to map input tables, which are created from (1) the control-application specified input tables, and (2) a set of properties associated with switching elements used by the system, to output tables. The content of these output tables are then transferred to the NIB elements.","Some embodiments use a variation of the datalog database language to allow application developers to create the table mapping engine for the virtualization application, and thereby to specify the manner by which the virtualization application maps logical data path sets to the controlled physical switching infrastructure. This variation of the datalog database language is referred to below as nLog. Like datalog, nLog provides a few declaratory rules and operators that allow a developer to specify different operations that are to be performed upon the occurrence of different events. In some embodiments, nLog provides a limited subset of the operators that are provided by datalog in order to increase the operational speed of nLog. For instance, in some embodiments, nLog only allows the AND operator to be used in any of the declaratory rules.","The declaratory rules and operations that are specified through nLog are then compiled into a much larger set of rules by an nLog compiler. In some embodiments, this compiler translates each rule that is meant to address an event into several sets of database join operations. Collectively the larger set of rules forms the table-mapping rules engine that is referred to below as the nLog engine. The nLog mapping techniques of some embodiments are further described in U.S. patent application Ser. No. 13\/177,533, now published as U.S. Patent Publication 2013\/0058228, entitled \u201cNetwork Virtualization Apparatus and Method,\u201d filed concurrently with this application.","In some embodiments, the nLog virtualization engine provides feedback (e.g., from one or more of the output tables or from NIB records that are updated to reflect values stored in the output tables) to the user in order to provide the user with state information about the logical data path set that he or she created. In this manner, the updates that the user gets are expressed in terms of the logical space that the user understands and not in terms of the underlying switching element states, which the user does not understand.","The use of nLog serves as a significant distinction between Type I virtualized control systems and Type II virtualized control systems, even for Type II systems that store user specified logical data path sets in the NIB. This is because nLog provides a machine-generated rules engine that addresses the mapping between the logical and physical domains in a more robust, comprehensive manner than the hand-coded approach used for Type I virtualized control systems. In the Type I control systems, the application developers need to have a detailed understanding of the NIB structure and need to use this detailed understanding to write code that addresses all possible conditions that the control system would encounter at runtime. On the other hand, in Type II control systems, the application developers only need to produce applications that express the user-specified logical data path sets in terms of one or more tables, which are then automatically mapped to output tables whose contents are in turn transferred to the NIB. This approach allows the Type II virtualized systems to forego maintaining the data regarding the logical data path sets in the NIB. However, some embodiments maintain this data in the NIB in order to distribute this data among other NOS instances, as further described below.","In some embodiments, the system  propagates instructions to control a set of the switching elements -through the control application , the virtualization application , and the NOS . Specifically, in some embodiment, the control application , the virtualization application , and the NOS  collectively translate and propagate control plane data through the three layers to a set of the switching elements -","The control application  of some embodiments has two logical planes that can be used to express the input to and output from this application. In some embodiments, the first logical plane is a logical control plane that includes a collection of higher-level constructs that allow the control application  and its users to define a logical plane for a logical switching element by specifying one or more logical data path sets for a user. The second logical plane in some embodiments is the logical forwarding plane, which represents the logical data path sets of the users in a format that can be processed by the virtualization application . In this manner, the two logical planes are logical space analogs of physical control and forwarding planes that are typically found in a typical managed switch.","In some embodiments, the control application  defines and exposes the logical control plane constructs with which the application itself or users of the application specifies different logical data path sets. For instance, in some embodiments, the logical control plane data  includes the logical ACL table , the logical L2 table , and the logical L3 table . Some of this data can be specified by the user, while other such data are generated by the control application. In some embodiments, the control application  generates and\/or specifies such data in response to certain changes to the NIB (which indicate changes to the switching elements -and the managed data path sets) that the control application  detects.","In some embodiments, the logical control plane data (i.e., the LDPS data  that is expressed in terms of the control plane constructs) can be initially specified without consideration of current operational data from the switching elements -and without consideration of the manner by which this control plane data will be translated to physical control plane data. For instance, the logical control plane data might specify control data for one logical switch that connects five computers, even though this control plane data might later be translated to physical control data for three of the switching elements -that implement the desired switching between the five computers.","The control application  of some embodiments includes a set of modules (not shown) for converting any logical data path set within the logical control plane to a logical data path set in the logical forwarding plane of the control application . Some embodiments may express the logical data path set in the logical forwarding plane of the control application  as a set of forwarding tables (e.g., the L2 table  and L3 table ). The conversion process of some embodiments includes the control application  populating logical data path tables (e.g., logical forwarding tables) that are created by the virtualization application  with logical data path sets. In some embodiments, the control application  uses an nLog table mapping engine to perform this conversion. The control application's use of the nLog table mapping engine to perform this conversion is further described in U.S. patent application Ser. No. 13\/177,532, now issued as U.S. Pat. No. 8,743,888, entitled \u201cNetwork Control Apparatus and Method\u201d, filed concurrently with this application.","The virtualization application  of some embodiments also has two planes of data, a logical forwarding plane and a physical control plane. The logical forwarding plane is identical or similar to the logical forwarding plane produced by the control application . In some embodiments, the logical forwarding plane of the virtualization application  includes one or more logical data path sets of one or more users. The logical forwarding plane of the virtualization application  in some embodiments includes logical forwarding data for one or more logical data path sets of one or more users. Some of this data is pushed directly or indirectly to the logical forwarding plane of the virtualization application  by the control application , while other such data are pushed to the logical forwarding plane of the virtualization application  by the virtualization application  detecting events in the NIB.","The physical control plane of the virtualization application  includes one or more physical data path sets of one or more users. Some embodiments of the virtualization application  include a set of modules (not shown) for converting any LDPS within the logical forwarding plane of the virtualization application  to a physical data path set in the physical control plane of the virtualization application . In some embodiments, the virtualization application  uses the nLog table mapping engine to perform this conversion. The virtualization application  also includes a set of modules (not shown) for pushing the control plane data from the physical control plane of the virtualization application  into the NIB of the NOS .","From the NIB, the physical control plane data is later pushed into a set of the switching elements -(e.g., switching elements and ). In some embodiments, the physical control plane data is pushed to each of the set of the switching elements -by the controller instance that is the master of the switching element. In some cases, the master controller instance of the switching element is the same controller instance that converted the logical control plane data to the logical forwarding plane data and the logical forwarding plane data to the physical control plane data. In other cases, the master controller instance of the switching element is not the same controller instance that converted the logical control plane data to the logical forwarding plane data and the logical forwarding plane data to the physical control plane data. The set of the switching elements -then converts this physical control plane data to physical forwarding plane data that specifies the forwarding behavior of the set of the switching elements -","In some embodiments, the physical control plane data that is propagated to the set of the switching elements -allows the set of the switching elements -to perform the logical data processing on data packets that it processes in order to effectuate the processing of the logical data path sets specified by the control application . In some such embodiments, physical control planes include control plane data for operating in the physical domain and control plane data for operating in the logical domain. In other words, the physical control planes of these embodiments include control plane data for processing network data (e.g., packets) through switching elements to implement physical switching and control plane data for processing network data through switching elements in order to implement the logical switching. In this manner, the physical control plane facilitates implementing logical switches across the switching elements. The use of the propagated physical control plane to implement logical data processing in the switching elements is further described in U.S. application Ser. No. 13\/177,535, now issued as U.S. Pat. No. 8,750,164, entitled \u201cHierarchical Managed Switch Architecture\u201d, filed concurrently with this application.","In addition to pushing physical control plane data to the NIB , the control and virtualization applications  and  also store logical control plane data and logical forwarding plane data in the NIB . These embodiments store such data in the NIB  for a variety of reasons. For instance, in some embodiments, the NIB  serves as a medium for communications between different controller instances, and the storage of such data in the NIB  facilitates the relaying of such data across different controller instances.","The NIB  in some embodiments serves as a hub for all communications among the control application , the virtualization application , and the NOS . For instance, the control application  may store in the NIB logical data path sets in the logical forwarding plane that have been converted from logical data path sets in the logical control plane. The virtualization application  may retrieve from the NIB the converted logical data path sets in the logical forwarding plane and then convert the logical data path sets to physical data path sets in the physical control plane of the virtualization application . Thus, the NIB of some embodiments serves as a medium for communication between the different processing layers. Also, the NIB  in these embodiments stores logical control plane data and logical forwarding plane data as well as physical control plane data.","The above description describes a control data pipeline through three processing layers to a set of the switching elements -. However, in some embodiments, the control data pipeline may have two processing layers instead of three with the upper layer being a single application that performs the functionalities of both the control application  and the virtualization application . For example, a single virtualization application (also called a network hypervisor) may replace these the control application  and the virtualization application  in some embodiments. In such embodiments, the control application  would form the front end of this network hypervisor, and would create and populate the logical data path sets. The virtualization application  in these embodiments would form the back end of the network hypervisor, and would convert the logical data path sets to physical data path sets that are defined in the physical control plane.","In some embodiments, the different processing layers are implemented on a single computing device. Referring to  as an example, some such embodiments may execute the control application , and virtualization application , and the NOS  on a single computing device. However, some embodiments may execute the different processing layers on different computing devices. For instance, the control application , and virtualization application , and the NOS  may each be executed on separate computing devices. Other embodiments may execute any number of processing layers on any number of different computing devices.","C. Edge and Non-Edge Switch Controls","As mentioned above, the NIB in some embodiments stores data regarding each switching element within the network infrastructure of a system, while in other embodiments, the NIB stores state information about only switching elements at the edge of a network infrastructure.  illustrate an example that differentiates the two differing approaches. Specifically,  illustrates the switch infrastructure of a multi-tenant server hosting system. In this system, six switching elements are employed to interconnect six computing devices of two users A and B. Four of these switches - are edge switches that have direct connections with the computing devices - of the users A and B, while two of the switches  and  are interior switches (i.e., non-edge switches) that interconnect the edge switches and connect to each other.",{"@attributes":{"id":"p-0145","num":"0144"},"figref":["FIG. 7","FIG. 7"],"b":["700","605","620","700","110","115","605","620","705","110","605","620","610","645","615","650","605","620","610","615"]},"The system of some embodiments only controls edge switches (i.e., only maintains data in the NIB regarding edge switches) for several reasons. Controlling edge switches provides the system with a sufficient mechanism for maintaining isolation between computing devices, which is needed, as opposed to maintaining isolation between all switch elements, which is not needed. The interior switches forward between switching elements. The edge switches forward between computing devices and other network elements. Thus, the system can maintain user isolation simply by controlling the edge switch because the edge switch is the last switch in line to forward packets to a host.","Controlling only edge switches also allows the system to be deployed independent of concerns about the hardware vendor of the non-edge switches, because deploying at the edge allows the edge switches to treat the internal nodes of the network as simply a collection of elements that moves packets without considering the hardware makeup of these internal nodes. Also, controlling only edge switches makes distributing switching logic computationally easier. Controlling only edge switches also enables non-disruptive deployment of the system because edge-switching solutions can be added as top of rack switches without disrupting the configuration of the non-edge switches.","In addition to controlling edge switches, the network control system of some embodiments also utilizes and controls non-edge switches that are inserted in the switch network hierarchy to simplify and\/or facilitate the operation of the controlled edge switches. For instance, in some embodiments, the control system requires the switches that it controls to be interconnected in a hierarchical switching architecture that has several edge switches as the leaf nodes in this switching architecture and one or more non-edge switches as the non-leaf nodes in this architecture. In some such embodiments, each edge switch connects to one or more of the non-leaf switches, and uses such non-leaf switches to facilitate its communication with other edge switches. Examples of functions that a non-leaf switch of some embodiments may provide to facilitate such communications between edge switches in some embodiments include (1) routing of a packet with an unknown destination address (e.g., unknown MAC address) to the non-leaf switch so that this switch can route this packet to the appropriate edge switch, (2) routing a multicast or broadcast packet to the non-leaf switch so that this switch can convert this packet to a series of unicast packets to the desired destinations, (3) bridging remote managed networks that are separated by one or more networks, and (4) bridging a managed network with an unmanaged network.","Some embodiments employ one level of non-leaf (non-edge) switches that connect to edge switches and in some cases to other non-leaf switches. Other embodiments, on the other hand, employ multiple levels of non-leaf switches, with each level of non-leaf switch after the first level serving as a mechanism to facilitate communication between lower level non-leaf switches and leaf switches. In some embodiments, the non-leaf switches are software switches that are implemented by storing the switching tables in the memory of a standalone computer instead of an off-the-shelf switch. In some embodiments, the standalone computer may also be executing in some cases a hypervisor and one or more virtual machines on top of that hypervisor. Irrespective of the manner by which the leaf and non-leaf switches are implemented, the NIB of the control system of some embodiments stores switching state information regarding the leaf and non-leaf switches.","The above discussion relates to the control of edge switches and non-edge switches by a network control system of some embodiments. In some embodiments, edge switches and non-edge switches (leaf and non-leaf nodes) may be referred to as managed switches. This is because these switches are managed by the network control system (as opposed to unmanaged switches, which are not managed by the network control system, in the network) in order to implement logical data path sets through the managed switches.","D. Secondary Storage Structure","In addition to using the NIB to store switching-element data, the virtualized network-control system of some embodiments also stores other storage structures to store data regarding the switching elements of the network. These other storage structures are secondary storage structures that supplement the storage functions of the NIB, which is the primary storage structure of the system while the system operates. In some embodiments, the primary purpose for one or more of the secondary storage structures is to back up the data in the NIB. In these or other embodiments, one or more of the secondary storage structures serves a purpose other than backing up the data in the NIB (e.g., for storing data that are not in the NIB).","In some embodiments, the NIB is stored in system memory (e.g., RAM) while the system operates. This allows for fast access of the NIB records. In some embodiments, one or more of the secondary storage structures, on the other hand, are stored on disk or other non-volatile memories that are slower to access. Such non-volatile disk or other storages, however, improve the resiliency of the system as they allow the data to be stored in a persistent manner.",{"@attributes":{"id":"p-0154","num":"0153"},"figref":["FIG. 8","FIGS. 4 and 5"],"b":["800","400","500","805","810","815","820"]},"In some embodiments, the PTD  is a database that is stored on disk or other non-volatile memory. In some embodiments, the PTD is a commonly available database, such as MySQL or SQLite. The PTD of some embodiments can handle complex transactional queries. As a transactional database, the PTD can undo a series of prior query operations that it has performed as part of a transaction when one of the subsequent query operations of the transaction fails. Moreover, some embodiments define a transactional guard processing (TGP) layer before the PTD in order to allow the PTD to execute conditional sets of database transactions. The TGP layer allows the PTD to avoid unnecessary later database operations when conditions of earlier operations are not met.","The PTD in some embodiments stores an exact replica of the data that is stored in the NIB, while in other embodiments it stores only a subset of the data that is stored in the NIB. Some or all of the data in the NIB is stored in the PTD in order to ensure that the NIB data will not be lost in the event of a crash of the NOS or the NIB.","The PNTD  is another persistent database that is stored on disk or other non-volatile memory. Some embodiments use this database to store data (e.g., statistics, computations, etc.) regarding one or more switch element attributes or operations. For instance, this database is used in some embodiments to store the number of packets routed through a particular port of a particular switching element. Other examples of types of data stored in the database  include error messages, log files, warning messages, and billing data. Also, in some embodiments, the PNTD stores the results of operations performed by the application(s)  running on top of the NOS, while the PTD and hash table store only values generated by the NOS.","The PNTD in some embodiments has a database query manager that can process database queries, but as it is not a transactional database, this query manager cannot handle complex conditional transactional queries. In some embodiments, accesses to the PNTD are faster than accesses to the PTD but slower than accesses to the hash table .","Unlike the databases  and , the hash table  is not a database that is stored on disk or other non-volatile memory. Instead, it is a storage structure that is stored in volatile system memory (e.g., RAM). It uses hashing techniques that use hashed indices to quickly identify records that are stored in the table. This structure combined with the hash table's placement in the system memory allows this table to be accessed very quickly. To facilitate this quick access, a simplified query interface is used in some embodiments. For instance, in some embodiments, the hash table has just two queries: a Put query for writing values to the table and a Get query for retrieving values from the table. Some embodiments use the hash table to store data that changes quickly. Examples of such quick-changing data include network entity status, statistics, state, uptime, link arrangement, and packet handling information. Furthermore, in some embodiments, the NOS uses the hash tables as a cache to store information that is repeatedly queried for, such as flow entries that will be written to multiple nodes. Some embodiments employ a hash structure in the NIB in order to quickly access records in the NIB. Accordingly, in some of these embodiments, the hash table  is part of the NIB data structure.","The PTD and the PNTD improve the resiliency of the NOS system by preserving network data on hard disks. If a NOS system fails, network configuration data will be preserved on disk in the PTD and log file information will be preserved on disk in the PNTD.","E. Multi-Instance Control System","Using a single NOS instance to control a network can lead to scaling and reliability issues. As the number of network elements increases, the processing power and\/or memory capacity that are required by those elements will saturate a single node. Some embodiments further improve the resiliency of the control system by having multiple instances of the NOS running on one or more computers, with each instance of the NOS containing one or more of the secondary storage structures described above. The control applications in some embodiments partition the workload between the different instances in order to reduce each instance's workload. Also, in some embodiments, the multiple instances of the NOS communicate the information stored in their storage layers to enable each instance of the NOS to cover for the others in the event of a NOS instance failing.",{"@attributes":{"id":"p-0163","num":"0162"},"figref":"FIG. 9","b":["900","990","905","910","915","900"]},"As shown in , each instance includes a NOS , a virtualization application , one or more control applications , and a coordination manager (CM) . For the embodiments illustrated in this figure, each NOS in the system  is shown to include a NIB  and three secondary storage structures, i.e., a PTD , a distributed hash table (DHT) instance , and a persistent non-transaction database (PNTD) . Other embodiments may not tightly couple the NIB and\/or each of the secondary storage structures within the NOS. Also, other embodiments might not include each of the three secondary storage structures (i.e., the PTD, DHT instance, and PNTD) in each instance , , or . For example, one NOS instance  may have all three data structures whereas another NOS instance may only have the DHT instance.","In some embodiments, the system  maintains the same switch element data records in the NIB of each instance, while in other embodiments, the system  allows NIBs of different instances to store different sets of switch element data records.  illustrate three different approaches that different embodiments employ to maintain the NIB records. In each of these three examples, two instances  and  are used to manage several switching elements having numerous attributes that are stored collectively in the NIB instances. This collection of the switch element data in the NIB instances is referred to as the global NIB data structure  in .",{"@attributes":{"id":"p-0166","num":"0165"},"figref":["FIG. 10","FIG. 11","FIG. 12"],"b":["1015","1005","1010","1015","1020","1025","1020","1005","1025","1010","1015","1030","1035","1030","1005","1035","1010"]},"The system  of some embodiments also replicates each NIB record in each instance in the PTD  of that instance in order to maintain the records of the NIB in a persistent manner. Also, in some embodiments, the system  replicates each NIB record in the PTDs of all the controller instances , , or , in order to protect against failures of individual controller instances (e.g., of an entire controller instance or a portion of the controller instance). Other embodiments, however, do not replicate each NIB record in each PTD and\/or do not replicate the PTD records across all the PTDs. For instance, some embodiments replicate only a part but not all of the NIB data records of one controller instance in the PTD storage layer of that controller instance, and then replicate only this replicated portion of the NIB in all of the NIBs and PTDs of all other controller instances. Some embodiments also store a subset of the NIB records in another one of the secondary storage records, such as the DHT instance .","In some embodiments, the DHT instances (DHTI)  of all controller instances collectively store one set of records that are indexed based on hashed indices for quick access. These records are distributed across the different controller instances to minimize the size of the records within each instance and to allow the size of the DHT to be increased by adding additional DHT instances. According to this scheme, one DHT record is not stored in each controller instance. In fact, in some embodiments, each DHT record is stored in at most one controller instance. To improve the system's resiliency, some embodiments, however, allow one DHT record to be stored in more than one controller instance, so that in case one DHT record is no longer accessible because of one instance failure, that DHT record can be accessed from another instance. Some embodiments store in the DHT only the type of data that can be quickly re-generated, and therefore do not allow for replication of records across different DHT instances or allow only a small amount of such records to be replicated.","The PNTD  is another distributed data structure of the system  of some embodiments. For example, in some embodiments, each instance's PNTD stores the records generated by the NOS  or applications  or  of that instance or another instance. Each instance's PNTD records can be locally accessed or remotely accessed by other controller instances whenever the controller instances need these records. This distributed nature of the PNTD allows the PNTD to be scalable as additional controller instances are added to the control system . In other words, addition of other controller instances increases the overall size of the PNTD storage layer.","The PNTD in some embodiments is replicated partially across different instances. In other embodiments, the PNTD is replicated fully across different instances. Also, in some embodiments, the PNTD  within each instance is accessible only by the application(s) that run on top of the NOS of that instance. In other embodiments, the NOS can also access (e.g., read and\/or write) the PNTD . In yet other embodiments, the PNTD  of one instance is only accessible by the NOS of that instance.","By allowing different NOS instances to store the same or overlapping NIB records, and\/or secondary storage structure records, the system improves its overall resiliency by guarding against the loss of data due to the failure of any NOS or secondary storage structure instance. In some embodiments, each of the three storages of the secondary storage layer uses a different distribution technique to improve the resiliency of a multiple NOS instance system. For instance, as mentioned above, the system  of some embodiments replicates the PTD across NOS instances so that every NOS has a full copy of the PTD to enable a failed NOS instance to quickly reload its PTD from another instance. In some embodiments, the system  distributes the PNTD with overlapping distributions of data across the NOS instances to reduce the damage of a failure. The system  in some embodiments also distributes the DHT fully or with minimal overlap across multiple controller instances in order to maintain the DHT instance within each instance small and to allow the size of the DHT to be increased by adding additional DHT instances.","For some or all of the communications between the distributed instances, the system  uses the CMs . The CM  in each instance allows the instance to coordinate certain activities with the other instances. Different embodiments use the CM to coordinate the different sets of activities between the instances. Examples of such activities include writing to the NIB, writing to the PTD, writing to the DHT, controlling the switching elements, facilitating intra-controller communication related to fault tolerance of controller instances, etc. Several more detailed examples of the operations of the CMs in some embodiments are further described below in Section III.B.","As mentioned above, different controller instances of the system  can control the operations of the same switching elements or different switching elements. By distributing the control of these operations over several instances, the system can more easily scale up to handle additional switching elements. Specifically, the system can distribute the management of different switching elements and\/or different portions of the NIB to different NOS instances in order to enjoy the benefit of processing efficiencies that can be realized by using multiple NOS instances. In such a distributed system, each NOS instance can have a reduced number of switches or a reduce portion of the NIB under management, thereby reducing the number of computations each controller needs to perform to distribute flow entries across the switches and\/or to manage the NIB. In other embodiments, the use of multiple NOS instances enables the creation of a scale-out network management system. The computation of how best to distribute network flow tables in large networks is a CPU intensive task. By splitting the processing over NOS instances, the system  can use a set of more numerous but less powerful computer systems to create a scale-out network management system capable of handling large networks.","As noted above, some embodiments use multiple NOS instance in order to scale a network control system. Different embodiments may utilize different methods to improve the scalability of a network control system. Three example of such methods include (1) partitioning, (2) aggregation, and (3) consistency and durability. For a first method, the network control system of some embodiments configures the NOS instances so that a particular controller instance maintains only a subset of the NIB in memory and up-to-date. Further, in some of these embodiments, a particular NOS instance has connections to only a subset of the network elements, and subsequently, can have less network events to process.","A second method for improving scalability of a network control system is referred to as aggregation. In some embodiments, aggregation involves the controller instances grouping NOS instances together into sets. All the NOS instances within a set have complete access to the NIB entities representing network entities connected to those NOS instances. The set of NOS instances then exports aggregated information about its subset of the NIB to other NOS instances (which are not included in the set of NOS instances)","Consistency and durability is a third method for improving scalability of a network control system. For this method, the controller instances of some embodiments are able to dictate the consistency requirements for the network state that they manage. In some embodiments, distributed locking and consistency algorithms are implemented for network state that requires strong consistency, and conflict detection and resolution algorithms are implemented for network state that does not require strong consistency (e.g., network state that is not guaranteed to be consistent). As mentioned above, the NOS of some embodiments provides two data stores that an application can use for network state with differing preferences for durability and consistency. The NOS of some embodiments provides a replicated transactional database for network state that favors durability and strong consistency, and provides a memory-based one-hop DHT for volatile network state that can sustain inconsistencies.","In some embodiments, the above methods for improving scalability can be used alone or in combination. They can also be used to manage networks too large to be controlled by a single NOS instance. These methods are described in further detail in U.S. patent application Ser. No. 13\/177,538, now published as U.S Patent Publication 2013\/0060929, entitled \u201cA Distributed Control Platform for Large-scale Production Networks,\u201d filed concurrently with the present application.","To distribute the workload and to avoid conflicting operations from different controller instances, the system  of some embodiments designates one controller instance (e.g., ) within the system  as the master of any particular NIB portion and\/or any given switching element (e.g., ). Even with one master controller, different controller instance (e.g.,  and ) can request changes to different NIB portions and\/or to different switching elements (e.g., ) controlled by the master (e.g., ). If allowed, the master instance then effectuates this change and writes to the desired NIB portion and\/or switching element. Otherwise, the master rejects the request. More detailed examples of processing such requests are described below.",{"@attributes":{"id":"p-0179","num":"0178"},"figref":["FIG. 13","FIG. 9"],"b":["1300","900","1305","1310","1","2","3","1315","1320","1325","1330","1355","1360","1305","1310","1345","1350"]},"In the example illustrated in , both control applications  and  of both controllers  and  can modify records of the switching element S for both users A and B, but only controller  is the master of this switching element. This example illustrates two cases. The first case involves the controller  updating the record S in switching element S for the user B. The second case involves the controller  updating the records S in switching element S after the control application  updates a NIB record S for switching element S and user A in NIB . In the example illustrated in , this update is routed from NIB  of the controller  to the NIB  of the controller , and then subsequently routed to switching element S.","Different embodiments use different techniques to propagate changes from the NIB  of controller instance  to NIB  of the controller instance . For instance, to propagate changes, the system  in some embodiments uses the secondary storage structures (not shown) of the controller instances  and . More generally, the distributed control system of some embodiments uses the secondary storage structures as communication channels between the different controller instances. Because of the differing properties of the secondary storage structures, these structures provide the controller instances with different mechanisms for communicating with each other. For instance, in some embodiments, different DHT instances can be different, and each DHT instance is used as a bulletin board for one or more instances to store data so that they or other instances can retrieve this data later. In some of these embodiments, the PTDs are replicated across all instances, and some or all of the NIB changes are pushed from one controller instance to another through the PTD storage layer. Accordingly, in the example illustrated in , the change to the NIB  could be replicated to the PTD of the controller , and from there it could be replicated in the PTD of the controller  and the NIB . Several examples of such DHT and PTD operations will be described below.","Instead of propagating the NIB changes through the secondary storages, the system  uses other techniques to change the record S in the switch S in response to the request from control application . For instance, to propagate this update, the NOS  of the controller  in some embodiments sends an update command to the NOS  of the controller  (with the requisite NIB update parameters that identify the record and one or more new values for the record) to direct the NOS  to modify the record in the NIB  or in the switch S. In response, the NOS  would make the changes to the NIB  and the switch S (if such a change is allowed). After this change, the controller instance  would change the corresponding record in its NIB  once it receives notification (from controller  or from another notification mechanism) that the record in the NIB  and\/or switch S has changed.","Other variations to the sequence of operations shown in  could exist because some embodiments designate one controller instance as a master of a portion of the NIB, in addition to designating a controller instance as a master of a switching element. In some embodiments, different controller instances can be masters of a switch and a corresponding record for that switch in the NIB, while other embodiments require the controller instance to be master of the switch and all records for that switch in the NIB.","In the embodiments where the system  allows for the designation of masters for switching elements and NIB records, the example illustrated in  illustrates a case where the controller instance  is the master of the NIB record S, while the controller instance  is the master for the switch S. If a controller instance other than the controller instance  and  was the master of the NIB record S, then the request for the NIB record modification from the control application  would have to be propagated to this other controller instance. This other controller instance would then modify the NIB record and this modification would then cause the NIB , the NIB  and the switch S to update their records once the controller instances  and  are notified of this modification through any number of mechanisms that would propagate this modification to the controller instances  and .","In other embodiments, the controller instance  might be the master of the NIB record S, or the controller instance  is the master of switch S and all the records for this NIB. In these embodiments, the request for the NIB record modification from the control application  would have to be propagated the controller instance , which would then modify the records in the NIB  and the switch S. Once this modification is made, the NIB  would modify its record S once the controller instance  is notified of this modification through any number of mechanisms that would propagate this modification to the controller instance .","As mentioned above, different embodiments employ different techniques to facilitate communication between different controller instances. In addition, different embodiments implement the controller instances differently. For instance, in some embodiments, the stack of the control application(s) (e.g.,  or  in ), the virtualization application (e.g.,  or ), and the NOS (e.g.,  or ) are installed and run on a single computer. Also, in some embodiments, multiple controller instances can be installed and run in parallel on a single computer. In some embodiments, a controller instance can also have its stack of components divided amongst several computers. For example, within one instance, the control application (e.g.,  or ) can be on a first physical or virtual computer, the virtualization application (e.g.,  or ) can be on a second physical or virtual computer, and the NOS (e.g.,  or ) can be on a third physical or virtual computer.","II. NIB",{"@attributes":{"id":"p-0187","num":"0186"},"figref":"FIG. 14","b":["1400","1400","1400","1400","1400"]},{"@attributes":{"id":"p-0188","num":"0187"},"figref":["FIG. 14","FIG. 14","FIGS. 17"],"b":["1400","1400","1400","1440","1440","1410","1460","1465","1470","1445","1450","1455","1420","1430","1425","1415","1475","1480","1435","18","19"]},"The NIB  performs functions that compose the heart of the NOS for several reasons. First, the NIB functions as a data storage structure for storing network configuration state information. In some embodiments, the NIB contains only physical network configuration state information while in other embodiments the NIB contains logical network configuration state information as well.","Second, in some embodiments, the NIB functions as a communication medium between NOS instances. The NOS instances replicate the NIB to some degree, with different embodiments of the invention replicating the NIB to varying degrees. This degree of replication allows the NIB to serve as a communication medium between NOS instances. For example, changes to the forwarding engine object  and the forwarding table objects  and  may be replicated amongst all NOS instances, thereby sharing that information between NOS instances.","Third, in some embodiments, the NIB functions as an interface to allow higher-level applications to configure the underlying network. The NOS propagates changes made to the NIB to the underlying network, thus allowing higher-level applications to control underlying network state using the NIB. For example, if a higher-level application changes the configuration of forwarding engine , then the NOS instance with authority over the physical switch corresponding to forwarding engine  will propagate any changes made to forwarding engine  down to the physical switch represented by forwarding engine .","Fourth, in some embodiments, the NIB functions as a view of the network topology that the NOS can present to higher-level applications, and in some embodiments, application users. The conceptualization of NIB  shown in  can be presented as a view of the network to higher-level applications in some embodiments. For example, a first hop switch with a port that is linked to a port on a host can be represented in a NIB by the forwarding engine object , the port object , the link object , the port object , and the host object .","For sake of simplicity,  presents the NIB  as a single hierarchical tree structure. However, in some embodiments, the NIB  has a more complicated structure than that. For instance, the NIB in some embodiments is a multi-layer hierarchical data structure, with each layer having a hierarchical structure and one or more elements (e.g., nodes) on each layer linked to one or more elements (e.g., nodes) on another layer. In some embodiments, the lowest layer elements correspond to the actual switching elements and their attributes, while each of the higher layer elements serve as abstractions of the actual switching elements and their attributes. As further described below, some of these higher layer elements are used in some embodiments to show different abstract switching elements and\/or switching element attributes to different users in a virtualized control system. In other words, the NOS of some embodiments generates the multi-layer, hierarchical NIB data structure, and the NOS or an application that runs on top of the NOS shows different users different views of different parts of the hierarchical levels and\/or layers, in order to provide the different users with virtualized access to the shared switching elements and network.","The operation of the NIB  will now be discussed in conjunction with .  illustrates a portion of a physical network  that the NIB  represents. The physical network  comprises switch123  that has port1  connected to link479  that connects to port3  on host456 . The network elements of the network  correspond to NIB objects in NIB . Switch123  corresponds to the forwarding engine  in NIB . Port1  corresponds to the Port  in NIB . Link479  corresponds to the Link  in NIB . Port3  corresponds to the Port  in NIB . Host456  corresponds to the host  in NIB . In this manner, the NIB  can serve as a topology of the physical network .",{"@attributes":{"id":"p-0195","num":"0194"},"figref":["FIG. 16","FIG. 16","FIG. 15","FIG. 14","FIG. 16","FIG. 16","FIG. 18"],"b":["1400","1610","1620","1630","1640","1650","1610","1610","1510","1610","1610","1520","1500","1420","1400","1610"]},{"@attributes":{"id":"p-0196","num":"0195"},"figref":["FIG. 17","FIG. 17","FIG. 17"],"b":["1710","1720","1720","1750"]},{"@attributes":{"id":"p-0197","num":"0196"},"figref":["FIG. 17","FIG. 17"],"b":["1770","1730","1760","1710"]},{"@attributes":{"id":"p-0198","num":"0197"},"figref":["FIG. 18","FIG. 19","FIG. 18","FIG. 18","FIG. 19","FIG. 18","FIG. 19"],"b":["1810","1820","1830","1840","1850","1910","1920","1930","1940","1950","1960"]},"The attributes shown in  are not the only attributes supportable by the invention. NOS users and NOS developers may extend this base set of network classes to support additional types of network elements. The NIB entity classes of some embodiments support inheritance and can be extended into new classes. For example, a virtual interface class representing a port between a hypervisor and a virtual machine can be inherited from the port class.","The node class  represents a point on the network that network data can move between. Examples are physical or virtual switches and hosts. As described in , the forwarding engine  (i.e., ), network  (i.e., ), and host  (i.e., ) classes are inherited from the node  (i.e., ) class. Nodes can contain ports through which network data can enter and exit the node. Nodes also have addresses to represent their location on the network. While no node class is shown in NIB , the host  is inherited from the node class and can have a pointer to a port  even though no ports are shown on the host class  in .","The port class  is the NIB analog to a port on a node. Ports are bound to nodes . Ports have many statistics that are not shown in . The port statistics include the number of transmitted packets and bytes, the number of received packets and bytes, and the number and type of transmit errors. Ports may have one attached outgoing link and one attached incoming link acting as a start and an end port, respectively. Ports may be bound to queue-collections to enable quality of service functionality. As shown in NIB , port  has link  attached and is a port of host .","The link class  is the NIB analog to links between ports. Network data moves across links. Links have statistics describing their speed, weight, and usage. A link may have one start port and one end port. Typically, a port's incoming and outgoing link are bound to the same link object, to enable a link to serve as a bi-directional communication point. This is shown by the a solid arrow going from the attached link of port class  to the link class .","The queue-collection class  is the NIB analog to the set of 8 queues associated with the egress ports of industry standard top of rack switches. Queue-collections are groups of queues that can have ports bound to them. The queue-collection class enables network administrators to select one queue-collection to manage many ports, thereby placing a consistent quality of service policy across many ports. The queue class  is the NIB analog to the queues attached to egress ports that schedule packets for processing. The queue class contains statistics and information regarding which queue-collection the queue is bound to. Additionally, the queue class has an attribute to describe the identity of the queues above and below the queue.",{"@attributes":{"id":"p-0204","num":"0203"},"figref":["FIG. 19","FIG. 18","FIG. 19","FIG. 19"],"b":["1910","1920","1930","1940","1950","1960"]},"The chassis class  is the NIB analog to a physical rack of switches. The chassis class contains a plurality of forwarding engines and addresses the chassis manages. The NIB  has a chassis  with pointers to forwarding engines  and . The forwarding engine class  is the NIB analog to a network switch. The forwarding engine contains a set of forwarding tables that can define the forwarding behavior of a switch on the network. The NIB  has a forwarding engine  with two pointers to two forwarding tables  and . The forwarding engine also contains the datapath ID that a controller uses to communicate with the forwarding engine.","The forwarding table class  is the NIB analog of the forwarding tables within switches that contain rules governing how packets will be forwarded. The forwarding table class  contains flow entries to be propagated by NOS instances to the forwarding tables of network switches. The flow entries contained in the forwarding table class are the basic unit of network management. A flow entry contains a rule for deciding what to do with a unit of network information when that unit arrives in a node on the network. The forwarding table class further supports search functions to find matching flow entries on a forwarding table object.","The host class  is the NIB analog to the physical computers of the network. Typical hosts often have many virtual machines contained within them. A host's virtual machines may belong to different users. The host class  supports a list of users. The user class  is the NIB analog to the owner of virtual machines on a host. The network class  serves as a black box of network elements that behave in a similar fashion to a node. Packets enter a network and exit a network, but the NOS instances are not concerned with the internal workings of a network class object.",{"@attributes":{"id":"p-0208","num":"0207"},"figref":"FIG. 20","b":"2000"},"An application can query a NIB object to learn its status. A NOS instance can create a NIB entity to reflect a new element being added to the physical network. A user can destroy a logical datapath in some embodiments. A NOS instance can access the attributes of another NOS instance's NIB entities. A transfer module may register for notification for changes to the data of a NIB entity object. A NOS instance can issue a synchronize command to synchronize NIB entity object data with data gathered from the physical network. An application can issue a \u201cpull entity into the NIB\u201d command to compel a NOS instance to add a new entity object to the NIB.","III. Multi-Instance Architecture",{"@attributes":{"id":"p-0210","num":"0209"},"figref":["FIG. 21","FIG. 9","FIG. 21"],"b":["2100","2100","900","2105","2110","2115","2100"]},"Also, like the control system , each controller instance includes a NOS , a virtualization application , one or more control applications , and a coordination manager (CM) . Each NOS in the system  includes a NIB  and at least two secondary storage structures, e.g., a distributed hash table (DHT)  and a PNTD .","However, as illustrated in , the control system  has several additional and\/or different features than the control system . These features include a NIB notification module , NIB transfer modules , a CM interface , PTD triggers , DHT triggers , and master\/slave PTDs \/.","In some embodiments, the notification module  in each controller instance allows applications (e.g., a control application) that run on top of the NOS to register for callbacks when changes occur within the NIB. This module in some embodiments has two components, which include a notification processor and a notification registry. The notification registry stores the list of applications that need to be notified for each NIB record that the module  tracks, while the notification processor reviews the registry and processes the notifications upon detecting a change in a NIB record that it tracks. The notification module as well as its notification registry and notification processor are a conceptual representation of the NIB-application layer notification components of some embodiments, as the system of these embodiments provides a separate notification function and registry within each NIB object that can be tracked by the application layer.","The transfer modules  include one or more modules that allow data to be exchanged between the NIB  on one hand, and the PTD or DHT storage layers in each controller instance on the other hand. In some embodiments, the transfer modules  include an import module for importing changes from the PTD\/DHT storage layers into the NIB, and an export module for exporting changes in the NIB to the PTD\/DHT storage layers. The use of these modules to propagate data between the NIB and PTD\/DHT storage layers will be further described below.","Unlike the control system  that has the same type of PTD in each instance, the control system  only has PTDs in some of the NOS instances, and of these PTDs, one of them serves as master PTD , while the rest serve as slave PTDs . In some embodiments, NIB changes within a controller instance that has a slave PTD are first propagated to the master PTD , which then directs the controller instance's slave PTD to record the NIB changes. The master PTD  similarly receives NIB changes from controller instances that do not have either master or slave PTDs. The use of the master PTDs in processing NIB changes will be further described below.","In the control system , the coordination manager  includes the CM interface  to facilitate communication between the NIB storage layer and the PTD storage layer. The CM interface also maintains the PTD trigger list , which identifies the modules of the system  to call back whenever the CM interface  is notified of a PTD record change. A similar trigger list  for handling DHT callbacks is maintained by the DHT instance . The CM  also has a DHT range identifier (not shown) that allows the DHT instances of different controller instances to store different DHT records in different DHT instances. The operations that are performed through the CM, the CM interface, the PTD trigger list, and the DHT trigger list will be further described below.","Also, in the control system , the PNTD is not placed underneath the NIB storage layer. This placement is to signify that the PNTD in the control system  does not exchange data directly with the NIB storage layer, but rather is accessible solely by the application(s) (e.g., the control application) running on top of the NOS  as well as other applications of other controller instances. This placement is in contrast to the placement of the PTD storage layer \/ and DHT storage layers , which are shown to be underneath the NIB storage layer because the PTD and DHT are not directly accessible by the application(s) running on top of the NOS . Rather, in the control system , data are exchanged between the NIB storage layer and the PTD\/DHT storage layers of the same or different instances.","The control system  uses the PTD, DHT and PNTD storage layers to facilitate communication between the different controller instances. In some embodiments, each of the three storages of the secondary storage layer uses a different storage and distribution technique to improve the resiliency of the distributed, multi-instance system . For instance, as further described below, the system  of some embodiments replicates the PTD across NOS instances so that every NOS has a full copy of the PTD to enable a failed NOS instance to quickly reload its PTD from another instance. On the other hand, the system  in some embodiments distributes the PNTD with partial overlapping distributions of data across the NOS instances to reduce the damage of a failure. Similarly, the system  in some embodiments distributes the DHT fully or with minimal overlap across multiple controller instances in order to minimize the size of the DHT instance (e.g., the amount of memory the DHT instance utilizes) within each instance. Also, using this approach allows the system to increase the size of the DHT by adding additional DHT instances in order to make the system more scalable.","One of the advantages of this system is that it can be configured in any number of ways. In some embodiments, this system provides great flexibility to specify the configurations for the components of the system in order to customize its storage and data distribution scheme to achieve the best tradeoff of scalability and speed on one hand, and reliability and consistency on the other hand. Attributes of the storage structures that affect scalability, speed, reliability and consistency considerations include the speed of the storage (e.g., RAM versus disk access speed), the reliability of the storage (e.g., persistent non-volatile storage of disk versus volatile storage of RAM), the query interface of the storage (e.g., simple Put\/Get query interface of DHT versus more robust transactional database queries of PTD in some embodiments), and the number of points of failure in the system (e.g., a single point of failure for a DHT record versus multiple points of failure for a PTD record in some embodiments).","Through the configurations of its components, the system can be configured to (1) distribute the data records between the NIB and the secondary storage structures within one instance (e.g., which secondary storage should store which NIB record), (2) distribute the data records between the NIBs of different instances (e.g., which NIB records should be replicated across different controller instances), (3) distribute the data records between the secondary storage structures within one instance (e.g., which secondary storage records contain which records), (4) distribute the data records between the secondary storage structures of different instances (e.g., which secondary storage records are replicated across different controller instances), (5) distribute secondary storage instances across controller instances (e.g., whether to put a PTD, a DHT, or a Stats database instance within each controller or whether to put different subsets of these storages within different instances), and (6) replicate data records in the distributed secondary storage structures (e.g., whether to replicated PTD fully across all instances, whether to replicate some or all DHT records across more than one instance, etc.). The system also allows the coordination between the different controller instances as to the master control over different switching elements or different portions of the NIB to be configured differently. In some embodiments, some or all of these configurations can be specified by applications (e.g., a control application or a virtualization application) that run on top of the NOS.","In some embodiments, as noted above, the CMs facilitate intra-controller communication related to fault tolerance of controller instances. For instance, the CMs implement the intra-controller communication through the secondary storage layers described above. A controller instance in the control system may fail due to any number of reasons (e.g., hardware failure, software failure, network failure, etc.). Different embodiments may use different techniques for determining whether a controller instance has failed. In some embodiments, Paxos protocol is used to determine whether a controller instance in the control system has failed. While some of these embodiments may use Apache Zookeeper to implement the Paxos protocol, other of these embodiments may implement Paxos protocol in other ways.","Some embodiments of the CM  may utilize defined timeouts to determine whether a controller instance has failed. For instance, if a CM of a controller instance does not respond to a communication (e.g., sent from another CM of another controller instance in the control system) within an amount of time (i.e., a defined timeout amount), the non-responsive controller instance is determined to have failed. Other techniques may be utilized to determine whether a controller instance has failed in other embodiments.","When a controller instance fails, a new master for the logical data path sets and the switching elements, of which the failed controller instance was a master, needs to be determined. Some embodiments of the CM  make such determination by performing a master election process that elects a master controller instance (e.g., for partitioning management of logical data path sets and\/or partitioning management of switching elements). The CM  of some embodiments may perform a master election process for electing a new master controller instance for both the logical data path sets and the switching elements of which the failed controller instance was a master. However, the CM  of other embodiments may perform (1) a master election process for electing a new master controller instance for the logical data path sets of which the failed controller instance was a master and (2) another master election process for electing a new master controller instance for the switching elements of which the failed controller instance was a master. In these cases, the CM  may determine two different controller instances as new controller instances: one for the logical data path sets of which the failed controller instance was a master and another for the switching elements of which the failed controller instance was a master.","In some embodiments, the master election process is further for partitioning management of logical data path sets and\/or management of switching elements when a controller instance is added to the control system. In particular, some embodiments of the CM  perform the master election process when the control system  detects a change in membership of the controller instances in the control system . For instance, the CM  may perform the master election process to redistribute a portion of the management of the logical data path sets and\/or the management of the switching elements from the existing controller instances to the new controller instance when the control system  detects that a new network controller has been added to the control system . However, in other embodiments, redistribution of a portion of the management of the logical data path sets and\/or the management of the switching elements from the existing controller instances to the new controller instance does not occur when the control system  detects that a new network controller has been added to the control system . Instead, the control system  in these embodiments assigns unassigned logical data path sets and\/or switching elements (e.g., new logical data path sets and\/or switching elements or logical data path sets and\/or switching elements from a failed network controller) to the new controller instance when the control system  detects the unassigned logical data path sets and\/or switching elements have been added.","The control system's use of the PTD, DHT and PNTD storage layers to facilitate communication between the different controller instances will be described further in sub-section III.A below. This discussion will then be followed by a discussion of the operations of the CM  in sub-section III.B. Section IV then describes the architecture of a single controller instance of the system  in some embodiments.","A. Facilitating Communication in Distributed System","The distributed control system  of some embodiments uses the secondary storage structures as communication channels between the different controller instances , , and . The distributed control system of some embodiments makes such a use of the secondary storage structures because it provides a robust distributed logic, where often the rules for distributing a data record reside in the storage layer adjacent to the data record. This scheme is also advantageous as it modularizes the design of the different components of the distributed system. It also simplifies the addition of new controller instances in the system. It further allows some or all of the applications running on top of the NOS (e.g., the control application(s) and\/or the virtualization application) within each instance to operate as an independent logical silo from the other controller instances, as the application does not need to know how the system distributes control over the switching elements.","Because of the differing properties of the secondary storage structures, the secondary storage structures provide the controller instances with different mechanisms for communicating with each other. For instance, the control system  uses the PTD storage layer to push data between different controller instances, while it uses the DHT storage layer to enable different controller instances to post data and pull data from the DHT storages.","Specifically, in some embodiments, different DHT instances can be different, and each DHT instance is used as a bulletin board for one or more instances to store data so that they or other instances can retrieve this data later. In some embodiments, the DHT is a one-hop, eventually-consistent, memory-only DHT. A one-hop DHT, in some embodiments, is configured in a full mesh such that each DHT instance is connected to each other DHT instance. In this way, if a particular DHT instance does not have piece of data, the particular DHT instance can retrieve the piece of data from another DHT instance that is \u201cone-hop\u201d away instead of having to traverse multiple DHT instances in order to retrieve the piece of data. However, the system  in some embodiments maintains the same switch element data records in the NIB of each instance, and replicates some or all of the NIB records in the PTDs  and  of the controller instances  and . By replicating the PTDs across all instances, the system  pushes NIB changes from one controller instance to another through the PTD storage layer. Pushing the NIB changes through the PTD storage layer involves the use of the master PTD .","While maintaining some of the NIB records in the PTD, the system  in some embodiments maintains a portion of the NIB data in the DHT instance . The DHT instance in some embodiments is a distributed storage structure that is stored in the volatile system memory with minimal replications to enable greater scalability. As discussed above, applications can configure the distribution of NIB data records between the PTD and the DHT. In some embodiments, the typical configuration distributes fast changing information (e.g., link state, statistics, entity status) to the DHT and slow changing information (e.g., existence node and port entities) to the PTD.","Performing NIB and PTD replication through the master PTD will be described in sub-section III.A.1 below. Sub-section III.A.2 will then describe distributing data among the controller instances through the DHT storage layer. Sub-section III.A.3 then describes distributing data among controller instances through the PNTD storage layer.","1. PTD Replication","In some embodiments, the system  maintains the same switch element data records in the NIB of each instance. In the NIBs, the system  stores physical network data and in some embodiments logical network data. The system  of some embodiments stores some or all of the records of each instance's NIB in that instance's PTD. For instance, in some embodiments, the system  stores in the PTDs slow changing network state data (e.g., network policy declarations, switching element inventories, other physical network element inventories, etc.) that needs to be stored in a more durable manner but does not need to be frequently updated.","By replicating the PTDs across all instances, the system  pushes some or all of the NIB changes from one controller instance to another through the PTD storage layer.  illustrates pushing a NIB change through the PTD storage layer. Specifically, it shows four data flow diagrams, with (1) one diagram  conceptually illustrating the propagation of a NIB change from a first controller  to a second controller  through the PTD storage layers of the two controllers, and (2) three diagrams , , and  illustrating alternative uses of a master PTD  of a third controller  in performing this propagation. In this figure, the use of the CM  and CM interface  is ignored to simplify the description of this figure. However, the use of the CM  and CM interface  in performing the PTD replication will be further described below.","The flow diagram  conceptually illustrates the propagation of a change in a NIB  of the first controller  to a NIB  of the second controller , through the PTDs  and  of these two controllers  and . In this diagram as well as the other three diagrams, the NIBs  and  are shown above a dashed line  and the PTDs  and  are shown below the dashed line  in order to convey that the NIBs are part of a NIB storage layer across all of the controller instances, while the PTDs are part of a PTD storage layer across all of the controller instances.","In the flow diagram  as well as the other three diagrams, the flow of data between components is indicated by way of arrows and numbers, with each number indicating an order of an operation in the flow of data between the layers. Accordingly, the flow diagram  shows that the change in the NIB  is initially transferred to the PTD  within the same controller instance . This change is then pushed to the PTD  of the second controller instance . From there, the change is propagated to the NIB  of the second controller instance .","The flow diagram  is illustrative of the sequence of operations that are performed to propagate a NIB change through the PTD storage layer. However, for the control system  of some embodiments, the flow diagram  simply illustrates the concept of propagating a NIB change through the PTD storage layer. It is not an illustration of the actual sequence of operations for propagating a NIB change in such a system, because the control system  uses a master PTD  as a single point of replication to ensure consistency across the PTD layers , , and .","While ignoring the operations of the CM and CM interface, the flow diagram  provides a more representative diagram of the sequence of operations for propagating a NIB change in the system  for some embodiments of the invention. This diagram shows that in the system  of some embodiments, the first controller's PTD  pushes a NIB change that it receives from its NIB  to a master PTD , which may reside in another controller instance , as illustrated in diagram . The master PTD  then directs each slave PTD  and  to update their records based on the received NIB change. In the embodiment illustrated in flow diagram , the master PTD  even notifies the PTD  to update its records. In other words, the system of some embodiments does not make a NIB change in the PTD of the instance that originated the NIB change, without the direction of the master PTD . In some embodiments, instead of the master PTD sending the changed PTD record to each slave PTD, the master PTD notifies the slave instances of the PTD change, and then the slave instances query the master PTD to pull the changed PTD record.","Once the slave PTDs  and  notify the master PTD  that they have updated their records based on the NIB change, the master PTD directs all the NIBs (including the NIB  of the second controller instance  as well as a NIB  of the third controller instance ) to modify their records in view of the NIB change that originated from controller instance . The master PTD  in some embodiments effectuates this modification through the CM interface and a NIB import module that interfaces with the CMI. This NIB import module is part of the NIB transfer module  that also includes a NIB export module, which is the module used to propagate the NIB change from the NIB  to the PTD . In some embodiments, the master PTD notifies the NIB import module of the changed PTD record, and in response the NIB import module queries the master PTD for the changed record. In other embodiments, the master PTD sends to the NIB import module the changed PTD record along with its notification regarding the change to its record. The use of the CM interface, the NIB export module, and the NIB import module to effectuate NIB-to-NIB replication will be further described below.","The flow diagram  presents an alternative data flow to the diagram  for the NIB-to-NIB replication operations that involve the master PTD in some embodiments. The flow  is identical to the flow  except that in the flow , the master PTD is only responsible for notifying its own NIB  of the NIB change as it is not responsible for directing the NIB  of the instance  (or the NIB of any other slave instance) to make the desired NIB change. The NIB change is propagated in the diagram  to the NIB  through the PTD  of the second instance. In different embodiments, the PTD  uses different techniques to cause the NIB  to change a record. In some embodiments, the PTD  notifies the import module of NIB  of the changed PTD record, and in response the NIB import module queries the PTD  for the changed record. In other embodiments, the PTD  sends to the import module of the NIB  the changed PTD record along with its notification regarding the change to its record.","The flow diagram  presents yet another alternative data flow to the diagrams  and  for the NIB-to-NIB replication operations that involve the master PTD in some embodiments. The flow  is identical to the flow  except that in the flow , the slave NIB  directly notifies the master PTD  of the change to its NIB. In other words, the notification regarding the change in the NIB  is not relayed through slave PTD . Instead, the export module of the slave NIB  directly notifies the master PTD  (through the CM interface (not shown)). After being notified of this change, the master PTD  in the flow  first notifies the slave PTDs  and , and then notifies the slave NIB  and its own NIB , as in the flow diagram .","The control systems of other embodiments use still other alternative flows to those illustrated in diagrams ,  and . For instance, another flow involves the same sequence of operations as illustrated in diagrams  and , except that the PTD  of the instance  records the NIB change before the master PTD is notified of this change. In this approach, the master PTD would not have to direct the PTD  to modify its records based on the received NIB change. The master PTD would only have to notify the other slave PTDs of the change under this approach.","Other control systems of other embodiments use still other flows to those illustrated in diagrams , , and . For instance, in some systems that do not use master PTDs, the flow illustrated in diagram  is used to replicate a NIB change across instances. Yet another flow that such systems use in some embodiments would be similar to the flow illustrated in the diagram , except that the PTD  would be the component that notifies the NIB  of the NIB change after the PTD  notifies the PTD  of the NIB change.","2. DHT Access","In the control system  of some embodiments, the DHT instances  of all controller instances collectively store one set of records that are indexed based on hashed indices for quick access. These records are distributed across the different controller instances to minimize the size of the records within each instance and to allow for the size of the DHT to be increased by adding additional DHT instances. According to this scheme, one DHT record is not stored in each controller instance. In fact, in some embodiments, each DHT record is stored in at most one controller instance. To improve the system's resiliency, some embodiments, however, allow one DHT record to be stored in more than one controller instance, so that in case one DHT record is no longer accessible because of one instance failure, that DHT record can be accessed from another instance. The system of some embodiments stores in the DHT rapidly changing network state that is more transient in nature. This type of data often can be quickly re-generated. Accordingly, some of these embodiments do not allow for replication of records across different DHT instances or only allow a small amount of such records to be replicated. In some embodiments, rapidly changing NIB data is stored in the DHT to take advantage of the DHT's aforementioned properties.","Because the system of these embodiments does not replicate DHT records across all DHT instances, it needs to have a mechanism for identifying the location (or the primary location in case of a DHT record that is stored within more than one DHT) of a DHT record. The CM  provides such a mechanism in some embodiments of the invention. Specifically, as further described below, the CM  of some embodiments maintains a hash value range list that allows the DHT instances of different controller instances to store different DHT records in different DHT instances.",{"@attributes":{"id":"p-0247","num":"0246"},"figref":["FIG. 23","FIG. 23"],"b":["2300","2320","2325","2330","2305","2310","2315"],"sup":["16 ","48"]},{"@attributes":{"id":"p-0248","num":"0247"},"figref":"FIG. 23","b":"2300"},{"@attributes":{"id":"p-0249","num":"0248"},"figref":"FIG. 24","b":["2120","2405","2120","2435","2415","2440","2420","2410","2120","2445","2425","2440","2420","2120","2120"]},"In , the flow diagram  conceptually illustrates the propagation of a change in a NIB  of the first controller  to the DHT instance  of the second controller , through the DHT instance  of first controller . In this diagram as well as the other diagram , the NIBs  and  are shown above a dashed line  and the DHT instances , , and  are shown below the dashed line  in order to convey that the NIBs are part of a NIB storage layer across all of the controller instances, while the DHT instances are part of a DHT storage layer across all of the controller instances. Also, in the flow diagram  as well as the other diagram , the flow of data between components is indicated by way of arrows and numbers, with each number indicating an order of operation in the flow of data between the layers.","The flow diagram  shows that the change in the NIB  is initially transferred to the DHT instance  within the same controller instance . The DHT instance does not necessarily change the records that it keeps because the DHT instance  might not store a DHT record that corresponds to the changed NIB record for which it receives the notification from NIB . Hence, in response to the NIB change notification that it receives, the DHT instance checks the hash value range list  to identify the DHT instance that stores the DHT-layer record that corresponds to the modified NIB record. To identify this DHT instance, the DHT instance  uses a hash index for the DHT record that it needs to locate. In some embodiments, the DHT instance  generates this hash value when it receives the NIB change notification from the NIB .","Based on the hash index, the DHT instance  obtains the identity of DHT instance  from the DHT range list . The DHT instance  then directs the DHT instance  to modify its DHT record to reflect the received NIB change. In some embodiments, the DHT instance  directs the DHT instance  to modify its records, by supplying the DHT instance  with a Put command, which supplies the DHT instance  with a key, a hash value based on the key, and a value to store along with the hash value. The DHT instance  then modifies its DHT records based on the request that it receives from the DHT instance .","The flow diagram  shows the NIB  of the third controller instance  pulling from DHT instance  the record that was created at the end of the flow illustrated in diagram . Specifically, it shows the DHT instance  of the third controller instance  receiving a DHT record request from its corresponding NIB . The NIB  might need to pull a DHT record for a variety of reasons. For instance, when the NIB creates a new node for a new port, it might need to obtain some statistics regarding the port to populate its NIB records.","In response to the received DHT record request, the DHT instance  checks the hash value range list  to identify the DHT instance that stores the requested DHT record. To identify this DHT instance, the DHT instance  uses a hash index for the DHT record that it needs to locate. In some embodiments, the DHT instance  generates this hash value when it receives the request from the NIB .","Based on the hash index, the DHT instance  obtains the identity of DHT instance  from the DHT range list . The DHT instance  then directs the DHT instance  to provide the requested DHT record. In some embodiments, the DHT instance  directs the DHT instance  for the requested record, by supplying the DHT instance  with a Get command, which supplies the DHT instance  with a key and\/or a hash value based on the key. The DHT instance  then supplies the value stored in the specified DHT record to the DHT instance , which, in turn, supplies this value to the NIB .","3. PNTD","As described above, the system  includes a PNTD  in some embodiments of the invention. The PNTD stores information for a user or application to review. Examples of such information include error messages, log files, and billing information. The PNTD can receive push or pull commands from the application layer above the NOS, as illustrated in  by the arrow linking the PNTD  to the application interface .  will be described in detail further below.","In some embodiments, the PNTD is a distributed software database, such as Cassandra. For example, in some embodiments, each instance's PNTD stores the records generated by that instance's applications or by other applications of other instances. Each instance's PNTD records can be locally accessed or remotely accessed by the other controller instances whenever these instances need these records. This distributed nature of the PNTD allows the PNTD to be scalable as additional controller instances are added to the control system. In other words, addition of other controller instances increases the overall size of the PNTD storage layer.","The system  uses the PNTD to store information in a durable manner that does not require the same degree of replication as the PTD . In some embodiments, the PNTD is stored on a non-volatile storage medium, such as a hard disk.","The PNTD  is a distributed storage structure similar to the DHT instance . Similar to the DHT, data records in the PNTD are distributed across each NOS controller instance that has a PNTD. However, unlike the DHT or the PTD, the PNTD  has no support for any trigger or notification functionality. Similar to the DHT instance , the PNTD  has a configurable level of replication. In some embodiments, data records are stored only once across the entire system, in other embodiments the data records are replicated across a configurable portion of the controller instances running a PNTD to improve the resiliency of the data records. In other words, the PNTD in some embodiments is not replicated across different instances or is only partially replicated across different instances, while in other embodiments, the PNTD is replicated fully across different instances.","B. Coordination Manager","In some embodiments, the different controller instances of the system  communicate with each other through the secondary storage structures, as described above. Also, as described above, the system  in some embodiments uses the CMs  to facilitate much of the communication between the secondary storages of the different controller instances. The CM  in each instance is also configured in some embodiments to specify control of different controller instances over different switching elements.",{"@attributes":{"id":"p-0263","num":"0262"},"figref":"FIG. 25","b":["2500","2500"]},"As shown in , the CM  includes a CM-to-CM interface , a NIB-to-PTD interface , a master tracker , a PTD trigger tracker , a CM processor , a NOS tracker , a DHT range identifier , an ordering module , and a CM instance tracker . The CM-to-CM interface  serves as the interface for passing communication between the different CMs of the different controller instances. Such communication is at times needed when distributing data needed for secondary storage layer communication between the different instances. For instance, such communication is needed to route one NIB change from one controller that has a slave PTD to another controller that has a master PTD.","The NIB-to-PTD interface  serves as the interface to facilitate communications between NIB and PTD storage layers. On the NIB side, the interface  communicates with transfer modules that import and export data to and from the NIB. On the PTD side, the interface  in some embodiments communicates (1) with the CM-to-CM interface  (through the CM processor ) to facilitate communication between master and slave PTDs, (2) with the query manager of the PTD to effectuate a PTD access (e.g., a PTD write), and (3) with the query manager of the PTD to receive PTD layer callbacks when records change in the PTD. In some embodiments, the interface  converts NIB queries to the PTD into a query format that is suitable for the PTD. In other embodiments, however, the NIB transfer modules provide the PTD queries in a format suitable for the PTD.","The CM processor  receives communications from each interface  or . It routes such communications to the other interface, if needed, or to the other modules of the CM , if needed. One example of a communication that the CM processor routes to the appropriate CM module is a PTD trigger call back that it receives from the PTD of its controller instance. As further described below, the PTD can be configured on a record-by-record basis to call back the CM when a particular record has changed. The CM uses the PTD trigger tracker  to maintain a PTD trigger list  that allows the CM to identify for different PTD records, different sets of modules within the same controller instance or within other controller instances that the CM needs to notify of the particular record's change in its associated PTD. Maintaining the PTD trigger list outside of the PTD is beneficial for several reasons, including keeping the size of the PTD small, avoiding replication of such lists across PTDs, etc.","The CM processor  also uses the ordering module  to maintain the ordering of the inter-instance communications and\/or tasks. To maintain such ordering, the ordering modules of different embodiments use different processes and ordering schemes. Some of these ordering processes maintain total ordering among packets exchanged between the different controller instances. Examples of such ordering processes include the Paxos protocols and processes.","In some embodiments, the ordering module includes a time stamper to timestamp each communication that it receives that needs inter-instance coordination. The timestamps allow the CM  to process communications in an appropriate sequential manner to ensure data consistency and reliability across the instances for the communications (e.g., PTD storage layer communications) that need such consistency and reliability. Instead of a time stamper, the CM processor  uses other techniques or modules in other embodiments to ensure that the communications that it receives are processed in the appropriate sequential manner to facilitate the proper coordination of activities between the different controller instances, as mentioned above.","The CM processor  also directs the DHT range identifier  to generate and update the DHT range list . In some embodiments, the CM processor directs the range identifier to update the range list  periodically or upon receiving a communication through one of the interfaces  or . As discussed above, the DHT instances use the range list  to identify the location of each DHT record in the DHT instances. In some embodiments, the DHT instances access the DHT range list directly, while in other embodiments the DHT instances access this list through the CM, which they access through a DHT-to-CM interface (not shown).","In addition to the DHT range list and the PTD trigger list, the CM  maintains four other lists, which are the CM instance list , the NOS instance list , the switching element master list , and the NIB master list . The CM instance list  is a list of all active CM instances, and this list is maintained by CM Instance tracker . The NOS instance list  is a list of all active NOS instances and this list is maintained by the NOS tracker .","The switch element and the NIB master lists  and  are maintained by the master tracker . In some embodiments, the switching element master list identifies a master controller instance for each switching element, and one or more back-up controller instances for each master controller in case the master controller fails. The CM  designates one controller instance within the control system as the master of any given switching element, in order to distribute the workload and to avoid conflicting operations from different controller instances. By distributing the control of these operations over several instances, the system can more easily scale up to handle additional switching elements.","In some embodiments, the NIB master list  identifies (1) a master for each portion (e.g., each record or set of records) of the NIB, (2) one or more back up controller instances for each identified master to use in case the master fails, and (3) access and\/or modification rights for each controller instance with respect to each portion of NIB. Even with one master controller as master of a portion of the NIB, different controller instances can request a change to the portion controlled by the master. If allowed, the master instance effectuates this change, which is subsequently written to the switching element by the switch element master. Otherwise, the master rejects the request.","Some embodiments use the access and\/or modification rights in the NIB master list to restrict changes to different portions of the NIB to different subsets of the controller instances. Each subset might only include in some embodiments the master controller instance that can modify the NIB portion or the switching element record that corresponds to the NIB portion that is subject to the requested change. Alternatively, in some embodiments, a subset might include one or more controller instances in addition to the master controller instance for the NIB portion.","In some embodiments, a first controller instance can be master of a switch and a second controller instance can be master of a corresponding record for that switch in the NIB. In such a case, the second controller instance would determine whether a requested change to the NIB is allowed (e.g., from a control application of any of the controller instances), while the first controller instance would modify the switch records if the second controller instance modifies the NIB in response to the requested change. If a request to change the NIB is not allowed, the NIB master controller (e.g., the second instance in the example above) would reject the request. Different embodiments use different techniques to propagate NIB modification requests through a control system, and some of these techniques are described below.","In some embodiments, each controller instance queries its CM  to determine whether it is the master of the NIB portion for which it receives a NIB change, or whether it is the master of the switching element for which it has detected a change in the NIB. The CM  then examines its NIB master list  (e.g., through the CM processor  and master tracker ) or its switch master list  (e.g., through the CM processor  and master tracker ) to determine whether the instance is the master of the switching element.","By allowing rights to be specified for accessing and\/or modifying NIB records, the CM  allows the control system  to partition management of logical data path sets (also referred to as serialized management of logical data path sets). Each logical data path set includes one or more logical data paths that are specified for a single user of the control system. Partitioning management of the logical data path sets involves specifying for each particular logical data path set only one controller instance as the instance responsible for changing NIB records associated with that particular logical data path set. For instance, when the control system uses three switching elements to specify five logical data path sets for five different users with two different controller instances, one controller instance can be the master for NIB records relating to two of the logical data path sets while the other controller instance can be the master for the NIB records for the other three logical data path sets. Portioning management of logical data path sets ensures that conflicting values for the same logical data path sets are not written to the NIB by two different controller instances, and thereby alleviates the applications running on top of the NOS from guarding against the writing of such conflicting values.","Irrespective of whether the control system partitions management of logical data path sets, the control system of some embodiments allows one control application that operates on controller instance to request that the control system lock down or otherwise restrict access to one or more NIB records for an entire logical data path set or a portion of it, even when that controller instance is not the master of that logical data path set. In some embodiments, this request is propagated through the system (e.g., by any propagation mechanism, including NIB\/PTD replication, etc.) until it reaches the controller instance that is the master of the NIB portion. In some embodiments, the system allows each lock down operation to be specified in terms of one or more tasks that can be performed on one or more data records in the NIB.","The CM  of the master controller determines whether a request to lock down or otherwise restrict access to a set of NIB records is allowed. If so, it will modify the records in its NIB master list so that subsequent requests for modifying the affected set of NIB records by other controller instances will be appropriately restricted.","In some embodiments, the CMs across all of the controller instances perform unified coordination activity management in a distributed manner. This coordination is facilitated by the CM processor  and the procedures that it follows. In some embodiments, some or all of the modules of the CM  are implemented by using available coordination management applications. For instance, some embodiments employ the Apache Zookeeper application to implement some or all of the modules of the CM .","As mentioned above, the CMs of some embodiments facilitate intra-controller communication related to fault tolerance of controller instances. As such, some embodiments of the CM-to-CM interface  pass these fault tolerance communications between the different CMs of the different controller instances. In some of these embodiments, the CM processor  executes Apache Zookeeper, which implements the Paxos protocols, for determining whether a controller instance has failed. In addition, the CM processor  of some such embodiments defines a timeout for determining that a controller instance is non-responsive and thus has failed. In other such embodiments, the timeout may be predefined. Furthermore, upon failure of a controller instance, some embodiments of the CM processor  may be responsible for performing a master election process(es) to elect a new master controller instance (e.g., for logical data path sets and switching elements of which the failed controller instance was a master) to replace the failed controller instance.","IV. Controller Instance","A. Architecture",{"@attributes":{"id":"p-0282","num":"0281"},"figref":"FIG. 26","b":["2600","2100","2600"]},"Also, in some embodiments, the NOS instance  provides multiple methods for applications to gain access to network entities. For instance, in some embodiments, it maintains an index of all of its entities based on the entity identifier, allowing for direct querying of a specific entity. The NOS instance of some embodiments also supports registration for notifications on state changes or the addition\/deletion of an entity. In some embodiments, the applications may further extend the querying capabilities by listening for notifications of entity arrival and maintaining their own indices. In some embodiments, the control for a typical application is fairly straightforward. It can register to be notified on some state change (e.g., the addition of new switches and ports), and once notified, it can manipulate the network state by modifying the NIB data tuple(s) (e.g., key-value pairs) of the affected entities.","As shown in , the NOS  includes an application interface , a notification processor , a notification registry , a NIB , a hash table , a NOS controller , a switch controller , transfer modules , a CM , a PTD , a CM interface , a PNTD , a DHT instance , switch interface , and a NIB request list .","The application interface  is a conceptual illustration of the interface between the NOS and the applications (e.g., control and virtualization applications) that can run on top of the NOS. The interface  includes the NOS APIs that the applications (e.g., control or virtualization application) running on top of the NOS use to communicate with the NOS. In some embodiments, these communications include registrations for receiving notifications of certain changes in the NIB , queries to read certain NIB attributes, queries to write to certain NIB attributes, requests to create or destroy NIB entities, instructions for configuring the NOS instance (e.g., instructions regarding how to import or export state), requests to import or export entities on demand, and requests to synchronize NIB entities with switching elements or other NOS instances.","The switch interface  is a conceptual illustration of the interface between the NOS and the switching elements that run below the NOS instance . In some embodiments, the NOS accesses the switching elements by using the OpenFlow or OVS APIs provided by the switching elements. Accordingly, in some embodiments, the switch interface  includes the set of APIs provided by the OpenFlow and\/or OVS protocols.","The NIB  is the data storage structure that stores data regarding the switching elements that the NOS instance  is controlling. In some embodiments, the NIB just stores data attributes regarding these switching elements, while in other embodiments, the NIB also stores data attributes for the logical data path sets defined by the user. Also, in some embodiments, the NIB is a hierarchical object data structure (such as the ones described above) in which some or all of the NIB objects not only include data attributes (e.g., data tuples regarding the switching elements) but also include functions to perform certain functionalities of the NIB. For these embodiments, one or more of the NOS functionalities that are shown in modular form in  are conceptual representations of the functions performed by the NIB objects. Several examples of these conceptual representations are provided below.","The hash table  is a table that stores a hash value for each NIB object and a reference to each NIB object. Specifically, each time an object is created in the NIB, the object's identifier is hashed to generate a hash value, and this hash value is stored in the hash table along with a reference (e.g., a pointer) to the object. The hash table  is used to quickly access an object in the NIB each time a data attribute or function of the object is requested (e.g., by an application or secondary storage). Upon receiving such requests, the NIB hashes the identifier of the requested object to generate a hash value, and then uses that hash value to quickly identify in the hash table a reference to the object in the NIB. In some cases, a request for a NIB object might not provide the identity of the NIB object but instead might be based on non-entity name keys (e.g., might be a request for all entities that have a particular port). For these cases, the NIB includes an iterator that iterates through all entities looking for the key specified in the request.","The notification processor  interacts with the application interface  to receive NIB notification registrations from applications running on top of the NOS and other modules of the NOS (e.g., such as an export module within the transfer modules ). Upon receiving these registrations, the notification processor  stores notification requests in the notification registry  that identifies each requesting party and the NIB data tuple(s) that the requesting party is tracking.","As mentioned above, the system of some embodiments embeds in each NIB object a function for handling notification registrations for changes in the value(s) of that NIB object. For these embodiments, the notification processor  is a conceptual illustration of the amalgamation of all the NIB object notification functions. Other embodiments, however, do not provide notification functions in some or all of the NIB objects. The NOS of some of these embodiments therefore provides an actual separate module to serve as the notification processor for some or all of the NIB objects.","When some or all of the NIB objects have notification functions in some embodiments, the notification registry for such NIB objects are typically kept with the objects themselves. Accordingly, for some of these embodiments, the notification registry  is a conceptual illustration of the amalgamation of the different sets of registered requestors maintained by the NIB objects. Alternatively, when some or all of the NIB objects do not have notification functions and notification services are needed for these objects, some embodiments use a separate notification registry  for the notification processing module  to use to keep track of the notification requests for such objects.","The notification process serves as only one manner for accessing the data in the NIB. Other mechanisms are needed in some embodiments for accessing the NIB. For instance, the secondary storage structures (e.g., the PTD  and the DHT instance ) also need to be able to import data from and export data to the NIB. For these operations, the NOS  uses the transfer modules  to exchange data between the NIB and the secondary storage structure.","In some embodiments, the transfer modules include a NIB import module and a NIB export module. These two modules in some embodiments are configured through the NOS controller , which processes configuration instructions that it receives through the interfaces  from the applications above the NOS. The NOS controller  also performs several other operations. As with the notification processor, some or all of the operations performed by the NOS controller are performed by one or more functions of NIB objects, in some of the embodiments that implement one or more of the NOS  operations through the NIB object functions. Accordingly, for these embodiments, the NOS controller  is a conceptual amalgamation of several NOS operations, some of which are performed by NIB object functions.","Other than configuration requests, the NOS controller  of some embodiments handles some of the other types of requests directed at the NOS instance . Examples of such other requests include queries to read certain NIB attributes, queries to write to certain NIB attributes, requests to create or destroy NIB entities, requests to import or export entities on demand, and requests to synchronize NIB entities with switching elements or other NOS instances.","In some embodiments, the NOS controller stores requests to change the NIB on the NIB request list . Like the notification registry, the NIB request list in some embodiments is a conceptual representation of a set of distributed requests that are stored in a distributed manner with the objects in the NIB. Alternatively, for embodiments in which some or all of the NIB objects do not maintain their modification requests locally, the request list is a separate list maintained by the NOS . The system of some of these embodiments that maintains the request list as a separate list, stores this list in the NIB in order to allow for its replication across the different controller instances through the PTD storage layer. As further described below, this replication allows the distributed controller instances to process in a uniform manner a request that is received from an application operating on one of the controller instances.","Synchronization requests are used to maintain consistency in NIB data in some embodiments that employ multiple NIB instances in a distributed control system. For instance, in some embodiments, the NIB of some embodiments provides a mechanism to request and release exclusive access to the NIB data structure of the local instance. As such, an application running on top of the NOS instance(s) is only assured that no other thread is updating the NIB within the same controller instance; the application therefore needs to implement mechanisms external to the NIB to coordinate an effort with other controller instances to control access to the NIB. In some embodiments, this coordination is static and requires control logic involvement during failure conditions.","Also, in some embodiments, all NIB operations are asynchronous, meaning that updating a network entity only guarantees that the update will eventually be pushed to the corresponding switching element and\/or other NOS instances. While this has the potential to simplify the application logic and make multiple modifications more efficient, often it is useful to know when an update has successfully completed. For instance, to minimize disruption to network traffic, the application logic of some embodiments requires the updating of forwarding state on multiple switches to happen in a particular order (to minimize, for example, packet drops). For this purpose, the API of some embodiments provides the synchronization request primitive that calls back one or more applications running on top of the NOS once the state has been pushed for an entity. After receiving the callback, the control application of some embodiments will then inspect the content of the NIB and determine whether its state is still as originally intended. Alternatively, in some embodiments, the control application can simply rely on NIB notifications to react to failures in modifications as they would react to any other network state changes.","The NOS controller  is also responsible for pushing the changes in its corresponding NIB to switching elements for which the NOS  is the master. To facilitate writing such data to the switching element, the NOS controller  uses the switch controller . It also uses the switch controller  to read values from a switching element. To access a switching element, the switch controller  uses the switch interface , which, as mentioned above, uses OpenFlow or OVS, or other known sets of APIs in some embodiments.","Like the PTD and DHT storage structures  and  of the control system  of , the PTD and DHT storage structures  and  of  interface with the NIB and not the application layer. In other words, some embodiments only limit PTD and DHT layers to communicate between the NIB layer and these two storage layers, and to communicate between the PTD\/DHT storages of one instance and PTD\/DHT storages of other instances. Other embodiments, however, allow the application layer (e.g., the control application) within one instance to access the PTD and DHT storages directly or through the transfer modules . These embodiments might provide PTD and DHT access handles (e.g., APIs to DHT, PTD or CM interface) as part of the application interface , or might provide handles to the transfer modules that interact with the PTD layer (e.g., the CM interface ) and DHT layers, so that the applications can directly interact with the PTD and DHT storage layers.","Also, like structures  and , the PTD  and DHT instance  have corresponding lists of triggers that are respectively maintained in the CM interface  and the DHT instance . The use of these triggers will be further described below. Also, like the PNTD  of the control system , the PNTD  of  does not interface with the NIB . Instead, it interfaces with the application layer through the application interface . Through this interface, the applications running on top of the NOS can store data in and retrieve data from the PNTD. Also, applications of other controller instances can access the PNTD , as shown in .","The process for applications registering for NIB notifications will next be described in sub-section IV.B. After this discussion, the process for interacting with the DHT and\/or PTD upon modification of the NIB will be described in sub-section IV.C. Next, the process for handling NIB change requests from the application will be described in sub-section IV.D.","B. Application Registering for NIB Notification",{"@attributes":{"id":"p-0303","num":"0302"},"figref":"FIG. 27","b":["2700","2610"]},"As shown in , the process  initially registers (at ) a notification request for one application for a particular NIB data record. This request is recorded in the NIB data record's corresponding notification list in some embodiments, or in combined notification list for several NIB data records in other embodiments. After , the process  determines (at ) whether it should end. The process ends in some embodiments when it does not have any notifications left on its list of notifications for the particular NIB data record.","When the process determines (at ) that it should not end, the process determines (at ) whether the particular NIB data has changed. If not, the process transitions to , which will be further described below. When the process determines (at ) that the particular NIB data has changed, the process determines (at ) whether any application callbacks were triggered by the NIB data change. Such callbacks would be triggered always in embodiments that call back one or more applications when one or more callback notifications are on the notification lists. For such embodiments, the determination (at ) is not needed. Other embodiments, however, allow the callbacks to be set conditionally (e.g., based on the value of the changed record). In these embodiments, the determination (at ) entails determining whether the condition for triggering the callback has been met.","When the process determines (at ) that it needs to call back one or more applications and notify them of the changes to the NIB records, the process sends (at ) the notification of the NIB record change along with the new value for the changed NIB record to each application that it needs to notify (i.e., to each application that is on the notification list and that needs to be notified). From , the process transitions to . The process also transitions to  from  when it determines that no application callbacks were triggered by the NIB record change.","At , the process determines whether any new notification requests need to be registered on the callback notification list. If so, the process transitions to , which was described above. Otherwise, the process transitions to , where it determines whether any request to delete notification requests from the notification list has been received. If not, the process transitions to , which was described above. However, when the process determines (at ) that it needs to delete a notification request, it transitions to  to delete the desired notification request from the notification list. From , the process transitions to , which was described above.","C. Secondary Storage Records and Callbacks",{"@attributes":{"id":"p-0309","num":"0308"},"figref":"FIG. 28","b":["2800","2630","2640","2650","2800"]},"As shown in , the process  initially receives (at ) a notification of a change of a record within the NIB. The process  receives such notification in some embodiments because it previously registered for such notifications with the NIB (e.g., with a notification processor  of the NIB, or with the notification function of the NIB record that was changed).","After , the process determines (at ) whether the notification relates to creation of a new object in the NIB. If the notification does not correspond to a new NIB object, the process transitions to , which will be described further below. Otherwise, the process determines (at ) whether it needs to direct one or more secondary storages to create one or more records to correspond to the newly created NIB record. When the process determines (at ) that it does not need to direct any secondary storages to create any new records, the process ends. Otherwise, the process selects (at ) a secondary storage structure and directs (at ) this secondary storage structure to create a record that would correspond to the newly created NIB object. In the case of the DHT, the process  directly interfaces with a query manager of the DHT to make this request for a new record. In the case of the PTD, however, this request is routed to the master PTD through the CM(s) and CM interface(s) that serve as the interface between the PTD and the NIB layers.","After , the process, if necessary, registers (at ) for a callback from the selected secondary storage structure to the import module of the transfer modules . This callback is triggered in some embodiments whenever the newly created record in the selected secondary storage structure changes. In some embodiments, this callback notifies the import module that a record has changed in the secondary storage structure.","In the case of the PTD , the process  in some embodiments directs the CM interface  of the master PTD to create a trigger for the newly created PTD record and to identify the import module as the module to call back when the newly created PTD record has changed. As mentioned above, the CM processor then receives this request and directs the PTD trigger tracker of the master PTD to create such a trigger record in its PTD trigger list for the newly created PTD record.",{"@attributes":{"id":"p-0314","num":"0313"},"figref":"FIG. 29","b":"2955"},"In the case of the DHT, the process in some embodiments directs the DHT query manager to register a trigger for the newly created DHT record and to identify the import module of the NIB that originated the change as the module to call back, when the newly created DHT record has changed.  illustrates that the DHT record trigger is stored with the newly created record in some embodiments. Specifically, it shows that each DHT record has a hash index, a data value and the identity of one or more NIB import modules (of controller instances) to call back. More than one NIB import modules will be in the callback list because, in some embodiments, each time one controller instance's NIB does a DHT query, it records a NIB callback registration that identifies its NIB's corresponding import module. As further described below, the newly created DHT record will not necessarily be in the same instance as the NIB that originated the change received at .","Instead of registering for a callback at  upon creation of a new NIB record, the process  of other embodiments uses other techniques for registering callbacks to the NIB from one or more of the secondary storage structures. For instance, in some embodiments, the NIB import module of a controller instance registers for callbacks from the master PTD when the NIB and the import module are instantiated. In some embodiments, such callbacks are registered with the CM interface of the master PTD, and the CM interface performs these callbacks when the master PTD notifies it that one of its records has changed. Some embodiments use a similar approach to register for callbacks from the DHT, while other embodiments use the process  (or similar process) to register callbacks (e.g., at ) for the DHT.","After , the process adds (at ) the selected secondary storage structure to the list of modules that it needs to notify when the newly created NIB record has changed. The process then determines (at ) whether it has to select another secondary storage structure in which it has to create a new record to correspond to the newly created NIB record. In some embodiments, the process  can at most create a new record in the master PTD and a new record in one DHT instance. In other embodiments, however, the process can create more than these two records in more than two secondary storages of the controller instances of the control system.","When the process determines (at ) that it does not need to create a record in any other secondary storage structure, it ends. However, when the process determines (at ) that it needs to create a new record in another secondary storage structure, it returns to  to select another secondary storage structure and repeat its operations  to  for this structure.","When the process determines (at ) that the NIB change notification that it has received does not correspond to a new NIB object, the process transitions to . At , the process determines whether any secondary storages need to be notified of this NIB change. If not, the process ends. Otherwise, the process selects (at ) a secondary storage to notify and then notifies (at ) the selected secondary storage. In some embodiments, the notification of the selected secondary storage always or at times entails generating a write command to the secondary storage to direct it to modify a value of its record that corresponds to the NIB record which has been modified (i.e., which was the NIB record identified at ).","After , the process determines (at ) whether it needs to notify any other secondary storage of the NIB change. If so, the process returns to  to select another secondary storage structure to notify. Otherwise, the process ends.",{"@attributes":{"id":"p-0321","num":"0320"},"figref":"FIG. 31","b":["3100","2630","2640","2650","2800"]},"As shown in , the process  initially receives (at ) a notification of a change of a record within the secondary storage structure. The process  receives such notification in some embodiments because the process  previously registered for such notifications at . After , the process determines (at ) whether the notification relates to a change that needs to be imported into the NIB. If not, the process ends. Otherwise, the process queries (at ) the secondary storage structure (e.g., queries the PTD query manager through the CM interface, or queries the DHT query manager) for the new value of the changed record. At , the process also registers another notification in the secondary storage structure for the record for which it receives the notification at , if such a registration is desired and necessary. After , the process imports (at ) the received changed value into the NIB and then ends.",{"@attributes":{"id":"p-0323","num":"0322"},"figref":["FIG. 32","FIG. 32"],"b":["3200","2800","3100"]},{"@attributes":{"id":"p-0324","num":"0323"},"figref":"FIG. 32","b":["3201","3210","3250","3201","3230","3240","3210","3250","3220","3210","3250"]},"In the second stage , the NIB  adds a new NIB entity, which is illustrated by an arrow pointing to a new NIB node . The value of this new NIB record  is \u201cX\u201d in this example. Next, in the third stage , the export module  in the set of transfer modules receives notification of the newly created entity  in the NIB. Upon receipt of this notification, the export module  creates a new record  in the secondary storage layer as illustrated by the arrow starting at the export module and ending at the box  in the secondary storage layer . The third stage  shows that the value \u201cX\u201d is stored in the newly created record  in the secondary storage layer . In the third stage, the export module  also directs the secondary storage layer to create a trigger in the secondary storage layer (e.g., to create a DHT trigger in the DHT, or to create a PTD trigger in the CM) and register the identity of the import module  as a module to call back in case the new record  changes subsequently.","The fourth stage  illustrates the updating of the record  in the secondary storage at a subsequent point in time. This updating results in a new value \u201cS\u201d being stored in this record . This updating results in the identification of the notification trigger stored at the direction of the export module , and the subsequent identification of the import module  as a module to notify of the NIB change.","The fifth stage  illustrates that after the identification of the import module , this module  receives notification of the change to the record  that occurred in the fourth stage . With the double arrow connection between the import module  and the record , the fifth stage  also shows that the import module queries the secondary storage structure to receive the new value \u201cS\u201d once it determines that it needs to import this new value into the NIB. In the sixth, and final stage , the import module  imports the new value \u201cS\u201d into the NIB record  to reflect the change that occurred to the corresponding record  in the secondary storage layer in the fourth stage . This process shows how the transfer modules maintain consistency between the NIB and the secondary storage layer through use of export and import modules.","D. Application Requesting NIB Changes","The discussion above describes how the applications and export modules register notifications with the NIB and how the import modules import data into the NIB, in some embodiments of the invention. Another NIB layer interaction involves the applications requesting through the application interface  changes in the NIB. Some embodiments allow all applications to make such requests, but only make changes based on some of the application requests.","As further described below, in some embodiments, the system replicates the PTDs and NIBs across multiple controller instances. In some embodiments, the system takes advantage of this replication to distribute a request by one application to modify the NIB. For instance, in some embodiments, a request to modify the NIB from one controller instance's application is stored in a NIB request list  within the NIB . As this list is part of the NIB, additions to it are propagated to the NIBs of the other controller instances through the NIB\/PTD replication process, which will be further described below.","Each controller instance then subsequently retrieves the request from its NIB's request list and determines whether it should process the NIB change. The controller instance that should process the received NIB modification request and change the NIB then determines whether this change should be made, and if it determines that it should, it then modifies its NIB based on the request. If this controller instance determines that it should not grant this request, it rejects the request. In some embodiments, the NOS controller  of the NOS  is the module of the controller instance that decides whether it should process the request, and if so, whether it should make the desired change based on the request or deny this request. As mentioned above, the NOS controller  in some embodiments is a conceptual amalgamation of several different functions in several different NIB objects that process NIB modification requests from the application layer.","In some embodiments, the NOS controller , which makes or denies the requested NIB modification, records a response to the specified request in a response list in the NIB. This response list is part of the request list in some embodiments. Alternatively, this response list is a conceptual amalgamation of various response fields or attributes in various NIB objects. This response list is propagated to the other NIBs through the NIB\/PTD replication process. Each NOS controller  of each controller instance examines the response list to determine whether there are any responses that it needs to process. Accordingly, the NOS controller  of the controller instance that originated the NIB request modification removes the response added to the list by the controller that made or denied the NIB modification. Based on this response, this NOS controller then supplies an acknowledgment or a denial of the change to the application that originated the request.","For some embodiments of the invention,  illustrates three processes , , and  for dealing with a NIB modification request from an application (e.g., a control application) running on top of a NOS on one controller instance. Two of these processes  and  are performed by one controller instance, while the third  is performed by each controller instances. Specifically, the first process  is performed by the controller instance that receives the NIB modification request from an application that runs within that instance. This process starts (at ) when the NIB modification request is received. Next, the process  changes (at ) the request list in the NIB to reflect this new request. As this list is part of the NIB, additions to it are propagated to the NIBs of the other controller instances through the NIB\/PTD replication process that replicates the NIBs and PTDs across all the controller instances. After , the process  ends.","Process  is a process that each controller instance subsequently performs when it receives notification of the change to the request list. In some embodiments, this process previously registered to be notified of NIB modifications (e.g., with the notification processor ) whenever the request list is modified. As shown in , the process  initially retrieves (at ) the newly received request from the request list. It then determines (at ) whether its controller instance is the master of the portion of the NIB being changed. In some embodiments, the process  makes this determination by querying the CM interface  to inquire whether its controller instance is the master of the portion of the NIB being changed. As mentioned above, some embodiments have a one-to-one correlation between an instance being the master of a NIB data record and the instance being the master of the corresponding record in the switching element, while other embodiments allow one instance to be the master of a NIB data record and another instance be the master of the corresponding record in the switching element.","When the process  determines (at ) that its controller instance is not the master of the NIB portion being changed, it ends. Otherwise, the process calls (at ) the NIB updater process , and then ends.","Process  is the process that is performed by the controller instance that should process the received NIB modification request (i.e., by the controller instance that is the master of the NIB portion being changed). As shown in , this process initially determines (at ) whether it should make the requested change. The process  denies this request if it determines (at ) that the requesting application does not have authority to change the identified NIB portion. This might be the case if the application simply does not have this authority, if another application or instance locked the identified NIB portion from being modified by some or all other applications and\/or instances, or if the state has changed significantly since the request was made.","When the process determines (at ) the requested NIB modification should not be made, it transitions to , which will be described further below. Otherwise, when the process determines (at ) that it should perform the requested NIB modification, it makes (at ) this modification in the NIB and then transitions to .","At , the process removes the modification request from the request list. After , the process transitions to , at which point it updates the response list in the NIB to reflect an acknowledgement that it has made the desired modification. After , the process ends.","The response list is propagated to the other NIBs through the NIB\/PTD replication process. The NOS controller of the controller instance that originated the NIB request modification removes the response added to the list by the controller that made or denied the NIB modification. Based on this response, this NOS controller then supplies an acknowledgment or a denial of the change to the application that originated the request.","Some embodiments perform variations of the processes -. For instance, in some embodiments, the process  that handles the incoming NIB modification request from an application of its controller instance, initially determines whether the NIB modification needs a master controller to perform the modification. If not, the process  implements this change in some embodiments. Also, while some embodiments propagate the NIB modification request through the PTD storage layer, other embodiments propagate the NIB modifications through the DHT storage layer.","As described above,  illustrates that in some embodiments requests to modify the NIB from one controller instance are propagated through NIB request lists to the controller instance that is responsible for managing the portion of the NIB that the request identifies for the modification. In such a case, the NIB of some embodiments is used as a medium for communication between different controller instances and between the processing layers of the controller instances (e.g., a control application, a virtualization application, and a NOS). Other examples of the NIB as a communication layer between controller instances exist. For example, one controller instance might generate physical control plane data for a particular managed switching element. This update is then transmitted through the secondary storage layer to the NIB of another controller instance that is the master of the particular managed switching element. This other controller instance then pushes the physical control plane data to the particular managed switching element. Also, the NIB may be used as a communication layer between different applications of one controller instance. For instance, a control application can store logical forwarding plane data in the NIB and a virtualization application may retrieve the logical forwarding plane data from the NIB, which the virtualization application then converts to physical control plane data and stores in the NIB.","V. Secondary Storage","A. DHT",{"@attributes":{"id":"p-0343","num":"0342"},"figref":["FIG. 34","FIG. 34"],"b":["3400","3400","3405","3410","3415","3420","3425","3430"]},"In several embodiments described below, the query manager  receives queries only from other DHT storage structures and from the import and export modules of the controller instance that includes the DHT storage structure . In other embodiments, the query manager  also receives queries from applications running on top of the NOS instances.","The query manager  interacts with the other software modules contained inside of the DHT storage structure  in order to process queries. In some embodiments, the query manager  can handle \u201cput\u201d and \u201cget\u201d queries. When the query manager  receives a \u201cput\u201d query, it adds or changes a data record in the hash table . When the query manager  receives a \u201cget\u201d query, the query manager  retrieves a data record from the hash table  and returns this data record to the querying entity.","The query manager in some embodiments can receive a query with a key value for a record in the hash table. In some of these embodiments, the query in some cases can also include a hash value that corresponds to the hash of the key value, whereas the query in other cases does not include a hash value.","The hash generator  is used by the query manager  to generate a hash value for a received key value. For instance, when query manager receives a query that does not specify a hash value, it sends the query along with the received key value. The hash generator  contains and executes one or more hash functions on the received key value to generate a hash value. The hash generator  sends hash values that it generates to the query manager .","The DHT range list  contains a list of hash value ranges, with different ranges being associated with different DHT instances of different controller instances. The CM (e.g., CM ) periodically updates the DHT range list , as described above and further described below. The query manager  uses the DHT range list to identify the DHT instance that contains a DHT record associated with a hash value that it receives from the hash generator  or receives with the query. For a particular hash value, the DHT range list  might specify the current DHT instance (i.e., the DHT instance whose query manager is currently processing the DHT query) as the location of the corresponding DHT record, or alternatively, it can specify another DHT instance that runs in another controller instance as the location of the desired DHT record.","When the DHT range list  shows that the hash value falls within a range of another DHT instance, the query manger  uses its remote DHT module interface to pass the query to the remote DHT that contains the desired DHT record. In some embodiments, the query manager  also sends the hash value the local hash generator  so that the remote hash generator does not need to re-compute this hash value. After processing the query, the remote DHT data structure will send the requested data record to the requesting query manager  through its remote DHT interface module . Thus, the remote DHT interface module  serves two functions. First, the remote DHT interface module  sends queries, data records, and hash values to remote DHT storage structures. Second, the remote DHT interface module  receives queries, data records, and hash values from remote DHT storage structures. The remote DHT interface module  enables the query managers of all the DHT storage structures in the network to share the information stored in their local hash tables.","When the DHT range list  shows that a hash value is stored locally, the query manager  will use the hash value to access its local hash table  for the hash record associated with the hash value. The hash table  contains several data records and a hash value for each data record. When this table receives a hash value, it returns the data record associated with the hash value.","The trigger processor  handles trigger notifications when the query manager modifies a record in the local hash table . Whenever the query manager writes a new value in the hash table, the hash table in some embodiments returns a set of identities for a set of modules to notify in the same or different controller instances. The trigger processor receives this set of identities. It then notifies the associated modules of the change to the DHT record. If needed, the modules then query the DHT instance to retrieve the new value for the DHT record.","Other embodiments may implement the triggering process differently. For instance, in conjunction with or instead of triggering based on writes to the hash table, the triggering in some embodiments is performed based on deletes from the hash table. Also, instead of just calling back modules to notify them that a DHT record value has changed, some embodiments send the new value of the DHT record along with the notification to the modules that are called back.","The description of the operation of the DHT storage structure  will now be described in reference to , , and .  illustrates a simple example of the operation of the DHT storage structure  for the case where the DHT record being retrieved is stored locally within the DHT storage structure. This example is further simplified by ignoring access to the DHT range list and the handling of triggers.  subsequently provide more elaborate examples that show how the DHT range list is accessed and how the triggers are processed.",{"@attributes":{"id":"p-0354","num":"0353"},"figref":["FIG. 35","FIG. 35"],"b":["3500","3510","3520","3530","3510","3540","3550","3510","3540","3550","3520","3520","3541","3540","3551","3550","3520","3541","3551","3510","3510","3530","3530","3530","3542","3510","3542","3552"]},{"@attributes":{"id":"p-0355","num":"0354"},"figref":"FIG. 36","b":["3600","3600","3610","3620","3630","3632","3640","3650"]},"In this example, the query manager  initially receives from a querying entity a put query  includes a key  and a value . The query manager  then sends the key  to the hash generator , which generates hash  and returns this hash to the query manager . The query manager  then provides the hash  to the DHT range list . The DHT range list  then identifies a range of hash values in which the hash  falls.  illustrates that the CM  periodically updates the DHT range list. The CM is shown with dashed lines in this example as it is not one of the components of the DHT and its operation is not in the same sequence as the other operations illustrated in .","Based on the range that the DHT range list  identifies, it identifies a corresponding controller instance whose DHT instance contains the desired DHT record (i.e., the record corresponding to the generated hash value). The DHT range list  returns the identification  of this controller instance to the query manager . In this case, the identified controller instance is the local controller instance.","Hence, the query manager  next performs a put query on its local hash table . With this query, the query manager  sends the hash , and the value  to write in the corresponding DHT record in the hash table . Because the put query  is a put command, the hash table  writes the value  in the hash table. If the accessed DHT record did not exist before this put query, the hash table generates a DHT record based on this query and stores in this record the hash  along with the value .","In this example, the modified DHT record has a set of notification triggers (i.e., a set of identities of modules that need to be notified). Accordingly, after modifying its DHT record, the hash tables  sends the list  of modules that need to be notified of the DHT record modification. The query manager  then sends the key  that identifies the modified record along with the trigger list  to the trigger processor . The trigger processor  processes the triggers in the trigger list  by sending a notification  to all entities that have registered triggers (i.e., all modules on the trigger list ) that the DHT record (with the key ) has been modified. The three arrows exiting the trigger processor  represent the key  and notification  are being sent to three registered modules in this example. In addition to sending the key and trigger list to the trigger processor, the query manager also sends a confirmation  of the completion of the Put request to the source that sent it the Put query.",{"@attributes":{"id":"p-0360","num":"0359"},"figref":"FIG. 37","b":["3700","3700","3700","3701","3705","3706","3710","3715","3720","3730","3732","3745","3750"]},"The example begins when the query manager  receives a put query  that includes key  and value . The query manager  then sends the key  to the hash generator . The hash generator  generates hash  and sends the hash  to the query manager .","The query manager  then sends the hash  to the DHT range list . As was the case in , the DHT range list  is periodically updated by the CM . The DHT range list  identifies a range of hash values in which the hash  falls. Based on the range that the DHT range list  identifies, it identifies a corresponding controller instance whose DHT instance contains the desired DHT record (i.e., the record corresponding to the generated hash value). The DHT range list  returns the identification  of this controller instance to the query manager . In this case, the identified controller instance is the remote controller instance .","Because instance  manages the desired DHT record, the query manager  relays the key , put query , hash , and value  to the query manager  of the instance . The query manager  then sends the value  and the hash  to the hash table , which then writes value  to its record at hash .","In this example, the modified DHT record has a set of notification triggers. Accordingly, after modifying its DHT record, the hash tables  sends to the query manager  the trigger list  of modules that need to be notified of the DHT record modification. The query manager  then sends key  and trigger list  to the trigger processor . The trigger processor  processes the triggers  by sending a notification  to all entities that have registered triggers (i.e., all modules on the trigger list ) that the DHT record (with key ) has been modified. The three arrows exiting the trigger processor  represent the key  and notification  are being sent to three registered modules in this example.","In addition to sending the key and trigger list to the trigger processor, the query manager of instance B also sends a confirmation  of the completion of the Put request to the query manager  of the instance A. The query manager  then relays this confirmation  to the source that sent it the Put query.",{"@attributes":{"id":"p-0366","num":"0365"},"figref":"FIG. 38","b":["3800","3405"]},"As shown in , the process  initially receives (at ) an access request for a record within the DHT. In some embodiments, the process  receives an access request from an import module  or an export module  of the transfer modules . In some embodiments, the process receives an access request from another query manager on a remote NOS instance's DHT as shown in . After , the process generates (at ) a hash value for the access request if necessary. In some embodiments, the hash value does not need to be generated when it is provided in the access request in some embodiments, but when the access request does not include a hash value, it is necessary for the process to generate a hash value. The process generates the hash value from information contained in the access request. In some embodiments, the process hashes the key that identifies the data to be accessed.","The process  then uses the hash value it generated (at ) or received (at ) with the access request to check (at ) the DHT range list. The DHT range list contains a list of hash ranges associated with DHT instances and is locally cached by the query manager . If a hash value is within a DHT range for a DHT instance on the DHT range list, then that DHT instance can process an access request for said hash value.","After referencing the DHT range list (at ), the process determines (at ) whether the access request can be processed locally. If so, the process executes (at ) the access request. In some embodiments, the execution of the access request consists of the process performing a \u201cput\u201d function or a \u201cget\u201d function on the records requested by the access request. After executing the access request , the process receives (at ) triggers from the local DHT records on data that the access request operated on, if any. A trigger is list of entities that the query manager must notify if the query manager accesses the record associated with the trigger. In some embodiments, the entities that could have triggers on DHT data are the notification processors , the transfer modules , or the application interface . In some embodiments, the triggers are stored with the local DHT records as shown in . After , the process handles (at ) trigger notifications, if the process received (at ) any triggers. The process handles (at ) the trigger notifications by sending notifications to any entities on the triggers. After , the process transitions to , which will be explained below.","When the process determines (at ) that the access request cannot be processed locally, the process sends (at ) the access request to the remote DHT node identified (at ) on the DHT range list. The process sends (at ) the access request to the remote DHT node including any hash values received (at ) or generated (at ). After sending the access request to a remote DHT node , the process transitions to  to wait for a confirmation from the remote DHT node. Once the process receives (at ) confirmation from the remote DHT node, the process transitions to .","At , the process sends a confirmation to the source that sent it the query. When the query is a Put query, the confirmation confirms the completion of the query. However, when the query is a Get query, the confirmation relays the data retrieved from the DHT. Also, in cases that the remote DHT node does not return a confirmation (at ) within a timely manner, the process  has an error handling procedure to address the failure to receive the confirmation. Different embodiments employ different error handling procedures. In some embodiments, the error handler has the DHT node re-transmit the query several times to the remote node, and in case of repeated failures, generate an error to the source of the query and\/or an error for a system administrator to address the failure. Other embodiments, on the other hand, do not re-transmit the query several times, and instead generate an error to the source of the query and\/or an error for a system administrator to address upon failure to receive confirmation.","B. PTD",{"@attributes":{"id":"p-0373","num":"0372"},"figref":"FIG. 39","b":"3900"},"As described above and as illustrated in , data is exchanged between a NIB  and the PTD  through transfer modules  and CM interface . In some embodiments, the NIB  and the PTD  that exchange data through these intermediate modules can be in the same controller instance (e.g., the NIB and PTD are part of the master PTD controller instance), or the NIB and PTD can be part of two different controller instances. When the NIB and PTD are part of two different controller instances, the CM interface  is an amalgamation of the CM interface of the two controller instances.","As further illustrated in , the PTD  includes a query manager  and a set of database tables . In some embodiments, the query manager  receives queries  from the CM interface  and provides responses to these queries through the CM interface. In some embodiments, the PTD  and its query manager  can handle complex transactional queries from the CM interface . As a transactional database, the PTD can undo a series of prior query operations that it has performed as part of a transaction when one of the subsequent query operations of the transaction fails.","Some embodiments define a transactional guard processing (TGP) layer before the PTD in order to allow the PTD to execute conditional sets of database transactions. In some embodiments, this TGP layer is built as part of the CM interface  or the query manager  and it allows the transfer modules  to send conditional transactions to the PTD.  illustrates an example of a simple conditional transaction statement  that the query manager  can receive. In this example, all the ports of a tenant \u201cT1\u201d in a multi-tenant server hosting system are set to \u201copen\u201d if the Tenant ID is that of tenant T1. Otherwise, all ports are set to close.","In some embodiments, the controller instances maintain identical data records in the NIBs and PTDs of all controller instances. In other embodiments, only a portion of the NIB data is replicated in the PTD. In some embodiments, the portion of NIB data that is replicated in the PTD is replicated in the NIBs and PTDs of all controller instances.",{"@attributes":{"id":"p-0378","num":"0377"},"figref":"FIG. 40","b":"4000"},"As shown in  the process  initially propagates () any changes made to the NIB layer to the PTD layer. In some embodiments, the data is translated, transformed, or otherwise modified when it is transferred from the NIB layer to the PTD layer, while in other embodiments the data is transferred from the NIB layer to the PTD layer in the same format. Also, in some embodiments, the change to the NIB is propagated to the PTD in the same controller instance as the NIB. However, as described below, some embodiments propagate the NIB change first to a master PTD instance.","After , the process replicates (at ) the change across the PTDs of the PTD layer. In some embodiments, the change is replicated across all PTDs by having the PTD of the instance that received the NIB change notify the other PTDs. However, as described below, the process  of some embodiments employs the master PTD to notify all other slave PTDs to replicate the change in their PTDs.","After the process completes the PTD replication operation , the process propagates (at ) the NIB change to all the NIBs of all other controller instances. In some embodiments, this process is performed by each controller instance's transfer modules retrieving the modified PTD record from its local PTD after being locally notified by its PTD storage layer (e.g., by the local CM interface of that instance) of the local PTD change. However, as mentioned above, the process  in some embodiments replicates the NIB change in all the NIBs by having the master PTD notify each instance's transfer module of the PTD layer change, and then supplying each instance's NIB with the modified record. As further described above, the master PTD supplies the modified record with the notification of PTD layer change to each NIB instance in some embodiments, while in other embodiments, the master PTD supplies the modified record to each NIB instance after it notifies the NIB instance and the NIB instance in response queries the master PTD for the modified record. After , the process ends.",{"@attributes":{"id":"p-0382","num":"0381"},"figref":["FIG. 41","FIG. 41"],"b":["4100","4100","4110","4110"]},"After , the process determines (at ) whether this instance is the master PTD instance. A slave PTD instance is PTD without the authority to write to that PTD without direction from a master PTD instance, while a master PTD instance is a PTD that has the authority to make updates to its PTD and distributes updates to the PTDs of the slave PTD instances.","When the process  determines that it is the master PTD, it initiates (at ) the master update process, and then terminates. The master update process will be described below by reference to . When the process determines (at ) that it is not the master PTD, the process transmits (at ) the PTD update request to the CM interface of the master PTD instances. The process then waits (at ) until the process receives an update command from the master PTD instance. When the process receives (at ) an update command from the master PTD instance, the process sends (at ) to its controller instance's NIB import module a PTD update notification, which then causes this module to update its NIB based on the change in the PTD. In some embodiments, this PTD update notification is accompanied with the updated record, while in other embodiments, this notification causes the import module to query the master PTD to retrieve the updated record. After , the process ends.","For some embodiments, the wait state  in  is a conceptual representation that is meant to convey the notion that the slave PTD does nothing further for a PTD update request after it notifies the master PTD and before it receives a PTD update request from the master. This wait state is not meant to indicate that the PTD slave instance has to receive a PTD update request from the master. In some embodiments, the PTD slave instance sends to the master a PTD update request if it does not hear from the master PTD to make sure that the master PTD receives the PTD update request. If for some reason, the PTD master determines that it should not make such a change, it will notify the slave PTD instance in some embodiments, while in other embodiments the slave PTD instance will stop notifying the master of the particular PTD update request after a set number of re-transmissions of this request.",{"@attributes":{"id":"p-0386","num":"0385"},"figref":"FIG. 42","b":"4200"},"As shown in , the process  initially receives (at ) a PTD update request. The PTD update request can come from the process  of the master PTD instance or of another slave PTD instance. The PTD update request can comprise a request to add, modify, or delete PTD records. In some embodiments, the PTD is a database (e.g., SQLite) that supports complex, transactional queries. Where the PTD is a database, the PTD update request can comprise a complex, transactional database query.","After , the process directs (at ) the slave PTD instances to update their PTDs and the process requests acknowledgment of completion of the PTD update from all slave PTD instances. In some embodiments, the direction to update PTDs is sent from the master PTD instance's CM interface to the CM interfaces of the slave PTD instances, and the master PTD instance's CM interface will receive acknowledgment of the completion of the PTD update from the slave PTD instances' CM interfaces.","After , the process in some embodiments determines (at ) whether it has received acknowledgement from all slave instances of completion of the PTD update process. Instead of requiring acknowledgments from all slave instances, the process  of some embodiments only requires (at ) acknowledgments from a majority of slave instances.","When the process determines (at ) that it has not yet received acknowledgement from a sufficient number of slave instances (e.g., from all slave instances or a majority of slave instances), the process determines (at ) whether to call an error handler. If not, the process returns to  to wait for acknowledgements from the slave instances. Otherwise, the process calls (at ) the error handler to address the lack of acknowledgement from the slave PTDs. In some embodiments, the error handler flags the unresponsive slave PTDs for a system administrator to examine to determine the reason for their lack of response. In some embodiments, the process  re-transmits the PTD update command a set number of times to each unresponsive slave instance, before calling the error handler to address these unresponsive slave instances. After calling the error handler (at ), the process ends.","When the process determines (at ) that it has received acknowledgement from a sufficient number of slave instances (e.g., from all slave instances or a majority of slave instances), the process transitions to . At , the process records the PTD update in its master PTD. It then sends (at ) a PTD update notification to all NIB import modules (including the import module of the master PTD controller) to update their NIBs based on the received NIB modification and requests acknowledgement of completion of those NIB update from a sufficient number instances. This PTD update notification causes each NIB import module to update its NIB based on the change in the PTD. In some embodiments, this PTD update notification is accompanied with the updated record, while in other embodiments, this notification causes the import module to query the master PTD to retrieve the updated record. In some embodiments, the process also sends the NIB import module of its controller instance a PTD update notification, in order to cause this import module to update its NIB. Alternatively, the process  makes the modifications to its NIB at  instead of at  in some embodiments.","At , the process determines whether it has received acknowledgement from all slave instances of the completion of the NIB update process. If so, the process ends. Otherwise, the process determines (at ) whether to call an error handler. If not, the process returns to  to wait for acknowledgements from the slave instances. When the process determines (at ) that it should call the error handler (e.g., that sufficient time has passed for it to call an error handler), the process calls (at ) the error handler to address the lack of acknowledgement from the slave instances. In some embodiments, the error handler flags the unresponsive slave instances for a system administrator to examine to determine the reason for their lack of response. In some embodiments, the process  re-transmits the NIB update command a set number of times to each unresponsive slave instance, before calling the error handler to address these unresponsive slave instances. Also, in some embodiments, the process  does not request acknowledgments at  or wait for such acknowledgments at . In some of these embodiments, the process  simply ends after sending the PTD update notification at .",{"@attributes":{"id":"p-0393","num":"0392"},"figref":"FIG. 43","b":["4350","4360","4370","4380","4361","4362","4363","4364","4360","4365","4351","4370"]},"As shown in , the first stage  shows four PTD instances at steady state. In the second stage , the slave instance's transfer module  detects a change in the NIB and transfers  that change to the slave instance's CM interface . In the third stage , the CM interface  of the slave instance  sends notification  to the CM interface  of the master instance  of the change the slave is trying to push to the PTD layer. In some embodiments, the slave instance's transfer module  directly contacts the master instance's CM interface  when it detects a change in the NIB during the second stage. In such a case, the third stage  would not be needed as the master's CM interface would be notified directly during the second stage .","In the fourth stage , the CM interface  of the master instance  pushes the requested change to the master PTD . In this case the master instance  approved the change and wrote it to the master PTD. However, in other cases, the master could have refused the change and sent an error message back to the slave controller instance .","The fifth stage  shows the CM interface  of the master instance  sending notification  to the CM interfaces of the slave instances  and  of the change that the master has made to the master PTD. In some embodiments, the master PTD sends the updated PTD record with its notification  to the CM interfaces of the slave instances, while in other embodiments, the slave CM interfaces retrieve the updated PTD record from the master after receiving notification of the change from the master.","In the sixth stage , the CM interfaces of the slave instances  and  write an update  to change to their slave PTDs. In the seventh stage , the CM interface  of the master instance  receives acknowledgements  from the slave instances  and  that the slaves have performed the PTD change the master instance pushed to the slave instances during the fifth stage.","In the eighth stage , the CM interface  of the master instance pushes the change made to the PTD by sending a PTD update notification to the NIB import modules inside the transfer modules  of all the controller instances , , , and . In some embodiments, the PTD update notification causes each NIB import module to update its NIB based on the change in the PTD. In some embodiments, this PTD update notification is accompanied with the updated record, while in other embodiments, this notification causes the import module to query the master PTD to retrieve the updated record. Also, in some embodiments, the master PTD does not send a PTD update notification to the NIB import module of the slave controller instance  that detected the NIB change for some or all NIB changes detected by this slave controller instance.","C. NIB Replication Through DHT","As mentioned above, the controller instances replicate data records in the NIBs of all controller instances. In some embodiments, some of this replication is done through the PTD storage layer (e.g., by using the processes described in Section V.B. above, or similar processes) while the rest of this replication is done through the DHT storage layer.",{"@attributes":{"id":"p-0401","num":"0400"},"figref":["FIG. 44","FIG. 44"],"b":["4400","4410"]},"After , the DHT instance then modifies (at ) according to the update notification its record that corresponds to the updated NIB record. Next, at , the DHT instance retrieves for the updated DHT record a list of all modules to call back in response to the updating of the DHT record. As mentioned above, one such list is stored with each DHT record in some embodiments. Also, to effectuate NIB replication through the DHT storage layer, this list includes the identity of the import modules of all NIB instances in some embodiments. Accordingly, at , the process  retrieves the list of all NIB import modules and sends to each of these modules a notification of the DHT record update. In response to this update notification, each of the other NIB instances (i.e., the NIB instances other than the one that made the original modification that resulted in the start of the process ) update their records to reflect this modification. After , the process  ends.","VI. Electronic System","Many of the above-described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium (also referred to as computer readable medium). When these instructions are executed by one or more processing unit(s) (e.g., one or more processors, cores of processors, or other processing units), they cause the processing unit(s) to perform the actions indicated in the instructions. Examples of computer readable media include, but are not limited to, CD-ROMs, flash drives, RAM chips, hard drives, EPROMs, etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.","In this specification, the term \u201csoftware\u201d is meant to include firmware residing in read-only memory or applications stored in magnetic storage, which can be read into memory for processing by a processor. Also, in some embodiments, multiple software inventions can be implemented as sub-parts of a larger program while remaining distinct software inventions. In some embodiments, multiple software inventions can also be implemented as separate programs. Finally, any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments, the software programs, when installed to operate on one or more electronic systems, define one or more specific machine implementations that execute and perform the operations of the software programs.",{"@attributes":{"id":"p-0405","num":"0404"},"figref":"FIG. 45","b":["4500","4500","4500","4500","4505","4510","4525","4530","4535","4540","4545"]},"The bus  collectively represents all system, peripheral, and chipset buses that communicatively connect the numerous internal devices of the electronic system . For instance, the bus  communicatively connects the processing unit(s)  with the read-only memory , the system memory , and the permanent storage device .","From these various memory units, the processing unit(s)  retrieve instructions to execute and data to process in order to execute the processes of the invention. The processing unit(s) may be a single processor or a multi-core processor in different embodiments.","The read-only-memory (ROM)  stores static data and instructions that are needed by the processing unit(s)  and other modules of the electronic system. The permanent storage device , on the other hand, is a read-and-write memory device. This device is a non-volatile memory unit that stores instructions and data even when the electronic system  is off. Some embodiments of the invention use a mass-storage device (such as a magnetic or optical disk and its corresponding disk drive) as the permanent storage device .","Other embodiments use a removable storage device (such as a floppy disk, flash drive, etc.) as the permanent storage device. Like the permanent storage device , the system memory  is a read-and-write memory device. However, unlike storage device , the system memory is a volatile read-and-write memory, such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments, the invention's processes are stored in the system memory , the permanent storage device , and\/or the read-only memory . From these various memory units, the processing unit(s)  retrieve instructions to execute and data to process in order to execute the processes of some embodiments.","The bus  also connects to the input and output devices  and . The input devices enable the user to communicate information and select commands to the electronic system. The input devices  include alphanumeric keyboards and pointing devices (also called \u201ccursor control devices\u201d). The output devices  display images generated by the electronic system. The output devices include printers and display devices, such as cathode ray tubes (CRT) or liquid crystal displays (LCD). Some embodiments include devices such as a touchscreen that function as both input and output devices.","Finally, as shown in , bus  also couples electronic system  to a network  through a network adapter (not shown). In this manner, the computer can be a part of a network of computers (such as a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), or an Intranet, or a network of networks, such as the Internet. Any or all components of electronic system  may be used in conjunction with the invention.","Some embodiments include electronic components, such as microprocessors, storage and memory that store computer program instructions in a machine-readable or computer-readable medium (alternatively referred to as computer-readable storage media, machine-readable media, or machine-readable storage media). Some examples of such computer-readable media include RAM, ROM, read-only compact discs (CD-ROM), recordable compact discs (CD-R), rewritable compact discs (CD-RW), read-only digital versatile discs (e.g., DVD-ROM, dual-layer DVD-ROM), a variety of recordable\/rewritable DVDs (e.g., DVD-RAM, DVD-RW, DVD+RW, etc.), flash memory (e.g., SD cards, mini-SD cards, micro-SD cards, etc.), magnetic and\/or solid state hard drives, read-only and recordable Blu-Ray\u00ae discs, ultra density optical discs, any other optical or magnetic media, and floppy disks. The computer-readable media may store a computer program that is executable by at least one processing unit and includes sets of instructions for performing various operations. Examples of computer programs or computer code include machine code, such as is produced by a compiler, and files including higher-level code that are executed by a computer, an electronic component, or a microprocessor using an interpreter.","While the above discussion primarily refers to microprocessor or multi-core processors that execute software, some embodiments are performed by one or more integrated circuits, such as application specific integrated circuits (ASICs) or field programmable gate arrays (FPGAs). In some embodiments, such integrated circuits execute instructions that are stored on the circuit itself.","As used in this specification, the terms \u201ccomputer\u201d, \u201cserver\u201d, \u201cprocessor\u201d, and \u201cmemory\u201d all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification, the terms display or displaying means displaying on an electronic device. As used in this specification, the terms \u201ccomputer readable medium,\u201d \u201ccomputer readable media,\u201d and \u201cmachine readable medium\u201d are entirely restricted to tangible, physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals, wired download signals, and any other ephemeral signals.","While the invention has been described with reference to numerous specific details, one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. In addition, a number of the figures (including , , , , , , ,  and ) conceptually illustrate processes. The specific operations of these processes may not be performed in the exact order shown and described. The specific operations may not be performed in one continuous series of operations, and different specific operations may be performed in different embodiments. Furthermore, the process could be implemented using several sub-processes, or as part of a larger macro process.","Also, several embodiments were described above in which a user provide logical datapath sets in terms of logical control plane data. In other embodiments, however, a user may provide logical datapath sets in terms of logical forwarding plane data. In addition, several embodiments were described above in which a controller instance provide physical control plane data to a switching element in order to manage the switching element. In other embodiments, however, the controller instance may provide the switching elements with physical forwarding plane data. In such embodiments, the NIB would store physical forwarding plane data and the virtualization application would generate such data.","Furthermore, in several examples above, a user specifies one or more logic switches. In some embodiments, the user can provide physical switch configurations along with such logic switch configurations. Also, even though controller instances are described that in some embodiments are individually formed by several application layers that execute on one computing device, one of ordinary skill will realize that such instances are formed by dedicated computing devices or other machines in some embodiments that perform one or more layers of their operations. Thus, one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details. Thus, one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features of the invention are set forth in the appended claims. However, for purposes of explanation, several embodiments of the invention are set forth in the following figures.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 19","FIG. 18"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 32","FIGS. 28 and 31"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIGS. 36 and 37"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 45"}]},"DETDESC":[{},{}]}
