---
title: Visual debugger for stylesheets
abstract: A visual Debugger for stylesheets assists a user of stylesheets debug the stylesheets by: allowing the user to set breakpoints on the stylesheet; running to, and stopping at, the breakpoints; single stepping through each template rule as the rule is fired (both forward and backward); evaluating the template rule on the fly; showing the relationship between each template rule and the source document that provides the data; supporting stylesheets that call external programs written in Java or JavaScript; supporting stylesheets that include or import other stylesheets; supporting XML documents that use the “?xml-stylesheet” processing instruction to include stylesheets; supporting multiple debug sessions; and allowing the user to edit the stylesheet or source document and then allowing the debugger to be relaunched.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07890931&OS=07890931&RS=07890931
owner: International Business Machines Corporation
number: 07890931
owner_city: Armonk
owner_country: US
publication_date: 20030610
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates to working with stylesheets and, more specifically, to a visual debugger for stylesheets.","The World Wide Web Consortium (W3C) describes the eXtensible Stylesheet Language (XSL) as a language for expressing stylesheets. Where a \u201cstylesheet\u201d, a term extended from print publishing to online media, is a definition of the appearance of a document. XSL consists of three parts. The first part is XSL Transformations (XSLT), a language for transforming eXtensible Markup Language (XML) documents. The second part is the XML Path Language (XPath), an expression language used by XSLT to access, or to refer to, parts of an XML document. The third part is XSL Formatting Objects, an XML vocabulary for specifying formatting semantics.","An XSL stylesheet consists of a set of elements called templates. Each template is surrounded by <xsl: template> tags and contains rules to apply when a specified pattern is matched.","Developing XSL stylesheets can be very complicated and error-prone due to the declarative and recursive nature of the XSL language. Often it is difficult to determine, after the application of an XSL stylesheet to an XML document, which template rule has fired (i.e., which template rule has been used) and which pattern has been matched.","Clearly there is a need for an improved debugger to help the developer of stylesheets to debug stylesheets under development.","A visual Debugger for stylesheets is provided to assist a user of stylesheets to debug the stylesheets. The debugger provides a visual environment (display) from which a source document and a stylesheet to be applied to the source document may be selected. During the application of the selected stylesheet to the source document, the debugger receives events from the stylesheet processor and updates the visual environment based on the received event.","The visual debugger may have many features including: allowing the user to set breakpoints on the stylesheet; running to, and stopping at, the breakpoints; single stepping through each template rule as the rule is fired (both forward and backward); evaluating the template rule on the fly; showing the relationship between each template rule and the source document that provides the data; supporting stylesheets that call external programs written in Java or JavaScript; supporting stylesheets that include or import other stylesheets; supporting XML documents that use the \u201c?xml-stylesheet\u201d processing instruction to include stylesheets; supporting multiple debug sessions; and allowing the user to edit the stylesheet or source document and then allowing the debugger to be relaunched.","In accordance with an aspect of the present invention there is provided a computer readable medium containing computer-executable instructions which, when performed by a processor in a computer system, cause the computer system to provide a display of a source document and a stylesheet to be applied to the source document, instruct a stylesheet processor to launch application of the stylesheet to the source document, receive a plurality of events from the stylesheet processor, where the plurality of events relate to the application, by the stylesheet processor, of the stylesheet to the source document and update the display based on the plurality of events.","In accordance with another aspect of the present invention there is provided a stylesheet debugging system. The stylesheet debugging system includes a display monitor adapted to provide a display of a source document and a stylesheet to be applied to the source document. The stylesheet debugging system also includes a processor adapted to instruct a stylesheet processor to launch application of the stylesheet to the source document, receive a plurality of events from the stylesheet processor, where the plurality of events relate to the application of the stylesheet to the source document and update the display based on the plurality of events.","In accordance with another a further aspect of the present invention there is provided a method of providing support for stylesheet debugging. The method includes providing a user interface including a display, the user interface adapted to receive an indication of a source document and a stylesheet to be applied to the source document, instructing a stylesheet processor to launch application of the stylesheet to the source document, receiving a plurality of events from the stylesheet processor, where the plurality of events relate to the application of the stylesheet to the source document and updating the display based on the plurality of events. Additionally, there is provided a computer readable medium for allowing a general purpose computer to perform this method.","Other aspects and features of the present invention will become apparent to those of ordinary skill in the art upon review of the following description of specific embodiments of the invention in conjunction with the accompanying figures.","The developer of an XSL stylesheet (i.e., the potential user of a visual debugger for stylesheets) has, generally, initially generated an XSL stylesheet, perhaps using an editor optimized for editing XSL stylesheets. The developer then wishes to test (debug) the generated XSL stylesheet. Such testing involves applying the generated XSL stylesheet to a source XML document. The application of the generated XSL stylesheet to the source XML document is said to \u201ctransform\u201d the source XML document. This transformation results in the creation of a new document, where the new document may be formatted, for example, in the Hyper-Text Markup Language (HTML), XML or text. The new HTML, XML or text document may then be opened in a typical Web browser, such as Microsoft\u00ae Internet Explorer or Netscape\u00ae Navigator.","To apply an XSL stylesheet to an XML document, a \u201cprocessor\u201d application is required. One processor known to the applicant is the \u201cXalan\u201d processor. The Xalan processor is an XSLT processor that transforms XML documents into documents formatted as HTML, text or another XML file type. The Xalan processor implements the W3C Recommendations for XSL Transformations (XSLT) and the XML Path Language (XPath) (For more information on the Xalan processor, see http:\/\/xml.apache.org\/xalan-j\/).","Aspects of the visual debugger for stylesheets of the present invention enable a user to visually step through an XSL transformation script (i.e., an XSLT stylesheet). While the user steps through the script, the user may highlight transformation rules as the rules are fired. Thus, the user may be shown the relationship between each rule and the source document.","In overview, the challenges inherent in providing a visual debugger for stylesheets are met by two new components, namely a \u201cuser interface\u201d component and an \u201cengine\u201d component. A visual XSL Debugger  is logically illustrated in . As shown, the visual XSL Debugger  includes an XSL Debugger user interface component  and an XSL Debugger engine component . In normal operation, under control of XSL Debugger user interface component , a Xalan processor  receives an XML document  and applies an XSL stylesheet  to the XML document  to result in a transformed output document . The visual XSL Debugger  interacts with the Xalan processor  in that the XSL Debugger engine component  receives notification of events from the Xalan processor  as the XSL stylesheet  is applied to the XML document . These events are collected and stored. The stored events are then interpreted by the XSL Debugger engine component . Later, responsive to commands received from a user interacting with the XSL Debugger user interface component , the XSL Debugger engine component  performs a simulation of the application of the XSL stylesheet  to the XML document , where the simulation is based on the stored and interpreted events. During the simulation, the display presented by the XSL Debugger user interface component  is updated appropriately.","The XSL Debugger engine component  also sends instructions to the Xalan processor , for instance, indications of the source XML document  and the XSL stylesheet  to apply to the source XML document . The identities of the source XML document  and the XSL stylesheet  to apply to the source XML document , are sent to the Xalan processor  after having been received by the XSL Debugger engine component  from the XSL Debugger user interface component . Additionally, the transformed output document  may be presented by the XSL Debugger user interface component .","An XSL Debugging system , capable of running the visual XSL Debugger  according to methods exemplary of the present invention, is illustrated in . The XSL Debugging system  includes a display monitor  and a central processing unit . The central processing unit  may include hardware to network with other computers, long term and short term memory and a processor. As is typical, connected to the central processing unit  may be multiple input peripherals such as a keyboard  and a mouse . The XSL Debugging system  may be loaded with a visual debugger for stylesheets for executing methods exemplary of this invention from a software medium  which could be a disk, a tape, a chip or a random access memory containing a file downloaded from a remote source.","An exemplary realization of the XSL Debugger user interface component  is illustrated in  as an XSL Debugger perspective , which may be part of a larger XSL stylesheet development application. The XSL Debugger perspective  is made up of a set of \u201cviews\u201d. Advantageously, within these views, the source XSL stylesheet  and the source XML document  of interest may be displayed side by side, the source XSL stylesheet  in an XSL editor  and the source XML document  of interest in an XML editor . The user may select, e.g., by a double click on a mouse within the XSL editor , a location in the source XSL stylesheet  at which to set a breakpoint.","The set of views facilitate the debugging process. A \u201cSessions\u201d View  shows the debug sessions that are currently active, so that the user may switch among multiple debug sessions. The Sessions View  may also be used to open the new document, formatted in HTML, XML or text, resulting from applying an XSL stylesheet  under test to a source XML document . At the bottom left of the Sessions View  is a tab  that allows the user to replace the Sessions View  with a \u201cNavigator\u201d View. The Navigator View provides a hierarchical view of the resources in the Workbench (a local site where projects with their related documents reside). Beside the tab  for the switch to the Navigator View is a tab  to allow a switch back to the Sessions View . The Sessions view  also includes a number of buttons in the upper left, namely a Trace forward button , a Trace backward button , a Restart Trace button , Run to breakpoint button , a Globe button  and the conventional Close Window button.","A \u201cCurrent XSL Element\u201d View  shows the template currently under evaluation. As shown in , the Current XSL Element View  has column headings for Property, XSL Expression and Actual Value so that the evaluated values of the properties of the template may be displayed. These evaluated properties include XPath expressions such as","substring-after(\/Contact\/PostalAddress\/DeliverTo\/text( ), \u2018 \u2019)","or attribute values such as \u201c@name\u201d. Along the bottom of the Current XSL Element View  are tabs that allow a switch to further views. The further views include a \u201cBreakpoints\u201d View, a \u201cTemplate Call Stacks\u201d View and a \u201cTasks\u201d View. The Breakpoints View is designed to show a list of breakpoints that have been set. The Template Call Stacks View is designed to show the template call stack as a template is entered and exited. Once breakpoints have been set, say, as above, by double clicking within the source XSL, the user can remove breakpoints from the Breakpoints View. The Tasks View is designed to show a list of any errors that occurred during the transformation.","The XSL Debugger engine component  receives and stores the events that are fired from the Xalan processor. For example, consider the following XSL template:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<xsl: template match=\u201cperson\u201d>"]},{"entry":[{},"\u2003\u2003<xsl: param name=\u201clevel\u201d\/> (*)"]},{"entry":[{},"\u2003\u2003. . ."]},{"entry":[{},"<\/xsl:template>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Where a given input XML document has a node that matches \u201cperson\u201d, it is said that a Xalan processor using the XSL stylesheet that includes the above template finds the match and, responsive to finding the match, \u201centers\u201d the above template. When the above template is entered, the Xalan processor fires an event. The XSL Debugger engine component  receives the event, retrieves the template type from the event and evaluates the template within the context of the transformation. For example, the XSL instruction marked with (*) above is an ElemParam object. Evaluating this ElemParam object will return the value for the parameter \u201clevel\u201d that is being passed. The returned value may be displayed in the Current XSL Element View  of the XSL Debugger user interface component .","As will be apparent to a person skilled in the art, there are about a dozen different kinds of XSL instructions (e.g., \u201cfor-each\u201d, \u201cvalue-of\u201d, \u201ccopy-of\u201d, etc.). The XSL Debugger engine component  provides a framework to handle the evaluation of these XSL instructions and to return the appropriate results for rendering in the XSL Debugger user interface component .","To support debugging of an XSL Transformation that invokes external programs written in languages such as Java or JavaScript, a mechanism may be provided wherein a separate virtual machine may be created. Using the separate virtual machine, class paths for the external programs may be set. The Xalan processor may be invoked in the virtual machine environment and the transformation result may be returned to the XSL Debugger user interface component  for displaying to the user.","In operation, the user may use the information in the views of the XSL Debugger user interface component  to debug XML documents and XSL stylesheets. A single application of a given XSL stylesheet to an XML document of interest may yield information prompting the user to make some changes in either the XML document or the XSL stylesheet or both. As a session may be defined by the XML document and the XSL stylesheet or stylesheets applied to the XML document, such changes may be broadly termed \u201cchanges in a session\u201d. After making any changes in a session, the user may right-click the session in the Sessions view  and select \u201cRelaunch\u201d. This action will apply the XSL stylesheet to the XML document again and allow the user to assess the impact of the changes.","Two approaches are contemplated for initiating a session using the present XSL Debugger. In the first approach, the user selects an XSL stylesheet and an XML document of interest, acts to bring up a menu of options and selects an \u201cApply XSL\u201d menu item. In the second approach, the user may use a \u201cXSL Debugging and Transformation wizard\u201d. If the user is simply interested in quickly applying an XSL stylesheet to an XML document to transform the XML document, the user should use the first approach. If, however, the user is interested in providing specific information about the transformation (for example, the location to which to write the transformed output document ), the second approach, using the XSL Debugging and Transformation wizard, may be preferred.","Additionally, if the user is interested in debugging any XSL stylesheets that call external Java programs, again the XSL Debugging and Transformation wizard may be preferred. In the wizard, a \u201cRemote XSL Application\u201d option may be selected so that the user may specify a class path for the external Java program.","As stated hereinbefore, a user of the visual XSL Debugger may apply an XSL stylesheet to an XML document and create a transformed output document, which may be formatted in XML, HTML or text. Notably, an XSL stylesheet should only be applied to an XML document and in an attempt to create an HTML document if the XSL stylesheet to be applied is designed to provide HTML output. Otherwise, an empty or incorrect HTML document may be created.","If the user selects only an XSL stylesheet or an XML document before selecting \u201cApply XSL\u201d from the menu of options, the visual XSL Debugger opens a wizard, prompting the user to retrieve an XML document or an XSL stylesheet, whichever is not selected, from the Workbench or from a remote site using, for instance, the Hyper-Text Transfer Protocol (HTTP). If the XML document or the XSL stylesheet is retrieved from a remote site, the Uniform Resource Identifier (URI) of the XML document or the XSL stylesheet must be specified.","If the XML document is retrieved from a remote site, only an XSL transformation will be run on the retrieved XML document. As the retrieved XML document is not available in the Workbench, the debugger cannot be opened on the retrieved XML document. The retrieved XML document can only be transformed and the results displayed.","To apply an XSL stylesheet to an XML document and create a transformed output document formatted in XML, the user of the visual XSL Debugger performs the following steps. The steps are performed using an \u201cXML perspective\u201d related to the XSL Debugger perspective  of . The purpose of the availability of different perspectives is to adapt the environment of the visual XSL Debugger to the task at hand. The XML perspective and the XSL Debugger perspective  of  are similar in many ways (the toolbar icons for fast access to XML-related wizards are identical). The perspectives differ however in the layout of the views and the views that are visible.","If not already in the XML perspective, the user switches to the XML perspective. In the Navigator view, the user selects an XML document and an XSL stylesheet. By right clicking on one of the selected documents a pop-up menu of options is provided. In the pop-up menu, \u201cApply XSL>As XML\u201d is selected. Responsive to the selection, the XSL Debugger perspective  is opened (see ). Using the Sessions view , the user may step through the application of the selected XSL stylesheet to the selected XML document to perform a transformation resulting in a transformed output document formatted in XML, (\u201cApply XSL>As XML\u201d was selected). To view the transformed output document, the user clicks the Globe button  in the Sessions view .","To apply an XSL stylesheet to an XML document and create a transformed output document formatted in HTML, the above steps are followed, with exception that \u201cApply XSL>As HTML\u201d is selected from the menu rather than \u201cApply XSL>As XML\u201d. Similarly, the above steps are followed to apply an XSL stylesheet to an XML document and create a transformed output document formatted as text, with exception that \u201cApply XSL>As Text\u201d is selected from the menu rather than \u201cApply XSL>As XML\u201d.","The transformed output document formatted as text, HTML or XML is automatically saved to the location from which the XSL stylesheet was selected. In a preferred embodiment, the transformed output document will be named \u201cXMLfilename_XSLfilename_transform\u201d with a suffix dependent on the format of output selected (i.e., \u201c.txt\u201d, \u201c.html\u201d or \u201c.xml\u201d).","If the source XSL stylesheet or the source XML document are changed after the creation of the transformed output document, and the changes are required to be reflected in the transformed output document, the session for the selected XSL stylesheet and XML source documents in the Sessions view  may be right-clicked to bring up a pop-up menu in which may be selected \u201cRelaunch\u201d. As a result of the selection of Relaunch, the source XSL stylesheet and source XML document are reloaded, the transformation is stepped through and the resultant transformed output document is updated as necessary.","As an alternative to the above document-selection approach, a transformation and debugging session may be initiated using an XSL Debugging and Transformation wizard. As above, the method begins with a switch to the XML perspective. The user then uses the XML perspective menu to select File>New>Other>XML>XSL Debug and Transform. The user then selects the XSL stylesheet to be debugged. If the XSL stylesheet is not in the Workbench, the XSL stylesheet may be imported through the use of an \u201cImport Files\u201d menu item. The XML document to be transformed is then selected by the user. If the XML document is not in the Workbench, the XML document may be imported through the use of the \u201cImport Files\u201d menu item. The user then selects a format for the transformed output document to be XML, HTML or text.","If the output format is selected to be XML or HTML, the user may be invited to provide the XML or HTML version number. The user may also be offered an opportunity to select a character encoding set for the output document. When a character encoding set has been selected, the proper name of the character set will be shown in a read-only Internet Assigned Numbers Authority (IANA) field in the transformed output document. An opportunity may then be given to the user to specify the folder and name of the transformed output document.","The user may select \u201cRemote XSL Application\u201d if the XSL stylesheets that are to be debugged call external Java programs. If \u201cRemote XSL Application\u201d is selected, the user may be prompted to provide a class path to the external Java program. The user may then add Java Archive files and class folders as necessary to the class path and close the wizard by clicking \u201cFinish\u201d.","If the XSL stylesheets that are to be debugged do not call external Java programs, the user selects \u201cXSL Application\u201d and closes the wizard by clicking \u201cFinish\u201d.","Responsive to the closing of the wizard, the XSL Debugger perspective  opens. Using the Sessions view , the user may step through the application of the selected XSL stylesheet to the selected XML document to perform a transformation resulting in a transformed output document. To view the transformed output document, the user clicks the Globe button  in the Sessions view .","Stepping Through Files","The Sessions view  displays any sessions that have been run, i.e., any XSL stylesheets have been applied to XML documents. Using the Sessions view , the user may visually step through an XSL transformation script, highlighting the transformation rules as the rules are fired. To step forward, the user may click the Trace forward button . To step backwards, the user may click the Trace backward button . To reset the document, the user may click the Restart Trace button . To run to a breakpoint and stop there, the user may click the Run to breakpoint button . To open the transformed output document (that is, the document formatted in XML, HTML or text resulting from the transformation) in a Web browser, the user clicks the Globe button .","Working in the Template Call Stack View","The Template Call Stack view is designed to show the templates that are currently in the call stack, with the first listed item being the first template called and the last listed item being the most recent (or current) template. When a template is called, the called template is added to the template call stack. When the execution of a template is complete, the competed template is removed from the template call stack.","The Template Call Stack view is divided into four columns titled \u201cName Template\u201d, \u201cMatch Template\u201d, \u201cPriority\u201d and \u201cMode\u201d.","A name template is a template that may be explicitly called in the XSL stylesheet. Any time a name template (that is, <xsl: template: name>) is called, the pattern matched by the name template will show up in the Name Template column.","A match template is a template that searches for an XPath pattern. Any time a match template (that is, <xsl: template: match>) is called, the pattern that the match template must match is listed the Match Template column.","If there is more than one template that could be instantiated for a node, and the XSLT rules give each template the same priority, a priority attribute can be used to force one template to be called ahead of the others. If a given template has the priority attribute set, the value of the priority attribute will appear in the Priority column.","When a template is created, a mode attribute may be specified, where the mode attribute is given a name to describe the mode. Modes allow an element to be processed multiple times, each time producing a different result. If a given template has a mode attribute set, the value of the mode attribute will appear in the Mode column.","Working in the Current XSL Element View","The Current XSL Element view is divided into three columns titled Property, XSL Expression and Actual Value.","The Property column lists any of the attributes associated with the current XSL element.","The XSL Expression column lists the values of the attributes associated with the current XSL element. It also contains the name of the current XSL element.","The Actual Value column contains the actual value of the XML element or attribute, i.e., the value the XML element or attribute receives by being applied to an XML document. If a given value is very long or required to be seen in a separate viewer, the cell containing the given value may be clicked to result in the display of an arrow button, the arrow button may then be clicked to open a dialog that displays the entirety of the given value.","Working in the Breakpoints View","The Breakpoints view is designed to show the current breakpoints set in the input XSL stylesheets. Breakpoints, in the exemplary embodiment, may not be set in the Breakpoints view.","To set a breakpoint for an XSL stylesheet, the stylesheet may be opened in the XSL editor , the cursor may be placed in the line where the breakpoint is required, and Add>Breakpoint may be selected from the pop-up menu. The input XSL stylesheet may automatically have been opened in the XSL editor  when the XSL transformation was run.","A breakpoint may be removed from a document in the Breakpoints view by right clicking the breakpoint and selecting Remove in the resultant pop-up menu.","Defining XSL Stylesheet Preferences","The <xsl: stylesheet> element is the root element of nearly all XSL stylesheets. The <xsl: transform> element may also be used. <xsl: transform> has the exact same meaning and syntax as <xsl: stylesheet>.","To define XSL transformation preferences, the user first switches to the XML perspective. The user then selects Window>Preferences>XML>XSL. Then the user selects the \u201cUse <xsl: stylesheet>\u201d radio button if the user prefers to use <xsl: stylesheet> as the root element of the stylesheet. Alternatively, the user may select the \u201cUse <xsl: transform>\u201d radio button if the user prefers to use <xsl: transform> as root element of the stylesheet. The user may then click \u201cApply\u201d and then \u201cOK\u201d to save the changes. If the preferred root element is changed, the change will not affect any existing XSL stylesheets. The change will only affect XSL stylesheets created after the change is confirmed with clicks on \u201cApply\u201d and \u201cOK\u201d.","Defining XSL Debugging Preferences","To define XSL debugging preferences, the user first switches to the XML perspective. The user then selects Window>Preferences>XML>XSL Debugging.","The \u201cShow All Debugging Files In A Tile Editor\u201d check box may be cleared if it is preferred not to have the source XSL stylesheet and the source XML document \u201ctiled\u201d next to each other. If this check box is selected, the source documents will be displayed together in a single \u201ctile\u201d editor in the XSL Debugger perspective . If the check box is cleared, the source documents will be displayed separately in an XSL editor and an XML editor.","The \u201cRun Transformation And Open A Debugging Session\u201d check box should be cleared if it is preferred that a debugging session is automatically opened any time an XSL transformation is run. After a transformation is run, only the transformed output document will be opened in a Web browser.","The \u201cXSL Remote Application\u201d radio button should be selected if debugging is to be performed on any XSL stylesheets that call external Java programs. This will become the default value in a \u201cSelect XSL Launcher\u201d page within the XSL Debugging and Transformation wizard and the user will be prompted to specify a class path for the external Java program.","If debugging is to be performed on XSL stylesheets that do not call external Java programs, \u201cXSL Application\u201d should be selected. A Context path may be specified for resolving URIs in <xsl: import>, <xsl: include> and document( ) elements. The Context path value will be prepended to the value in the elements so the Context path can be resolved both in the Workbench and the run-time environment.","As described hereinbefore, in the visual XSL Debugger preferences page (Select Window>Preferences>XML>XSL Debugging) a Context path may be specified for resolving URIs in <xsl: import>, <xsl: include> and document( ) elements.","If the XSL stylesheet under test uses the <xsl: import>, <xsl: include> or document( ) function to reference other stylesheets or documents, the reference to the other stylesheets or documents should be formatted with an awareness of the default URI resolution mechanism. The default URI resolution mechanism may, for instance, be based on a relative path. In which case, the user of the visual XSL Debugger should format a pointer such that the pointer indicates a file location of the referenced stylesheet or document relative to the file location of the XSL stylesheet containing the reference.","For example, consider a directory structure wherein XSL stylesheets named \u201cFirst.xsl\u201d and \u201cSecond.xsl\u201d are stored in a directory called \u201cProject1\u201d and an XSL stylesheet named \u201cThird.xsl\u201d is stored in a subdirectory of Project1 called \u201cCommon\u201d. If it is required that First.xsl references Second.xsl and Third.xsl, import statements such as the following should be used: <xsl: import href=\u201cSecond.xsl\u201d\/>; <xsl: import href=\u201cCommon\/Third.xsl\u201d\/>. The default URI resolution mechanism will resolve the Second.xsl and Third.xsl file relative to the First.xsl file by appending the href attribute value (for example, Second.xsl) to the file location of First.xsl.","Sometimes, this resolution mechanism is not enough. For example, it may be required to set up stylesheets so the stylesheets will work in a given run-time environment in addition to working in the Workbench. Where an import statement such as <xsl: import href=\u201c\/MyWebProject\/xsl\/MyFile.xsl\u201d\/>(note the leading \u201c\/\u201d in the href attribute) is used, the default URI resolution mechanism may not work properly. The default URI resolution mechanism is designed to resolve this URI relative to the current drive. That is, the default URI resolution mechanism will resolve the import statement to something like C:\/MyWebProject\/xsl\/MyFile.xsl, which may not be the actual location of MyFile.xsl.","The ability to define a Context path enables work with such a stylesheet in the Workbench without having to modify the stylesheet. In the Context path field, the user may specify a directory path to be prepended to the href attribute value during URI resolution. For example, assuming the location for MyFile.xsl is \u201cC:\/eclipse\/workspace\/MyWebProject\/xsl\/MyFile.xsl\u201d, the Context path may be defined as \u201cC:\/eclipse\/workspace\u201d.","As discussed in conjunction with the description of the Sessions View  hereinbefore, the visual debugger for stylesheets of the present invention has the ability to support multiple debugging sessions. An extension of this ability allows the debugging of stylesheets that include or import other stylesheets. Any \u201csupplementary\u201d stylesheets included by, or imported into, a given \u201cmain\u201d stylesheet that has been opened in the visual XSL Debugger may be opened in supplementary debugging sessions. The current context of each of the supplementary stylesheets may be maintained by the visual XSL Debugger while the main stylesheet is applied to a given XML document. As the supplementary debugging sessions behave as any other debugging session, the user may step through the supplementary stylesheets as described hereinbefore.","In addition to support for stylesheets including other stylesheets, the visual XSL Debugger may provide support for XML documents that include stylesheets. In particular, the \u201c?xml-stylesheet\u201d processing instruction may be used in a given XML document to include a stylesheet. Upon encountering such an instruction, the visual XSL Debugger processes the instruction, locates the stylesheet and continues as usual.","Consider an example wherein a user is creating a stylesheet to result in a display of data found in an xml file  called familyTree.xml (see ) in HTML format.","An initial attempt is illustrated in  as an xsl file  called familyTree.xsl. However, when familyTree.xsl  is run against familyTree.xml , the resultant HTML page is empty. The problem may be that the person template (the code that starts with <xsl:template match=\u201cperson\u201d>) is not called or fired. Alternatively, the problem may lie in the recursion within the person template itself (note that the person template calls itself within the body of the template). Further, the problem could be in the XPath expression that is used to display a person's name. In the instruction <xsl:value-of select=\u201cname\u201d\/>, the portion within quotes is the XPath expression. The visual Debugger for stylesheets disclosed herein may be used by the user to assist in debugging familyTree.xsl .","In particular, the user may launch the visual Debugger within an Application Developer Workbench environment by right clicking an indication of the familyTree.xml document in the Navigator view and selecting \u201cApply XSL>As HTML\u201d from the pop-up menu. Note that the user does not have to explicitly select the stylesheet because familyTree.xml uses the \u201c?xml-stylesheet\u201d processing instruction to include familyTree.xsl. The menu selection leads to familyTree.xsl  being opened in an XSL editor window  () and familyTree.xml  being opened in an XML editor window.","Once the visual Debugger has been launched with familyTree.xsl  and familyTree.xml , the Xalan processor  () is instructed by the XSL Debugger engine component  to apply familyTree.xsl  to familyTree.xml . While applying farmilyTree.xsl  to familyTree.xml , the Xalan processor  fires multiple events. These events are collected and interpreted by the XSL Debugger engine component  so the application of familyTree.xsl  to familyTree.xml  may be simulated for the benefit of the user.","To identify the problem, the user may set a breakpoint on the <xsl: value-of select=\u201cname\u201d\/> instruction within the person template. The user accomplishes this breakpoint setting by double clicking in the margin of the XSL editor window  directly in line with the corresponding instruction. The user can then click the Run to breakpoint button  in the Sessions view  (). The simulation of the application of familyTree.xsl  to familyTree.xml  is performed by the XSL Debugger engine component  and stopped at the specified breakpoint. Thus, it is confirmed that the person template does get called.","To eliminate recursion as the problem, the user may open the Template Call Stack view by selecting the appropriate tab in the upper right hand view (shown as Current XSL Element View  in ). The user may then continue to click the Run to breakpoint button to allow the XSL Debugger engine component  to continue performing the simulation. By carefully monitoring the Template Call Stack view while the simulation is performed, the user may verify that the call stack adds and removes the person template appropriately. An exemplary Template Call Stack view  is illustrated in . Once recursion has been removed as the potential problem in this way, an incorrect XPath expression is left as the likely problem area.","The user may test or modify the XPath expression by editing familyTree.xsl . The problem may, for instance, be that the expression \u201cname\u201d is attempting to access an attribute and not an element in the xml document, so there is a missing \u201c@\u201d. After editing the stylesheet, the changes may be saved by the user by way of a right click inside the xsl editor and the selection of save from the resulting menu. In the Sessions view, the user may right click and select Relaunch from the resulting pop-up menu options to update the transformation with the changes. Responsive to the relaunch, the Xalan processor  is instructed by the XSL Debugger engine component  to apply the edited version of familyTree.xsl to familyTree.xml . As before, while performing the transformation, the Xalan processor  fires events that are collected and interpreted by the XSL Debugger engine component . Additionally, the Xalan processor  generates a newly transformed output document. The user may then click the Globe button  in the Session view to open the newly transformed output document in a Web browser to verify that the changes indeed solved the problem.","As will be apparent to a person skilled in the art, the XSL Debugger engine component  need not necessarily collect and store the events for use in performing a simulation of the application of the selected stylesheet to the selected source file. Instead, if the application programming interface of the stylesheet processor allows, instructions related to the wishes expressed by the user via the XSL Debugger user interface component  may be directly sent to the stylesheet processor and the display updated responsive to reception of each event from the stylesheet processor.","Advantageously, such a visual debugger for stylesheets as disclosed herein provides much needed assistance to those debugging stylesheets that are under development.","Other modifications will be apparent to those skilled in the art and, therefore, the invention is defined in the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the figures which illustrate example embodiments of this invention:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
