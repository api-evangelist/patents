---
title: Method and computer system for software tuning
abstract: Method and computer system for software tuning. A computer system stores variables () for storing at least one threshold value for at least one parameter (P) influencing the performance of a software application () with regards to a specific task. A threshold evaluator () compares () the at least one threshold value to at least one corresponding current value allowing the software application () to select () an algorithm (A) from a plurality of algorithms (A to AN) for performing the task in accordance with the result of comparison.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08074206&OS=08074206&RS=08074206
owner: SAP AG
number: 08074206
owner_city: Walldorf
owner_country: DE
publication_date: 20040707
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CLAIM OF PRIORITY","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is a U.S. National Stage Filing under 35 U.S.C. 371 from International Patent Application No. PCT\/EP2004\/051381, filed on Jul. 7, 2004, and published as WO 2005\/005214 A1 on Jan. 20, 2005, which claims priority under 35 U.S.C. \u00a7119(a)-(d) or 365(b) from European Patent Office Patent Application No. EP20030153662, Publication No. 1 496 450 A1, filed Jul. 8, 2003, the entire content of each of the applications is incorporated herein by reference.","The present invention generally relates to electronic data processing, and more particularly, relates to methods, computer program products and systems for software tuning.","Some software products (e.g., application systems, database systems, etc.) include parameter profiles that can be set by specialists to achieve an optimal performance of the software product in a given environment of a computer system. The environment is determined, for example, by the used hardware, operating system, network data transfer speed, and many other factors. There are cases where the specialist has to use a try and error procedure to determine the parameters where the software product performs best in the given environment. Typically, the parameters are part of a static configuration of the software product that is defined once.","In the publication \u201cStatistical Models for Automatic Performance Tuning\u201d by Richard Vuduc et al., automatic tuning systems are proposed that are based on search-based systems. The paper discloses a heuristic for stopping an exhaustive compile-time search early if a near-optimal implementation is found. Further, it shows how to construct run-time decision rules, based on run-time inputs, for selecting from among a subset of the best implementations. Complex statistical techniques are used to exploit a large amount of performance data collected during a search. The run-time decision rules can be costly so that the compile-time search may be preferable.","One embodiment of the invention provides a simple mechanism for enabling a computer program that runs on a computer system to tune itself without human interaction for achieving optimal system performance in a given environment at runtime. An advantage of this embodiment is that simple comparisons with threshold values are used for the selection of the most suitable algorithm for a specific task instead of complex statistical techniques. A further advantage lies in the ability to handle more-dimensional dependencies of the performance of alternative algorithms for performing the task.","Another embodiment provides a mechanism to enable the computer program to dynamically adjust tuning parameters at runtime when the environment changes. This embodiment allows the software application to recalculate threshold values of multiple dimensions based on the actual performance of the alternative algorithms. If appropriate, the software application can use the recalculated threshold values for future algorithm selection.","In another embodiment of the invention a data storage system automatically switches between multiple data retrieval algorithms. This embodiment provides a fast data retrieval mechanism in the presence of more than one parameter influencing the performance of the data retrieval.","The aspects of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the appended claims. Also, the described combination of the features of the invention is not be understood as a limitation, and all the features can be combined in other constellations without departing from the spirit of the invention. It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention as described.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","b":["200","990","200","210","2","210","1"]},"The parameter variables  store information about the parameters that can be used to influence the performance of the software application  with regards to a specific task. The parameter variables P to Pn will also be referred to as variables. The software application implements various algorithms A to AN for performing the specific task in different ways. Further algorithms used for different tasks may be implemented in the software application. For example, specific tasks can be sorting data, retrieving data, filtering data or any other operation performed on data that may depend on a parameter that has influence on the performance of the specific task. For example, threshold values that can influence the performance can be either hardware related parameters (e.g., the number of processors in the computer system, the available main memory of the computer system) or software related parameters (e.g., the main memory allocated to the software application, the size of the data volume, the number of hits of a query, or any other parameter value, that can influence the performance of the software application). Software related parameters can easily be modified by the software application itself, whereas hardware related parameter modification in general requires human interaction (e.g., adding an additional blade in a blade server) in many cases.","The software application further implements a threshold evaluator  and a threshold calculator .","In a first step the threshold calculator  is used to calculate  one or more threshold values of the first parameter that relates to the specific task. Details are explained under . The calculated one or more threshold values are stored  in corresponding variables (e.g., variable P). In one alternative, multiple threshold values of the parameter are stored in one variable (vector variable). In another alternative, for each threshold value a corresponding variable is used.","The software application generates current values with respect to the parameters. For example, for performing a sort function for data in a list, the current value can correspond to the length of the list. A threshold value in the first variable P indicates that for a current value below the threshold value the best system performance is achieved when using a first algorithm (e.g., A) and for a current value above the threshold value the best system performance is achieved when using a second algorithm (e.g., A). In other words, each algorithm covers a corresponding value range where the use of the algorithm provides the best system performance. That is, the one or more threshold values separate the value range of the first parameter P into at least two intervals.","The threshold evaluator  uses  the one or more threshold values P when comparing  the current value with the one or more threshold values to determine the appropriate algorithm for performing the specific task with optimal performance. In the example, the first algorithm A is selected  from the plurality of algorithms A, A, AN for performing the specific task. The selection is in accordance with the result of the comparing step . For example, the first algorithm A is assigned to the interval that includes the current value. A is determined but any other algorithm A to AN might be selected (dashed arrows). This depends on the interval where the current value belongs to.","Once the specific task has been performed, the actual performance of the selected first algorithm A can be measured  and a check is performed  whether the measured performance complies with the one or more threshold values, that is, whether the assignment of the selected algorithm to the interval including the current value delivers the best performance within the plurality of algorithms.","The threshold calculator  uses the performance measure and, in case the performance measure does not comply with the current setting of the one or more threshold values for the first parameter P, recalculates  the one or more threshold values for the first parameter P. The one or more recalculated threshold values are then used to update  the corresponding variables .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2","b":"200"},"For this reason, an embodiment of the invention can be used to reduce the number of profile parameters that have to be manually set to a necessary minimum. Specialists working from outside the software may tune only parameters that depend on a specific use case or business scenario, where pre-tuning of the software is difficult. For example, consider the pre-tuning of relational database management systems, and in particular deciding in advance which indexes to create, which depends on the final structure of the various tables in the database system.","In this embodiment of the invention, the software itself can tune scenario-independent parameters, such as the threshold values for the various algorithms A to An. The initial values may be set during start-up of the software by running predefined test cases for the various algorithms.","The example of  illustrates the automatic determination (initial calculation , cf. ) of a threshold value with regards to two algorithms A (illustrated by bullet points) and A (illustrated by circles). In the example, a parameter p is tuned to a series of discrete values between a pair of chosen extreme values. The spacing of values between the extremes need not be very fine and can be equidistant. For each value p(x), a measurement is made of the performance difference D(p(x)) (defined as runtime difference or any other suitable measure) between the two algorithms. For example, the difference may be defined as D(p(x))=PA(p(x))\u2212PA(p(x)). For each difference D(p(x)), either a single measurement is made or the average of several runs can be taken.","Below the threshold value, the performance of algorithm A decreases steadily with increasing value p(x) whereas the performance of algorithm A increases. So the magnitude of the performance difference D(p(x)) between the algorithms decreases but always has the same sign. For example, if D(p(x))=PA(p(x))\u2212PA(p(x)), then the difference is positive as long as algorithm A has a better performance than algorithm A.","The measured performance difference D(p(a)) for value p(a) is the last positive difference, so p(a) is the greatest value of p such that D(p)>0. From value p(b) onward, the difference is negative, so p(b) is the least value of p such that D(p)<0. The threshold value lies in the interval between values p(a) and p(b).","An iteration, for example based on an interval bisection procedure, can be used to locate the threshold value within the interval [p(a), p(b)].","For the first step of the iteration, the value p(a) is the left interval border, p(b) is the right interval border and p(c)=[p(b)\u2212p(a)]\/2 is the middle of the interval. A new measurement D(p(c)) of the performance difference between the two algorithms is made for value p(c).","If the difference is positive, D(p(c))>0, then the threshold value lies in the right half-interval [p(c), p(b)].","If the difference is negative, D(p(c))<0, then the threshold value lies in the left half-interval [p(a), p(c)].","If the difference is zero, D(p(c))=0, then the threshold value is determined exactly by the parameter value p(c) and the iteration is complete.","If the difference is greater than a predefined delta, the iteration continues. The half-interval containing the threshold value is subdivided into two smaller half-intervals (which are either [p(c), p(d)] and [p(d), p(b)] or [p(a), p(d)] and [p(d), p(c)], depending on whether D(p(c)) is positive or negative) and the performance difference D(p(d)) is evaluated for the value p(d), and so on, as above.","The procedure stops as soon as the threshold value has been identified with sufficient precision. This may depend on:","The size of the measured difference D(p), for example, whether D(p)<delta, for some predefined minimal difference delta.","The type of the parameter, for example, whether p(x) is of type integer or floating point.","In this way, this embodiment of the invention can calculate initial values for all threshold values during start-up.","This start-up calculation can last for several milliseconds or even seconds before the software is up and running.","However, the software tunes itself automatically and optimally on the given environment (e.g., given hardware, operating system). It can be expected to do so more quickly, more exactly, and more inexpensively than a specialist could tune the software by manually setting profile parameters.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 3","FIG. 1"],"b":["200","1"]},"Assuming that the initial threshold values are correct at start-up and for some time after start-up, in the course of time, this situation may change, for example, because of memory fragmentation or accumulating memory leaks due to bugs in the coding or other reasons. Therefore, after a certain time the software can run under conditions that differ from those that prevailed immediately after start-up.","The performance of any of the algorithms A to AN may degrade or improve by different amounts relative to the other algorithms. Therefore, the corresponding threshold values may shift in the course of time.","This embodiment of the invention can automatically and regularly repeat its determination of its threshold values, as specified in the above calculation (cf. ), so as to adjust the threshold values used to switch algorithms dynamically during runtime.","To revise its determination of threshold values, the software application  makes automatic performance measurements  (cf. ), for example, by using an appropriate time measuring component. For example, the measurements can simply be records of the time taken for certain tasks to run. The measurements can be made either on an ongoing basis or from time to time.","When using ongoing performance measurements, the software application  measures the performance of each execution of an algorithm.","If the current execution of algorithm A corresponds to a current value p(x) that is below the threshold value B, the performance PA(p(x)) of algorithm A should in general be better than its performance at the corresponding threshold value B, since this is the reason why the software  executes algorithm A instead of algorithm A (see ).","At the threshold value B, the performance of algorithm A is by definition the same as that of algorithm A, that is, PA(B)=PA(B).","In , for the algorithm An (1<n<N) chosen in the interval between the two neighbouring threshold values B(n\u22121) and Bn, the performance PAn(pc) of the algorithm An at the value pc (in the interval) should be either the same as or better than its performance PAn(B(n\u22121)) and PAn(Bn) at the upper and lower threshold values B(n) and B(n\u22121).","If the performance PAn(pc) of algorithm An (middle arrow) is below its performance PAn(B(n\u22121)) (left arrow) or PAn(Bn) (right arrow) at a neighbouring threshold value (either B(n\u22121) or Bn, respectively), then it is no longer advantageous to choose the algorithm An at the value pc. As a consequence, the checking step  (cf. ) concludes that the measured performance for the algorithm does not comply with the current setting of threshold values.","Therefore, in future, at parameter value pc, the software application chooses an algorithm that was earlier measured as performing better in the neighbouring interval, which is either algorithm A(n\u22121) or A(n+1). This choice is equivalent to moving the threshold value B(n\u22121) or Bn, respectively, to a new position at value pc, which corresponds to the recalculating step  (cf. ).","However, when algorithm A(n\u22121) or A(n+1) is next run at parameter value pc, it may be the case that the newly measured performance of the algorithm is also reduced, possibly even more so than the performance of the original algorithm An. In this case, the threshold value B(n\u22121) or Bn, respectively, should not have been moved to the new position pc.","This situation may occur in practice because any reasons for the reduced performance of algorithm An may also apply to reduce the performance of algorithm A(n\u22121) or A(n+1).","Therefore, a situation like this can trigger a recalculation of all the threshold values, either immediately or as soon as practically possible, for example, when the system load is sufficiently low. Alternatively, the software can generate a system message to warn an administrator that the latest performance measurements indicate the need for a recalculation of the threshold values.","When using performance measurements from time to time, the software recalculates  the threshold values preferably at times of low system load, in the same way that it does during start-up for the initial calculation  (cf. ). This recalculation may be defined as part of a bundle of housekeeping tasks that are performed at regular time intervals by the software. In this case, the threshold values are adjusted with a lower frequency than when using the ongoing basis alternative.","Removing as many manually set profile parameters as possible from a profile file and letting the software itself tune such parameters instead of a specialist can lead to an improved performance over the full range of parameter values.","However, in certain exceptional and rare situations, there may be good reasons why such parameters should not be tuned by the software but from outside by a specialist.","These exceptional cases can be handled as follows. By default, profile parameters that are tuned by the software itself do not appear in the profile file. However, if an expert explicitly sets a parameter threshold value by entering it in the profile file, then the software does not change the threshold value of this parameter.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 4","FIG. 3"]},"In the example, for each value of the first parameter p, two algorithms are available. In general, any number of algorithms can be available for each value of one dimension. For example, for the value pc the algorithms An and A\u2032n can be used in the first dimension interval [B(n\u22121),B(n)] to achieve optimal performance regarding the first parameter p. Each algorithm is represented by a corresponding rectangle in the drawing to reflect the coverage of the two dimensions. However, which of the two algorithms provides the best performance depends also on the second dimension. If the value of p\u2032 is in the second dimension interval [B\u2032(n\u22121), B\u2032(n)], then the algorithm An is selected by the software application. If the value of p\u2032 is in the second dimension interval [B\u2032(n), B\u2032(n+1)], then the algorithm A\u2032n is selected. That is, in the case of multidimensional performance dependencies the threshold evaluator compares a plurality of current values of various dimensions to a plurality of corresponding threshold values and selects the appropriate algorithm for the specific task that provides the best performance for the current combination of current values in the various dimensions.","The threshold calculator can initialise the threshold values of various dimensions by using the initialising procedure described under  for one dimension while values of the further dimensions are kept constant during the performance measurement.","In the following, an example for the software application  is a database management software of a data (storage) system that can be used together with an embodiment of the invention. The data system may be implemented according to a relational database model. However, the system is not limited to use within the constraints of a known relational database architecture. The elements of the data system roughly translate to the known nomenclature of the relational database theory as follows (with the definitions used with an embodiment of the invention on the left):",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"InfoSystem",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00001","he":"2.46mm","wi":"2.12mm","file":"US08074206-20111206-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Management System"]},{"entry":[{},"InfoArea",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00002","he":"2.46mm","wi":"2.12mm","file":"US08074206-20111206-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Database"]},{"entry":[{},"InfoCluster",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00003","he":"2.46mm","wi":"2.12mm","file":"US08074206-20111206-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Table"]},{"entry":[{},"InfoType",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00004","he":"2.46mm","wi":"2.12mm","file":"US08074206-20111206-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Attribute"]},{"entry":[{},"InfoCourse",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00005","he":"2.46mm","wi":"2.12mm","file":"US08074206-20111206-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Data record"]},{"entry":[{},"InfoCell",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00006","he":"2.46mm","wi":"2.12mm","file":"US08074206-20111206-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Field"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{},{},{},{}]},{"@attributes":{"id":"p-0079","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<","(less than)"]},{"entry":["<=","(less than or equal to)"]},{"entry":[">","(greater than)"]},{"entry":[">=","(greater than or equal to)"]},{"entry":["=","(equal to)"]},{"entry":["<>","(not equal to)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{},{}],"figref":"FIG. 5","b":["990","990","901","902","999"]},"For example, the second computing device  may be a backend system, such as a database system, a file system or an application system, that stores data. The data can also be stored anywhere inside or outside of the computer system .","The first computing device  may be used to compose Boolean expressions  to be used in a QUERY for retrieving selected data from the second computing device . For example, the first computing device  may be a front end computer that provides a graphical user interface (GUI) to a user.","There can be various ways in which the data storage system  receives the QUERY, dependent on the interfaces offered for the data storage system . For example, in case of using an SAP R\/3 based system, the SAP Remote Function Call (RFC) functionality provided by the ABAP kernel can be used. An application programming interface (API) can be implemented as a collection of ABAP Function Modules. The API uses the RFC functionality to communicate remotely with the data storage system. An SAP R\/3 based application uses the API for receiving parameters that are passed to the data storage system . The corresponding results are then returned as ABAP parameters. A selection query is filled into an internal table in ABAP and can be rapidly processed by the data storage system since the query is already pre-structured.","In general, any interface or meta format can be used to post a Query to the data storage system. A pre-structured query is useful but not necessary. The query may also be coded in XML or simply be passed to the data storage system as a string that has to be parsed within the data storage system.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIGS. 5 to 11","b":["902","902","500","501","502"]},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 6","b":"902"},"Each InfoArea is connected via a linking element (again an anchor as described hereinafter) to an InfoCluster. In turn, each InfoCluster is connected to at least one InfoCourse and at least one InfoType, through respective linking elements, such as anchors. The InfoType can be seen as an attribute of a table; an InfoCourse starts always in an InfoCluster. If an InfoCourse stays within an InfoCluster with its addressed InfoCell elements corresponding to fields of a table, then the InfoCourse is similar to a record of a table, such as a relational database table.","Under the InfoCourse and the InfoType the InfoCell is found; this is the element on the lowest level in the hierarchical structure. On the creation of an InfoType an anchor is created that is an InfoCell also. This anchor has the function to represent the structure of following InfoCell elements.","For the implementation of the levels below the InfoArea level, i.e. the InfoCluster, the InfoCourse, the InfoType, and the InfoCell levels, use is made of a data element according to the invention as shown in . In this example, the data element is shown schematically as an anchor, and is provided with a number of pointers. The pointers of the first pair are labelled LVR and RVR (Left Vertical Ring, respectively Right Vertical Ring), the pointers of the second pair are labelled LHR and RHR (Left Horizontal Ring, respectively Right Horizontal Ring), the pointers of the third pair are labelled LSR and RSR (Left Self Ring, respectively Right Self Ring), and the single pointer is labelled IF (InFormation bridge). Note that the pointers LSR, RSR and IF are in principle optional.","Further pointers my be used. In the initial state, as shown in , all pointers point to the anchor. This initial state is also the simplest of possible ring structures. Every pointer in the structure has a valid address, and cases of a non defined pointer (nil pointer) are avoided.","In the following, example data is used as shown in table A of . The table includes data regarding first names, ages and weights. For this table an InfoCluster is generated. Furthermore, three InfoTypes are generated to represent respectively first names, ages, and weights.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 8","FIG. 8"]},"As described above, the InfoCell is provided with a LVR\/RVR pointer pair. As shown in , the RVR pointer of the InfoCell points towards the anchor, and also the LVR pointer points to the anchor. As a result, the ring configuration of the anchor is maintained.",{"@attributes":{"id":"h-0007","num":"0000"},"figref":"FIG. 9"},"The order in which the InfoCells are organized depends on their value. In case of a smaller value, the InfoCell is ordered in on the LVR side, otherwise on the RVR side. This practise is well known in the art as binary tree building. Preferably, the binary trees are organized as balanced or AVL trees, methods which are well known in the art. These kinds of trees minimise the number of levels within the tree structure, so as to minimize access time. Preferably, all tree structures within the data system are dynamically balanced in use, so as to guarantee optimum access times.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 10"},"To complete the implementation of the table, the relations between the InfoType have to be made. To this end an InfoCourse is introduced.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 11","FIG. 12"],"br":{}},"When five million records with 100 attributes (e.g., 100 columns of a relational database table) are loaded into the data storage system , then five million InfoCourse trees (InfoCourses) exist, one for each record. Each InfoCourse includes 100 nodes. Each InfoCourse has a corresponding InfoCourse anchor pointing to the respective InfoCourse. In other words, when loading five million records into the data storage system  then also five million InfoCourse anchors exist.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIGS. 13 to 15","FIG. 16","FIGS. 17 to 19","FIG. 13","FIGS. 2 to 8"],"br":{},"b":["902","902","300","301","302","303","310","311","312","313"]},"Once the Boolean expression is received by the data storage system , a parser decomposes the Boolean expression  into the first portion  and the second portion . If further portions are included they are also subject to decomposition. Each portion includes at least one condition that has to be fulfilled by any InfoCourse that is selected by the original query. The conditions relate to InfoTypes.","The data storage system  then determines a result set for each portion. In the example, a first result set  includes result flags (C-FLAG) in compliance with the first portion  and a second result set  includes further result flags (C-FLAG) in compliance with the second portion . A result flag is used to indicate whether a specific InfoCourse fulfils a condition in a corresponding portion. Each result flag relates (bold up-arrows) to a result identification number ,  of the corresponding result set , , where it belongs to. The result flags within a result set are also interrelated (dashed arrows). Further, each result flag relates (bold left-arrows) to the corresponding InfoCourse anchor (IC-anchor) , , ,  of the InfoCourse fulfilling the corresponding condition.","The two result sets ,  can originate from the evaluation of a complex Boolean expression, where the first result set  can be the result of one bracket including potentially any Boolean sub-expression as sub-query. The same is true for the second result set , e.g. representing another bracket of the Boolean expression.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIGS. 13 and 14","FIG. 16","FIGS. 17 to 19","FIG. 14"],"b":["361","362","363","500"],"br":{}},"For the combination, the InfoCourses or the IC-anchors are not needed anymore. The number of result flags in each result set is known by, for example, incrementing a corresponding counter when creating the result flags.","In one implementation, the data storage system runs through one of the result sets from the first to the last result flag. Advantageously, the result set including the lowest number of result flags is chosen because of a shorter processing time, which becomes more relevant in the case of Boolean AND combinations. The first result set  includes three result flags (C-FLAG) and the second result  set includes two result flags (C-FLAG). Therefore, the data storage system starts with the second result set  and then processes the first result set . In one implementation, for each IC-anchor where a result flag C-FLAG or C-FLAG relates to, a corresponding result flag R-FLAG is generated in the third result set  with having result identification number .","In another implementation, one can use also the first or second result set for storing the result of the Boolean OR operation.","For example, when running through the second result set , each C-FLAG can be \u201crenamed\u201d into C-FLAG. The result ID  of the second result set is set to the result ID  of the first result set.","Further, it is checked whether a corresponding C-FLAG result flag exists. If not, the data storage system proceeds with the next C-FLAG in the second result set . If a corresponding C-FLAG exists, then one of these two result flags, either in the first or in the second result set, is deleted to avoid intersections.","To find out, whether a corresponding C-FLAG exists in the first result set , for example, the data storage system moves along a circular structure that is used to relate the result flags to their corresponding IC-anchor.","After having processed all result flags of the first and second result sets, only C-FLAG result flags remain. The combination with OR means to link the two result sets together to one result set. In this example, in the end, all result flags have the result ID  of the first result set . During the above described procedure the Counters for the number of result flags in each result set are continuously updated (e.g., decremented when result flags are deleted). Therefore, the number of result flags in the \u201cfinal\u201d result set is the sum of the counters of the first and second result sets just prior to lining them together. This count result can be reported to an application as the number of InfoCourses (records) matching the first portion  or the second portion  of the Boolean expression .","The \u201cfinal\u201d result set may represent a real final result set or an intermediate result when the Boolean expression  includes further portions. In this case, it is combined again with further result sets that correspond to the further portions. A complex query consisting of several nested sub-queries may be evaluated recursively by combining the result sets of sub-queries with the result sets of other sub-queries. This continues until all levels of the Boolean expression are resolved. At the end, a single result set (e.g., result set ) is left. Its number of result flags corresponds to the number of hits for the whole query (Boolean expression ).","In the example of , the Boolean expression  combines the first and second result sets with a Boolean AND operator.","Again, the data storage system knows the number of result flags in each result set from the corresponding result counters and starts with processing the result set with the lowest number of result flags. This is advantageous in the case of Boolean AND combinations because the total number of result flags can only be as large as the smallest result set. In the example of  the second result set  is the smaller one.","For each IC-anchor, where a result flag C-FLAG and also a result flag C-FLAG relate to, a corresponding result flag R-FLAG is generated in the third result set .","In one implementation, one can use also the first or second result set for storing the result of the Boolean AND operation.","For each result flag C-FLAG of the second result set , the data storage system checks whether a corresponding result flag C-FLAG exists in the first result set . If so, the result flag C-FLAG is the data storage system proceeds with the next result flag of the second result set. If no corresponding result flag C-FLAG is found in the first result set, then the result flag C-FLAG in the second result set  is deleted.","At the end of this filtering procedure, the second result set  includes the \u201cfinal\u201d result set and, therefore, plays the role of the third result set . The first result set  is not needed any more and can be deleted.","Again, with each deletion of a result flag, the corresponding counter is reduced accordingly. Therefore, the counter of the second result set always contains the current number of result flags C-FLAG, which, at the end of the filtering procedure, corresponds to the number of hits for the query and may be reported to an Application.","As in the Boolean OR case, the \u201cfinal\u201d result set may represent a real final result set or an intermediate result when the Boolean expression  includes further portions that are subject to further combinations.",{"@attributes":{"id":"h-0009","num":"0000"},"figref":"FIG. 16","b":["1","2"]},"In this first implementation, the data storage system instantiates an instance (C-FLAG, C-FLAG) of a result flag class for each result flag. Multiple result flags for one InfoCourse  (record) are connected in a ring structure . The ring structure  relates ,  to the corresponding IC-anchor . Advantageously, a docket element (D-FLAG) is used. The docket element represents a counterpart of the IC-anchor  on the side of the result flags. One advantage is that the docket element is decoupled from the IC-anchor in the sense that it is derived from a different class than the IC-anchor. Therefore, it can provide different functions than the IC-anchor. These functions can be used by the other result flags because the docket element is instantiated from the same class as the result flags. The decoupling allows instances from the result flag class to consume less memory than a corresponding IC-anchor that has, for example, more pointers, additional administrative information (e.g., number of elements in a substructure), methods that operate on attributes, such as \u201csort elements\u201d or \u201cbalance tree\u201d, etc. The docket element D-FLAG has a docket pointer  pointing at the corresponding IC-anchor , whereas the IC-anchor  has an anchor pointer  pointing at the corresponding docket element. Using the ring structure  the data storage system can quickly identify any result flag related to a specific IC-anchor.","To summarize, each InfoCourse has one IC-anchor that relates to a corresponding docket element. That is, an InfoCourse (record)  is represented by an IC-anchor  and the corresponding docket element D-FLAG. The docket element is the docking point for the result flags C-FLAG, C-FLAG. A result flag semantically plays the role of a dynamic flag. If a result flag is connected to a docket element, the InfoCourse, which is represented by the docket element, has been selected. That is, it fulfils one ore more conditions of the original query.","Multiple result flags that relate to different IC-anchors may be linked together in a pointer list by means of pointers (e.g., pUp and pDown). This is also valid for the docket elements, since technically speaking they are also instances of the result flag class. A linear list of result flags is called a result set. Each result set is identified by a result ID. A result set flags a subset of InfoCourses that comply with at least portion of the Boolean expression  in the query.","In the example, the first result set  is implemented by the first pointer list PL- that includes the result flag pointers C-FLAG and has the result ID . The second result set  is implemented by the second pointer list PL- that includes the result flag pointers C-FLAG and has the result ID . The docking elements formally are also linked in a pointer list PL-D having its own result ID .","Several result sets may exist simultaneously. On the level of a docket element D-FLAG, the result flags can be linked in the circular structure  using pointers, such as pointer pSmallId and pointer pLargeId. The pointer names indicate that the result flags in the circular structure  can be sorted by result ID. The circular structure  can be run through in both directions, e.g. to find the result flag of a particular result set. Sorting the result flags in the circular structure  by result ID helps to decide in which direction the circular structure should be searched for a fast identification of a certain result ID.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIGS. 13 and 14"},"The number of hits as well as some or all of the InfoCourses that match the query may be returned to an application. As an example, assume that 20.000 InfoCourses are found. That is, the final result set contains 20.000 result flags. If an application requests the next 20 InfoCourses after the 5.390th InfoCourse from the data storage system, then the request can be satisfied by using the final result set. The result flag 5.390 (offset) is located by running down the final result set and counting the result flags until the offset result flag at position 5.390 is reached. The next 20 InfoCourses are read from the corresponding tree structures (e.g., by using the IC-anchors that relate to the corresponding docket elements). The retrieved values may be serialized, for example, into a Send-Buffer-Structure or any other kind of appropriate communication data structure. Any type of transport format and\/or rearrangement, concatenation, etc. of data may be used for the Send-Buffer-Structure (e.g., the use of fixed lengths). Preferably, the application knows the data format provided by the data storage system to ensure stable communication.","For a fast localisation of a specific InfoCourse (e.g., number 5.390) it is useful to subdivide a result set into Intervals. One can use an interval pointer which points to the result flag in the middle of the result set (e.g., result flag 10.000 of 20.000) or to any other sub-interval of the result set, such as quarters. According to the offset requested by the application the data storage system can jump to the nearest interval pointer and then sequentially run through only a part of the result set (e.g., upwards or downwards) and count until the requested result flag (e.g., docket element D-FLAG) has been reached. It is useful to choose the direction having the shortest distance to the requested offset position. For example, assume that there are 20.000 result flags in the result set. If InfoCourse 15.390 is requested as an offset and no interval pointers are available, then it is advantageous to start at the bottom of the result set (result flag 20.000) and run through 20.000\u221215.390+1=4.611 result flags instead of starting at the top and run through 15.390 result flags. The same is true when using interval pointers.","For example, the above describe implementation may correspond to the algorithm An (cf. ). To achieve the best data retrieval performance, it can be advantageous to use this algorithm An when the current value of the number of hits (e.g., pc; cf. ) is below the threshold value B(n) (cf. ) in the \u201cnumber of hits\u201d dimension and the complexity of the Boolean expression is in the interval [B\u2032(n\u22121), B\u2032(n)] of the second dimension. The second dimension parameter p\u2032 in , therefore, reflects the complexity of the Boolean statement in this example. The threshold value B\u2032(n) may be defined through a Boolean AND expression including a single condition portion (\u201csingle-condition-Boolean-AND\u201d).","In the previously explained general result flag instance based implementation, the Boolean AND operator was applied to two result sets. In another implementation a \u201cLean AND\u201d can be implemented in case only one result set exists as a result of one portion of the Boolean expression and this result set is to be combined with a single condition through a Boolean AND operator (Boolean AND expression). The Query may have a syntax like: (<complex Subquery>) AND condition C. Also for multiple non-nested conditions combined with AND at the same bracket level the \u201cLean AND\u201d can be used. A syntax example for this kind of flat Boolean expression is: C AND C AND . . . AND Cn, where Cn are conditions.","This \u201cLean AND\u201d implementation may, for example, correspond to the algorithm A\u2032n (cf. ). To achieve the best data retrieval performance, it can be advantageous to use the algorithm A\u2032n at the \u201cnumber of hits\u201d value pc when the complexity of the Boolean AND expression is below a certain threshold value (e.g., in the second dimension interval [B\u2032(n), B\u2032(n+1)], cf. ).","In the above examples, only one result set exists and one or more conditions are to be combined with the Boolean AND operator.","Assume a Boolean expression, such as:\n\nC1 AND C2 AND . . . AND Cn.\n","As explained before, the data storage system  is able to quickly find out which of the conditions C to Cn has the lowest number of hits, that is, the highest selectivity. The total number of hits in the intersection set of all conditions cannot be larger than the number of hits for the condition with the highest selectivity.","Therefore, the data storage system creates a result set for the condition with the highest selectivity, then runs through all result flags of the result set and checks for each result flag if the remaining conditions are fulfilled by the corresponding InfoCourse or not. In this implementation the InfoCourses are needed to check, for example, a condition NAME_FIRST=\u2018Peter\u2019. The data storage system uses the relation from the result flag through the docking element to the corresponding IC-anchor, which points at the corresponding InfoCourse. The corresponding InfoCourse tree is then searched for the InfoType values according to the remaining conditions.","In this implementation, a second result set is not needed to be checked against the result set because the checking is directly performed on the related InfoCourses. As a consequence, the time to instantiate all the result flags of a second result set is saved by directly searching the InfoCourses matching the result set (already the most selective Condition) and checking directly if the corresponding values match or not.","For each result flag this check is performed for one or more conditions. For example, in a query C AND C AND C AND C, a result set is instantiated for the most selective condition and for each result flag the three other conditions are checked accordingly. If at least one condition does not match, the corresponding result flag is deleted from the result set and the result counter is adjusted accordingly.","Finally, the result set flags all matching InfoCourses (records) and the result counter has the correct number of hits, which may be reported to an application.","For example, the \u201cLean AND\u201d implementation can be advantageous when the time to instantiate the result flag instances of the second result flag exceeds the time to check the corresponding InfoCourses.","If the Boolean expression has only one single condition, result sets are not necessary. Result sets become valuable in case of a combination of several conditions in a corresponding query. In the particular case of only one condition the count result for the total number of hits is obtained by means of the tree structures as described in . If InfoCourses have to be returned to an application, this can also be done by using the tree structures. Instead of a result set identifying the matching InfoCourses the tree nodes as such are used. For example, instead of running through a result set to visit all matching InfoCourses and collect the data into a Send-Buffer-Structure, only the matching sub-tree structures identified by the corresponding start pointers are traversed. As soon as the offset InfoCourse is found, only the number of InfoCourses has to be visited that is to be returned. For example, when 10 InfoCourses have to be returned to an application, only 10 nodes from the offset InfoCourse on have to be traversed in the corresponding InfoType sub-tree. From each node in an InfoType tree the corresponding anchor object can be reached, and from the anchor each attribute value of the given InfoCourse can be reached.",{"@attributes":{"id":"h-0010","num":"0000"},"figref":"FIGS. 16 to 18","b":["1","2"]},"This second implementation is appropriate for very large result sets, where the first implementation would require many result flag instances eating up a lot of memory space of the data storage system.",{"@attributes":{"id":"h-0011","num":"0000"},"figref":"FIG. 17"},"For example, a first bitmap BM-n corresponds to the first result set  and a second bitmap BM-n+2 corresponds to the second result set . The result flags C-FLAG, C-FLAG are implemented as bits in the respective bitmaps.","A bitmap in general consists of multiple machine words. Depending on the hardware architecture of the data storage system, a machine word can consist, for example, of 32 or 64 bits. The second implementation also works with any other machine word length, such as 128 bit or more. A bitmap is a contiguous concatenation of machine words in a sufficiently large area of the data storage system memory. The number of bits in a (result set) bitmap corresponds to the number of IC-anchors of the InfoCourses selected by the Boolean expression . Therefore, each bitmap has the maximum size of a result set. Multiple bitmaps can simultaneously exist in the memory. Each bitmap (result set) is identified by a corresponding result ID. Each result ID points to the start address of its corresponding bitmap. For example, the first result ID  and the second result ID  point to the start address of the first bit map BM-n and the second bit map BM-n+2, respectively.","Assume, 5 million records (InfoCourses) are loaded into the tree structures of the data storage system. Therefore, 5 million IC-anchors exist and, in this example, one bitmap includes 5 million bits (one Bit per IC-anchor). The bitmap occupies 5.000.000\/8=625.000 bytes 610 KB. The 5 million bits correspond to 5.000.000\/64=78.125 machine words on a 64 Bit hardware platform and to 5.000.000\/32=156.250 machine words on a 32 Bit hardware platform. This example shows that a bitmap can be made up of tens of thousands or even more machine words. The number of machine words in a Bitmap is only physically limited by the size of the available main memory and the addressability of the main memory.","That is, each Bitmap may consist of a theoretically unlimited number of machine words, where the length of a machine word depends on the given hardware platform and\/or the operating system of the data storage system. Each bitmap is referenced by a result ID. Preferably, the result IDs ,  are stored in a tree structure allowing direct access to the start address of the corresponding bitmap via a pointer. In general, any structure (e.g., a linear list) can be used to administrate the result IDs. However, for large numbers of result IDs the access to a specific result set is more efficient when using a tree structure than when using a linear list or another structure.","When the start address of a specific bitmap has been found, this specific bitmap can be used to count the number of hits (number of result flags) or to return data to an application.","In the second implementation, each bitmap has a counter counting the Number of result flags, that is, the number of bits set to 1. To count the number of hits, the data storage system can run through all machine words of the bitmap. If a machine word has a value of zero, then all bits of the machine word are zero and the next machine word can be checked. For machine words having a value different from zero the data storage system determines the number of bits that are set to 1. This can be achieved by known methods, such as, shifting the bits of a machine word into one direction, testing with bit masks performing a bit by bit AND operation, etc. Each time a bit is set to 1, the counter is increased by 1. At the end of the procedure the counter value corresponds to the number of bits set to 1 and, therefore, the number of result flags in the corresponding result set.",{"@attributes":{"id":"h-0012","num":"0000"},"figref":"FIG. 18"},"In contrast to the first implementation, bits of a bitmap and the corresponding IC anchors are not linked by pointers.","However, IC-anchors and their corresponding bits are related by a memory mapping rule using relative addresses. A memory manager of the data storage system can ensure that the IC-anchors and the bitmaps reside in contiguous memory areas. The data storage system can then locate any IC-anchor that relates to a specific bit in a bitmap.","For retrieving data (InfoCourses) in response to a query the data storage system identifies the corresponding IC-anchors. Using the IC-anchor and the corresponding InfoCourse tree a specific node in an InfoType tree can be found and the value can be read from the node. The value can then be copied, for example, to a Send-Buffer-Structure as described earlier. To locate the specific bit that corresponds to the identified IC-anchor the data storage system can use an algorithm that works with relative addresses.","A specific bit is part of a machine word. Assume that this specific bit is bit number K. The machine word has a memory address MWA. The whole bitmap has a start address SA. For example, the relative address of the specific bit is calculated as BA=(MWA\u2212SA)*64+K for 64 Bit long machine words and BA=(MWA\u2212SA)*32+K for 32 Bit long machine words. At this memory location, the specific bit of the Bitmap can be checked. If it is set to 1, the InfoCourse with the corresponding IC-anchor is part of the result set.","The IC-anchor can be found in the IC-anchor memory area in the following way. All IC-anchors reside in the IC-anchor memory area with the basis address C. The size AS of an IC-anchor is known. Therefore, the IC-anchor address AA of the specific IC-anchor can be calculated as AA=C+BA*AS. Therefore, a pointer that is set to the address AA points to the requested IC-anchor.","When creating a result set bitmap in compliance with a portion of the Boolean expression, the result flag bits that relate to IC-anchors of the corresponding InfoCourses are set to 1. This can also be achieved by using relative addresses.","Each IC-anchor has a memory address AA. The basis address of the IC-anchor memory area is C. By knowing the size AS of an IC-anchor, the IC-anchor position number can be calculated as BA=(AA\u2212C)\/AS. That is, the result flag bit for the BAth IC-anchor is to be located in the bitmap memory area. The start address of a specific bitmap (result set identified by result ID) is SA. The machine word address MAW where the bit is located is calculated as MAW=SA+BA div 64 on a 64 bit hardware platform and MAW=SA+BA div 32 on a 32 bit hardware platform, where the div operator divides one integer number by another integer number and returns the integer part of the result. Within the identified machine word at MAW the Kth bit has to be set to 1 with K=BA mod 64 on a 64 bit hardware platform and K=BA mod 32 on a 32 bit hardware platform, where the mod operator divides two integer numbers and returns only the remainder. Alternatively, K could also be calculated as: K=BA\u2212(MAW\u2212SA)*BS, where 2is the addressable number of bits in the used hardware platform\/operating system.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":"FIG. 19"},"Machine word  of the first bitmap BM-n is combined with machine word \u2032 of the second bitmap BM-n+2. This is repeated for all pairs of machine words (,\u2032), (,\u2032), and so on, with respect to the first and second bitmaps. Since all IC-anchors are represented by a corresponding bit in each of the bitmaps, all bitmaps have the same size and, thus, contain the same number of machine words.","The logical combination of pairs of machine words by applying the Boolean AND or OR operators can be performed as a bit by bit AND or OR operation. Usually, the CPU (processor) can perform this in one processing cycle. Programming languages, such as C++, offer commands for this kind of bit by bit operations.","The result of the combination of first and second result set bitmaps may be written to a new, third bitmap (e.g., BM-n+1) or to one of the two original bitmaps BM-n, BM-n+2. This depends on whether the original bitmaps may be overwritten or are to be kept for later use.","After the processing of each pair of machine words the result flag counter counts how many bits are set to 1 in the resulting machine word. The sum of the counting results for all machine words of the resulting bitmap corresponds to the total number of bits set to 1 in the resulting bitmap and may be reported to an application as the number of hits.","The application of the Boolean NOT operator to a bitmap is performed as a bit by bit NOT operation applied to each machine word in the bitmap. Again, the result may overwrite the original bitmap or can be written to another bitmap if the original bitmap has to be kept for later use.","The so far described bit map implementation may correspond to the algorithm A(n+1) (cf. ) that has a better performance than the algorithm An in case the number of hits pc exceeds the threshold value B(n) and the complexity of the Boolean expression is in the interval [B\u2032(n\u22121), B\u2032(n)].","The \u201cLean AND\u201d, as described under , only needs one result set and can also be implemented when using bitmaps. The bit map \u201cLean AND\u201d implementation may correspond to the algorithm A\u2032(n+1) (cf. ) that is to be used when the complexity of the Boolean AND expression is in the interval [B\u2032(n), B\u2032(n+1)] in the complexity dimension and the current number of hits is in the interval [B(n), B(n+1)].","For example, the Boolean expression includes five conditions that are combined by Boolean AND operators: C AND C AND C AND C AND C. A result set bitmap is set up (as described in , ) for the condition with the highest selectivity of all conditions included in the Boolean expression. Then the data storage system runs through the bitmap from the first to the last bit. For each bit that is set to 1 the data storage system jumps to the corresponding InfoCourse and checks if all other Conditions are fulfilled by the corresponding InfoCourse. This check is performed in the same way as described in the implementation using result flag instances (cf. ). If all conditions are true the bit keeps its value 1, otherwise the bit is set to 0. When a bit is set to 0, the corresponding result counter containing the number of bits that are set to 1 is reduced by 1. Therefore, the result counter contains always the current number of hits.","Alternatively, instead of getting the number of hits from the initial bitmap and reducing the counter each time a bit is set to 0 when an InfoCourse does not match the other conditions, the counter may also count the number of bits that are set to 1 in the bitmap after the \u201cLean AND\u201d has been applied.",{"@attributes":{"id":"p-0162","num":"0161"},"figref":"FIG. 20","b":["990","111","112","113","114"]},"A result set may potentially contain millions of result flags given a sufficiently large number of infoCourses loaded. Using the first or third data retriever , , for example, on a 64 bit architecture one pointer address occupies already 64 Bit (8 Bytes). Each result flag has at least two pointers plus the content of the result flag. Therefore, one result flag may occupy several hundreds of bytes. In this case, one result set containing some millions of result flags occupies memory space in the range of up to several hundreds of megabytes. This is in addition to the memory space occupied by the tree structures that also reside in main memory. Further, as the data storage system using the first or third data retriever ,  processes the result sets sequentially and checks result flag instance by result flag instance to perform AND\/OR combinations, this may lead to processing times of several seconds for one combination when applied to very large result sets (e.g., several millions of result flag instances). One can apply an appropriate parallelisation to the first implementation or use the second implementation to overcome these issues.","The second and forth data retriever implementations ,  use bitmaps for result sets. Bitmaps are a representation of result sets that consumes considerably less memory space than the result sets of the first and third data retrievers. Further, bit by bit Operations are performed very fast and can usually be handled in one CPU processing cycle per machine word, if supported by a programming language, such as C++.","For very large result sets, such as several millions of hits (e.g., in the interval [B(n), B(n\u22121)]), it can be more time saving to perform Boolean combinations of result sets using bitmaps instead of pointer lists of result flag instances. Already the instantiation of millions of result flag instances may last several seconds if parallelisation is not used. In addition the time for performing the Boolean combination has to be considered. The Boolean combination of result flag instances is performed one by one at the instance level.","However, when a result set contains only a small number of hits (e.g., in the interval [B(n\u22121), B(n)]) then bitmaps may be \u201calmost empty\u201d. That is, only a small number of bits is set to 1 in a large number of machine words (e.g., for 5 million InfoCourses a bitmap includes 78.125 machine words on a 64 bit platform). In a bad case only one bit is set to 1 in each machine word. Therefore, for small result sets the use of result flag instances may be advantageous.","Within the corresponding intervals in the \u201cnumber of hits\u201d dimension the further performance dependency on the complexity of the Boolean statement exists. This dependency has already been explained under .","The computer program product components in  allow the data storage system to switch from one data retriever implementation to another if the other implementation uses an algorithm that is more advantageous in a specific environment. For example, this can be achieved by transforming pointer lists of the first implementation into bitmaps of the second implementation and vice versa. For these transformations the above explained procedures for creating result flag instances and for creating bitmaps can be used.","The data storage system decides by itself when it is appropriate to use an implementation that is useful for small result sets having a number of result flags below a threshold value (e.g., up to several thousand elements) or an implementation having a number of result flags above the threshold value. For each of these cases the data storage system further decides whether the corresponding \u201cLean AND\u201d algorithm A\u2032n, A\u2032(n+1) or the more general algorithms An, A(n+1) is advantageously used.","This enables the data storage system to automatically select the algorithm, which is best in terms of memory consumption and performance in a specific situation. If a current value of one dimension equals a threshold value of this dimension, then it is not important, whether the algorithm for the interval above or below the threshold value is used because, preferably, the threshold value is defined as the breakeven points for the two algorithms.","In the example, the threshold value in the \u201cnumber of hits\u201d dimension may be the break even point being defined as the number of result flags in a result set, where the use of result flag instances leads to the same system performance as the use of bitmaps. The data storage system can determine the threshold value dynamically, for example, by appropriate time measurements. Therefore, on a given technology platform for a given data volume, data value distribution, etc., the appropriate value for the threshold value can be used in a stable environment at all times.","The query generator  generates the query that includes the Boolean expression . For example, the query generator can be implemented on the front end computing device . The query generator  can also be part of an application that runs on any other computing device of the computer system .","Once the data storage system  receives the Boolean expression through a corresponding interface, the result counter  determines the corresponding number of hits. Preferably, the result counter is implemented in the data storage system .","The threshold evaluator  is able to perform multidimensional comparisons. In other words, the threshold evaluator can compare the current number of hits with the intervals [B(n\u22121), B(n)] and [B(n), B(n+1)] and, substantially simultaneously, the complexity of the Boolean expression with the intervals [B\u2032(n\u22121), B\u2032(n)] and [B\u2032(n), B\u2032(n+1)].  explains details about how to initialise the threshold values defining the intervals.","In case the number of hits (result flags) is in the interval [B(n\u22121), B(n)] and the Boolean expression is a complex Boolean expression from the interval [B\u2032(n\u22121), B\u2032(n)], the data storage system uses the first data retriever . This case is illustrated by bold solid connection lines between the threshold evaluator and the first data retriever.","In case the number of hits (result flags) is in the interval [B(n), B(n+1)] and the Boolean expression is a complex Boolean expression from the interval [B\u2032(n\u22121), B\u2032(n)], the data storage system uses the second data retriever . This case is illustrated by bold dotted connection lines between the threshold evaluator and the second data retriever.","In case the number of hits (result flags) is in the interval [B(n\u22121), B(n)] and the Boolean expression includes a \u201csingle-condition-Boolean-AND\u201d expression from the interval [B\u2032(n), B\u2032(n+1)], the data storage system uses the third data retriever . This case is illustrated by bold dashed connection lines between the threshold evaluator and the second data retriever.","In case the number of hits (result flags) is in the interval [B(n), B(n+1)] and the Boolean expression includes a \u201csingle-condition-Boolean-AND\u201d expression from the interval [B\u2032(n), B\u2032(n+1)], the data storage system uses the forth data retriever . This case is illustrated by bold dotted-dashed connection lines between the threshold evaluator and the second data retriever.","The retrieval time measuring component  of the data storage system can measure the time that is consumed by either data retriever implementation.","The threshold calculator  can dynamically determine (re-calculate) the threshold values of the various dimensions on the basis of the time measurements with respect to the four data retriever implementations. The recalculated threshold values can be fed into the threshold evaluator  and used for the next query.","In general, there can be more threshold values that correspond to even more data retrievers for even more dimensions. That is, there can be further dependencies on further parameters that are considered by the threshold evaluator for selecting the appropriate data retriever.","Embodiments of the invention can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The invention can be implemented as a computer program product, i.e., a computer program tangibly embodied in an information carrier, e.g., in a machine-readable storage device or in a propagated signal, for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Method steps of the invention can be performed by one or more programmable processors executing a computer program to perform functions of the invention by operating on input data and generating output. Method steps can also be performed by, and apparatus of the invention can be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in special purpose logic circuitry.","To provide for interaction with a user, the invention can be implemented on a computer having a display device, e.g., a cathode ray tube (CRT) or liquid crystal display (LCD) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","The invention can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","Although an embodiment of the invention has been described in detail using a data storage system having a plurality of data retrieval algorithms, the invention is not limited to this embodiment. Rather, other software applications making use of the spirit of the invention as broadly described by the claims are considered to be within the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
