---
title: Cross-format analysis of software systems
abstract: In various implementations of a software analysis system, compliance checking is facilitated by analyzing different characteristics of a software system to be developed, and by comparing the information extracted from these analysis. Two or more characteristics may be expressed in different formats or languages, and the descriptions of one or more of these characteristic may be incomplete.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134976&OS=09134976&RS=09134976
owner: Reservoir Labs, Inc.
number: 09134976
owner_city: New York
owner_country: US
publication_date: 20111213
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","GOVERNMENT INTERESTS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","EXAMPLES"],"p":["This application claims priority to and the benefit of U.S. Provisional Patent Application No. 61\/422,566, filed on Dec. 13, 2010, which is incorporated herein by reference in its entirety.","This invention was made with Government support under contract no. N00039-09-C-0118 awarded by the U.S. Navy\/SPAWAR. The Government has certain rights in the invention.","The technology disclosed herein relates generally to systems and methods for software analysis, and in particular to systems and methods for software testing.","As the use of computer-based software systems and applications proliferates in areas as diverse as home use and entertainment\/recreation, scientific and business computing, communications, and medical and military applications, there is an increasing demand to produce high-quality software in a timely and cost-effective manner. Errors in software can cause costly product delays and may jeopardize privacy and\/or safety of the users of the software in certain situations, for example, in the case of software used in financial, medical, and\/or military systems. Therefore, significant emphasis is usually given to software testing and quality assurance of software.","One aspect of software testing is compliance checking in which various requirements of a software system are typically specified in a human and\/or computer-readable specification document. Such requirements include, for example, a set of functionalities (also called capabilities) the software is expected to deliver, certain special situations the software should be able to handle, and certain interfaces the software should provide, possibly to facilitate interaction with other software systems. Accordingly, compliance checking generally includes ascertaining that the functionalities described in the specification document are, in fact, provided by the software and\/or various constraints, if listed in the specification document, are not violated by the software. Compliance checking may also include verifying that the functionalities provided by the software are consistent with the software architecture that describes various components of the software, and interactions among those components. In addition, compliance checking may include verifying that any supplemental configuration associated with the software, e.g., a listing of interfaces provided by the software, conforms to the requirements described in the specification document, and\/or verifying that the supplemental configuration is consistent with the functionalities provided by the software and\/or the software architecture.","Compliance checking can be performed once the software is ready for execution, i.e., the source code thereof has been written and compiled into a computer readable executable code. If an error is discovered during such a test, e.g., if a functionality provided is found not to be in accordance with a requirement in the specification document, the source code of the software may be modified and recompiled to obtain a modified executable code that must be retested. This testing methodology is often time consuming and costly. Moreover, to obtain a fully executable software system, the source code of all components of the software must be implemented, e.g., written by a developer, obtained from other sources, generated using a computer, etc. Awaiting implementation of all software components can add a significant delay to the overall development of the software.","In addition, in some situations, certain components of the complete software system are not available to a developer. It is not uncommon that a user of a software system may obtain some components from a developer, and generate certain other components on its own or may obtain them from a third-party vendor. Those other components may not be available to the developer, even in an executable form, typically for reasons such as those other components are the software user's proprietary, confidential property that the user may not share, or because obtaining a license from the third-party vendor is costly. In this situation, the user of the software typically specifies several requirements for the components to be supplied by the developer so that the user can integrate the various components into a complete software system. The developer is typically required to test and assure compliance of the components to be supplied by the developer with the specified requirements, even though the developer does not have access to all components of the software and, hence, cannot build a complete executable software for testing thereof.","According to some static-analysis techniques (i.e., techniques for testing a source-code implementation of a software system) various errors, including violations of some general implementation guidelines, can be detected early in a software development cycle. Thus, static analysis can avoid significant delays and costs associated with detecting these errors\/violations for the first time while testing the executable software. Many static-analysis techniques, however, present some challenges to the use thereof for compliance checking.","As described above, static analysis is usually performed on the software source-code, which is typically written using a single programming language such as C, C++, JAVA\u2122, etc. As such, many static-analysis tools are language specific, i.e., they are designed to analyze code written in only one format or language. In compliance checking, however, the software architecture (e.g., a high level description of various components of the software, and interactions among those components) may be provided in one format, e.g., plain text, Extensible Markup Language (XML), etc., while the source-code may be written in a different format\/language such as C, C++, JAVA\u2122, etc. Moreover, one part of the source code may be written in one format\/language and another part may be written in a different format\/language. Therefore, those static-analysis tools cannot ascertain that the requirements according to a high-level architecture specified in one format are met by an implementation described in one or more different formats. This problem may be compounded if the supplemental configuration associated with the software, such as interfaces to other components to be provided, is described in a third format.","Some known static-analysis tools may be used to test partially implemented source code, but these tools generally require at least some information about the incomplete or unavailable portions of the source code and\/or components of the system. Such information is often provided in files commonly known as header files. The header files are not available, however, when certain proprietary and\/or third-party-supplied components are inaccessible to the developer, as described above. As such, in various situations described above, known static analysis techniques cannot be employed effectively for compliance checking.","In various provided embodiments, systems and methods of cross-format analysis of software systems enable testing, and compliance checking in particular, of a software system being developed early in the development cycle, i.e. at the source-code level, even if one or more of the software architecture, source code, and the associated configuration to be provided with the software are expressed in different formats\/languages. The cross-format analysis systems and methods can perform the testing as described above even if some components are only partially developed and even if no information is available for some components.","This is achieved, in part, by analyzing the software requirements described in one or more files of a certain format\/language, and by extracting and representing those requirements in an intermediate format. Then, the source-code files, in another format\/language, which may provide a full or incomplete implementation of the software system are analyzed and various functionalities that are implemented at the time of analysis are extracted. These extracted functionalities are compared with the requirements listed in the intermediate format, and discrepancies, if any, are identified.","Any supplemental configuration that may include, for example, interfaces for inter-operability with other components of the software being developed, or a different software system, is similarly analyzed and the information obtained from that analysis is compared with the extracted requirements, the extracted functionalities, or both. The supplemental configuration may also be only partially complete. The order of analysis described above is merely exemplary and not a required one. In general, depending on the type of testing to be performed, a suitable order of analyses can be selected. For example, in some situations, the source-code implementation may be analyzed first and then the software architecture may be analyzed, checking, for example, whether an implemented functionality as extracted from the source-code analysis is permitted according to the software architecture and\/or the software specification.","In this way, it can be ascertained that different characteristics of the software being developed, e.g., the software architecture\/requirements, provided functionalities, provided supplemental configuration, etc., are all consistent with one another. Thus, various provided embodiments of cross-format analysis enable compliance checking at the source-code level regardless the format\/language of the software characteristics, thereby allowing for detection of errors early which, in turn, can reduce the cost of software development. Moreover, the cross-format analysis according to various provided embodiments facilitates compliance checking even if no information is available about certain components of the software.","Accordingly, in one aspect, a computer-implemented method, an apparatus including a processor and a memory including processor executable instructions that, when executed by the processor, configure the apparatus, and\/or an article of manufacture including a non-transitory machine-readable medium storing instructions that, when executed by a machine, configure the machine are provided to read, in the memory, a first module describing a first characteristic of the software application. At least a part of the first module has a first format. The method and\/or instructions in the apparatus and\/or the article are also provided to read, in the memory, a second module describing a second characteristic of the software application. At least a part of the second module has a second format that is different from the first format.","The method and\/or instructions in the apparatus and\/or the article are also provided to analyze, by the processor, the first module to express at least a portion of the first characteristic as a first artifact, and to analyze, by the processor, the second module to derive at least a portion of the second characteristic. In addition, the method and\/or instructions in the apparatus and\/or the article are provided to compare, by the processor, the first artifact and the derived portion of the second characteristic to determine if the at least a portion of the first characteristic, as expressed by the first artifact, is consistent with the derived portion of the second characteristic, and to store, in one or both of the memory and a nonvolatile storage, a result of the comparison as a second artifact.","In some provided embodiments, the first format includes one or more of plain text, Extensible Markup Language (XML), JAVASCRIPT\u2122 Object Notation (JSON), and Unified Modeling Language (UML). The first module may include one or more files. The first characteristic described by the first module may include a partial and\/or entire software architecture describing a functionality to be provided by the software application. The first artifact may include one or more application-program-interfaces (APIs) corresponding to the partial and\/or entire software architecture.","In some provided embodiments, the second format includes one or more of Interface Description Language (IDL), Simple Declarative Language (SDL), and proprietary distributed Component Object Model (DCOM), and the second module may include one or more files. The second characteristic described by the second module may include a software configuration associated with the software application. The software configuration may be expressed as one or more APIs corresponding to the partial and\/or entire software architecture describing of the functionality to be provided by the software application. The second artifact may include a portion of the first artifact that is consistent with the derived portion of the second characteristic and\/or a portion of the first artifact that is not consistent with the derived portion of the second characteristic.","In some provided embodiments, the second artifact includes at least a portion of a third characteristic of the software application, and the third characteristic may include partial and\/or entire source-code implementation of the software application. The language of the source-code implementation may be one or more of C, C++, JAVA\u2122, Fortran, and Ada. The portion of the third characteristic or the entire third characteristic of the software application may include one or more API function declarations. The one or more of the API function declarations may include at least one of a function name, a function argument, and a function return type.","In some provided embodiments, the processor is further configured to read, in the memory, a third module comprising a file describing a part of a third characteristic of the software application. At least a part of the file has a third format. The processor may also be configured to analyze, by the processor, the file to derive at least a portion of the third characteristic, that corresponds to the file, from the part of the third characteristic described in the file, and to compare, by the processor, the second artifact and the derived portion corresponding to the file to determine if the derived portion corresponding to the file is consistent with the second artifact. The processor may be further configured to store, in the at least one of the memory and the nonvolatile storage, a result of the comparison of the second artifact and the derived portion corresponding to the file as a report corresponding to the analyzed file. The third format may include one or more source-code languages. One of the source-code languages may be one of C, C++, JAVA\u2122, Fortran, and Ada.","In some provided embodiments, the part of the third characteristic described by the file comprises at least a portion of a source-code implementation of the software application. The report corresponding to the file may include a portion of the second artifact that is consistent with the derived portion of the third characteristic corresponding to the file, or a portion of the second artifact that is not consistent with the derived portion of the third characteristic corresponding to the file. The derived portion corresponding to the file may include one or more API function declarations corresponding to at least a partial source-code implementation of the software application. The second artifact may include one or more API function declarations.","In some provided embodiments, the third module includes several files, each file describing a part of a third characteristic of the software application. The processor may be configured to repeat analyzing, comparing, and storing for each file in the third module, thereby generating a number of reports, each report corresponding to one file. The second artifact comprises a set of requirements, and the processor is further configured to combine the report corresponding to each file to generate a combined report. The processor may also be configured to analyze the combined report to determine if each requirement in the set is satisfied exactly once.","In some provided embodiments, the second artifact includes a set of requirements, and the method and\/or configuration of the processor to compare comprises a further configuration of the processor to annotate a requirement in the set if the requirement determined to correspond to the derived portion corresponding to the file. The configuration to annotate the requirement may include a further configuration of the processor to lock the requirement in the second artifact. The locking can avoid simultaneous updates to a requirement if comparing the second artifact and the derived portion corresponding to the file is performed simultaneously with another comparison, comparing the second artifact and a derived portion corresponding to another file.","In some provided embodiments, several characteristics are associated with the software application, and the method further provides and\/or the processors, according to the instructions, is further configured to select a test to be performed to determine consistency. The method may also include and\/or the processor may be further configured to designate, based on the selected test, one characteristic from the several characteristics as the first characteristic, and a another, different characteristic from the several characteristics as the second characteristic. The selected test to be performed may be exception consistency, and the characteristic designated as the first characteristic may include at least a portion of a source-code implementation of the software application. The characteristic designated as the second characteristic may include at least a partial software architecture describing one or more functionalities to be provided by the software application. The second artifact, the report, or both may include a line identifier for a line in a file in at least one of the first, second, and third modules, the identified line being inconsistent with a software specification.","Cross-testing generally refers to a technique for statically (e.g., at the source-code level) analyzing a mixed-format corpus of files (e.g., CORBA\u00ae Interface Description Language (IDL), XML, and programming language source code) belonging to a common project against a specification containing rules for imposing consistency across the information represented by the different files. An objective of cross-testing is to test and verify requirements, such as consistency requirements, that cannot be completely checked by examining the files of only one type. In general, cross testing includes parsing files of each type separately, distilling the information relevant to consistency testing into a queryable intermediate format, the distilled information forming a common base of knowledge, and then testing each requirement by analyzing the common base of knowledge.","To this end, an exemplary cross-format analysis system includes a separate parser and information extractor\/generator for each file format associated with a software-development project. The cross-format system also includes an analyzer for analyzing, e.g., by comparing, matching, etc., the extracted\/generated information corresponding to the different formats. That analysis is used to check consistency, for example, between an architecture of the software in one format and the implementation of the software in another format.","An exemplary cross-format analysis system analyzes source-code files in C and\/or C++ languages using a parser. Various commercially available parsers can be used for this purpose. An output of the parser representing the source code is broken down into a documented set of data structures that can be queried and\/or processed with respect to one or more software architecture\/specification requirements. From this processing and analysis, a report that includes all the relevant information and documents the test performance is produced. The report may also relate (e.g., cross reference) any incidents of discrepancies between the software architecture and the source-code implementation to the corresponding text of the source code.","With reference to , a cross-format software analysis system  receives software specification  describing the requirements of the software  to be implemented. These requirements may include certain functionalities that must be implemented in the software , and certain functions provided by other components (e.g., proprietary and\/or third-party components) that must be invoked and\/or cannot be invoked. Associated with the software  is a software architecture , a software configuration , a source-code implementation  and an executable . The cross-format software analysis system  reads and analyzes the software architecture , a software configuration , a source-code implementation  for consistency thereof with one another.","The specification  may require that the configuration  be supplied as a part of software . The configuration , for example, may include interfaces to various functionalities provided in the software , thereby facilitating convenient integration of the software  with other software components and\/or systems. In general, the software architecture , the configuration , and the source code  can be viewed as various characteristics (or properties) of the software . Each of these characteristics can be expressed in a different format, and parts of the same characteristic, for example different source files of the source code  may also be expressed in different formats.","With reference to , in a compliance testing process , a description module describing\/specifying the requirements of the software to be developed is analyzed in step . The description module includes one or more files in the XML format. In other provided embodiments, the files of the descriptor module can be in various other formats such as plain text, JSON, UML, etc. In step , the XML descriptor files corresponding to the software architecture are statically analyzed to determine a functionality (also called capability) set. The functionality set identifies the various functionalities the software is required to provide.","This functionality\/capability set is rendered into an Artifact I in step . For example, the Artifact I may include or consist essentially of a list of application-program interfaces (APIs) corresponding to the capabilities described. The steps ,  may be performed even if the descriptor module is incomplete, i.e., some descriptor files have not been provided and\/or one or more descriptor files may be updated at a later time to include additional requirements. At the time of performance of steps , , a list of APIs is built from the requirement information that is available at that time.","In one provided embodiment, the specification of the software requires that each functionality provided by the software be expressed as an API in an interface module as supplemental configuration associated with the software. The specification further requires that the format of the APIs be IDL. It should be understood, however, that the supplemental configuration associated with the software may be described in other formats such as SDL, proprietary DCOM, etc. As such, in step , the interface module that includes various API files in the IDL format is analyzed. During this analysis, a list of APIs corresponding to the functionalities purportedly provided by the software is derived from the IDL files.","The list of APIs derived in step  is compared with the Artifact I, which contains the list of API that the software is required to be provide, in step . If these two lists do not match, the supplemental configuration includes APIs corresponding to functionalities that are not required, or the supplemental configuration lacks the APIs corresponding to the functionalities that are, or both. Such discrepancies, if any, and indicating that the supplemental configuration does not comply with the specified requirements of the software, are reported in the step .","In step , the information derived from the API files and that extracted from the descriptor files and rendered into Artifact I is processed to facilitate further compliance analysis. Specifically, the APIs for which no discrepancies were found in step , a corresponding list of function declarations, including function names, arguments, and return types, that is expected to be provided in the source code of the software is generated and rendered as Artifact II in step . Artifact If may also include any discrepancies identified in step .","In step , one of the source files of the software being developed (or already developed) is selected. The format of these source files can be C, C++, JAVA\u2122 Fortran, Ada, etc. In some provided embodiments, all source files available at the time of analysis may be described using one format\/language, while in other provided embodiments, some source files may be described in one format\/language (e.g., C++) while the other source files may be described in another format\/language (e.g., Ada). It should be understood that the combination of C++ and Ada files described herein is illustrative only, and that combinations of source files in other formats and combinations including more than two different formats (e.g., three or five different formats) are within the scope of the present invention. The selected source file is analyzed in step , and one or more function declarations, each one having a corresponding function that implements a certain functionality\/capability, are identified from the source code contained in that file.","In step , the identified function declarations are compared with the function declarations rendered into Artifact II. Recall, the function declarations in Artifact II are based on the specified requirements and the documented APIs that were determined to be in compliance with the specified requirements. Therefore, if the identified function declarations match with those in Artifact II, it may be concluded that the part of the source-code implementation contained in the analyzed file is in compliance with both the software architecture and the supplemental configuration. If, however, a discrepancy is found, for example with respect to the number and\/or types of arguments and\/or return type, that discrepancy is reported in step .","Based on the above analysis, in step , a report is generated and rendered that includes all of the functions rendered in Artifact II that are also defined with the scope of the analyzed file, whether or not any discrepancies exists, i.e., whether or not the source-code implementation conforms to the specified requirements and\/or the documented APIs.","Whether all source files have been analyzed is checked in step  and, if one or more files remain to be analyzed, the next source file is selected in step , and steps - are repeated. When all files are analyzed, the file reports, each one corresponding to a source-code file, are consolidated (e.g., merged), in step . Also in step , the consolidated report is compared with Artifact II, so as to ascertain that among all available source files, each functionality, as specified in the descriptor module, is implemented exactly one in some source-code file. Any discrepancies, such as a required functionality was not found in any available source-code file, or a required functionality was implemented more than once in the source code, are also analyzed in step . A final report, including results of various analyses and comparisons, and any discrepancies identified, is rendered in step .","With reference to , in the process , the steps - and - are the same as the corresponding steps in the process . In step , however, based on the analysis in the earlier steps, if a function declaration rendered in Artifact II is found within the scope of the analyzed file, whether or not any discrepancies exists, Artifact II is updated, e.g., the function declarations generated in step  are updated (e.g., annotated) to indicate that corresponding function implementation in the source code was identified. In the process , the step  of the process  is avoided. Instead, the function declaration in Artifact II is used as a check list, i.e., if one or more function declarations remain un-annotated after all source-code files have been analyzed, it is determined that one or more specified functionalities have not been implemented. Conversely, if a match is found again for an annotated function declaration in Artifact II, it is determined that a certain functionality has been implemented more than once. These implementations may be redundant, or one or more of them may be inconsistent with the software architecture. A final report, including results of various analyses and comparisons, and any discrepancies identified, is rendered in step .","In processes , , various steps may be executed concurrently on multi-processor computers as separate execution threads. For example, one or more software-architecture files, one or more interface files, and\/or one or more source-code files may be analyzed simultaneously. In the process , in order to avoid simultaneous updates to the same function declaration in Artifact II a locking mechanism for synchronization and for controlling write accesses may be used.","Although in processes  and  the software-architecture files are analyzed first, subsequently the APIs to be provided in the IDL format are analyzed, and the source-code files are analyzed finally, this order is illustrative only, and that other processing orders are within the scope of the invention. It should also be understood, that in some provided embodiments, during compliance testing files described in only two different formats, e.g., XML and C source code may be analyzed. In general, rendering an artifact and\/or a report includes making the artifact\/report available in computer memory or storing the artifact\/report on a non-volatile memory such as a hard-disk drive, for subsequent use.","In general, a cross-format compliance testing analysis (e.g., as illustrated by processes , ) is organized as a strategy that can be static or dynamic. It should be noted, however, that even under the dynamic strategy, the analysis is performed statically, i.e., using source files without requiring an executable software, in whole or in part. The strategy typically depends on one or more rules being tested, that may be described in the software specification\/requirements and\/or software architecture, or may be inferred in part or entirely therefrom, one or more types\/formats of files being tested, and, in the case of a dynamic strategy, the results of a previous analysis.","A strategy is usually executed by constructing an information-dependency graph that specifies which analyses must be performed before other analysis, thereby directing the flow of information. The dependency graph is acyclic among analysis-file pairs, although it may require touching (i.e., analyzing) an individual file more than once. Under both static and dynamic strategies, the graph is finite.","For example, the order in which files having different formats are analyzed may depend on the nature of the test being performed. In one provided embodiment, the test is to ascertain that all functionalites\/capabilities required according to the specification\/software architecture are implemented, and, hence, the order chosen can be that described with reference to . In another provided embodiment, the test to be performed is to ascertain that the source-code implementation only invokes the exceptions that are permitted by the specification and\/or the software architecture. As such, a suitable exemplary order is an analysis of the source-code files first, followed by an analysis of the software architecture.","Under a particular strategy, by analyzing one or more files of a type\/format, an artifact encapsulating the information derived from the analysis is obtained. That artifact may be stored in volatile computer memory (e.g., cache, RAM, etc.) or in non-volatile memory (e.g., hard disk, flash drive, CD, etc., for later use). The information derived from the analysis may be necessary to perform subsequent analysis, for example, such information may be compared with information derived from the analysis of files of other types\/formats, or it may be used in a final presentation\/report indicating that a compliance test was successful or that it failed. A counter example (e.g., as mismatched function declarations) may be provided in the report if a test fails.","Both static and dynamic strategies can be executed in partial-code mode (PCM), in which static analysis can be performed on partial code, i.e., code that missing dependent files or code blocks that would be necessary to actually compile and execute the code. In some provided embodiments, the artifacts and the final report share a common syntax (e.g., a single XML scheme) that makes them interchangeable and those artifacts and report may also be manipulated by a common set of functions.","With reference to , in an exemplary cross-format analysis system  modules\/files of different types are parsed\/analyzed by various parsers\/analyzers  (for XML files),  (for IDL files),  (for C files),  (for Fortran files). The order analyzer  determines the order in which the files are analyzed. The consistency analyzer  compares and\/or consolidates the artifacts generated by the different parsers\/analyzers -. It should be understood that various components - of the system  are logical entities that may be implemented as different software modules or logical entities within one or more modules. The components - may be executed on the same computer or server, or on different processors, computers, or servers that may communicate with each other via a network. One or more of the components - may be executed concurrently, and\/or any one component may be executed as parallel threads. For example, the parser  may comprise more than one C parsers, each simultaneously parsing a different C source-code file.","In general, the components - can be implemented in hardware (e.g., as integrated circuits, FPGAs, etc.), software, or combination thereof. Typically, the components implemented as software may be coded and implemented in any programming language, including, for example, C, C++, or JAVA\u2122. The software components may be further translated into machine language or virtual machine instructions and stored in a program file in that form. The program file may then be stored on or in one or more computer-readable articles of manufacture. The article of manufacture may be any suitable hardware apparatus, such as, for example, a floppy disk, a hard disk, a CD ROM, a CD-RW, a CD-R, a DVD ROM, a DVD-RW, a DVD-R, a flash memory card, a PROM, a RAM, a ROM, or a magnetic tape.","If one or more of the components of the cross-format analysis system  are implemented, at least in part, in software, those software portions may be executed using any type of personal computer, Windows-based terminal, network computer, wireless device, information appliance, RISC Power PC, X-device, workstation, mini computer, main frame computer, personal digital assistant, set top box, handheld device, or other computing device that is capable of both presenting information\/data to, and receiving commands from, a user of the system . In general, a computer system implementing the cross-format analysis system  in hardware, software, or a combination thereof may include, for example, a visual display device (e.g., a computer monitor), a data entry device (e.g., a keyboard, a mouse, etc.), persistent and\/or volatile storage (e.g., computer memory), and a processor.","In some provided embodiments, a commercially available consistency-checking tool (e.g., R-Check\u00ae SCA from Reservoir Labs Inc.) may be used to perform some of the steps in the processes , . In these embodiments, a separate parser tool may generate a summary report from all available files of each type\/format such that the summary report includes all of the information determined to be relevant to cross-format analysis. These files may include files that describe specification\/requirements\/architecture of the software and\/or configuration associated therewith. That information is available in each summary report as an intermediate representation. Once the summary reports (also called artifacts, typically one for each file type\/format) are generated, R-Check\u00ae SCA may be executed, which may parse C and C++ source files into an intermediate representation. R-Check\u00ae SCA may also add to that representation the information contained in each of the file-type\/format artifacts.","Generally, the file type\/format artifacts (i.e., the summary reports) include only the information pertinent to cross-format testing (i.e., the information determined to be relevant) and, as such, the information in the artifacts may map nearly one-to-one to the information in the immediate representation. From this common, unified intermediate representation in memory, cross testing can be performed similarly as the single-format testing in R-Check\u00ae SCA, resulting in a unified summary report that may provide a cross-reference back to both the source code and to any line of interest in any file in any of the other formats.","The Joint Tactical Radio System (JTRS) family of software radios is being deployed with waveform application software specifically developed to the Software Communications Architecture (SCA), which references the POSIX\u00ae and CORBA\u00ae standards. In the examples below, various requirements of the SCA are considered.","The AP0100, 102, and 103 requirements of the SCA mandate the existence of a stop operation for each resource, and verification that the stop operation disables all current operations, puts the resource in a suspended state, and handles an exception that provides additional information describing the reason for the error and an error number of type CF::ErrorNumberType. To support evaluation of this requirement, given a list of resources (either extracted automatically from the code or provided as a configuration), the cross-format analysis system can identify the necessary stop operation and check the error number type automatically. The system may also provide a best-effort analysis to determine that the stop operation has the necessary semantics and exception support based on a built-in library of code patterns. Many cases can be verified automatically, though some others may require manual post-inspection. The resulting report discriminates between fully-checked cases and those requiring manual post-inspection. The latter set of cases is flagged in the report and accompanied by file and line numbers.","The AP0075, 76, and 78 requirements refer to the placement and use of releaseObject calls for CORBA components. To support evaluation of this requirement, the cross-format analysis system includes a selectable analysis for identifying, in context, use of the releaseObject function call. The system also provides a best-effort analysis to determine that the releaseObject operation has the necessary semantics and exception support based on a built-in library of code patterns. Many cases are verified automatically, while some others require manual post-inspection. The resulting report discriminates between fully-checked cases and those requiring manual post-inspection. The latter set of cases is flagged in the report and accompanied by file and line numbers.","The AP0609-11 requirements introduce support obligations in the Naming Service. The AP0063-65 requirements introduce support obligations in the CosEventComm PushConsumer. To support evaluation of these requirements, the cross-format analysis system includes a selectable analysis performing a search equivalent to the current JTEL grep-based test procedure, but with full context information about the use of each relevant keyword. This analysis is included in all generated reports, is configurable, and includes documentation. In the HTML reports, code lines are highlighted and designated as lines of interest.","The AP0614-15 requirements mandate descriptions of the interfaces used by a component in a Software Component Descriptor (SCD) XML file. To support evaluation of this requirement, the cross-format analysis system can parse and analyze, in context, the contents of SCD, Software Assembly Descriptor (SAD), and Software Package Descriptor (SPD), XML files. Parsing is based on a valid schema (not simple text grep). The analysis for AP0614 and AP0615 identifies ports designated as provides or uses in the SCD file. The output is a report formatted such that it can be synthesized by a suitable report generation tool. The analysis is configurable and includes documentation. In the HTML reports, syntax highlighting within the XML code will be supported.","The AP0608 requirement mandates that each component identified as implementing the Base Application Interfaces (Ports, LifeCycle, TestableObject, PropertySet, PortSupplier, Resource, or ResourceFactory) following the specifications identified in the SCA. Furthermore this requirement mandates that the interfaces implemented match the IDL signature in the SCA. To support evaluation of this requirement, the cross-format analysis system parses and analyzes IDL files for the purpose of extracting and summarizing interface specifications relevant to AP0608. These summaries are included as tests and then any mismatches between the IDL summary and the source code are identified as violations. Reports highlight the offending line of code and include, as a message, the source file and line of the mismatched IDL summary.","The AP0742 requirement mandates that all APIs implemented in a JTR set must have their interfaces generated through the use of an IDL. It also checks that APIs generated using methods other than the use of IDL must be documented in the service definition mapping format. To support evaluation of this requirement, the cross-format analysis system parses and analyzes IDL files for the purpose of extracting and summarizing interface specifications relevant to AP0742. Using these summaries interfaces defined but not specified in the IDL are identified as violations. This analysis can support, as an option, the ability to exempt interfaces defined though means other than the use of IDL. In the HTML reports, unspecified interface specifications are highlighted as violations.","One skilled in the art will appreciate that the present invention can be practiced by other than the above-described embodiments, which are presented in this description for purposes of illustration and not of limitation. The specification and drawings are not intended to limit the exclusionary scope of this patent document. It is noted that various equivalents for the particular embodiments discussed in this description may practice the invention as well. That is, while the present invention has been described in conjunction with specific embodiments, it is evident that many alternatives, modifications, permutations and variations will become apparent to those of ordinary skill in the art in light of the foregoing description. Accordingly, it is intended that the present invention embrace all such alternatives, modifications and variations as fall within the scope of the appended claims. The fact that a product, process or method exhibits differences from one or more of the above-described exemplary embodiments does not mean that the product or process is outside the scope (literal scope and\/or other legally-recognized scope) of the following claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings, like reference characters generally refer to the same parts throughout the different views. Also, the drawings are not necessarily to scale, emphasis instead generally being placed upon illustrating the principles of the invention. In the following description, various provided embodiments of the present invention are described with reference to the following drawings, in which:",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
