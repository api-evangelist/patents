---
title: System, method and computer program product for application development using a visual paradigm to combine existing data and applications
abstract: A system, method and computer program product are provided for generating an application. An interaction with a first application is recorded for capturing a functionality of the first application. An interaction with a second application is also recorded for capturing a functionality of the second application. A pattern is generated based on the recorded interactions. An application is generated based on the pattern. The interactions recorded in the pattern are repeated upon replay of the pattern for providing the functionalities of the first and second applications. A method for executing the pattern-based application is provided. Upon receiving a request for data, a pattern for retrieving the requested data is selected. The pattern is replayed. The recorded interaction is conducted as specified in the pattern for obtaining the requested data. The requested data is received.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07647561&OS=07647561&RS=07647561
owner: NVIDIA International, Inc.
number: 07647561
owner_city: St. Michael
owner_country: BB
publication_date: 20021213
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS","EXAMPLE"],"p":["This application claims priority from U.S. Provisional Patent Application Ser. No. 60\/341,344 entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR APPLICATION DEVELOPMENT USING A VISUAL PARADIGM TO COMBINE EXISTING DATA AND APPLICATIONS, filed Dec. 14, 2001; and is a continuation in part of the following copending patent applications: U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR THE RECORDING AND PLAYBACK OF TRANSACTION MACROS, filed non-provisionally Aug. 28, 2001 under Ser. No. 09\/942,047; U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PATTERN REPLAY USING STATE RECOGNITION, filed non-provisionally Aug. 28, 2001 now abandoned under Ser. No. 09\/942,080; and U.S. Patent Application entitled INTERFACE FOR MOBILIZING CONTENT AND TRANSACTIONS ON MULTIPLE CLASSES OF DEVICES, filed non-provisionally Sep. 14, 2001 under Ser. No. 09\/953,372, now U.S. Pat. No. 7,185,286; each of which is assigned to common assignee NVIDIA International, Inc., and herein incorporated by reference.","The present invention relates to computer programming, and more particularly to creating new applications using functionality from existing applications.","The term application is a shorter form of application program. An application program is a program designed to perform a specific function directly for the user or, in some cases, for another application program. Examples of applications include word processors, database programs, Web browsers, development tools, drawing, paint, image editing programs, and communication programs. Applications use the services of the computer's operating system and other supporting applications. The formal requests and means of communicating with other programs that an application program uses is called the application program interface (API).","In computing, a program is a specific set of ordered operations for a computer to perform. In the modem computer that John von Neumann outlined in 1945, the program contains a one-at-a-time sequence of instructions that the computer follows. Typically, the program is put into a storage area accessible to the computer. The computer gets one instruction and performs it and then gets the next instruction. The storage area or memory can also contain the data that the instruction operates on. (Note that a program is also a special kind of \u201cdata\u201d that tells how to operate on \u201capplication or user data.\u201d)","Programs can be characterized as interactive or batch in terms of what drives them and how continuously they run. An interactive program receives data from an interactive user (or possibly from another program). A batch program runs and does its work, and then stops. Batch programs can be started by interactive users who request their interactive program to run the batch program. A command interpreter or a Web browser is an example of an interactive program. A program that computes and prints out a company payroll is an example of a batch program. Print jobs are also batch programs.","When a program is created, it is written using some kind of computer language. The language statements are the source program. The developer then \u201ccompiles\u201d the source program (with a special program called a language compiler) and the result is called an object program (not to be confused with object-oriented programming). There are several synonyms for object program, including object module and compiled program. The object program contains the string of 0s and 1s called machine language that the logic processor works with. The machine language of the computer is constructed by the language compiler with an understanding of the computer's logic architecture, including the set of possible computer instructions and the length (number of bits) in an instruction.","From the above, it should be apparent that it takes weeks to create an application, even for a skilled programmer. Consider the following example. Company A want to develop an enterprise travel application. The application is to be constantly running, monitoring a human resources database for details on when executives are traveling, then going into a travel site (such as Travelocity.com, etc.) and checking flight times, checking confirmations, etc. The application is also to access a rental car site and make reservations. Upon completing the aforementioned tasks, the application is to allow each employee to check the status of his or her itinerary. The application is also to send alerts to the manager and\/or administrative assistant of the employee regarding the travel arrangements.","To create such an application, a developer has to program the application to access several types of databases and gather data, process the data, and send the processed data out to potentially several types of devices (PC, phone, PDA, Blackberry, etc.). One skilled in the art will appreciate the time that must be spent when writing the code for such an application, ensuring that all API's are properly coded to, etc.","What is needed is a method of creating an application quickly and efficiently without requiring the typical weeks and months of coding and debugging.","Another problem inherent in the prior art is that most applications are created for the desktop. In an enterprise situation, a client-server implementation is most typical. However, only one client can interact with a particular session of the software. As modern businesses expand, they will grow to rely on enterprise-wide applications. Thus, pervasive computing will become the rule.","What is needed is a way to provide pervasive (vs. desktop) applications that are accessible throughout an enterprise on various types of devices and via multiple modes of connection.","Web services (sometimes called application services) are services (usually including some combination of programming and data, but possibly including human resources as well) that are made available from a business's Web server for Web users or other Web-connected programs. Providers of Web services are generally known as application service providers. Web services range from such major services as storage management and customer relationship management (CRM) down to much more limited services such as the furnishing of a stock quote and the checking of bids for an auction item. The accelerating creation and availability of these services is a major Web trend.","Users can access some Web services through a peer-to-peer arrangement rather than by going to a central server. Some services can communicate with other services and this exchange of procedures and data is generally enabled by a class of software known as middleware. Services previously possible only with the older standardized service known as Electronic Data Interchange (EDI) increasingly are likely to become Web services. Besides the standardization and wide availability to users and businesses of the Internet itself, Web services are also increasingly enabled by the use of the Extensible Markup Language (XML) as a means of standardizing data formats and exchanging data. XML is the foundation for the Web Services Description Language (WSDL).","Several companies provide the building blocks for creating Web services. However, one problem inherent in creating Web services is that a developer is limited by the number of building blocks he or she has access to. In other words, the developer has a \u201cfixed menu\u201d of building blocks, and must write code for any additional functionality desired.","What is needed is a methodology for reusing exiting functionality rather than having to create custom applications for each desired function. Such a methodology would allow companies to leverage existing infrastructure, thereby saving money.","A developer is able to stitch together components of existing applications, including web applications, web services, legacy applications, enterprise applications, mainframe applications, WINDOWS\u00ae applications, and a JAVA\u00ae applications and is also able to add new application functionality using a variety of programming languages including Java, JavaScript and SQL, all using a visual paradigm that allows the application to be built very quickly. Using an intuitive user interface, the developer can publish the new application as a web service. The newly developed application can be made accessible on multiple devices via any type of network, wireless or Internet connection.","This process allows the application to be created quickly without requiring the developer to spend days and weeks writing code for a new application. Rather, using the processes set forth herein, selected portions of applications in an existing infrastructure can be reused to provide new functionality and applications. The developer simply interacts with the existing applications and those interactions are recorded to capture the resulting functionality.","Accordingly, a system, method and computer program product are provided for generating an application. An interaction with a first application, preferably at the user-interface level, is recorded for capturing a functionality of the first application. An interaction with a second application is also recorded for capturing a functionality of the second application. Note that the interactions may be user interactions, interactions by other applications, etc. A pattern is generated based on the recorded interactions. The pattern can be saved in memory such as in a file on a hard disk. An application is generated based on the pattern. The interactions recorded in the pattern are repeated upon replay of the pattern for providing the functionalities of the first and second applications.","This allows the application to be created quickly without requiring the developer to spend weeks and months writing code for a new application. Rather, using the process set forth above and below, selected portions of an existing infrastructure can be reused to provide new functionality and applications. The developer simply interacts with the existing applications and those interactions are recorded.","According to one embodiment, additional functionality can be added to the pattern. The pattern can be displayed on a graphical user interface, where the pattern includes a graphical representation of each interaction. According to another embodiment, when recording the interaction with one or more of the applications, an interface can be displayed. The user is allowed to specify interactions with the application(s) via the interface. The user interactions are recorded and become part of the pattern.","The application can be published as a network service accessible via the Internet, an intranet, or other network. Further, a rendering of the output from the application can be specified for transcoding and output on multiple types of devices the content can be rendered for output on multiple types of devices such as a desktop computer, a wireless telephone, a PDA, and\/or any other type of device.","A method for creating an application utilizing a graphical user interface is also provided. First, an interface is displayed. A user is allowed to specify interactions with multiple applications via the interface. These interactions are recorded. A pattern is generated based on the recorded interactions. The pattern is displayed on a graphical user interface, and the pattern includes a graphical representation of each interaction. Such graphical representation can be an icon, etc. The user is allowed to add additional functionality to the pattern. A graphical representation of the additional functionality is also displayed on the graphical user interface.","Preferably, the user is allowed to connect representations of the interactions via the graphical user interface for specifying an order of execution of the interactions in the pattern. As an option, the pattern can include prerecorded interactions. Thus, previously recorded interactions can be used as \u201cbuilding blocks\u201d for the new application, thereby avoiding the need to re-record the interaction. They are merely retrieved from storage and added to the pattern to provide functionality.","According to an embodiment, if a portion of the pattern is recognized as a prefix of an already existing pattern, a branching of the pattern is created from the already existing pattern. Also, the pattern can be coupled to another pattern to provide additional functionality. The other pattern can be a previously created pattern that has been stored. Preferably, output relating to the pattern can be specified for multiple client devices.","Once the application has been created, the pattern-based application can be executed. Upon receiving a request for data from a user or another application, a pattern for retrieving the requested data is selected based on stored information associating the pattern with the desired functionality required to obtain the requested data. The pattern has stored therein a recorded interaction with at least one external application. The interaction accesses the functionality of the external application, thereby permitting data to be obtained from the external application. The pattern is replayed to execute the recorded interaction. The recorded interaction is conducted as specified in the pattern for obtaining the requested data. The requested data is received and can be further processed and\/or output.","The received data can then be processed for output on a particular type of device as specified in the pattern, and\/or can be processed for output on multiple types of devices via transcoding.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 1","b":["100","102","104","102","104"]},"For example, a transaction, in one embodiment, may refer to: information submitted by the user, actions taken by the user, actions taken by a system enabling the access of the user to the data, actions taken by the data to retrieve\/modify content, results sent back to the user, and\/or any combination or portion of the foregoing entities.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 2","b":["200","202"]},"In one embodiment of the present invention, the transaction pattern may include a record of: information submitted by a user, actions taken by the user, actions taken by a system to generate results, and results sent to the user. As an option, the transaction pattern may include a record of actions taken by the system which enable access of the user to data, and actions enabled by the data to retrieve content. Storage in accordance with operation  may take any form with sufficient identification and description of any required step in the transaction process.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 2A","FIG. 2"],"b":["220","202"]},"During use of the present invention, such transaction pattern may be retrieved from memory when desired in operation . Thereafter, the transaction pattern is executed to carry out the transaction in an automated manner. Note operation . An execution, or playback, in accordance with operation  may include the invocation of a stored transaction pattern.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 2B","FIG. 2"],"b":["230","206"]},"A transaction pattern for any transaction need only be recorded once by anyone with sufficient system access privilege. Once recorded, any user may conduct that transaction, any number of times, by the invocation of the recorded transaction pattern, or \u201ctransaction macro.\u201d","Since a transaction macro can be stored in any fashion and invoked, directly or indirectly, by any agent (human or automated), it enables the completion of the transaction it describes in any fashion from any device.","System Architecture",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 3","FIG. 2"],"b":["200","310","312"]},"The workstation shown in  includes a Random Access Memory (RAM) , Read Only Memory (ROM) , an I\/O adapter  for connecting peripheral devices such as disk storage units  to the bus , a user interface adapter  for connecting a keyboard , a mouse , a speaker , a microphone , and\/or other user interface devices such as a touch screen (not shown) to the bus , communication adapter  for connecting the workstation to a communication network  (e.g., a data processing network) and a display adapter  for connecting the bus  to a display device .","The workstation typically has resident thereon an operating system such as the Microsoft Windows NT or Windows 2000. Operating System (OS), the IBM OS\/2. operating system, the MAC OS, or UNIX operating system. Those skilled in the art may appreciate that the present invention may also be implemented on platforms and operating systems other than those mentioned.","Applications","Following is a plurality of exemplary applications of the present invention. It should be noted that such examples are not exhaustive, and should not be construed as limiting.","Scenario I",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 4","b":"400"},"In this case, the transaction pattern includes: (i) required parameters submitted by the user (ii) the entire internal process of submission of these parameters to the database by the interface and (iii) the results returned by the database and presented to the user. Note .","Scenario II",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5","b":"500"},"In this case, the transaction pattern consists of (i) the creation and actions associated with the forms presented in the web-interface with which the user submits information (ii) the information submitted by the user, in every form in every step of the e-commerce flow (iii) the internal process whereby the submitted information is sent to the servers and databases of the e-commerce site (iv) the navigation (automatic or user determined) of the user within the e-commerce process and (v) the results returned by the e-commerce site once the submitted information has been processed. Note .","Scenario III",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 6","b":"600"},"In this case, the transaction pattern consists of (i) the creation and the action associated with the forms presented in the web-interface with which the user submits information (ii) the information submitted by the user, in every form in every step of the login and account access process (iii) the internal process whereby the submitted information is sent to the servers and databases of the user's portfolio account site (iv) the navigation (automatic or user determined) of the user within the portfolio account and (v) all the content that the user desires in every step of his navigation within the portfolio account. Note .","In all of these scenarios, the user submits and retrieves different pieces of information in multiple steps. While it is possible to submit information in this fashion from a desktop computer, it becomes increasingly inconvenient once a user tries to do so through devices other than PC's where the entry of information is not as convenient. Therefore, a process whereby a query or a transaction can be completed and the resulting content sent to the user with a minimum amount of information input and navigation, is highly desirable.","The present invention thus allows any transaction to be automated through the concept of the recording and the playback of a \u201ctransaction macro.\u201d","Dynamic Content","A description of dynamic content in the context of the present invention will now be set forth along with a comparison with static content. A computer network system has one or more host network servers connected to serve data to one or more client computers over a network.  shows a simple computer network system  with a single host network server  connected to serve data to a client  via a network . The client  sends a request for data and\/or services to the server  over the network . The server  processes the request and returns a response over the network . If the request is for data, the server  accesses a database  to retrieve the requested data  and returns the data  as part of the response.","The client-server system  is representative of many different environments. One particular environment of interest is the Internet. The server  runs a Web server software program that accepts requests from client-based programs (e.g., browsers) and returns data  in the form of Web pages or documents to the client . The Web pages are commonly written in HTML (hypertext markup language) and XML (extensible markup language). Web pages are transmitted using conventional network protocols, such as TCP\/IP (Transmission Control Protocol\/Internet Protocol), HTTP (Hypertext Transfer Protocol) and DCOM (Distributed Component Object Model). The client  executes a browser or other application to render the Web page into human-perceptible forms. A Web document might include text, images, sound, video, active code, and so forth.","Documents served from a server to client are typically generated using either or both of two methods: a static content method and a dynamic content method. In a static content method, the document is created in advance and stored statically on a server database. When a client requests the document, the server retrieves the document and transmits it over the network to the client.  is an example in which the server retrieves the static data  from database  and serves the data to the client . It is further noted that conventional servers, and particularly Web servers, may be configured to push the content to the client without receiving a request. The static content method has an advantage of minimizing the user's perceived response time, meaning the time between requesting the document and seeing it rendered on a computer screen. It has a disadvantage that all users who request the document receive exactly the same content. With static content, the server cannot respond to specific user requests or personalize a document for individual users.","In a dynamic content method, the document is generated dynamically by the server. When a client requests a document, the server invokes one or more agents, feeding the agents relevant parameters from the user's request (such as the user's name). The agent(s) generate the document that satisfies the user's request and the server returns the document over the network to the client. The dynamic content method has the advantage of responding to specific user requests or personalizing content for individual users. It has the disadvantage that the user's perceived response time will generally be longer than with static document requests. This is because the document generation process involves additional time to invoke the appropriate agent(s) and generate the document.","The server generates dynamic content documents by invoking an agent in one of two ways: an \u201cout-of-process\u201d method and an \u201cin-process\u201d method. In an \u201cout-of-process\u201d method, the agent runs in its own process and address space, separate from the server's process and address space. Typically, the out-of-process method uses the industry-standard common gateway interface (CGI) as the communication mechanism between the server and agent. In an \u201cin-process\u201d method, the agent runs within the Web server's process and address space. The in-process method typically uses a vendor-specific application programming interface, like the Internet Server Application Programming Interface (ISAPI) implemented by Internet Information Server (IIS), which is available from Microsoft Corporation.","To illustrate the two dynamic content methods and how they can be used in conjunction with the static content method, consider a scenario in which the server  runs a Web server for an online retail company. When the client  first accesses the Web site, the server  might retrieve a pre-existing home page for the company from the database  and serve that page to the client . This initial step is an example of a static content method. From the home page, the client might request to view an online catalog of products offered by the company. In response, the Web server might invoke a catalog agent to guide the user through various product offerings. When the user decides to purchase a product, the client submits an order request. In response, the Web server might invoke an order agent to assist the user in ordering the product. The steps involved with actively serving a catalog or taking an order are examples of dynamic content methods. They both involve dynamic generation of documents in response to input received from the client.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 8","b":["702","800","1","800","800","802","708","802","800","804","804","2","1","804","806","804","806","800","806","804","2"]},"The out-of-process method shown in  has an advantage in crash prevention and recovery. If the out-of-process order manager  is unreliable and ultimately crashes, it will not cause the Web server  to crash. However, the out-of-process method has a disadvantage in that a particular agent must be loaded into memory each time a request arrives for it. Using CGI technology, the agent must also be unloaded from memory once it finishes the request. This loading and unloading consumes resources, resulting in a relatively slow response time. Another problem compounding the slowness is that the out-of-process method involves cross-process communication between processes  and , including such activities as marshalling, messaging, and the like.","A variation of CGI, known as FastCGI, allows the server to keep the agent loaded, rather than terminating the agent each time it responds to a particular request. FastCGI is an improvement over CGI in that it saves the per-request invocation overhead, thereby improving the response time. However, the FastCGI is still run in a separate process, and hence the drawbacks associated with cross-process communication remain.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 9","b":["800","902","902","1","800","800","902","902","904","902","904","800","806","902"]},"The in-process method is advantageous in that a particular agent need only be loaded into memory once, when the first request arrives for it. The agent can then remain in memory within the server's process and address space, and can handle additional requests that arrive for it. The in-process method has a further advantage in that there is no need for cross-process communication. As a result, the in-process method is comparatively faster than the out-of-process method.","Pattern Recording","A preferred embodiment of the present invention gives its users the ability to create (record) functional elements called patterns and use those elements (replay) in their custom applications. A pattern consists of a collection of states. A state refers to the state of an application in its interaction by the user (the designer). States can be of different types. For example, an action that requires accessing the World Wide Web can be represented by an XML (or other type) state and an action that would require sending e-mail can be a part of an SMTP state. Each type of state has a dedicated connector, which is used to create the state definitions and operate on those states. Thus, an XML Connector Module (XCM) is the connector that aids in recording and replaying of XML states. A database connector is used to store and retrieve data from a database, but may or may not point to a next state. An HTML Connector points to a next table. For example, the HTML Connector in state A would instruct a User Agent to execute action X to access state C. The User Agent is used to fetch the output from a remote application and execute any user actions on that output.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 10","b":["1000","1002","1004","1006","1008","1010","1012","1014","1016","1018","1020","1022"]},"The system now knows how to retrieve desired information using the pattern. Accordingly, all users using the system can obtain that content. The next (or same) user that wants to perform a similar action enters the URL of the pattern by selecting it. The pattern is replayed with the User Agent executing the actions received of operation . The parts of the web page that were identified by the user and stored in operation  are returned to the user. The user can also define a default area to access in the event that a state is not recognized. See also the description below regarding state identification based on content and probability.","The information stored in a pattern may involve (i) the web or non-web interfaces presented to the user, (ii) the actions performed by the user or the system in the submission of the information, (iii) the parameters required to complete the transaction and submitted by the user, (iv) the automatic or manual navigation of the user within the transaction process, and\/or (v) the content or results returned by the system or selected by the user.","A transaction pattern for any transaction need only be recorded once by anyone with sufficient system access privilege. Once recorded, any user may conduct that transaction, any number of times, by the invocation of the recorded transaction pattern, or \u201ctransaction macro.\u201d","Since a transaction pattern can be stored in any fashion and invoked, directly or indirectly, by any agent (human or automated), it enables the completion of the transaction it describes in any fashion from any device.","Interactive Design Tool (IDT)","The Interactive Design Tool according to one embodiment allows a user to mobilize content and transactions on to multiple classes of devices. Some specific examples of the use of the IDT include:\n\n","The IDT graphical user interface provides several views according to one embodiment.","Workplaces","The first view is the Workplace view. Workplace views are the views within which the designer specifies the content and\/or transaction by example. For example, while mobilizing web content, the Web Workplace presents a browser view to the designer where the designer can indicate specific content by clicking on the areas of interest. The workplace records the usage pattern in the background. If the designer is mobilizing content stored in a database, the Database Workplace displays the appropriate database connection dialogs. Thus, the workplace is at all times, aware of the class of content\/transactions the designer is mobilizing and provides the appropriate view. The designer accesses content with multiple types of connectors. Connectors are functional blocks that allow access via various methods such as Web, database connectivity, FTP, etc.","Pattern View","The Pattern View is a view where the designer is able to manipulate the properties of the pattern. The Pattern View can also allow the designer to create a pattern manually and\/or add pattern elements directly. Several functions enabled by the Pattern View follow.","The Pattern View allows formal pattern specification. Especially for web patterns, the pattern recorded in the Workplace represents only one possible interaction path. For example, the pattern may only represent a successful login into an online account. However, in actual usage, a user may also encounter an unsuccessful login. The Pattern View is used to visually specify such alternate paths in a flowchart format. Note that formal specification may be needed not just for the web connector. For example, some connectors may require error handling alternate interaction paths. See the section on Recording Alternate Paths, below, for further details.","The Pattern View also enables cross-connector flow, including design of complex interactions that span multiple types of connectors. For example, consider an interaction that obtains content like stock quotes from the web and inserts them into a database. The two pieces of this interaction (web and database) are individually recorded within the Workplace. However, the Pattern View is where the information flow across these pieces is coupled, or \u201cglued,\u201d together.","A pattern may be divided into multiple segments. For example, a pattern which aims to check on the price using a price comparison engine and then purchase the item, might be first divided up into two segments (one for the comparison and one for the purchase). The designer can eventually link the individual segments together while applying appropriate selection and transformation using scripts.","Device Editor View(s)","The Device Editor View(s) is a view where the designer is able to specify the view and interaction of the Client Devices as it relates to the pattern under design. For example, consider a pattern for retrieving bank account information. Within the Workplace and Pattern View, the designer is able to specify how to fetch the account information while navigating through multiple web screens. In the Device Editor, the designer may specify, for example, two screens: one in which the bank account number is entered and a second where the account balance is displayed. The Device Editor View is able to accommodate design for multiple classes of devices (e.g. phones, PDAs, etc.). Further, the Device Editor View(s) can function as the screen editors for specific clients, and can depict an accurate rendering of what the client device displays.","Script Editor View","Within the Script View, the designer is able to edit Javascript to manipulate the data flow within the pattern and also serve as gluing logic.","Utility Views","These are views used to enhance the user experience and provide useful information at various points. One Utility View is a Project Explorer. The Project Explorer displays all elements defined in the project thus far in a tree format. The main branches of the tree can include: Pattern (which contains all the states defined thus far in the Pattern View grouped into segments), Scripts (all scripts defined), and\/or Session Data.","Another Utility View is a Data Explorer. Using the Data Explorer, the designer is able to create and inspect the data variables. These variables can be created for a give pattern and\/or can be predefined and provided in a database of the mobilization program. The variables can be of basic data types but also can belong to User Defined data types that can also be created via this View. These variables are available to be used in different views.","A further Utility View is a Pattern Gallery, which displays a list of available patterns that can be re-used. Various properties of the patterns (inputs, outputs, description, last modification date, etc.) can be shown.","Replay Mode (Testing and Debugging)","According to one embodiment, once a pattern has been recorded, the IDT can be used to replay the pattern. This is critical for testing and debugging the pattern. The designer will have the ability to set breakpoints, step through the pattern and set up variable watch windows to trace the execution of the pattern. Since the pattern is interpreted, it may be possible to stop at a breakpoint, change the pattern that is supposed to follow, and re-start execution of the pattern.","IDT Output","According to an embodiment, the IDT can generate XML descriptions of the pattern called Pattern XML (or other suitable name), the mobile views generated and the data transformations, etc. designed within the data view. In addition, the scripts written by the designer are also recorded. The IDT also stores the current project in a binary document (uses MFC object serialization mechanisms), which has the information of the Pattern defined so far. The project file can be called \u201cCompany Process Document\u201d (*.cpd files) or other suitable name.","More information about the IDT is provided in copending U.S. Patent Application entitled INTERFACE FOR MOBILIZING CONTENT AND TRANSACTIONS ON MULTIPLE CLASSES OF DEVICES, from which priority is claimed.",{"@attributes":{"id":"p-0108","num":"0111"},"figref":"FIG. 11","b":["1100","1102","1104","1106","1108","1110","1112"]},"The following example illustrates creation of an application for retrieving a customer identifier (ID) from a database and creating an interface for displaying the customer ID on a particular type and\/or model of device. As will be discussed in the example, the recording interface allows creation of different interfaces for different devices based on the capabilities of each.","Referring again to , a start screen  is displayed upon selection of the wizard button. The database server is selected from the drop down menu  and the Next button is selected. A database selection screen (not shown) is presented, which allows the user to select the desired database from which the desired data is to be retrieved.",{"@attributes":{"id":"p-0111","num":"0114"},"figref":"FIG. 12","b":"1200"},{"@attributes":{"id":"p-0112","num":"0115"},"figref":"FIG. 13","b":["1300","1302","1304"]},{"@attributes":{"id":"p-0113","num":"0116"},"figref":"FIG. 14","b":["1400","1402","1404","1406"]},{"@attributes":{"id":"p-0114","num":"0117"},"figref":"FIG. 15","b":["1500","1502","1504","1506"]},{"@attributes":{"id":"p-0115","num":"0118"},"figref":"FIG. 16","b":["1600","1602"]},{"@attributes":{"id":"p-0116","num":"0119"},"figref":"FIG. 17","b":["1100","1110","1702","1704","1706"]},{"@attributes":{"id":"p-0117","num":"0120"},"figref":"FIG. 18","b":["1802","1804","1806"]},{"@attributes":{"id":"p-0118","num":"0121"},"figref":"FIG. 19","b":["1900","1902","1904","1906","1908","1910"]},"For example, a database program may have a table having an output with five columns. On a PDA, perhaps only four columns can be displayed on the display. The output can be set to show only four variables. Similarly, if only two columns of the table can be displayed on a phone, the output can be set to show only two variables.","Alternate Paths","The ability to specify alternate paths is especially useful for the XML Connector. The returned page may or may not be the \u2018expected\u2019 page, i.e. the page that the designer saw during recording, or it may be some different page. For example, during recording, the designer goes to a URL which is a login page, enters a Login\/Password and can see the contents. During pattern replay, it is possible that the returned page after this interaction is a \u2018Server too busy\u2019 page. In such a situation, the designer may now want to retry for the password entry page.","To handle such a situation, the designer records the normal path using XML Connector Workplace and switches to Pattern View. From the \u2018Palette View\u2019, the designer drags and drops the XML Connector icon on the Pattern View. The designer links the login page node with this new connector node. The designer right-clicks the new connector node and selects \u2018Identify Page\u2019 from a pop-up menu. This invokes the XML Connector Workplace. The designer now browses to the alternate page and clicks \u2018identify\u2019. Details for this identify operation are provided in U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR RECOGNIZING A STATE OF A REMOTE APPLICATION, filed Aug. 28, 2001. under Ser. No. 09\/942,263.","The workplace recording allows the designer to follow a given path in a linear fashion. Consider the scenario, of the XML Connector, where in a certain state there are choices for interactions (i.e. some links to choose from) that results in different outcomes. The designer desires to cover the alternate paths too. Even if the workplace only allowed recording in a linear fashion of a single scenario, the IDT would recognize a sub-pattern that is the \u201cprefix\u201d of an already recorded pattern, and if the designer revisits the workplace and starts recording again to reach the same state that matches a previously recorded pattern and then branches off to an alternate path, the workplace would still show a linear recording but the IDT would recognize the prefix and eventually insert the branching off from the prefix in the Pattern View.","Illustrative System Architecture for Pattern Replay",{"@attributes":{"id":"p-0123","num":"0126"},"figref":"FIG. 20","b":["2000","2002"]},"A Request Handler (RH)  communicates with a user device . The RH manages requests from the user device, routing them to the appropriate system component. When a user requests a transaction, the request is sent to a Pattern Replay Engine (PRE) , which replays a pattern for conducting one or more transactions with other applications ,  to provide functionality. More information about the PRE is set forth below.","The State Recognition Module (SRM)  determines which state a website is in based on its current output, such as a structure of the current output. The SRM may communicate with a Content Recognition Module , which recognizes individual documents that can comprise a state.","A Connector  is in communication with the SRM. The Connector executes a state in the pattern.","The User Agent  is used by other components of the system to provide the actual interaction with a remote application. For example, when replaying a pattern, the SRM communicates with the User Agent via the Connector to provide instructions to the User Agent. The other system components have intelligence built into them that instructs them how to utilize the User Agent. For example, when a user clicks on a button on a page, other components instruct the User Agent to navigate to the desired application and perform some action, such as filling in a form. The User Agent retrieves the resulting output from the application and returns it to the other components.","By default, the User Agent is not running. A listener (not shown) listens for requests. When the listener receives a request, it creates a new User Agent process on the server and returns an identifier that identifies the User Agent process. Subsequently, client processes use the identifier, go to the specific User Agent and instruct it to perform some action. The User Agent performs the action according to the instructions and returns the results of the action.","Content is retrieved from a remote application and is sent to a specific device in a format suitable for that device. The formatting is done by another module, namely, the Transcoding Page Rendering Engine (TRE). A Content Retrieval Module (CRM) (not shown) retrieves the content as an XML stream for use by the other system components. Components that directly use the CRM are the State Recognition Module (SRM) and the Interactive Development Tool (IDT). More information about operation and functionality of the Content Retrieval Module is found in copending U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR RETRIEVING ARBITRARY CONTENT FROM A REMOTE DATA SITE FOR OUTPUT TO A DEVICE IN A FORMAT SUITABLE FOR THAT DEVICE, filed Aug. 28, 2001. under Ser. No. 09\/942,262, which is herein incorporated by reference.","The Transcoding Page Rending Engine (TRE)  renders content for display on the user device. Preferably, the TRE is able to render content on any display environment.","Pattern Replay Engine (PRE) ","The Pattern Replay Engine (PRE) is a component that is responsible for replaying a pattern from one particular state to another during runtime.",{"@attributes":{"id":"p-0132","num":"0135"},"figref":"FIG. 21","b":["2006","2104","2106","2108","2110"]},"The PRE is a request-driven component. The PRE takes the request to make a transition from a particular State. Transitions from one State to another are made by executing Actions. The PRE communicates with the appropriate Connector (of the current State) to execute the current Action in the request and get the new resulting State. Next, all Script associated with the State is evaluated.","The PRE then calls the Transcoding Page Rendering Engine (TRE) to \u201cflush\u201d its output to the device. This means that any Content, which has been queued for display in the TRE (while processing the request), is sent to the device. Every state can potentially generate output to be displayed on the device, including internal states. This is a desirable feature as it means the designer can send a status message to the device, e.g. \u201cPlease wait while processing . . . \u201d etc. Finally, a script is called, which can initiate further State transitions from this script method if necessary.","More information about operation and functionality of the PRE is found in U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PATTERN REPLAY USING STATE RECOGNITION, from which priority is claimed.","Transcoding Page Rendering Engine (TRE) ","The Transcoding Page Rendering Engine (TRE) is a tool used to render content on any display environment.",{"@attributes":{"id":"p-0137","num":"0140"},"figref":"FIG. 22","b":["2200","2202","2204","2206","2208","2210","2212"]},"Note that the TRE can process other types of output, such as audio, etc.","More information about operation and functionality of the TRE is found in U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR PAGE RENDERING UTILIZING TRANSCODING, filed non-provisionally Aug. 28, 2001. under Ser. No. 09\/942,051. and assigned to common assignee Clickmarks, Inc., and which is herein incorporated by reference.","Pervasive Computing Through Interaction Level Programming","Interaction Level Programming (ILP)\u2014Interaction Level Programming is the act of creating a software application, using the user-interface (UI) of another program as the Application Program Interface (API). Because many applications that do not expose an API, do expose a UI, ILP allows many more applications to be re-factored into e.g. mobile applications, web applications, and web services. ILP effectively turns the application UI into an API.","Visual Interaction Level Programming (VILP)\u2014Visual ILP is the act of visually creating a program using the UI of another application. The programmer interacts with the application via the application's user interface as they normally would. In addition, the programmer visually instructs the ILP system what actions to carry out, and what UI elements to extract from the application. The user's interactions are recorded by a tool such as the IDT described above. The recorded interactions may then be replayed.","When replayed by the ILP system, the resulting program carries out the specified actions against the application's user interface, and exposes the specified UI elements to the program for use in its user interface.","For clarity, the present discussion will refer primarily to ILP, it being understood that the discussion applies equally to VILP.","The new application created via ILP can expose different interfaces, including user interfaces, and\/or programming interfaces (API), allowing the new application to be used in completely new environments and computing systems. For example, ILP could be applied to an IBM 3270. mainframe application, to create a new application that allows mobile users to enter information into the 3270. application from their web-enabled cell phones. All this is done without changing the original 3270. application in any way whatsoever, thus providing complete flexibility in integrating different applications together without having to modify said applications.","Finite State Machine","According to a preferred embodiment, ILP works by modeling the application as a finite state machine (FSM), where each state is the UI presented by the application at a given time. Transitions between states are made by performing a sequence of actions on the UI, known as an event stream. The exact definition of a state in the FSM is determined by the ILP programmer.","A state in the FSM is defined by the UI elements present in the UI of the application at a given point in time. The presence of UI elements can be given different weights, thus allowing slightly different UI screens to be treated as the same state by the ILP system. This flexibility allows the user to simplify the FSM, as it does not need to contain as many states as there are different UI screens. For example, two UI screens that differ only in background color can be represented as the same state in the FSM.","State Recognition","The ILP system recognizes at runtime what state in the FSM the application is actually in. The state is recognized using a heuristic search that computes the recognition score of each possible state based on the weighted presence or absence of UI elements in the application. For example, suppose that after a given transition, the FSM could be in potentially one of 2. states. In one state, a certain UI element, say a button, must be present for the FSM to be in that state. In the other state, that same button must not be present. Thus the system evaluates the recognition score for each state, and picks the best one, in this case, depending on whether or not the button is present.","State recognition is important, because it allows for tremendous flexibility in constructing the FSM. For example, suppose that in a certain state, the user is expected to enter a text value into an entry field, and then press a submit button. 99% of the time, the application ends up in state A upon pressing the button. But if the user enters a certain value in the entry field, the application ends up in state B instead. These states may be very different from each other. For example, consider a simple login form in a typical web application. If the user enters the correct user name and password she is taken to a page displaying some personal information. If not, the user is prompted to try again for a few times, and after that is told that they must contact technical support. In all cases the user carries out the same actions (enter username and password, press submit) but ends up in 3. potentially different states. Because the logic of which state the user will end up is embedded in the application, there is no easy way to express this fact when constructing an external model of the application. Instead, the model simply indicates that pressing the submit button in the login state can lead to 3. possible states. Which of the states was actually reached is determined at runtime by the ILP system.","Performing Actions on a State","Once the system determines what FSM state it is in, it carries out the actions defined for that state, and if the actions result in a state transition, it again recognizes the FSM state, and so on. The actions that can be performed on a given state are:","Send UI events to the application (e.g. push button , enter a value into field , etc.). Extract UI elements from the application (e.g. extract an HTML table from a website). Create UI widgets tied back to the application (e.g. create a form widget that corresponds to a form in the application).","Together, these actions allow the user of the ILP system to create a new application or \u201cprogram\u201d that derives part or all of its functionality from the original application.",{"@attributes":{"id":"p-0152","num":"0155"},"figref":["FIG. 23","FIG. 20"],"b":["2302","2304","2306","2308"]},"This process allows the application to be created quickly without requiring the developer to spend days and weeks writing code for a new application. Rather, using the processes set forth herein, selected portions of applications in an existing infrastructure can be reused to provide new functionality and applications. The developer simply interacts with the existing applications and those interactions are recorded to capture the resulting functionality. The developer no longer needs to code to API's. Rather, the methodology presented herein goes above API's, to the interaction level, thus making it easier to call the functionality of the existing infrastructure.",{"@attributes":{"id":"p-0154","num":"0157"},"figref":"FIG. 24","b":["2400","2402","2404","2406"]},"When recording the interaction with one or more of the applications, an interface can be displayed to allow a user to specify interactions with the application(s) via the interface. The user interactions are recorded and become part of the pattern as the user interacts.","In operation , an application is generated based on the pattern. The interactions recorded in the pattern are repeated upon replay of the pattern for providing the functionalities of the first and second applications. In optional operation , the application is published as a network service accessible via the Internet, an intranet, or other network.",{"@attributes":{"id":"p-0157","num":"0160"},"figref":["FIG. 25","FIGS. 11-19"],"b":["2500","2502","2504","2506","2508","2510","2512"]},"With continued reference to , the user is allowed to add additional functionality to the pattern in operation . In operation , a graphical representation of the additional functionality is displayed on the graphical user interface. Thus, by creating a pattern with recorded interactions and additional functionality, a developer has created an application that can be used and reused.","As an option, the pattern can include prerecorded interactions. Thus, previously recorded interactions can be used as \u201cbuilding blocks\u201d for the new application, thereby avoiding the need to re-record the interaction. They are merely retrieved from storage and added to the pattern to provide functionality.","As another option, the pattern can be coupled to another pattern to provide additional functionality. The other pattern can be a previously created pattern that has been stored or another pattern created jointly.","Preferably, output relating to the pattern can be specified for multiple client devices. This can include specifying which output is actually sent to a particular type of device, as well as the format of the output for particular types of devices.","Once the application has been created, the pattern-based application can be executed.  provides a flow of execution  of the pattern-based application. Upon receiving a request for data from a user or another application in operation , a pattern for retrieving the requested data is selected in operation  based on stored information associating the pattern with the desired functionality required to obtain the requested data. The pattern has stored therein a recorded interaction with at least one external application. The interaction accesses the functionality of the external application, thereby permitting data to be obtained from the external application. In operation , the pattern is replayed to execute the recorded interaction. In operation , the recorded interaction is conducted as specified in the pattern for obtaining the requested data. The requested data is received in operation . The received data can be further processed and\/or output. Note operations  and . For example, the received data can then be processed for output on a particular type of device as specified in the pattern, and\/or can be processed for output on multiple types of devices such as a desktop computer, a wireless telephone, a PDA, and\/or any other type of device. This can be done by transcoding the output as described above.","Consider the following example of a logistics application. A company is currently using the following system. A truck driver delivers goods and notes the delivery on a sheet, returns to headquarters, and gives sheet to data entry. If there were problems or he was unable to deliver the goods, he writes the details on the sheet and data entry sends an email to a manager.","The company wants to automate this process. The desired application is to have the following parameters. The driver is to be given a PDA or voice phone (for communicating via a voice portal, as described in copending U.S. Patent Application entitled VOICE APPLICATIONS AND VOICE-BASED INTERFACE, filed Sep. 14, 2001. under Ser. No. 09\/952,909, and which is herein incorporated by reference). The driver is to enter a status or problem via the PDA or voice phone. The information is either entered in database, or sent to report generation, which creates a report and sends it to a manager. The manager is to be able to check status\/reports on a desktop.","To perform all of these functions, the application must interface with a backend resource management system (how company resources are being used), and go into a customer management system (customer database) to see if the customer is not available at a particular delivery time or has billing issues. The application must also be able to communicate with the driver's device, whether connected or disconnected. Also, the application must be capable of generating an alert to the manager.","To create such a pervasive application in the prior art method, the developer must learn about and write code for the PDA (Palm Pilot, etc). Code must also be written to handle the transactions that occur when the driver interacts and his data comes to the application on the server. A connection to the databases must be opened and the driver's communications written in. Further, the developer must write code that checks for exceptions written by someone (for example, if delivery doesn't happen by this time, send alert) via an administrative interface created by someone. Then if someone (manager) wants to log on through a desktop, the developer must create an interface for that too. Thus, the developer has to write a lot of software.","According to the methodology presented herein, a pervasive application connecting all of these applications and devices can be quickly built and implemented. Using the IDT, the developer merely needs to interact with the various devices and programs. The IDT captures the interactions, which are then used to create a pattern or patterns.","A form presented on the PDA can be generated using the publisher for mobile devices described in U.S. Patent Application entitled SYSTEM, METHOD AND COMPUTER PROGRAM PRODUCT FOR A CONTENT PUBLISHER FOR WIRELESS DEVICES filed Jul. 10, 2001. under Ser. No. 09\/902,929, and which is herein incorporated by reference. The driver can enter information on the form, which is transmitted to the new application via an existing communications program. The developer interacts with the existing communications program in such a way that the desired data is obtained. The developer's interaction is recorded and placed in a pattern, as described above. Upon replay of the pattern, the desired data is again retrieved. See  for a description of capturing interactions with databases. To create the alerts, the developer interacts with an email program, entering delivery and content information. Again, this interaction is recorded and placed in the pattern. The developer is then able to set criteria for which alert is sent upon receipt of information from the driver.","Transaction Object Model (TOM)","One embodiment allows developers to create transaction objects, which they can use as building blocks to create applications. In sharp contrast to the prior art, the methodology set forth herein overcome the \u201cfixed menu\u201d drawback of prior art systems and allows a developer to use any existing functionality by capturing it in a pattern.","Any software application can be seen as a set of functional flows. Each transaction can be seen as a transaction object. The transaction objects are captured and converted into building blocks that a developer can use and reuse. The developer no longer needs to select from a predefined set of building blocks, but can capture the blocks from any application. Now, the entire universe of applications provides building blocks. Any portion of any application by anyone can become a building block.","The developer selects the desired blocks and writes some code around the block (if necessary) to create a new application. Further, the system is flexible, allowing the developer to add and remove blocks at will.","Simple Object Access Protocol (SOAP) is a way for a program running in one kind of operating system (such as Windows 2000) to communicate with a program in the same or another kind of an operating system (such as Linux) by using the World Wide Web's Hypertext Transfer Protocol (HTTP) and its Extensible Markup Language (XML) as the mechanisms for information exchange. Since Web protocols are installed and available for use by all major operating system platforms, HTTP and XML provide an already at-hand solution to the problem of how programs running under different operating systems in a network can communicate with each other. SOAP specifies exactly how to encode an HTTP header and an XML file so that a program in one computer can call a program in another computer and pass it information. It also specifies how the called program can return a response.","SOAP was developed by Microsoft, DevelopMentor, and Userland Software and has been proposed as a standard interface to the Internet Engineering Task Force (IETF). It is somewhat similar to the Internet Inter-ORB Protocol (IIOP), a protocol that is part of the Common Object Request Broker Architecture (CORBA). Sun Microsystems' Remote Method Invocation (RMI) is a similar client\/server interprogram protocol between programs written in Java.","An advantage of SOAP is that program calls are much more likely to get through firewall servers that screen out requests other than those for known applications (through the designated port mechanism). Since HTTP requests are usually allowed through firewalls, programs using SOAP to communicate can be sure that they can communicate with programs anywhere.","System Architecture",{"@attributes":{"id":"p-0175","num":"0178"},"figref":"FIG. 27","b":["2700","2702","2704","2706","2708","2710"]},"Application Instances ","Each application instance represents an interactive session, generally corresponding to a single user of the ILP application. Note that in client-server applications, only multiple client instances are needed. Each application instance can be a pattern, as described above.","Instance Manager ","The Instance Manager (IM) allows the system to scale to a large number of simultaneous users. For each user interaction, the system requests an application instance from the IM. Because application instances may be expensive (generally an entire operating system process is required for each instance) the IM may implement instance pooling, where application instances are re-used across users. The IM preferably separates instances so that instances do not pollute each other.","UI Converter ","The UI Converter (UIC) takes a \u201csnapshot,\u201d of the application's UI state, and converts it to a representation that is used for state recognition. The \u201csnapshot\u201d can be an identification of selected items and\/or features of the UI (UI elements), a graphical image of the screen, the table structure of the UI state, etc.","Application Server ","The Application Server carries out the ILP application's logic, including state recognition, and performing the specified actions at each state. The application server also serves as a platform for accessing the ILP application via e.g. HTTP, SOAP, etc. Thus, the application server can include a state recognition module (described above) and a pattern replay engine (described above).","Visual Tool ","The Visual Tool allows the use of VILP, where the programming is done visually by interacting with the application. The user can visually designate states and actions, and record events as they are performed against the application to be replayed at runtime. In a preferred embodiment, the visual tool is an IDT, mentioned above.","Scalability","Because ILP accesses the application through the user interface, a large amount of system resources are potentially used up by each ILP user session. Note however, that the current model for distributed computing is that each user has a fairly powerful desktop machine that runs the client, while a high-powered server processes client requests. Thus a worst-case scenario might require that for each ILP user session a single desktop workstation is required to run the application. In fact the ILP system allows multiple user sessions to be created on a single server machine. So, in fact, ILP is more scalable than current distributed computing practices. Compared to the cost of even thin-client terminals such as PDAs, the cost of using ILP to enable these new client terminals to access existing applications is small. If a $1000. server can support 10. simultaneous users, that is a cost of $100. per simultaneous user. The actual cost per user is even lower unless all users are always simultaneously accessing the system. Compared to a low-end PDA, which would cost $100, this is minimal. And compared to the development costs of replacing the application, or integrating it with other applications at the source code level, ILP is a very favorable choice.","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 7-9"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 13","FIG. 11"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 14","FIG. 11"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 15","FIG. 11"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 16","FIG. 11"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 17","FIG. 11"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 18","FIG. 17"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 19","FIG. 11"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 27"}]},"DETDESC":[{},{}]}
