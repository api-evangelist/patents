---
title: Rendering images in a remote web browser
abstract: A processing device receives graphical output data from an application. The processing device generates, based on the graphical output data, at least one of an image or a drawing command that is formatted for an application programming interface (API) of a web browser. The processing device then transmits at least one of the image or the drawing command to a web browser instance executing on a remote client device, wherein the web browser instance is natively capable of rendering at least one of the image or the drawing command to a display on the remote client device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08941673&OS=08941673&RS=08941673
owner: Red Hat, Inc.
number: 08941673
owner_city: Raleigh
owner_country: US
publication_date: 20111108
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE PRESENT INVENTION"],"p":["Embodiments of the invention relate to image rendering, and more specifically to performing image rendering on a remote device using standard APIs included in web browsers.","There are numerous remote desktop systems that enable a user of a client machine to interact with an application running on a server machine. However, these remote desktop applications generally require the installation of agents on the client machine. The agents typically communicate with the server machine using proprietary communication protocols to receive image data for rendering on a local display and for sending mouse commands and keyboard commands to the server machine.","Methods and systems for performing image rendering on a remote device using standard APIs included in a web browser running on the remote device are described herein. In one embodiment, a processing device receives graphical output data from an application. The processing device generates, based on the graphical output data, an image and\/or a drawing command that is formatted for an application programming interface (API) of a web browser. In one embodiment, the processing device generates a first rendering of the graphical output data in a first buffer based on the graphical output data, and generates the image and\/or drawing command from the first rendering. In one embodiment, the processing device compares the first rendering in the first buffer to a second rendering in a second buffer, wherein the second rendering reflects a current rendering in the display on the remote client device. The processing device may then determine differences between first pixel values of first pixels in the first rendering and second pixel values of corresponding second pixels in the second rendering based on the comparison. In such an embodiment, the generated image comprises the differences between the first pixel values and the second pixel values, and the drawing command comprises a command to add the differences to corresponding pixels of the current rendering in the display. The processing device may update the second rendering in the second buffer based on the first rendering in the first buffer. The processing device transmits at least one of the image or the drawing command to a web browser instance running on a remote client device, wherein the web browser instance is capable of natively rendering the image and\/or the drawing command to a display on the remote client device (e.g., using the API without any additional application, extension or plugin).","Embodiments of the present invention enable an application running on a server machine to render image data in a display of a remote client device and to receive input commands (e.g., mouse commands and keyboard commands) from the client device using standard APIs of a web browser running on the client device. Therefore, embodiments of the present invention enable remote application usage within a web browser instance without the installation of any agents, extensions, plugins or other applications on the client device. Additionally, no changes typically need to be made to the application running on the server machine to enable the application to render image data within the browser.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","100","105","110","115","115"]},"Client computing device (hereinafter referred to simply as client)  may be a computing device such as, for example, a desktop computer, laptop computer, rackmount server, blade server, cellular phone, personal digital assistant (PDA), tablet computer, netbook, etc. In one embodiment, client  includes a browser . Browser  is an application that enables client  to display and interact with text, images, and other information provided by servers. Browser  may be a web browser configured to display web pages (e.g., by using hypertext transfer protocol (HTTP), extended markup language (XML), JavaScript, etc.) and receive and\/or consume other web based content (e.g., digital videos, digital music, remote services, etc.).","In one embodiment, browser  supports hypertext markup language 5 (HTML5). Accordingly, in one embodiment, browser  includes a JavaScript application programming interface (API) , a canvas element application programming interface (API)  and a web sockets API . The JavaScript API  enables use of the JavaScript scripting language that runs applications and other code inside of a sandbox. The sandbox is a security mechanism for separating running applications, and provides an isolated execution environment for the applications. Using the JavaScript API , the browser  may download JavaScript code from a remote server and run the JavaScript code within the JavaScript sandbox.","The canvas element API  enables the browser  to perform dynamic, scriptable rendering of two dimensional (2D) shapes and bitmap images in a display. The canvas element API  provides scripts with a resolution-dependent bitmap canvas. This bitmap canvas can be used to render any bitmap images in a window included in a display.","The web sockets API  enables bi-directional and full-duplex communications over a single transmission control protocol (TCP) socket. Via an active web socket connection, browser  may receive data (e.g., images and commands) from a remote server without first sending a request to the remote server. Images may also be received in response to sending requests.","Server computing device (hereinafter referred to simply as server)  may be a computing device such as, for example, a desktop computer, laptop computer, rackmount server, blade server, cellular phone, personal digital assistant (PDA), tablet computer, netbook, etc. Server  hosts one or more applications  that may provide services to client . Some applications  may be traditional server applications that provide services such as database services, systems management services, network monitoring services, transactional services, webpage viewing services, etc. to client . Other applications  may be applications that were not designed to serve data to remote clients (e.g., applications that cannot be directly accessed via a network). For example, applications  may include word processing applications, spreadsheet applications, email applications, games, or any other applications that are designed to receive inputs (e.g., mouse inputs and keyboard inputs) from local input devices and to provide outputs (e.g., graphical outputs and audio outputs) to local output devices (e.g., to a local display).","Server  includes a remote rendering module . Remote rendering module may be a standalone application, a plugin, an extension, a library, or some other software or firmware construct. In one embodiment, the remote rendering module  is a component of a rendering library such as a user interface rendering library. A rendering library is a set of instructions that can be used by applications to render images. The rendering library can be used to provide a visual environment for interacting with a computing device. Rendering is the process of generating an image from a model and\/or additional graphics data. One example of a rendering library is the C library of user interface toolkit (GTK). Remote rendering module  receives graphics data from applications , and causes the graphics data to be rendered within a browser window of browser  using native APIs included in browser . The received graphics data may be API calls to a native user interface API (e.g., GTK). The API calls may be to draw lines, draw rectangles or other shapes, fill in areas with specified colors, gradients or source images, and so on. In one embodiment, an application  generates the graphics data and provides the graphics data to the remote rendering module  in the same manner that the application would typically provide graphical output data for rendering on a local display. For example, the remote rendering module  may replace a library and\/or interface layer that renders graphical output data to a local display. Alternatively, or in addition, remote rendering module  may intercept graphical output data that will be rendered on a local display of server  (e.g., graphical output data sent to a library or interface layer). No changes to the application  are typically necessary to enable the application to render graphical output data to client . For example, application  may be a freshly installed Microsoft Word application with no plugins, extensions or other modifications.","Remote rendering module  performs one or more operations based on the received graphical output data (e.g., based on received API calls to a user interface API). These operations may include generating an image and\/or a drawing command. In one embodiment, the image is a bitmap image. The drawing command may be formatted for the canvas element API . In one embodiment, the drawing command is a command to render the generated image on a display within a window of a web browser.","In one embodiment, remote rendering module  includes a server component . The server component  may handle communications to and from browser  on client . In one embodiment, the server component  is configured to receive input commands from the browser . Such input commands may include mouse commands, keyboard commands, scrolling commands, etc. Browser  may send these input commands to server component  as client  receives user inputs (e.g., when a user presses a key or moves a mouse). Server component  is additionally configured to send data to browser . The data sent to browser  may include JavaScript code, images, drawing commands, and\/or other types of data (e.g., traditional html code). The drawing commands and images may be sent to the browser  in response to requests from the browser . Server component  may also send the images and drawing commands to the browser  unsolicited via a bi-directional connection. The bi-directional connection may be a web sockets connection that has been set up using the web sockets API .","In one embodiment, remote rendering module  causes the browser  to maintain an image cache . The image cache  may include a specified number of images. In one embodiment, the image cache  holds those images that were most recently received by browser  from remote rendering module . In one embodiment, the image cache  holds specified commonly used images (e.g., button graphics, window border graphics, etc.). For images that are stored in the image cache , remote rendering module  may direct the browser  to render specified images from the image cache  rather than resending those images to the browser . This may reduce bandwidth usage and network traffic.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","140","200","205","210","215","220","225","230","235"]},"Server component  is preferably a bare bones server module having a small footprint (e.g., low memory requirements and\/or low processor requirements). However, embodiments of the present invention work equally well with other types of server components (e.g., server components that have many features and consume significant memory and\/or processor resources). Server component  is configured to serve content from an application to a remote client. Server component  establishes a connection with a remote client upon a connection request from the client. In one embodiment, the connection is a bi-directional communication connection established using web sockets. Accordingly, server component  can send data to the client without first receiving a client request. This may enable remote rendering module  to send periodic or continuous display updates to the client.","In one embodiment, server component  downloads JavaScript code  to the client. This may be performed using a regular hypertext transport protocol (HTTP) request. A web browser running on the client may execute the JavaScript code inside of a JavaScript sandbox, which then sets up a bi-directional connection. The JavaScript code may include functions for generating and maintaining an image cache, for executing drawing commands generated by the remote rendering module , and\/or for performing other operations.","Once server component  has an active connection with a client (e.g., with a web browser running on a client), server component  receives input commands from the client as a user moves a mouse and\/or presses keys on a keyboard. Server component  provides these input commands to an application connected to remote rendering module . The application may perform actions in response to the input command, and may generate graphical output data. The application may also generate graphical output data based on internal operations of the application that are not responsive to inputs from the client. Remote rendering module  is configured to process the graphical output data, and server component  is configured to send a result of that processing to the client device, as described below.","Remote rendering module  receives or intercepts graphical output data from the connected application. The graphical output data includes instructions for drawing images such as buttons, shapes, text, etc. In one embodiment, the graphical output data includes instructions for drawing a window for an application, including all buttons, text, scrollbars, toolbars and other 2D graphics included in the window. The graphical output data may be formatted according to a protocol used by a graphical API, framework or toolkit. For example, the graphical output data may be formatted as calls to the drawing API in the user interface toolkit (GTK) for rendering to a display. These calls may include API calls to perform actions such as draw lines, draw rectangles or other shapes, fill areas with specified colors, gradients or source images, and so on.","Renderer  renders the received graphical output data to a first memory buffer  to generate a first rendering . The first memory buffer  includes a designated memory space, which may be a volatile memory (e.g., random access memory (RAM). In one embodiment, the first rendering  is an image bitmap generated from the graphical output data.","Image generator  generates an image based on the first rendering . The image generated by image generator  has a format that can be processed by an API of a web browser. For example, the image may have a format that can be processed by the canvas element API. In one embodiment, the generated image is a portable network graphics (PNG) file. However, the image may have another raster graphic file format, such as graphics interchange format (GIF), tag image file format (TIFF), BMP, JPEG, etc. Alternatively, the image may have a vector graphic format such as scalable vector graphics (SVG) format, vector markup language (VML) format, Windows metafile (WMF) format, etc.","In one embodiment, second memory buffer  stores a second rendering  that reflects a current rendering in a browser window on a display of a remote client device. The second rendering  in one embodiment is an image bitmap generated from previous graphical output data received from the application. In one embodiment, image generator  compares pixel values of pixels in the first rendering  to pixel values of corresponding pixels in the second rendering . Each pixel value may describe how bright a pixel is and\/or what color the pixel is. The color information may be a set of red, green and blue color values. For example, the first rendering  and second rendering  may each be renderings of rectangles that are 380 pixels by 420 pixels, and thus include 159,600 pixels. Rendering comparator  may compare pixel  from the first rendering to pixel  from the second rendering, pixel  from the first rendering to pixel  of the second rendering, and so on. In one embodiment, image generator  subtracts pixel values of pixels from the first rendering from pixel values of corresponding pixels in the second rendering to generate an image file. Pixels from the first rendering that match corresponding pixels from the second rendering represent images that are unchanged by a display update, and have a difference value of zero. For example, the first rendering and second rendering may each include the same application buttons at the top of the rendering. In such an instance, the resultant pixel values for pixels representing the application buttons may include a 0 intensity, 0 red, 0 green and 0 blue since the image of the buttons is unchanged. The image file generated based on pixel value differences may be much smaller than a standard image file. For example, image files with a large number of zeros can be compressed very efficiently.","Command generator  generates a drawing command. The drawing command, when executed by a web browser, will cause the web browser to render a specified image to a window on a display of a client device. Typically, the specified image will be an image generated by image generator . In one embodiment, command generator  generates a command to render an image that was generated based on differences between pixel values of pixels in the first rendering  and pixel values of corresponding pixels in the second rendering . In such an embodiment, the drawing command directs the web browser to add the pixels values of pixels in the image to current pixel values of corresponding pixels in a current rendering. This is in contrast to a conventional drawing command, which discards existing pixel values and replaces the discarded pixel values with new pixel values.","Once the image and\/or drawing command are generated, server component  transmits the image and\/or drawing command to the remote client. Server component  may initiate communication with the client via a bi-directional connection, and may send the image and\/or drawing command to the client in the communication.","In one embodiment, image cache manager  maintains an image cache . In such an embodiment, a client is also made to maintain a copy of the image cache . The image cache  maintained by image cache manager  and the client's image cache may maintain synchronization by having the same cache size, cache advancement policies, cache ordering policies and\/or cache eviction policies. The image cache  may include a specified number of recently generated images. For example, the image cache  may include the 100 most recently generated images. In one embodiment, the image cache  has a first in first out (FIFO) cache eviction policy. In another embodiment, images are ordered in the image cache  based on a number of times the images have been used. For example, an image that was used 30 times would stay in the image cache longer than an image that was used only twice.","In one embodiment, the image cache  includes a set of pre-generated images. These pre-generated images may be associated with a particular application. In one embodiment, image generator  maintains a record of the number of times that particular images are used by an application. This record may be based on the contents of the image cache  during different stages of previous sessions between the remote rendering module  and clients. For example, contents of the image cache  may be recorded periodically and\/or at the end of a session. Those images that are most frequently used (and thus that are in the set of pre-generated images) may automatically be downloaded to a client when a new session is established with the client for a particular application. In one embodiment, the image cache  includes a first fixed cache portion that includes the pre-generated images and a second dynamic cache portion that includes the most recently used images. Alternatively, the image cache may be preloaded with the pre-generated images, and the pre-generated images may later be replaced via cache eviction policies.","If an image cache  is maintained by image cache manager , then image generator  may compare generated images to cached images in the image cache. If a generated image (or a portion of a generated image) matches an image in the image cache, then that image (or that portion of an image) does not need to be resent to the client. Accordingly, if a generated image matches a cached image, then the generated command includes an identification of the image (or image portion) and coordinates indicating where that image (or image portion) should be placed in a rendering. Since image cache  matches an image cache on the client, command generator  may identify the image by an identified position in the image cache (e.g., image 4 in the image cache). Use of the image cache may reduce a bandwidth usage and reduce latency.","One common operation in many applications is a scrolling operation. In a scrolling operation, often at least a portion of the displayed rendering is simply repositioned (e.g., transposed vertically or horizontally). In one embodiment, remote rendering module  includes a scrolling responder  to optimize image generation and command generation for scrolling commands. Scrolling responder  may listen for scrolling commands. A scrolling command is a higher level command than a mouse command or keyboard command. Accordingly, scrolling responder  may listen for scrolling commands at the application level. If a scrolling command is identified, scrolling responder  determines a scrolling direction and a number of pixels scrolled from the scrolling command. Scrolling responder  may also identify an area of the rendering (and thus of a display on the client) that is affected by the scrolling command. Command generator  uses this information to generate a command to copy a portion of a current rendering in a display on the client (e.g., the second rendering ) and pasting the portion to a new region of the rendering that is transposed from the copied portion by the determined number of pixels in the determined scrolling direction. Therefore, the web browser on the client may use the current rendering to render a portion of the display. This reduces an amount of image data that is sent to the client in response to a scrolling command.","There are other instances than scrolling in which an image is repositioned from a first region in a display to a second region. For example, any animated graphics may include images that move around in the display. In one embodiment, image analyzer  analyses first rendering  and second rendering  to identify shared images in the two renderings. Standard image analysis techniques may be used to perform the analysis. Image analyzer  may identify images that are in different locations in the first rendering  than in the second rendering . When image analyzer  identifies such images, image analyzer notifies image generator  and command generator . Image generator  may then exclude such images from a generated image, and command generator  may generate a command to copy an image from a first region of the second rendering  and copy the image to a second region based on the image analysis.","In one embodiment, images generated by image generator are compressed images such as PNGs. In another embodiment, the images are uncompressed images. In such an embodiment, remote rendering module  may compress an entire data stream that will be sent to the remote client. This may include multiple images, commands and\/or additional data. By compressing the entire stream together, greater compression efficiency may be achieved.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIGS. 3-7","FIGS. 3-7","FIG. 2","FIGS. 3-7","FIGS. 3-7"],"b":"200"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["300","300","305","300","310"]},"At block , processing logic generates an image and\/or drawing command that is formatted for an API of a web browser based on the first rendering. Accordingly, the web browser is natively capable of rendering the image and\/or drawing command. In one embodiment, the image and\/or drawing command are formatted for processing by a canvas element API of a web browser. Various embodiments for generating the image and\/or drawing command are described below with reference to . Returning to , at block , processing logic transmits the image and\/or drawing command to a web browser instance running on a remote client device. Processing logic may receive new or updated graphical output data periodically or continuously. Accordingly, method  may be repeated until a connection to the client device is terminated or the application is terminated.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4","b":["400","400","315","300"]},"At block  of method , processing logic compares a pixel of a first rendering in a first buffer to a corresponding pixel of a second rendering in a second buffer. At block , processing logic subtracts a pixel value of the pixel in the first rendering from a pixel value of the pixel in the second rendering. The method then proceeds to block , at which processing logic determines whether all pixels from the first rendering have been compared to corresponding pixels of the second rendering. If there are additional pixels to be compared, the method returns to block . If there are no additional pixels to compare, the method continues to block .","At block , processing logic generates an image based on resultant pixel value differences between pixels of the first rendering and corresponding pixels of the second rendering (based on the subtraction results). At block , processing logic updates the second rendering in the second buffer based on the first rendering in the first buffer. In one embodiment, processing copies the first rendering and pastes it into the second buffer. At block , processing logic generates a drawing command to add pixel values of the generated image to current pixel values of corresponding pixels in a current rendering in a display on a remote client.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 5","b":["500","300","400","510","530","500","315","300"]},"At block  of method , processing logic intercepts a scrolling command from a web browser instance. The scrolling command may be based on a mouse command and\/or keyboard command that will cause an application to perform scrolling. At block , processing logic determines a number of pixels to be scrolled in response to the scrolling command. Processing logic additionally determines a scrolling direction. At block , processing logic determines an area of a display that will be affected by the scrolling command. This may include determining an area of a current rendering that will be affected by the scrolling command. For example, the rendering may include graphics for a window border, application buttons, etc. that are not changed as a result of the scrolling command. However, the rendering may include shapes, text, tables, etc. that will be affected by the scrolling command.","At block , processing logic generates a copy command that will cause a remote client to copy contents from a first region within the affected area of the display. Processing logic additionally creates a paste command to paste the contents to a second region within the affected area. The second region is offset from the first region in the determined scrolling direction by the determined number of pixels. Some portion of the first region and the second region may overlap. For example, the first region may include vertical pixel lines 3-33 and the second region may include vertical pixel lines 13-43.","At block , processing logic generates an image that will be rendered to the display of a remote client device. The image may be rendered to a third region of the display, which may be a portion of the first region. At block , processing logic generates a drawing command to render the image to a portion of the first region vacated by the transposition of the contents of the first region to the second region. For example, a display may include 420 vertical pixel lines. Vertical pixel lines 21-400 may be affected by the scrolling. An example scrolling command may scroll the current contents of the display down 3 pixels. The contents of vertical pixel lines 31-397 may be copied and pasted to vertical pixel lines 34-400. A new image to be rendered to vertical pixel lines 31-33 may be generated, and the command to render the image to vertical pixel lines 31-33 may be generated.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6","b":["600","600","300","400","500","615","635","600","315","300"]},"At block  of method , processing logic maintains an image cache. At block , processing logic causes a remote client to maintain a copy of the image cache. The image caches may contain pre-generated images that are frequently used by an application and\/or may include most recent images that have been rendered to a display of a client device. The image cache maintained by image cache manager and the client's image cache may maintain synchronization by having the same cache size, cache advancement policies, cache ordering policies and\/or cache eviction policies.","At block , processing logic generates an image based on a rendering in a first buffer. At block , processing logic compares the generated image to images in the image cache. At block , processing logic determines whether the generated image (or a portion of the generated image) matches any of the images in the image cache. If a match is found, the method proceeds to block . If no match is found, the method continues to block .","At block , processing logic generates a drawing command to render the matching image from the copy of the image cache maintained by the remote client to specified coordinates of a display. At block , processing logic sends the drawing command to the client device. The drawing command may be sent without sending a copy of the image to the client device. Accordingly, system resources can be conserved.","At block , processing logic generates a drawing command to render the image to the display. At block , processing logic sends the drawing command and the image to the client device.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 7","b":["700","300","400","500","600","700","315","300"]},"At block  of method , processing logic performs image analysis on a first rendering and a second rendering. The second rendering may reflect a current rendering in a display of a client device. The image analysis may be performed using standard techniques in the art. For example, processing logic may perform object recognition using techniques such as edge matching, grayscale matching, gradient matching, intensity matching, interpolation trees, geometric hashing, and so forth. The image analysis is performed to identify an image (e.g., an object) that is located at a first region in the first rendering and also at a second region of the second rendering.","At block , processing logic generates a drawing command to copy contents from an area of a display corresponding to the second region and to paste the contents to an area of the display corresponding to the first region. At block , processing logic sends the drawing command to the client device without sending the image to the client device.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 8","b":"800"},"The exemplary computer system  includes a processing device , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or Rambus DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a data storage device , which communicate with each other via a bus .","Processing device  represents one or more general-purpose processing devices such as a microprocessor, central processing unit, or the like. More particularly, the processing device  may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, or a processor implementing other instruction sets or processors implementing a combination of instruction sets. The processing device  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. The processing device  is configured to execute instructions  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The data storage device  may include a computer-readable storage medium  on which is stored one or more sets of instructions  embodying any one or more of the methodologies or functions described herein. For example, the instructions  may include instructions for a remote rendering module . The instructions  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system , the main memory  and the processing device  also constituting machine-accessible storage media.","While the computer-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-accessible storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-accessible storage medium\u201d shall also be taken to include any medium that is capable of storing, encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201ccomputer readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, optical media, and magnetic media.","In the above description, numerous details are set forth. Some portions of the detailed description are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cgenerating\u201d, \u201creceiving\u201d, \u201ctransmitting\u201d, \u201ccomparing\u201d, \u201csubtracting\u201d or the like, refer to the actions and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (e.g., electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions.","It is to be understood that the above description is intended to be illustrative, and not restrictive. It will be apparent to one skilled in the art that embodiments of the present invention may be practiced without these specific details. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. In some instances, well-known structures and devices have been shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention. The scope of the invention should, therefore, be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be understood more fully from the detailed description given below and from the accompanying drawings of various embodiments of the invention, which, however, should not be taken to limit the invention to the specific embodiments, but are for explanation and understanding only.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
