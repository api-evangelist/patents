---
title: Reusable and late addition enabled XML data binding
abstract: Various embodiments of systems and methods for reusable and late addition enabled XML data binding are described herein. A computer receives an element class that is created for a non-atomic class. The element class comprises a first constructor, a decomposer that returns data extracted from an object for an entity to aid in serialization, and a composer that extracts value of the entity and creates a new instance of the non-atomic class using the extracted value to aid in de-serialization. The object is of type non-atomic class. The computer also receives an attribute class that is created for an atomic class to which the non-atomic class refers to. The attribute class comprises a second constructor, a serializer, and a de-serializer. The computer then generates an XML document using the element class and the attribute class.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09430253&OS=09430253&RS=09430253
owner: SAP SE
number: 09430253
owner_city: Walldorf
owner_country: DE
publication_date: 20110925
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The field relates generally to Extensible Markup Language (XML) data binding. More particularly, the field relates to an XML data binding approach that is reusable and enables late addition of data binding.","It is often required to transform memory representations of data such as objects (of object oriented programming) into an XML document. The process of transforming data into an XML document is called \u201cmarshalling\u201d or \u201cserialization\u201d and the process of transforming an XML document back into data is called \u201cun-marshalling\u201d or \u201cde-serialization.\u201d XML data binding approaches are used for serialization and de-serialization.","Several approaches for XML data binding are known in the art. These approaches can be categorized into procedural approaches and declarative approaches. Procedural approaches provide flexibility in serialization and de-serialization. They are suitable for late addition of data binding to existing projects. However, procedural approaches require writing of code, which can be a complicated and expensive way to add support for data binding. Also, the code for serialization and de-serialization may not be easily reused for other projects.","Declarative approaches follow the class generation metaphor, i.e. classes and interfaces for serialization and de-serialization are first generated from document type definitions (e.g., with XML Schema). The classes generated from the document type definitions then contain both the code for serializing and de-serializing the corresponding object instances. An advantage of this approach is that there is no need to write a code to add support for data binding, as it is only necessary to declaratively define a document type. The same approach may be re-used for a new project\u2014only a new XML document type is required for each new class.","However, in declarative approaches, it is difficult to add support for data binding for existing projects. The existing classes first have to be transformed into XML document types because only then these XML document types can be compiled into classes and interfaces that are required for serialization and de-serialization. Also, after serialization, the existing classes have to be mapped to the generated classes, and after de-serialization, the generated classes have to be mapped back to the original ones. Even for new projects where classes to be serialized can be derived from XML document type definitions, a developer should be well versed with XML document type definition language and it may not be easy to achieve a good mapping.","It would therefore be desirable to have both late addition functionality and reusability for XML data binding.","Various embodiments of systems and methods for reusable and late addition enabled XML data binding are described herein. A computer receives an element class that is created for a non-atomic class. The element class comprises a first constructor, a decomposer that returns data extracted from an object for an entity to aid in serialization, and a composer that extracts value of the entity and creates a new instance of the non-atomic class using the extracted value to aid in de-serialization. The object is of type non-atomic class. The computer also receives an attribute class that is created for an atomic class to which the non-atomic class refers to. The attribute class comprises a second constructor, a serializer, and a de-serializer. The computer then generates an XML document using the element class and the attribute class.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for reusable and late addition enabled XML data binding are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","102","100","104","104","100","102"],"sub":["1","2 ","n","1","2 ","n"]},{"@attributes":{"id":"p-0019","num":"0018"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class Player {"]},{"entry":[{},"\u2003\u2003\u2003private String firstName;"]},{"entry":[{},"\u2003\u2003\u2003private String lastName;"]},{"entry":[{},"\u2003\u2003\u2003private int age;"]},{"entry":[{},"\u2003\u2003\u2003private Participation[ ] participations;"]},{"entry":[{},"\u2003\u2003\u2003public Player(String firstName, String lastName, int age,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Participation[ ] participations) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003this.firstName = firstName;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003this.lastName = lastName;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003this.age = age;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003this.participations = participations;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003public String getFirstName( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return firstName;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003public String getLastName( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return lastName;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003public int getAge( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return age;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003public Participation[ ] getParticipations( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return participations;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above program code is a JAVA class PLAYER. The PLAYER class is a non-atomic class as it is represented by nested strings. The PLAYER class models a football player with a first name, a last name, an age, and number of participations in tournaments. The PLAYER class refers to two atomic classes, namely, a STRING class and an INT class. STRING and INT classes are represented using a simple, non-nested string. The PLAYER class also refers to a non-atomic class PARTICIPATION. The PARTICIPATION class is presented below:",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class Participation {"},{"entry":"\u2003\u2003\u2003private String tournament;"},{"entry":"\u2003\u2003\u2003private int matches;"},{"entry":"\u2003\u2003\u2003private int goals;"},{"entry":"\u2003\u2003\u2003public Participation(String tournament, int matches, int goals) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.tournament = tournament;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.matches = matches;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.goals = goals;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003public String getTournament( ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return tournament;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003public int getMatches( ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return matches;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003public int getGoals( ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return goals;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The PARTICIPATION class is represented by nested strings. The PARTICIPATION class models participation in a tournament by the number of matches played in the tournament and the number of goals scored in the tournament. The PARTICIPATION class also refers to atomic classes STRING and INT.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":"200"},"At , a computer receives an element class. The element class is created for a non-atomic class. Considering the example of PLAYER class, an element class \u201cPLAYER-ELEMENT\u201d is created for the PLAYER class. An embodiment of the PLAYER-ELEMENT class is presented below:",{"@attributes":{"id":"p-0025","num":"0024"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/First constructor"},{"entry":"public class PlayerElement extends SingleElement {"},{"entry":"\u2003\u2003\u2003private EmptySingleElement nameElement;"},{"entry":"\u2003\u2003\u2003private EmptySingleElement ageElement;"},{"entry":"\u2003\u2003\u2003private ListElement participationsElement;"},{"entry":"\u2003\u2003\u2003public PlayerElement( ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003super(\u201cplayer\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003new Attribute[0],"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003new Element[ ]{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new EmptySingleElement ("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cname\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new StringAttribute(\u201cfirst\u201d, true),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new StringAttribute(\u201clast\u201d, true)),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new EmptySingleElement ("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cage\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new IntegerAttribute(\u201cvalue\u201d, true)),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new ListElement("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cparticipations\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new ParticipationElement( ))});"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.nameElement ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(EmptySingleElement) getDaughterElements( )[0];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.ageElement ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(EmptySingleElement) getDaughterElements( )[1];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.participationsElement ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(ListElement) getDaughterElements( )[2];"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\/\/Decomposer"},{"entry":"\u2003\u2003\u2003public Object decompose(Object obj, Entity entity) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Object returnObj = null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (obj != null) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Player player = (Player) obj;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (entity.equals(nameElement)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003returnObj ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Object[ ]{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003player.getFirstName( ),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002player.getLastName( )};"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003} else if (entity.equals(ageElement)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003returnObj = player.getAge( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003} else if (entity.equals(participationsElement)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003returnObj = player.getParticipations( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return returnObj;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\/\/Composer"},{"entry":"\u2003\u2003\u2003public Object compose(Map<Entity, Object> entityObjMap) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Object[ ] nameObjs ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(Object[ ]) entityObjMap.get(nameElement);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String firstName ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(String) nameObjs[0];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String lastName ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(String) nameObjs[1];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int age ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(Integer) entityObjMap.get(ageElement);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Object[ ] participationObjs ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(Object[ ])"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003entityObjMap.get(participationsElement);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Participation[ ] participations ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Participation[participationObjs.length];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003for (int i = 0; i < participationObjs.length; i++) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003participations[i] ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(Participation) participationObjs[i];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Player player ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Player(firstName, lastName, age,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003participations);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return player;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The element class includes a first constructor, a decomposer, and a composer. The first constructor is used to create the PLAYER-ELEMENT with a plurality of sub-elements. The sub-elements include a \u201cname\u201d sub-element, an \u201cage\u201d sub-element, and a \u201cparticipation\u201d sub-element. The PLAYER-ELEMENT does not include any attributes. The \u201cname\u201d sub-element is an empty single element because it does not include any sub-elements. The \u201cage\u201d sub-element is an empty single element with the attribute \u201cvalue\u201d of type INT. The \u201cparticipation\u201d sub-element is a list element that includes one or more elements of type PARTICIPATION-ELEMENT. As will be described below, the PARTICIPATION-ELEMENT is an element class created for the PARTICIPATION class that is referred by the PLAYER class.","The decomposer is a decompose method that gets an object of type PLAYER and an entity and returns the data extracted from the object PLAYER for the given entity. The entity can be an attribute or a sub-element and there can be more than one entity. When an entity is the \u201cname\u201d sub-element, then the decomposer returns the first name and last name of the player (player.getFirstName( ) and player.getLastName( )). Similarly, when an entity is the \u201cage\u201d sub-element, then the decomposer returns the age (value) of the player (player.getAge( )). The decomposer aids in serializing JAVA objects of type PLAYER to an XML document. The actual serializing code is hidden in the super class ELEMENT. This serializing code is included in a JAVA-to-XML data binding package or Application Programming Interface (API) embodying this method  and need not be written by an end user who wants to serialize JAVA data.","For de-serialization, the XML document is first parsed using an XML parser. In one embodiment, Streaming API for XML (StAX) parsing is used for parsing the XML document. The composer is a compose method that first gets a mapping of entities to objects after parsing the XML document. The composer then extracts the values of the entities and creates a new instance of PLAYER class. In the above example, the composer extracts the values of the following entities: the \u201cname\u201d sub-element, the \u201cage\u201d sub-element, and the \u201cparticipation\u201d sub-element. The composer aids in de-serializing an XML document into JAVA objects of type PLAYER. The actual de-serializing code and XML parsing is hidden in the super class ELEMENT. The de-serializing code and XML parsing are included in a JAVA-to-XML data binding package embodying this method .","Since the PLAYER class refers to a non-atomic PARTICIPATION class, a PARTICIPATION-ELEMENT class is also created at . An embodiment of the PARTICIPATION-ELEMENT class is presented below:",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/First constructor"},{"entry":"public class ParticipationElement extends SingleElement {"},{"entry":"\u2003\u2003\u2003private StringAttribute tournamentAttribute;"},{"entry":"\u2003\u2003\u2003private IntegerAttribute matchesAttribute;"},{"entry":"\u2003\u2003\u2003private IntegerAttribute goalsAttribute;"},{"entry":"\u2003\u2003\u2003public ParticipationElement( ) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003super("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cparticipation\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003new Attribute[ ]{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new StringAttribute(\u201ctournament\u201d, true),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new IntegerAttribute(\u201cmatches\u201d, true),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new IntegerAttribute(\u201cgoals\u201d, false)});"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.tournamentAttribute ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(StringAttribute) getAttributes( )[0];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.matchesAttribute ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(IntegerAttribute) getAttributes( )[1];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003this.goalsAttribute ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(IntegerAttribute) getAttributes( )[2];"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\/\/Decomposer"},{"entry":"\u2003\u2003\u2003public Object decompose(Object obj, Entity entity) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Object returnObj = null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (obj != null) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Participation participation = (Participation) obj;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (entity.equals(this.tournamentAttribute)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003returnObj = participation.getTournament( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003} else if (entity.equals(this.matchesAttribute)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003returnObj = participation.getMatches( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003} else if (entity.equals(this.goalsAttribute)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003returnObj = participation.getGoals( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return returnObj;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\/\/Composer"},{"entry":"\u2003\u2003\u2003public Object compose(Map<Entity, Object> entityObjMap) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003String tournament ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(String) entityObjMap.get(tournamentAttribute);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int matches ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(Integer) entityObjMap.get(matchesAttribute);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int goals ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(Integer) entityObjMap.get(goalsAttribute);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Participation participation ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Participation (tournament, matches, goals);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return participation;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The PARTICIPATION-ELEMENT class also includes a first constructor, a decomposer, and a composer. The first constructor is used to create the PARTICIPATION-ELEMENT with one or more entities. In this case the entities include three attributes, namely, a \u201ctournament\u201d attribute, a \u201cmatches\u201d attribute, and a \u201cgoals\u201d attribute.","The decomposer is a decompose method that gets an object of type PARTICIPATION and an entity and returns the data extracted from the PARTICIPATION object for the given entity. For a given tournament, matches, and goals entities, tournament name, number of matches, and number of goals are extracted (e.g., participation.getTournament ( ), participation.getMatches ( ), and participation.getGoals ( )).","After parsing the XML document, the composer extracts the values of the \u201ctournament\u201d attribute, the \u201cmatches\u201d attribute, and the \u201cgoals\u201d attribute and creates a new instance of PARTICIPATION class. The decomposer aids in serializing JAVA objects of type PARTICIPATION to an XML document and the composer aids in de-serializing an XML document into JAVA objects of type PARTICIPATION. As cited previously, the actual serializing code, the actual de-serializing code, and XML parsing are included in a JAVA-to-XML data binding package embodying this method .","At , the computer receives an attribute class that is created for an atomic class to which the non-atomic class refers to. If the non-atomic class refers to more than one atomic class, then an attribute class is created for each atomic class. In the previous example of PLAYER class, the PLAYER class refers to two atomic classes, namely, a STRING class and an INT (integer) class. Therefore, a STRING-ATTRIBUTE class is created for the STRING class and an INT-ATTRIBUTE class is created for the INT class. An embodiment of the STRING-ATTRIBUTE class is presented below:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/Second constructor"]},{"entry":[{},"public class StringAttribute extends Attribute {"]},{"entry":[{},"\u2003\u2003\u2003public StringAttribute(String name, boolean isRequired) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003super(name, isRequired);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\/\/Serializer"]},{"entry":[{},"\u2003\u2003\u2003public String serialize(Object obj) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003String s = (String) obj;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return s;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\/\/De- serializer"]},{"entry":[{},"\u2003\u2003\u2003public Object deserialize(String s) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return s;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The STRING-ATTRIBUTE class includes a second constructor, a serializer, and a de-serializer. In the constructor, a name is assigned to the STRING-ATTRIBUTE. A Boolean operation for deciding whether the attribute is required or not is also defined in the constructor. The serializer aids in serializing. The serializer is a JAVA serialize method that gets an object of type STRING and return the string. The de-serializer aids in de-serializing. The de-serializer is a JAVA de-serialize method that just returns the string it gets as its argument.","An embodiment of the INT-ATTRIBUTE class created for the INT class is presented below:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/Second constructor"]},{"entry":[{},"public class IntegerAttribute extends Attribute {"]},{"entry":[{},"\u2003\u2003\u2003public IntegerAttribute(String name, boolean isRequired) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003super(name, isRequired);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\/\/Serializer"]},{"entry":[{},"\u2003\u2003\u2003public String serialize(Object obj) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Integer i = (Integer) obj;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003String s = String.valueOf(i);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return s;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\/\/De-serializer"]},{"entry":[{},"\u2003\u2003\u2003public Object deserialize(String s) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Integer i = Integer.valueOf(s);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003return i;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The INT-ATTRIBUTE class also includes a second constructor, a serializer, and a de-serializer. In the constructor, a name is assigned to the INT-ATTRIBUTE and a Boolean operation for deciding whether the attribute is required or not is defined. The serializer is a JAVA serialize method that gets an object of type INT and returns a corresponding string. The de-serializer is a JAVA de-serialize method that takes a string and returns the corresponding integer value.","At , the element classes and the attribute classes are used by the computer for JAVA-to-XML data binding. The element classes and the attribute classes are used to generate an XML document as explained in reference to . Referring to , a JAVA-to-XML data binding package or API embodying this method  is used by a user intending to serialize a JAVA code . The user creates one or more element classes  and one or more attribute classes . An element class  is created for a non-atomic class of the JAVA data  and an attribute class  is created for an atomic class of the JAVA data  to which the non-atomic class refers to. If there are a plurality of non-atomic classes and atomic classes, corresponding element classes and attribute classes are created. The decomposer in the element class aids in serializing JAVA objects of type NON-ATOMIC CLASS and the serializer in the attribute class aids in serializing JAVA objects of type ATOMIC CLASS. The actual serializing code is in the super class ELEMENT , which is part of the JAVA-to-XML data binding package and need not be written by a user. The element class , the attribute class , the serializing code in the super class ELEMENT , and any existing classes  which are previously created or part of the JAVA-to-XML data binding package are used to serialize  the JAVA data  and generate an XML document . In one embodiment, the JAVA-to-XML data binding package provides a user interface (not shown) using which a user can create the element classes and attribute classes, select existing classes, and select an option to generate the XML document.","An example using test data about how the created classes can be used is presented below:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class WmDemo {"},{"entry":"\u2003\u2003\u2003public static void main(String[ ] args) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003try {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Create test data"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Player klose ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002new Player("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u201cMiroslav\u201d, \u201cKlose\u201d, 32,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Participation[ ]{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Participation(\u201cwm2010\u201d, 5, 4),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Participation(\u201cwm2006\u201d, 7, 5),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002new Participation(\u201cwm2002\u201d, 7, 5)});"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Player mueller ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002new Player("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u201cThomas\u201d, \u201cMueller\u201d, 20,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Participation[ ]{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new Participation(\u201cwm2010\u201d, 6, 5)});"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Player[ ] players = new Player[ ]{klose, mueller};"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Serializing"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003File file = new File(\u201cwmdemo.xml\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FileOutputStream fileOutputStream ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new FileOutputStream(file);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ListElement playersElement ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new ListElement(\u201cplayers\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new PlayerElement( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003playersElement.serialize("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fileOutputStream, players, null);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fileOutputStream.flush( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fileOutputStream.close( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ De-serializing"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003File file1 = new File(\u201cwmdemo.xml\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003FileInputStream fileInputStream ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new FileInputStream(file1);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ListElement playersElement1 ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new ListElement(\u201cplayers\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003new PlayerElement( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Object obj ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003playersElement1.-"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003deserialize(fileInputStream);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Object[ ] playerObjs = (Object[ ]) obj;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Player[ ] players1 = new Player[playerObjs.length];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003for (int i = 0; i < playerObjs.length; i++) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003playersl[i] = (Player) playerObjs[i];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fileInputStream.close( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003} catch (Exception e) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003e.printStackTrace( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the above example, a test data of two football players \u201cMiroslav Klose\u201d and \u201cThomas Mueller\u201d is created. Then in the serializing code, a list element \u201cPLAYERSELEMENT\u201d is created. The PLAYER-ELEMENT class, PARTICIPANT-ELEMENT class, STRING-ATTRIBUTE class, and INT-ATTRIBUTE class are then used to serialize the two football players to XML. The XML output after serialization is presented below:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>"},{"entry":"<players>"},{"entry":"\u2002<player>"},{"entry":"\u2003<name first=\u201cMiroslav\u201d last=\u201cKlose\u201d\/>"},{"entry":"\u2003\u2002<age value=\u201c32\u201d\/>"},{"entry":"\u2003\u2003\u2002<participations>"},{"entry":"\u2003\u2003\u2003<participation tournament=\u201cwm2010\u201d matches=\u201c5\u201d goals=\u201c4\u201d\/>"},{"entry":"\u2003\u2003\u2003<participation tournament=\u201cwm2006\u201d matches=\u201c7\u201d goals=\u201c5\u201d\/>"},{"entry":"\u2003\u2003\u2003<participation tournament=\u201cwm2002\u201d matches=\u201c7\u201d goals=\u201c5\u201d\/>"},{"entry":"\u2003\u2003\u2002<\/participations>"},{"entry":"\u2002<\/player>"},{"entry":"\u2002<player>"},{"entry":"\u2003<name first=\u201cThomas\u201d last=\u201cMueller\u201d\/>"},{"entry":"\u2003\u2002<age value=\u201c20\u201d\/>"},{"entry":"\u2003\u2003\u2002<participations>"},{"entry":"\u2003\u2003\u2003<participation tournament=\u201cwm2010\u201d matches=\u201c6\u201d goals=\u201c5\u201d\/>"},{"entry":"\u2003\u2003\u2002<\/participations>"},{"entry":"\u2002<\/player>"},{"entry":"<\/players>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Compared to the some of the existing XML data binding techniques, the data binding technique described above obviates the need to learn XML Schema or XML Schema-based Java annotations. It is also unnecessary to follow the complicated process of compilation steps from XML Schema to a number of JAVA classes as in the case of some existing XML data binding approaches. A user needs to write only a template-like JAVA glue code (element classes and attribute classes) to serialize JAVA data. This enables the late addition of data binding to existing JAVA projects. As can be seen from close similarities between the PLAYER-ELEMENT class and the PARTICIPATION-ELEMENT class, an element class is a template-like JAVA glue code. An element class template can be defined as a template including a constructor, a decomposer, and a composer. The constructor code creates an element with one or more sub-elements and one or more attributes for the element. The decomposer code gets an object of type element and an entity and returns the data extracted from the object for the given entity. The composer code gets a mapping of entities to objects after parsing the XML document and then extracts the values of the entities and creates a corresponding JAVA object. Similarly, an attribute class is also a template-like JAVA glue code. The attribute class template can be defined as a template including a simple constructor for assigning a name and defining a Boolean operation, a serializer which is a simple JAVA serialize method, and a de-serializer which is a simple JAVA de-serialize method. The element classes and attribute classes once created for a project can be reused for any other new or existing projects.","Referring to , to de-serialize an XML document , the XML document  is first parsed using an XML parser . The XML document  has reference to objects of JAVA data that is previously serialized. Any state-of-the-art XML parser can be used. In one embodiment, a StAX parser is used for parsing the XML document . The composer of the element class  and the de-serializer of the attribute class  are used to de-serialize  the XML document  into corresponding JAVA data . The actual de-serializing code and XML parsing are included in a JAVA-to-XML data binding package embodying this method. In one embodiment, the de-serializing code and XML parsing code are in a super class ELEMENT .","Although the reusable and late addition enabled XML data binding is described in reference to JAVA, it should be understood that a similar approach can be applied to other object-oriented programming languages that include atomic and non-atomic classes where an atomic class is a class that is represented by a non-nested string and a non-atomic class is a class that is represented by a nested string. Examples of some such object-oriented programming languages include Advanced Business Application Programming (ABAP), C++, etc.","Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable storage medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer readable storage media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 5","b":["500","500","505","555","500","540","555","510","515","510","515","505","515","500","525","530","500","525","530","500","535","500","550","550","500","545","500","520","560","560","560","550","560"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","In the above description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however that the invention can be practiced without one or more of the specific details or with other methods, components, techniques, etc. In other instances, well-known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.","Although the processes illustrated and described herein include series of steps, it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps, as some steps may occur in different orders, some concurrently with other steps apart from that shown and described herein. In addition, not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover, it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
