---
title: Software application porting system
abstract: A software application porting system facilitates the transition of code and data compatible with an old platform version to a new platform version. The software application porting system identifies differences between the platform versions by comparing sample source code objects or sample data schemas. Then, the software application porting system utilizes the identified differences to perform an automated transformation of software application objects and schemas.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09348568&OS=09348568&RS=09348568
owner: Accenture Global Services Limited
number: 09348568
owner_city: Dublin
owner_country: IE
publication_date: 20110824
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Technical Field","This disclosure relates to porting software applications. In particular, this disclosure relates to modifying software applications that are compatible with a source platform version for enhanced compatibility with a destination platform version.","2. Related Art","Software applications are used across a wide variety of industries for a wide variety of purposes. Modern software applications are capable of managing complex business requirements across multiple entities while being flexible enough to allow the development of custom functionality to meet specific business needs. Many different computing platforms allow for the consistent development and execution of software applications.","Platform vendors are constantly upgrading the platforms upon which software applications run, providing support for additional functionalities and improved performance. However, vendor packages and platforms are often standardized, making customization of the platform difficult. Additional complications arise during platform version upgrades, where custom software applications and functionalities are often incompatible with the new vendor platform versions. A company risks using outdated or poorly performing technology if its computing platform is never upgraded. On the other hand, rewriting application code and altering application data to meet the compatibility requirements of an upgraded vendor platform costs the company time, effort, and money.","A software application porting system facilitates the transition of code and data compatible with an old platform version to a new platform version. The software application porting system identifies differences between the platform versions by comparing sample source code objects or sample data schemas. Then, the software application porting system utilizes the identified differences to perform an automated transformation of software application objects and schemas.","Other systems, methods, features and advantages will be, or will become, apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems, methods, features and advantages be included within this description, be within the scope of the invention, and be protected by the following claims.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","110","100","120","130","130","142","144"]},"The software application porting system  may port any of the objects (including code) and data that implement a software application from a source platform version to a destination platform version. The platform may refer to the computing platform the software application is executed on, such as the Siebel\u2122 platform, SAP\u2122 platform, or Java\u2122 platform. As one specific example used below, the software application porting system  may port a customer relationship management (CRM) application from one platform version to another, such as porting the CRM application from Siebel 7.5 (the source platform version) to Siebel 7.8 (the destination platform version). The software application porting system  may perform the porting by altering the individual objects that form the software application (e.g., a source application object ) in the source platform version to obtain increased compatibility with the destination platform version.","To this end, the object comparator  may receive a source sample object  that provides any particular functionality and that is compatible with the source platform version. Additionally, the object comparator  may receive a destination sample object  that also provides the same particular functionality but is instead compatible with the destination platform version. Then, the object comparator  may compare the received source sample object  and destination sample object  to identify differences between the source platform version and the destination platform version. As described in greater detail below, the software application porting system  may receive and compare multiple source sample objects with corresponding (e.g., in functionality) destination sample objects to identify additional differences in the way that objects and data are implemented between the source platform version and the destination platform version. The source sample objects may include any type of object, including objects from different classes of the software application.","The object comparator  may store the identified differences within the version difference table . The software application porting system  may then communicate the identified differences between the source platform version and the destination platform version in the form of the version difference table  to the porting engine . Alternatively, the porting engine  may read the version difference table  from memory, or may obtain the version differences in other ways.","The porting engine  may also receive a source application object  as an input. The source application object  may be any object in the source platform version that the software application porting system  will alter for increased compatibility with the destination platform version. Next, the porting engine  may alter the source application object  based on the differences that were identified by the comparison between the sample objects. The porting engine generates a destination application object  as a result. The destination application object  may have increased compatibility with the destination platform version, as compared to the source application object. Through this software application porting process, the software application porting system  may port a software application from a source platform version to a destination platform version by altering each of the individual objects that form the software application with the porting engine , based on the version difference table .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 2"],"b":["100","100","210","220","230","250","260","230","231","232","236","238","231","232","236","238"]},"The memory  may also store a version difference table  and a filtered version difference table . In one implementation, the version table  distinguishes between enforced differences  and unenforced differences . As discussed in greater detail below, the system  may filter the version difference table  based on the enforced differences  or unenforced differences  to generate a filtered version difference table . The source application object database  may store multiple source application objects (e.g., the source application object ) to port from a source platform version to a destination platform version. An application object porting list  may be stored within the memory  as well. The application object porting list  may include object identifiers that specify which specific source application objects to port to the destination platform version. The destination application object database  may store multiple destination application objects (e.g., the destination application object ) generated from the software application porting process.","In operation, the software application porting system  may compare sample objects to identify differences between the source platform version and the destination platform version. The software application porting system  may perform the difference analysis on any number of sample objects, whether of the same or different type. In general, the difference analysis may compare any specific source sample object  against any specific destination sample object . A given source sample object  and a destination sample object  that are compared may be referred to as a comparison set of sample objects. The destination sample object  may be chosen based on functionality, parameters, or other features that it shares in common with the source sample object . For example, one particular comparison set of sample objects may include a sample applet object in Siebel 7.5 (the source sample object ) that performs customer contact data entry, and a sample applet object in Siebel 7.8 (the destination sample object ) that also performs customer contact data entry.","In some instances, the destination sample object  compared against the source sample object  is specifically created to capture the functionality of the source sample object . For example, a programmer may create the destination sample object  by manually converting the source sample object  to the destination platform version. There may be any number of such destination sample objects that match to any number of source sample objects. The matching pairs (source sample object  and destination sample object ) in the comparison set provide, in effect, a training base for the software application porting system , from which the system  may determine the version differences. The extent to which all of the version differences are found depends on the sample objects that the system compares. It is not necessary to provide complete coverage that reveals every version difference. Instead, as explained below, the system  improves compatibility with the destination platform version even when fewer than all of the version differences are available to the system .","The software application porting system  may receive multiple comparison sets of sample objects of a particular type. For instance, the software application porting system  may receive multiple comparison sets of sample applet objects. Additionally, the software application porting system  may receive multiple comparison sets of multiple object types of sample objects as well. As an example, in porting a CRM application from Siebel 7.5 to Siebel 7.8, the software application porting system  may receive for comparison multiple sets of corresponding applet objects, customer objects, or other types of objects in the source platform version and the destination platform version respectively.","The degree of compatibility of a software application ported by the software application porting system  with the destination platform version may reflect the completeness of the version difference table . As the comparison sets cover increasing amounts of differences between the platform versions, the version difference table  becomes more complete, and the degree of compatibility increases. Thus, the selection of source sample objects and destination sample objects may determine the degree of compatibility the ported software application objects have with the destination platform version. For example, if the comparison sets received by the software application porting system  encompass 60% of the programmatic aspects of a particular software application overall, the source code porting process may be expected to correctly transform 60% of the programmatic aspects of the software application. Thus, the ported software application may have increased compatibility (though perhaps not complete compatibility) with the destination platform version. On the other hand, if the received sample object comparison sets encompass 100% of the programmatic aspects of the particular software application, the ported software application may be completely compatible with the destination platform version.","The source sample objects received by the software application porting system  may be source application objects. In other words, a subset of source application objects in the source application objects database  may be designated as source sample objects for comparison to identify platform version differences. As discussed above, the particular source application objects chosen as source sample objects may depend on the degree of programmatic aspects encompassed by the particular source application objects.","Alternatively or additionally, the source sample objects received by the software application porting system  may be manually generated, as noted above. For example, in porting a CRM application with hundreds of applet objects, a programmer may generate an applet object that includes all or part of the programmatic aspects encompassed within the hundreds of CRM application applet objects. A programmer may generate one or multiple applet objects to partially or completely encompass the applet object programmatic features. Generated applet objects may then be received by the software application porting system , each as a source sample object . A programmer may employ a similar process to manually generate source sample objects of different types or classes of objects.","For each received source sample object , the software application porting system  may also receive a destination sample object  in the destination platform version with matching programmatic features. A destination sample object  may be manually generated based on a corresponding source application object , that is, to match the programmatic aspects of the corresponding source application object . In the CRM application porting example, finding the version differences between a source sample applet object in Siebel 7.5 and a destination sample applet object with corresponding programmatic aspects in Siebel 7.8 may allow the software application porting system  to port any of the CRM application applet objects from Siebel 7.5 to Siebel 7.8. The ported CRM application applet objects may have varying degrees of resultant compatibility depending on the coverage provided by the selected sample applets.","In the example shown in , a source sample object  or a destination sample object  may be received in a tag based language format, such as Extensible Markup Language (XML). Alternatively, a source sample object  or a destination sample object  may be received in a native source platform format (i.e., the software format of the object code and software application, such as C++, Java, or other software languages). The extraction logic  stored in the memory  may convert received sample objects from the received native source platform format to a tag based language format, such as XML. Accordingly, received source sample objects  or destination sample objects  may be converted to a tag based language format for comparison. In some implementations, the source platform provides the extraction logic . For example, Siebel 7.5 includes a utility to export native format objects to a tag based format.","The comparator logic  may be implemented as processor executed instructions to identify the differences between a source sample object  and a destination sample object . In one respect, the comparator logic  may compare sample objects received in XML or other tag based language formats by employing an iterative comparison process. The comparator logic  may iteratively compare tag values, node-by-node, between the source sample object  and the destination sample object . Thus, the iterative node-by-node comparison employed by the comparator logic  may detect differences between the received sample objects even if the tag values are ordered differently in the source sample object  and the destination sample object .","Upon comparing the received source sample objects and destination sample objects, the comparator logic  may identify a path location in the source application object  and the destination application object  where a difference between platform versions occurs. The comparator logic  may also determine an operation to perform at the identified path location to account for the identified difference between platform versions. For example, the comparator logic  may identify in a source sample Applet object in Siebel 7.5 that a \u201cFLOW_VALUE\u201d tag and corresponding tag value are present at an identified path location of \u201cRepository\\Project\\Applet.\u201d The comparator logic  may further identify that the \u201cFLOW_VALUE\u201d tag is not present in the destination applet sample object at the identified path location at all. Accordingly, in porting application objects from Siebel 7.5 to Siebel 7.8, the comparator logic  may determine that any application objects containing the \u201cFLOW_VALUE\u201d tag at the \u201cRepository\\Project\\Applet\u201d path location should be altered to delete the \u201cFLOW_VALUE\u201d tag at the identified path location.","Similarly, the comparator logic  may identify differing tag values between the source sample object  and the destination sample object  at an identified path location. In this situation, the comparator logic  may determine that any received source application object  should be altered at the identified path location by replacing the old tag value present in the source sample object  with the new tag value present in the destination sample object . As an example, the comparator logic  may identify differing \u201cCLASS\u201d tag values at the \u201cRepository\\Project\\Applet\u201d path location between sample applet objects received in Siebel 7.5 and Siebel 7.8. The source sample Applet object may have a \u201cCLASS\u201d tag value of \u201cCSSFrameList\u201d while the destination sample Applet object may have a \u201cCLASS\u201d tag value of \u201cCSSFrame.\u201d Thus, in porting application objects from Siebel 7.5 to Siebel 7.8, the comparator logic  may determine that any source application objects containing a \u201cCLASS\u201d tag value of \u201cCSSFrameList\u201d at the \u201cRepository\\Project\\Applet\u201d path location should be altered to have a \u201cCLASS\u201d tag value of \u201cCSSFrame\u201d instead.","The comparator logic  may also identify a tag and tag value present in the destination sample object  that is not present in the corresponding source sample object . Accordingly, the comparator logic  may determine that an insert operation may be required to properly port objects in the source platform version to the destination platform version. For example, the comparator logic  may identify that a destination sample applet object contains an \u201cALLOW_OBJECT_LOCKING\u201d tag with a corresponding tag value at the \u201cRepository\\Project\u201d path location whereas the source sample applet object does not. Thus, in porting application objects from Siebel 7.5 to Siebel 7.8, the comparator logic  may determine that source application objects should be altered by inserting the \u201cALLOW_OBJECT_LOCKING\u201d tag and a corresponding tag value at the identified \u201cRepository\\Project\u201d path location.","The comparator logic  may store each of the identified differences between received sample objects in the version difference table , an example of which is also discussed in greater detail in . As mentioned above, the version difference table  may distinguish between enforced differences  and unenforced differences . The distinction between enforced differences  and unenforced differences  may be utilized in the process of porting source application objects  to the source platform version to generate destination application objects  in the destination process version that include the enforced differences  but not the unenforced differences .","In the example shown in , the code porting system  includes an application object porting list . The application object porting list  may include object identifiers specifying which source application objects  the porting logic  should transform from the source platform version to the destination platform version. The application object porting list  may be manually or automatically generated, allowing flexibility in porting a software application between platform versions. For example, in porting a CRM application from Siebel 7.5 to Siebel 7.8, a programmer may determine that a certain functionality of the CRM application is obsolete or no longer needed. The application object porting list  may exclude the source application objects  corresponding to the obsolete functionality, thereby removing the obsolete functionality when the CRM application is ported to Siebel 7.8. In one respect, the application object porting list  may initially contain every source application object  that forms the software application. Removing obsolete or undesired functionality may be accomplished manually, for example, where the programmer removes the source application objects  corresponding to the obsolete or undesired functionality from the application object porting list .","The process of porting a source application object  from the source platform version to the destination platform version may be directed by the porting logic , which may be implemented as processor executable instructions. The porting logic  may receive as inputs the identified differences between the source platform version and the destination platform version from the version difference table  and the source application objects  listed in the application object porting list  from the source application object database . The porting logic  may alter each received source application object  according to the identified differences to generate a destination application object , having increased compatibility with the destination platform version.","The porting logic  may alter the source application object  for each identified differences relevant to the source application object  (i.e., for each identified difference with a path location present in the source application object ). For each relevant identified difference, the porting logic  may alter the source application object  by deleting a tag (and the corresponding tag value) no longer present in the destination platform version, modifying an old tag value to a new tag value present in the destination platform version, or inserting a new tag and corresponding tag value now present in the destination platform version.","The porting logic  may generate a destination application object  for each inputted source application object . Accordingly, the porting of the source application objects that implement the software application in the source platform version may result in a set of destination application objects that implement the software application in the destination platform version. The software application porting system  may store the generated destination application objects  in the destination application object database  after the porting process has completed.","In the example depicted in , the generated destination application objects may be in a tag based language format, such as XML. The software application porting system  may further include importing logic , implemented as processor executable instructions to convert the destination application objects  to a native destination platform format. As an example, the importing logic  may convert generated destination application objects  from XML to a format compatible with C++, Java, or other software programming languages. Thus, the source porting system  may extract source application objects  from a native source platform format to XML, transform the XML source application objects  to XML destination application objects , and import the XML destination application objects to a native destination platform format (which may be identical to the native source platform format). The importing logic  may be implemented in the destination platform. For example, Siebel 7.8 includes a utility to import tag based format files to create native language format objects.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 3","FIG. 3"],"b":["100","100","310","320","310","100","142","310","231","310","250"]},"The destination system  may be compatible with the destination platform version. Accordingly, the destination system  may store the ported software application and may execute the ported software application in the destination platform version. The importing logic  may transmit the destination application objects from the destination application object database  to the destination system . As discussed above, the importing logic  may convert the destination application objects from a tag based format (such as XML) to a destination platform format. Alternatively, the destination system  may be capable of converting destination application objects received in a tag based format to the native destination platform format.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4","b":["100","231","232","235","120","232","233","234","235","120","233"]},"The software application porting system  may receive a list of comparison sets of sample objects (). As discussed above, the comparison sets may determine the completeness of the version difference table , thereby affecting the ported software application's compatibility with the destination platform version. The list of comparison sets may be generated externally by a programmer. In one respect, the programmer may determine which comparison sets of sample objects to include in the application software porting process. In another respect, the list of comparison sets of sample objects may be determined by the extraction logic . That is, the extraction logic  may analyze the source application objects implementing the software application to determine the programmatic aspects of sample objects needed in order to encompass the programmatic aspects of the software application. In yet another example, the extraction logic  may produce a general analysis of the software application's programmatic aspects (e.g., determining the different types of objects present in the software application), allowing the programmer to select the specific sample object comparison sets to input to the software application porting system .","As mentioned above, each object comparison set may include a source sample object  and a corresponding destination sample object . The software application porting system  may receive a source sample object  from at least two sources (). First, the software application porting system  may extract a source application object  from the source system  as a source sample object  (). The extraction logic  may then convert the extracted source application object  into XML () or any other tag based format. Second, the software application porting system  may receive a manually generated source sample object  (). As discussed above, source sample objects may be generated by a programmer to encompass, to a degree determined by the programmer, the programmatic aspects of the software application. In one example, the programmer may generate the source sample object  in XML or another tag based format. Alternatively, the programmer may generate the source sample object  in a non-tag based format. The extraction logic  may then convert the generated source sample object  into XML () or another tag based format.","Next, the software application porting system  may receive destination sample objects corresponding (e.g., in functionality) to the received source sample objects. The software application porting system  may receive corresponding destination sample objects from at least two sources (). First, the software application porting system  may receive standard vendor objects in the destination platform version as a destination application object  (). For example, Siebel 7.8 may include a standard customer applet object that the system  may receive as a destination sample object . The extraction logic  may then convert the received destination vendor object into XML () or any other tag based format. Second, system  may receive manually generated destination sample objects (). The corresponding destination sample objects may be manually generated by a programmer to be compatible with the destination platform version. As with received vendor destination sample objects, the extraction logic  may likewise convert manually generated destination sample objects into XML or any other tag based format ().","Upon receiving the source sample objects and corresponding destination sample objects, the comparator logic  may identify a particular sample object comparison sets () and begin the object comparison process. As discussed above, the comparator logic  may employ an iterative comparison process, traversing the compared objects node-by-node. During the comparison process, the comparator logic  may identify differences present within the comparison set of sample objects. The comparator logic  may continue the comparison process if a differences are identified (). When a difference has been identified, the comparator logic  may identify the path location in the source sample object  where the difference occurred (). Additionally, the comparator logic  may determine an operation to later perform on application objects based on the identified difference in the sample objects (). Example operations may include an Insert operation, a Delete operation, a Modify operation, or any combination thereof. The comparator logic  may then store the identified difference (including the identified path and the determined operation) in the version difference table  ().","The comparator logic  may employ the described iterative comparison process, node-by-node, for each of the received comparison sets of sample objects. Each identified difference may be stored in the version difference table , increasing the completeness of the version difference table . The comparison process may complete when the comparator logic  compares every received comparison set and no more differences are identified (). The version difference table  may then reflect the differences between platform versions as identified from the comparison sets of sample objects.","Once the sample object comparison process has completed, the software application porting system  may identify the enforced differences  and the unenforced differences  stored in the version difference table  (). The software application porting system  may then generate a filtered version difference table  (). In one implementation, the system  may generate the filtered version difference table  by removing from the version difference table  any entry characterized as an unenforced difference . In an alternative implementation, the system  may generate a filtered version difference table  by keeping any entry characterized as an enforced difference .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5","FIG. 5"],"b":["120","235","120","510","520","232","521","528"]},"Each table row in the version difference table  may specify one difference in an object comparison set as identified by the comparator logic . As discussed above, the identified difference in the object comparison set may identify a difference between platform versions. The Tag column  may specify the specific tag to which the comparator logic  identified a difference between the received sample objects. The Operation column  may identify the operation determined by the comparator logic  to later perform on application objects based on the identified difference in the sample objects (e.g., Modify, Insert, Delete, etc.). The Old Tag Value column  may identify the tag value of the source sample object  for the differing tag (i.e., the tag specified in the Tag column ). The New Tag Value column  may identify the tag value of the destination sample object  for the differing tag. The Identified Path column  may identify the path location where the comparator logic  identified the difference in sample objects, as discussed above. The Enforced? column  may identify whether the identified difference is an enforced difference  or an unenforced difference .","A table row storing an identified difference may have no stored data in the Old Tag Value column  (e.g., , ). When the determined operation is an Insert operation (i.e., a new tag and corresponding tag value are present only in the destination platform version), the differing tag may not exist in the source platform version. Thus, the different tag and tag value may not be present in the source sample object  at the identified path. Similarly, the version difference table  many include table rows where the New Tag Value column  has no stored data (e.g., , ). When the determined operation is a Delete operation (i.e., a tag and corresponding tag value present only in the source platform version), the differing tag may not exist in the destination platform version. Accordingly, the differing tag and tag value may not be present in the destination sample object  at the identified path.","To elaborate on one example, the table row  in the version difference table  identifies a difference between a received source sample object  and a corresponding destination sample object . The comparator logic  may have identified the difference between the sample objects at a path location of \u201cRepository\\Project\\Applet\u201d as indicated by the Identified Path column value in the row . The difference identified by the comparator logic  concerned the tag \u201cFLOW_LAYOUT.\u201d The \u201cFLOW_LAYOUT\u201d tag had a tag value of \u201cY\u201d in the source sample object , and was not present in the destination sample object . As such, the comparator logic  may have determined that a Delete operation was appropriate to perform on source application objects with a \u201cFLOW_LAYOUT\u201d tag at the \u201cRepository\\Project\\Applet\u201d path.","The software application porting system  may filter the version difference table  based on the enforced differences , as indicated by the Enforced? column . The filtering process may result in a filtered version difference table . In the example shown in , the filtered version difference table  includes 4 table rows (e.g., -), each of which had an Enforced? column value of \u201cYes\u201d in the version difference table  from which the filtered version difference table  was generated. The filtered version difference table  may specify how the porting logic  should alter received source application objects to generate destination application objects with increased compatibility with the destination platform version. For example, according to a table row  of the filtered version difference table  depicted in , the porting logic  may insert within received source application objects an \u201cALLOW_OBJECT_LOCKING\u201d tag with a corresponding \u201cY\u201d tag value at the \u201cRepository\\Project\u201d path. According to the table row , the porting logic  may also insert within received source application objects a \u201cUI_FREEZE\u201d tag with a corresponding \u201cN\u201d tag value at the \u201cRepository\\Project\u201d path as well. In a similar way, the filtered version difference table  may specify Delete and Modify operations (e.g., table rows , ) for the porting logic  to execute when altering received source application objects during the porting process.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 6","FIG. 3","FIG. 2"],"b":["100","236","237","100","235","231","310","602","100","250","231","604","100","250","236"]},"In one implementation, the porting logic  may receive three inputs: the application object porting list  (), the source application objects in XML format (), and the filtered version differences from the filtered version difference table  (). As discussed above, the application object porting list  may specify the particular received source application objects that the porting logic  should port from the source platform version to the destination platform version. The filtered version differences may identify the particular differences identified by the comparator logic  the porting logic  should include in porting the source application objects.","Next, the porting logic  may alter the specified source application objects according to the filtered differences in order to generate destination application objects (). The porting logic  may alter received source application objects by performing operations specified in the filtered version difference table , including Insert, Modify, and Delete operations and combinations thereof. The porting logic  perform each determine operation relevant to the source application object (i.e., all identified differences with an identified path located in the source application object ). The porting process results in the generation of destination application objects. In one implementation, the generated destination application objects may then be stored in the destination application object database .","The software application porting system  may import the generated destination application objects into a destination system (). The porting process may produce destination application objects in XML format. As such, the importing logic  may convert the generated destination application objects to a native destination platform format compatible with the destination system . Alternatively, the destination system  may include functionality capable to import and convert objects in a tag based language format to the native destination platform format.","In addition to source code included or represented in application objects, software applications may also include data. The data schemas specifying the format of data may vary between platform versions. Even if the generated destination application objects are completely compatible with the destination platform version, the software application may not function properly because of incompatible data schemas. The software application porting system  may also port data schemas from a source platform version to a destination platform version as well.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 7","FIG. 7"],"b":["700","700","750","760","700","702","704"]},"In one implementation, a source application schema  may be input to the schema porting system  as a source sample schema . The schema porting process may be required when the destination platform version includes standard vendor schemas. The destination sample schema  may be a standard data schema supplied by the platform vendor. For example, Siebel may provide a standard data schema for a customer data table in Siebel 7.8, including specific fields and the length of each field.","The memory  may store schema extraction logic , schema comparator logic , schema porting logic , and schema importing logic . The schema extraction logic  may be implemented as processor executable instructions to convert received schemas (either sample or application) to XML or another tag based format. In one respect, the extraction logic  may also extract the source application schemas from a source system . The schema comparator logic  may be implemented as processor executable instructions to compare a source sample schema  in the native platform version and a destination sample schema  in the destination platform version. In one implementation, the schema comparator logic  may employ an iterative, node-by-node, comparison process to identify differences in schema comparison sets. The schema comparator logic  may also determine an operation to perform in order to port received source application schemas (i.e., a source application schema ).","Schema altering operations may include a Modify operation, an Insert operation, or combinations thereof. As an example, the \u201cNAME\u201d field of a customer table schema in Siebel 7.5 (the source platform version) may have a field length of 30 characters. The \u201cNAME\u201d field for a corresponding standard vendor customer table schema in Siebel 7.8 (the destination platform version) may have a field length of 80 characters. The schema comparator logic  may determine that a Modify operation is appropriate to alter received source application customer table schemas with a \u201cNAME\u201d field. In another example, a customer table schema in Siebel 7.5 may not have a \u201cPHONE NUMBER\u201d field whereas a corresponding customer table schema in Siebel 7.8 does. The schema comparator logic  may determine that an Insert operation is appropriate (i.e., inserting a \u201cPHONE NUMBER\u201d field to source application customer table schemas) when porting source application schemas.","Additionally, the comparator logic  may instead determine that no action is needed for an identified difference between sample schemas. For example, the \u201cNAME\u201d field of a customer table schema in Siebel 7.5 (the source platform version) may have a field length of 80 characters. The \u201cNAME\u201d field for a corresponding standard vendor customer table schema in Siebel 7.8 (the destination platform version) may have a field length of 30 characters. If the \u201cNAME\u201d field in Siebel 7.5 application customer table schemas were reduced to 30 characters, previously stored application data may be truncated and lost. As such, the schema comparator logic  may determine that source application customer table schema with a \u201cNAME\u201d field width of 80 characters do not require any altering.","The schema porting system  may store schema differences identified by the schema comparator logic  in the schema version difference table . The identified schema differences between platform versions may include enforced schema differences  and unenforced schema differences . Similar to object enforced differences  and object unenforced differences , distinctions between enforced and unenforced schema differences may be manually generated by a programmer or user. The generated differences may indicate a programmer's decision to exclude schema differences that relate to obsolete or undesired functionality. Utilizing the enforced schema differences  and unenforced schema differences , the software application porting system  may generate a filtered schema version difference table  in a manner similar to generating a filtered version difference table .","The schema porting logic  may be implemented as processor executable instructions to transform received source application schemas into destination application schemas with increased compatibility with the destination platform version. Specifically, the schema porting logic  may receive as inputs the source application schemas (e.g., ), an application schema porting list , and filtered version differences from the filtered schema version difference table . Like its object counterpart, the application schema porting list  may specify the particular source application schemas to port from the source platform version to the destination platform version. A programmer may manually generate the application schema porting list , eliminating schemas supporting obsolete or unwanted application functionality. The schema porting logic  may alter received source application schemas based on operations determined by the schema comparator logic . As a result, the schema porting logic  may generate destination application schemas (i.e., ) with increased compatibility with the destination platform version. In one implementation, the generated destination application schemas are in a tag based format, such as XML.","The importing logic  may be implemented as processor executable instructions to convert generated destination application schemas from a tag based format to a data format compatible with a destination system . As one example, the importing logic  may convert generated destination application schemas from XML to a relational database format compatible with a destination system . The importing logic  may also import the converted destination application schemas into the destination system  as well.","The schema porting system  may port a data schema in a way similar to the way that the software application porting system  ports an application object.  shows logic that the schema porting system  may implement as the schema extraction logic , the schema comparator logic , the schema porting logic , and the schema importing logic  for porting a database schema from a source platform version to a destination platform version. As discussed above, the software application porting system  may receive source sample schemas () and corresponding destination sample schemas (). A source sample schema  and a corresponding destination sample schema  may form a schema comparison set. By comparing each received comparison set of sample schemas, the schema comparator logic  may identify the differences between platform versions (). The comparator logic  may identify where in the schema a difference is identified (e.g., a field location) and the difference (e.g., varying field widths). The comparator logic  may further determine an operation to perform based on the identified difference (e.g., Insert, Modify, or no action).","Next, the schema porting system  may generate a filtered schema version difference table  (), as described in greater detail above. Upon identifying schema differences between platform versions (i.e., data in the filtered schema version difference table ), the software application porting system  may receive source application schemas (). As an example, the software application porting system  may extract the source application schemas from the source system .","The schema porting logic  may then receive three inputs (). First, the schema porting logic  may receive the source application schemas (e.g., ) to port to the destination platform version. Second, the schema porting logic  may receive the application schema porting list  indicating which specific source application schemas the schema porting logic  should alter. Third, the schema porting logic  may receive the identified schema differences via the filtered schema version difference table . Upon receiving the three inputs, the schema porting logic  may alter source application schemas according to the identified schema differences in order to generate destination application schemas (e.g., ) (). Lastly in , the software application porting system  may import the generated application schemas into a destination system  ().",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 9","b":["910","920","930","910","702","920","704","910","920","100"]},"The source database schema  may be compatible with a source platform version, such as Siebel 7.5. The source database schema  may include a \u201cNAME\u201d field  with a field width of 30 characters, an \u201cADDRESS\u201d field  with a field width of 100 characters, a \u201cCITY\u201d field  with a field width of 15 characters, a \u201cSTATE\u201d field  with a field width of 2 characters, a \u201cZIP\u201d  field with a field width of 5 characters, and a \u201cPERSON CODE\u201d field  with a field width of 5 characters.","The destination database schema  may be compatible with a destination platform version, such as Siebel 7.8. The destination database schema  may include a corresponding \u201cNAME\u201d field  with a field width of 30 characters, a corresponding \u201cADDRESS\u201d field  with a field width of 40 characters, a corresponding \u201cCITY\u201d field  with a field width of 15 characters, a corresponding \u201cSTATE\u201d field  with a field width of 15 characters, a corresponding \u201cZIP\u201d field  with a field width of 9 characters, and a \u201cPHONE #\u201d field  with a field width of 10 characters.","Upon receiving the source database schema  and the destination database schema  as inputs, a software application porting system  may generate the ported database schema . The ported database schema  may have increased compatibility with the destination platform version. In , the field width is consistent between the \u201cNAME\u201d fields of each platform version (i.e.,  and ) and the \u201cCITY\u201d fields of each platform version (i.e.,  and ). Accordingly, the ported database schema  includes a \u201cNAME\u201d field  with a matching field width of 30 characters and a \u201cCITY\u201d field  with a matching field width of 15 characters. The \u201cADDRESS\u201d field  of the source database schema  is greater in length than the \u201cADDRESS\u201d field  of the destination database schema . As such, the ported database schema  may receive the field width of the 100 character \u201cADDRESS\u201d field  field width from the source database schema . Similarly, the destination database schema  has longer field widths that the source database schema  for both the \u201cSTATE\u201d field (e.g.,  and ) and the \u201cZIP\u201d field (e.g.,  and ). Thus, the ported database schema  may receive the field widths for the \u201cSTATE\u201d field  and the \u201cZIP\u201d field  from the destination database schema fields. In , the respective field widths of the ported database schema  are 15 characters for the \u201cSTATE\u201d field  and 9 characters for the \u201cZIP\u201d field .","As discussed above, the schema porting system  may alter a source application schema  to receive the longer of differing field widths between platform versions. By having ported schemas receive the longer field width of compared platform versions field widths, the schema porting system  may prevent truncation (i.e., loss) of data previously generated by the software application in the source platform version. Having ported schemas receive the longer field width between platform versions may also support application functionality present in the destination platform version that requires additional characters of data.","Similarly, the ported database schema  may include table fields present only in the source platform version or the destination platform version. In the example shown in , the ported database schema  includes both a \u201cPERSON CODE\u201d field  and a \u201cPHONE #\u201d field . The source database schema  includes a corresponding \u201cPERSON CODE\u201d field , but not a \u201cPHONE #\u201d field. The destination database schema  includes a corresponding \u201cPHONE #\u201d field , but not a \u201cPERSON CODE\u201d field. The software application porting system  may determine that both fields should be present in the ported database schema . Doing so may prevent truncation of data previously generated by the software application (e.g., keeping the \u201cPERSON CODE\u201d field) and support functionality present in the destination platform version requiring additional fields (e.g., the \u201cPHONE #\u201d field ).","In general, the logic and processing described above may be encoded or stored in a machine-readable or computer-readable medium such as a compact disc read only memory (CDROM), magnetic or optical disk, flash memory, random access memory (RAM) or read only memory (ROM), erasable programmable read only memory (EPROM) or other machine-readable medium as, for examples, instructions for execution by a processor, controller, or other processing device. The medium may be implemented as any device or tangible component that contains, stores, communicates, propagates, or transports executable instructions for use by or in connection with an instruction executable system, apparatus, or device. Alternatively or additionally, the logic may be implemented as analog or digital logic using hardware, such as one or more integrated circuits, or one or more processors executing instructions that perform the processing described above, or in software in an application programming interface (API) or in a Dynamic Link Library (DLL), functions available in a shared memory or defined as local or remote procedure calls, or as a combination of hardware and software. As examples, the extraction logic , the comparator logic , and the porting logic  may be implemented in software, hardware, or both. The logic may be functionally partitioned to meet to goals of any specific implementation. For example, the extraction logic , the comparator logic , and the porting logic  may be separate processing systems or individual programs, or may be integrated into a single processing system or program.","The systems may include additional or different logic and may be implemented in many different ways. A processor may be implemented as a controller, microprocessor, digital signal processor, microcontroller, application specific integrated circuit (ASIC), discrete logic, or a combination of other types of circuits or logic. Similarly, memories may be Dynamic Random Access Memory (DRAM), Static Random Access Memory (SRAM), Flash, or other types of memory. Parameters (e.g., conditions and thresholds) and other data structures may be separately stored and managed, may be incorporated into a single memory or database, or may be logically and physically organized in many different ways. Programs and instructions may be parts of a single program, separate programs, implemented in libraries such as Dynamic Link Libraries (DLLs), or distributed across several memories, processors, cards, and systems.","While various embodiments of the invention have been described, it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the invention. Accordingly, the invention is not to be restricted except in light of the attached claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The system may be better understood with reference to the following drawings and description. In the figures, like reference numerals designate corresponding parts throughout the different views.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
