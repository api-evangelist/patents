---
title: Method and apparatus for performing configuration of aeronautical system in compliance with the ARINC 653 standard
abstract: Disclosed herein are a method and apparatus for performing a configuration of an aeronautical system. The apparatus includes a display unit, an intermediate model generation unit, an Extensible Markup Language (XML) conversion unit, and a translator. The display unit display displays a user interface for receiving aeronautical system setting information in compliance with an ARINC 653 standard. The intermediate model generation unit generates an intermediate model of source code based on the setting information received via the user interface. The XML conversion unit creates an XML document by performing XML conversion on the generated intermediate model. The translator generates a source code file in compliance with the ARINC 653 standard by converting the generated XML document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09032366&OS=09032366&RS=09032366
owner: Electronics and Telecommunications Research Institute
number: 09032366
owner_city: Daejeon
owner_country: KR
publication_date: 20130213
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application claims the benefit of Korean Patent Application No. 10-2012-0039710, filed on Apr. 17, 2012, which is hereby incorporated by reference in its entirety into this application.","1. Technical Field","The present invention relates generally to a method and apparatus for performing a configuration of an aeronautical system, which facilitate ARINC 653 configurations when writing an aeronautical application program in accordance with the ARINC 653 standard, and, more particularly, to a method and apparatus that facilitate the setting of an aeronautical system using a method and apparatus for receiving setting information via a user interface, a method and apparatus for allowing set information to refer to a target source code template, and a method and apparatus for generating source code from the setting information.","2. Description of the Related Art","The fields of industry requiring a high-level of safety, such as the aeronautical and nuclear power generation industries, have the tendency to adhere to existing system architectures. However, this tendency leads system management to high-cost, low-efficient structures, and therefore a changeover to architectures that use high-performance processors is being called for. A high-performance processor allows a plurality of application programs to run on a single processor, but it is difficult to guarantee safety in that environment. Therefore, safety should be basically provided at the level of a platform.","Accordingly, for the management of an aeronautical system, Aeronautical Radio, Inc. established an avionics standard in order to enhance safety and maintain compatibility in aeronautical management.","In particular, ARINC 653 stipulates the interface between a real-time Operating System (OS) and application programs running on the real-time OS. That is, ARINC 653 is a standard for the development of aeronautical software, and is a real-time OS Application Programming Interface (API) standard that is needed for integrated modular avionics systems. ARINC 653 stipulates APplication EXecutive (APEX), which is the interface between an OS and application programs running on the OS.","Therefore, using the standard API, the dependency on developing hardware can be reduced, the portability to other systems can be enhanced, and the simultaneous development of aeronautical system applications can be facilitated, in the development of avionics software.","ARINC 653 is used in conjunction with the concept of Integrated Modular Avionics (IMA). While an existing federated system runs application software on a plurality of processors, IMA is based on a platform concept that replaces a plurality of processors with a single high-performance processor. A federated system has the disadvantage of each function separately running on one or more processors, and the disadvantage of having software that is poor in terms of reuse, portability and modularization. IMA has the advantage of enabling a plurality of functions to be performed on a single processor and the advantage of increasing the reuse, portability and modularization of software.","However, while ARINC 653 system settings play a decisive role in enhancing the portability of aeronautical application software, ARINC 653 system settings have the problem of having the risk of erroneous set values leading to a fatal defect.","Accordingly, the present invention has been made keeping in mind the above problems occurring in the prior art, and an object of the present invention is to provide a method and apparatus that facilitate ARINC 653 configurations.","That is, the object of the present invention is to provide an ARINC 653 configuration method and apparatus that provide a user setting interface, a code template, and code generation rules, assisting in system settings, when carrying out development in compliance with the ARINC 653 standard, thereby improving the convenience and accuracy of ARINC 653 configurations.","In order to accomplish the above object, the present invention provides a method of performing a configuration of an aeronautical system in compliance with an ARINC 653 standard via generation of a source code file, the method including displaying a user interface, and receiving setting information in compliance with the ARINC 653 standard; generating an intermediate model of source code based on the received setting information; creating an Extensible Markup Language (XML) document by performing XML conversion on the generated intermediate model; and generating a source code file in compliance with the ARINC 653 standard by converting the generated XML document.","In order to accomplish the above object, the present invention provides an apparatus for performing a configuration of an aeronautical system, including a display unit display configured to display a user interface for receiving aeronautical system setting information in compliance with an ARINC 653 standard; an intermediate model generation unit configured to generate an intermediate model of source code based on the setting information received via the user interface; an XML conversion unit configured to create an XML document by performing XML conversion on the generated intermediate model; and a translator configured to generate a source code file in compliance with the ARINC 653 standard by converting the generated XML document.","Embodiments of the present invention will be described in detail below with reference to the accompanying drawings. Furthermore, the terms \u201cdevice\u201d and \u201cmodule\u201d added to elements in the following description are used merely for ease of preparation of the specification. The terms \u201cdevice\u201d and \u201cmodule\u201d may be interchangeable and designed in the form of hardware or software.","While the embodiments of the present invention will be described in detail below with reference to the accompanying drawings and the descriptions given in the accompanying drawings, the present invention is not limited to the embodiments of the present invention.","The present invention includes user interfaces for ARINC 653 configurations, a set source code template, and code generation rules for obtaining source code from the user interface, as embodiments.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 1","FIG. 2"]},"According to this embodiment, when information about ARINC 653 configuration values is received via the user interfaces  at step S, an intermediate model  is first generated and then stored in memory at step S. Thereafter, XML conversion is performed based on an ARINC 653 XML schema standard, and an XML document  is created at step S. Thereafter, source codes , , , . . . are generated from the XML file via a translator  at step S.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3"},"According to this embodiment, in order to enable a shared input\/output (IO) (Shared_IO) function to be set when writing avionics software, the ARINC 653 XML schema standard may be extended, as shown in . ShareIO_List includes one or more shared IO components, and each of the shared IO components includes its name Name, its physical address PhysicalAddress and its size Size as its attributes. It further includes at least one authority component having a partition ID and access as its attributes.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 4","FIG. 4"],"b":["402","403","401"]},"The first and second code paragraphs  and  of  are portions that are newly defined and added to the existing ARINC 653 XML schema standard according to the embodiment of the present invention, and the remaining portion corresponds to the code of the original ARINC 653 XML schema standard that represents the locations at which the added pieces of code are inserted.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 5 to 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5"},"According to this embodiment, when a user selects a module configuration item  from a menu, a user setting interface including a menu item  for receiving module configuration information, a menu item  for receiving module scheduling information, and a menu item  for receiving information about the shared IO component of a module may be displayed.","The menu item  for receiving module configuration information may receive information about the name, version and ID of a module.","Furthermore, the menu item  for receiving module scheduling information may receive information about important frames. The menu item  for receiving information about the shared IO component of a module may receive information about the name, physical address and size of each shared IO component.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6"},"According to this embodiment, when a user selects a partition item  from a setting menu, a user setting interface including a menu item  for receiving partition attributes information, a menu item  for receiving sampling port information, a menu item  for receiving queuing port information, a menu item  for receiving memory requirement information, a menu item  for receiving process information, a menu item  for receiving scheduling information, and a menu item  for receiving information about a shared IO component may be displayed.","Furthermore, according to this embodiment, the menu item  for receiving partition attributes information may receive information about the ID id, name Name, critical Critical, sys-partition SysPartition and entry point EntryPoint of a partition.","The menu item  for receiving sampling port information may receive information about a name, the maximum message size MaxMessageSize, a direction Direction and refresh rate time RefreshRateSecond.","The menu item  for receiving queuing port information may receive information about a name Name, the maximum message size MaxMessageSize, a direction Direction and the maximum number of messages MaxNbMessage.","The menu item  for receiving memory requirement information may receive information about a name Name, a type Type, a direction Direction, a size Size, a physical address PhysicalAddress and access Access.","The menu item  for receiving process information may receive information about a name Name and a stack size StackSize.","The menu item  for receiving scheduling information may receive information about an ID ID, a window start Window Start, a window duration Window Duration and a partition start Part.PreiodStart.","The menu item  for receiving information about a shared IO component may receive information about a name Name and access Access.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7"},"According to this embodiment, when a user selects a channel item  from a setting menu, a user setting interface, including a menu item  for receiving channel attributes information, a menu item  for receiving source information, and a menu item  for receiving destination information may be displayed.","Furthermore, according to this embodiment, the menu item  for receiving channel attributes information may receive information about the ID and name of a channel.","Furthermore, the menu item  for receiving source information may receive information about a selection item capable of the selection of a standard partition or a pseudo partition, a port name PortName, a partition ID PartitionID, a partition name PartitionName, a physical address PhysicalAddress, a name Name, and a procedure Procedure.","Furthermore, the menu item  for receiving information about a destination Destination may receive information about a selection item capable of the selection of a standard partition Standard Partition or a pseudo partition Pseudo Partition, a port name PortName, a partition ID PartitionID, a partition name PartitionName, a physical address PhysicalAddress, a name Name, and a procedure Procedure.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 8"},"According to this embodiment, when a user selects a health monitor setting item  from a setting menu, a user setting interface, including a system health monitor setting page , a module health monitor setting page , and a partition health monitor setting page , may be displayed.","Each of the pages ,  and  may include a menu that is used to receive health monitor setting items.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 9"},"According to this embodiment, an ARINC 653 configuration apparatus may include a display unit  for displaying a user interface for receiving information about ARINC 653 configurations via an input interface unit , an intermediate model generation unit  for generating an intermediate model of source code based on the information about settings received via the user interface, an XML conversion unit  for creating an XML document by performing XML conversion on the generated intermediate model, and a translator  for generating an ARINC 653 source code file by converting the created XML document. Furthermore, the respective units may be controlled via a control unit .","Furthermore, the display unit  may display a user interface including a menu for receiving at least one piece of setting information that is selected from among module configuration information, partition information, channel information, and health monitor information.","Furthermore, the XML conversion unit  may use an extended ARINC 653 XML schema standard that enables a shared IO function to be set.","Furthermore, the translator  may generate the ARINC 653 source code file in a form corresponding to a preset source code template, and may create the ARINC 653 source code file in a form corresponding to the preset source code template based on preset source code conversion rules.","A source code template and code generation rules according to an embodiment of the present invention will be described in detail below.","That is, in the following description, the source code template will be defined along with simple descriptions, and rules that convert an XML file in which set values have been stored into source code which complies with the template will also be described. Each of the rules will be described on the assumption that an XML file has been given.","Furthermore, in the following description, the sign \u201c< >\u201d indicates an XML tag, and represents a set of corresponding tags in an input XML file.","That is, <Partition> that is used in the following description of rules means a set of all partition tags that is declared in an input XML file. If p\u03b5<Partition>, this means that p is one of partition tags. p.PartitionIdentifier means the value of a partition ID attribute that belongs to tag p. Furthermore, \u2225 is used as a sign indicative of the number of sets. That is, |<Partition>| means the number of all <Partition> tags that are present in a given XML file. Furthermore, p.<Process> means a set of process tags that belong to partition p. <Process> without a prefix means a set of all process tags in an XML file. When conversion rules are defined below, data types, such as reserved words and arrays, for example, \u201cprint,\u201d \u201cif\u201d or the like, that are used in general high-level languages are used. In particular, \u201cfor each\u201d means application to all the elements of a corresponding set, and \u201csome\u201d means application to some element(s) of a corresponding set. Accordingly, when a \u201csome\u201d syntax is applied to a set having a single element, the \u201csome\u201d indicates the corresponding element. That is, when for each p\u03b5<Partition> { . . . }, it means that the processing within { } is applied to each element p of a partition tag set. When some s\u03b5<Source>{ . . . }, it means that the processing within { } is applied to some element(s) s of a source tag. Here, since <Source> appears once per channel tag, \u201cs\u201d is a singular value. A comma (,) used in a print statement means string-join. In order to define a function, the form of func function_name par1, . . . , parN{ . . . } is used. As in a general high-level language, the returning of a return value is defined using a return syntax. The sign \u201c-\u201d is used for comments.","First, the configurations included in Kernel_Conf.hfile will be described below.","(1) NEEDS_PARTITIONS\n\n",{"@attributes":{"id":"p-0068","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201c#define NEEDS_PARTITIONS\u20021\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(2) NEEDS_SCHED\n\n",{"@attributes":{"id":"p-0070","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201c#define NEEDS_SCHED \u20021\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(3) NEEDS_IO","NEEDS_IO is a macro that indicates that IO services must be activated, so that some partitions are made to perform IO.",{"@attributes":{"id":"p-0073","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"#define NEEDS_IO \u20021"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(4) NEEDS_PORTS_SAMPLING","NEEDS_PROTS_SAMPLING implies that a sampling port service for inter-partition communication is included.",{"@attributes":{"id":"p-0076","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"if (|<Sampling_Port>|> 0){"]},{"entry":[{},"print \u201c#define NEEDS_PORTS_SAMPLING 1\u201d"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(5) NEEDS_PORTS_QUEUEING","A queuing port service for inter-partition communication is needed.",{"@attributes":{"id":"p-0079","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"if (|<Queueing_Port>|> 0){"]},{"entry":[{},"print \u201c#define NEEDS_PORTS_QUEUEING 1\u201d"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(6) CONFIG_NB_THREADS","CONFIG_NB_THREADS specifies the number of threads in a system. This represents how many threads can be handled in a kernel. Furthermore, the number of threads is computed like this: the number of threads in the system+2. Furthermore, in this macro, two threads, that is, a kernel thread and an idle thread, are added. Here, the thread means the process of an ARINC 653 partition.",{"@attributes":{"id":"p-0082","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201c#define CONFIG_NB_THREADS \u201d, |<Process>| + 2"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(7) CONFIG_NB_PARTITIONS","CONFIG_NB_PARTITIONS is a macro that specifies the number of partitions that are handled in the kernel.",{"@attributes":{"id":"p-0085","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201c#define CONFIG_NB_PARTITIONS \u201d, |<Partition>|"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(8) CONFIG_PARTITIONS_NTHREADS","CONFIG_PARTITIONS_NTHREADS is a macro that specifies how many threads reside in partitions. This macro is an array. Each index of this array represents a partition. Each value represents the number of threads of a corresponding partition. The following embodiment is a code that represents four partitions that have 2, 2, 2, and 4, respectively.",{"@attributes":{"id":"p-0088","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define CONFIG_PARTITIONS_NTHREADS {2, 2, 2, 4}"]},{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201c#define CONFIG_PARTITIONS_NTHREADS {\u201d"]},{"entry":[{},"count = 0"]},{"entry":[{},"for each p \u2208 <Partition> {"]},{"entry":[{},"print |<Process>|"]},{"entry":[{},"\u2003count = count + 1"]},{"entry":[{},"if (count <|<Partition>|){ print \u201c,\u201d}"]},{"entry":[{},"}"]},{"entry":[{},"print \u201c}\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(9) CONFIG_SCHEDULERING_MAJOR_FRAME","CONFIG_SCHEDULERING_MAJOR_FRAME specifies a major frame. The major frame is the time when inter-partition ports are flushed. This corresponds to the end of a scheduling cycle. In the following scheduling setting example, four slots of 500 ms are declared. A first slot is for a first partition, a second slot is for a second partition and so on. The major frame is 2 s.",{"@attributes":{"id":"p-0091","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define CONFIG_PARTITIONS_NTHREADS {2, 2, 2, 4}"},{"entry":"[Conversion Rule]"},{"entry":"for each ms \u2208 <Module_Schedule>{"},{"entry":"mfs = ms.MajorFrameSeconds"},{"entry":"print \u201c#define CONFIG_SCHEDULERING_MAJOR_FRAME\u201d, mfs"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(10) CONFIG_SCHEDULERING_NBSLOTS","CONFIG_SCHEDULERING_NBSLOTS specifies the number of time frames allocated for the execution of partitions.",{"@attributes":{"id":"p-0094","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define CONFIG_SCHEDULERING_NBSLOTS 4"]},{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"number = |<Window_Schedule>|"]},{"entry":[{},"print \u201c#define CONFIG_SCHEDULERING_NBSLOTS\u201d, number"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(11) CONFIG_SCHEDULERING_SLOTS","CONFIG_SCHEDULERING_SLOTS specifies the size of each slot in milliseconds.",{"@attributes":{"id":"p-0097","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define CONFIG_SCHEDULERING_SLOTS {500, 500, 500, 500}"},{"entry":"[Conversion Rule]"},{"entry":"print \u201c#define CONFIG_SCHEDULERING_SLOTS {\u201d"},{"entry":"count = 0"},{"entry":"for each w \u2208 <Window_Schedule> {"},{"entry":"print w.WindowDurationSecond * 1000"},{"entry":"count = count + 1"},{"entry":"\u2003if (count < |<Window_Schedule>|){ print \u201c,\u201d"},{"entry":"}"},{"entry":"print \u201c}\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(12) CONFIG_SCHEDULERING_SLOTS_ALLOCATION","CONFIG_SCHEDULERING_SLOTS_ALLOCATION specifies the allocation of each slot. It may be declared using an array. Each index of the array represents a partition, and each value represents each slot",{"@attributes":{"id":"p-0100","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define CONFIG_SCHEDULERING_SLOTS_ALLOCATION"},{"entry":"{0, 1, 2, 3}"},{"entry":"[Conversion Rule]"},{"entry":"print \u201c#define CONFIG_SCHEDULERING_SLOTS_ALLOCATION {\u201d"},{"entry":"count = 0"},{"entry":"for each ps \u2208 <Partition_Schedule> {"},{"entry":"for each ps.<Window_Schedule> {"},{"entry":"print ps.PartitionIdentifier"},{"entry":"count = count + 1"},{"entry":"\u2003\u2003if (count < |<Window_Schedule>|){ print \u201c,\u201d}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"print \u201c}\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(13) CONFIG_PARTITIONS_SME","CONFIG_PARTITIONS_SME specifies an array with partition sizes in bytes. Each index of an array represents a partition, and each value represents the size of the partition. The following example means that first three partitions have a size of 80000 bytes and the last partition has a size of 85000 bytes.",{"@attributes":{"id":"p-0103","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define CONFIG_PARTITIONS_SIZE {80000, 80000, 80000, 85000}"},{"entry":"[Conversion Rule]"},{"entry":"print \u201c#define CONFIG_PARTITIONS_SIZE {\u201d"},{"entry":"count = 0"},{"entry":"for each p \u2208 <Partition> {"},{"entry":"\u2003size = 0"},{"entry":"for each pm \u2208 <Partition_Memory> {"},{"entry":"\u2003if (p.PartitionName == pm.PartitionName){"},{"entry":"\u2003\u2003for each mr \u2208 pm.<Memory_Requirement> {"},{"entry":"\u2003\u2003\u2003size = size + mr.SizeBytes"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"\u2003print size"},{"entry":"count = count + 1"},{"entry":"\u2003if (count < |<Partition>|){ print \u201c,\u201d}"},{"entry":"}"},{"entry":"print \u201c}\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(14) CONFIG_LOCAL_NODE","CONFIG_LOCAL_NODE specifies the ID of a current node.",{"@attributes":{"id":"p-0106","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201c#define CONFIG_LOCAL_NODE 0\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(15) CONFIG_NB_GLOBAL_PORTS","CONFIG_NB_GLOBAL_PORTS is a macro that specifies the number of global ports in a distributed system.",{"@attributes":{"id":"p-0109","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"number = |<Queueing_Port>| + |<Sampling_Port>|"]},{"entry":[{},"print \u201c#define CONFIG_NB_GLOBAL_PORTS\u201d, number"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(16) CONFIG_NB_PORTS","CONFIG_NB_PORTS is a macro that specifies the number of local ports in a current node.",{"@attributes":{"id":"p-0112","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"number = |<Queueing_Port>| + |<Sampling_Port>|"]},{"entry":[{},"print \u201c#define CONFIG_NB_PORTS\u201d, number"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(17) port_local_identifier_t","port_local_identifier_t means a type that represent local port IDs declared in an \u2018enum\u2019. An invalid ID called \u2018invalid_identifier\u2019 must always be added to the type. This \u2018enum\u2019 declaration specifies the local ports of a current node and, consequently, is dependent on the communication requirements of each node.",{"@attributes":{"id":"p-0115","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\u2009typedef\u2003\u2003\u2002enum"},{"entry":"{node1_partition_secret_outgoing\u2003\u2003=\u2003\u20030,"},{"entry":"node1_partition_topsecret_outgoing = 1,"},{"entry":"node1_partition_unclassified_outgoing = 2,"},{"entry":"invalid_local_port = 3} port_local_indentitier_t;"},{"entry":"\u2003\u2003\u2003\u2009[Conversion Rule]"},{"entry":"\u2003\u2003\u2003\u2009max = |<Queueing_Port>| + |<Sampling_Port>|"},{"entry":"\u2003\u2003\u2003\u2009if (max > 0){"},{"entry":"\u2003\u2003\u2003\u2009pID = \u22121"},{"entry":"\u2003\u2003\u2003\u2009print \u201ctypedef enum {\u201d"},{"entry":"\u2003\u2003\u2003\u2009for each p \u2208 <Partition> {"},{"entry":"\u2003\u2003\u2003\u2009for each qp \u2208 p.<Queueing_Port> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002pID = pID + 1"},{"entry":"\u2003\u2003\u2003\u2009print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, qp. PortName,\u201d=\u201d, pID, \u201c,\u201d"},{"entry":"\u2003\u2003\u2003\u2009}"},{"entry":"\u2003\u2003\u2003\u2009for each sp \u2208 p.<Sampling_Port> {"},{"entry":"\u2003\u2003\u2003\u2009pID = pID + 1"},{"entry":"\u2003\u2003\u2003\u2009print \u201cp\u201d, p.PartitionIdentifier,\u201c_\u201d, sp. PortName,\u201c=\u201d, pID, \u201c,\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2009}"},{"entry":"\u2003\u2003\u2003\u2009pID = pID + 1;"},{"entry":"\u2003\u2003\u2003\u2009print \u201cinvalid_local_port = \u201d, pID"},{"entry":"\u2003\u2003\u2003\u2009print \u201c} port_local_identifier_t;\u201d"},{"entry":"\u2003\u2003\u2003\u2009} else {"},{"entry":"\u2003\u2003\u2003\u2009ERROR! - error occurred (no port)"},{"entry":"\u2003\u2003\u2003\u2009}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(18) port_identifier_t","A global port identifier is specified by declaring an \u2018enum\u2019 type. This enum declaration must be the same on all nodes.",{"@attributes":{"id":"p-0118","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2009typedef\u2003\u2003enum\u2003\u2003\u2009{node1_partition_secret_outgoing_global\u2003\u2003\u2009=","0,"]},{"entry":["node1_partition_topsecret_outgoing_global\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003=","1,"]},{"entry":["node1_partition_unclassified_outgoing_global\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002=","2,"]},{"entry":["node2_partition_secret_incoming_global\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2009=","3,"]},{"entry":["node2_partition_topsecret_incoming_global\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2009=","4,"]},{"entry":["node2_partition_unclassified_incoming_global = 5,} port_indentitier_t;",{}]},{"entry":["\u2003\u2003\u2003\u2009[Conversion Rule]",{}]},{"entry":["\u2003\u2003\u2003\u2009max = |<Queueing_Port>| + |<Sampling_Port>|",{}]},{"entry":["\u2003\u2003\u2003\u2009if (max > 0){",{}]},{"entry":["\u2003\u2003\u2003\u2009pID = \u22121",{}]},{"entry":["\u2003\u2003\u2003\u2009print \u201ctypedef enum {\u201d",{}]},{"entry":["\u2003\u2003\u2003\u2009for each p \u2208 <Partition> {",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2002for each qp \u2208 p.<Queueing_Port> {",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2002\u2009pID = pID + 1",{}]},{"entry":["\u2003\u2003\u2003\u2009print \u201cp\u201d, p.PartitionIdentifier,\u201c_\u201d,",{}]},{"entry":["\u2003\u2003\u2003\u2009qp. PortName,\u201c_global = \u201d, pID",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2002\u2009if (max > pID+1){ print \u201c,\u201d}",{}]},{"entry":["\u2003\u2003\u2003\u2009\u2002}",{}]},{"entry":["\u2003\u2003\u2003\u2009for each sp \u2208 p.<Sampling_Port> {",{}]},{"entry":["\u2003\u2003\u2003\u2009pID = pID + 1",{}]},{"entry":["\u2003\u2003\u2003\u2009print \u201cp\u201d, p.PartitionIdentifier,\u201c_\u201d, sp. PortName,\u201c_global = \u201d,",{}]},{"entry":["\u2003\u2003\u2003\u2009pID",{}]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2002\u2009if (max > pID+1){ print \u201c,\u201d}",{}]},{"entry":["\u2003\u2003\u2003\u2009}",{}]},{"entry":["\u2003\u2003\u2003\u2009}",{}]},{"entry":["\u2003\u2003\u2003\u2009print \u201c} port_identifier_t;\u201d",{}]},{"entry":["\u2003\u2003\u2003\u2009} else {",{}]},{"entry":["\u2003\u2003\u2003\u2009ERROR! -- error occurred (no port)",{}]},{"entry":"\u2003\u2003\u2003\u2009}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(19) node_identifier_t","node_identifier_t is a type that specifies a node identifier. The type contains the value of each node. The value of \u2018CONFIG_LOCAL_NODE\u2019 must be in this type. This enum declaration is the same on all nodes. An example thereof is as follows:",{"@attributes":{"id":"p-0121","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef enum {node1 = 0, node2 = 1 } node_indentitier_t;"]},{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201ctypedef enum {\u201d"]},{"entry":[{},"print \u201c node1 = 0\u201d"]},{"entry":[{},"print \u201c} node_identifier-t;\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(20) Config_NB_Shared_IO","CONFIG_NB_SHARED_IO is a macro that means the number of shared IOs. In a kernel source file, information about set Shared IOs is indicated.",{"@attributes":{"id":"p-0124","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"number = the number of <SharedIO> tags"]},{"entry":[{},"print \u201c#define CONFIG_NB_SHARED_IO \u201d, number"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(21) table_t declaration",{"@attributes":{"id":"p-0126","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[Conversion Rule]"},{"entry":"print \u201ctable_t\u2003system_hm_table;\u201d"},{"entry":"print \u201ctable_t\u2003\u2003\u2009module_hm_table;\u201d"},{"entry":"print \u201ctable_t\u2003\u2003\u2009partition_hm_table[CONFIG_NB_PARTITIONS];\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Second, the configurations included in Kernel_Conf.cfile will be described below.","(1) ports_identifiers","ports_identifiers is an array that specifies the global port of each local port. In the following embodiment, the first local port of a current node is the global port \u2018node1_partition_secret_outgoing.\u2019",{"@attributes":{"id":"p-0130","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\u2009unit8_t\u2003\u2003\u2003\u2002ports_identifiers[CONFIG_NB_PORTS]\u2003\u2003\u2002="},{"entry":"{node1_partition_secret_outgoing,"},{"entry":"node1_partition_topsecret_outgoing,"},{"entry":"node1_partition_unclassified_outgoing};"},{"entry":"\u2003\u2003\u2003\u2009[Conversion Rule]"},{"entry":"\u2003\u2003\u2003\u2009max = |<Queueing_Port>| + |<Sampling_Port>|"},{"entry":"\u2003\u2003\u2003\u2009if (max > 0){"},{"entry":"\u2003\u2003\u2003\u2009count = 0"},{"entry":"\u2003\u2003\u2003\u2009print \u201cunit8_t ports_identifiers[CONFIG_NB_PORTS] = {\u201d"},{"entry":"\u2003\u2003\u2003\u2009for each p \u2208 <Partition> {"},{"entry":"\u2003\u2003\u2003\u2003\u2002for each qp \u2208 p.<Queueing_Port> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002\u2009count = count + 1"},{"entry":"\u2003\u2003\u2003\u2009print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, qp.PortName"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002\u2009if (max > count){ print \u201c,\u201d}"},{"entry":"\u2003\u2003\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2003\u2009for each sp \u2208 p.<Sampling_Port> {"},{"entry":"\u2003\u2003\u2003\u2009count = count + 1"},{"entry":"\u2003\u2003\u2003\u2009print \u201cp\u201d, p.PartitionIdentifier,\u201c_\u201d, sp.PortName"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002\u2009if (max > count){ print \u201c,\u201d}"},{"entry":"\u2003\u2003\u2003\u2009}"},{"entry":"\u2003\u2003\u2003\u2009}"},{"entry":"\u2003\u2003\u2003\u2009print \u201c};\u201d"},{"entry":"\u2003\u2003\u2003\u2009} else {"},{"entry":"\u2003\u2003\u2003\u2009ERROR! -- error occurred (no port)"},{"entry":"\u2003\u2003\u2003\u2009}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(2) prots_nb_destinations","prots_nb_destinations is an array that specifies the number of destinations for each local port. prots_nb_destinations specifies how many ports should receive data because a plurality of receptions are possible for a single transmission port.",{"@attributes":{"id":"p-0133","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"func getDestNumber pName{"]},{"entry":[{},"for each c \u2208 <Channel> {"]},{"entry":[{},"\u2003\u2003some s \u2208 c.<Source> {"]},{"entry":[{},"if (|s.<Standard_Partition>| != 0){"]},{"entry":[{},"some spa \u2208 s.<Standard_Partition>{"]},{"entry":[{},"if (pName == spa.PortName){"]},{"entry":[{},"return |c.<Destination>|"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"return \u22121"]},{"entry":[{},"}"]},{"entry":[{},"max = |<Queueing_Port>| + |<Sampling_Port>|"]},{"entry":[{},"if (max > 0){"]},{"entry":[{},"print \u201cunit8_t ports_nb_destinations[CONFIG_NB_PORTS] = {\u201d"]},{"entry":[{},"count = 0"]},{"entry":[{},"for each p \u2208 <Partition> {"]},{"entry":[{},"\u2003for each qp \u2208 p.<Queueing_Port> {"]},{"entry":[{},"\u2003\u2003if (qp.Direction == \u201cDESTINATION\u201d){"]},{"entry":[{},"print 0"]},{"entry":[{},"\u2003\u2003}else{"]},{"entry":[{},"\u2003\u2003\u2003number_ds = getDestNumber(qp.PortName)"]},{"entry":[{},"\u2003\u2003\u2003if (number_ds < 1) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003ERROR! -- port and channel definition error"]},{"entry":[{},"\u2003\u2003\u2003}else{"]},{"entry":[{},"\u2003\u2003\u2003\u2003print number_ds"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"count = count + 1"]},{"entry":[{},"\u2003\u2003if (max > count){ print \u201c,\u201d}"]},{"entry":[{},"}"]},{"entry":[{},"\u2003for each sp \u2208 p.<Sampling_Port> {"]},{"entry":[{},"\u2003\u2003if (sp.Direction == \u201cDESTINATION\u201d){"]},{"entry":[{},"print 0"]},{"entry":[{},"\u2003\u2003}else{"]},{"entry":[{},"\u2003\u2003\u2003number_ds = getDestNumber (sp.PortName)"]},{"entry":[{},"\u2003\u2003\u2003if (number_ds < 1) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003ERROR! -- port and channel definition error"]},{"entry":[{},"\u2003\u2003\u2003}else{"]},{"entry":[{},"\u2003\u2003\u2003\u2003print number_ds"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"count = count + 1"]},{"entry":[{},"\u2003\u2003if (max > count){ print \u201c,\u201d}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"print \u201c};\u201d"]},{"entry":[{},"} else {"]},{"entry":[{},"ERROR! - error occurred (no port)"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(3) ports_destinations","ports_destinations is an array that specifies a local port routing policy. Each value of this array is a pointer to another array. The array that is connected by pointers contains the values of recipient global ports. In the following example, a first local port has one recipient. The recipient list is specified with the first elements of the \u2018ports_destinations\u2019 array. These elements are the \u2018node1_partition_secret_outgoing_deployment_destinations\u2019 array. In this manner, it can be seen that a recipient port identifier is \u2018node2_partition secert_incoming_global.\u2019",{"@attributes":{"id":"p-0136","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003uint8_t\u2003\u2003\u2002node1_partition_secret_outgoing_deployment_destinations[1]\u2003\u2002="},{"entry":"{node2_partition_secret_incoming_global};"},{"entry":"\u2003\u2003\u2003uint8_t\u2003\u2002node1_partition_topsecret_outgoing_deployment_destinations[1]\u2003\u2009="},{"entry":"{node2_partition_topsecret_incoming_global};"},{"entry":"\u2003\u2003\u2003uint8_t\u2003\u2003node1_partition_unclassified_outgoing_deployment_destinations[1]"},{"entry":"={node2_partition_unclassified_incoming_global};"},{"entry":"\u2003\u2003\u2003uint8_t ports_nb_destinations[CONFIG_NB_PORTS] = {1,1,1};"},{"entry":"\u2003\u2003\u2003uint8_t*\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2009ports_destinations[CONFIG_NB_PORTS]"},{"entry":"={node1_partition_secret_outgoing_deployment_destinations,"},{"entry":"node1_partition_topsecret_outgoing_deployment_destinations,"},{"entry":"node1_partition_unclassified_outgoing_deployment_destinations};"},{"entry":"\u2003\u2003\u2003[Conversion Rule]"},{"entry":"\u2003\u2003\u2003-- array pointer ports_destinations generation"},{"entry":"\u2003\u2003\u2003max = |<Queueing_Port>| + |<Sampling_Port>|"},{"entry":"\u2003\u2003\u2003if (max > 0){"},{"entry":"\u2003\u2003\u2003print \u201cuint8_t* ports_destinations[CONFIG_NB_PORTS] = {\u201d"},{"entry":"\u2003\u2003\u2003count = 0"},{"entry":"for each p \u2208 <Partition> {"},{"entry":"\u2003for each qp \u2208 p.<Queueing_Port> {"},{"entry":"\u2003\u2003if (qp.Direction == \u201cDESTINATION\u201d) {"},{"entry":"print \u201cNULL\u201d"},{"entry":"\u2003\u2003}else{"},{"entry":"\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, qp.PortName, \u201c_destinations\u201d"},{"entry":"\u2003\u2003}"},{"entry":"count = count + 1"},{"entry":"\u2003\u2003if (max > count){ print \u201c,\u201d}"},{"entry":"}"},{"entry":"\u2003for each sp \u2208 p.<Sampling_Port> {"},{"entry":"if (sp.Direction == \u201cDESTINATION\u201d) {"},{"entry":"print \u201cNULL\u201d"},{"entry":"\u2003\u2003}else{"},{"entry":"\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, sp.PortName, \u201c_destinations\u201d"},{"entry":"\u2003\u2003}"},{"entry":"count = count + 1"},{"entry":"\u2003\u2003if (max > count){ print \u201c,\u201d}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"print \u201c};\u201d"},{"entry":"} else {"},{"entry":"\u2002ERROR! -- error occurred (no port)"},{"entry":"}"},{"entry":"\u2003\u2003\u2003func findDestination (pName){"},{"entry":"\u2003\u2003\u2003for each c \u2208 <Channel> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003some s \u2208 c.<Source>{"},{"entry":"\u2003\u2003\u2003if (|s.<Standard_Partition>| != 0){"},{"entry":"\u2003\u2003\u2003some spa \u2208 s.<Standard_Partition>{"},{"entry":"\u2003\u2003\u2003if (pName == spa.PortName) {"},{"entry":"\u2003\u2003\u2003return c.<Destination>"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return { }"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003-- generate an array that belongs to ports_destinations"},{"entry":"\u2003\u2003\u2003if (max > 0){"},{"entry":"\u2003\u2003\u2003for each p \u2208 <Partition> {"},{"entry":"\u2003\u2003\u2003\u2003for each qp \u2208 p.<Queueing_Port> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003flag = 0"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (qp.Direction == \u201cSOURCE\u201d) {"},{"entry":"\u2003\u2003\u2003print \u201cunit8_t p\u201d, p.PartitionIdentifier, \u201c_\u201d, qp.PortName, \u201c_destinations[\u201d,"},{"entry":"getDestNumber(qp.PortName), \u201c] = {\u201d"},{"entry":"\u2003\u2003\u2003foreach dest \u2208 findDestination(qp.PortName) {"},{"entry":"\u2003\u2003\u2003\u2003foreach spa \u2208 dest.<Standard_Partition> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (flag = 1) { print \u201c, \u201d}"},{"entry":"\u2003\u2003\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, spa.PortName"},{"entry":"\u2003\u2003\u2003\u2003\u2003flag = 1"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003print \u201c};\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003for each sp \u2208 p.<Sampling_Port> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003flag = 0"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (sp.Direction == \u201cSOURCE\u201d) {"},{"entry":"\u2003\u2003\u2003print \u201cunit8_t p\u201d, p.PartitionIdentifier, \u201c_\u201d, sp.PortName, \u201c_destinations[\u201d,"},{"entry":"getDestNumber (sp.PortName), \u201c] = {\u201d"},{"entry":"\u2003\u2003\u2003foreach dest \u2208 findDestination (sp.PortName) {"},{"entry":"\u2003\u2003\u2003\u2003foreach spa \u2208 dest.<Standard_Partition> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (flag = 1) { print \u201c,\u201d}"},{"entry":"\u2003\u2003\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, spa.PortName"},{"entry":"\u2003\u2003\u2003\u2003\u2003flag = 1"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003print \u201c};\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003ERROR! -- error occurred (no port)"},{"entry":"\u2003\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(4) local_ports_to_global_ports","local_ports_to_global_ports is an array that performs the association (conversion) between each local and global port. The associated global port value is specified for each local port ID. In the following example, the first local port corresponds to the global port ID \u2018node1_partition_secret_outgoing_global.\u2019",{"@attributes":{"id":"p-0139","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"uint8_t"]},{"entry":[{},"local_ports_to_global_ports[CONFIG_NB_PORTS]"]},{"entry":[{},"={node1_partition_secret_outgoing_global,"]},{"entry":[{},"node1_partition_topsecret_outgoing_global,"]},{"entry":[{},"node1_partition_unclassified_outgoing_global};"]},{"entry":[{},"\u2003\u2003\u2003[Conversion Rule]"]},{"entry":[{},"\u2003\u2003\u2003max = |<Queueing_Port>| + |<Sampling_Port>|"]},{"entry":[{},"\u2003\u2003\u2003if (max > 0){"]},{"entry":[{},"\u2003\u2003\u2003count = 0"]},{"entry":[{},"\u2003\u2003\u2003print \u201cuint8_t global_ports_to_local_ports-"]},{"entry":[{},"\u2003\u2003\u2003CONFIG_NB_PORTS] = {\u201d"]},{"entry":[{},"\u2003\u2003\u2003for each p \u2208 <Partition> {"]},{"entry":[{},"\u2003\u2003\u2003\u2003for each qp \u2208 p.<Queueing_Port> {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003count = count + 1"]},{"entry":[{},"\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, qp.PortName, \u201c_global\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003if (max > count) { print \u201c,\u201d}"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003for each sp \u2208 p.<Sampling_Port> {"]},{"entry":[{},"\u2003\u2003\u2003count = count + 1"]},{"entry":[{},"\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, sp.PortName, \u201c_global\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003if (max > count){ print \u201c,\u201d}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003print \u201c};\u201d"]},{"entry":[{},"\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003ERROR! -- error occurred (no port)"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(5) global_ports_to_local_ports","When it is necessary to convert a global port value to a local port, an invalid_port value is specified if the global port is not on a current node because the definition of this array is different on all nodes. From the following embodiment, it can be seen that the three last ports are not located on the current node.",{"@attributes":{"id":"p-0142","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003uint8_t\u2003\u2002global_ports_to_local_ports-"]},{"entry":[{},"[CONFIG_NB_GLOBAL_PORTS]\u2003="]},{"entry":[{},"{node1_partition_secret_outgoing,"]},{"entry":[{},"node1 _partition_topsecret_outgoing,"]},{"entry":[{},"node1_partition_unclassified_outgoing,"]},{"entry":[{},"invalid_local_port, invalid_local_port, invalid_local_port};"]},{"entry":[{},"\u2003\u2003\u2003[Conversion Rule]"]},{"entry":[{},"\u2003\u2003\u2003max = |<Queueing_Port>| + |<Sampling_Port>|"]},{"entry":[{},"\u2003\u2003\u2003if (max > 0){"]},{"entry":[{},"\u2003\u2003\u2003count = 0"]},{"entry":[{},"\u2003\u2003\u2003print \u201cuint8_t local_ports_to_global_ports-"]},{"entry":[{},"\u2003\u2003\u2003[CONFIG_NB_PORTS] = {\u201d"]},{"entry":[{},"\u2003\u2003\u2003for each p \u2208 <Partition> {"]},{"entry":[{},"\u2003\u2003\u2003\u2003for each qp \u2208 p.<Queueing_Port> {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003count = count + 1"]},{"entry":[{},"\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, qp.PortName"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003if (max > count){ print \u201c,\u201d}"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003for each sp \u2208 p.<Sampling_Port> {"]},{"entry":[{},"\u2003\u2003\u2003count = count + 1"]},{"entry":[{},"\u2003\u2003\u2003print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, sp.PortName"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003if (max > count){ print \u201c,\u201d}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003print \u201c};\u201d"]},{"entry":[{},"\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003ERROR! -- error occurred (no port)"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(6) ports_nodes","The location of each global port is specified with this array. This array associates each port with a node identifier. In the following example, it can be seen that three global ports are located on node 0 and the remaining three global ports are located on node 1.",{"@attributes":{"id":"p-0145","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"uint8_t ports_nodes[CONFIG_NB_GLOBAL_PORTS] ="]},{"entry":[{},"{0,0,0,1,1,1};"]},{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"max = |<Queueing_Port>| + |<Sampling_Port>|"]},{"entry":[{},"if (max > 0){"]},{"entry":[{},"count = 0"]},{"entry":[{},"print \u201cuint8_t ports_nodes[CONFIG_NB_PORTS] = {\u201d"]},{"entry":[{},"for each p \u2208 <Partition> {"]},{"entry":[{},"\u2003for each qp \u2208 p.<Queueing_Port> {"]},{"entry":[{},"\u2003\u2003count = count + 1"]},{"entry":[{},"print 0"]},{"entry":[{},"\u2003\u2003if (max > count){ print \u201c,\u201d}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"for each sp \u2208 p.<Sampling_Port> {"]},{"entry":[{},"count = count + 1"]},{"entry":[{},"print 0"]},{"entry":[{},"\u2003\u2003if (max > count){ print \u201c,\u201d}"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},"print \u201c};\u201d"]},{"entry":[{},"} else {"]},{"entry":[{},"ERROR! -- error occurred (no port)"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(7) ports_kind","The kernel must know the kind of each port (queuing or sampling). That requirement is specified with a \u2018pok_ports_kind\u2019 array. In the following example, three local ports are all specified as the sampling port type.",{"@attributes":{"id":"p-0148","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003port_kind_t\u2003\u2003\u2003\u2003ports_kind[CONFIG_NB_PORTS]\u2003\u2003\u2003="},{"entry":"{PORT_KIND_SAMPLING,\u2003\u2003\u2003\u2003\u2003PORT_KIND_SAMPLING,"},{"entry":"PORT_KIND_SAMPLING};"},{"entry":"\u2003\u2003[Conversion Rule]"},{"entry":"\u2003\u2003max = |<Queueing_Port>| + |<Sampling_Port>|"},{"entry":"\u2003\u2003if (max > 0){"},{"entry":"\u2003\u2003count = 0"},{"entry":"\u2003\u2003print \u201cuint8_t ports_kind[CONFIG_NB_PORTS] = {\u201d"},{"entry":"\u2003\u2003for each p \u2208 <Partition> {"},{"entry":"\u2003\u2003\u2003for each qp \u2208 p.<Queueing_Port> {"},{"entry":"\u2003\u2003\u2003\u2003count = count + 1"},{"entry":"\u2003\u2003print \u201cPORT_KIND_QUEUEING\u201d"},{"entry":"\u2003\u2003\u2003\u2003if (max > count) {print \u201c,\u201d}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003for each sp \u2208 p.<Sampling_Port> {"},{"entry":"\u2003\u2003count = count + 1"},{"entry":"\u2003\u2003print \u201cPORT_KIND_SAMPLING\u201d"},{"entry":"\u2003\u2003\u2003\u2003if (max > count){ print \u201c,\u201d}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003print \u201c};\u201d"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003ERROR! -- error occurred (no port)"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(8) ports_names","When a develop calls port instantiation, a port name can be specified. For this reason, the kernel must know the name associated with each port. This information is provided by the ports_names declaration. This array contains the name of each local port. The following example is an example in which the name of a port is specified.",{"@attributes":{"id":"p-0151","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003port_kind_t\u2003\u2003\u2003ports_names[CONFIG_NB_PORTS]\u2003\u2003="},{"entry":"{\u201cnode1_partition_secret_outgoing\u201d,"},{"entry":"\u201cnode1_partition_topsecret_outgoing\u201d,"},{"entry":"\u201cnode1_partition_unclassified_outgoing\u201d};"},{"entry":"\u2003\u2003\u2003[Conversion Rule]"},{"entry":"\u2003\u2003\u2003max = |<Queueing_Port>| + |<Sampling_Port>|"},{"entry":"\u2003\u2003\u2003if (max > 0) {"},{"entry":"\u2003\u2003\u2003count = 0"},{"entry":"\u2003\u2003\u2003print \u201cchar* ports_names[CONFIG_NB_PORTS] = {\u201d"},{"entry":"\u2003\u2003\u2003for each p \u2208 <Partition> {"},{"entry":"\u2003\u2003\u2003\u2003for each qp \u2208 p.<Queueing_Port> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003count = count + 1"},{"entry":"\u2003\u2003\u2003print \u201c\u201c\u201d\u2019p\u201d, p.PartitionIdentifier, \u201c_\u201d, qp.PortName, \u201c\u201c\u201d\u201d\u2019"},{"entry":"\u2003\u2003if (max > count) { print \u201c,\u201d}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003for each sp \u2208 p.<Sampling_Port> {"},{"entry":"\u2003\u2003\u2003count = count + 1"},{"entry":"\u2003\u2003\u2003print \u201c\u201c\u201d\u2019p\u201d, p.PartitionIdentifier, \u201c_\u201d, sp.PortName, \u201c\u201c\u201d\u201d\u2019"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (max > count) {print \u201c,\u201d}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003print \u201c};\u201d"},{"entry":"\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003ERROR! -- error occurred (no port)"},{"entry":"\u2003\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(9) ports_nb_ports_by_partition","The inter-partition communication ports are dedicated to some partitions. Therefore, which partition is allowed to read\/write which port should be specified. Two arrays are required. This variable is an array that identifies the number of ports allocated for each partition.",{"@attributes":{"id":"p-0154","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[Conversion Rule]"},{"entry":"-- the number of ports for each partition"},{"entry":"print \u201cuint8_t ports_nb_ports_by_partition"},{"entry":"[CONFIG_NB_PARTITIONS] = {\u201d"},{"entry":"count = 0;"},{"entry":"for each p \u2208 <Partition> {"},{"entry":"count = count + 1"},{"entry":"print |p.<Queueing_Port>| + |p.<Sampling_Port>|"},{"entry":"\u2003if (|<Partition>| > count) {print \u201c,\u201d}"},{"entry":"}"},{"entry":"print \u201c};\u201d"},{"entry":"-- a port name for each partition"},{"entry":"for each p \u2208 <Partition> {"},{"entry":"partNum = |p.<Queueing_Port>| + |p.<Sampling_Port>|"},{"entry":"print \u201cuint8_t p\u201d, p.PartitionIdentifier, \u201c_partport[\u201d, partNum, \u201c] = {\u201d"},{"entry":"flag = 0"},{"entry":"for each qp \u2208 p.<Queueing_Port> {"},{"entry":"\u2003\u2003if (flag == 1) { print \u201c,\u201d}"},{"entry":"print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, qp.PortName"},{"entry":"\u2003\u2003flag = 1"},{"entry":"\u2003}"},{"entry":"flag = 0"},{"entry":"for each sp \u2208 p.<Sampling_Port> {"},{"entry":"\u2003\u2003if (flag == 1) { print \u201c,\u201d}"},{"entry":"print \u201cp\u201d, p.PartitionIdentifier, \u201c_\u201d, sp.PortName"},{"entry":"\u2003\u2003flag = 1"},{"entry":"}"},{"entry":"\u2003print \u201c};\u201d"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(10) ports_by_partition","This variable is an array that contains global port identifiers allowed for a corresponding partition. In the following example, a first partition has one port whose identifier is node1_partition_secret_outgoing. The number of partitions is three, and each of the partitions has one global port.",{"@attributes":{"id":"p-0157","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint8_t","\u2003node1_partition_secret_partport[1]","="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{node1_partition_secret_outgoing};"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint8_t","\u2002node1_partition_topsecret_partport[1]","="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{node1_partition_topsecret_outgoing};"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint8_t","node1_partition_unclassified_partport[1]","="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{node1_partition_unclassified_outgoing};"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint8_t ports_nb_ports_by_partition[CONFIG_NB_PARTITIONS] = {1,1,1};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint8_t*","ports_by_partition[CONFIG_NB_PARTITIONS]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"={node1_partition_secret_partport,node1_partition_topsecret_partport,node1_partition_unclassified_partport};"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201cuint8_t* ports_by_partition[CONFIG_NB_PARTITIONS] = {\u201d"]},{"entry":[{},"count = 0;"]},{"entry":[{},"for each p \u2208 <Partition> {"]},{"entry":[{},"count = count + 1"]},{"entry":[{},"print \u201cp\u201d, p.PartitionIdentifier, \u201c_partport\u201d"]},{"entry":[{},"\u2003if (|<Partition>| > count) {, print \u201c,\u201d}"]},{"entry":[{},"}"]},{"entry":[{},"print \u201c};\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"(11) shared_io","In order to define shared IO, the following header file sharedio.h should be first defined. This header file defines a structure in which set values will be stored.","(11-1) sharedio.h",{"@attributes":{"id":"p-0161","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003#define NAME_LENGTH 30"]},{"entry":[{},"\u2003\u2003typedef struct"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003SHARED_IO_ACCESS_TYPE"]},{"entry":[{},"\u2003shared_io_auth[CONFIG_NB_PARTITIONS]"]},{"entry":[{},"\u2003\u2003char\u2003\u2003\u2003\u2003name[NAME_LENGTH];"]},{"entry":[{},"\u2003\u2003void\u2003\u2003\u2003\u2003\u2003* addr;"]},{"entry":[{},"\u2003\u2003UINT32\u2003\u2003\u2003\u2003\u2003\u2003size;"]},{"entry":[{},"\u2003\u2003} shared_io_t;"]},{"entry":[{},"\u2003\u2003typedef enum {"]},{"entry":[{},"\u2003\u2003NONE,"]},{"entry":[{},"\u2003\u2003READ_ONLY,"]},{"entry":[{},"\u2003\u2003WRITE_ONLY,"]},{"entry":[{},"\u2003\u2003READ_WRITE"]},{"entry":[{},"\u2003\u2003} SHARED_IO_ACCESS_TYPE;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(11-2) Kernel-conf.c source code may be written as described below.","Furthermore, the Kernel-conf.c source code represents information about shared IO. Furthermore, a number of values of the shared_io_t type, that is, the access authorities of the partitions for each shared IO and shared IOs own attributes, equal to the number of shared IOs defined in the header file, are described in a single array.",{"@attributes":{"id":"p-0164","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003shared_io_t shared_io[CONFIG_NB_SHARED_IO] = {"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003sharedIO1_authorities,"},{"entry":"\u2003\u2003sharedIO1, 0x001c0030, 40},"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003sharedIO2_authorities,"},{"entry":"\u2003\u2003sharedIO2, 0x0ff00000, 100},"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003SHARED_IO_ACCESS_TYPE sharedIO1_authorities[3] ={"},{"entry":"\u2003\u2003NONE, READ_ONLY, WRITE_ONLY}"},{"entry":"\u2003\u2003SHARED_IO_ACCESS_TYPE sharedIO2_authorities[3] ={"},{"entry":"\u2003\u2003NONE, NONE, WRITE_ONLY}"},{"entry":"\u2003\u2003..."},{"entry":"\u2003\u2003[Conversion Rule]"},{"entry":"\u2003\u2003-- generate access authorities array for each shared IO"},{"entry":"\u2003\u2003for each sio \u2208 <SahredIO> {"},{"entry":"\u2003\u2003print\u2003\u201cSHARED_IO_ACCESS_TYPE\u2003\u201c,\u2003sio.Name,"},{"entry":"\u201c_Authorities[\u201d, CONFIG_NB_PARTITIONS, \u201c] = {\u201d"},{"entry":"\u2003\u2003count = 0"},{"entry":"\u2003\u2003\u2003for each p \u2208 <Partition> {"},{"entry":"\u2003\u2003\u2003\u2003flag = 0;"},{"entry":"\u2003\u2003\u2003\u2003for each a \u2208 sio.<Authorities> {"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (p.PartitionIdentifier == a.PartitionID) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003print a.Access"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003flag = 1"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003if (flag == 0) {print \u201cNONE\u201d }"},{"entry":"\u2003\u2003\u2003\u2003count = count + 1"},{"entry":"\u2003\u2003if (|<Partition>| > count) { print \u201c,\u201d}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003print \u201c};\u201d"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003-- generate the shared IO array"},{"entry":"\u2003\u2003count =0"},{"entry":"\u2003\u2003print \u201cshared_io_t shared_io[CONFIG_NB_SHARED_IO] = {\u201d"},{"entry":"\u2003\u2003for each sio \u2208 <SahredIO> {"},{"entry":"\u2003\u2003\u2003count = count + 1"},{"entry":"\u2003\u2003\u2003print \u201c{\u201c, sio.Name, \u201c_Authorities, \u201d, sio.PhysicalAddress, \u201c,\u201d,"},{"entry":"\u2003\u2003\u2003sio.Size"},{"entry":"\u2003\u2003if (|<SahredIO>| > count) {print \u201c}, \u201d} else { print \u201c}\u201d}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003print \u201c};\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(12) hm_table_init","In order to represent set values for a health monitor (HM), the following types should be defined in the header file \u2018erroth\u2019 in advance.","(12-1) Codes representing the states of the system and types representative of errors that may occur in the system",{"@attributes":{"id":"p-0168","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003#define NB_SYSTEM_STATE 5"]},{"entry":[{},"\u2003\u2003\u2003\u2003typedef enum"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003MODULE_INIT, PARTITION_SWITCHING, "]},{"entry":[{},"\u2003\u2003\u2003\u2003PARTITION_INIT, PROCESS_EXECUTION,"]},{"entry":[{},"\u2003\u2003\u2003\u2003OS_EXECUTION"]},{"entry":[{},"} system_state_t;"]},{"entry":[{},"\u2003\u2003\u2003\u2003#define NB_ERROR_ID 19"]},{"entry":[{},"\u2003\u2003\u2003\u2003typedef enum"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003DIVIDE_ERROR, DEBUG, NMI, BREAKPOINT,"]},{"entry":[{},"\u2003\u2003\u2003\u2003OVERFLOW,"]},{"entry":[{},"\u2003\u2003\u2003\u2003BOUND_RANGE,\u2003\u2003INVALID_OPCODE,"]},{"entry":[{},"\u2003\u2003\u2003\u2003NOMATH_COPROC,"]},{"entry":[{},"\u2003\u2003DOUBLE_FAULT,"]},{"entry":[{},"\u2003\u2003\u2003\u2003COPSEG_OVERRUN, INVALID_TSS,"]},{"entry":[{},"\u2003\u2003\u2003\u2003SEGMENT_NOT_PRESENT,"]},{"entry":[{},"\u2003\u2003\u2003\u2003STACK_SEG_FAULT,\u2003\u2003GENERAL_PROTECTION,"]},{"entry":[{},"\u2003\u2003\u2003\u2003PAGEFAULT,"]},{"entry":[{},"\u2003\u2003FPU_FAULT,"]},{"entry":[{},"\u2003\u2003\u2003\u2003ALIGNEMENT_CHECK, MACHINE_CHECK,"]},{"entry":[{},"\u2003\u2003\u2003\u2003SIMD_FAULT"]},{"entry":[{},"\u2003\u2003\u2003\u2003} error_id_t;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(12-2) Codes representing error levels to be used in a system HM table and error actions to be used in a module HM table and a partition HM table",{"@attributes":{"id":"p-0170","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003typedef enum"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003NONE, MODULE_LEVEL, PARTITION_LEVEL,"]},{"entry":[{},"\u2003\u2003DEADLINE_MISSED, APPLICATION_ERROR,"]},{"entry":[{},"\u2003\u2003NUMERIC_ERROR, ILLEGAL_REQUEST,"]},{"entry":[{},"\u2003\u2003POWER_FAIL,\u2003\u2003MEMORY_VIOLATION,"]},{"entry":[{},"\u2003\u2003HARDWARE_FAULT,"]},{"entry":[{},"STACK_OVERFLOW"]},{"entry":[{},"\u2003\u2003} error_level_t;"]},{"entry":[{},"\u2003\u2003typedef enum"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003M_NONE, M_RESET, M_SHUTDOWN, M_IGNORE"]},{"entry":[{},"\u2003\u2003} module_action_t;"]},{"entry":[{},"\u2003\u2003typedef enum"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003P_NONE, P_IDLE, P_WARM_START, P_COLD_START,"]},{"entry":[{},"\u2003\u2003P_IGNORE"]},{"entry":[{},"\u2003\u2003} partition_action_t;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(12-3) Codes defining the \u2018struct\u2019 type representing the structure of the HM table",{"@attributes":{"id":"p-0172","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct {"},{"entry":"union{"},{"entry":"error_level_t\u2003\u2003system[NB_ERROR_ID][NB_SYSTEM_STATE];"},{"entry":"module_action_t\u2002module[NB_ERROR_ID] [NB_SYSTEM_STATE];"},{"entry":"partition_action_t partition[NB_ERROR_ID][NB_SYSTEM_STATE];"},{"entry":"} table;"},{"entry":"void (*callback) (uint32_t);"},{"entry":"} table_t;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Furthermore, \u2018NB_ERROR_ID\u2019 and \u2018NB_SYSTEM_STATE\u2019 used in the codes represent the number of elements of the type \u2018system_state_t\u2019 and the number of elements of the type \u2018error_id_t\u2019. \u2018callback\u2019 represents a user-defined callback function. When the \u2018error.h\u2019 header file is declared as described above, the following partition table information is declared in the \u2018Kernel-conf.h\u2019 header file.","(12-4) Partition table information declaration",{"@attributes":{"id":"p-0175","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"table_t\u2003system_hm_table;"]},{"entry":[{},"table_t\u2003\u2003\u2003module_hm_table;"]},{"entry":[{},"table_t\u2003\u2003\u2003partition_hm_table[CONFIG_NB_PARTITIONS];"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Furthermore, in Kernel-conf.c, the following HM table initiation function is written. In the initiation function, all the values of the HM tables are initialized to NONE.","(12-5) HM table initiation function",{"@attributes":{"id":"p-0178","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void hm_table_init"]},{"entry":[{},"{"]},{"entry":[{},"\u2002int i, j, k;"]},{"entry":[{},"\u2002for (i = 0; i < CONFIG_NB_ERROR_ID; i++)"]},{"entry":[{},"\u2002{"]},{"entry":[{},"\u2003for (j = 0; j < CONFIG_NB_SYSTEM_STATE; j++)"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2002system_hm_table.table.system[i][j] = NONE;"]},{"entry":[{},"\u2003\u2002module_hm_table.table.module[i][j] = M_NONE;"]},{"entry":[{},"\u2003\u2002for (k = 0; k < CONFIG_NB_PARTITIONS; k++)"]},{"entry":[{},"\u2003\u2003partition_hm_table[k].table.partition [i][j] = P_NONE;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2002}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Finally, the following code is written in the Kernel-conf.c based on the values set in the MI table.","(12-6) Codes based on values set in HM table",{"@attributes":{"id":"p-0181","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"system_hm_table.table.system[OVERFLOW][MODULE_INIT]","="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"MODULE_LEVEL;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"module_hm_table.table.module[OVERFLOW][MODULE_INIT]","="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"M_RESET;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"system_hm_table.table.system[OVERFLOW][PARTITION_INIT]","="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"PARTITION_LEVEL;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"module_hm_table.table.module[OVERFLOW][PARTITION_INIT]","="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"P_COLD_START"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"print \u201cvoid hm_table_init {\u201d"]},{"entry":[{},"print \u201c int i, j, k;\u201d"]},{"entry":[{},"print \u201c for (i = 0; i < NB_ERROR_ID; i++) {\u201c"]},{"entry":[{},"print \u201c\u2003for (j = 0; j < NB_SYSTEM_STATE; j++) {\u201c"]},{"entry":[{},"print \u201c\u2003\u2003system_hm_table.table.system[i][j] = NONE;\u201d"]},{"entry":[{},"print \u201c\u2003\u2003module_hm_table.table.module[i][j] = M_NONE;\u201d"]},{"entry":[{},"print \u201c\u2003\u2003for k = 0; k < CONFIG_NB_PARTITIONS; k++ {\u201c"]},{"entry":[{},"print \u201c\u2003\u2003\u2003partition_hm_table[k].table.partition[i][j] = P_NONE;\u201d"]},{"entry":[{},"print \u201c\u2003\u2003}\u201d"]},{"entry":[{},"print \u201c\u2003}\u201d"]},{"entry":[{},"print \u201c }\u201d"]},{"entry":[{},"print \u201c}\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"(13) system_hm_table",{"@attributes":{"id":"p-0183","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"some s_hm \u2208 <System_HM_Table> {"]},{"entry":[{},"\u2003for each state \u2208 s_hm.<System_State_Enrty> {"]},{"entry":[{},"\u2003\u2003for each e \u2208 state.<Error_ID_Level> {"]},{"entry":[{},"print \u201csystem_hm_table.table.system[\u201d, e.ErrorIdentifier, \u201c][\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003state.SystemState, \u201c] = \u201d, e.ErrorLevel, \u201c;\u201d"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"(14) module_hm_table",{"@attributes":{"id":"p-0185","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Conversion Rule]"]},{"entry":[{},"some m_hm \u2208 <Module_HM_Table> {"]},{"entry":[{},"\u2003for each state \u2208 m_hm.<System_State_Enrty> {"]},{"entry":[{},"\u2003\u2003for each e \u2208 state.<Error_ID_Action> {"]},{"entry":[{},"print \u201cmodule_hm_table.table.module[\u201d, e.Error Identifier, \u201c][\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003state.SystemState, \u201c] = \u201d, e.Action, \u201c;\u201d"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Third, the configurations included in the PartN_Conf.c file will be described below.","(1) partition_hm_table","A number of partition HM tables equal to the number of partitions are created. Accordingly, a source file having the following assignment form should be created in each partition directory.","(1-1) Assignment statement",{"@attributes":{"id":"p-0190","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003partition_hm_table[0].table.partition[OVERFLOW]"]},{"entry":[{},"\u2003\u2003[MODULE_INIT] \u2003\u2003\u2003="]},{"entry":[{},"P_NONE;"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003[Conversion Rule]"]},{"entry":[{},"\u2003\u2003index = 0"]},{"entry":[{},"\u2003\u2003for each p_hm \u2208 <Partition_HM_Table> {"]},{"entry":[{},"\u2003\u2003\u2003for each s \u2208 p_hm.<System_State_Enrty> {"]},{"entry":[{},"\u2003\u2003\u2003\u2003for each e \u2208 state.<Error_ID_Action> {"]},{"entry":[{},"\u2003\u2003print \u201cmodule_hm_table[\u201d, index, \u201c].table. partition[\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2002e.ErrorIdentifier, \u201c][\u201d, s.SystemState, \u201c] = \u201d, e.Action, \u201c;\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003index = index + 1"]},{"entry":[{},"\u2003\u2003}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The method and apparatus for performing a configuration of an aeronautical system in compliance with the ARINC 653 standard according to the present invention have the advantage of improving the quality of software and the advantage of improving the efficiency of development by reducing the load of a mere navvy's work because the method and apparatus enable ARINC 653 configurations to be easily and rapidly made.","Although the preferred embodiments of the present invention have been disclosed for illustrative purposes, those skilled in the art will appreciate that various modifications, additions and substitutions are possible, without departing from the scope and spirit of the invention as disclosed in the accompanying claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and other objects, features and advantages of the present invention will be more clearly understood from the following detailed description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
