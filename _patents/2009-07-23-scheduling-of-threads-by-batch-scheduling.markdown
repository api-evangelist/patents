---
title: Scheduling of threads by batch scheduling
abstract: In accordance with the disclosed subject matter there is provided a method for segregating threads running in a computer system, and executing the threads according to this categorization.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08839255&OS=08839255&RS=08839255
owner: Empire Technology Development LLC
number: 08839255
owner_city: Wilmington
owner_country: US
publication_date: 20090723
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["REFERENCE TO RELATED APPLICATIONS","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application is related to the following co-pending applications, application Ser. No. 12\/507,686 entitled \u201cBatch Scheduling With Segregation\u201d filed Jul. 22, 2009 and application Ser. No. 12\/507,671 entitled \u201cApplication Selection of Memory Request Scheduling\u201d filed Jul. 22, 2009.","In a chip-multiprocessor (CMP) system, the DRAM system is shared among cores. In a shared DRAM system, requests from a thread can not only delay requests from other threads by causing bank conflicts, bus conflicts or row-buffer conflicts, but they can also destroy DRAM-bank-level parallelism of other threads. Requests with latencies that would otherwise have been overlapped could effectively become serialized. As a result, both fairness and system throughput may degrade, and some threads can starve for long time periods.","One approach to providing fair and high-performance memory scheduling is using a scheduling algorithm called parallelism-aware batch scheduling (PAR-BS), as shown in Onur Mutlu and Thomas Moscibroda, \u201cParallelism-Aware Batch Scheduling: Enhancing both Performance and Fairness of Shared DRAM Systems,\u201d , pp. 63-74, 2008 (2008 International Symposium on Computer Architecture), all of which is incorporated by reference herein, except where inconsistent with the present application. PAR-BS design is based on two ideas: (1) request batching; and (2) parallelism-aware memory scheduling. First, PAR-BS processes DRAM requests in batches to provide fairness and to avoid starvation of requests. Second, to optimize system throughput, PAR-BS employs a parallelism-aware DRAM scheduling policy that aims to process requests from a thread in parallel in the DRAM banks, thereby reducing the memory-related stall-time experienced by the thread. PAR-BS incorporates support for system-level thread priorities and can provide different service levels, including purely opportunistic service, to threads with different priorities.","The following description sets forth various examples along with specific details to provide a thorough understanding of claimed subject matter. It will be understood by those skilled in the art, however, that claimed subject matter may be practiced without some or more of the specific details disclosed herein. Further, in some circumstances, well-known methods, procedures, systems, components and\/or circuits have not been described in detail in order to avoid unnecessarily obscuring claimed subject matter. In the following detailed description, reference is made to the accompanying drawings, which form a part hereof. In the drawings, similar symbols typically identify similar components, unless context dictates otherwise. The illustrative embodiments described in the detailed description, drawings, and claims are not meant to be limiting. Other embodiments may be utilized, and other changes may be made, without departing from the spirit or scope of the subject matter presented here. It will be readily understood that the aspects of the present disclosure, as generally described herein, and illustrated in the Figures, can be arranged, substituted, combined, and designed in a wide variety of different configurations, all of which are explicitly contemplated and make part of this disclosure.","In the following description, algorithms and\/or symbolic representations of operations on data bits and\/or binary digital signals stored within a computing system, such as within a computer and\/or computing system memory may be presented. An algorithm is generally considered to be a self-consistent sequence of operations and\/or similar processing leading to a desired result where the operations may involve physical manipulations of physical quantities that may take the form of electrical, magnetic and\/or electromagnetic signals capable of being stored, transferred, combined, compared and\/or otherwise manipulated. In various contexts such signals may be referred to as bits, data, values, elements, symbols, characters, terms, numbers, numerals, etc. Those skilled in the art will recognize, however, that such terms may be used to connote physical quantities. Hence, when terms such as \u201cstoring\u201d, \u201cprocessing\u201d, \u201cretrieving\u201d, \u201ccalculating\u201d, \u201cdetermining\u201d etc. are used in this description they may refer to the actions of a computing platform, such as a computer or a similar electronic computing device such as a cellular telephone, that manipulates and\/or transforms data represented as physical quantities including electronic and\/or magnetic quantities within the computing platform's processors, memories, registers, etc.","This disclosure is drawn, inter alia, to methods, apparatus, systems and computer program products related to scheduling of threads by batch scheduling. The present disclosure makes use of the discovery of grouping threads into batches, based upon certain criteria. The threads may be grouped into batches in a variety of ways, such as: (1) good design threads and bad design threads, based on how well the threads are designed for use with parallel processors; (2) cooperative threads and non-cooperative threads, based on how efficiently the threads work with other threads; (3) first application, second application and third application threads, based on the application program from which the thread originated; (4) large request threads, optionally medium request threads and small request threads, based on the relative number of requests for data in memory the threads make, for example large request thread may make an average number of request or greater, and small request threads may make a number of requests less than an average number. Other criteria for grouping threads into batches may include assigning an importance to each thread, for example high importance or low importance, or assigning importance values and batching threads with similar or the same importance values, together. Still other criteria for grouping threads into batches may include grouping based on past compatibility data collect when previously executing the threads, with the data stored in a ghost page associated with each thread; or the data could be stored in a freeze dried ghost page provided as part of the application program from which the thread issued, the freeze dried ghost page containing compatibility data of the threads provided with the application program. Many other variations are possible.","In some examples, methods may be described for segregating threads running in a computer system. The computer system may include an operating system. Some described methods may include segregating the threads based on their efficiency into good threads and bad threads. In some examples, threads that can extract data in parallel from the memory banks may be considered good threads and threads that do not extract data in parallel from the memory banks may be considered bad threads. The methods may also include forming a first batch of threads comprising primarily good threads, and forming a second batch of threads comprising primarily bad threads.","In some additional examples, methods for segregating threads running in a computer system may be described. The computer system may include an operating system. Example methods may include determining which threads operate efficiently with each other and which threads do not operate efficiently with each other. Threads that operate efficiently with each other may extract data from different memory banks, and threads that do not operate efficiently with each other may extract data from the same memory banks. Example methods may also include forming a first batch of threads comprising primarily threads that operate efficiently with each other and forming a second batch of threads comprising primarily threads that do not operate efficiently with each other.","In yet other examples, methods may be described for segregating threads running in a computer system. The computer system may include an operating system. The example methods may include segregating the threads based on criteria into a first and second thread type. The example methods may also include forming a first batch comprising threads which are primarily of the first thread type and forming a second batch comprising threads which are primarily of the second thread type.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1","FIG. 4"],"b":["100","110","120","130","130","100","130","140","150","160","180","140","150","100","154","100","190"]},"These and other input devices may be coupled to processor  through a user input interface that may be coupled to a system bus or it may be connected by other interface or bus structures, such as a parallel port, game port or a universal serial bus (USB), or the like. Computer  may include peripheral output devices such as speakers, a printer, or a display , which may be connected through an output peripheral interface  or the like.","Computer  may be configured to operate in a networking environment using logical connections to one or more computers, such as a remote computer connected to network interface  The remote computer may be a personal computer (PC), a server, a router, a network PC, a peer device or other common network node, and may include many or all of the elements described above relative to computer .","Networking environments may include offices, enterprise-wide area networks (WAN), local area networks (LAN), intranets and the Internet. In an example, computer  may be the source machine from which data is being migrated and the remote computer may comprise the destination machine, or vice versa. Source and destination machines may not be connected by a network  or any other means, but instead, data may be migrated via any media capable of being written by the source platform and read by the destination platform or platforms. In a LAN or WLAN networking environment, computer  may be connected to the LAN or WAN through a network interface  or an adapter. In a WAN networking environment, computer  may include a modem or other means for establishing communications over the WAN, such as the Internet or network . Other means of establishing a communications link between the computers may be used.","A computer peripheral may include any device coupled to the processor  and the memory  of the computer  through the system bus. A computer peripheral may include any device connected with the output peripheral interface, including the display , the printer, or speakers, drives , user input devices  such as the keyboard, the mouse, and the microphone, and the network interface . Components of the computer peripheral may include any device within a computer peripherals which may use power and may be any device, such as speakers, lighting elements such as light emitting diodes, or backlights used to provide lighting for displays, display elements, such as LCD, LED, OLED, CRT, or Plasma displays, or semiconductor chips such as a central processing unit (CPU), a graphic processing unit (GPU), memory.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 2","FIG. 4"],"b":["140","150","130","140","150","100","150","140","111","150","230","120","230","120","210","150","220","230","122","120","226","220","150","150","220","150","150","150","220","220","220","111","111","220","226","230","120","226","210","226","111"]},"In some embodiments, as shown in , multiprocessor  may include processors that may simultaneously execute more than one thread . Multiprocessor  may include multiple processors known as cores  and , or a single processor (only one of  or ) which may run multiple threads  simultaneously, also known as a multithreaded processor.  illustrates an example multiprocessor  including two cores  and , but is not limited to any particular number of cores. The term \u201ccore\u201d may be used herein to refer to any device which may process a single thread and may refer to a processor or a portion within a processor that may process a single thread. A multithreaded processor may be referred to as a processor having multiple cores. A computer  having multiple processors may be referred to herein as a computer  having multiple cores.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 3","FIG. 3","FIG. 2"],"b":["150","220","220","220","150","111","220","220","150","220","220","226","226","230","120","220","226","1","226","220"],"sub":["a","n","a","n","a1","no "]},"Each thread  may issue requests  for data  stored in memory , and in an example, for data  stored in memory banks -within memory , where the index (a, b . . . m) may represent the number of memory banks . Memory  may include multiple memory banks to that may allow multiple outstanding memory requests  to proceed in parallel if they seek data  from different memory banks. As a result, first memory bank and second memory bank may be accessed concurrently by memory controller  upon receiving a request  for data .","Each memory bank  may be a two-dimensional array, including columns Cto C, where the index ( . . . i) may represent the number of columns, and rows Rto R, where the index ( . . . j) may represent the number of rows. Rows may store data in consecutive memory locations and may be, for example, approximately 1-2 kilobytes (KB) in size. The data  in a memory bank  may be accessed from a row-buffer R, which may contain at most one row. In an example, each memory bank  may contain one row-buffer R. The time it takes to service each request  for data  may depend on the status of each row-buffer Rand may fall into one of three categories. The first category may be row hit, where a request  may be to a row that may be currently open in each row-buffer R, allowing the memory controller  to issue only a read or write command to the respective memory bank , resulting in a bank access latency of t.","The second category may be row closed, where there may be no open row in a row-buffer R, so that the memory controller  may need to first issue an activate command to open a required row and then a read\/write command, resulting in a total latency of t+t, where tis the latency for the activate command and tis the latency for the read\/write command. The third category may be row conflict, where a request  may be to a row different from the one currently in a respective row-buffer R, so that the memory controller  needs to first issue a precharge command and open the required row (by activating it), and issue a read\/write command for data in the required row. These accesses may incur the highest total latency of t+t+t, where tis the latency for the row precharge (to close it), tis the latency for the activate command and tis the latency for the read\/write command.","Memory controller  may be arranged in communication with memory  and the multiprocessor and may be located anywhere along the system, including within the multiprocessor. Memory controller  may include a memory request buffer  that may be arranged to buffer the requests  and the data  while the requests  may be waiting to be serviced. Memory controller  may include a request scheduler  that may be arranged to select the next request  to be serviced. In some embodiments, request scheduler  may have two-levels. When selecting the next request  to be serviced, the request scheduler  may be configured to consider the state of the memory banks -and the state of memory buses -connecting the memory controller  to each memory bank , and the state of a request . A memory command for a request  may be scheduled by the request scheduler  if its scheduling does not cause any resource, such as memory banks -and address\/data\/system bus, conflicts and does not violate any memory timing constraints. A memory command which does not cause any conflicts may be considered to be ready.","The memory controller  includes a request scheduler , which includes a request scheduling algorithm having a request batch algorithm, and request within-batch scheduling algorithm or request parallelism-aware within-batch scheduling algorithm. Alternatively, both the request within-batch scheduling algorithm and the request parallelism-aware within-batch scheduling algorithm may be employed by the request scheduling algorithm.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3A","b":["140","300","302","350"]},"Referring again to , in order to improve the efficiency of scheduling requests -from threads -, memory controller , and specifically request scheduler , may use a request scheduling algorithm which may take into account intra-thread bank-parallelism, and may provide quality of service (QoS) to each thread -. Quality of service may be considered as the ability to provide different priority to different threads -, and\/or to provide a base level of performance when executing threads -. The request scheduling algorithm may be designed to provide a configurable substrate for fairness and QoS and high CMP system throughput. The request batching algorithm may be configured to group a number of outstanding memory requests -into batches. The request scheduling algorithm also may be configured to ensure that all requests -belonging to current batches are serviced before the next batches are formed. The request batching algorithm may be adapted to form multiple batches all at the same time, where each batch may be formed using certain criteria, described herein.","The request batching algorithm may be arranged to group outstanding requests in the memory request buffer into sets of requests, called request batches. The memory scheduler may avoid request re-ordering across request batches by prioritizing requests belonging to a current request batch over other requests. Once all requests of a request batch are serviced, for example when the request batch is finished, the next request batch, which may include outstanding requests in the memory request buffer that were not included in the last request batch, may then be serviced. The formation of multiple request batches at the same time, may allow for re-order requests within a request batch.","The request batching algorithm may work as follows below. Each request in the memory request buffer may have an associated bit indicating which request batch the request belongs to in the current request batches. If a request belongs to a first request batch, for example, the associated bit may be set to indicate that the request belongs to the first request batch, and the request may be considered marked. Multiple request batches may be formed, where each of the requests are marked to indicate which of the multiple request batches the requests are to be placed in or are a part of, based upon certain criteria, described herein. When there are no marked requests left in the memory request buffer, for example when all requests from previous request batches have been completely serviced, new request batches may be formed.","In some embodiments, when forming a request batch, the request batching algorithm may mark up to a set number, a marking-cap, of outstanding requests per memory bank for each thread; these requests may form the request batch. The marking-cap may be utilized as a system parameter that may limit how many requests issued by a thread for a certain bank can be part of a request batch. For instance, if the marking-cap is five and a thread has seven outstanding requests for a memory bank, the request batching algorithm may mark the five oldest requests (or fewer if less than five requests exist). Examples include 2, 3, 5, 7, 10, 20, 50, or even larger marking-caps. Furthermore, for different types of batches, as described herein, the marking-caps may be different. In some examples, when no marking-cap is set, all outstanding requests may be marked when one or more batches are formed.","The request batching algorithm may be arranged to prioritize marked requests (requests in batches) over non-marked requests in a given memory bank. If there are no marked requests to a given bank, outstanding non-marked requests may be scheduled to that bank. To select among two marked or two non-marked requests, any existing or new memory scheduling algorithm, such as FR-FCFS, may be employed.","A request scheduling method for forming one or more batches of thread requests, where each request batch includes one or more requests, may be initiated. After initiating the method, threads may then be segregated into (identified as) thread types, for example first thread type and second thread type, or first, second and third thread types. One or more request batches, where each request batch may contain requests issued from the thread or threads of similar or the same thread type or types, may be formed. After forming one or more request batches, with each request batch containing one or more requests, the one or more request batches may then be executed by the memory controller. The one or more request batch may be executed one at a time, or if the computer system is capable, they may be executed more than one at a time.","The segregation (identification) of threads, and therefore the batching of requests from the different thread types, may be based on any of a number of different criteria. For example, threads may be segregated into: (1) good design threads and bad design threads, based on how well the threads are designed for use with parallel memory; (2) cooperative threads and non-cooperative threads, based on how efficiently the threads work with other threads; (3) first application, second application and third application threads, based on the application program from which the thread originated; (4) large request threads, optionally medium request threads and small request threads, based on the relative number of requests the thread makes, for example large request thread may make an average number of request or greater, and small request threads may make a number of requests less than an average number. Many other variations are possible. Accordingly, depending on the criteria selected, there may be a first thread type, a second thread type, an optional third thread type, an optional fourth thread type, etc.","The following is an example using a criteria which may result in two thread types; as noted above, more than two thread types is also possible, depending on the criteria selected. The threads may be segregated into a first thread type and a second thread type. Requests issued by each thread type, for example a first requests issued from the first thread type, and a second requests issued from the second thread type, may then be formed into one or more batches of thread requests. Each request batch may include requests of one thread type, for example a first request batch may include only first requests, and a last request batch may include second requests. In another example, each request batch may contain primarily first requests from the first thread type, or primarily second requests from the second thread type. In this manner, the request batches formed may be homogeneous or primarily homogeneous for requests from each thread type. The one or more request batches may be executed one at a time, or if the computer system is capable, they may be executed more than one at a time. The term primarily, as used herein, may be more than approximately 50%, and more than approximately 80%, more than approximately 95%, or more than approximately 99%.","Once one or more request batches are formed, the request scheduling algorithm may be arranged to employ a request within-batch scheduling algorithm or a request parallelism-aware within-batch scheduling algorithm, to schedule service of requests within a request batch. Any request within-batch scheduling algorithm may be used, such as FR-FCFS.","Within a request batch, the request parallelism-aware within-batch scheduling algorithm may be arranged to first prioritize row-hit requests. Second, requests from threads with higher rank may be prioritized over those from threads with lower rank to increase bank-level parallelism, as explained in detail herein. Finally, all else being equal, an older request may be prioritized over a younger request.","The request parallelism-aware within-batch scheduling algorithm may use a rank-based thread prioritization scheme within a request batch. When a new request batch is formed, the memory scheduler may be arranged to compute a ranking among all threads that have requests in the new request batch. While the new request batch is processed, the computed ranking may remain the same and requests from higher-ranked threads maybe prioritized over those from lower-ranked threads. The effect of ranking-based scheduling is that different threads may be prioritized in the same order across all memory banks and thus, requests of each thread may be more likely to be serviced in parallel by all banks.","Although any ranking-based scheme may be used, the specific ranking procedure may have a significant impact on CMP throughput and fairness. A good ranking scheme may effectively differentiate between memory-intensive and non-intensive threads (and threads with high bank-parallelism). In some implementations, a ranking scheme may be employed conforming to the shortest job first principle: it may rank the non-intensive threads higher than the intensive threads.","Referring again to  and , in order to improve the efficiency of scheduling threads -from application program  or an operating system , the application program  or the operating system  may be arranged to group the threads into thread batches. The thread batching algorithm  may be arranged to group a number of outstanding threads -into thread batches. The thread scheduling algorithm  also may be arranged to ensure that threads -belonging to current thread batches may be serviced before the next thread batches are formed. The thread batching algorithm  may be arranged to form multiple thread batches at the same time, where each thread batch may be formed using certain criteria, described herein.","The thread batching algorithm may be arranged to group outstanding threads into sets of threads, called batches. The application program or an operating system may avoid thread re-ordering across thread batches by prioritizing threads belonging to a current thread batch over other threads. Once threads of a thread batch are serviced, for example when the thread batch is finished, the next thread batch, which may include outstanding threads that were not included in the last thread batch, may then be serviced. The formation of multiple thread batches at the same time, may allow for re-order threads within a thread batch.","An example thread batching algorithm may work as follows. Each thread may have an associated bit indicating which thread batch the thread belongs to in the current thread batches. If a thread belongs to a first thread batch, for example, the associated bit may be set to indicate that the thread belongs to the first thread batch, and the thread may be considered marked. Multiple thread batches may be formed, where each of the threads may be marked to indicate which of the multiple thread batches the threads are to be placed in or are a part of, based upon certain criteria, described herein. When there are no marked threads left, for example when all threads from previous thread batches have been completely serviced, new thread batches may be formed.","In some embodiments, when forming a thread batch, the thread batching algorithm may be arranged to mark up to a set number, a marking-cap, of outstanding threads per core for each application program; these threads may form the thread batch. The marking-cap may be utilized as a system parameter that may limit how many threads issued by an application program for a certain core can be part of a thread batch. For instance, if the marking-cap is five and an application program has seven outstanding threads, the thread batching algorithm may mark the five oldest threads (or fewer for examples with less than five threads). Examples include 2, 3, 5, 7, 10, 20, 50, or even larger marking-caps. Furthermore, for different types of thread batches, as described herein, the marking-caps may be different. If no marking-cap is set, outstanding threads may be marked when one or more thread batches are formed.","The thread batching algorithm may be arranged to prioritize marked threads (threads in batches) over non-marked threads. If there are no marked threads, outstanding non-marked threads may be scheduled. To select among two marked or two non-marked threads, any existing or new thread scheduling algorithm, may be employed.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 4","FIG. 4","FIG. 4"]},"Accordingly, blocks of the flowchart illustration in  support combinations of means for performing the specified functions, combinations of steps for performing the specified functions and program instruction means for performing the specified functions and\/or operations. It will also be understood that each block of the flowchart illustration in , and combinations of blocks in the flowchart illustration in  may be implemented by special purpose hardware-based computer systems which perform the specified functions\/operations\/actions or steps, or combinations of special purpose hardware and computer instructions.","Such computer instructions may be fixed either on a tangible medium, such as a computer readable medium (e.g., a diskette, CD-ROM, ROM, or fixed disk) or transmittable to a computer system, via a modem or other interface device, such as a communications adapter connected to a network over a medium. The medium may be either a tangible medium (e.g., optical or analog communications lines) or a medium implemented with wireless techniques (e.g., microwave, infrared or other transmission techniques). The series of computer instructions embodies all or part of the functionality previously described herein with respect to the system.","Those skilled in the art should appreciate that such computer instructions may be written in a number of programming languages for use with many computer architectures or operating systems. Furthermore, such instructions may be stored in any memory device, such as semiconductor, magnetic, optical or other memory devices, and may be transmitted using any communications technology, such as optical, infrared, microwave, or other transmission technologies. It is expected that such a computer program product may be distributed as a removable medium with accompanying printed or electronic documentation (for example, shrink wrapped software), preloaded with a computer system (for example, on system ROM or fixed disk), or distributed from a server or electronic bulletin board over the network (for example, the Internet or World Wide Web).","As shown in , a method  for forming one or more batches of threads, where each thread batch includes one or more threads, may be initiated at block . After initiating the method , threads may then be segregated into (identified as) thread types, for example first thread type and second thread type, or first, second and third thread types, at block . One or more thread batches, where each thread batch may contain threads issued from an application program or an operating system, with threads of similar or the same thread type or types, may be formed at block . After forming one or more thread batches, with each thread batch containing one or more threads, the one or more thread batches may then be executed by the cores at block . The one or more thread batch may be executed one at a time, or if the computer system is capable, they may be executed more than one at a time.","The segregation (identification) of threads, and therefore the batching of threads of the different thread types, may be based on any of a number of different criteria. For example, threads may be segregated into: (1) good design threads and bad design threads, based on how well the threads are designed for use with parallel memory; (2) cooperative threads and non-cooperative threads, based on how efficiently the threads work with other threads; (3) first application, second application and third application threads, based on the application program from which the thread originated; (4) large request threads, optionally medium request threads and small request threads, based on the relative number of requests the threads make, for example large request thread may make an average number of request or greater, and small request threads may make a number of requests less than an average number. Other criteria for grouping threads into batches may include assigning an importance to each thread, for example high importance or low importance, or assigning an importance values and batching threads with similar or the same importance values, together. Still other criteria for grouping threads into thread batches may include grouping based on past compatibility data collected when previously executing the threads, with the data stored in a ghost page associated with each thread; or the data may be stored in a freeze dried ghost page provided as part of the application program from which the thread issued, the freeze dried ghost page containing compatibility data of the threads provided with the application program. Many other variations are possible. Accordingly, depending on the criteria selected, there may be a first thread type, a second thread type, an optional third thread type, an optional fourth thread type, etc.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5","b":["220","220","250","251","250","251","332","332","332","250","332","251","332","332","250","251","332","332"],"sub":["a","n ","a","x ","a ","x ","a","x ","a","x "]},"Once one or more thread batches are formed, the thread scheduling algorithm may employ a thread within-batch scheduling algorithm or a thread parallelism-aware within-batch scheduling algorithm, to schedule service of threads within a thread batch.","The thread parallelism-aware within-batch scheduling algorithm may use a rank-based thread prioritization scheme within a thread batch. When a new thread batch is formed, the memory scheduler may be arranged to compute a ranking among all threads in the new batch. While the new batch is processed, the computed ranking may remain the same and higher-ranked threads may be prioritized over lower-ranked threads.","Although any ranking-based scheme may be used, the specific ranking procedure may have a significant impact. A good ranking scheme may effectively differentiate between computationally-intensive and non-intensive threads (and threads with high bank-parallelism). In some implementations, a ranking scheme may be employed conforming to the shortest job first principle: it may rank the quickly executing threads higher than the slowly executing threads.","Claimed subject matter is not limited in scope to the particular implementations described herein. For example, some implementations may be in hardware, such as employed to operate on a device or combination of devices, for example, whereas other implementations may be in software and\/or firmware. Likewise, although claimed subject matter is not limited in scope in this respect, some implementations may include one or more articles, such as a storage medium or storage media. This storage media, such as CD-ROMs, computer disks, flash memory, or the like, for example, may have instructions stored thereon, that, when executed by a system, such as a computer system, computing platform, or other system, for example, may result in execution of a processor in accordance with claimed subject matter, such as one of the implementations previously described, for example. As one possibility, a computing platform may include one or more processing units or processors, one or more input\/output devices, such as a display, a keyboard and\/or a mouse, and one or more memories, such as static random access memory, dynamic random access memory, flash memory, and\/or a hard drive.","Reference in the specification to \u201can implementation,\u201d \u201cone implementation,\u201d \u201csome implementations,\u201d or \u201cother implementations\u201d may mean that a particular feature, structure, or characteristic described in connection with one or more implementations may be included in at least some implementations, but not necessarily in all implementations. The various appearances of \u201can implementation,\u201d \u201cone implementation,\u201d or \u201csome implementations\u201d in the preceding description are not necessarily all referring to the same implementations. Moreover, when terms or phrases such as \u201ccoupled\u201d or \u201cresponsive\u201d or \u201cin response to\u201d or \u201cin communication with\u201d, etc. are used herein or in the claims that follow, these terms should be interpreted broadly. For example, the phrase \u201ccoupled to\u201d may refer to being communicatively, electrically and\/or operatively coupled as appropriate for the context in which the phrase is used.","In the preceding description, various aspects of claimed subject matter have been described. For purposes of explanation, specific numbers, systems and\/or configurations were set forth to provide a thorough understanding of claimed subject matter. However, it should be apparent to one skilled in the art and having the benefit of this disclosure that claimed subject matter may be practiced without the specific details. In other instances, well-known features were omitted and\/or simplified so as not to obscure claimed subject matter. While certain features have been illustrated and\/or described herein, many modifications, substitutions, changes and\/or equivalents will now, or in the future, occur to those skilled in the art. It is, therefore, to be understood that the appended claims are intended to cover all such modifications and\/or changes as fall within the true spirit of claimed subject matter.","There is little distinction left between hardware and software implementations of aspects of systems; the use of hardware or software is generally (but not always, in that in certain contexts the choice between hardware and software can become significant) a design choice representing cost vs. efficiency tradeoffs. There are various vehicles by which processes and\/or systems and\/or other technologies described herein can be effected (e.g., hardware, software, and\/or firmware), and that the preferred vehicle will vary with the context in which the processes and\/or systems and\/or other technologies are deployed. For example, if an implementer determines that speed and accuracy are paramount, the implementer may opt for a mainly hardware and\/or firmware vehicle; if flexibility is paramount, the implementer may opt for a mainly software implementation; or, yet again alternatively, the implementer may opt for some combination of hardware, software, and\/or firmware.","The foregoing detailed description has set forth various embodiments of the devices and\/or processes via the use of block diagrams, flowcharts, and\/or examples. Insofar as such block diagrams, flowcharts, and\/or examples contain one or more functions and\/or operations, it will be understood by those within the art that each function and\/or operation within such block diagrams, flowcharts, or examples can be implemented, individually and\/or collectively, by a wide range of hardware, software, firmware, or virtually any combination thereof. In one embodiment, several portions of the subject matter described herein may be implemented via Application Specific Integrated Circuits (ASICs), Field Programmable Gate Arrays (FPGAs), digital signal processors (DSPs), or other integrated formats. However, those skilled in the art will recognize that some aspects of the embodiments disclosed herein, in whole or in part, can be equivalently implemented in integrated circuits, as one or more computer programs running on one or more computers (e.g., as one or more programs running on one or more computer systems), as one or more programs running on one or more processors (e.g., as one or more programs running on one or more microprocessors), as firmware, or as virtually any combination thereof, and that designing the circuitry and\/or writing the code for the software and or firmware would be well within the skill of one of skill in the art in light of this disclosure. In addition, those skilled in the art will appreciate that the mechanisms of the subject matter described herein are capable of being distributed as a program product in a variety of forms, and that an illustrative embodiment of the subject matter described herein applies regardless of the particular type of signal bearing medium used to actually carry out the distribution. Examples of a signal bearing medium include, but are not limited to, the following: a recordable type medium such as a floppy disk, a hard disk drive, a Compact Disc (CD), a Digital Video Disk (DVD), a digital tape, a computer memory, etc.; and a transmission type medium such as a digital and\/or an analog communication medium (e.g., a fiber optic cable, a waveguide, a wired communications link, a wireless communication link, etc.).","Those skilled in the art will recognize that it is common within the art to describe devices and\/or processes in the fashion set forth herein, and thereafter use engineering practices to integrate such described devices and\/or processes into data processing systems. That is, at least a portion of the devices and\/or processes described herein can be integrated into a data processing system via a reasonable amount of experimentation. Those having skill in the art will recognize that a typical data processing system generally includes one or more of a system unit housing, a video display device, a memory such as volatile and non-volatile memory, processors such as microprocessors and digital signal processors, computational entities such as operating systems, drivers, graphical user interfaces, and applications programs, one or more interaction devices, such as a touch pad or screen, and\/or control systems including feedback loops and control motors (e.g., feedback for sensing position and\/or velocity; control motors for moving and\/or adjusting components and\/or quantities). A typical data processing system may be implemented utilizing any suitable commercially available components, such as those typically found in data computing\/communication and\/or network computing\/communication systems.","The herein described subject matter sometimes illustrates different components contained within, or connected with, different other components. It is to be understood that such depicted architectures are merely exemplary, and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense, any arrangement of components to achieve the same functionality is effectively \u201cassociated\u201d such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as \u201cassociated with\u201d each other such that the desired functionality is achieved, irrespective of architectures or intermedial components. Likewise, any two components so associated can also be viewed as being \u201coperably connected\u201d, or \u201coperably coupled\u201d, to each other to achieve the desired functionality, and any two components capable of being so associated can also be viewed as being \u201coperably couplable\u201d, to each other to achieve the desired functionality. Specific examples of operably couplable include but are not limited to physically mateable and\/or physically interacting components and\/or wirelessly interactable and\/or wirelessly interacting components and\/or logically interacting and\/or logically interactable components.","With respect to the use of substantially any plural and\/or singular terms herein, those having skill in the art can translate from the plural to the singular and\/or from the singular to the plural as is appropriate to the context and\/or application. The various singular\/plural permutations may be expressly set forth herein for sake of clarity.","It will be understood by those within the art that, in general, terms used herein, and especially in the appended claims (e.g., bodies of the appended claims) are generally intended as \u201copen\u201d terms (e.g., the term \u201cincluding\u201d should be interpreted as \u201cincluding but not limited to,\u201d the term \u201chaving\u201d should be interpreted as \u201chaving at least,\u201d the term \u201cincludes\u201d should be interpreted as \u201cincludes but is not limited to,\u201d etc.). It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended, such an intent will be explicitly recited in the claim, and in the absence of such recitation no such intent is present. For example, as an aid to understanding, the following appended claims may contain usage of the introductory phrases \u201cat least one\u201d and \u201cone or more\u201d to introduce claim recitations. However, the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles \u201ca\u201d or \u201can\u201d limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation, even when the same claim includes the introductory phrases \u201cone or more\u201d or \u201cat least one\u201d and indefinite articles such as \u201ca\u201d or \u201can\u201d (e.g., \u201ca\u201d and\/or \u201can\u201d should typically be interpreted to mean \u201cat least one\u201d or \u201cone or more\u201d); the same holds true for the use of definite articles used to introduce claim recitations. In addition, even if a specific number of an introduced claim recitation is explicitly recited, those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number (e.g., the bare recitation of \u201ctwo recitations,\u201d without other modifiers, typically means at least two recitations, or two or more recitations).","Furthermore, in those instances where a convention analogous to \u201cat least one of A, B, and C, etc.\u201d is used, in general such a construction is intended in the sense one having skill in the art would understand the convention (e.g., \u201ca system having at least one of A, B, and C\u201d would include but not be limited to systems that have A alone, B alone, C alone, A and B together, A and C together, B and C together, and\/or A, B, and C together, etc.). In those instances where a convention analogous to \u201cat least one of A, B, or C, etc.\u201d is used, in general such a construction is intended in the sense one having skill in the art would understand the convention (e.g., \u201ca system having at least one of A, B, or C\u201d would include but not be limited to systems that have A alone, B alone, C alone, A and B together, A and C together, B and C together, and\/or A, B, and C together, etc.). It will be further understood by those within the art that virtually any disjunctive word and\/or phrase presenting two or more alternative terms, whether in the description, claims, or drawings, should be understood to contemplate the possibilities of including one of the terms, either of the terms, or both terms. For example, the phrase \u201cA or B\u201d will be understood to include the possibilities of \u201cA\u201d or \u201cB\u201d or \u201cA and B.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Subject matter is particularly pointed out and distinctly claimed in the concluding portion of the specification. The foregoing and other features of the present disclosure will become more fully apparent from the following description and appended claims, taken in conjunction with the accompanying drawings. Understanding that these drawings depict only several embodiments in accordance with the disclosure and are, therefore, not to be considered limiting of its scope, the disclosure will be described with additional specificity and detail through use of the accompanying drawings:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 3","FIG. 3A"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
