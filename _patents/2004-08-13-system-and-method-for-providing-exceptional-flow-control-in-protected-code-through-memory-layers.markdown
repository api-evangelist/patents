---
title: System and method for providing exceptional flow control in protected code through memory layers
abstract: A system and method for providing exceptional flow control in protected code through memory layers. Code is generated. The generated code includes a sequence of normal operations and is subject to protection against copying during execution of the generated code. The generated code is instantiated as a master process into a master layer in a memory space. The master process is cloned by instantiating a copy of the master process as a child layer in the memory space. Execution points within the generated code are identified. A copy of at least a portion of the generated code containing each execution point as an exception layer is instantiated in the memory space. The generated code in the exception layer is patched at each identified execution point with operations exceptional to the normal operations sequence and which are performed upon a triggering of each execution point during execution of the generated code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07472383&OS=07472383&RS=07472383
owner: Sun Microsystems, Inc.
number: 07472383
owner_city: Santa Clara
owner_country: US
publication_date: 20040813
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The invention relates in general to exceptional flow control and, in particular, to a system and method for providing exceptional flow control in protected code through memory layers.","Fundamentally, a computer program is a sequence of instructions expressed according to the rules and syntax of a high level programming or assembly language, such as C++ or Java. The program specifies the control flow and logic to be performed at runtime. Prior to execution, the instructions are translated into machine operations by an interpreter or compiler. An interpreter performs a runtime translation of the instructions, which sacrifices speed for convenience and is generally inefficient. However, interpreted code is acceptable for non-critical applications and can be modified on-the-fly without having an appreciable effect on execution speed.","Conversely, compilers generate executable code embodied as an executable module. Compiled or generated code typically executes efficiently, but, once compiled, cannot be changed except through patching, which statically modifies or replaces the generated code. Patching is often performed for code updates to fix program bugs or to provide improve functionality. Patching can also be performed as temporary memory writes to facilitate secondary system activities, such as exceptional flow control, which uses short-lived modifications to the generated code that are removed upon completion of the system activity. Temporary memory writes include setting breakpoints, setting safepoints for rendezvous of threads, selective instrumentation or profiling, and performing garbage collection activities, such as object header marking for liveness checking. Rendezvous points or safe points are set to enable a task that requires all threads to be in a known state to safely execute.","For example, patching generated code is particularly effective at improving the efficiency of garbage collection in memory-constrained embedded systems, where memory fragmentation can be damaging to performance. In garbage collection, precise pointer scanning can be used to allow a virtual machine environment to fully compact a memory heap by tracking memory pointers assigned to dynamically allocated objects. For efficiency, the generated code is kept garbage collection unsafe at runtime. Garbage collection safepoints are defined at particular execution points within the code and memory pointer manipulation is allowed to proceed at runtime without fear of interacting with garbage collection operations. Safepoints avoid the overhead incurred by having to track memory pointers by stopping all execution threads during a rendezvous to allow garbage collection to proceed. Typically, safepoints are defined at method invocations, object allocations, thread synchronization calls, loop iterations, and similar execution points to ensure that all threads can be reached and stopped.","Safepoints are triggered in response to a garbage collection request, which can be detected through polling. However, polling is computationally expensive. For instance, on RISC architectures, polling often requires up to five processor cycles per poll, which creates unacceptably high overhead, particularly where safepoints are set at each loop iteration. Alternatively, code patching allows garbage collection request monitoring to proceed with no overhead cost. In the absence of a garbage collection request, a table of the locations of the safepoints is maintained for use by a dynamic complier, which patches the generated code at each safepoint at runtime upon receiving a garbage collection request. The patches invoke exception flow control that stops thread execution through, for instance, a function call, code branch, software trap, or instruction that causes a memory fault trap. Generally, a patch causing exceptional flow control modifies only a small section of code to cause execution to be redirected to an exception handler. The exception handler then performs extra operations and removes the patch to enable regular execution to resume once control is returned back from the exception handler.","Patching code, such as used for garbage collection safepoints, can be incompatible with generated non-modifiable code, such as read only code or code embodied in read only memory. Patching code can also be ill-suited to code maintained in a copy protected form that does not readily accommodate patching, such as code found in precompiled and linked methods or speculatively initialized application models. Similarly, process cloning as provided through copy-on-write or deferred copying allows a child process to implicitly share the process memory space, including generated code, of a master parent process, provided that the shared memory space of the child process remains unmodified. Code patching destroys the implicit sharing relationship and can negate memory advantages gained through process cloning.","Therefore, there is a need for an approach to providing temporary writes to generated code without destroying copy protection to enable exceptional flow control. Preferably, such an approach would be performed in separately defined memory layers that non-destructively overlay the original generated code.","One embodiment provides a system and method for providing exceptional flow control in protected code through memory layers. Code is generated. The generated code includes a sequence of normal operations and is subject to protection against copying during execution of the generated code. The generated code is instantiated as a master process into a master layer in a memory space. The master process is cloned by instantiating a copy of the master process as a child layer in the memory space. Execution points within the generated code are identified. A copy of at least a portion of the generated code containing each execution point is instantiated as an exception layer in the memory space. The generated code in the exception layer is patched at each identified execution point with operations exceptional to the normal operations sequence and which are performed upon a triggering of each execution point during execution of the generated code.","A further embodiment provides a system and method for providing exceptional flow control in protected code through breakpoints with a private memory layer. Code is generated. The generated code includes a sequence of normal operations and is subject to protection against copying during execution of the generated code. Execution points within the generated code are identified. A copy of at least a portion of the generated code containing each execution point is instantiated into a private memory layer. A breakpoint corresponding to each of the execution points is set by modifying the private memory layer by writing a breakpoint patch at the corresponding execution point. A trap handler associated with each breakpoint is defined and includes operations exceptional to the normal operations sequence that are performed upon a triggering of each breakpoint during execution of the generated code.","Still other embodiments of the invention will become readily apparent to those skilled in the art from the following detailed description, wherein are described embodiments of the invention by way of illustrating the best mode contemplated for carrying out the invention. As will be realized, the invention is capable of other and different embodiments and its several details are capable of modifications in various obvious respects, all without departing from the spirit and the scope of the invention. Accordingly, the drawings and detailed description are to be regarded as illustrative in nature and not as restrictive.","System Overview",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 2","FIG. 3"],"b":["10","15","15","17","19","11","12","14","16","18","20"]},"In a further embodiment, each operating system supports a process cloning mechanism that spawns multiple and independent isolated user applications by cloning the memory space of specifiable processes, as further described below with reference to . An example of a process cloning mechanism suitable for use in the present invention is the fork( ) system call provided by the Unix or Linux operating systems, such as described in M. J. Bach, \u201cThe Design Of The Unix Operating System,\u201d Ch. 7, Bell Tele. Labs., Inc. (1986), the disclosure of which is incorporated by reference. The process invoking the fork( ) system call is known as the \u201cparent\u201d or master process and the newly created process is called the \u201cchild\u201d process. The operating system assigns a new process identifier to the child process, which executes as a separate process. The operating system also creates a logical copy of the context of the parent process by copying the memory space of the parent process into the memory space of the child process. In a copy-on-write variant of the fork( ) system call, the operating system only copies references to the memory space and defers actually copying individual memory space segments until, and if, the child process attempts to modify the referenced data of the parent process context. The copy-on-write fork( ) system call is faster than the non-copy-on-write fork( ) system call and implicitly shares any data not written into between the parent and child processes.","Executable Process Address Space",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["30","66","66","31","32","33","33","31","11","31","32","33","32","33"]},"As shown, the code segment , data segment  and heap segment  are loaded as generated code into a memory in a single linear address space beginning with the code segment  at the lowest memory address. However, in a machine architecture supporting virtual memory paging, the entire address space of the executable process  could be paged to memory, thereby resulting in non-contiguous placement of the segments or, where a segment spans multiple pages, parts of segments. Moreover, in memory-constrained programmable devices, the code segment  and data segment  can be designated as read only or be embodied on a ROM device to avoid having to be read from non-volatile storage into memory prior to execution. Consequently, only objects defined within the heap segment  are actively allocated and deallocated at runtime.","Portions of the generated code in the executable process , including individual segments, parts of segments, or the entire process, can be subject to protection against copying during execution. Copy protection includes designation as read only or embodiment on a ROM device. Copy protection also includes precompiled and linked methods or speculatively initialized application models, such as respectively described in commonly-assigned U.S. patent application, entitled \u201cSystem and Method for Providing Precompiled Code through Memory Space Cloning of a Master Runtime System Process,\u201d Ser. No. 10\/745,020, filed Dec. 22, 2003, pending, and U.S. patent application, entitled \u201cSystem and Method for Performing Speculative Initialization of Application Models for a Cloned Runtime System Process,\u201d Ser. No. 10\/745,022, filed Dec. 22, 2003, pending, the disclosures of which are incorporated by reference, or process cloning as provided through copy-on-write or deferred copying, such as described in commonly-assigned U.S. patent application, entitled \u201cSystem and Method for Dynamic Preloading of Classes through Memory Space Cloning of a Master Runtime System Process,\u201d Ser. No. 10\/745,023, filed Dec. 22, 2003, pending; U.S. patent application, entitled \u201cSystem and Method for Performing Incremental Initialization of a Master Runtime System Process,\u201d Ser. No. 10\/745,164, filed Dec. 22, 2003, pending; and U.S. patent application, entitled \u201cSystem and Method for Eliminating Static Initialization Overhead by Memory Space Cloning of a Master Runtime System Process,\u201d Ser. No. 10\/745,021, filed Dec. 22, 2003, pending; the disclosures of which are incorporated by reference. Other types of copy protection over generated code are possible.","Prior Art System for Providing Exceptional Flow Control",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":"40"},"The system  defines an exemplary runtime environment  provided through an operating system and includes a virtual machine (VM) process  that executes generated code  maintained in non-volatile storage . Typically, the generated code  remains unchanged in memory and, at runtime, portions of the generated code  are progressively staged from memory into a code cache  as execution proceeds. However to accommodate requests for exceptional flow control , the generated code  can be patched by a dynamic compiler  to temporarily write modifications or changes, as specified through patch code , into the generated code  in memory. The patch code  is typically a set of function calls to runtime system rendezvous code that stop thread execution by suspending execution or causing the thread to sleep or wait. Exceptional flow control requests  include setting breakpoints, setting safepoints for rendezvous of threads, selective instrumentation or profiling, and performing garbage collection activities, such as object header marking for liveness checking. Other types of exceptional flow control requests  are possible.","At runtime, the dynamic compiler  maintains a table of execution points  within the generated code  that includes the locations in memory of method invocations, object allocations, thread synchronization calls, loop iterations, and similar execution points to ensure that all threads can be reached and stopped. Other execution points are possible. Upon receiving an exceptional flow control request , the dynamic compiler  consults the execution points table  and patches the generated code  in memory with the patch code , which provides instructions that stop the corresponding execution thread at a rendezvous point. The thread that requested exceptional flow control waits for the watched execution threads to stop during a rendezvous. Upon completion of the rendezvous, including any secondary work that needs to be done, such as performing a garbage collection, the patch code  is removed from the generated code  and normal execution by the watched execution threads resumes.","While effective at accommodating exceptional flow control requests , the patching of the generated code  in memory is either inconsistent or incompatible with copy protected code. Generated code maintained as read only or embodied on a ROM device cannot be patched. And patching generated code for recompiled and linked methods, speculatively initialized application models, or cloned processes, as provided through copy-on-write or deferred copying, can negate significant memory advantages as provided through pre-compilation, initialization and implicit sharing.","Memory Mapping for a Parent Process","In a further embodiment, the runtime environment  executes an application framework that spawns multiple independent and isolated user application process instances by preferably cloning the memory space of the virtual machine process  as a \u201cparent\u201d or master process to create one or more \u201cchild\u201d processes. The example of an application framework suitable for use in the present invention is the Unix operating system, such as described generally in M. J. Bach, supra at Ch. 2, the disclosure of which is incorporated by reference.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4","b":["60","65","62","62","65","62","64","63","61","65"],"i":["a","d"]},"Memory Mapping for a Child Process",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5","b":["70","65","66","62","64","62","65","66","62","72","71","67","66","66","65","66","41","41","43","65","31"],"i":["a","c ","a","d"]},"Memory Mapping for a Child Process with Copy-On-Write",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIGS. 6A-B","FIG. 6A"],"b":["80","90","65","66","62","63","65","81","66","66","64","66","66","62","66"],"i":["a","d "]},"Referring next to , the child process  has attempted to modify one of the pages in the memory space of the parent process context, such as through code patching. In response, the operating system creates a physical copy of the to-be-modified memory space page as a new page  and updates the allocation in the page table entries  for the child process . Through copy-on-write semantics, the overall footprint of the runtime environment  is maintained as small as possible and only grows until, and if, each child process  actually requires additional memory space for application-specific context. Nevertheless, the new page  is needlessly created, as code patching for exceptional flow control introduces only temporary modifications or changes to the child process , which are removed upon completion of the exceptional flow control.","System for Providing Exceptional Flow Control Through Memory Layers",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 7","b":"100"},"The system  also defines an exemplary runtime environment  provided through an operating system and includes an application manager , parent virtual machine process  and zero or more cloned child virtual machine processes . The parent virtual machine process  interprets machine-portable code defining compatible applications. The runtime environment  need not execute child virtual machine processes , which are only invoked upon request by the application manager .","The runtime environment  executes an application framework that spawns multiple independent and isolated user application process instances by preferably cloning the memory space of a parent virtual machine process. An example of an application framework suitable for use in the present invention is the Unix operating system, such as described generally in M. J. Bach, supra at Ch. 2, the disclosure of which is incorporated by reference.","The application manager  presents a user interface through which individual applications can be selected and executed. The application manager  and parent virtual machine process  preferably communicate via an inter-process communication (IPC) mechanism, such as a pipe or a socket. The parent virtual machine  creates a cloned child virtual machine process  as a new cloned process instance of the parent virtual machine process  using the process cloning mechanism of the underlying operating system. When implemented with copy-on-write semantics, the process cloning creates a logical copy of only the references to the parent virtual machine process context, as further described above with reference to . Segments of the referenced parent virtual machine process context are lazily copied only upon an attempt by the child virtual machine process to modify the referenced context. Therefore, as long as the child virtual machine process does not write into a memory segment, the segment remains shared between parent and child virtual machine processes.","As before, portions of the generated code  are progressively staged from memory into a code cache  of the parent virtual machine  at runtime as execution proceeds. The code cache  is copied as the code cache  of the child virtual machine  as part of the context of the parent virtual machine  at process cloning. At runtime, an exception monitor  detects an exceptional control flow request  and creates a writeable copy of the code cache  of the child virtual machine , as further described below with reference to . In a manner analogous to a stack, the code cache copy logically forms a separate layer that is \u201cpushed\u201d on top of the previous view of memory and which is removed by \u201cpopping\u201d or dereferencing the separate layer from the page table.","The request to copy the pages containing the code cache  is made through a mapping application programming interface (API)  exported by the operating system in the runtime environment , which coordinates the page copy request through a page manager . In a further embodiment, the mapping API  is provided by a library. The exception monitor  then patches the execution points identified in the execution point table. Each page that is modified by these patches will exist only in the new memory layer. Due to copy-on-write semantics, the original contents of the page remain unchanged in the original, underlying memory layer. Thus, upon receiving an exceptional flow control request , the exception monitor  writes patch instructions  into the code cache, effectively creating a breakpoint. When an executing thread executes the breakpoint code, an exception handler is called. The state of the executing thread is preserved, such that normal execution of the thread can resume later, as if the breakpoint never happened. The exception handler will cause the executing thread to rendezvous with the thread that issued the exceptional flow control request and the executing thread will then wait until asked to resume normal execution. The thread that requested exceptional flow control waits for the watched execution threads to stop at the rendezvous point. Upon completion of the rendezvous, the page containing the generated code copy is removed or \u201cpopped\u201d to reveal the original code cache memory and normal execution by the watched execution threads resumes. In the described embodiment, the API  implements a code cache copying interface:\n\n",{"@attributes":{"id":"p-0044","num":"0045"},"figref":["FIGS. 8A-B","FIG. 8A","FIG. 8B"],"b":["110","120","49","146","111","62","107","104","122","48","122","121","122","62","122","121","67"]},"Method for Providing Exceptional Flow Control Through Memory Layers",{"@attributes":{"id":"p-0045","num":"0046"},"figref":["FIG. 9","FIG. 7"],"b":["130","130","101"]},"Initially, the generated code  executes (block ). In response to an exceptional flow control request , the code cache  of the child virtual machine  is copied. For each page of the code cache  (blocks -), the page  is copied into a separate layer in the memory  (block ) and patched with patch code  (block ). Upon triggering of a trap corresponding to the patch code  (block ), a trap is vectored (block ) to trigger the execution of the patch code  (block ), after which the cache code copy is dereferenced and execution of the generated code  resumes (block ). The method terminates upon completion of the generated code . In a further embodiment, the program counter of the child virtual machine  is adjusted to cause execution to begin in the new address range upon trapping in response to an exceptional flow control request  (block ).","System for Providing Exceptional Flow Control Through Breakpoints",{"@attributes":{"id":"p-0047","num":"0048"},"figref":"FIG. 10","b":"140"},"The system  also defines an exemplary runtime environment  provided through an operating system and includes the virtual machine (VM) process  that executes the generated code  maintained in the non-volatile storage . Unlike code patching, which is performed by the application, the generated code  is patched with breakpoints that are recorded in a breakpoint table  through a breakpoint facility implemented by the operating system or a breakpoint library. As before, portions of the generated code  are progressively staged from memory into a code cache  at runtime as execution proceeds. At runtime, an exception monitor  running within the dynamic compiler  detects an exceptional control flow request  and creates a writeable copy of each page containing a breakpoint listed in the breakpoints table . The set of pages containing copies of those portions of the generated code  containing a breakpoint form a private memory layer, as further described below with reference to .","The request to copy the page is made through a breakpoint application programming interface (API)  exported by the operating system in the runtime environment , which coordinates the page copy request through a page manager . The dynamic compiler then patches the page containing the generated code copy with a trap to a trap handler . In the described embodiment, the API  implements a page copy request interface:\n\n",{"@attributes":{"id":"p-0050","num":"0052"},"figref":["FIGS. 11A-C","FIG. 11A","FIG. 11B","FIG. 11C"],"b":["150","160","170","151","46","47","151","151","46","49","146","152","46","152","152","152","67","161","62"]},"Method for Providing Exceptional Flow Control Through Breakpoints",{"@attributes":{"id":"p-0051","num":"0053"},"figref":["FIG. 12","FIG. 10"],"b":["180","100","141"]},"Initially, one or more breakpoints  are registered in the generated code  (block ). The generated code  executes (block ). For each page containing generated code containing a breakpoint  (blocks -), the page  is copied into a private layer in the memory  (block ). Only those pages  modified with a breakpoint are copied. In addition, the pages  are copied with copy-on-write semantics, such that any of the pages  not written into by a breakpoint or patch remain shared with the original page table . The breakpoints  on the page  are enabled (block ). Upon triggering of the breakpoint (block ), a trap is vectored (block ) to trigger the execution of a trap handler  (block ), after which the breakpoint is cleared and execution of the generated code  resumes (block ). The method terminates upon completion of the generated code .","While the invention has been particularly shown and described as referenced to the embodiments thereof, those skilled in the art will understand that the foregoing and other changes in form and detail may be made therein without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 6A-B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 8A-B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 11A-C"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
