---
title: General programming language support for nullable types
abstract: The subject invention relates to systems and methods that provide null capabilities within the context of programming languages. In one aspect, a system is provided that facilitates null-support in various programming languages. The system includes one or more types associated with at least one programming language. A type modifier is provided to signal that the type is nullable. The type modifier enables a multi-element structure to be automatically created in association with the type wherein, the multi-element structure includes the type and a Boolean element indicating whether or not the variable is null.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07647580&OS=07647580&RS=07647580
owner: Microsoft Corporation
number: 07647580
owner_city: Redmond
owner_country: US
publication_date: 20040907
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The subject invention relates generally to computer systems and more particularly, the subject invention relates to providing nullable type support across multiple variable types in various programming languages.","As programming approaches and foundations have evolved, application programming interfaces (APIs) and programming schemas have been developed to standardize and unify programming methodologies that were previously multi-variant and relatively incompatible. Modern programming therefore often involves employing APIs and schemas in conjunction with reusable libraries. Unfortunately, this evolution has inadvertently created many inefficient programming artifacts that are actually spread and perpetuated by these standardizations programming constructs. For example, one resulting software programming artifact is a duality between reference types and value types.","Reference types are variables that are stored on a heap and referenced by a pointer stored on the stack. Value types are variables that are stored directly on the stack. Consequently, variables that are represented as reference types can be uninitialized (termed \u201cnull\u201d), but variables that are represented as value types cannot be established in an uninitialized condition without risking indeterminate or even catastrophic results. This nullification issue can present problems in a myriad of situations, including data base accessing.","The nullification problem has been previously addressed with many different strategies. Examples of such strategies include tuples, boxing, variants, convoluted pointer manipulations, and so forth. However, each of these strategies have one or more drawbacks including memory inefficiencies, runtime inefficiencies, loss of strong typing, proliferation of non-standard types, and so forth. By way of example, boxing turns value types into reference types, with the accompanying greater memory usage and increased processing demands to handle the inherent pointer overhead.","Support for nullability across all types, including value types, is essential when interacting with databases, yet general purpose programming languages have historically provided little or no support in this area. Many approaches exist for handling nulls and value types without direct language support, but all have shortcomings. For example, one approach is to use a \u201cspecial\u201d value (such as \u22121 for integers) to indicate null, but this only works when an unused value can be identified. Another approach is to maintain boolean null indicators in separate fields or variables, but this doesn't work well for parameters and return values. A third approach is to use a set of user-defined nullable types, but this only works for a closed set of types.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The subject invention relates to providing nullable type support across multiple types in programming languages. A type modifier can be applied to a type in substantially any form to automatically create a multi-element structure representing the underlying value of the type along with a Boolean element in the structure representing whether or not the value is null. Null is generally assigned to a value indicating an undetermined or undefined type. The data indication of null (e.g., value of false) can be employed if the underlying value of the variable in the structure is declared or detected null, wherein the variable is then considered null regardless of the actual value of the variable. If the data indication in the Boolean element is non-null (e.g., value of true), the actual value of the nullable type is represented and may be processed in accordance with the actual value. By allowing substantially any type to also include the concept of nullability, the subject invention allows the concept of nullability to be efficiently handled and processed across all programming languages while mitigating conventional workarounds and potential coding problems such as employing \u201cspecial\u201d values to indicate null, maintaining boolean null indicators in separate fields or variables, and employing user-defined nullable types for a closed set of types.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the invention may be practiced, all of which are intended to be covered by the present invention. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The subject invention relates to systems and methods that provide null capabilities within the context of programming languages (e.g., C, C++, C#, Pascal, Fortan, BASIC, other dynamic languages and so forth). In one aspect, a system is provided that facilitates null-support in various programming languages. The system includes one or more types associated with at least one programming language. A type modifier is provided to signal that the type is nullable. The type modifier enables a multi-element structure to be automatically created in association with the type wherein, the multi-element structure includes the original value and a Boolean element indicating whether or not the value is null. In this manner, programming languages can be made to seamlessly integrate with other languages such as SQL and XML that commonly support null values.","As used in this application, the terms \u201ccomponent,\u201d \u201ctype,\u201d \u201cmodifier,\u201d and \u201csystem\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","Referring initially to , a system  provides nullable type support for programming languages in accordance with an aspect of the subject invention. The system  includes one or more data structures  that can be declared in the context of a programming language  such as C, C++, C#, Pascal, Python, Ruby, Visual Basic, Java, and so forth. The data structures  generally consist of an underlying type such as an integer, float, Boolean, and so forth that can be declared to be a nullable type by associating a type modifier with the underlying type. For instance, a symbol such as \u201c?\u201d can be employed as a type modifier to indicate to a compiler  that the underlying type is to be considered a nullable type. It is to be appreciated that various other symbols can be employed as the type modifier. Upon declaration and compilation, executable code can be generated at  via the compiler  including nullable and non-nullable types, if desired by the programmer. Nullable types can contain any value available for the underlying type and also include the value of null. This is achieved by automatically creating a multi-element structure including an element for the underlying value and a Boolean element representing whether or not the underlying value is null (e.g., flag indicating null or non-null value for the underlying type). If the Boolean element is declared false for example, the underlying type is considered null, whereas if the Boolean element is true for example, the value contained in the underlying value is considered the value of the nullable type variable.","Generally, nullable types are constructed using the ? type modifier (or other symbol). For example, int? is a nullable form of the predefined type int. A nullable type's underlying type should be a non-nullable value type. A nullable type is a structure that combines a value of the underlying type with a boolean null indicator. An instance of a nullable type generally has two public read-only properties that can be used to test the null status of the value: HasValue, of type bool, and Value, of the nullable type's underlying type. For example, HasValue is true for a non-null instance and false for a null instance. When HasValue is true, the Value property returns the contained value. When HasValue is false, an attempt to access the Value property throws an exception.","An implicit conversion can exist from any non-nullable value type to a nullable form of that type. Furthermore, an implicit conversion can exist from the null literal to any nullable type. For example:\n\n","Nullable conversions and lifted conversions described below permit predefined and user-defined conversions that operate on non-nullable value types to also be used with nullable forms of those types. Likewise, lifted operators permit predefined and user-defined operators that work for non-nullable value types to also work for nullable forms of those types. For predefined conversions from a non-nullable value type S to a non-nullable value type T, for example, a predefined nullable conversion automatically exists from S? to T?. This nullable conversion is a null propagating form of the underlying conversion: It converts a null source value directly to a null target value, but otherwise performs the underlying non-nullable conversion. Nullable conversions are furthermore provided from S to T? and from S? to T, the latter as an explicit conversion that throws an exception if the source value is null.","Some examples of nullable conversions are shown in the following.",{"@attributes":{"id":"p-0026","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int i = 123;",{}]},{"entry":[{},"int? x = i;","\/\/ int --> int?"]},{"entry":[{},"double? y = x;","\/\/ int? --> double?"]},{"entry":[{},"int? z = (int?)y;","\/\/ double? --> int?"]},{"entry":[{},"int j = (int)z;","\/\/ int? --> int"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A user-defined conversion operator has a lifted form when the source and target types are non-nullable value types. A ? modifier is added to the source and target types to create the lifted form. Similar to predefined nullable conversions, lifted conversion operators propagate nulls. A non-comparison operator has a lifted form when the operand types and result type are all non-nullable value types. For non-comparison operators, a ? modifier is added to each operand type and the result type to create the lifted form. For example, the lifted form of a predefined+operator that takes two int operands and returns an int is an operator that takes two int? operands and returns an int?. Similar to lifted conversions, lifted non-comparison operators are null propagating: If either operand of a lifted operator is null, the result is null.","The following example uses a lifted+operator to add two int? values:\n\n","The null propagating semantics of C#'s nullable conversions (or other language), lifted conversions, and lifted non-comparison operators are very similar to the corresponding conversions and operators in SQL. However, C#'s lifted comparison operators can be designed to produce regular boolean results rather than introducing SQL's three-valued boolean logic, if desired.","A comparison operator (==, !=, <, >, <=, >=) has a lifted form when the operand types are non-nullable value types and the result type is bool. The lifted form of a comparison operator is formed by adding a ? modifier to each operand type (but not to the result type). Lifted forms of the == and != operators consider two null values equal, and a null value unequal to a non-null value. Lifted forms of the <, >, <=, and >= operators return false if one or both operands are null.","When one of the operands of the == or != operator is the null literal, the other operand may be of any nullable type regardless of whether the underlying value type actually declares that operator. In cases where no operator == or != implementation is available, a check of the operand's HasValue property is substituted. The effect of this rule is that statements such as:\n\n","A new null coalescing operator, ??, can also be provided. The result of a ?? b is a if a is non-null; otherwise, the result is b. Intuitively, b supplies the value to use when a is null. When a is of a nullable type and b is of a non-nullable type, a ?? b returns a non-nullable value, provided suitable implicit conversions exist between the operand types. In the example:\n\n","Referring now to , a system  illustrates null compatibility between languages in accordance with an aspect of the subject invention. In this aspect, a representative programming language is illustrated at , wherein the language is adapted for null compatibility with a nullable type extension structure . As noted above, such structures  include a memory location to hold a value for an underlying type such as an integer or floating point value and include a memory location in the structure for a Boolean value indicating whether or not the underlying type is null. After adapting the programming languages  for handling nullable types , other null-supported languages  can be readily interfaced with. For instance, the null-supported languages can include a database language such as SQL or variants such as SQLXML or XML for example, that may include null in columns or other structures of the language, for example. In one specific example, the database language may be a listing of people having addresses and telephone numbers. If one of the values of the columns were unknown such as a missing address or telephone number, the value of null may be employed to indicate that the actual data is unknown or missing. By providing null-support  with the programming language , the null-supported languages and programming languages  can be integrated (e.g., codes in C# programming languages can read\/write and interpret nullable fields in the database language and visa versa).","Turning now to , more detailed aspects of nullable types  are illustrated in accordance with an aspect of the subject invention. The nullable type  is generally classified as a value type such as:",{"@attributes":{"id":"p-0035","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"value-type:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct-type"]},{"entry":[{},"enum-type"]},{"entry":[{},"nullable-type"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nullable-type:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type ?"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The type specified before the ? modifier in a nullable type  is referred to as the underlying type of the nullable type. The underlying type of a nullable type can be any non-nullable value type (that is, any type parameter with a struct constraint), but it typically cannot be a reference type or a nullable type. For example, int? and double? are valid nullable types, but string? and int?? are generally not. A nullable type can represent all values of its underlying type plus an additional null value. This invention however can be limited to this restriction and the underlying type of the nullable type  may itself be a nullable type or a reference type. Thus, types such as int?? and int??? are permitted, although they can represent no more values than int?. The syntax T? is shorthand for System.Nullable<T>, and the two forms can be used interchangeably.","At , members of nullable types  are considered. An instance of a nullable type T? generally has two public read-only properties:\n\n","In addition to the default constructor, every nullable type T? typically has a public constructor that takes a single argument of type T. If nested nullable types, or nullable reference types are allowed, a constructor invocation of the form\u2014new T?(x) is evaluated as follows: If T is a type parameter, if the run-time type of T is a nullable type, and if x is null, the result is the null value of T?. Otherwise, the result is a non-null instance of T? for which the Value property is x. It is usually not necessary to explicitly invoke a nullable type's constructor since equivalent functionality is provided as an implicit conversion from T to T?.","At , default values for nullable types  are considered. The default value of a nullable type is an instance for which the HasValue property is false and the Value property is undefined although different default values can be provided, if desired. The default value is also known as the null value of the nullable type. An implicit conversion exists from the null literal to any nullable type, and this conversion produces the null value of the type.","Referring now to , nullable type conversions  are illustrated in accordance with an aspect of the subject invention. Before proceeding, the following notations and terms are used: The term wrapping denotes the process of packaging a value, of type T, in an instance of a type of the form T?. Conceptually, a value x of type T is wrapped to type T? by evaluating the expression new T?(x). The term unwrapping denotes the process of obtaining the value, of type T, contained in an instance of a type of the form T?. Conceptually, a value x of type T? is unwrapped to type T by evaluating the expression x.Value. Attempting to unwrap a null instance causes a System.InvalidOperationException to be thrown.","At , null literal conversions are considered. An implicit conversion exists from the null literal to any nullable type. This conversion produces the null value of the given nullable type. At , nullable conversions are considered. Nullable conversions permit predefined conversions that operate on non-nullable value types to also be used with nullable forms of those types. For each of the predefined implicit or explicit conversions that convert from a non-nullable value type S to a non-nullable value type T, the following nullable conversions exist: An implicit or explicit conversion from types of the form S? to types of the form T?, an implicit or explicit conversion from S to types of the form T?, or an explicit conversion from types of the form S? to T.","A nullable conversion is itself classified as an implicit or explicit conversion. Implicit nullable conversions are classified as standard implicit conversions and can thus occur as part of a user-defined conversion. Evaluation of a nullable conversion based on an underlying conversion from S to T proceeds as follows: If the nullable conversion is from a type of the form S? to a type of the form T?: If the source value is null (HasValue property is false), the result is the null value of type T?. Otherwise, the conversion is evaluated as an unwrapping from S? to S, followed by the underlying conversion from S to T, followed by a wrapping from T to T?. If the nullable conversion is from S to a type of the form T?, the conversion is evaluated as the underlying conversion from S to T followed by a wrapping from T to T?. If the nullable conversion is from a type of the form S? to T, the conversion is evaluated as an unwrapping from S? to S followed by the underlying conversion from S to T.","At , user-defined conversions are considered. The rules governing permitted user-defined conversion operator declarations are modified to allow a struct to also declare conversion operators that convert to or from nullable forms of the struct type. A class or struct is permitted to declare a conversion from a source type S to a target type T only if all of the following are true, where Sand Tare the types that result from removing all trailing ? modifiers (if any) from S and T:\n\n","Evaluation of user-defined conversions is modified as follows to support nullable types: Trailing ? modifiers (if any) are removed from the source and target types before determining the set of types from which user-defined conversion operators will be considered. For example, when converting from a type S? to a type T?, the set of types from which user-defined conversion operators will be considered consists of S and T. When the source and target types are both nullable, the set of applicable conversion operators includes not just user-defined conversion operators but also lifted conversion operators. When determining the most specific conversion operator, user-defined conversion operators are preferred over lifted conversion operators.","At , lifted conversions are considered. Given a user-defined conversion operator that converts from a non-nullable value type S to a non-nullable value type T, a lifted conversion operator exists that converts from S? to T?. This lifted conversion operator performs an unwrapping from S? to S followed by the user-defined conversion from S to T followed by a wrapping from T to T?, except that a null valued S? converts directly to a null valued T?. A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.",{"@attributes":{"id":"p-0046","num":"0070"},"figref":"FIG. 5","b":"500"},"Before proceeding, it is noted that implicit and explicit conversions are described that generally follow the flow diagram . A user-defined implicit conversion from type S to type T is processed as follows: At , determine the types Sand Tthat result from removing all trailing ? modifiers (if any) from S and T. At , find the set of types, D, from which user-defined conversion operators will be considered. This set consists of S(if Sis a class or struct), the base classes of S(if Sis a class), and T(if Tis a class or struct). At , find the set of applicable conversion operators, U. This set consists of the user-defined and, if S and T are both nullable, lifted implicit conversion operators declared by the classes or structs in D that convert from a type encompassing S to a type encompassed by T. If U is empty, the conversion is undefined and a compile-time error occurs.","At , find the most specific source type, S, of the operators in U: If any of the operators in U convert from S, then Sis S. Otherwise, Sis the most encompassed type in the combined set of source types of the operators in U. If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs. At , find the most specific target type, T, of the operators in U: If any of the operators in U convert to T, then Tis T. Otherwise, Tis the most encompassing type in the combined set of target types of the operators in U. If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs. At , find the most specific conversion operator: If U contains exactly one user-defined conversion operator that converts from Sto T, then this is the most specific conversion operator. Otherwise, if U contains exactly one lifted conversion operator that converts from Sto T, then this is the most specific conversion operator. Otherwise, the conversion is ambiguous and a compile-time error occurs. At , apply the conversion: If S is not S, then a standard implicit conversion from S to Sis performed. The most specific conversion operator is invoked to convert from Sto T. If Tis not T, then a standard implicit conversion from Tto T is performed.","Before proceeding, a process for user-defined explicit conversions is described that generally follows the flow of . A user-defined explicit conversion from type S to type T is processed as follows: Determine the types Sand Tthat result from removing all trailing ? modifiers (if any) from S and T. Find the set of types, D, from which user-defined conversion operators will be considered. This set consists of S(if Sis a class or struct), the base classes of S(if Sis a class), T(if Tis a class or struct), and the base classes of T(if Tis a class). Find the set of applicable conversion operators, U. This set consists of the user-defined and, if S and T are both nullable, lifted implicit or explicit conversion operators declared by the classes or structs in D that convert from a type encompassing or encompassed by S to a type encompassing or encompassed by T. If U is empty, the conversion is undefined and a compile-time error occurs.","Find the most specific source type, S, of the operators in U: If any of the operators in U convert from S, then Sis S. Otherwise, if any of the operators in U convert from types that encompass S, then Sis the most encompassed type in the combined set of source types of those operators. If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.","Otherwise, Sis the most encompassing type in the combined set of source types of the operators in U. If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs. Find the most specific target type, T, of the operators in U: If any of the operators in U convert to T, then Tis T.","Otherwise, if any of the operators in U convert to types that are encompassed by T, then Tis the most encompassing type in the combined set of target types of those operators. If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs. Otherwise, Tis the most encompassed type in the combined set of target types of the operators in U. If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.","Find the most specific conversion operator: If U contains exactly one user-defined conversion operator that converts from Sto T, then this is the most specific conversion operator. Otherwise, if U contains exactly one lifted conversion operator that converts from Sto T, then this is the most specific conversion operator. Otherwise, the conversion is ambiguous and a compile-time error occurs. Apply the conversion:","If S is not S, then a standard explicit conversion from S to Sis performed. The most specific conversion operator is invoked to convert from Sto T. If Tis not T, then a standard explicit conversion from Tto T is performed.",{"@attributes":{"id":"p-0055","num":"0079"},"figref":"FIG. 6","b":["600","610"]},"For the unary operators + ++ \u2212 \u2212\u2212 ! \u02dc a lifted form of an operator exists if the operand and result types are both non-nullable value types. The lifted form is constructed by adding a single ? modifier to the operand and result types. The lifted operator produces a null value if the operand is null. Otherwise, the lifted operator unwraps the operand, applies the underlying operator, and wraps the result.","For the binary operators + \u2212 * \/ % & |^ << >> a lifted form of an operator exists if the operand and result types are all non-nullable value types. The lifted form is constructed by adding a single ? modifier to each operand and result type. The lifted operator produces a null value if one or both operands are null (an exception being the & and | operators of the bool? type described below). Otherwise, the lifted operator unwraps the operands, applies the underlying operator, and wraps the result.","For the equality operators == !=a lifted form of an operator exists if the operand types are both non-nullable value types and if the result type is book. The lifted form is constructed by adding a single ? modifier to each operand type. The lifted operator considers two null values equal, and a null value unequal to any non-null value. If both operands are non-null, the lifted operator unwraps the operands and applies the underlying operator to produce the bool result.","For the relational operators < > <= >= a lifted form of an operator exists if the operand types are both non-nullable value types and if the result type is bool. The lifted form is constructed by adding a single ? modifier to each operand type. The lifted operator produces the value false if one or both operands are null. Otherwise, the lifted operator unwraps the operands and applies the underlying operator to produce the bool result.","At , operator overload resolution is considered. The rules for unary and binary operator overload resolution can be modified as follows to support lifted operators: Trailing ? modifiers (if any) are removed from the operand types to determine the types in which to locate user-defined operator declarations. For example, if the operands are of type X? and Y?, the set of candidate operators is determined by examining X and Y. When determining the set of candidate user-defined operators, lifted forms of the operators declared in a type are considered to also be declared by the type.","Operator lifting applies to predefined operators, and the lifted forms of the predefined operators are themselves considered predefined operators. When selecting the single best operator, if two operators have identical signatures, an unlifted operator is generally considered more optimal than a lifted operator.","At , equality operators and null is considered. The == and != operators permit one operand to be a value of a nullable type and the other to be the null literal, even if no predefined or user-defined operator (in unlifted or lifted form) exists for the operation.","For an operation of one of the forms x==null null==x x !=null null !=x","where x is an expression of a nullable type, if operator overload resolution fails to find an applicable operator, the result is instead computed from the HasValue property of x. Specifically, the first two forms are translated into !x.HasValue, and last two forms are translated into x.HasValue. At , compound assignments are considered. Compound assignment operations support lifted operators. Since a compound assignment x op=y is evaluated as either x=x op y or x=(T)(x op y), the existing rules of evaluation implicitly cover lifted operators and thus no changes to the rules are required.","At , a bool? Type is considered. The nullable boolean type bool? can represent three values, true, false, and null, and is conceptually similar to the three-valued type used for boolean expressions in SQL. To ensure that the results produced by the & and | operators for bool? operands are consistent with SQL's three-valued logic, the following predefined operators are provided: bool? operator &(bool? x, bool? y);","and bool? operator |(bool? x, bool? y); The following table lists the results produced by these operators for all combinations of the values true, false, and null.",{"@attributes":{"id":"p-0067","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"x","y","x & y","x | y"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"true","true","True","True"]},{"entry":[{},"true","false","False","True"]},{"entry":[{},"true","null","Null","True"]},{"entry":[{},"false","true","False","True"]},{"entry":[{},"false","false","False","False"]},{"entry":[{},"false","null","False","Null"]},{"entry":[{},"null","true","Null","True"]},{"entry":[{},"null","false","False","Null"]},{"entry":[{},"null","null","Null","Null"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}}}},"The bool? type is considered to implement operator true and operator false in the obvious manner: operator true returns true if the operand is true, and operator false returns true if the operand is false. Since bool? implements these operators, operands of the ?? and \u2225 operators are permitted to be of type bool?, and expressions of type bool? may be used with if, while, do, and for statements.",{"@attributes":{"id":"p-0069","num":"0093"},"figref":"FIG. 7","b":["700","710"]},"A?? operator is referred to as a null coalescing operator.",{"@attributes":{"id":"p-0070","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"null-coalescing-expression:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"conditional-or-expression"]},{"entry":[{},"conditional-or-expression double-question null-"]},{"entry":[{},"coalescing-expression"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"double-question:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"? ?"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"conditional-expression:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"null-coalescing-expression"]},{"entry":[{},"null-coalescing-expression ? expression : expression"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The double-question production does not permit any intervening whitespace or comments between the two ? tokens. A null coalescing expression of the form a ?? b requires a to be of a nullable type or reference type. If a is non-null, the result of a ?? b is a; otherwise, the result is b. The operation evaluates b only if a is null.","The null coalescing operator is right-associative, meaning that operations are grouped from right to left. For example, an expression of the form a ?? b ?? c is evaluated as a ?? (b ?? c). In general terms, an expression of the form E?? E?? . . . ?? Ereturns the first of the operands that is non-null, or null if all operands are null. The type of the expression a ?? b depends on which implicit conversions are available between the types of the operands. In order of preference, the type of a ?? b is A, A, or B, where A is the type of a, B is the type of b, and Ais the type that results from removing all trailing ? modifiers from A. Specifically, a ?? b is generally processed as follows: If A is not a nullable type or a reference type, a compile-time error occurs. If A is a nullable type and an implicit conversion exists from b to A, the result type is A. At run-time, a is first evaluated. If a is not null, a is unwrapped to type A, and this becomes the result. Otherwise, b is evaluated and converted to type A, and this becomes the result. Otherwise, if an implicit conversion exists from b to A, the result type is A. At run-time, a is first evaluated. If a is not null, a becomes the result. Otherwise, b is evaluated and converted to type A, and this becomes the result. Otherwise, if an implicit conversion exists from Ato B, the result type is B. At run-time, a is first evaluated. If a is not null, a is unwrapped to type A(unless A and Aare the same type) and converted to type B, and this becomes the result. Otherwise, b is evaluated and becomes the result. Otherwise, a and b are incompatible, and a compile-time error occurs.","At , nested types are considered. In one aspect, the type-system described above can prevent users from constructing type T? when T is a reference type or T itself is S? for some type S at compile time. The underlying implementation uses the existing \u201cstruct\u201d constraint to encode this. As a result, users are not allowed by design to write string? since string is a reference type, or int?? since int? is a nullable type. One concept is that the type-system can impose certain constraints on the construction of nullable types if desired; the current constraint is a specific instance of this concept. For example, in the future it may be desirable to prevent double? Or restrict T? to types T whose size is smaller than 10 bytes or other constraint.","In another example, consider nested type T?? at runtime. Assume that that there are two operations on T? namely HasValue that tests if a value t of type T? is null, and Value that given a value of type T? returns the underlying value of type T. Consider the following example:\n\n","It should be clear that x.HasValue returns false. One question is what y.HasValue should return. In principle it could return true, since x is actually a value of type int?. It would be unusual however if y.HasValue returns true while y.Value.HasValue returned false (since y.Value is x, and x.HasValue is false). The purpose of \u201cnull unification\u201d or null-propagation is to make sure that for any value r if r.HasValue is true then r.Value.HasValue is true as well (or if r.Value.HasValue is false, then r.HasValue is false as well). There are several ways to achieve the above: (a) perform a check in the constructor of T? and propagate the underlying null (b) to insert special unification code at certain points in the program where nested nullable values are constructed, or (c) to throw an error in the static constructor of the Nullable<T> when T itself is Nullable. The general concepts ensures the runtime invariant that for any value r of type T? if P(r) is true then P(r.Value) is true as well for some predicate P. In case nested nullable types or nullable reference types are allowed, the given rules for the systems and methods described above can be generalized.","With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer . The computer  includes a processing unit , a system memory , and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, 11-bit bus, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), and Small Computer Systems Interface (SCSI).","The system memory  includes volatile memory  and nonvolatile memory . The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer  also includes removable\/non-removable, volatile\/non-volatile computer storage media.  illustrates, for example a disk storage . Disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-100 drive, flash memory card, or memory stick. In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to computer , and to output information from computer  to an output device . Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers, among other output devices , that require special adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It should be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to computer . For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to computer  through a network interface  and then physically connected via communication connection . Network interface  encompasses communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet\/IEEE 802.3, Token Ring\/IEEE 802.5 and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to computer . The hardware\/software necessary for connection to the network interface  includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.",{"@attributes":{"id":"p-0084","num":"0110"},"figref":"FIG. 9","b":["900","900","910","910","900","930","930","930","910","930","900","950","910","930","910","960","910","930","940","930"]},"What has been described above includes examples of the subject invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the subject invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the subject invention are possible. Accordingly, the subject invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
