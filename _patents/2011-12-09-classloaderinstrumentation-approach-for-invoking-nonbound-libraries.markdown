---
title: Classloader/instrumentation approach for invoking non-bound libraries
abstract: An agent object can invoke one or more methods of an application object using a helper object. The application object passes a reference to itself to the agent object. The agent object identifies a class loader of the application from the reference. The agent object obtains byte code of a helper class and uses the byte code of the helper class to creating a helper class loader. A parent of the helper class loader is set as the class loader of the application. The helper class loader is used to load the helper class and define an instance of the helper object. Using the helper object, the one or more methods of the application object are invoked by the agent using casting, without having a direct class loader connection with the class loader of the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09411616&OS=09411616&RS=09411616
owner: CA, Inc.
number: 09411616
owner_city: New York
owner_country: US
publication_date: 20111209
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Technology for monitoring software in a computing environment is provided.","2. Description of the Related Art","The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e-commerce, education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives, and devote considerable resources to ensuring that they perform as expected. To this end, various application management techniques have been developed. One approach involves monitoring the infrastructure of the application by instrumenting the application and using the instrumentation to collect data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example, using the instrumentation, a thread or process can be traced to identify each component that is invoked, as well as to obtain runtime data such as the execution time of each component. However, the agent's ability to otherwise interact with the application components has been limited.","The present invention provides a technique which allows agent software to access an application such as to invoke methods of the application in an efficient manner.","In one embodiment, one or more tangible processor-readable storage devices having computer readable software embodied thereon are provided for programming at least one processor to perform a method for accessing an application. The method includes: (a) at an agent, receiving a reference to an object of the application from instrumentation of the application, and identifying a class loader of the application from the reference, and (b) based on the reference, performing a process which allows the agent to invoke one or more methods of the application object. The process comprises: (i) at the agent, identifying the class loader of the application from the reference; (ii) creating a helper class loader and setting a parent class loader of the helper class loader as the class loader of the application, responsive to the identifying; (iii) using the helper class loader to obtain and load byte code of a helper class; (iv) using the loaded byte code of the helper class to define a helper object; and (v) using the helper object, invoking the one or more methods of the application object.","In another embodiment, one or more tangible processor-readable storage devices having computer readable software embodied thereon are provided for programming at least one processor to perform a method for accessing an application. The method includes: (a) at an agent, receiving a reference to an object of the application from instrumentation of the application, and identifying a class loader of the application from the reference; and (b) based on the reference, performing a process which allows the agent to invoke one or more methods of the application object. The process comprises: (i) at the agent, identifying the class loader of the application from the reference; (ii) creating a helper class loader and setting a parent class loader of the helper class loader as the class loader of the application, responsive to the identifying; (iii) using the helper class loader to obtain and load byte code of a helper class and a helper object from at least one file; and (iv) using the helper object, invoking the one or more methods of the application object.","In another embodiment, a computer-implemented method for accessing an application includes: (a) at an agent, receiving a reference to an object of an application from instrumentation of the application, and identifying a class loader of the application from the reference; (b) creating a helper class loader and setting a parent class loader of the helper class loader as the class loader of the application, responsive to the identifying; (c) using the helper class loader to obtain and load byte code of a helper class; (d) using the loaded byte code of the helper class to define a helper object; and (e) using the helper object, invoking the one or more methods of the application object.","Corresponding processor-implemented methods may be provided which perform computer-implemented steps as described herein. A corresponding computer system may be provided which includes one or more tangible processor-readable storage devices having computer readable software embodied thereon, and at least one processor, where the at least one processor is responsive to the one or more tangible processor-readable storage devices to perform a method for accessing an application, as described herein.","One or more tangible processor-readable storage devices having computer readable software embodied thereon can also be provided for programming at least one processor to perform the above-mentioned method. A corresponding computer system may be provided which includes one or more tangible processor-readable storage devices having computer readable software embodied thereon, and at least one processor, where the at least one processor is responsive to the one or more tangible processor-readable storage devices to perform a method for accessing an application, as described herein.","The present invention provides a technique which enables agent software to efficiently invoke a method of an application. When agent software is used to instrument the bytecode of an application, an arbitrary object of the application is re-defined to invoke a method in an agent shim object, passing itself as a parameter, in one possible approach. The agent software performs several operations, some of which require access to specific fields and methods on the application object or other objects passed as parameters to the original application method. For example, if an instrumented method is a servlet.service method, the agent will attempt to invoke methods on the parameter object implementing HttpServletRequest.","In one approach, the agent uses the JAVA Reflection Application Programming Interface (API) to invoke the methods, instead of the more direct technique of class casting. Non-bound libraries are not linked statically and therefore need to be read using the Reflection approach instead of casting. Reflection is a feature in the JAVA programming language which allows an executing JAVA program to examine or \u201cintrospect\u201d upon itself, and manipulate internal properties of the program. For example, it's possible for a Java class to obtain the names of all its members and display them. The Reflection API is used by programs to examine or modify the runtime behavior of applications running in the JAVA virtual machine (JVM). The agent can use the Reflection API when the agent does not have access through its class loader to the same API classes that are used by the application object. An example of class loader is the abstract JAVA class of ClassLoader.","However, the Reflection API is a weak-typed API or method call because it works at the JVM level rather than the compiler level, so the type of the object that is invoked is not known at compile time. Although, JAVA generally is a strong-typed language since the type of all object invocations is known or can be inferred at compile time. As a result, invocation of methods using the Reflection API can be slow and inefficient. Techniques described herein allow an agent to invoke a method of an application using casting, which is strong-typed and therefore fast and inefficient, instead of using the Reflection API.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIGS. 1-9","FIGS. 10-11C"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","103","105","111","102","102","111","103","105","101","102","101","102","108","108"]},"For example, a corporation running an enterprise application such as a web-based e-commerce application may employ a number of application servers at one location for load balancing. Requests from users, such as from the example web browser , are received via the network , and can be routed to any of the managed computing devices. Agent software running on the managed computing devices  and , denoted by agent  and agent , respectively, gather information from an application, middleware or other software, running on the respective managed computing devices. Such information may be obtained using instrumentation, one example of which is byte code instrumentation. However, the gathered data may be obtained in other ways as well. The agents essentially live in the computing device being monitored and provide a data acquisition point. The agents organize and optimize the data communicated to the manager . In one implementation, different instances of the same application run at the managed computing devices.","The manager  can be provided on a separate computing device such as a workstation which communicates with a user interface  (see also ), such as a monitor, to display information based on data received from the agents. The manager can also access a database  to store the data received from the agents. For instance, some large organizations employ a central network operations center where one or more managers obtain data from a number of distributed agents at different geographic locations. To illustrate, a web-based e-commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders, from servers that process payments, from servers at warehouses for tracking inventory and conveying orders, and so forth. The manager  and user interface display  might be provided at a corporate headquarters location. Other applications which are not necessarily web-based or involve retail or other sales, similarly employ agents and managers for managing their systems. For example, a bank may use an application for processing checks and credit accounts. Moreover, in addition to the multi-computing device arrangements mentioned, a single computing device can be monitored as well with one or more agents.","Various approaches are known for instrumenting software to monitor its execution. For example, tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Pat. No. 7,870,431, issued Jan. 11, 2011, titled \u201cTransaction Tracer,\u201d and incorporated herein by reference. In one approach discussed therein, object code or bytecode of an application to be monitored is instrumented, e.g., modified, with probes. The probes measure specific pieces of information about the application without changing the application's business or other logic. Once the probes have been installed in the bytecode of an application, it is referred to as a managed application, and a computing device on which the application runs is referred to as a managed computing device. The agent software receives information from the probes and may communicate the information to another process, such as at the manager , or process the information locally, such as to determine whether the information indicates an abnormal condition. The agent thus collects and summarizes information received from the probes. The probes collect information as defined by a directives file. For example, the information from the probes may indicate start and stop times of a transaction or other execution flow, or of individual components within a transaction\/execution flow. This information can be compared to pre-established criteria to determine if it within bounds. If the information is not within bounds, the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents are typically aware of the software executing on the local managed computing device with which they are associated.","The probes can report a standard set of metrics which include: CORBA method timers, Remote Method Invocation (RMI) method timers, Thread counters, Network bandwidth, JDBC update and query timers, Servlet timers, Java Server Pages (JSP) timers, System logs, File system input and output bandwidth meters, Available and used memory and EJB (Enterprise JavaBean) timers. A metric is a measurement of a specific application activity. Each of these metrics can be configured by agent metadata.","An agent reports information about transactions, which identifies resources which are accessed by an application. In one approach, when reporting about transactions, the word Called designates a resource. This resource is a resource (or a sub-resource) of a parent component, which is a consumer. For example, assume that Servlet A is the first component invoked in a transaction. Under the consumer Servlet A (see below), there may be a sub-resource Called EJB. Consumers and resources can be reported by the agent in a tree-like manner. Data for a transaction can also be stored according to the tree. For example, if a Servlet (e.g., Servlet A) is a consumer of a network socket (e.g., Socket C) and is also a consumer of an EJB (e.g. EJB B), which in turn is a consumer of a JDBC (e.g., JDBC D), the tree might look something like the following:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Servlet A"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data for Servlet A"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Called EJB B"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data for EJB B"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Called JDBC D"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data for JDBC D"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Called Socket C"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Data for Socket C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In one embodiment, the above tree is stored by the agent in a stack, called the Blame Stack. When transactions are started, they are pushed onto the stack. When transactions are completed, they are popped off the stack. In one embodiment, each transaction on the stack has the following information stored: type of transaction, a name used by the system for that transaction, a hash map or dictionary of parameters, a timestamp for when the transaction was pushed onto the stack, and sub-elements. Sub-elements are Blame Stack entries for other components (e.g., methods, process, procedure, function, thread, set of instructions, etc.) that are started from within the transaction of interest. Using the tree as an example above, the Blame Stack entry for Servlet A would have two sub-elements. The first sub-element would be an entry for EJB B and the second sub-element would be an entry for Socket Space C. Even though a sub-element is part of an entry for a particular transaction, the sub-element will also have its own Blame Stack entry. An example of an entry point to a transaction\/branch is a URL. As the tree above notes, EJB B is a sub-element of Servlet A and also has its own entry. The top (or initial) entry (e.g., Servlet A) for a transaction, is called the root component. Each of the entries on the stack is an object.","Each agent adds instrumentation to an application and is configured based on one or more configuration files. For example, agent  may use configuration files ,  and , and agent  may use configuration files ,  and . The configuration files can include an agent profile file, a probe builder directives file and a probe builder list file, for instance (e.g., files ,  and , respectively, or ,  and , respectively). One or more of each type of file may be used.","The agent profile files are responsible for enabling\/disabling of agent features, location of server, type of communication (e.g., plain socket, SSL, HTTP, HTTP over SSL), location of configuration files and log files, metric sending frequency, and so forth.","A probe builder directives file contains directives for the agent. Directives may contain information about the type and source of metrics to generate, e.g., by specifying at least one method of a class or set of classes to monitor and a type of information to be collected in the application, or information about a formatter for renaming a metric, and so forth. Directives can also specify at least one method of a class or set of classes to instrument.","A PBL (Probe Builder Listing) configuration file is used for grouping a set of PBD files.","The applications of the servers  and  can execute in an execution environment such as the JAVA runtime environment, as discussed in connection with . The JAVA runtime environment uses a Java Virtual Machine (JVM). Programs intended to run on a JVM are typically compiled into a standardized portable binary format, which usually are in the form of .class files. A program may include many classes in different files. For easier distribution of large programs, multiple class files may be packaged together in a (JAVA Archive) JAR file. The JVM runtime executes CLASS or JAR files, emulating the JVM instruction set by interpreting it, or using a just-in-time compiler (JIT). JIT compiling, as opposed to interpreting, is often used in a JVM to achieve greater speed.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2A","b":["130","132"]},{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameters","Appears in","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UserID","Servlet, JSP","The UserID of the end-user invoking"]},{"entry":[{},{},"the http servlet request."]},{"entry":["URL","Servlet, JSP","The URL passed through to the servlet"]},{"entry":[{},{},"or JSP, not including the Query String."]},{"entry":["URL Query","Servlet, JSP","The portion of the URL that specifies"]},{"entry":[{},{},"query parameters in the http request"]},{"entry":[{},{},"(text that follows the \u2018?\u2019 delimiter)."]},{"entry":["Dynamic","Dynamic JDBC","The dynamic SQL statement, either in a"]},{"entry":["SQL","Statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Method","Blamed Method","The name of the traced method. If the"]},{"entry":[{},"timers (every-","traced method directly calls another"]},{"entry":[{},"thing but","method within the same component,"]},{"entry":[{},"Servlets, JSP's","only the \u201coutermost\u201d first"]},{"entry":[{},"and JDBC","encountered method is captured."]},{"entry":[{},"Statements)"]},{"entry":["Callable","Callable JDBC","The callable SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Prepared","Prepared JDBC","The prepared SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Object","All non-static","toString( ) of the this object of the"]},{"entry":[{},"methods","traced component, truncated to some"]},{"entry":[{},{},"upper limit of characters."]},{"entry":["Class Name","All","Fully qualified name of the class of the"]},{"entry":[{},{},"traced component."]},{"entry":["Param_n","All objects with","toString( ) of the nth parameter passed"]},{"entry":[{},"WithParams","to the traced method of the component."]},{"entry":[{},"custom tracers"]},{"entry":["Primary Key","Entity Beans","toString( ) of the entity bean's"]},{"entry":[{},{},"property key, truncated to some upper"]},{"entry":[{},{},"limit of characters."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Parameters can include query, cookie, post, URL and session type name\/value pairs.","In step , the system acquires a timestamp indicating the current time. In step , a stack entry is created. In step , the stack entry is pushed onto the Blame Stack. In one embodiment, the timestamp is added as part of step . The process is performed when a transaction is started. A similar process is performed when a sub-component of the transaction starts (e.g., EJB B is a sub-component of Servlet A\u2014see tree described above).",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 2B","FIG. 1"],"b":["140","142","144","146","142","148","148","146","150","150","160","162","111"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 2B"},"Note, in one embodiment, if the transaction tracer is off, the system will still use the Blame Stack; however, parameters will not be stored and no component data will be created. In some embodiments, the system defaults to starting with the tracing technology off. The tracing only starts after a user requests it, as described above.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 3","FIG. 1","FIG. 1","FIG. 9"],"b":["300","300","310","320","330","340","310","350","310","330","350","350"]},"A database may be included in the storage device  when the storage device  is part of a computing device  such as an application server, manager and\/or user interfaces. The storage device  can represent one or more storage devices which store data received from one or more agents, and which can be accessed to obtain data to provide a user interface as described herein. The storage device  can represent a data store.","Further, the functionality described herein may be implemented using hardware, software or a combination of both hardware and software. For software, one or more non-transitory, tangible processor readable storage devices having processor readable code embodied thereon for programming one or more processors may be used. The non-transitory, tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media, removable and non-removable media. For example, non-transitory, tangible computer readable media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Examples of non-transitory, tangible computer readable media include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer. In alternative embodiments, some or all of the software can be replaced by dedicated hardware including custom integrated circuits, gate arrays, FPGAs, PLDs, and special purpose processors. In one embodiment, software (stored on a storage device) implementing one or more embodiments is used to program one or more processors. The one or more processors can be in communication with one or more tangible computer readable media\/storage devices, peripherals and\/or communication interfaces.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4"},"A top level of the hierarchy is a domain level  named \u201cDomain.\u201d A next level of the hierarchy is a Business Service level . An example of a Business Service relates to trading a stock using a web site. Thus, \u201cTrading\u201d can be the name of a node at the Business Service level of the hierarchy. A next level of the hierarchy is a Business Transaction level. A Business Service can be made up of a number of Business Transactions. For example, for Trading, the Business Transactions can include Reports  (e.g., view a report regarding a stock or an account) and Quotes  (e.g., obtain a quote for a stock price). Further, a Business Transaction can be associated with one or more Business Transaction Components. In one approach, a Business Transaction has only one identifying component. A Business Transaction Component can be a type of component of an application which is recognizable and measurable by a server, such as a servlet or EJB. In one approach, one of the components of an application is set as a Business Transaction Component, which is an identifying transaction component for a Business Transaction.","The Business Transaction Component is the identifying transaction component for the transaction that is the identifying transaction for the Business Transaction. A transaction can represent a sequence of software components which are invoked in response to a request from a client, to provide a corresponding response to the client. For example, a Business Transaction Component can be identified by determining when component data reported by an agent match a set of rules. This definition can include, e.g., a specified URL host name, URL parameters, HTTP post parameters, cookie and\/or session manager parameters. Additionally, or alternatively, the definition may require a transaction to start with a specified URL host name. The agent or manager, for instance, can compare the component data against the set of rules to determine when a Business Transaction Component is present in a Business Transaction. If a Business Transaction Component is detected, then the associated Business Transaction is of a specified type. For example, if the Business Transaction Component  is detected, then the associated Business Transaction is Reports . If the Business Transaction Component  is detected, then the associated Business Transaction is Quotes .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 5","FIG. 4"]},"Component-oriented programming models are useful in allowing the programmer to assemble an application or other program from building blocks referred to as components. Each component can perform a specific function which fits in with an overall functionality of the software. Furthermore, a component can call other components, as well as calling itself, in a recursive call, so that a sequence of components is invoked in a program. One example of a component oriented programming model is J2EE, which can employ components such as a Java Server Page, an EJB, a servlet, and a Java Database Connectivity (JDBC) component. JDBC is an Application Programming Interface (API) for the JAVA\u2122 programming language that defines how a client may access a database. It provides methods for querying and updating data in a database. However, other component oriented programming models such as the MICROSOFT CORP. \u201c.NET\u201d Framework may also be used. Moreover, the programming model need not be object oriented.","This example provides details of the Reports and Quotes Business Transactions discussed previously. In one possible implementation, each component of a Business Transaction includes one or more class-method pairs. For example, a servlet is a JAVA class. It is an object that receives a request and generates a corresponding response. A class-method pair can be represented by the notation class.method. For example, Reports could include a component C () which displays a reports screen on a user interface (UI) to receive a user's input regarding a desired report. An example format of a class-method pair for C is ServletA1.DisplayReportScreen. C is under a root . Thus, whenever an agent detects that C has been invoked, it concludes that the current transaction is part of Reports, and associates its component data with Reports.","C can call C () which relates to a requested report. C could include a class-method pair such as ServletA2.RequestedReport which processes a user input of a requested report. This processing could include checking the format of the request, for instance, and, if the format is valid, making a call to a component C (), which receives the report request. For instance, this call may be a cross-process, cross-thread transaction or cross-subsystem call. If the format is invalid, the control flow returns to C, which may call C to display an error message, for instance.","An example format of a class-method pair for C is ServletA3.ReceiveReportRequest. C can call C () to access a database and\/or C () to access a database, such as based on the type of the report request. For example, C and C can each include a JDBC driver call which invokes one or more SQL statements. The control flow then returns to C, then to C and then to C. Subsequently, C calls C () which relates to providing a display, such as a display of the requested report based on data retrieved from the databases. The control flow then returns to C.","Also, under the root , a component C () can be provided which displays a quotes screen on a user interface (UI) to receive a user's input regarding a desired quote. C can call C () which relates to a requested report. C can process the user input by checking the format of the request, for instance, and if the format is valid, obtaining the requested quote, such as from a data source which is local to subsystem. If the format is invalid, the control flow returns to C, which may call C to display an error message, for instance. The control flow then returns to C. C can call C (), which relates to providing a display, such as a display of the requested quote based on the data retrieved from the data source.","Note that a component can continue executing after calling another component, which begins executing, in an asynchronous, multi-thread or multi-process mode. Or, a component can temporarily pause until the called component has finished executing, in a synchronous, single-thread or single-process mode. A component which is pausing can be considered to be in a wait interval, while a component which is executing can be considered to be in an active, executing mode. Also, a component may be invoked more than once during a transaction.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 6","FIG. 5","FIG. 9"]},"The transaction trace of  involves components C, C, C and C, represented by graph portions , ,  and , respectively. C starts executing at t and ends or stops at t. C, which is called by C, starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. The time increments are not necessarily equidistant.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 7","FIG. 1"],"b":["700","720","730","702","704","706","708","710","712","708","710","712"]},"The registers include a program counter (pc), which keeps track of where in the memory it should be executing instructions. The program counter identifies the next byte code to be executed. The frame register contains a pointer to the execution environment of the current method in the operand stack. The operand top (optop) register contains a pointer to the top of the operand stack, and is used to evaluate arithmetic expressions. The variable (vars) register contains a pointer to local variables.","The operand stack supplies parameters to methods and operations and receives results back from them. All byte code instructions take operands from the stack, operate on them, and return results to the stack. The operand stack includes a stack frame of an executing method. The stack frame holds the state, e.g., local variables, and intermediate results of calculations, for a particular invocation of a method. Specifically, each JVM thread has a private JVM stack, created at the same time as the thread. A JVM stack stores frames, holds local variables and partial results, and plays a part in method invocation and return. A frame is thus used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the JVM stack of the thread creating the frame. Each frame has its own array of local variables, its own operand stack, and a reference to the runtime constant pool of the class of the current method.","The heap or memory allocation pool is garbage collected. The heap is the runtime data area from which memory for all class instances and arrays is allocated. The heap is created on virtual machine start-up, and heap storage for objects is reclaimed by an automatic storage management system known as a garbage collector. Specifically, each program running in the Java runtime environment has a garbage-collected heap assigned to it. Moreover, each class in the heap has a constant pool associated with it. Because constants do not change, they are usually created at compile time. Items in the constant pool encode all the names used by any method in a particular class. The class contains a count of how many constants exist, and an offset that specifies where a particular listing of constants begins within the class description.","The method area stores byte code instructions that are associated with methods in the compiled code, and a symbol table which the execution environment needs for dynamic linking Any debugging or additional information that might need to be associated with a method is stored in this area as well. The program counter always points to, e.g., contains the address of, some byte in the method area. The program counter is used to keep track of the thread of execution. After a byte code instruction has been executed, the program counter will contain the address of the next instruction to execute.","The method area is shared among all JVM threads, and stores per-class structures such as the runtime constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface type initialization. The method area is created on virtual machine start-up. A runtime constant pool is a per-class or per-interface runtime representation of the constant_pool table in a class file. It contains several kinds of constants, ranging from numeric literals known at compile time, to method and field references that must be resolved at run time. Each runtime constant pool is allocated from the JVM's method area. The runtime constant pool for a class or interface is constructed when the class or interface is created by the JVM.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 8A","FIG. 1"],"b":["820","815","815","815"]},"If the application byte code matches rules (directives)  at a decision block , the transformer  adds probes in the form of tracer byte code. If the application byte code does not matches the rules  at the decision block , the transformer  does not add instrumentation to the byte code. The transformer  and the decision block  may be considered to be part of a probe builder .","In this implementation, the rules  are a set of typically static rules that identify portions of the managed application which are to be instrumented. The rules are usually implemented when a class is defined in a virtual machine for the first time. A class can be loaded multiple times while being defined only once. For example, there can be multiple class loaders loading the same class. Further, components such as classes may be instrumented based on whether they are named a certain way, whether they implement a certain interface, whether they extend a certain subclass or super class, and so forth. Such components are selected to be instrumented because it is believed they might provide performance data which is useful or otherwise interesting.","For instance, a rule may indicate that all servlets should be instrumented since it is believed that at least some of the servlets may provide interesting data. In this case, the rules  may indicate that all components that are subclasses of the JAVA class HttpServlet should be instrumented. HttpServlet is an abstract class from which all servlets depend. However, not all components can be instrumented, and there is a tension in that over-inclusive instrumentation results in excessive overhead costs and possibly impairing the operation of the application, while under-inclusive instrumentation results in the omission of important performance data.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 8B"},"Moreover, the CLR is an implementation of a Common Language Infrastructure (CLI) which provides a language-neutral platform for application development and execution, including functions for exception handling, garbage collection, security, and interoperability. The CLI includes the core class libraries, Common Type System, and the Common Intermediate Language (CIL). As with JAVA byte code, CIL is another example of intermediate byte code. JAVA and .NET provide example implementations only, as other implementations are possible.","Here, the process may be implemented by an agent, in one possible approach. In one possible scenario, some process in the .NET framework references a class by name, and the CLR  finds the class, shows it to a transformer  (if any) and uses the resultant CIL. In particular, if the class matches rules  at a decision block , instrumentation is added. If the class does not match the rules  at the decision block , instrumentation is not added. The transformer  and the decision block  may be considered to be part of a probe builder .",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 9","FIG. 5","FIG. 6"],"b":["900","904","904","906","904","906","904","906"]},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 10"},"For byte code running in a JVM, there is the concept of dynamic linking of the code to classes which are loaded by class loaders. The code needs to have access to the class loader that loaded a class to have this link. However, in some cases we do not have access to the class of an object of an application and therefore cannot perform the dynamic linking and casting of the object. This can happen in different situations. For, an object may be received at a computing system on a communication path as an unknown stream of bytes. This can happen in the case of an agent, for instance, when we have a byte code modification and the agent intercepts the method of the user that has this object. The agent knows that it is an object but does not have access to the class of the object. The object itself knows its class. The agent can essentially ask the object, \u201cWhat is your class?,\u201d using the Reflection API, and the object can report its class to the agent. However, as mentioned, this process is slow. In the case of a managed application, it is important to minimize the processing overhead of the instrumentation.","The problem is that the agent does not have access to the class loader mechanism of the class of the object. Thus, we have a piece of JAVA code which is an object, and we can always have a reference to an object inside a JVM. In order to do casting and dynamic linking of the object, the agent needs to have access to the class of that object through the class loader mechanism of the object. If the object does not have this access, the object cannot invoke a method in that object because the JVM will not allow it.","The agent does not normally have this access due to the location of the agent. The left-hand part of  shows an example class loader hierarchy of class loaders which set up for an application server. Specifically, the Bootstrap ClassLoader  is the parent of all classloaders and loads the standard JAVA Development Kit (JDK) classes in the library directory of JRE. All the java.* classes are loaded by this ClassLoader. The Bootstrap ClassLoader loads the System ClassLoader , which in turn loads code found on java.class.path. By default, all user classes are loaded by the default System ClassLoader. The System ClassLoaderloads the Common ClassLoader , which is common to multiple application ClassLoaders such as WebApp ClassLoader  and WebApp ClassLoader . Using the Common ClassLoader makes an application or module accessible to all applications or modules deployed on servers that share the same configuration. Each application ClassLoader can define one or more classes which in turn can each define one or more objects. As discussed in connection with , the method defineClass converts an array of bytes into an instance of class Class. For example, WebApp ClassLoader defines and loads WebApp class , and WebApp class creates WebApp Object , a specific object which is cast on the application.","When a class is loaded by the application ClassLoader, the application ClassLoader can also add instrumentation to the class. Instrumentation may be added statically through the Probe Builder or dynamically through an \u201cAutoTransformer.\u201d The dynamic approach uses the Java API \u201cjava.lang.Instrument\u201d or Java Dynamic Instrumentation. In both cases, the agent object itself is not controlling the instrumentation process. The agent code only calls the JAVA instrumentation API in the dynamic case to activate the (auto)transformer. In the static case, the agent code does not directly interact with the probe builder, in one approach. The instrumentation added to the WebApp class says: \u201ccall one method in the agent class.\u201d The agent is activated the first time by a method call from the code that is instrumented.","The applications are web-based as an example, but this is not required. From the perspective of the provider of the agent as part of application management software, a managed application is sometimes referred to as a customer application.","An agent class  is defined by the Bootstrap ClassLoader  using the method defineClass. The agent class in turn defines an agent object . There may be only one agent object in the JVM, in one approach. The agent object and class sit on the Bootstrap ClassLoader and are therefore visible to all other objects in the JVM. Instrumented application objects can therefore call the agent to say \u201cstart trace\u201d and \u201cend trace,\u201d for instance.","If an object is of any type, and from any class that is loaded by a class loader other than the Bootstrap ClassLoader, the agent is not able to cast the object because the agent does not see those class loaders. For example, the agent does not see the WebApp ClassLoader so it cannot cast the object . The agent cannot see the class loaders below the Bootstrap ClassLoader because the agent is loaded by the Bootstrap ClassLoader.","Let's say the agent wants to cast to a class called XYZ. The agent will look for the class in any accessible location. It will look at the hierarchy of classes, and all the parents for the class XYZ to see if it can link the class. But the agent only has Bootstrap ClassLoader as a parent. So, if the object is of a class which is under the Bootstrap ClassLoader, the agent cannot access it. The Reflection API is a mechanism to circumvent this problem. Using it, the agent asks the object: What is your class? and the object responds: XYZ. So, the agent calls the class object and asks the class object to call the method object and asks the method object to invoke to get an object value.","A better approach uses a combination of instrumentation and classloader APIs to allow the agent to safely and directly invoke methods on the application objects or on objects passed by reference by the application. In this approach, application objects are instrumented to invoke a method in an agent shim  using a static call. A shim can be a small library which transparently intercepts an API, changes the parameters passed, handles the operation itself, or redirects the operation elsewhere. The instrumentation of the application object allows the agent code to have a reference to the invocation object as well as all objects that are parameters to the method calling the agent. The agent identifies if invocation of methods on any of these objects is required. The decision of when it is necessary to invoke methods of the application object can be delegated to specific tracer business logic. For example, it may be necessary to access an API in the object to retrieve an identifier for tracing. The business logic can be either hard coded or based on rules. The agent can determine that the object traced is actually one to invoke the method in a variety of ways, including trial and error, or based on the specific position of a given tracer in the code of the user by examining the class that instanced the object.","If the agent desires to invoke a method of the application, it attempts to fetch a specific helper object from a map repository , e.g., at least one file such as a JAR file. The keys of the maps are classloaders; the element, helper objects. The classloader passed as a key in the fetch request is the classloader (e.g., WebApp ClassLoader, ) of the class of the application of the object that the agent wants to invoke one or more methods on. If the helper object has previously been created, byte code of both the helper object and the helper class are present in the repository  and can be retrieved. If the helper object is not found, a new one is created. To create a helper object, the agent code creates an agent plugin ClassLoader  and uses it to define a helper class . This happens once for an application, after which the byte code is cached and can be subsequently accessed.","The agent identifies the class that will create a helper instance object, and gets byte code  of this class as an array of bytes from a JAR file in the repository . The agent code (agent class ) creates a new instance of a special classloader, Helper ClassLoader . This happens for each different ClassLoader of the monitored application on which the agent may need to invoke a method. The Helper ClassLoader  overrides the findClass method of java.lang.ClassLoader so that it will use the cached array of bytes to define a class if it is requested to do so for the helper class. The new Helper ClassLoader  is created with the ClassLoader  of the application set as its parent. The agent code identifies the ClassLoader  of the application based on a reference to an object of the application which is received from instrumentation of the application.","The Helper ClassLoader is then requested to load the Helper class  (using Class.forName(\u201chelperClass\u201d, true, HelperClassLoader) API. This forces the Helper ClassLoader to define the Helper class  using the byte array. A new instance of the helper object  is created, using the Reflection API to create the helper object  from the class  retrieved with the previous method. The helper object  is put in the map repository , along with the helper class , with the application ClassLoader  as the key. That is, the helper class and helper object are indexed to the application ClassLoader.","If the agent object needs to invoke multiple different methods on one application object, such as WebApp , one helper object can be used. Different methods in the same class are defined using the same classloader, and can therefore be invoked using the same helper object. Generally, one helper object can be used to invoke methods on different objects in different classes defined under the same ClassLoader (such as WebApp ClassLoader). A second helper object would be used to invoke methods on different objects in different classes defined under another ClassLoader (e.g., WebApp ClassLoader).","The approach allow the helper object  to safely cast the objects\/methods of the application. The helper, in fact, is using a classloader  that has as parent the classloader  of the customer application: every class that the helper is requesting from its Helper ClassLoader  is coming from the classloader  of the application code.","In summary, we have an agent class loaded by the Bootstrap ClassLoader, where the agent class has a reference to an agent plug-in class loader which can define a helper class from an agent plug-in JAR file. We can always create a class using a JAR file to load the class in memory using a plug-in class loader. This infrastructure allows us to get access to the byte code of the helper class. The byte code of the helper class is contained in the JAR file as a set of bytes and can be extracted from the JAR file by the Helper ClassLoader. Moreover, there is an application object (WebAppobject) that was created by class (WebApp class) that was loaded by a class loader (WebApp ClassLoader). A reference or handle to this application is held by the agent object  due to byte code instrumentation of the application object. That is, the application object is accessible to the agent object through the instrumentation. The object on the agent can do some work with data that is received via the instrumentation.","In order to cast the application object, the agent creates a new plug-in class loader which has access to the helper class byte code because the helper class loader is created by the agent object. The agent has access to the byte code through the JAR file. The helper class loader is set up to have the same parent as the parent of the application object to which the agent object has a handle. Because the agent object has a handle to the application object, it has a handle to the class of the application object. Because the agent object has a handle to the class of the application object, it knows the class loader of the class of the application object. Because it knows the class loader, it knows the parent of the class loader of the class of the object. The agent has a handle to the application object which has been passed to the agent object through instrumentation. Because it has a handle to the object, it can call a method of the application object.","The agent can perform a command such as \u201cclass dot get class loader\u201d to obtain a handle to the class loader. The class loader can use a \u201cget parent\u201d command that will provide the parent class loader.","The agent can thus ask the helper class loader to create a helper class and create a helper object out of that helper class. We can create the helper class because we have the byte code. The JVM is passed byte code to create classes in JAVA. If we have a class that is compiled in byte code we can pass the byte code in to create a class. The helper class is a bona fide class which can create the helper object. This helper object is important because the agent can see it. The agent has a handle to the helper class loader which has a handle to the helper class which has a handle to the helper object. The agent thus knows all about the helper object and can make a direct call to it. Because of the parent relationship of the application class loader  to the helper class loader , the agent object can see all of these classes loaded by the application class loader  and call a method on the application objects of thee classes using a command such as \u201cdo C of O dot do.\u201d The agent can thus do a casting of the application objects.","The agent can say \u201ccast O to class C\u201d and then invoke the method \u201cdo.\u201d This is fast because it is strong typed. We create an object from a class in a class loader, that has as a parent the class loader that loaded the object that it wants to cast. Studies indicate that the time required to invoke an API\/method of the application can be cut by more than about a third with this approach.","As mentioned, the invocations of the application methods by the helper object  use the faster and more efficient strong-type casting rather than weak-type Reflection API. As an example for weak and strong-typed method calls in JAVA, consider a class C such as:",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"public class C{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void doSomething( ){ }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"One example of strong-type method call is:"},{"entry":"public void startTrace(Object o){"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"C objectOfTypeC = (C)c; \/\/ this is casting"]},{"entry":[{},"c.doSomething( ); \/\/ this is a strong-typed invocation }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Another example of direct casting is: ((HttpServletRequest)object)."},{"entry":"getRequestURI ( )."},{"entry":"One example of soft-typed invocation (through the Reflection API) is:"},{"entry":"public void startTrace(Object o){"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class classc = o.getClass( );"]},{"entry":[{},"Method methodDoSomething = classc.getMethod(\u2033doSomething\u2033);"]},{"entry":[{},"methodDoSomething.invoke( ); \/\/ this is a weak-typed invocation }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u201cMethod\u201d is one of the Reflection classes, which are found in the package"},{"entry":"\u201cjava.lang.reflect,\u201d which provides classes and interfaces for obtaining"},{"entry":"reflective information about classes and objects."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"To perform casting, we need to be able to access class C from the object doing the invocation. But the agent object is not in general able to do so, because, as discussed, it is defined from the Bootstrap ClassLoader and therefore does not see all the classes that the application classloader () sees. The agent object is required to be defined from the Bootstrap ClassLoader so that the methods of the applications that are bytecode instrumented can see the agent.","Example code of the helper object  is as follows:",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class Helper{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void invokeOnC(Object o){"]},{"entry":[{},"\u2003C c = (C)o;"]},{"entry":[{},"\u2003c.doSomething( ); \/\/ this is strong-typed, therefore fast. The helper"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"can see the class C because of the way it is created."},{"entry":"}"},{"entry":"Example code of the agent can be:"},{"entry":"public void startTrace(Object o){"},{"entry":"\u2003Object helper = getHelper(o.getClass( ).getClassLoader( ));"},{"entry":"\u2003(Helper)helper.invokeOnC(o); \/\/ this is fast."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"A more specific implementation of the helper includes a ByteCode ClassLoader () and a ClassLoaderHelper ().",{"@attributes":{"id":"p-0107","num":"0106"},"figref":["FIG. 11A","FIG. 10","FIG. 10"]},"At step , the Bootstrap ClassLoader  loads the System ClassLoader . At step , the System ClassLoader  loads the Common ClassLoader . At step , the Common ClassLoader  loads Application ClassLoaders such as WebApp ClassLoader  and WebApp ClassLoader . At step , the Application ClassLoaders such as WebApp ClassLoader load one or more classes of the application, such as WebApp class . At step , an Application class such as WebApp class  creates an object of the application such as WebApp object . At step , an object of the application such as WebApp object passes a reference to itself to an object of the agent, such as agent object  via agent shim . In a separate path, at step , the Bootstrap ClassLoader loads a class  of the agent. At step , the agent class creates an object  of the agent. The agent does not have a direct class loader connection with the application object because the agent class and the application class ultimately rely on the same Bootstrap ClassLoader for their creation.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":["FIG. 11B","FIG. 10","FIG. 10","FIG. 11A"],"b":["1120","1018","1122","1020","1124","1022","1126","1018","1","1008","1110"]},"At step , the agent plug-in ClassLoader stores the byte code of the helper class in at least one file (such as in repository ), indexed to the ClassLoader  of the object of the application which the helper class will use to assist in invoking. At step , the agent class  creates a helper ClassLoader , and sets its parent ClassLoader as the ClassLoader (such as WebApp ClassLoader ) of the object of the application. At step , the helper ClassLoader  uses the byte code  of the helper class to define the helper class . At step , the helper class defines a helper object . Step  stores byte code of the helper object with the byte code of the helper class in at least one file, so that both are cross-referenced to the ClassLoader of the application (e.g., WebApp ClassLoader). At step , the helper object invokes a method of the object of the application (such as WebApp object ) using the common parent ClassLoader such as WebApp ClassLoader .",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 11C","FIG. 10","FIG. 10","FIG. 11A"],"b":["1150","1018","1012","1152","1018","1","1008","1110","1154","1014","1030","1","1008","1156","1026","1","1008","1158","1","1012","1","1008"]},"The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 7","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 11A","FIG. 10"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 11B","FIG. 10"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 11C","FIG. 10"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 12A-12C"}]},"DETDESC":[{},{}]}
