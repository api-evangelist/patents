---
title: Apparatus and method for thread scheduling and lock acquisition order control based on deterministic progress index
abstract: Provided is a method and apparatus for ensuring a deterministic execution characteristic of an application program to perform data processing and execute particular functions in a computing environment using a micro architecture. A lock controlling apparatus based on a deterministic progress index (DPI) may include a loading unit to load a DPI of a first core and a DPI of a second core among DPIs of a plurality of cores at a lock acquisition point in time of each thread, a comparison unit to compare the DPI of the first core and the DPI of the second core, and a controller to assign a lock to a thread of the first core when the DPI of the first core is less than the DPI of the second core and when the second core corresponds to a last core to be compared among the plurality of cores.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047138&OS=09047138&RS=09047138
owner: Samsung Electronics Co., Ltd.
number: 09047138
owner_city: Suwon-si
owner_country: KR
publication_date: 20110503
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the priority benefit of Korean Patent Application No. 10-2010-0070964, filed on Jul. 22, 2010, in the Korean Intellectual Property Office, the disclosure of which is incorporated herein by reference.","1. Field","Example embodiments relate to a method and apparatus for ensuring a deterministic execution characteristic of an application program to perform data processing and execute predetermined functions in a computing environment using a micro architecture.","2. Description of the Related Art","As distribution of portable devices and an amount of information processing increases, computing devices become complex and a variety of applications are simultaneously performed. In addition, due to an increase in applications such as a multimedia application using real-time processing, an interest in a system performance of the computing devices has been increasing. However, a variety of applications may not be effectively processed using a single processor alone.","To overcome the above circumstance, integrated semiconductor technology has been developed and multi-processor computing technology has been introduced. Compared to a single processor, a multi-processor may have relatively high energy efficiency and show significant performance improvement. However, the design and development of a system using the multi-processor may not be readily performed. In addition, verification of a parallel system may be difficult. A verification cost of the system having a parallel system may increase in proportion to a square of a number of cores with respect to a development period of an existing sequential system. A variety of schemes have been proposed to reduce the verification cost. A basic purpose for effectively configuring the variety of schemes is to accurately measure the performance and progress state of the application program executing the variety of instructions. Also, while a thread execution order is maintained to be constant at all times, a waiting time for execution of a priority thread may need to be minimized.","The foregoing and\/or other aspects are achieved by providing a lock controlling apparatus, based on a deterministic progress index (DPI), the apparatus including: a loading unit to load a DPI of a first core and a DPI of a second core among DPIs of a plurality of cores at a lock acquisition point in time of each thread, the first core for reference and the second core corresponding to a neighbor core; a comparison unit to compare the DPI of the first core and the DPI of the second core; and a controller to assign a lock to a thread of the first core when the DPI of the first core is less than the DPI of the second core and when the second core corresponds to a last core to be compared among the plurality of cores.","When the DPI of the first core has the same value as the DPI of the second core, and when an identification (ID) of the first core has a value less than an ID of the second core, the controller may assign the lock to the thread of the first core.","When the second core is not the last core to be compared among the plurality of cores, the loading unit may load a DPI of a third core among the plurality of cores.","The apparatus may further include: a core DPI generator to generate a core DPI by accumulating thread DPIs of a predetermined thread group executed in the same core; and a memory unit to store the generated core DPI.","The predetermined thread group may correspond to a group of threads attempting a lock acquisition to access the same shared resource.","The apparatus may further include a core DPI correction unit to correct the DPI of the first core by a measurement value of a non-deterministic section through actual application execution.","The foregoing and\/or other aspects are achieved by providing a thread scheduling apparatus based on a deterministic progress index (DPI), the apparatus including: a measurement unit to measure a DPI of a thread executed with respect to a predetermined input; a database to store a DPI of each thread at a lock acquisition point in time based on the measured DPI of the thread; and a controller to schedule a thread execution order in an ascending order of a thread DPI at a next lock acquisition point in time from a corresponding lock acquisition point in time, based on the stored DPI of each thread.","The controller may schedule the thread execution order in an ascending order of an increased value in the thread DPI at the next lock acquisition from the corresponding lock acquisition point in time.","The foregoing and\/or other aspects are achieved by providing a lock controlling method based on a deterministic progress index (DPI), the method including: loading a DPI of a first core and a DPI of a second core among DPIs of a plurality of cores at a lock acquisition point in time of each thread, the first core for reference and the second core corresponding to a neighbor core; comparing the DPI of the first core and the DPI of the second core; and assigning a lock to a thread of the first core when the DPI of the first core is less than the DPI of the second core and when the second core corresponds to a last core to be compared among the plurality of cores.","The assigning may include assigning the lock to the thread of the first core when the DPI of the first core has the same value as the DPI of the second core, and when an identification (ID) of the first core has a value less than an ID of the second core.","The assigning may include loading a DPI of a third core among the plurality of cores when the second core is not the last core to be compared among the plurality of cores.","The method may further include: generating a core DPI using a DPI of a previous thread as a DPI start point in time of a next thread when a context switch event occurs in the same core; and storing the generated core DPI.","The method may further include correcting the DPI of the first core by a measurement value of a non-deterministic section through actual application execution.","The method may further include measuring a minimum value and a maximum value of the non-deterministic section. The correcting may include correcting the DPI of the first core by a deterministic measurement value based on the measured minimum value and the maximum value.","The foregoing and\/or other aspects are achieved by providing a thread scheduling method based on a deterministic progress index (DPI), the method including: measuring a DPI of a thread executed with respect to a predetermined input; storing a DPI of each thread at a lock acquisition point in time based on the measured DPI of the thread; and scheduling a thread execution order in an ascending order of a thread DPI at a next lock acquisition point in time from a corresponding lock acquisition point in time, based on the stored DPI of each thread.","The scheduling may include scheduling the thread execution order in an ascending order of an increased value in the thread DPI at the next lock acquisition from the corresponding lock acquisition point in time.","The example embodiments may include a lock controlling method based on a DPI that may be configured with relatively small costs using a hardware function provided in a general micro architecture.","The example embodiments may also include a lock controlling apparatus based on a DPI that may effectively control a thread lock order using a DPI based on a core unit.","The example embodiments may also include a lock controlling apparatus based on a DPI that may provide, using significantly small runtime overhead, a deterministic execution environment of programs to be processed in parallel in a multi-core processor.","The example embodiments may also include a lock controlling apparatus based on a DPI that may minimize a priority thread waiting overhead by correcting DPIs of multiple cores.","The example embodiments may also include a thread scheduling apparatus based on a DPI that may provide deterministic thread scheduling suitable for an execution characteristic of an application program.","Additional aspects of embodiments will be set forth in part in the description which follows and, in part, will be apparent from the description, or may be learned by practice of the disclosure.","Reference will now be made in detail to embodiments, examples of which are illustrated in the accompanying drawings, wherein like reference numerals refer to the like elements throughout. Embodiments are described below to explain the present disclosure by referring to the figures.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 1"},"The general application program may perform a predetermined function by employing, as resources, a memory and a hardware device in a processor. In general, the memory has a hierarchical structure. In this instance, when an access speed of the memory is to be relatively fast, contents of the memory may be provided to a local bus. When the access speed of the memory is relatively slow, and is to be relatively inexpensive, the memory may be provided to a system bus. To satisfy a high performance requirement, a multi-processor may perform parallel processing of the application program by integrating processors in a single system.","The general application program may include at least one thread. Accordingly, multiple threads may be executed in a single processor. The processor may be used for the same meaning as a core. Multiple threads being executed in the single processor or core is referred to as multi-threading. Accordingly, to measure a performance and a progress state of the application program, a performance and a progress state of the at least one thread constituting the application program may be measured. A method of measuring a thread performance and progress state may include a method of using a deterministic progress index (DPI). A thread may include instructions to execute a particular function. An instruction execution scheme may be classified into a deterministic execution scheme and a non-deterministic execution scheme. When the instruction execution scheme corresponds to the deterministic execution scheme, times when an execution of a corresponding instruction are completed or times when an execution of an instruction group are completed may have a regular cycle. When the instruction execution scheme corresponds to the non-deterministic execution scheme, times when the execution of the instruction are completed or the times when the execution of the instruction group is completed may have an irregular cycle.","The DPI corresponds to a value indicating only a deterministic execution section excluding a non-deterministic section in a thread execution, and may be generated using a deterministic progress counter (DPC). A DPI of a thread may be used as an index for measuring a progress state of the thread. The non-deterministic execution section and the deterministic execution section may be distinguished from each other based on a predetermined criterion. The DPI of the thread may be stored in a DPI exclusive memory or a general memory.  illustrates an example of a generally configurable computing environment. An application environment of a DPI-based lock order controlling and thread scheduling apparatus according to example embodiments is not limited to the example of .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 2"},"In the case of the general parallel execution, a lock acquisition may be determined based on a time order with respect to a lock acquisition attempt. In the parallel execution according to the deterministic scheme, a lock acquisition may be determined based on a predetermined criterion regardless of the above order. The parallel execution using the deterministic scheme may be expressed by a deterministic execution scheme. The deterministic execution scheme ensures a thread execution order and thus, the same output for the same input may be ensured. The deterministic execution scheme may effectively solve a simultaneity issue occurring as a result of the parallel execution in multiple cores.","However, the deterministic execution scheme may deteriorate a performance by artificially controlling a thread execution. For example, in the case of the general parallel execution, a thread initially executed based on a time order may be executed according to a priority. However, in the case of the deterministic execution scheme, the thread may be executed based on a predetermined order or criterion. Accordingly, for a thread to be executed before a prior ingress thread to acquire a lock based on a time, an execution is to be suspended and paused. In addition, the deterministic execution scheme may use a memory access to control an execution order and may generate overhead by using an additional computer resource to determine the execution order.","The deterministic execution scheme may be classified into a strong deterministic execution scheme for ensuring a deterministic order with respect to all the memory accesses of parallel programs and a weak deterministic execution scheme for ensuring the deterministic order only with respect to a shared memory access. The strong deterministic execution scheme may use a separate hardware module to ensure an order with respect to all the memory accesses. When the hardware module is not supported, a performance may be significantly deteriorated. The weak deterministic execution scheme may use a hardware function provided in a general micro architecture to ensure a lock acquisition order with respect to the shared memory. Accordingly, the weak deterministic execution scheme may not use a complex hardware module and may ensure an acquisition order with respect to all the locks occurring while executing an application in a software manner using a DPI.","Referring to , the general parallel execution may use a lock acquisition based on a time order. In this instance, the time order may include chronological order. Thread , thread , and thread  are executed in different cores. Since an execution time of the thread  is shortest, the thread  may initially make a lock acquisition request. A lock acquisition request of each thread, such as an exclusive read and write, may be performed using a memory. Each thread may acquire a corresponding lock to prevent another thread from accessing the shared memory. For example, it is possible to atomically prevent an access of the other thread to the shared memory through the lock acquisition. When the thread  initially requests the lock acquisition, accesses of the thread  and the thread  with respect to the shared memory may be blocked even though the execution time has ended. The thread  may request a lock acquisition after the thread  acquires the lock and a critical section protected by lock is terminated. After the thread  acquires the lock, the thread  may acquire a lock. That is, the general parallel execution may make the lock acquisition request in an ascending order of a physical execution time. In the general parallel execution, a thread execution state may not be predicted and an order where a corresponding thread reaches a lock acquisition point in time may not be predicted.","When a lock acquisition order of each thread is known, it is possible to reduce costs for verifying a stable execution of a developed application program. When the lock acquisition order of each thread accessing the shared memory is determined based on a predetermined criterion according to the weak deterministic execution scheme, the verification costs may be reduced. Referring to , the lock acquisition request is made based on the predetermined criterion, that is, the weak deterministic execution scheme. Since the lock acquisition order is determined in an order of the thread , the thread , and the thread , the thread  may most initially request a lock acquisition even though the thread  has a longest execution time. Since the lock acquisition order is determined based on the predetermined criterion, a deterministic execution order may be known. The predetermined criterion may be DPIs of threads. When DPIs of threads are the same, the predetermined criterion may be order of a thread ID.","When the lock acquisition order is ensured for deterministic execution, a lower priority thread may reach a lock acquisition point in time prior to a priority thread. In this example, the lower priority thread may wait until the priority thread acquires a lock. That is, compared to the lock acquisition request based on the chronological order, the total execution time may be delayed by an amount of time T\u2212T. T\u2212Tcorresponds to a performance delay time occurring due to waiting of lower priority threads during an actual deterministic execution.","The weak deterministic execution scheme may use a DPI of each thread as a criterion for determining the lock acquisition order of each thread. When the lock acquisition order is desired to be determined in an ascending order of a thread DPI, DPIs of all the threads may need to be read from a memory. The performance delay time may be determined based on a number of threads of which orders are to be determined and an access speed to a memory. DPIs may need to be stored in a shared memory space accessible from all the cores. In general, since the shared memory exists in a secondary memory in multiple cores, the access speed may be slow. Accordingly, during a process of comparing a relatively large number of thread DPIs, the performance may be significantly deteriorated. In the case of an application program corresponding to frequent lock attempts, the performance may be further deteriorated. A most significant performance deterioration may occur during waiting overhead that waits for a priority thread. Based on experiments, due to the waiting overhead, an average of at least 16% deterioration in performance and a maximum of at least 70% deterioration in performance may occur, depending on a characteristic of an application program.","Accordingly, there is a desire for a method of reducing a waiting time of a priority thread while using a weak deterministic execution scheme to verify a stability of an application program in multiple cores. A deterministic execution scheme described below corresponds to the weak deterministic execution scheme.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 3A","FIG. 3B"]},"When controlling a lock acquisition order of a thread using a deterministic execution scheme, waiting overhead and lock acquisition thread selection overhead may occur. In this example, the overhead may differently occur based on a lock acquisition pattern of each thread. The lock acquisition pattern may be classified into a BLA pattern and an IBLA pattern.","The BLA pattern corresponds to a case where the same lock acquisition pattern is performed in parallel in multiple cores, and includes a case where the same instruction and the same input point in time is used. For example, threads executed in the multiple cores may perform the same work and request a lock acquisition at the same point. When the lock acquisition pattern of the threads corresponds to the BLA pattern, the threads may request the lock acquisition at the nearly same point in time and thus, the performance deterioration by the waiting overhead may be relatively small. The lock acquisition thread selection overhead occurring while determining a lock acquisition order may be relatively great. Accordingly, in the case of the BLA pattern, a significant performance difference may occur depending on a method of determining the lock acquisition order.","The IBLA pattern corresponds to a case where different lock acquisition patterns are performed in parallel in multiple cores, and includes a case where instructions of threads and input points in times are different. The IBLA pattern may ensure deterministic execution between application programs having different lock acquisition patterns with different instructions. In general, lock acquisition points in times of threads are different and thus, waiting overhead that waits for a thread having a prior DPI may relatively increase.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 3A","FIG. 3A"],"b":["1","2","1","2"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 3B","FIG. 3B"],"b":["1","2","2","1","2"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 4A","FIG. 4B"]},"A size of each thread DPI may be known using a length of an arrow indicator based on T. Tindicates a DPI concept of indexing a logical time.","Referring to , since thread () through thread () have the same DPI size and the same lock acquisition point in time, a lock acquisition pattern may correspond to a BLA pattern. In core , the thread () and the thread () are executed. In core , the thread () and the thread () are executed. When a DPI of a corresponding thread is smallest at a lock acquisition point in time, or when DPIs of threads are the same, a lock acquisition order may be determined based on an ascending order of a thread ID. In the core , physical time Twhere the thread () is actually executed uses a deterministic execution section and a non-deterministic execution section. Accordingly, compared to a DPI using only the deterministic execution section, a relatively long time may be used. When the execution of the thread () is terminated, a DPI of the thread () becomes 0 and thus, the thread () may be executed. Initial execution of the thread () may be determined by thread scheduling. Even though the thread () attempts to acquire a lock, the thread () yields the execution to the thread () since the DPI of the thread () is relatively small. When the execution of the thread () is terminated, the thread () and the thread () may request a lock acquisition and a critical section may be protected by the acquired lock. The critical section corresponds to a section where accesses of the thread () and the thread () in the core  with respect to a shared memory are blocked.","In the core , the thread () and the thread () may be executed using the same scheme as used in the core . Since the thread () and the thread () have a relatively great thread ID, the thread () and the thread () may have a lower priority order compared to the lock acquisition order of the thread () and the thread (). Since the lock acquisition pattern corresponds to the BLA pattern, a method of determining the lock acquisition order of the thread () and the thread () may significantly affect the performance.","Referring to , since thread () through thread () have different DPI sizes and different lock acquisition points in times, a lock acquisition pattern may correspond to the IBLA pattern. When a DPI of a corresponding thread is smallest at a lock acquisition point in time, or when DPIs of threads are the same, a lock acquisition order may be determined based on an ascending order of a thread ID. Among the thread () through the thread (), a DPI sizes follow thread () >thread () >thread () =thread () . The DPI size of the thread () is the same as the DPI size of the thread () as \u201c20\u201d. However, since a thread ID of the thread () is smaller than the thread (), the thread () may request a lock acquisition prior to the thread (). In core , even though the thread () requests a lock acquisition after the execution of the thread () is terminated, the thread () yields the execution to the thread () since the DPI of the thread () is 0. After the execution of the thread () is terminated, the thread () may need to request the lock acquisition. However, at the point in time when the execution of the thread () is terminated, the DPI of the thread () is smaller than the DPI of the thread (). The lock acquisition request of the thread () may wait until the execution of the thread () is terminated. Accordingly, a waiting time  may occur.","When the execution of the thread () is terminated, the thread () may request the lock acquisition and a critical section  may be protected by the acquired lock. That the protection of the critical section is terminated is referred to as \u201cunlock\u201d. When the thread () is unlocked, the thread () may request a lock acquisition and a critical section  may be protected. When the thread () is unlocked, the thread () may be executed. The DPI of the thread () after the execution of the thread () is terminated is less than the DPI of the thread () and thus, the execution of the thread () may be terminated. The thread () may request a lock acquisition and a critical section  may be protected, and a waiting time  may occur until the thread () is unlocked. After the thread () is unlocked, the thread () may request a lock acquisition and a critical section  may be protected. In a second cycle, the thread () through the thread () have a DPI sizes of thread ()>thread () >thread () >thread () . Accordingly, the lock acquisition order may be determined in an order of the thread () , the thread () , the thread () , and the thread (). Since the lock acquisition pattern corresponds to the IBLA pattern, a method of adjusting the waiting overhead may affect the performance.","In the IBLA pattern, since a cycle of a non-deterministic execution section included in a thread is different, a difference may occur between an amount of time Tand a DPI value using only the deterministic section. The difference indicates a non-deterministic execution section and thus, may be expressed by T=T\u2212T. In the IBLA pattern, a thread execution time and a non-deterministic execution section included in a corresponding thread are different between threads and thus, a waiting time of a lower priority thread may occur. The waiting time may be expressed by T=T\u2212T.","Accordingly, a method of quickly determining the lock acquisition order may be used in the BLA pattern and a method of minimizing waiting overhead may be used in the IBLA pattern.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5"},"Referring to , the lock controlling apparatus based on the DPI may include a core DPI generator , a memory unit , a loading unit , a comparison unit , a controller , and a core DPI correction unit .","The core DPI generator  may generate a core DPI by accumulating thread DPIs of a predetermined thread group executed in the same core. In the case of a method of determining a lock acquisition order of each thread executed in multiple cores by comparing thread DPIs, lock acquisition selection overhead may increase in proportion to an increase in a number of threads to be compared. The core DPI generator  may generate a DPI for each core instead of generating a DPI for each thread. The predetermined thread group indicates a group of threads attempting a lock acquisition for accessing the same shared resource. Here, the shared resource may include a shared memory accessible by multiple cores. The predetermined thread group may include a group of threads attempting a lock acquisition for accessing a predetermined area of the shared memory and a group of threads having DPIs to be compared when determining the lock acquisition order.","The core DPI generator  may generate the core DPI using DPIs of the predetermined thread group of threads executed in a core. When a context switch event of a thread occurs, the core DPI generator  may generate a DPI based on a core unit by using a thread DPI before the event occurrence as a start point in time of a thread DPI after the event occurrence. The generated thread DPI and core DPI may be counted by a DPC.","The memory unit  may store the generated core DPI in a memory. The memory  may store the generated core DPI which is the same as when the thread DPI may be stored in a DPI memory for each thread. The memory unit  may include a shared memory to be accessible by multiple cores.","The loading unit  may load a DPI of a first core and a DPI of a second core among DPIs of a plurality of cores at a lock acquisition point in time of each thread. Here, the first core may correspond to reference core for reference and the second core may correspond to a neighbor core. To determine a lock acquisition order of a thread at a lock acquisition point in time of each thread, the loading unit  may load the DPI of the first core. The loading unit  may load the DPI of the second core that may be compared with the DPI of the first core. Here, the DPI of the second core indicates a DPI of a core that has not been loaded among the plurality of cores.","When the second core is not a last core to be compared among the plurality of cores, the loading unit  may load a DPI of a third core among the plurality of cores. That is, when the second core to be compared with the first core is not a finally loaded core among the plurality of cores, the loading unit  may load the DPI of the third core.","The comparison unit  may compare the DPI of the first core and the DPI of the second core. The comparison unit  may compare the loaded DPI of the first core with the DPI of the second core to determine the lock acquisition order of each thread at the lock acquisition point in time.","When the DPI of the first core is less than the DPI of the second core and when the second core corresponds to the last core to be compared among the plurality of cores, the controller  may assign a lock to a thread of the first core at the lock acquisition point in time of the first core. A criterion of determining the lock acquisition order of each thread may based on a case where a core DPI at the lock acquisition point in time is smallest or where an ID of a core is relatively small when core DPIs are the same. A criterion of determining the lock acquisition order of each thread may be set to be different depending on a type of an application program. That the controller  assigns a lock to a thread has the same meaning as that the thread acquires the lock. However, when the DPI of the first core is less than the DPI of the second core, or when the DPI of the first core is the same as the DPI of the second core, an ID of the first core is less than an ID of the second core, and when the second core is the last core to be compared, the controller  may assign the lock to the thread of the first core. The controller  controlling the lock indicates that the controller  controls the lock acquisition order.","When the DPI of the first core has the same value as the DPI of the second core, and when the ID of the first core has a value less than the ID of the second core, the controller  may assign the lock to the thread of the first core. However, when the DPI of the first core has a value greater than the DPI of the second core, or when the DPI of the first core has the same value as the DPI of the second core, the ID of the first core is greater than the ID of the second core, and the controller  may terminate controlling of the lock acquisition order.","To control the lock acquisition order of each thread, the controller  may compare only core DPIs instead of comparing DPIs of total threads. Since only the core DPIs are compared, a number of accesses to the shared memory may decrease compared to a case where the DPIs of the total threads are compared. Accordingly, the lock acquisition order selection overhead may decrease. In addition, since the controller  determines the lock acquisition order using only core DPIs indicating a progress state of cores, it is possible to avoid the effect from a thread being relatively imbalanced-scheduled due to load imbalance in the IBLA pattern. Accordingly, it is possible to decrease waiting overhead. The controller  may include a processor that may perform functionalities of the loading unit  and the comparison unit .","The following example corresponds to a pseudocode showing an algorithm of the controller  to determine the lock acquisition order. The controller  may control the lock acquisition order by providing an application programming interface (API) like \u201cBoot TakeToken( )\u201d as given by:",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Bool TakeToken(void) {"},{"entry":"\u2003NextCore = NeighborCore;"},{"entry":"\u2003while(NextCore){"},{"entry":"\u2003\u2003if (MyCore\u2212>DPI > NextCore\u2212>DPI){"},{"entry":"\u2003\u2003\u2003return FALSE;"},{"entry":"\u2003\u2003}else if (MyCore\u2212>DPI == NextCore\u2212>DPI && MyCore\u2212>ID > "},{"entry":"NextCore\u2212>ID)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return FALSE;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003NextCore = NextCore\u2212>neighborCore;"},{"entry":"\u2003}"},{"entry":"\u2003return TRUE;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The core DPI correction unit  may correct the DPI of the first core by a measurement value of a non-deterministic section through actual application execution. When the lock acquisition order is controlled using the core DPI, it may be possible to reduce a waiting time. However, a sensor thread waiting time may still occur since a non-deterministic execution section is included in a section where a corresponding thread is substantially executed in a core. The core DPI uses only the deterministic execution section excluding the non-deterministic execution section, whereas the non-deterministic execution section is included in the section where the thread is substantially executed in the core. The core DPI correction unit  may measure a minimum value and a maximum value of the non-deterministic execution section included in the thread that is substantially executed in the core. The measurement of the maximum value and the minimum value may be performed using a separate measurement unit (not shown). The core DPI correction unit  may correct the core DPI using a deterministic value based on the measured maximum value and the minimum value of the non-deterministic section. The deterministic value may indicate a value that converges to a predetermined range by repeatedly measuring the maximum value and the minimum value. As the measured value and an actual non-deterministic execution section value become more similar, T, where T=T\u2212T, becomes smaller, thereby decreasing a waiting time T. The above method of correcting the core DPI using the deterministic value may be referred to as a DPI fast-forward (DFF) method.","The core DPI correction unit  may correct the core DPI by providing an API \u201cDetermSWNDClearWithDFF( )\u201d as given by:",{"@attributes":{"id":"p-0085","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","void DetermSWNDClearWithDFF(uint32 dffValue) {"]},{"entry":[{},{},"\u2003ClearNDFunctionFlag( );"]},{"entry":[{},{},"\u2003MyCore\u2212>DPI += dffValue;"]},{"entry":[{},{},"\u2003ClearDPCEnable( );"]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 6"},"Referring to , thread () and thread () are executed in core , and thread () and thread () are executed in core . Similar to , a lock acquisition pattern of a thread corresponds to an IBLA pattern. Since the core DPI is used in , DPIs of the thread () and the thread () may be used in DPI, and DPIs of the thread () and the thread () may be used in DPI. A lock acquisition order of each thread may be determined based on a case where a DPI of a core is smallest at a lock acquisition point in time, or where an ID of the core is relatively small when DPIs of cores are the same. Accordingly, when comparing DPIs of cores, the lock acquisition order may be determined in an order of thread () , thread () , thread () , thread () , thread () , thread () , thread (), and thread (). Referring to a process of threads being physically executed in actual cores, lock acquisition requests are in an order of thread () , thread () , thread () , thread () , thread () , and thread () , and thereby a critical section may be protected by lock.","Since the core DPI is used, controlling of the lock acquisition order may be deterministically performed. For example, when the core DPI is given, it is possible to predict the lock acquisition order. However, since the non-deterministic execution section is included in a section where a corresponding thread is substantially executed in a corresponding core, waiting times  and  may occur. The core DPI correction unit  may measure the maximum value and the minimum value of the non-deterministic execution section and correct the core DPI using the deterministic value. When the non-deterministic execution section is corrected using the deterministic value, a waiting time may decrease.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 7"},"Referring to , the thread scheduling apparatus may include a measurement unit , a database , and a controller .","The measurement unit  may measure a DPI of a thread executed with respect to a predetermined input. A DPI for each thread may have the same value with respect to the same instruction input since the DPI is a value used to indicate a deterministically executed, that is, a predictable execution period. The measurement unit  may measure a DPI of a thread executed according to an instruction input. The measurement unit  may measure the DPI of the thread at a lock acquisition point in time.","The database  may store a DPI of each thread at the lock acquisition point in time based on the measured DPI. The database  may store a thread DPI used for thread scheduling. The database  may store a thread DPI at the lock acquisition point in time for each thread. The database  may include a duplication unit (not shown) to copy the measured thread DPI.","The controller  may schedule a thread execution order in an ascending order of a thread DPI at a next lock acquisition point in time from a corresponding lock acquisition point in time, based on the stored DPI of each thread. An operation system may manage and schedule threads constituting an application program so that system resources may be effectively used through the threads. The controller  may schedule the thread execution order based on each thread DPI stored in the database . The controller  may schedule a thread in an ascending order of a thread DPI.","The controller  may perform different thread scheduling depending on a type of an application program being executed. For example, when a video application program is parallel executed based on a single thread per channel in multiple cores, balanced load scheduling may be used for each channel. Accordingly, the controller  may perform thread scheduling in an ascending order of a thread DPI at a next lock acquisition point in time.","The controller  may schedule the thread execution order in an ascending order of an increased value in the thread DPI at the next lock acquisition from the corresponding lock acquisition point in time. The controller  may schedule a thread, having a relatively small increased value in the thread DPI, as a priority thread.","The controller  may schedule the thread execution order by providing an API \u201cDoScheduleThredWithDPI( )\u201d as given by:",{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","void DoScheduleThredWithDPI(void) {"]},{"entry":[{},"\u2003\/* find minimum next DPI thead_handle *\/"]},{"entry":[{},"\u2003next_thread_t = DoFindMimiumNextDPI(g_thread_ready_q);"]},{"entry":[{},"\u2003if (current_thread_t == next_thread_t) return;"]},{"entry":[{},"\u2003context_save(current_thread_t);"]},{"entry":[{},"\u2003next_thread_t\u2212>next_lock_counter + = 1;"]},{"entry":[{},"\u2003dispatch_new_thread(next_thread_t);"]},{"entry":[{},"\u2003return;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 8"},"Referring to , thread () through thread () are executed in core . A lock acquisition pattern corresponds to an IBLA pattern. Accordingly, lock acquisition points in time of the thread () through the thread () may be different. When thread scheduling based on the DPI is applied, thread ()  may be most initially executed since the thread ()  has a smallest thread DPI at an initial lock acquisition point in time. When comparing thread DPIs at a next lock acquisition, thread ()  may be executed in a next order. Next, thread () , thread () , and thread ()  may be sequentially executed. Accordingly, the thread execution order may be scheduled in an order of thread () , thread () , thread () , thread () , and thread () . It can be known that threads of the core  are executed in a scheduled order.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIGS. 9A and 9B"},"In operations  and , a lock controlling apparatus based on a DPI may initialize a scheduler and a DPI module by an operating system. The initialization process may be performed to distinguish a new procedure from an existing procedure.","In operation , the lock controlling apparatus may select a thread prepared according to an instruction to be executed on the scheduler. The instruction to be executed may be different for each thread and thus, a corresponding thread may be selected based on a predetermined execution order of the scheduler.","In operation , the lock controlling apparatus may determine whether to use a core DPI. Whether to use the core DPI may be determined through a system setting. The core DPI may be used with respect to all the cases where threads are executed, or may be used only in a section arbitrarily determined by a user.","In operation , when the core DPI is determined to be used, the lock controlling apparatus may copy a previous thread DPI of a predetermined group. For example, the lock controlling apparatus may generate the core DPI using the previous thread DPI of the predetermined group. The predetermined thread group indicates a group of threads attempting a lock acquisition for access to the same shared resource. The lock controlling apparatus may generate a core DPI using a DPI of a previous thread as a DPI start point in time of a next thread when a context switch event occurs in the same core. The lock controlling apparatus may store the generated core DPI.","In operation , the lock controlling apparatus may set the copied previous thread DPI of the predetermined group as an initial value of a DPC. When the core DPI is not used, the selected thread DPI may be set as the initial value of the DPC. For example, the lock controlling apparatus may generate the core DPI by copying a DPI of a thread consecutively executed.","In operation  and  (See ), the lock controlling apparatus may dispatch a thread to be in a running state. The running state indicates a state where a DPI is generated by executing the thread according to a deterministic scheme.","In operations  and , when the scheduling event occurs in the thread that is in the running state, the lock controlling apparatus may suspend the DPC by setting a software non-deterministic execution (SWND) signal. SWND indicates a case where a non-deterministic execution is performed at a level of a randomly occurring event in an aspect of a function including instructions or software. A scheduler event may be, for example, an interrupt, and may include an input\/output waiting, a non-deterministic function call, and the like.","In operation , the lock controlling apparatus may determine whether the context switch event occurs in a state where the DPC is suspended. In operation , when the context switch event occurs, the lock controlling apparatus may store a value of the suspended DPC as a DPI value of a thread before the switch. Also, the lock controlling apparatus may store a context result performed by a point in time when the context switch occurs.","In operation , the lock controlling apparatus may operate the suspended DPC by clearing an SWND signal when the scheduler event is terminated in a state where the DPC is suspended.","The lock controlling apparatus may repeat the above procedure by selecting a thread prepared after the context switch.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 10"},"In operation , a lock controlling apparatus based on the DPI may load a DPI of a first core among DPIs of a plurality of cores at a lock acquisition point in time of each thread. The lock controlling apparatus may correct the DPI of the first core by a measurement value of a non-deterministic section through an actual application execution. The lock controlling method may further include measuring a minimum value and a maximum value of the non-deterministic section. A correction may be performed by a deterministic measurement value based on the measured minimum value and maximum value. The deterministic measurement value may indicate a value that converges to a predetermined range by repeatedly measuring the maximum value and the minimum value.","In operation , the lock controlling apparatus may load a DPI of a second core to be compared with the DPI of the first core.","In operation , the lock controlling apparatus may compare the load DPI of the first core with the DPI of the second core.","In operation , the lock controlling apparatus may determine whether the DPI of the first core has a value greater than the DPI of the second core. When the DPI of the first core has a value greater than the DPI of the second core, a thread of the first core may fail in the lock acquisition in operation . When the DPI of the first core has a value less than or equal to the DPI of the second core, operation  may be performed.","In operation , when the DPI of the first core has the same value as the DPI of the second core, the lock controlling apparatus may determine whether an ID of the first core has a value greater than an ID of the second core. When the ID of the first core has the value greater than the ID of the second core, the thread of the first core may fail in the lock acquisition in operation . When the ID of the first core is less than or equal to the ID of the second core, operation  may be performed.","In operation , the lock controlling apparatus may determine whether the second core to be compared corresponds to a last core. For example, whether the second core to be compared corresponds to a last core corresponds to a case where the DPI of the first core has a value less than the DPI of the second core, or where the DPI of the first core has the same value as the DPI of the second core, however, the ID of the first core is less than the ID of the second core.","In operation , when the second core corresponds to the last core, the lock controlling apparatus may assign a lock to the thread of the first core. Assigning of the lock to the tread has the same meaning as lock acquisition of the thread. Conversely, when the second core does not correspond to the last core, operation  of loading a new third core among a plurality of cores may be performed.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 11"},"In operation , a thread scheduling apparatus may measure a DPI of a thread to be executed with respect to a predetermined input.","In operation , the thread scheduling apparatus may store a DPI of each thread at a lock acquisition point in time based on the measured DPI of the thread. The thread scheduling apparatus may store each thread DPI to be distinguished for each thread.","In operation , the thread scheduling apparatus may schedule a thread execution order in an ascending order of a thread DPI at a next lock acquisition point in time from a corresponding lock acquisition point in time based on the stored DPI of each thread. The thread scheduling apparatus may schedule a thread to be initially executed in a core, as a thread having a smallest thread DPI. The thread scheduling apparatus may schedule the thread execution order in an ascending order of an increased value in the thread DPI at the next lock acquisition from the corresponding lock acquisition point in time.","According to example embodiments, a lock controlling method based on a DPI may reduce lock acquisition order selection overhead affecting a performance in a BLA pattern, based on a core DPI. The lock controlling method may reduce waiting overhead of a prior thread affecting a performance in an IBLA pattern.","According to example embodiments, a thread scheduling method based on a DPI may deterministically schedule a thread execution order even in an IBLA pattern.","The above-described embodiments may be recorded in non-transitory computer-readable media including program instructions to implement various operations embodied by a computer. The media may also include, alone or in combination with the program instructions, data files, data structures, and the like. Examples of non-transitory computer-readable media include magnetic media such as hard disks, floppy disks, and magnetic tape; optical media such as CD ROM disks and DVDs; magneto-optical media such as optical disks; and hardware devices that are specially configured to store and perform program instructions, such as read-only memory (ROM), random access memory (RAM), flash memory, and the like. Examples of program instructions include both machine code, such as produced by a compiler, and files containing higher level code that may be executed by the computer using an interpreter. The described hardware devices may be configured to act as one or more software modules in order to perform the operations of the above-described embodiments, or vice versa.","Although embodiments have been shown and described, it would be appreciated by those skilled in the art that changes may be made in these embodiments without departing from the principles and spirit of the disclosure, the scope of which is defined by the claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and\/or other aspects will become apparent and more readily appreciated from the following description of embodiments, taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 3A","FIG. 3B"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 4A","FIG. 4B"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 9A and 9B"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
