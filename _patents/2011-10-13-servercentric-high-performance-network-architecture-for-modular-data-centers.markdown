---
title: Server-centric high performance network architecture for modular data centers
abstract: Disclosed are systems and methods for network architecture that is a server-centric network architectural design.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09288134&OS=09288134&RS=09288134
owner: Microsoft Technology Licensing, LLC
number: 09288134
owner_city: Redmond
owner_country: US
publication_date: 20111013
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This application is a continuation of U.S. patent application Ser. No. 12\/351,355, filed on Jan. 9, 2009, which is incorporated by reference herein.","Modular data center (MDC), such as shipping-container based systems, offers a new way in which data centers are built and deployed. For example, in an MDC, up to a few thousand server computers may be interconnected via switches to form a network infrastructure, such as a typical, two-level tree structure. For example, the servers and switches may be packed into a standardized 20 or 40 foot shipping container. Since the MDC is not tied to a fixed location, organizations can place the MDC anywhere and relocate as needs change. In addition to a high degree of mobility, an MDC has other benefits compared with the data center facilities, such as data centers built from server racks. Such benefits may include higher system and power density, lower cooling requirements, and lower manufacturing costs.","The downsides of typical MDC architectures may include bandwidth-intensive requirements, and all-to-all or one-to-many communications among MDC servers. Therefore, there exists a need to support high inter-server bandwidth, as well as aggregate throughput, in an MDC architecture. Furthermore, server\/switch failure may occur during continuous full-time operations. Therefore, there is also a need to achieve graceful performance degradation when such failures occur.","This document describes a network architecture that is a server-centric network architectural design, where each server computer may have multiple network ports and serves not only as an end host, but also as an intermediate relay node for other servers.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The term \u201ctools,\u201d for instance, may refer to system(s), method(s), computer-readable instructions, and\/or technique(s) as permitted by the context above and throughout the document.","Described herein are \u201ctools\u201d and methods to a network architecture designed for modular data centers or MDCs, such as shipping-container-based MDCs. The described network architecture may be referred to as a hybrid Butterfly Cube architecture or \u201cBCube\u201d. References to the described network architecture may incorporate \u201cBCube\u201d. The described network architecture is a server-centric network architectural design, where each server computer may have multiple network ports and serves not only as an end host, but also an intermediate relay node for other servers.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100","100","102","104","102","106","108","110"]},"Switches  and  are multiple layers of switches, which may be used to connect to the server computers or servers ; however, the switches  and  never connect to each other directly. As further discussed below, the switches  and  may be commodity off-the-shelf or COTS switches. The described network architecture  may provide a high aggregate network capacity due to a small network diameter (i.e., network diameter is defined as the longest \u201cshortest\u201d path among all server pairs), and may also provide multiple node-disjoint short paths between any two servers . In the interconnection architecture, each server  may be equipped with a small number of ports, for example four or fewer ports. In certain implementations, multiple layers of inexpensive COTS mini-switches  and  are used to connect the servers . The described network architecture  may be a low-diameter structure that provides high aggregate network capacity for other distributed computing framework, such as the MapReduce framework. The described network architecture may also provide multiple parallel short paths between pairs of servers, which may provide high inter-server bandwidth, and also improve fault tolerance and load balancing. Furthermore, edge-disjointed complete graphs, as described below, may be constructed with the BCube network, which can speed up data replications by several times for distributed file systems, such as Google\u00ae File System or GFS.","BCube Structure","In the example of , the level-1 network architecture  is n=4 and k=1, where \u201ck\u201d denotes the level of the BCube network architecture, and \u201cn\u201d is the number of ports a switch has. In this case, the level-1 network architecture  has 4 level-0 network architectures , and each level-0 architecture  has 4 servers . Each server  has two ports, where the level-0 port connects to a level-0 switch and the level-1 port connects to a level-1 switch, respectively.","As described in the example of , there are two types of devices in the described network architecture : servers  that may have a small number of network ports and switches  and  that connect the servers . The BCube network architecture  can be recursively described. The high level network architecture  may include several low level network architectures. In this example, level-0 network architecture  is n servers that connect to a switch. A level-k network architecture (k>0), which we denote as BCube, has nservers and is built from n level-(k\u22121) network architecture BCubes and nswitches, referred to as nswitches the level-k switches. A server (e.g., servers ) in a BCubehas k+1 ports, which are numbered from level-0 to level-k. Servers (e.g., servers ) in the BCubemay be connected to the level-k switches (e.g., switches  and ) as follows. The servers (e.g., servers ) in each BCubeare numbered, and the level-k switches from 0 to n\u22121 are numbered, respectively. The i-th (0\u2266i<n) server of each BCubeis connected to the i-th level-k switch, using the level-k server ports.","In the described network architecture , switches  and  never directly connect to other switches  and , which allows for routing intelligence placed solely to the servers . Switches  and  may only be used as crossbars to interconnect several servers . Therefore, use COTS switches may be implemented, without any re-programming. Furthermore, when each switch (e.g., switches  and ) has 8 ports and each server  has 4 ports, a BCube network architecture can contain up to 4096 servers. Therefore, a shipping-container MDC with thousands of servers may be implemented with COTS mini-switches.","A BCubehas a low network diameter k+1 (k may typically be no more than 3). Low network diameter leads to high aggregate network capacity since packets do not need to traverse many intermediate nodes. Furthermore, a BCubeprovides k+1 parallel paths between any two servers and it contains many small edge-disjointed complete graphs. Multi-paths provide high inter-server (e.g., server ) throughput, which cannot be provided by structures where servers have only one link; and the edge-disjointed complete graphs accelerate chunk replications by several times for distributed file systems.","On top of the described network architecture  physical structure, implementation may be made of a fault-tolerant and load-balancing source routing protocol or BCube Source Routing or BSR, further described below, and a fast packet forwarding engine, also described below. The BSR protocol may exhibit graceful degradation in terms of throughput as the rate of server and switch failures increases. The forwarding engine may decide the next hop of a packet by only one table lookup. BSR places routing intelligence solely onto servers . By actively probing the network , BSR avoids link-state distribution, handles failures, and balances traffic in a unified fashion. With BSR, the capacity of the described network architecture  decreases gracefully as server\/switch (e.g., server , and switches  and ) failure increases. By leveraging the topology property of the described network architecture  and BSR, a fast packet forwarding engine delivers packets to the next hop with only one forwarding table lookup. For example, the forwarding table may use only 2 KB memory and is almost static.","The described network architecture departs from the typical tree-based architectures to achieve higher inter-server throughput, enhanced fault tolerance, and load balancing among servers  in a MDC (i.e., BCube network ).","Low-end, relatively inexpensive, non-programmable COTS switches may be used instead of relatively high-end high-priced switches for switches  and , based on the observation that the per-port price of the low-end switches is much cheaper than the high-end switches with greater capabilities, while providing high network capacity.","Typical data center applications may be bandwidth intensive and the network may become a performance bottleneck. For example, MapReduce-based applications may shuffle data among many servers . Data shuffling generates an all-to-all traffic pattern in which every server transmits data to all the other servers. As another example, distributed file systems such as GFS, replicate data chunks of a file several times at different chunk servers to improve reliability. The BCube network architecture  provides MapReduce traffic patterns with higher aggregate bandwidth, and may provide higher throughput between any two servers . This is particularly useful when there exist server pairs  that need to exchange large amounts of data, such as to dump crawled Web documents into data repositories.","BCube Construction","The BCube network architecture construction procedure is described in a non-recursive manner. A server is denoted in a BCubeas an address array aa. . . aa, where a\u03b5[0, n) and i\u03b5[0,k). A server may also be identified by the described network architecture address BCube address baddr=\u03a3{an}. A one-to-one mapping between the described network architecture address and its array form may be identified. A switch is denoted as <l, ss. . . s>, where l\u03b5[0,k) is the level of the switch and ss. . . s(s\u03b5[0, n)) numbers the switch at layer l. It is further noted, to use <l, saddr> to denote a switch, where saddr=\u03a3snis the switch address at layer l.","The construction procedure ensures that port <l, ss. . . s, i> of a switch connects to the level-l port of server ss. . . sis. . . susing a link. It is to be noted that links are bidirectional in the described network architecture. Numbering of the n ports of a switch is <l, ss. . . s,0>, <l, ss. . . s,1>, . . . <l, ss. . . s,n\u22121>.","The BCube network architecture is a modular structure, since there may be no need to re-wire the BCubenetwork when a BCubenetwork is built from n existing BCubenetwork architectures. A given BCubenetwork architecture has N=nservers and k+1 levels of switches, with nswitches at each level. When n=8 and k=3, 4096 servers may be supported in the BCube network architecture.","The described network architecture structure is closely related to both the generalized Butterfly and the Hypercube, leading to the term \u201cBCube.\u201d",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 2","FIG. 1"],"b":["200","108","200","108","100"]},"The value h(A, B) denotes the Hamming distance of the two servers A and B (e.g., servers ), which is the number of different digits of their address arrays. The maximum Hamming distance in a BCubeis k+1.","When the Hamming distance of the two servers A and B is 1 (one), the two servers are connected to the same switch. From the addresses of A and B, the switch S may be uniquely identified. For servers a. . . axa. . . aand a. . . aya. . . a, the switch that connects them is <l, a. . . aa. . . a>. Therefore, when a path from a source server to a destination server is denoted, only the intermediate servers are identified.","Single-Path Routing in BCube","From the construction of the BCube network architecture, it may be determined that the servers connected to the same switch differ in a single digit. Specifically, the servers that connect to a level-i switch differ at the i-th digit.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3","b":["300","302"]},"The BCubeRouting algorithm  may be used to find a path from servers A to B. The BCubeRouting algorithm  corrects one digit at one step. The digit correcting order is decided by a predefined permutation \u03a0.","In BCubeRouting algorithm  A=aa. . . ais the source server and B=bb. . . bis the destination server, and \u03a0 is a permutation of {0, 1, . . . k\u22121}. A series of intermediate servers may be systematically built by \u201ccorrecting\u201d one digit of the previous server. Therefore, the path length may at most be k+1. It is to be noted that the intermediate switches can be uniquely determined by its two adjacent servers.","Multi-Paths in BCube","Two parallel paths between a source server and a destination server exist if they are node-disjointed (i.e., the intermediate servers and switches on one path do not appear on the other). The following describes how to generate two parallel paths between two servers.","Given that two servers A=aa. . . aand B=bb. . . b, are different in every digit (i.e., a\u2260bfor I\u03b5[0, k]), BCubeRouting generates two parallel paths from A to B using two permutations \u03a0=[i,(i\u22121)mod (k+1), . . . , (i\u2212k)mod(k+1)] and \u03a0=[i,(i\u22121)mod(k+1), . . . , (i\u2212k)mod (k+1)] (i\u2260iand i, i\u03b5[0,k]).","The permutations \u03a0and \u03a0start from different locations of the address array and then correct the digits sequentially. This pattern ensures that the used switches are always at different levels for the same digit location, hence producing the two parallel paths.","It is determined that when the digits of A and B are different, there are k+1 parallel paths between them. It is also observed that the number of parallel paths between two servers is upper bounded by k+1, since each server has only k+1 links. It follows that there are k+1 parallel paths between any two servers (e.g., servers ) in a BCubenetwork architecture. This may be proven by constructing k+1 as follows.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4","b":"400","sub":"k "},"The construction procedure, BuildPathSet , is based on how two parallel paths between servers may be generated, as discussed above. For two servers A=aa. . . aand B=bb. . . b, the paths built by BuildPathSet  fall into two categories: the paths constructed by DCRouting  (i.e., permutations start from digits a\u2260b) and those constructed by AltDCRouting . There are h(A, B) and k+1\u2212h(A, B) paths in the first and second categories, respectively. By removing the digits a=bin all the servers), it is observed that the paths in the first category are parallel.","Next, it is determined that paths in the second category are also parallel. Assuming that a=band a=bfor two different i and j. The i-th digit of all the intermediate servers in path Pis a value c\u2260a, whereas it is ai in all the intermediate servers in path P. Similarly, the jdigits of Pand Pare also different. The intermediate servers in Pand Pdiffer by at least two digits. The switches in Pand Pare also different, since a switch connects only to servers that differ in a single digit. Therefore, the paths in the second category are parallel.","It may be shown that paths in both categories are parallel. First, the intermediate servers of a path in the second category are different from the servers in the first category, since there is at least one different digit (i.e., the i-th digit c). Second, the switches of a path in the second category are different from those in the first category, due to the fact that switches in the second category have cwhereas those in the first category have ain the same position.","From BuildPathSet , it may be further observed that the maximum path length of the paths constructed by BuildPathSet  be k+2. The length of the paths in the first category is h(A, B). The length of the paths in the second category is h(A, B)+2. The maximum value of h(A, B) is k+1. Therefore, the maximum path length is at most k+3. However, k+3 is not possible, since when h(A, B)=k+1, the number of paths in the second category is 0. The parallel paths created by BuildPathSet , therefore are of similar, small path lengths.","The following illustrates the multiple paths between two servers 0001 and 1011 in a BCube network with n=8 and k=3.\n\n","The Hamming distance of the two servers is h(A, B)=2. Therefore, there are two paths of length 2. The two paths are Pand P. There are also two paths of length h(A,B)+2=4. The two paths are Pand P, respectively. The intermediate switches in the paths may also be listed. It is possible o verify that all the paths are parallel ones, since an intermediate server\/switch on one path never appears on other paths.","BCube Source Routing","The BCube Source Routing Protocol or BSR takes advantage of the multi-path capability of described network architecture . BSR probes the multiple parallel paths to select the path with the maximum available bandwidth. The selected path then may be encoded into transmitted packets. By using probing-based source routing, link state broadcasting is avoided. BSR not only provides a unified framework for fault-tolerance and load-balance, but also enables graceful throughput degradation as server\/switch failures increase. BSR is a reactive source routing protocol, which achieves fault tolerance and load balancing by leveraging the described network architecture's multi-path capability. Moreover, BSR enables graceful performance degradation as the server\/switch failure rate increases.","In BSR, the source server (e.g., server ) decides which path a packet flow should traverse by probing the network. Source routing is used for two reasons. First, intermediate servers may not need to maintain and compute a routing table, which simplifies their functionalities. Reactive source routing is chosen to avoid link state broadcasting, which suffers from scalability concerns when thousands of servers are operational. Second, source routing allows for the source servers to decide which path to use. This is consistent with the objective to place intelligence on the server side.","BSR Idea","In BSR, the same path for packets of the same flow may be chosen. This may avoid a packet out-of-order problem. A flow may be defined as a stream of packets that has the same values for a subset of fields of the packet header, e.g., (src, dst) address pair, or the five-tuple: (src, src_port, dst, dst_port, prot). A duplex flow (e.g., a TCP connection) is considered as two simplex flows. Path selections are performed for these two simplex flows separately, since network conditions along opposite directions may vary significantly.","For a flow, BSR uses a path probing and selection procedure to select the best path (i.e., the one with maximum available bandwidth) from the parallel paths. It may also be possible to use other metrics such as minimum end-to-end delay; however, available bandwidth is used as an example.","When a new flow arrives (e.g., a TCP sync packet is received), path probing and selection will be triggered. A decision may be made as to whether to buffer the packets for the upcoming flows during probing. Therefore, a default path may be chosen from BuildPathSet (as described below) and use the default path to forward packets for these new flows. Simultaneously, path probing and selection may be performed. After the path selection completes and a better path is selected, a switch to the new path is performed.","After probing, the source server selects the path with the maximum available bandwidth from all available paths. If there are several paths with the identical, maximum available bandwidth, the shortest path is preferred. If there are more than one candidate paths, a path is selected by hashing the flow signature (e.g., the five-tuple) to break the tie. The flow then uses that path for packet transmission.","The Path Selection Procedure",{"@attributes":{"id":"p-0059","num":"0064"},"figref":"FIG. 5","b":["500","500","502","504","506"]},"When a source server (e.g., servers ) performs PathSelection , the source server first obtains k+1 parallel paths by using BuildPathSet. The source server then probes the k+1 paths. If one path is found not available, the source server tries to find another parallel path. The parallel path is selected as follows. The source server removes the existing parallel paths from a BCubegraph, and then uses a Breadth First Search (BFS) algorithm to find a path from the source server to the destination server. When links are of equal weight, BFS is a shortest-path routing algorithm. When a path is found, the path is assured to be parallel to the existing paths. A maximum path length threshold may be set. If the path length is larger than the threshold, the path is not included into the parallel paths set, since a long path is not efficient and wastes network bandwidth. The threshold value is a tunable parameter. When BFS cannot find a path, we know that the number of parallel paths is smaller than k+1.","BFS may be very fast for a described network architecture network that has thousands of servers. For example, in BCube architecture network with n=8 and k=3, the execution time of BFS may less than 1 millisecond in the worst case, using a 2.33 GHZ dual-core CPU. The source server can use several optimizations to further reduce computation time. For example, if a first-hop (or last hop) link is not available, the source server does not need to search for k+1 parallel paths since the maximum number of parallel paths becomes k. Also, a server can maintain a set of broken links by receiving and overhearing the path failure messages. These failed links can be readily removed from the described network architecture graph.","When an intermediate server receives a probing packet, the intermediate server updates the available bandwidth field of the probing packet, if its available bandwidth is smaller than the existing value. The available bandwidth of the intermediate server is the minimum of available bandwidths of its incoming and outgoing links. This is performed, since two adjacent servers A (e.g., servers ) and B (e.g., servers ) in the BCube architecture may be indirectly connected via a switch S (e.g., switches  and ). Therefore, the available bandwidth from A to B is the minimal value of the bandwidth from server A to switch S, and that from switch S to server B.","When a destination server receives a probing packet, destination server first updates the available bandwidth field of the probing packet when the available bandwidth of the incoming link is smaller than the value carried in the probing packet. After that, the destination server reverses the path of the probing packet and changes the message type from probing to response and sends the packet back to the source.","Path Adaptation","Path selection is first performed when a new flow arrives. After that, it is performed periodically, for example every 15 seconds. After a path selection completes, all the available paths are recorded in addition to the selected one. Once the path of a flow is determined, the source server encodes the selected path into each packet header of that flow. Intermediate servers then obtain the next hop of the packet by reading the packet header.","Once an intermediate server detects that the next hop is not available, the intermediate server sends back a path failure message to the source server. The source server will select a path from the available paths obtained from the previous probing. To avoid buffering packets, it may be necessary to immediately find another path to replace the broken path. The path may be readily found from the previous probing result. The path may be replaced later when we re-probe the network when probing timer timeouts.","Periodical probing is introduced to make source servers adapt to dynamic changing network conditions. BSR thus handles network failures and balances network traffic in a unified framework.","When multiple flows between two servers arrive simultaneously, they may select the same path. After the path selection timers timeout, they may probe the network and switch to another path simultaneously, resulting in undesirable path oscillation. Two mechanisms may be used to avoid this symptom. First, when there are paths with similar available bandwidth, one path is selected for a flow based on the hash value of the flow signature (e.g., the five-tuple). Second, randomness may be injected\/introduced into the timeout value of the path selection timers. The timeout value is a constant plus a small random value. This ensures that different flows will not initiate path selection at the same time.","BCube Protocol Suite","A network architecture protocol suite may be implemented to realize the benefits of the described BCube network architecture. For example, the network architecture protocol suite may be designed under TCP\/IP. This makes the described BCube network architecture compatible with all the TCP\/IP based applications. By taking advantage of the network architecture's structural property and BSR source routing, it is possible to design and implement a fast packet forwarding engine, which can decide the next hop of a packet by only one table lookup, in both software and hardware.","Low Network Diameter","The diameter, defined as the longest shortest path among all the server pairs, of a BCube, is k+1. The path length of path (A, B) is h(A, B), where h(A, B) is the Hamming distance of the address arrays of servers A and B. This is because only h(A, B) digits are changed to obtain the path from servers A to B. The maximum path length is therefore k+1. It follows that k+1 is the network diameter of a BCubenetwork. In practice, k may be a small integer, for example at the most a value of 3. The described network architecture therefore may be considered a low-diameter network.","Complete Graphs for Replication Speedup","Edge non-overlapping complete graphs with k+2 nodes can be efficiently constructed in a BCube. The complete graphs can speed up data replications in distributed file systems, such as like GFS. The following illustrates such.","In a BCube, a server src and a set of servers {d|0\u2266i\u2266k}, where dis a one-hop neighbor or src at level i (i.e., src and ddiffer only at the i-th digit), can form an edge-disjointed complete graph in which all the edges are parallel with each other. This can be proven by constructing an edge-disjointed complete graph.",{"@attributes":{"id":"p-0072","num":"0077"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIG. 6"],"b":["600","602","604","608","604","4","610","602","604","600","606","608","604","4","604","604","4","604","4","604","4","604","4","608","610","604","4","604","3"],"sub":["0","k\u22121 ","k\u22121 ","0 ","k ","k\u22121 ","1 ","0 ","k ","0","k\u22121 ","0","k\u22121","i","k ","i ","k ","i ","k ","i","i ","k ","0 ","i","1 ","k ","k\u22121 ","i","i","k\u22121"]},"From the construction procedure, it is seen that the longest path in such a complete graph has only two hops (i.e., the diameter of the graph is only two). For server src , there exist a huge number of such complete graphs. Server src  has n\u22121 choices for each d. Therefore, server src  can build (n\u22121)such complete graphs.","In distributed file systems such as GFS, Cloud-Store, and HDFS, a file may be divided into chunks, where each chunk is replicated several times (e.g., typical 3) at different chunk servers to improve reliability. The replicas are chosen to locate at different places. Once the chunk servers are selected, the client writes the data to the nearest chunk server. When the first chunk server starts to receive data, it transmits the data to the next chunk server, and so on. Therefore, the chunk servers form a pipeline to reduce the chunk replication time.","The complete graph built in the described network architecture works well for chunk replication for two reasons. First, the selected servers are located at different levels of the described network architecture, thus improving reliability. Second, complete graph with node-disjointed edges provides a topology for chunk replication speedup. When a client writes a chunk to r chunk servers, the client sends 1\/r of the chunk to each of the chunk servers. Meanwhile, a chunk server distributes its copy to the other r\u22121 servers using the node-disjointed edges. This may be r times faster than the pipeline model.","Partial BCube","In certain cases, it may be difficult or unnecessary to build a complete BCube network architecture structure. For example, when n=8 and k=3, we have 4096 servers in a BCube. However, due to space constraint, only 2048 servers may be accommodated.","A way to build a partial BCubeis to first build the BCubes and then use a partial layer-k switches to interconnect the BCubes. Referring back to , when a partial BCubewith 8 servers is built, two BCubes that contain servers 00-03 and 10-13 may be built, then add two switches <1,0> and <1,1> to connect the two BCubes. However, with this approach, BCubeRouting may not work well for some server pairs. For example, BCubeRouting will not be able to find a path between servers 02 and 13 no matter which routing permutation is used, due to the fact that 02 and 13 are connected to non-existing layer-1 switches. Paths between 02 and 13 can still be established by enlarging the path length. For example, 02 can reach 13 via path {02, 00, 10, 13}; however this approach enlarges path length and reduces network capacity.","In this example, the root cause is that server 02 cannot reach server 13, because switches <1, 2> and <1, 3> do not exist. A solution for partial network architecture construction is as follows. When building a partial BCube, a first step is to build the needed BCubes, then connect the BCubes using a full layer of layer-k switches. With a full layer-k switches, BCubeRouting performs in a similar way as a complete network architecture, and BSR and the construction of the complete graphs just work as before.","An apparent disadvantage of using a full layer-k switches is that many switches in layer-k are not fully utilized. The described solution may be preferable, because it makes routing the same for partial and complete BCube network architectures, and allow for the use of inexpensive mini-switches.","Choice of Parameters n and k","For the BCube network architectures that have the same number of N servers, the values of n and k are needed. Initial thought is to have larger k, since a larger k may give more parallel paths between two servers. More parallel paths give more opportunities for fault-tolerance and load-balance; however a larger k also results in more switch ports and higher wiring cost. Furthermore, a larger k does not necessarily result in larger aggregate network capacity. As discussed, the aggregate throughput is",{"@attributes":{"id":"p-0081","num":"0086"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mfrac":{"mi":"n","mrow":{"mi":"n","mo":"-","mn":"1"}},"mo":"\u2062","mi":"N"},"mo":","}}},"br":[{},{}]},"The description thus far has addressed routing packets inside the described architecture network. However, internal servers may need to communicate with external computers in other containers or the Internet. For example, an assumption may be made that both internal and external computers use TCP\/IP. Gateways may be used for internal and external communication bridging. The gateways have links to both the described network architecture and the external networks.",{"@attributes":{"id":"p-0083","num":"0088"},"figref":"FIG. 7","b":["700","700","700","700","702","700","700","704"]},"BCube Addressing","A 32-bit address (e.g. address  which is shown as a field of header ) may be used to identify a server in the described network architecture. In typical shipping container settings, 16-bit may be sufficient; however, 32-bit is chosen in the described BCube network architecture, allowing for enough space for to supporting a much larger number of servers.","BCube Header","The header  of packet  may have a size of up to 40 bytes. Since source routing may be used, the packet  may include an entire path in its header . In this example, path length or PL  indicates path length. Next hop index or NHI  is a pointer that refers to the next path. The complete path is an next hop array or NHA (array).","If the 32-bit addresses are directly used, so many bytes are needed to store the complete path. For example, 32 bytes are needed when the maximum path length is 8. Leveraging may be performed based on the fact that neighboring servers in the described BCube network architecture differ in only one digit in their address arrays to reduce the space, needed for an intermediate server, from four bytes to only one byte. This byte may be referred to as NHA. NHA is divided into two parts: DP and DV. DP indicates which digit of the next hop is different from the current relay server, and DV is the value of that digit. NHA, together with the address of the relay server, uniquely determines the next hop address.","A flag F in header  may decide the number of bits in DP and DV. When F is 0 (or 1), DP has 2 (or 3) bits and DV has 6 (5) bits. When DP has 2 (or 3) bits, each server may at most have 8 ports, the NHA array length is 8 (or 12), and the described network architecture header  length is 36 (or 40) bytes. When DV is 6 (or 5), switches in the described network architecture have up to 64 (or 32) ports. NHA is used for both space saving and fast packet forwarding.","Exemplary Implementation Architecture","In the BCube network architecture, a multi-port NIC (network interface card) may be included at each server. Various cards and implementations may be used, including NetFPGA standards.","A software solution may be implemented, using the server CPU for packet forwarding. A hardware solution, using a network card (e.g., NetFPGA card) may also be implemented.","For the software solution, a network architecture protocol suite may be used as a network architecture kernel driver in the Windows\u00ae server 2003 networking stack. This implementation may accommodate various NIC and NetFPGA standards\/cards. The network architecture driver locates between the TCP\/IP protocol driver and the Ethernet NDIS (Network Driver Interface Specification) miniport driver. This may be referred to as network architecture driver or a 2.5-layer solution: to the TCP\/IP driver, it is a NDIS miniport driver; to the real Ethernet miniport driver, it is a protocol driver. TCP\/IP applications can directly run in BCube since they see only TCP\/IP. In this implementation, a fixed, one-to-one mapping is established between an IP address and the described network architecture address.","The network architecture driver has two key components: BSR and the packet forwarding engine. BSR is not expected to be CPU intensive and is executed in the server CPU. The packet forwarding engine can be either in CPU (software solution) or in NetFPGA (hardware solution). Modular design allows support for both the NIC cards and NetFPGA with one single binary code.","Path probing and selection may be applied for each TCP connection. For other packets such as UDP and ICMP, path probing and selection may be applied per source and destination addresses pair. This may be applied, because TCP is a dominant transport protocol, and an implementation may be to split multiple TCP connections between two servers into multiple paths.","Packet Forwarding Engine","Using a packet forwarding engine, an intermediate server may use NHA to find a next hop. The packet forwarding engine, as discussed above, may be implemented in software or hardware, and may include a module(s) or device(s) to perform embedding information into packets and for forwarding the packets. To speed up packet forwarding, a forwarding table of the packet forwarding engine may be implemented using the NHA value as the index. The number of entries of the table is 256, if NHA is one byte. The number of valid entries is (k+1)(n\u22121), is the number of neighbors a server has.","Each entry may have three fields: OutPort, NeighborMAC, and ValidFlag. OutPort indicates the outgoing port number. OutPort is DP in NHA. The value is duplicated to avoid the logical AND and SHIFT operations on NHA. NeighborMAC is the MAC address of a neighbor, which is determined from neighbor discovery. ValidFlag indicates whether the neighbor is available.","One entry may need 8 bytes and the entire table may need only 2 KB memory. The forwarding table may be mostly static and easy to maintain. The number of entries in the table is fixed. For each entry, OutPort may never change, NeighborMAC may change only when the neighboring NIC is replaced, and ValidFlag may change only when the neighbor's status changes.","When an intermediate server receives a packet, it uses the NHI pointer to obtain the corresponding NHA value (i.e., the next hop). Using the NHA value as the index, it extracts the status and the MAC address of the next hop. If the next hop is alive, it updates the MAC header of the packet and forwards the packet to the identified output port. The forwarding procedure may just need one table lookup.","Implementation of the forwarding engine may be in software and hardware (e.g., NetFPGA). For example, using NetFPGA, table lookup can be performed and MAC header update in 5 clock cycles in a worst-case scenario. During this time frame, at most 40 B data may be received (with 64 bit processing width per cycle), which may be smaller than the smallest gap between two network architecture packets (which is the total length of a MAC header, a network architecture header, and an IP header). Hardware implementation (e.g., NetFPGA), therefore forwards packets at the line speed.","There may also be other network architecture driver components (such as neighbor maintenance protocol, available bandwidth estimation, network architecture broadcast), the described network architecture configuration program, and the NetFPGA miniport driver. For example, the network architecture driver may contain 16K lines of C code, the NetFPGA mini-port driver has 9K lines of C code, and the BCube NetF-PGA implementation contains 7K lines of Verilog (with 3.5K lines of Verilog for the forwarding engine).","The software solution may be CPU bounded. A server can handle 1.5-1.6 Gb\/s data rate, which is lower than the physical bandwidth provided by the described network architecture. As an example, each server uses two Gigabit ports, resulting in 4 Gb\/s aggregate physical bandwidth. In the hardware implementation, it may be possible to reduce the forwarding overhead to zero, but the interface between the PCI bus and NetFPGA may limit the throughput to 160 Mb\/s.","Exemplary Method(s)","Exemplary methods for constructing a server-centric network architecture are described in reference to . These exemplary methods may be described in the general context of computer executable instructions. Generally, computer executable instructions can include routines, programs, objects, components, data structures, procedures, modules, functions, and the like that perform particular functions or implement particular abstract data types. The methods may also be practiced in a distributed computing environment where functions are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, computer executable instructions may be located in both local and remote computer storage media, including memory storage devices.",{"@attributes":{"id":"p-0101","num":"0106"},"figref":"FIG. 8","b":"800"},"The order in which the method is described is not intended to be construed as a limitation, and any number of the described method blocks can be combined in any order to implement the method, or an alternate method. Additionally, individual blocks may be deleted from the method without departing from the spirit and scope of the subject matter described herein. Furthermore, the method can be implemented in any suitable hardware, software, firmware, or combination thereof.","At block , denoting servers of a network architecture is performed. As discussed above, the network architecture may support a modular data center. Servers may be source servers, destination servers, or act as both source and destination servers. Denoting of the servers may be by address array. A one-to-one mapping may also be performed.","At block , denoting of switches, and level of the switches, that connect the servers is performed. The denoting of the switches may include an address and the level of the switches.","At block , connecting the ports of the switches to appropriate ports is performed. Connecting is performed using a bi-directional link.","At block , determining alternate paths to the servers is performed. As discussed above, the determining alternate paths may be performed based on maximum available bandwidth as discussed above. In particular, the BCube Source Routing or BSR protocol as discussed may be used.","At block , creating a graph for data replication speedup may be performed. As discussed, such graphs may be used in distributed file systems, such as GFS.","An Exemplary Computer Environment",{"@attributes":{"id":"p-0108","num":"0113"},"figref":"FIG. 9","b":["900","900","900","900"]},"Computer environment  includes a general-purpose computing-based device in the form of a computer . Computer  can be, for example, a desktop computer, a handheld computer, a notebook or laptop computer, a server computer, a game console, and so on. The components of computer  can include, but are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including the processor  to the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","Computer  typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media.","The system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM  is illustrated. RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown). Furthermore,  illustrates a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), additionally  illustrates an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternately, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by one or more interfaces (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computing system and environment.","Any number of program modules can be stored on the hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of example, an operating system , one or more applications , other program modules , and program data . Each of such operating system , one or more applications , other program modules , and program data  (or some combination thereof) may implement all or part of the resident components that support the distributed file system.","A user can enter commands and information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices can include components such as speakers (not shown) and a printer , which can be connected to computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing-based device . By way of example, the remote computing-based device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. The remote computing-based device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote applications  reside on a memory device of remote computer . For purposes of illustration, applications and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computing-based device , and are executed by the data processor(s) of the computer.","Various modules and techniques may be described herein in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. that performs particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.","An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","\u201cComputer storage media\u201d includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer.","Alternately, portions of the framework may be implemented in hardware or a combination of hardware, software, and\/or firmware. For example, one or more application specific integrated circuits (ASICs) or programmable logic devices (PLDs) could be designed or programmed to implement one or more portions of the framework.","Although embodiments for implementing a server-centric network architectural design described in language specific to structural features and\/or methods, it is to be understood that the subject of the appended claims is not necessarily limited to the specific features or methods described. Rather, the specific features and methods are disclosed as exemplary implementations for providing a unified console for management of devices in a computer network."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE CONTENTS","p":["The detailed description is described with reference to accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different figures indicates similar or identical items.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
