---
title: Optimized SCA CORBA descriptor for SCA CORBA descriptor files
abstract: A preparsers tool is provided for converting Software Communications Architecture (SCA) Extensible Markup Language (XML) files into Common Object Request Broker Architect (CORBA) structures usable by a Software Communications Architect (SCA) Core Framework (CF). The preparsers tool retrieves a set of target environment implementation definitions (TEID) that define at least one characteristic of a target environment to which a CORBA Common Data Representation (CDR) file is provided. For each component in the target environment, one or more dependencies are merged into an implementation device dependencies list that comprises visible device dependencies and external device dependencies. The parsed set of XML files is converted into a CORBA structure type, the conversion based at least in part on the TEID, such that the conversion of the parsed set of XML files results in a CORBA structure having a type and precedence order that is correct for the target environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08719813&OS=08719813&RS=08719813
owner: Raytheon Company
number: 08719813
owner_city: Waltham
owner_country: US
publication_date: 20111129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","CROSS-REFERENCE TO RELATED APPLICATION","COMPUTER PROGRAM LISTING APPENDIX","COPYRIGHT NOTICE","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Embodiments of the invention generally relate to software communication architectures for radios and other applications. More particularly, the invention relates to systems and methods that improve operation of such software communication architectures by moving certain XML optimizations offline to avoid unnecessary processing of converting component implementation device and software dependencies information into the correct types and in the correct order.","This application is related to a commonly assigned United States Nonprovisional Patent Application filed on May 2, 2011, having Ser. No. 13\/068,061, entitled \u201cSystems, Methods, and Language for SCA CORBA Descriptor files\u201d, which application shares the same inventors Gerald L. Bickle and Susan J. Silver as the present application (\u201c\u2018061 application\u2019\u201d). The entire contents of the '061 application, including its Computer Program Listing Appendix, is hereby incorporated by reference.","This application includes herewith a transmittal under 37 C.F.R \u00a71.52(e) of a Computer Program Listing Appendix on Compact Disk (CD), where the transmittal comprises duplicate compact discs (CDs), totaling two (2) CDs, respectively labeled \u201cCopy 1\u201d and \u201cCopy 2\u201d. Each disk contains the same files. The discs are IBM-PC machine formatted and MICROSOFT WINDOWS Operating System compatible, and include identical copies of the following list of eight (8) files, where each file has been saved as a document viewable using MICROSOFT WORD. All of the materials on the compact disk, including the computer program listings contained in the following eight (8) files, are incorporated herein by reference in their entirety. The eight files include:\n\n","A portion of the disclosure of this patent document contains material which is subject to copyright protection (including, but not limited to the material contained in the Computer Program Appendix). The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","A Software Defined Radio (SDR) is a radio whose function is defined not by its underlying hardware, but instead by its software, such that its output signal is determined by software. SDR systems are thus reconfigurable, within the limits of the actual underlying hardware capabilities, by loading new software as required by a user.  is a block diagram of an exemplary prior art SDR system . The exemplary SDR system  includes a means for receiving an analog or digital radio waveform at a transmission frequency (e.g., an antenna  and associated hardware) along with an SDR hardware component , an SDR software component , and an SDR client .","The SDR hardware component  includes a radio receiver and\/or radio transmitter (which is shown for illustrative purposes only in  as a radio transceiver ), as well as an analog-to-digital (A\/D) converter (ADC)  for conversion of the radio waveform  (also referred to as analog baseband input) is required) to a digital baseband input signal  to the SDR software c component , and a digital to analog (D\/A) converter (DAC) , for D\/A conversion of the digital baseband output  from the SDR software component . The radio transceiver  is a component well understood by those of skill in the art and includes, for example, a radio frequency (RF) subsystem  and an intermediate frequency (IF) subsystem . In the receiving mode, signals received by the antenna  are processed by the RF subsystem  and IF subsystem : for example, the signals received at antenna  can be processed in a tuner (to select the desired signal, such as by filtering), a detector (to extract audio signal from the signal selected by the tuner), downconverted to the desired baseband frequency, and then sent to the ADC  to be converted from an analog baseband signal  to a digital baseband data signal .","In the transmit mode, the digital baseband output signal  from the SDR software component  is sent to DAC  for conversion to an analog baseband output signal , the analog baseband output signal  is sent the IF subsystem  and RF subsystem  of the radio transceiver  to the basic radio transceiver  for further processing, which may include upconverting the analog baseband output signal  to the appropriate transmission frequency, amplification, and filtering, then sent to antenna  for transmission.","The SDR software component  runs on a host, which can be a general-purpose computer system (such as described further herein in connection with ), or hardware that has been configured by software, such as a field-programmable gate array (FPGA), embedded computing device, multiprocessor embedded systems, any equivalent computing\/processing circuit. A waveform can consist of a set of SDR software components executing on general purpose processors, FPGA's, digital signal processors, etc. The host is able to handle a considerable amount of the signal processing previously done by conventional radio hardware components such as mixers, filters, amplifiers, modulators\/demodulators, detectors, etc. Thus, the SDR system  provides a radio that can receive and transmit widely different radio protocols (sometimes referred to as waveforms) based solely on the software used.","The SDR software component  is in operable communication with the SDR hardware component  via one or more data channels. For example, in , the data channels include a first data channel  that permits reception of digital baseband input data from the ADC  of the SDR hardware component , a second data channel  that permits transmission of digital baseband output data from the SDR software component  to the SDR hardware component , and a control data channel  that permits transmission of control data from the SDR software component  to the SDR hardware component . The SDR software component  receives client input data  from an SDR client  and sends client output data  to the SDR client .","The digital baseband output  typically results from the SDR software component  performing a series of digital signal processing (DSP) functions necessary to prepare the client input data  from the SDR client  for transmission by the SDR hardware component . These functions may include: source encoding, encryption, error-correction coding, and baseband modulation, as well as the aforementioned functions performed by hardware components such as mixers, filters, amplifiers, modulators\/demodulators, detectors, etc.","The SDR software component  of , as noted above, as well as the SDR client , each can be implemented using a known computing system such as a general purpose computer.  provides an illustration giving an overview of an exemplary computing system  usable with at least some embodiments of the invention. Note that systems and methods in accordance with the invention can be implemented using any type of computer system running any one or more types of operating systems. Exemplary types of computer systems on which at least some embodiments of the invention can be embodied include any system or device having a processor (or equivalent processing functionality) installed or embedded, including but not limited to a desktop computer, personal computer (PC), laptop computer, notebook computer, tablet computer, handheld computer, netbook, personal digital device (including but not limited to personal digital assistant (PDA), mobile communications device (including but not limited to radio, conventional telephone, mobile\/cellular telephone, smart phone, music playing device, electronic reading device) server, workstation, and interconnected group of computers, as well as any other type of device having a microprocessor installed or embedded thereto, such as a field-programmable gate array (FPGA).","Referring now to , the computer system  includes a central processor , associated memory  for storing programs and\/or data, an input\/output controller , a disk controller , a network interface , a display device , one or more input devices , a fixed or hard disk drive unit , a removal storage device\/drive (optional) , optionally a backup storage device (e.g., a tape drive unit) (not shown) and a data bus  coupling these components to allow communication therebetween.","The central processor  can be any type of microprocessor, such as a PENTIUM-family processor, made by Intel of Santa Clara, Calif. The display device  can be any type of display, such as a liquid crystal display (LCD), plasma display, cathode ray tube display (CRT), light emitting diode (LED), and the like, capable of displaying, in whole or in part, any desired information. The input device  can be any type of device capable of providing the desired inputs, such as keyboards, numeric keypads, touch screens, pointing devices, switches, styluses, and light pens. The network interface  can be any type of a device, card, adapter, or connector that provides the computer system  with network access to a computer or other device, such as a printer. For example, the network interface  can enables the computer system  to connect to a computer network such as the Internet. Other computer accessories well-known to those of skill in the art (e.g., microphones, cameras, speakers, biometric access-control devices such as fingerprint scanners, etc.), although not illustrated in the block diagram of , can of course be included as part of the computer system .","SDR is advantageous, flexible, efficient, and economical for users, because the SDR can evolve to meet changing or new standards by replacing software. In addition, use of SDR improves interoperability, because groups that each use SDR devices based on incompatible standards can communicate with each other by loading each group's SDR device with software that enables the two incompatible SDRs to communicate. SDR can be advantageous in military applications, and the United States Department of Defense (DoD), through its, Joint Tactical Radio System (JTRS) Joint Program Execute Office (JPEO) in San Diego, Calif., now requires that all radios delivered to any of the armed forces adhere to a so-called \u201cSoftware Communications Architecture\u201d (SCA) specification for SDR, which specification is hereby incorporated by reference in its entirety. Goals of the SCA standard include allowing all military branches to cooperate, reduce cost, increase interoperability, and provide the ability to upgrade and\/or extend such SDRs developed in accordance with the SCA, from either or both of the software and hardware sides of the radio.","Several versions of the SCA specification have been developed, At the time of this writing the latest specification prepared by the STRS JPEO is SCA 2.2.2 dated 15 May 2006, the entirely of which is hereby incorporated by reference, including all of its appendices, including Appendix A (Glossary)), Appendix B (Application Environment Profile (AEP)), Appendix C (Interface Definition Language (IDL)), Appendix D (Domain Profile), Appendix D (Common Properties) Attachment, Appendix D (Common Properties) Readme Attachment. In addition, as of this writing, a new proposed SCA specification, tentatively referred to as SCA NEXT, was introduced in December 2010, Both SCA 2.2.2 and SCA NEXT, including all Appendices, are hereby incorporated by reference.",{"@attributes":{"id":"p-0017","num":"0024"},"figref":["FIG. 3A","FIG. 3B","FIG. 3A","FIGS. 3A and 3B","FIGS. 3A and 3B"],"b":["10","11","16"]},"As illustrated in , software used in at least some SCA architectures\/systems  is organized into three layers: a processor environment layer (including operating system ), a middleware layer , and a so-called \u201ccore framework\u201d (CF) layer  (also referred to as a component framework layer), which includes a CF layer IDL and CF layer services and applications . This layer structure helps to isolate the waveform applications from the radio hardware. The processor environment layer and the middleware layer are generally commercially available off-the-shelf products. The CF layer , however, which is defined to be an open means to promote plug-and-play software interoperability, has been developed by a number of different suppliers, including but not limited to Raytheon Corporation of Waltham, Mass., ITT Industries of Clifton N.J., BAE Systems of the United Kingdom; Boeing Corporation of Chicago, Ill.; PrismTech of Woburn, Mass.; Communications Resource Center (CRCO) of Ottawa, Ontario Canada, and Selex Communications of Italy, as well as universities such as the Virginia Polytechnic Institute. An exemplary prior art CF layer  implementation is application independent, but also can be platform dependent.","The CF layer  also is the essential set of open application interfaces and services that provide an abstraction of the underlying Commercial Off-The-Shelf (COTS) software and hardware. Portability is achieved by implementing this same set of CF layer  application program interfaces on every platform. One purpose of the CF layer  is to deploy (load and execute) a distributed application in a controlled and secured manner. At startup, the CF layer  reads information in the Domain Profile (described further below) and attempts to deploy a given application to the platform, in accordance with relationships defined in the Domain Profile. Although the Domain Profile is not depicted in this figure, it is well understood by those skilled in the art and familiar with the SCA; further as those of skill in the art are aware, XML parsing of the domain profile inherently is one of the services that the CF layer  uses. The CF layer  is able to download a component (e.g., a software component) to a device, couple components together to enable them to communicate, stop and start components, handle errors, and perform other management tasks for the components. As illustrated in , the CF layer  includes a CF Interface Definition Language (IDL) and CF layer services and applications . CF layer services , in one exemplary prior art embodiment, consist of a Domain Manager that implements system control, a Device Manager that loads software and manages a set of hardware devices, and core services such as Log, File Manager, and File System. The CF layer  also includes a domain manager that managers the software applications, applications factories, hardware devices, and device manager. Although the details of the CF layer's domain manager and service are not expressly illustrated in , such services are known to those of skill in the art and, furthermore, are shown and described in further detail in the aforementioned SCA 2.2.2 Specification and '020 patent, which are incorporated by reference.","The aforementioned Domain Profile includes a set of files in eXtensible Mark-up Language (XML) format. As is known in the art, XML is a set of rules for encoding documents in machine readable form. An XML parser parses an XML-encoded document so as to convert the XML-encoded document into an XML Document Object Model (DOM), which can then be manipulated (e.g., displayed in a browser), where the XML parser ensures that the document meets defined structures, validation, and constraints (which can be defined in a document type definition (DTD)). For example, the SCA defines XML DTDs for application, device, and service deployment information, all of which are used by the SCA Domain Manager, Application Factory, and Device Manager components of the SCA. , described further herein, depicts the set of XML DTD types.","The Domain Profile is a hierarchical collection of XML files that define the properties of all software components in the system and describes the SCA system's components and connections between components and describes various aspects of the hardware and software devices making up the SCA system, including the identity, capabilities, properties (including properties of embedded hardware devices), and interdependencies, as well as information about the external interfaces of the components and devices, their implementations, and how they are connected to form applications and platforms. An exemplary Domain Profile includes a set of descriptor files for describing the application (the Software Profile) and a set of descriptor files for describing the platform (the Device Profile).","Often the Domain Profiles can include a large amount of information (e.g., tens of thousands of lines of XML code spread over hundreds of files). At runtime, the XML Domain Profile is read to get configuration and deployment information. The parsing of these XML Domain Profile files, and the interpretation of the parsed data by the SCA CF, loads software components of the SCA and creates the connections between such software components and thus enables the radio to operate. The XML Domain Profile can be parsed by the SCA CF layer  each time the SCA radio is turned on or when an application is installed into the radio Domain. The result, in some instances, is the requirement of multiple distributed software components within the radio Domain to parse XML files.","One way the prior art CF layer  deploys the distributed application is through the use of CORBA. CORBA is the acronym for Common Object Request Broker Architecture, which is a standard defined by the Object Management Group (OMG) that enables software components written in multiple computer languages and running on multiple computers to work together as a single application or set of services. CORBA uses an interface definition language (IDL) to specify interfaces that objects will present to the outside world, and specifies a mapping from the IDL to a specific implementation language. Because of the use of the CORBA distributive middleware layer and Portable Operating System Interface (POSIX)-compatible open system environment, the CF layer  supported components can port with relative ease across different processors, Real Time Operating Systems (RTOSs), buses and Object Request Brokers (ORBs). Further information about CORBA can be found in the CORBA Specification, version 3.1 (January 2008), including Part 1 (CORBA Interface) and Part 2 (Interoperability), available from the Object Management Group (OMG), 109 Highland Ave, Needham, Mass. 02494. The CORBA Specification is hereby incorporated by reference in its entirety","Referring again to  the middleware layer  typically includes CORBA. (distributive middleware layer) and Real Time Operating System (RTOS). As noted above, the prior art system of , as implemented in the '020 patent, also includes an embedded distributed XML parser that parses Domain profiles (which typically are defined in the SCA) of the applications for more efficiently installing and running the application. The CF layer  Domain Management subsystem is advantageously configured to invoke the XML parser only upon the installation of a new application or device.","As noted in the aforementioned and incorporated-by-reference '061 application one issue with at least some known implementations of the aforementioned SCA radio system is that the XML Document Object Model (DOM) validation parsers of the SCA generally are slow and large in code size and can require considerable General Purpose Processor (GPP) resources.","Various solutions have been proposed to provide an alternative to the way the existing XML DOM validation parsing function is provided, so as to improve speed and\/or reduce the code size. Some proposed solutions involve offline XML parsing and\/or various types of preparsing, which can be advantageous if the platform and device resources are known prior to the time of waveform deployment. For example, in the aforementioned and incorporated-by-reference '061 application, a proposed solution is provided that reduces code size and processing time by replacing the XML parser and XML files with a CORBA parser and CORBA descriptor files, so as to effectively eliminate the XML parser within the SCA radio system. For example, in one aspect the '412'061 application uses the CORBA CODEC mechanism to create a CORBA parser to replace the XML parser and uses CORBA descriptor files to replace the XML files, to greatly reduce the code size, improve parsing speed, and generally require fewer processing resources. In a further aspect, the '061 application provides a software architecture that includes a CORBA local parser interface; CORBA encoding for certain CORBA deployment types; pre-processor tools to convert XML into the CORBA deployment types and CORBA files; and, local parser interfaces for the SCA SAD and DMD, optional for the DCD when Device Manager when non-collocated with Domain Manager.","The aforementioned '061 application also provides a unique, advantageous preparsers tool located in the offline environment (i.e., a tool that is running on a system that is remote from the SDR system itself). For each type of descriptor (for example, Device Configuration Descriptor (DCD), Domain Manager Descriptor (DMD), and Software Assembly Descriptor (SAD)) used in the SCA, this offline preparsers tool preparses the XML files, including the XML descriptor files, using a COTS parser, then collapses the preparsed XML descriptor files into a corresponding CORBA structure (SAD, DCD, and DMD) that is encoded into a CORBA Common Data Representation (CDR) file using the CORBA CODEC factory. This resulting CDR file is provided to the SDR system (also referred to herein as the embedded environment or target environment), which uses the CORBA CODEC factory to decode the CDR file and extract from it the resultant CORBA structure descriptors (e.g., SAD, DCD, DMD).","In a further aspect of the incorporated-by-reference '061 application, three respective pre-processor tools pre-parse Device Configuration Descriptor (DCD), Software Assembly Descriptor (SAD), and Domain Manager Descriptor (DMD) XML files into respective CORBA structures, then convert these respective CORBA structures into respective CORBA encoded CDR files. Thus, for example, the SAD CORBA file contains a SAD encoded CDR CORBA structure (similarly true for DCD and DMD CORBA files). These preparsers tools parse and convert the XML files into CORBA representation using, at least in part, the CF PreParsers IDL.","In particular, the embodiments described in the '061 patent application improved on the prior art by:","(a) reducing this code size and processing time by replacing the XML parser and XML files with a CORBA parser and CORBA descriptor files, so as to effectively eliminate the XML parser within the SCA radio system;","(b) using CORBA's built in coding and decoding (CODEC) mechanisms, such CODEC mechanisms (along with other aspects of CORBA) to implement a system wherein the CORBA CODEC mechanism can be used, along with other features, to create, effectively, a CORBA parser to replace the XML parser; and","(c) providing a unique, advantageous preparsers tool located in the offline environment (i.e., a tool that is running on a system that is remote from the SDR system itself) that, for each type of descriptor (for example, Device Configuration Descriptor (DCD), Domain Manager Descriptor (DMD), and Software Assembly Descriptor (SAD)) used in the SCA, preparses the XML files, including the XML descriptor files, using a COTS parser, then collapses the preparsed XML descriptor files into a corresponding CORBA structure (SAD, DCD, and DMD) that is encoded into a CORBA Common Data Representation (CDR) file using the CORBA CODEC factory. This resulting CDR file is provided to the SDR system (also referred to herein as the embedded environment or target environment), which uses the CORBA CODEC factory to decode the CDR file and extract from it the resultant CORBA structure descriptors (e.g., SAD, DCD, DMD).","In the aforementioned '061 patent application, when the XML information is converted into CORBA property types during preparsing, the conversion is done such that the XML Properties (e.g., component instance properties for the different properties types) are converted to an appropriate core framework (CF) properties type, with correct values types and in correct precedence order, so that no further conversion is required when they are used with an SDR system. (The precedence order is well understood by those of skill in the art and is understood in connection with the rules specified in SCA version 2.2.2 section D.2.1 Software Package, D.6.1.3.3 componentinstantiation, concerning precedence order.)","As those of skill in the art will appreciate, the '061 patent application's above described inventive preparsers tools and XML properties conversion features helps to reduce code size and provide for more efficient operation of the SDR system, because these functions will no longer have to be done during run-time of the SDR system, but instead are done in an offline environment. For example, in one described embodiment of the '061 patent application, XML deployment information is captured in the following CORBA structures: Software Assembly Descriptor (SAD) structure, for an application that relates to SAD, Software Package Descriptors, (SPDs), Software Component Descriptors (SCDs), Application Deployment Descriptors (ADD), and Properties Descriptors (PRFs) SCA; DTDs; Device Configuration Descriptor (DCD) structure, for Device Manager that relates to DCD, SPDs, Device Package Descriptors (DPD), SCDs and PRFs SCA DTDs; and Domain Manager Configuration Descriptor (DMD) structure, for Domain Manager that relates to SCA, DMD, SPD, SCD, Deployment Platform Descriptor (PDD), PRFs, SCA DTDs.","These SAD, DCD, and DMD CORBA structures are defined based on the types defined by the existing core framework (CF) Parsers IDL interfaces for the SCA, which interfaces are further explained herein, in the figures and text, and further in the incorporated-by-reference computer program appendices, the incorporated-by-reference prior '720 patent, the incorporated-by-reference CORBA Specification, and in the incorporated-by-reference SCA Specification. Further, in one described embodiment of the '061 application, if an interface or interface operations are no longer needed by a given CF implementation, it is removed from the interface since the XML parsing is done offline.","In the '061 patent application, a method is described where three respective pre-processor tools pre-parse Device Configuration Descriptor (DCD), Software Assembly Descriptor (SAD), and Domain Manager Descriptor (DMD) XML files into respective CORBA structures, then convert these respective CORBA structures into respective CORBA encoded CDR files. Thus, for example, the SAD CORBA file contains a SAD encoded CDR CORBA structure (similarly true for DCD and DMD CORBA files). These preparsers tools parse and convert the XML files into CORBA representation using, at least in part, the CF PreParsers IDL. In addition, in one aspect of the '061 patent application, the CF_Parsers IDL file is modified by adding a local interface to its interface definitions, so that only client code is generated (and not skeletal server side code). Further, with this aspect, there need not be CORBA marshalling of interface operations (i.e., CORBA need not serialize objects associated with interface operations). For instances where the device manager is not co-located with the domain manager, the local interface is optional compile directive.","In another aspect of the '061 patent application, a software architecture is described as having a CORBA local parser interface; CORBA encoding for certain CORBA deployment types; pre-processor tools to convert XML into the CORBA deployment types and CORBA files; and, local parser interfaces for the SCA SAD and DMD, optional for the DCD when Device Manager when non-collocated with Domain Manager. Furthermore, when using the core framework (CF) implementation described in the '016 patent application in a system having a CF implementation (e.g., one based on one described in the aforementioned '020 patent) at least one or more of the embodiments of the invention described in the '061 patent application can be configured to have minimal impact to such an the existing CF Domain Manager, Device Manager, and Application Factory associated with the CF implementation based on the '020 patent, because the at least one or more embodiments, as described in the '061 patent application, can be configured to use substantially similar interfaces, types and operations.","The following presents a simplified summary in order to provide a basic understanding of one or more aspects of the invention. This summary is not an extensive overview of the invention, and is neither intended to identify key or critical elements of the invention, nor to delineate the scope thereof. Rather, the primary purpose of the summary is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","As noted above, offline parsing and preparsing can be helpful in parsing XML files used with the SCA and\/or SDR. Furthermore, the aforementioned, incorporated-by-reference '061 patent application describes several types of PreParsers tools that can convert SCA XML files into CORBA structures usable by a Software Communication Architecture (SCA) Core Framework (CF) and which also help to speed up the parsing process, by replacing the XML parser and XML files with a CORBA parser and CORBA descriptor files, so as to effectively eliminate the XML parser within the SCA radio system. However, the inventors of the '061 patent application have found that it is possible to achieve even further deployment optimizations, especially relating to software dependencies for device dependencies.","Accordingly, at least one embodiment of this invention described herein proposes further XML optimizations that can be done offline to avoid unnecessary processing of converting component implementation device and software dependencies information into the correct types and in the correct order. In prior art systems, during execution of processes running on the hardware (e.g., software defined radio (SDR) hardware), deployment processing converts pre-parsed information into the correct deployment dependencies types, to deploy a component successfully. This requires extra processing by the hardware (e.g., radio) deployment processing to convert pre-parsed information into the correct deployment types.","In contrast, at least some embodiments of the invention help to reduce core framework (CF) implementation code by using optimized parser types. By providing additional pre-parser input target environment and device dependencies files, the software implementation dependencies can be parsed and converted into the correct types needed by the CF implementation. Advantageously, at least some embodiments of the invention can be implemented using similar interfaces and operations as those described in the aforementioned, incorporated by-reference '061 patent application, or using similar interfaces and operations as those used in a given prior art SCA system, so that there is minimal impact to existing CF Domain Manager, Device Manager and Application Factory implementations.","As a further improvement to the preparsers tool provided in the '061 application, at least some embodiments of the invention described herein provide further XML optimizations that are done offline to avoid unnecessary processing of converting component implementation device and software dependencies information into the correct types and in the correct order. For example, in at least some embodiments, the further XML optimizations include converting software implementation device dependencies into the expected run-time deployment types so no type conversion happens during deployment. Additional implementation library dependencies are also in the correct order and their device dependencies are collapsed into one set of device dependencies. In at least some embodiments, the invention includes additional pre-parser input target environmental and device dependencies files, so that the software implementation dependencies can be parsed and converted into the correct types needed by the core framework (CF) implementations. With these embodiments, the optimized parser types help to further reduce CF code and processing time. Advantageously, at least some of the embodiments described herein have minimal impact to existing CF Domain Manager, Device Manager, and Application Factory implementations, since similar interface and operations are being used.","In one aspect, the invention provides a preparsers tool for converting Software Communications Architecture (SCA) XML files into Common Object Resource Broker Architecture (CORBA) structures usable by an SCA Core Framework (CF), the preparsers tool stored on a computer storage medium and configured to operate on a processor remote from the SCA CF. This preparsers tool comprises a core framework (CF)_PreParsers interface definition language (IDL) in operable communication with a first type of preparser. The CF_PreParsers IDL is configured to be in operable communication with an XML parser and with at least a first type of preparser. The first type of preparser is associated with a first type of descriptor for the CF, where the first type of descriptor is configured to:","call the XML parser to request parsing of a first set of first XML files;","retrieve a first set of target environment implementation definitions (TEID), the TEID defining at least one characteristic of a target environment to which a first CORBA Common Data Representation (CDR) data file is provided;","retrieve a first set of target environment implementation definitions (TEID), the TEID defining at least one characteristic of a target environment to which a first CORBA Common Data Representation (CDR) data file is provided","convert the first parsed set of first XML files into a first CORBA structure type, the first CORBA structure type based at least in part on at least one predetermined type associated with the SCA CF, the conversion based at least in part on the TEID, such that the conversion of the first parsed set of first XML files results in a first CORBA structure having a type and precedence order that is correct for the target environment;","encode the first CORBA structure type into a first CORBA Common Data Representation (CDR) file; and","write the first CORBA CDR to file as a first octet sequence.","In a further embodiment, the TEID of the preparsers tool is constructed and arranged to enable the preparsers tool to select a target-appropriate implementation from a software package descriptor (SPD), where the target-appropriate implementation corresponds to an implementation element of the SPD that is applicable to the target environment in which the CORBA CDR file is provided. In one","In one embodiment, the TEID further comprises a set of device definitions dependencies (DDD), the DDD comprising visible and external device allocation properties. In one embodiment, the TEID comprises a software package descriptor (SPD) extensible markup language (XML) file that comprises one set of device definitions for a device used in the target environment. For example, in one embodiment, the SPD XML device definitions comprise at least one allocation property for the device. In another embodiment, the set of device definitions in the SPD XML file comprise a reference to a Device Implementation, the Device Implementation comprising a reference to a property file describing at least one allocation property for the device.","In a further embodiment, in the preparsers tool, for a software component being loaded as part of the preparsing, the component instantiation's implementation device dependencies comprises a single implementation device dependencies list comprising a first part comprising visible device dependencies and a second part comprising external device dependencies. For example, in one embodiment, the preparser is further configured to convert the implementation's external device dependencies to the proper SCA CF::Properties type by using input device allocation property definitions provided by a TEID property file. In another embodiment, the preparser is further configured to convert the implementation's visible device dependencies to the proper device allocation type and equality operator by using the provided input device allocation property definitions provided by a TEID property file.","In still another embodiment of the preparsers tool, for an application software component implementation being loaded as part of the preparsing, the component instantiation's implementation software dependencies are formed into a single precedence order list in order of loading dependency software. In still another embodiment, for an application software component implementation being loaded as part of the preparsing, the component instantiation's implementation executable software dependency is converted to a component instantiation element.","In still another embodiment, for an application software component implementation being loaded as part of the preparsing, the component instantiation's deployment dependencies are merged together into one implementation device dependencies list that is separated into a first portion comprising visible device dependencies and a second portion comprising external device dependencies. For example, in one embodiment, for the application software component implementation being loaded as part of the preparsing, the preparser is further configured to convert the component instantiation's deployment dependencies external device dependencies to the proper SCA CF::Properties type by using the provided input device allocation property definitions provided by a TEID property file. In another example, in one embodiment, for the application software component implementation being loaded as part of the preparsing, the preparser is further configured to convert the component instantiation's deployment dependencies visible device dependencies to the proper device allocation type and equality operator by using the provided input device allocation property definitions provided by a TEID property file.","In another embodiment, in the preparsers tool, for an application software component being loaded as part of the preparsing, the component instantiation's implementation usesdevice dependencies is separated into 2 parts: visible device dependencies and external device dependencies. For example, in one embodiment, the preparser is further configured to convert the implementation's usesdevice external device dependencies to a proper SCA CF::Properties type by using provided input device allocation property definitions provided by a TEID property file. In another example embodiment, the preparser is further configured to convert the implementation's usesdevice visible device dependencies to a proper device allocation type and equality operator by using provided input device allocation property definitions provided by a TEID property file.","In another aspect, the invention provides a method of preparsing Software Communications Architecture (SCA) XML files that are converted into Common Object Resource Broker Architecture (CORBA) structures usable by an SCA Core Framework (CF), the preparsing method configured to operate on a processor remote from the SCA CF. The method comprises:","providing a core framework (CF)_PreParsers interface definition language (IDL)-configured to be in operable communication with an XML parser and with at least a first type of preparser;","providing a first type of preparser in operable communication with the CF_PreParsers IDL, the first type of preparser associated with a first type of descriptor for the CF;","calling the XML parser to request parsing of a first set of first XML files;","retrieving a first set of target environment implementation definitions (TEID), the TEID defining at least one characteristic of a target environment to which a first CORBA Common Data Representation (CDR) data file is provided;","converting the first parsed set of first XML files into a first CORBA structure type, the first CORBA structure type based at least in part on at least one predetermined type associated with the SCA CF, the conversion based at least in part on the TEID, such that the conversion of the first parsed set of first XML files results in a first CORBA structure having a type and precedence order that is correct for the target environment;","encoding the first CORBA structure type into a first CORBA Common Data Representation (CDR) file; and","writing the first CORBA CDR to file as a first octet sequence.","In a further embodiment of this aspect, the method further comprises merging together, for each component in the target environment, at least one of the:\n\n","into an implementation device dependencies list having a first part comprising visible device dependencies and a second part comprising external device dependencies;","converting the implementation's external device dependencies to the proper SCA CF::Properties type by using input device allocation property definitions provided by a TEID property file; and","converting the implementation's visible device dependencies to the proper device allocation type and equality operator by using the provided input device allocation property definitions provided by the TEID property file.","In still another aspect, the invention comprises a preparser system for converting for converting Software Communications Architecture (SCA) XML files into Common Object Resource Broker Architecture (CORBA) structures usable by an SCA Core Framework (CF), the preparsing system configured to run on a processor implemented on a computer system in operable communication with and remote from the SCA CF. The preparsing system comprises a computer storage medium, storing therein computer-readable code usable by a processor, and a processor in operable communication with the computer storage medium. The computer is configured to: run the computer-readable code so as to:","provide a core framework (CF)_PreParsers interface definition language (IDL) configured to be in operable communication with an XML parser and with at least a first type of preparser;","provide a first type of preparser in operable communication with the CF_PreParsers IDL, the first type of preparser associated with a first type of descriptor for the CF;","call the XML parser to request parsing of a first set of first XML files;","retrieve a first set of target environment implementation definitions (TEID), the TEID defining at least one characteristic of a target environment to which a first CORBA Common Data Representation (CDR) data file is provided;","merge together, for each component in the target environment, at least one of the: (a) component instantiation implementation software device dependencies; (b) component instantiation implementation usesdevice dependencies; and (c) component instantiation implementation deployment dependencies, into an implementation device dependencies list having a first part comprising visible device dependencies and a second part comprising external device dependencies;","convert the implementation's external device dependencies to the proper SCA CF::Properties type by using input device allocation property definitions provided by a TEID property file;","convert the implementation's visible device dependencies to the proper device allocation type and equality operator by using the provided input device allocation property definitions provided by the TEID property file;","convert the first parsed set of first XML files into a first CORBA structure type, the first CORBA structure type based at least in part on at least one predetermined type associated with the SCA CF, the conversion based at least in part on the TEID, such that the conversion of the first parsed set of first XML files results in a first CORBA structure having a type and precedence order that is correct for the target environment;","encode the first CORBA structure type into a first CORBA Common Data Representation (CDR) file; and","write the first CORBA CDR to file as a first octet sequence.","Furthermore, the architectures and methods which are the subject of this disclosure can be used in conjunction with (and\/or adapted to work with) the aforementioned Software Communications Architecture (SCA) for Software Defined Radio's (SDRs), both the existing 2.2\/2.2.2. Specification and future Specifications (e.g., SCA Next and beyond), all of which are hereby incorporated by reference, as well as with the aforementioned systems described in the incorporated-by-reference '020 patent. It is anticipated that at least some of the architectures and methods of this disclosure also are applicable to other types of SDRs, including but no limited to the so-called open source GNU Radio system, as well as to other systems and devices that utilize principles of SDR and\/or that use software components to communicate with different waveforms or protocols\/standards, such as mobile\/cellular telephones and other wireless network devices. It is further anticipated that at least some of the architectures and\/or methods of this invention are applicable to other technologies and\/or domains that require a lightweight deployment and configuration infrastructure, as well as any application that is using CORBA and XML internally.","Details relating to this and other embodiments of the invention are described more fully herein.","The drawings are not necessarily to scale, emphasis instead generally being placed upon illustrating the principles of the invention.","It should be understood that, in the following detailed description, detailed explanations are not provided in every instance for terms of art that can be located and explained in the aforementioned and incorporated-by-reference SCA specifications. For example, the definitions of the XML elements of the Software Assembly Descriptor (SAD) file and other descriptor files are not necessarily provided herein, as one of skill in the art will be expected either to know such a definition already or to have the ability to refer to the aforementioned, publicly available SCA specification to obtain such information.","In addition, in the following discussion, for clarity of description, exemplary listings of actual code used, in accordance with one embodiment of the invention, to implement the various interfaces (e.g., the interface definition language (IDL)), for example the core framework (CF) PreParsers IDL code, is not provided as part of the body of the text or in the drawings, except for the limited excerpts of code and\/or file listings provided in . Rather, such code listings are provided as part of the included computer program appendix.","Several illustrative embodiments of the invention will now be described. Referring now to the figures,  is a high-level block diagram  showing the components of at least one embodiment of the invention and further illustrating this embodiment's comparison with and derivation from the prior art system of . As  illustrates, the prior art system of  (which system was described more particularly in the aforementioned '020 patent), includes a distributed embedded parser , which includes a CF_Parsers module  that uses as its XML parser an open-source or COTS XML parser , which is illustrated by way of example only as being a Xerces parser.","In contrast, the optimized distributive embedded parser  of this embodiment of the invention is at least partially derived from the distributed embedded parser  of the aforementioned '020 patent, but, as will be explained further below, operates differently because it is, in fact, a CORBA parser. In addition, as explained further herein, the optimized distributed embedded parser  provides an optional local interface. The optimized distributed embedded parser  does not directly use the COTS XML parser  to perform XML parsing of the any XML files that require parsing (e.g., application XML files, Domain Profile files, Software Assembly Descriptor (SAD) files, device managers, etc.) within the SCA. Instead, as will be explained in further detail herein, the optimized distributed embedded parser  uses certain features of CORBA, along with a new CF_PreParsers Offline XML parser  (see ), to achieve XML parsing within the SCA environment.","Referring again to , the optimized distributed embedded parser  includes an optimized CF_Parsers module  and the pre-parsed information from a new CF_PreParsers Offline XML parser  that inherits from the optimized CF_Parsers module and uses this information, along with certain functionality of the CORBA Codec Factory , to (effectively) replace the prior art COTS XML parser  functionality with a new functionality able to parse XML files without requiring that an XML parser be part of the embedded SCA environment. That is, in accordance with at least one embodiment of the invention, no XML parsing takes place within the SDR system. Note that the CF_PreParsers Offline XML parser , as described further herein, can be configured, in accordance with one or more embodiments of the invention, to run on any type of computer configuration, including but not limited to computer systems  such as those described in connection with , herein. In addition, the Optimized CF_Parsers , as described further herein, can be configured, in accordance with one or more embodiments of the invention, to run within the SDR environment (e.g., the SDR system  of , in particular as part of the SDR software component  and\/or the SDR client ).",{"@attributes":{"id":"p-0111","num":"0121"},"figref":["FIG. 5A","FIGS. 9A and 10A","FIG. 5A","FIG. 1","FIG. 5A","FIG. 2"],"b":["200","202","204","202","204","200","202","204","202","200","20","204","50","204"]},"The Target Embedded Environment  of  includes the core framework (CF) , and an Optimized CF_Parsers (which is based on CORBA Interfaces and types). Both the Target Embedded Environment  and the Offline Environment each include an Optimized CF_Parsers module  (i.e., Optimized CF_Parsers in the Target Embedded Environment  and Optimized CF_Parsers in the Offline Environment ), where, as one of skill in the art would appreciate, the interface and functionality are adapted for the given environment (i.e., the same code is used for the different environments). The Target Embedded Environment  has access to a CORBA encoded CDR Files  (i.e., a file in a CORBA Common Data Representation (CDR)) that is created at the Offline environment  (this is explained more fully herein). In addition, the Target Embedded Environment  has access to the CORBA CODEC Factory  (for decoding data) and a set of SCA XML files . Note that the SCA XML Files  are still required as being provided in this embodiment, even though nothing is done with them, because the SCA has defined CF interfaces that reference such SCA XML files. However, in this embodiment of the invention, all that is done with the SCA XML files  is giving such SCA XML files  out on profile attribute CF interface operations. The Optimized CF_Parsers of the Target Embedded Environment  is in operable communication with and uses the CORBA CODEC factory  during a CORBA decode operation, as described further herein. The target embedded environment  may, of course, include other elements, but for simplicity these elements are not shown here.","The Offline environment  is an environment defined to be external to, and distinct from, the Target Embedded Environment , and can be implemented and run on a computer system (e.g., a computer system similar to that of ) that is separate\/remote from the Target Embedded Environment . In one embodiment, the Offline Environment  and the Embedded Environment  are located on physically distinct and separate computer systems. That is, the Offline environment  is an environment defined by the fact that it runs independently from the embedded environment , although the Offline environment  advantageously is able to create an encoded file (i.e., the CORBA Encoded CDR Data File ) that will be accessible to the Embedded environment . This does not necessarily require that the Offline Environment  be in operable or direct communication with the Embedded environment . Rather, as one of skill in the art will appreciate, there are various mechanisms to enable the file that is encoded by the Offline environment to be made accessible to the Embedded environment . For example, in one embodiment, the CORBA Encoded CDR Data File , created on the Offline environment , can be installed, moved, or copied to the Embedded environment . In a further embodiment, the CORBA Encoded CDR Data File  created in the Offline environment  is put in a remote location where the Embedded environment  can remotely access it. For example, the Embedded environment  and Offline environment  can communicate through a third party service, such as a network filing service (NFS), to enable the Embedded environment  to access the CORBA Encoded CDR Data File .","The Offline Environment  includes an Optimized CF_Parsers IDL interface and provides a PreParsers Tool for at least one embodiment of the invention. The Offline Environment  also includes: a set of Device Configuration Descriptor (DCD), Domain Manager Configuration Descriptor (DMD) and Software Assembly Descriptor (SAD) SAD PreParsers , , , respectively; a CF_PreParsers Interface Definition Language (IDL)  that is implemented on top of XML, and a low level parser  to parse the XML, shown by way of illustration and not limitation as being the Xerces XML parser , where the low level parser receives and parses SCA XML files . The CF_PreParsers IDL  definition is based upon the optimized CF_Parsers definition, so the same parser types are used, thus making the Optimized CF_PreParsers tool  more efficient. The Linux Offline environment  in which the Optimized CF_PreParsers Tool  is disposed also has access to the CORBA CODEC factory  and the SCA XML files  and generates the CORBA Encoded CDR Data File  (the CORBA CODEC factory , CORBA Encoded CDR Data File , and SCA XML Files  all are shown, for illustrative and not limiting purposes only, as being external to the Offline Environment ). The DCD, DMD, and SAD PreParsers , , , respectively, convert DCD, DMD and SAD XML files, respectively, into DCD, DMD, and SAD CORBA encoded files (CDR) , respectively. This conversion is explained further herein, in connection with .","Referring to , the Offline environment  also has, in certain embodiments of the invention, access to a set of Target Environment Implementation Definitions (TEID) , where the TEID , in at least some embodiment, also includes a set of Device Dependency Definitions (DDD) A. The inclusion and use of the TEID  and its included DDD A are features in  that differ from and expand upon the aforementioned '061 patent application, as will be explained herein. Advantageously, in at least some embodiments, when the XML information of the SCA software package descriptor (SPD) XML files is converted into CORBA software implementation dependencies during preparsing, the conversion is done such that the software implementation dependencies associated with each component (e.g., visible and external device dependencies, and software dependencies) are each converted to a respective correct type with correct precedence order, so that no further conversion is necessary when the converted XML file used with a radio or other SDR system.","Note that these component dependencies include dependencies against the device, which are, in SCA terms, visible and external types of device dependencies; and software dependencies, which are similar to libraries that need to be loaded before the component code is loaded, so that it can execute correctly. Referring again to , the DDD A, which in one embodiment are included within the TEID  (but also could be implemented separately), includes all software dependencies together, including both visible and external device dependencies. In at least one embodiment, the DDD A is an SCA XML properties file that has all the allocation properties that describe a device (e.g., all visible and external device properties) and is used for device dependencies. That is, the DDD A correspond to allocation properties definitions in the SCA.","As is known in the art, \u201cvisible\u201d means visible to the CF application factory (which itself is not shown in , but known in the art and explained further in the aforementioned, incorporated-by-reference SCA Specification at section 3.1.3.2.1). That is, the CF application factory can use those \u201cvisible\u201d dependencies directly for determining what device is capable of handling that dependency. In contrast, with \u201cexternal\u201d device dependencies, the CF application factory has to delegate that responsibility of determining whether a device is capable of handling a given dependency, to an appropriate device that indicates they have those types of device properties. A given component implementation also can have dependencies to other implementations (e.g., library dependencies (SPD implementations)). In accordance with at least some embodiments of the invention, all of the dependencies are collapsed into one set of device dependencies and one set of software dependencies, usable by the CF_Preparsers , where in the set of device dependencies, the set of visible dependencies is distinguished from the set of external device dependencies.","In contrast, in the prior art, during runtime, CF_Properties type is formed up by the CF_PreParser into a list that is used to encapsulate all the allocation properties that a device is managing, and as the CF_Properties type is formed, data must be converted into the correct types, because the device interface is expecting the input of its allocatecapacity operation to have properties in the correct format. However, with at least some of the embodiments described herein, the forming up of the CF_Properties type, including data converted into the correct types, is done offline, saving considerable time and processing resources.","Referring still to , the TEID  includes information that tells the CF_Preparser  about the target environment, so that the CF_Preparser  can determine the device definitions being used and can put the pre-parsed information into the correct format. For example, for each processing environment in which a software defined radio (SDR) is implemented (e.g., ), there can be different processing elements, like digital signal processors (DSP), general purpose processors (GPP), field programmable gate arrays (FPGA), etc. Each type of processing element has its respective set of characteristics and capacities that describe that processing environment. Those characteristics must be taken into account during processing that occurs at runtime of the SDR. The TEID  describes this set of characteristics and capacities. Different targets can have different corresponding TEIDs . An Exemplary TEID  is described further below in connection with , and the corresponding Device Implementation files are described further below in connection with .","In one embodiment, the TEID  is provided as part of a software package descriptor (SPD) describing the different processing elements used. For example, in one embodiment, the TEID comprises an SPD XML file that comprises at least one set of device definitions for a device used in the target environment. The SPD XML device definitions, in one embodiment, include an allocation property for a device and can, in a further embodiment, include a reference to a Device Implementation, the Device Implementation having a reference to a property file describing at least one allocation property for the device.  are a listing of an exemplary TargetEnvironment Software Package Descriptor (SPD) XML file, in accordance with one embodiment of the invention. The TargetEnvironment SPD XML file of  corresponds, in at least one embodiment of the invention, to the TEID  of . Each implementation element listed in the TargetEnvironment SPD XML file defines a corresponding platform device definition, which, as those of skill in the art recognize, are the corresponding device's allocation properties.  illustrate an exemplary set of Device Implementation files, as referenced by the TargetEnvironment SPD xml, for devices that include a General Purpose Processor (GPP), Digital Signal Processor (DSP), Field Programmable Gate Array (FPGA), Audio Device, and Serial Device.","Note that, as is known in the art, the SPD is used at deployment time to load a component and its various implementations. The information contained in the SPD provides the basis for the domain management function to manage the component within the SCA architecture. The aforementioned SCA Specification, version 2.2.2., at Appendix D, section D.2, provides more information about the SPD. An exemplary SPD includes a softpkg element that has a set of properties that includes these elements:",{"@attributes":{"id":"p-0122","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<!ELEMENT softpkg"]},{"entry":[{},"\u2003\u2002\u2009(\u2002title?"]},{"entry":[{},"\u2003\u2002\u2009,\u2002author+"]},{"entry":[{},"\u2003\u2002\u2009,\u2002description?"]},{"entry":[{},"\u2003\u2002\u2009,\u2002propertyfile?"]},{"entry":[{},"\u2003\u2002\u2009,\u2002descriptor?"]},{"entry":[{},"\u2003\u2002\u2009,\u2002implementation+"]},{"entry":[{},"\u2003\u2002\u2009,\u2002usesdevice*"]},{"entry":[{},")>"]},{"entry":[{},"<!ATTLIST softpkg"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"id","\u2002\u2009ID","\u2009#REQUIRED"]},{"entry":[{},"name","\u2002\u2009CDATA","\u2009#REQUIRED"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type\u2002(sca_compliant\u2002|\u2002sca_non_compliant)"]},{"entry":[{},"\u201csca_compliant\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"version","\u2002\u2009CDATA","\u2009#IMPLIED >"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"As noted above, the SPD can specify more than one implementation element (only one is illustrated above), although only one is applicable at a time in a given hardware element. That is, an implementation is specific to a processor and\/or an operating system. Referring briefly to ,  is a listing of an exemplary Component Software Package Descriptor (SPD) that specifies more than one implementation element, in accordance with one embodiment of the invention.","In addition, the above-mentioned implementation element itself can have software dependencies, and those can include a list of software dependencies. As is specified in Appendix D of the aforementioned SCA Specification, at D.2.1.6, the implementation element allows the same component to support different types of processors, operating systems, etc. An exemplary implementation element includes:",{"@attributes":{"id":"p-0125","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<!ELEMENT implementation"]},{"entry":[{},"\u2003\u2003\u2003\u2009(\u2002description?"]},{"entry":[{},"\u2003\u2003\u2003,\u2002propertyfile?"]},{"entry":[{},"\u2003\u2003\u2003,\u2002code"]},{"entry":[{},"\u2003\u2003\u2003,\u2002compiler?"]},{"entry":[{},"\u2003\u2003\u2003,\u2002programminglanguage?"]},{"entry":[{},"\u2003\u2003\u2003,\u2002humanlanguage?"]},{"entry":[{},"\u2003\u2003\u2003,\u2002runtime?"]},{"entry":[{},"\u2003\u2003\u2003,\u2002(\u2002os\u2002|\u2002processor\u2002|\u2002dependency\u2002)+"]},{"entry":[{},",\u2002usesdevice*"]},{"entry":[{},"\u2003\u2003\u2003)>"]},{"entry":[{},"<!ATTLIST implementation"]},{"entry":[{},"\u2003\u2003\u2003id\u2003\u2003\u2003\u2003\u2009ID\u2002#REQUIRED"]},{"entry":[{},"\u2003\u2003\u2003aepcompliance\u2003(aep_compliant\u2002|\u2002aep_non_compliant)"]},{"entry":[{},"\u2003\u2003\u2003\u201caep_compliant\u201d>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For example,  are listing of exemplary Device Implementation files, in XML format, that are usable with the TargetEnvironment SPD XML file of , in accordance with one embodiment of the invention.  is a listing of a first exemplary Device Implementation file, GPPDevice.prf.xml,  is a listing of a second exemplary Device Implementation file, DSPDevice.prf.xml,  is a listing of a third exemplary Device Implementation file, FPGADevice.prf.xml,  is a listing of a fourth exemplary Device Implementation file, AudioDevice.prf.xml,  is a listing of a fifth exemplary Device Implementation file, SerialDevice.prfxml, and  is a listing of an exemplary Component Software Package Descriptor (SPD) that specifies more than one implementation element exemplary each in accordance with one embodiment of the invention.","Each implementation element in the TargetEnvironment SPD file of  defines a platform device definition, which are the device's allocation properties. Each Device Implementation (i.e., ) references a property file that describes the allocation properties. As one of skill in the art will recognize, the exemplary TargetEnvironment SPD XML file of  effectively is collapsing a set of Device Manager Device Configuration Descriptor (DCD) files into a TargetEnvironment SPD XML file, which is much easier to process.","Within this above-referenced exemplary implementation element, for example, the optional os and processor elements, each has corresponding attributes that are defined in a corresponding property file as corresponding allocation properties, and each of the os and processor elements is interpreted as a dependency for the software component. These and other applicable allocation properties and dependencies for elements are known to those of skill in the art and explained further in the SCA Specification. In accordance with at least one embodiment of the invention, dependencies such as these are put into one device dependency list, based on the source XML file of the property. This is described further herein. In addition, the dependency element (of the implementation element) can itself refer to a softpkgref element (not shown above), i.e., a softpkg contained in another SPD and having a file-load dependency on that file (that is, the implementation can refer to other software SPDs for its dependencies).","These other dependencies are, in accordance with the embodiments of the invention described herein, also collapsed into a single precedence order list in order of loading dependency software. An SPD may have more than one implementation element that can be specified, but only one implementation element is applicable within the given hardware environment (e.g., SDR) in which it is being used (SPDs and implementation elements are explained further below). For example, referring to the TargetEnvironment SPD XML file of , although this file references the General Purpose Processor (GPP) as well as a Field Programmable Gate Array (FPGA), only one of these implementations is applicable within a given target environment. The CF_Preparsers  (), by using information contained in the TEID  (as described further herein), uses only the implementations from a given SPD file that are applicable to the given hardware environment. That is, the TEID  (e.g., the TargetEnvironment SPD XML file) tells the CF_Preparsers  which implementations to use.","Each software dependency may have specific device dependencies associated with it. These software dependency's device dependencies are merged together into one implementation device dependencies list (part of Device Dependency Definitions A). The implementation device dependencies list is separated into 2 parts: visible device dependencies and external device dependencies. The Optimized CF_Preparsers IDL  converts the external device dependencies to the proper SCA CF::Properties type by using the provided input device allocation property definitions. The CF_Preparsers IDL  also converts the visible device dependencies to the proper device allocation type and equality operator by using the provided input device allocation property definitions. Advantageously, in one embodiment, for a software component being loaded as part of the preparsing, the component instantiation's implementation device dependencies is a single implementation device dependencies list having a first part that includes visible device dependencies and a second part that includes external device dependencies.","A component instantiation's implementation usesdevice dependencies (the usesdevice element describes a \u201cuses\u201d relationships a given component has with a device in a system) also is separated into 2 parts: visible device dependencies and external device dependencies. The CF_preparser  converts the usesdevice external device dependencies to the proper SCA CF::Properties type by using the aforementioned provided input device allocation property definitions. The CF_Preparser  converts the usesdevice visible device dependencies to the proper device allocation type and equality operator by using the provided input device allocation property definitions.","Note that \u201cvisible device dependencies\u201d are visible device allocation properties (whose action type is not external) that the CF Application Factory can use directly to determine if device can satisfy a device dependency. External device dependencies are device external allocation properties (whose action type is external) that the CF Application uses with a Device's allocate capacity operation to determine if a device can satisfy an implementation dependency.","Thus, a component instantiation's implementation software dependencies are formed into a single precedence order list in order of loading dependency software. A component instantiation's implementation executable software dependency is converted to a component instantiation element.",{"@attributes":{"id":"p-0134","num":"0144"},"figref":["FIG. 5B","FIG. 5A"],"b":["1005","1090","1010","1110"]},"Referring to , for each component, if multiple implementations are specified in the Software Package Descriptor (SPD), the applicable implementation is selected for a given radio from the SPD file (block ). The Target Environment Implementation Definitions (TEID)  is used to help select the applicable implementation. The component instantiation's implementation software dependencies device dependencies are merged together into one implementation device dependencies list (block ). Advantageously, in one embodiment, there is only one set of device dependencies for a given application component implementation. As noted above, the implementation device dependencies list is separated into 2 parts: visible device dependencies and external device dependencies. The implementation's external device dependencies are converted (e.g., by CF_PreParser ) to the proper SCA CF::Properties type (block ) by using the provided input device allocation property definitions (block ). The implementation's visible device dependencies are converted (e.g., by CF_Preparser ) to the proper device allocation type and equality operator (block ) by using the provided input device allocation property definitions (block ).","In addition, for each component, the component instantiation's implementation usesdevice dependencies are separated into 2 parts: visible device dependencies and external device dependencies (block ). The implementation's usesdevice external device dependencies are converted (e.g., by the CF_PreParsers ) to the proper SCA CF::Properties type (block ) by using the provided input device allocation property definitions (block , which are, effectively the Device Dependency Definitions A of ). The implementation's usesdevice visible device dependencies are converted (e.g., by the CF_PreParsers ) to the proper device allocation type and equality operator (block ) by using the provided input device allocation property definitions (block ). Note that the equality operator refers to the action element in the property elements (see D.4.1.1.7 in SCA Specification).","For each component (i.e., an application component implementation), the component instantiation's implementation software dependencies are formed into a single precedence order list in order of loading dependency software (block ). For each component, the component instantiation's implementation executable software dependency is converted to a component instantiation element (block ). As is known to those skilled in the art, all component instantiation elements are code that gets executed, and, via the actions taken in blocks  and , the elements are formed up in correct order.","The actions detailed in blocks  through  are optional actions that are applicable to embodiments of the invention implemented using the SCA Next specification, as SCA Next includes the concept of deployment dependencies at the Software Assembly Level for an application. Referring again to , in optional black , for each component, the component instantiation's deployment dependencies are merged together into one implementation device dependencies list (As previously noted the implementation device dependencies list is separated into 2 parts: visible device dependencies and external device dependencies). For each component, the component instantiation's deployment dependencies external device dependencies are converted (e.g., by CF_PreParser ) to the proper SCA CF::Properties type (optional block ) by using the provided input device allocation property definitions (block ). For each component, the component instantiation's deployment dependencies visible device dependencies are converted to the proper device allocation type and equality operator (optional block ) by using the provided input device allocation property definitions (block ).","The operations in blocks  through  (and, optionally, if applicable, blocks  through ) are repeated for all components (block ). That is, the same target environment and device dependencies are used for all components. When a component is done, the implementation is formed by combining and collapsing the information that results in blocks ,  (and, optionally,  and ), into an implementation element usable in the SPD. When all component are done (block ), processing proceeds to preparsing (e.g., to block  of , discussed further herein) (block ).","(This is more particularly illustrated in the included computer program listing in the CF_Preparsers IDL, at about page 7). As those of skill in the art know, in XML there is a precedence of software implementation dependencies, and the pre-processing done in the offline environment  handles the precedence order for each software dependency to ensure that the software dependency obeys the precedence list requirement. The software implementation dependencies is well understood by those of skill in the art and is understood in connection with the rules specified in SCA version 2.0, section D.6.3.1.2 (as well as SCA 2.2\/2.2.2 section D.6.1.3.3), concerning device dependencies and software dependencies. Furthermore, the SCA's precedence rule for properties (specified at D.2.1) is independent of the version of SCA that is in use for any version of SCA 2.0 and above.","Referring again to , in accordance with one embodiment of the invention, the basic CF_Parsers IDL , as described in the aforementioned incorporated by reference '020 patent, is adapted and modified in at least some embodiments of the present invention to become a CF_PreParsers module\/tool  as well as an Optimized CF_Parsers , , so that it instead converts XML into CORBA types, then puts the CORBA types into a CORBA structure, where the information is stored into new types that capture condensed\/collapsed information into a CORBA structure (i.e., a SAD structure, a DCD structure, and a DMD structure) (explained further in connection with ). The SAD structure, DCD structure, and DMD structure are all CORBA structure types that are based upon existing CF_Parsers CORBA types and are shown and defined in , described further below. In addition, at least some embodiments of the invention take advantage of certain features of CORBA, such as the CORBA CODEC factory  and CORBA Anys. For example, it is known that the CORBA CODEC factory  provides encode\/decode behavior, so this CODEC factory  feature can be used to encode a CORBA_Any into an octet sequence, which can be written out to an encoded CORBA file. This is described further herein, especially in connection with .","In addition, note that the computer program listing appendix on CD that accompanies this filing, which CD and its contents are incorporated by reference, includes several non-executable, illustrative files (provided for illustrative purposes only in Microsoft WORD format) that list the text of several IDLs and other files that are useful in implementing at least some embodiments of the invention. These files correspond to CORBA IDL files. One of skill in the art will recognize that although the CORBA IDL files are provided as text type documents, the actual textual listings of the IDLs, together with the UML class diagrams of  (discussed further below), the known SCA and CORBA specifications, and routine skill in the art, can be used to help generate usable code to implement at least some embodiments of the invention. For example, a CORBA Language (C, CPP, Java) IDL compiler can be used to convert the illustrated IDL into CORBA language mapping client and server files.","As an example, the computer program listing appendix on CD includes a file titled CF_Parsers_IDL.doc, which file provides a textual code listing usable, in accordance with at least one embodiment of the invention, to implement the optimized CF_Parsers , of . Similarly, the aforementioned computer program listing appendix on CD includes a file titled CF_PreParsers_IDL.doc, which file provides an exemplary textual code listing usable, in accordance with at least one embodiment of the invention, to implement the CF_PreParsers IDL  of . Similarly, the aforementioned computer program listing appendix on CD includes a files titled DCD_IDL.doc, DMD_IDL.doc, and SAD_IDL.doc, as well as a DeviceConfigurationParser_IDL.doc, DomainManagerConfigurationParser_IDL.doc, and SoftwareAssemblyParser_IDL.doc, which files each provide respective exemplary textual code listings usable, in accordance with at least one embodiment of the invention, to implement the corresponding DCD PreParsers , DMD PreParsers B, and SAD PreParsers , of . Of course, those of skill in the art will appreciate that these textual code listings are merely exemplary and not limiting.",{"@attributes":{"id":"p-0144","num":"0154"},"figref":["FIG. 6","FIG. 6","FIGS. 8-12"],"b":["900","204","202"]},"Referring to , the block diagram  of  shows the particular SCA XML files that pre-parsed (e.g., using COTS parser ) (step #'s - of Offline Environment  of ) then are collapsed together, using, as applicable, the DCD PreParsers tool A, the DMD PreParsers tool B, and the SAD PreParsers tool C, to form the CORBA data structures , which structures include a SAD structure , a DCD structure , and DMD structure . Each CORBA structure is encoded into a respective CORBA encoded Common Data Representation (CDR) file  (e.g., resulting in the CDR file types SAD.cdr, DCD.cdr, and DMD.cdr) using CORBA CODEC  and Any mechanisms (e.g., as shown in step # in Offline Environment  of ), and written to file as an octet sequence (step # in Offline Environment of ). As shown in , the octet sequence is provided to the CORBA encoded CDR data file  in the Embedded Environment , which reads in the encoded CORBA octet sequence from the CORBA Encoded CDR Data File  (step # in Embedded Environment  of ) and also uses the CORBA CODEC factory  to decode the CORBA Encoded CDR data file (step # in Embedded Environment  of ) and extract from it the resultant descriptor files (e.g., SAD, DCD, DMD).","Referring again to , the block diagram  of  also illustrates, in a manner similar to that used in UML diagrams, the multiplicity relationships between the XML files that are parsed to create the structures. The particular SCA XML descriptors\/files of FIG,  are not discussed in great detail herein, as those of skill in the art will recognize the functions of and details about each of the types of descriptor files shown in FIG,  are discussed in the aforementioned, incorporated-by-reference SCA specification, especially in its Appendix A-Glossary, and also in the SCA 2.2.2 extensions. Note also that the aforementioned SCA Next Specification also provides further information about the descriptor files.","Advantageously, in at least some embodiments, when the XML information of the SCA XML files is converted into CORBA CF property types during preparsing, the conversion is done such that the XML Properties associated with each component (e.g., Configure Properties, Executable Properties, Resource Factory Properties, Options Properties, and other component instance properties) are each converted to a respective correct SCA CF::Properties type, with correct precedence order, so that no further conversion is necessary when the converted XML file used with a radio or other SDR system. The properties returned are converted to the proper CORBA types from their string types (found in XML). (This is more particularly illustrated in the included computer program listing in the CF_PreParsers_IDL.doc, at about page 7). That is, as those of skill in the art know, in XML there is a precedence of four levels for any given property, and the pre-processing done in the Offline Environment  handles the precedence order for each property to ensure that the property obeys the precedence list requirement. The precedence order is well understood by those of skill in the art and is understood in connection with the rules specified in SCA version 2.2\/2.2.2, section D.6.1.3.3, concerning precedence order.","This technique of converting to SCA CF::Properties type, with correct precedence order, provides efficiency advantages over prior art systems that convert XML information into SCA CF::Properties types during runtime, and also provides advantages over prior art systems that do not convert XML information into SCA CF::Properties types in correct precedence order.","As a first example of creation of a CORBA structure, in accordance with one embodiment of the invention, consider, for example, the DCD structure , created using DCD PreParsers tool A (an illustrative example of which is documented in the included computer program listing appendix, which forms part of this application, as DCD_IDL. Note that the preparser DCD tool A uses this DCD_IDL structure, such that the IDL-generated code becomes part of the tool. With the DCD PreParsers tool A, the Device Configuration Descriptor (DCD)  and its associated Software Package Descriptors (SPD) , Software Component Descriptors (SCD) , Device Package Descriptors (DPD)  and Properties Descriptor (PRF)  XML files are collapsed together so as to be converted into the CORBA DCD structure . The CORBA structure is further encoded into CDR and then written to file as an octet sequence, as described above and further herein.","Referring again to , an example of the resultant DCD structure , when collapsed in accordance with an embodiment of the invention, is shown below and also in , which is a first UML class diagram  illustrating the optimized CF Parsers CORBA module interfaces and structures, including various CORBA elements used in their definitions, and provides an overview of the interface relationships, in accordance with one embodiment of the invention. This DCD structure  is the structure that represents the collapsing of the DCD XML files after these DCD XML files have been preparsed (i.e., the DCD , and its associate DPD , PD , SPD  and SCD  XML files) as discussed above in connection with . The DCD structure  is the structure that contains the information about a device manager created by the preparser parsing the DCD XML file and is used by the CF_Optimized CF_PreParsers .","Referring now to , in forming the DCD structure , the DCD  pulls in the 1 to N associated SPDs  (i.e., it pulls in however many there are up to \u201cN\u201d, but will pull in at least one). In addition, the DCD indirectly pulls in SCDs  and PRFs , because each of the 1 to N associated SPDs  pulled by the DCD  will itself pull, for each SPD , from 0 to 1 single respective SCDs ; the DCD  also pulls in from 0 to N DPDs , and for each of the 0 to N DPDs , each respective DPD  pulls in from 0 to 1 single respective PRFs .","This DCD structure  and its illustrated elements is a representation that conveys everything of importance that was contained in the original SCA XML files. As shown in  (and as also included in the computer program listing appendix, in the DCD_IDL file), the exemplary DCD structure  includes as elements:",{"@attributes":{"id":"p-0153","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"id\u2002:\u2002string [1]"]},{"entry":[{},"name\u2002:\u2002string[1]"]},{"entry":[{},"partitions\u2002:\u2002PartitionsSequence[1]"]},{"entry":[{},"connections\u2002:\u2002ConnectionsSequence[1]"]},{"entry":[{},"domainManager\u2002:\u2002string[1]"]},{"entry":[{},"fileSystemNames\u2002:\u2002FileSystemNamesSeq[1]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This DCD structure  is provided as an example usable in accordance with at least some embodiments of the invention and is not intended as limiting. Each of the elements of the DCD structure  (as well as the SAD structure  and DMD structure , discussed further below) will be readily understood by one of skill in the art when viewed in connection with the aforementioned, incorporated-by-reference SCA Specification and the included computer program listing appendix. For example, the domainManager element indicates how to obtain the CF::DomainManager object reference, and the fileSystemNames element indicates the mounted file system names for CF::DeviceManager's FileManager. As will be apparent, advantageously, this DCD structure  does not include or require elements\/items that have nothing to do with (i.e., are not needed for) deployment and\/or that are merely informational elements\/items. Thus, in at least one embodiment the DCD structure  contains only elements required for deployment in the SCA Core Framework (CF) . Of course, one of skill in the art will appreciate that the DCD structure  (as well as the SAD structure  and DMD structure , described further herein) could, in an alternate embodiment, be implemented to include additional items, such as non-deployment items and merely informational items, but the resulting structure might not be as compact as the DCD structure  illustrated in . In addition, those of skill in the art will readily be able to determine, for a given deployment, which elements in the DCD structure  are not required for that given deployment; this also will be true for the SAD structure  and DMD structure  further described herein.","Referring again to , the SAD structure  and DMD structure  are formed in a manner similar to that for the DCD structure , which method is also discussed further below in connection with . Consider first the SAD structure . Using the SAD PreParsers tool B (an illustrative example of which is documented in the included computer program listing appendix as SAD_IDL.doc), the Software Assembly Descriptor (SAD)  and its associated SADs, SPDs , SCDs , Application Deployment Descriptors (APDs)  and PRF  XML files are collapsed together so as to be converted into the CORBA SAD structure .","An example of the resultant SAD structure , when collapsed in accordance with an embodiment of the invention, is shown below and in . This SAD structure  is the structure that represents the collapsing of the SAD XML files as discussed above in a similar manner for the DCD structure . The SAD structure  is the structure that contains the information created by the pre parser parsing the SAD XML file. The SAD structure  is used by the Optimized CF_Parsers . The SAD  corresponds to the Software Assembly Descriptor (SAD) DTD XML file and the SAD elements map to the concepts in the SAD . As with the DCD structure , the SAD structure  and its illustrated elements is a representation that conveys everything of importance that was contained in the original SCA XMLs. Referring again to , in forming the SAD structure , the SAD  pulls in at least an SPD or an SAD, and there can be N of these; for example, the SAD  can pull in the 0 to N associated SPDs  (i.e., it pulls in however many there are up to \u201cN\u201d, but there may be none). Optionally, the SAD  can pull in zero or one SCDs. The SAD  must be able to pull in at least one member from one of these two sets SAD and SPD. In addition, each of the 0 to N associated SPDs  will itself pull, for each SPD , from 0 to 1 single respective SCDs . The SAD  also pulls in from 0 to 1 Application Deployment Descriptors (ADD) .","As shown in  (and as also included in the computer program listing appendix), the exemplary SAD structure  includes as elements:",{"@attributes":{"id":"p-0158","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"id\u2002:\u2002string [1]"]},{"entry":[{},"name\u2002:\u2002string[1]"]},{"entry":[{},"partitions\u2002:\u2002PartitionsSequence[1]"]},{"entry":[{},"assemblyControllerID\u2002:\u2002string[1]"]},{"entry":[{},"connections\u2002:\u2002ConnectionsSequence[1]"]},{"entry":[{},"externalPorts\u2002:\u2002ExternalPortsSequence[1]"]},{"entry":[{},"deploymentPrefs\u2002:\u2002StringSequence[1]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As noted above, each of the elements of the SAD structure  will be readily understood by one of skill in the art when viewed in connection with the aforementioned, incorporated-by-reference SCA Specification and the included computer program listing appendix. For example, the readonly assemblyControllerId attribute corresponds to the SAD DTD assemblycontroller element within the SAD file. The readonly externalPorts attribute corresponds to the SAD DTD externalports element with the SAD file. As with the DCD structure , the SAD structure  advantageously only includes items required for a given deployment and thus does not include or require elements that are unnecessary for deployment and\/or that are merely informational.","Referring again to , consider next the DMD structure . Using the DMD PreParsers tool C (an illustrative example of which is documented in the included computer program listing appendix as DMD_IDL.doc), the Domain Manager Configuration Descriptor (DMD)  and its associated SPDs , SCDs , Deployment Platform Descriptor , and PRF  XML files are collapsed together so as to be converted into the CORBA DMD structure .","An example of the resultant DMD structure  when collapsed in accordance with an embodiment of the invention, is shown below and in . This DMD structure  is the structure that represents the collapsing of the DMD XML files as discussed above in a similar manner for the DCD structure . As with the DCD structure, the DMD structure  and its illustrated elements is a representation that conveys everything of importance that was contained in the original SCA XMLs. Referring again to , in forming the DMD structure , the DMD  pulls in the 0 to 1 associated Deployment Platform Descriptor (PDD) , at least one SPD , from 0 to 1 SCD , and, from 0 to N PRF .","As shown in  (and as also included in the computer program listing appendix), the exemplary DMD structure  includes as elements:",{"@attributes":{"id":"p-0163","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"id\u2002:\u2002string [1]"]},{"entry":[{},"props\u2002:\u2002Properties[1]"]},{"entry":[{},"services\u2002:\u2002ServiceTypeSeq[1]"]},{"entry":[{},"channels\u2002:\u2002ChannelTypeSeq[1]"]},{"entry":[{},"name\u2002:\u2002string[1]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As noted above, each of the elements of the DMD structure  will be readily understood by one of skill in the art when viewed in connection with the aforementioned, incorporated-by-reference SCA Specification and the included computer program listing appendix. As with the DCD structure , the DMD structure  advantageously does not include or require elements that are unnecessary for deployment and\/or that are merely informational, and, in accordance with at least one embodiment of the invention, includes only elements required for deployment. Note that the embodiment of the invention that include the aforementioned CORBA structures are applicable to virtually all SCA extensions, even those not illustrated with particularity in this patent application.","Referring more particularly to , this figure includes a first UML class diagram  illustrating the optimized CF_Parsers CORBA module interfaces and structures, including various CORBA elements used in their definitions, and provides an overview of the interface relationships, in accordance with one embodiment of the invention. In particular, the first UML class diagram  of  illustrates interface, classes and relationships related to the parsing activities of the UML Sequence chart of , described later herein. In addition,  is a second UML class diagram  illustrating the CF_PreParsers CORBA Module interfaces, including interfaces, CORBA elements, CORBA constants, and CORBA sequences, used in connection with preparsing, in accordance with one embodiment of the invention. That is, the second UML class diagram  of  illustrates interfaces and relationships used during the preparsing activities of the UML Sequence chart of , described later herein (these activities also include creation of the aforementioned SAD structure , DCD structure , and DMD structure ). The CF_PreParsers  is based upon interfaces and types from the optimized CF_Parsers , so compatible types and interfaces are defined once. This allows the encoding and decoding to be using the same types for SAD, DCD, and DMD.","Referring briefly to , at a high level, in this first UML diagram , the CORBA module interfaces include a Parser interface , an AssemblyParser interface , a PropertiesParser interface , a SoftwarePackageParser interface , a SoftwareAssemblyParser interface , a DeviceConfigurationParser interface , and a DomainManagerConfigurationParser interface . The UML class diagram  of  also illustrates the aforementioned CORBA structures that define the attributes of the aforementioned Software Assembly Descriptor (SAD) structure , Device Configuration Descriptor structure (DCD) structure , and Domain Manager Configuration Descriptor (DMD) structure . The AssemblyParser interface  and the DomainManagerConfigurationParser  interface each inherit from the Parser interface . The SoftwareAssemblyParser interface  and the DeviceConfigurationParser interface  each inherit from the AssemblyParser interface . The AssemblyParser interface  has a dependency on the PropertiesParser interface  and the SoftwarePackageParser interface . These types of dependencies can be used in building up Partitions. The DCD CORBA structure  and the SAD CORBA structure  each uses information from the AssemblyParser interface .","In addition, as will be appreciated by those of skill in the art, the first UML class diagram  of  updates and modifies in several places the middleware layer parser interfaces definitions shown in  of the aforementioned '020 patent in several ways. For example, the optimized CF_Parsers_IDL  of  of the instant application advantageously only has the bare minimum behavior needed for decoding the SAD, DCD, and DMD and retrieving the information, whereas the CF_PreParsers  (of ) includes all the information needed to parse the various XML files. Further, one of skill in the art will recognize that because details regarding at least some of the elements within the interfaces are explained further in the aforementioned, incorporated-by-reference SCA specification, these details are not repeated here in every instance, for purposes of clarity. In addition, details and implementation of the interfaces and elements shown in  is further illustrated in the files included with the computer program listing appendix that form part of this application.","Referring briefly to , at a high level, in the second UML diagram  of , the CF_PreParsers CORBA Module Interfaces include a Parser interface , an AssemblyParser interface , a CF_Parsers::AssemblyParser interface  (which is the same as the Assembly Parser interface  of ), a PropertiesParser interface , a CF_Parsers::PropertiesParser interface  (which is the same as the PropertiesParser interface  of ), a SoftwarePackageParser interface , a SoftwareAssemblyParser interface , a DomainManagerConfigurationParser interface , a DomainManagerConfigurationParser interface , a PackageParser interface , a DevicePackageParser interface , and a SoftwareComponentParser .","In , the AssemblyParser interface , the PropertiesParser interface , the SoftwareComponentParserinterface , the PackageParser interface  and the DomainManagerConfigurationParser  each inherit from the Parser interface  (each of these elements is explained further below). The SoftwareAssemblyParser interface  and the DeviceConfigurationParser interface  each inherit from the AssemblyParser interface . The SoftwarePackageParser interface  and the DevicePackageParser interface  each inherit from the PackageParser interface .","As illustrated in , the preParseFile of the Parser interface , in accordance with one embodiment of the invention, includes additional parameters for the Target Environment and Device allocation property definitions (e.g., the supplied target dependencies, including device dependencies). Further, the Parser interface  of  (CF_PreParsers\/Offline Environment) is somewhat similar to the Parser interface  of  (CF_Parsers\/Embedded Environment), but is adapted, of course, for the Offline Environment and, for example, can use different methods. For example, in , the Parser interface  defines the common attributes and operations for all CORBA parsers. The parseFile method used in the Parser interface  of  parses the input file and verifies that the input file is well formed and valid encoded file. In , the PreParseFile method of the Parser interface  of  calls the offline XML parser (e.g., Xerces parser ) to parse the SCA XML files  (e.g., so as to be used during formation of the aforementioned CORBA structures).","Similarly, the AssemblyParser interface  of  (CF_Parsers, Embedded Environment) is somewhat similar to the AssemblyParser interface  of  (CF_PreParsers, Target Environment), but each AssemblyParser interface is adapted for each environment. For example, the AssemblyParser interface  of  of  each contains common operations and attributes for retrieving common elements that an assembly type (e.g., DCD and SAD) file consist of and has common elements such as partitions and connections elements. In , the AssemblyParser interface  includes further methods and also uses definitions from the AssemblyParser interface  of the Embedded Environment of  (e.g., via the CF_Parsers::AssemblyParser interface ). That is, the AssemblyParser interface  of  depends on the CF_Parsers::AssemblyParser interface , where the AssemblyParser interface  is a member function of the CF_Parser class of .","The AssemblyParser interface  of  includes several methods\/operations, all further described in the included CF_PreParsers_IDL.doc in the Computer Program Appendix. The componentInitialConfigProperties operation returns the set of configuration properties that are used for the initial configuration of this component after execution. The properties returned have been converted to the proper CORBA types from their string types (found in XML). The conversion is based on the type attribute defined in the SimpleType. The getComponentExecuteProperties operation returns the set of execute properties that are used for executing a component. The properties returned have been converted to the proper CORBA types from their string types (found in XML). The conversion is based on the type attribute defined in the SimpleType.","The getComponentResourceFactoryProperties operation returns the set of properties associated with an instance of the resource and are to be sent to the resourceFactory when the instance is created. The properties returned have been converted to the proper CORBA types from their string types (found in XML). The conversion is based on the type attribute defined in the SimpleType. This operation adheres to the rules specified in SCA version 2.2\/2.2.2, section D.6.1.3.3, concerning precedence order.","Similarly, the PropertiesParser  of  and the PropertiesParser  of  are somewhat similar, but each is adapted for the respective environment, i.e., the Embedded Environment for the PropertiesParser  of  and the Offline Environment for the PropertiesParser  of . The PropertiesParser ,  of  is an interface for a property file (.prf) parser. A property file can be referenced by a Software Package Descriptor  (SPD; see ) or Software Component Descriptor (SCD; see ) XML file or a Device Package Descriptor  (DPD; see ) XML file. The SPD describes implementation(s) of a specific component. The SCD describes as CORBA-capable software component and its interfaces. The Device Package Descriptor identifies a class of device. The PropertiesParser interface  of  inherits from the CF_Parsers::PropertiesParser interface  (i.e., uses definitions from the PropertiesParser  of the Embedded Environment of ). A property file can be referenced by an assembly, component, or component instantiation and contains property elements.","The SoftwarePackageParser interface  of  and of  is part of an XML parser interface for a Software Package Descriptor (SPD) parser. The SPD is used at deployment time to load and execute an SCA compliant component and its various implementations.","Referring again to , the SoftwareAssemblyParser interface  (of  (of ) defines the operations to parse and retrieve information from a Software Assembly Descriptor (SAD) XML file that conforms to the SAD DTD. As with the other interfaces that are present in both the Offline and Embedded environments, each SoftwareAssemblyParser interface  (of  (of ) is tailored to the environment (Embedded or Offline) in which it is implemented. The SAD describes the deployment characteristics and connectivity of components. The SoftwareAssemblyParser interface \/ extends the AssemblyParser interface  by adding specific behavior and types for a SAD DTD, including several attributes. In , the SoftwareAssemblyParser interface  is used by the optimized CF_Parser  to parse the data in a SAD CDR file created by the Optimized CF_PreParsers . The readonly assemblyControllerId attribute corresponds to the SAD DTD assemblycontroller element within the SAD file. The readonly externalPorts attribute corresponds to the SAD DTD externalports element with the SAD file. This attribute is an optional element within the SAD DTD, therefore an empty set is valid.","In addition, as noted below, for the SoftwareAssemblyParser interface  of , (like the DomainManagerConfigurationParser interface , described below), the local interface can have a compiler directive if needed. CORBA inherently has a local interface mechanism. The Optimized CF_Parser  described herein is intended to reside within the SDR system  (), but, the Optimized CF_Parsers  can be local or remote (i.e., non-local), that is, the Optimized CF_Parsers  can have local or remote distribute behavior between the client and optimized CF_Parsers  components (e.g., between the SDR client  and the SDR software component ). For example, the Optimized CF_Parsers , in one embodiment of the invention can be co-located with an SDR client (e.g., SDR client  of ) that is calling the parsing behavior. Being \u201ccollocated\u201d or \u201clocal\u201d means that the SDR client  and the optimized CF_Parsers  are in the same operating system process\/partition. If that is the case, then the Optimized CF_Parsers  has local behavior. If, however, the SDR client and the Optimized CF_Parsers  are remote (such as when the Optimized CF_Parsers  is in a different operating system process\/partition than the SDR client ), then the optimized CF_Parsers  behavior is said to be remote service and client's CF_Parsers are marshaled CORBA requests.","Referring to , the DeviceConfigurationParser interface  (),  () defines the operations to parse and retrieve information from a Device Configuration Descriptor (DCD) file. The DCD  identifies components that will initially start on a device, information about the devices associated with a device manager and how to find the domain manager, as well as the configuration information for a device. As with the other interfaces that are present in both the Offline and Embedded environments, each DeviceConfigurationParser interface  (of  (of ) is tailored to the environment (Embedded or Offline) in which it is implemented. For example, in , the DeviceConfigurationParser interface  extends the AssemblyParser interface  and Parser interface  by adding specific behavior and types for a DCD DTD. In addition, in the Embedded environment of , the DeviceConfigurationParser  is used by the optimized CF_Parsers  to parse the data in a DCD CDR file created by the optimized CF_PreParsers . The domainmanager element of the DeviceConfigurationParser interface  of  indicates how to obtain the CF::DomainManager object reference. The filesystemames element of the DeviceConfigurationParser interface  of  indicates the mounted file system names for CF::DeviceManager's FileManager. The devicemanagersoftpkg element of the DeviceConfigurationParser interface  of  refers to the SPD  for the CF DeviceManager.","In addition, in one embodiment, the DeviceConfigurationParser interface \/ can include an optional (not illustrated in  or ), read-only, connections attribute, which the attribute corresponds to the DCD DTD connections element within the DCD file . This is illustrated, indirectly in  by inheritance: the DeviceConfigurationParser interface  inherits from the Assembly Parser interface , which inherits from CF_Parsers::AssemblyParser . This attribute is an optional element within the DCD DTD, therefore an empty set is valid. The connections attribute is intended to provide the connection map between components in the assembly.","Still referring to , the DomainManagerConfigurationParser interface  ( () defines the operations to parse and retrieve information from a DomainManager Configuration Descriptor (DMD) XML file  that conforms to the DMD DTD. As with the other interfaces that are present in both the Offline and Embedded environments, each DomainManagerConfigurationParser interface  (of  (of ) is tailored to the environment (Embedded or Offline) in which it is implemented. The DomainManagerConfigurationParser interface \/ extends the Parser interface \/ by adding specific behavior and types for a DMD DTD. The services type of the DomainmanagerConfigurationParser interface  of corresponds to the service element definition in the DMD DTD. It's used by the CF DomainManager to determine which service (Log, etc.) instances to use; it makes use of the service element in the DTD.","Referring to , the PackageParser interface  contains operations and attributes for retrieving common elements that an XML package type (e.g., Device Package Descriptor (DPD) , Software Package Descriptor (SPD) file ) consists of, such as author and title elements. The DPD  identifies a class of device.","Other embodiments can, of course, include additional interfaces and classes. For example, in one embodiment there is a PackageParser interface  that contains operations and attributes for retrieving common elements that an XML package type (e.g., DPD, SPD) file consists of, such as author and title elements. The SoftwarePackageParser  inherits from the PackageParser , and the SoftwarePackageParser  parsers and SPD .","As noted above,  also illustrate how an IDL Compiler directive can control whether the CF parser IDL interface is local or not. The ability to provide a local interface in the optimized CF_Parsers  is optional, and providing a local interface for the optimized CF_Parsers  is done for certain interfaces in cases where the Device Manager is not collocated with the Domain Manager. For example, in the exemplary embodiment of , an optional new constraint, namely the islocal=True\/False, is added to each of the SoftwareAssemblyParser interface  and DomainManagerConfigurationParser interface . This UML constraint is controlled by an IDL Compiler Directive, which controls whether the particular interface is local or not. In , the constraint is Local is set to TRUE. The local interface is controlled by compile directive:",{"@attributes":{"id":"p-0184","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#ifdef CORBA_LOCAL"]},{"entry":[{},"\u2003local"]},{"entry":[{},"#endif"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If the CORBA_LOCAL symbol is defined then local is used. The IDL compiler option allows for a symbol to be defined during compilation. That is, the compile directives allows choices when compiling the IDL, so generated code can be generated differently depending on the CORBA_LOCAL being defined or not.","For example, in one embodiment, the local interface feature is implemented via a modification to the CF_Parsers at IDL compile time. In such an embodiment, the SCA domain profile includes a set of SCA XML files and corresponding CORBA encoded data files (CDRs), the set of CORBA CDRs including a Software Assembly Descriptor (SAD) CDR, a Domain Manager Configuration Descriptor (DMD) CDR and a Device Configuration Descriptor (DCD) CDR. Each CDR corresponds to a respective set of preparsed SAD, DMD, and DCD XML files, wherein each respective set of preparsed SAD, DMD, and DCD XML files is, advantageously, further configured to be substantially free of elements or operations that are not required for deployment in the CF. The CF_Parsers is in operable communication with the set of CORBA encoded data files and with a client. The CF_Parsers configured to convert, upon receiving request from the client, each respective SAD, DMD, and DCD CDR to a corresponding respective SAD, DMD, and DCD CORBA structure type that is usable in the CF. In the CF_Parsers, a selectable local interface is included for the DeviceManagerParser interface but can also be extended to other Parser interfaces. This selectable local interface is configured to be selectable, at the time of compiling, to operate in a local operational mode when the CF_Parsers, Domain Manager and Device Manager clients are in either the same operating system process or the same operating system partition. In addition, the selectable local interface is configured to be selectable, at the time of compiling, to operate in a remote distributive operational mode in one of the following two situations: (a) when the CF_Parsers and the clients are in different operating system processes from each other; and (b) when the CF_Parsers and the client are in different operating system partitions from each other.","Those of skill in the art will note that the aforementioned code listings in the incorporated-by-reference CD of computer program listings provide further details as to the particulars of the types, exceptions, input parameters, and methods of the various interfaces shown in the UML diagrams  and  of , respectively, as implemented in accordance with one or more exemplary and non-limiting embodiments of the invention, which listings will be readily understood by one of skill in the art.",{"@attributes":{"id":"p-0188","num":"0198"},"figref":["FIG. 9A","FIGS. 4 and 5A","FIG. 9B","FIG. 10A","FIGS. 4 and 5A","FIG. 10B","FIGS. 11 and 12","FIG. 11","FIGS. 9A-9B","FIG. 12","FIGS. 10A-10B","FIGS. 9A-12"],"b":["450","114","214","206","207","207","500","114","110","600","110"]},"Although the following discussion uses the example of the SAD structure , the operations and signal flow discussed is, of course, applicable to the other CORBA structures (i.e., the DCD structure  and the DMD structure ), as will appreciated by those of skill in the art.","Referring now to , A, B, and , per \u201cstep \u201d of , the OfflinePreParsers Tool  of  (which includes, for example, the DCD, DMD, and SAD PreParsers , , ) sends a message, preParseFile, to the CF_PreParsers::SoftwareAssemblyParser  to Parse XML files using existing CORBA PreParsers interface (step  of ) that is on top of the COTS XML Parser, including parsing all SAD, SPDs, SCDs, and Properties SCA XML files. To accomplish this, the CF_Preparsers::Parser sends a call, preParseFile( ) to open( ) and read( ) the Target Environment Implementation Definitions (TEID) (e.g., step A of  and blocks ,  of ), and the CF_PreParsers::SoftwareAssemblyParser  sends a call, parseSCA_XMLFile( ) to the COTS XML Parser  (e.g., step B of , step  of ). As discussed above, the TEID  includes information that tells the CF_Preparser  about the target environment, so that the CF_Preparser  can determine the device definitions being used and can put the pre-parsed information into the correct format. All SAD, SPDs, ADD, SCD, and Properties SCA XML files  are parsed (step  of ), in accordance with the TEID .","The parsed XML data is received (step  of ) at the CF_PreParsers CORBA Interfaces (i.e., the interfaces in the UML diagram  of ). The information from the parsed XML data is collapsed\/converted into a new CORBA parser structure type (step ), such as a SAD, DCD, and\/or DMD structure (step ), as was discussed above in connection with . The information used to form up the CORBA CF_Parsers structure (which by way of example in  is a SAD structure) is shown in  next to the corresponding UML note (e.g., id( ), name( ), partitions( ), etc.), as was discussed previously above.","Still referring to . A, B, and , and particularly to , the CORBA parser structure type is converted into a CORBA_Any type (step ), using the generated Any operator that the compiler generates. As is known in the art, a CORBA Any is a container type that can represent any possible basic or constructed type. For example, as shown in , the Offline PreParsers Tool  uses the <<=Any insertion operation to insert the SAD into a CORBA_Any. A CORBA encode operation is done to convert the CORBA_Any into an octet sequence (step ), using a CODEC  obtained (step ) from a call to the CORBA CODEC FACTORY  (step ). For example, in , the OfflinePreParsers Tool  sends calls create_codec( ) to the CORBA Codec Factory  and encode( ) to the CODEC  to encode the Any into an octet sequence. Note that each CORBA structure has two CORBA Any operators generated by the IDL compiler for extracting from an Any and placing into an Any. Referring again to . A, B, and , the CORBA encoded octet sequence is written to File  (step A of , step  of ), such as via the Offline PreParsers Tool  sending a write( ) call to File . The File  is, advantageously, in the form of a CORBA encoded data (CDR) file . As noted above, this file is accessible to the Embedded CF_Parsers .","Referring now to , A, B, and , (the Optimized CF_Parsers (also referred to as Embedded CF_Parsers) Install Application Illustration), a call is made (step  of , step  of ) to the optimized CF_Parsers A to parse the encoded CORBA file (i.e., the octet sequence written to file in step  of ). For example, referring to , this is accomplished, in one embodiment by the SCA CF Domain Manager  sending a call parseFile( ) to the CF_Parsers::SoftwareAssemblyParser , then the CF:Parsers::SoftwareAssemblyParser sending an open( ) call to the File . The octet sequence is read in (step  of , step  of ), such as via the CF_Parsers::SoftwareAssemblyParser  sending a read( ) call to the File . A call is made to the CODEC factory  to retrieve a CODEC  (steps ,  of ), such as via the CF_Parsers:SoftwareAssemblyParser  parseFile  sending a create_codec( ) call to the CORBA CODEC Factory . The octet sequence is decoded, advantageously using the CODEC , to form the CORBA Any (step ). For example, this can be accomplished by the CF_Parsers:SoftwareAssemblyParser  parseFile sending a decode( ) call to the CODEC .","The CORBA Any operator is used to convert the CORBA Any into a CORBA CF_Parsers structure type (step ). For example, this can be done by the CF_Parsers::SoftwareAssemblyParser  calling the Any extraction operation on the CF_Parsers::SAD , to extract a given structure type (e.g., SAD structure ) from the CORBA_Any. The information from the optimized CORBA CF_Parsers Interfaces is then retrieved (step ), such as id( ), name( ), partitions( ), etc.","Thus, as shown and described in  herein, through the use of CORBA local interfaces, CORBA encoding for CORBA deployment types (SAD, DCD, DMD) and the removal of XML parser, as described herein, more efficient operation can be achieved. Further, as shown and described above, the CORBA CODEC mechanisms are used to implement and SCA system in which, effectively, a CORBA parser replaces the XML parser. The inventors propose that using a CORBA parser to replace the XML parser, as is shown herein for the SCA embodiments, provides significant improvements to any systems where XML parsing is used, including but not limited to SDR systems like the SCA SDR. For example, it is proposed that use of a CORBA parser, as described herein, reduces code size, improves parsing speed, and requires less processing overall.","As those skilled in the art will recognize, the various embodiments invention described herein can be modified to accommodate and\/or comply with any many different technologies and standards, including particularly future SCA standards, including but not limited to SCA Next. In addition, variations, modifications, and other implementations of what is described herein can occur to those of ordinary skill in the art without departing from the spirit and the scope of the invention as claimed. Further, virtually any aspect of the embodiments of the invention described herein can be implemented using software, hardware, or in a combination of hardware and software.","It should be understood that, in the Figures of this application, in some instances, a plurality of system elements or method steps may be shown as illustrative of a particular system element, and a single system element or method step may be shown as illustrative of a plurality of a particular systems elements or method steps. It should be understood that showing a plurality of a particular element or step is not intended to imply that a system or method implemented in accordance with the invention must comprise more than one of that element or step, nor is it intended by illustrating a single element or step that the invention is limited to embodiments having only a single one of that respective elements or steps. In addition, the total number of elements or steps shown for a particular system element or method is not intended to be limiting; those skilled in the art will recognize that the number of a particular system element or method steps can, in some instances, be selected to accommodate the particular user needs.","It should also be appreciated that the UML diagrams, block diagrams, and flow charts provided herein do not depict the syntax of any particular programming language (although in some instances methods from C++, CORBA IDL and\/or Java programming language have been provided by way of example). Rather, the flow diagrams and flow charts illustrate the functional information one of ordinary skill in the art requires to fabricate circuits or to generate computer software to perform the processing required of the particular apparatus. It should be noted that many routine program elements, such as initialization of loops and variables and the use of temporary variables are not shown. It will be appreciated by those of ordinary skill in the art that unless otherwise indicated herein, the particular sequence of steps described is illustrative only and can be varied without departing from the spirit and scope of the invention.","Those skilled in the art will appreciate that computer systems embodying the present invention need not include every element shown in , and that equivalents to each of the elements are intended to be included within the spirit and scope of the invention. For example, the computer system  need not include the tape drive , and may include other types of drives, such as compact disk read-only memory (CD-ROM) drives, universal serial bus (USB) drives, and any other type of removable media onto which information can be stored. CD-ROM drives can, for example, be used to store some or all of the databases described herein.","Systems and methods in accordance with the invention can be implemented using any type of computer system running any one or more types of operating systems (including, by way of illustration and not limitation, the target embedded environment  and Linux Offline environment , described further herein). Exemplary types of computer systems on which at least some embodiments of the invention can be embodied include any system or device having a processor (or equivalent processing functionality) installed or embedded, including but not limited to a desktop computer, personal computer (PC), laptop computer, notebook computer, tablet computer, handheld computer, netbook, personal digital device (including but not limited to personal digital assistant (PDA), mobile communications device (including but not limited to radio, conventional telephone, mobile\/cellular telephone, smart phone, music playing device, electronic reading device) server, workstation, and interconnected group of computers, as well as any other type of device having a microprocessor installed or embedded thereto, such as a field-programmable gate array (FPGA).","In at least one embodiment of the invention, one or more computer programs, such as those further described herein, define the operational capabilities of the computer system . These programs can be loaded into the computer system  in many ways, such as via the hard disk drive , the floppy disk drive , the tape drive , a CD-ROM drive, a USB drive, or via the network interface  (e.g., wirelessly, via the Internet, etc.) Alternatively, the programs can reside in a permanent memory portion (e.g., a read-only-memory (ROM)) chip) of the main memory . In another embodiment, the computer system  can include specially designed, dedicated, hard-wired electronic circuits that perform all functions described herein without the need for methods from computer programs.","In at least one embodiment of the present invention, the computer system  is networked to other devices, such as in a client-server or peer-to-peer system. The computer system  can, for example, be a client system, a server system, or a peer system. In one embodiment, the invention is implemented at the server side and receives and responds to requests from a client, such as a reader application running on a user computer. The computer system can be implemented as part of, controlling, or in operable communication with a terminal, personal computer, mainframe computer, workstation, hand-held device, electronic book, personal digital assistant, peripheral device, notebook computer, a handheld computing device (e.g., a PDA), an Internet appliance, a telephone, an electronic reader device, an SDR, or any other such device connectable to the computer network.","In addition, software embodying the present invention, in one embodiment, resides in an application or other program running on the computer system . In at least one embodiment, the present invention is embodied in a computer-readable program medium usable with the general-purpose computer system . In at least one embodiment, the present invention is embodied in a data structure stored on a computer or a computer-readable program medium. In addition, in one embodiment, the present invention is embodied in a transmission medium, such as one or more carrier wave signals transmitted between the computer system  and another entity, such as another computer system, a server, a wireless network, etc. The present invention also, in an embodiment, is embodied in an application programming interface (API) or a user interface. In addition, the present invention, in one embodiment, is embodied in a data structure.","Further, in describing the embodiments of the invention illustrated in the figures, specific terminology is used for the sake of clarity. However, the invention is not limited to the specific terms so selected, and each specific term at least includes all technical and functional equivalents that operate in a similar manner to accomplish a similar purpose."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["The advantages and aspects of the present invention will be more fully understood in conjunction with the following detailed description and accompanying drawings, wherein:",{"@attributes":{"id":"p-0082","num":"0092"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0083","num":"0093"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0084","num":"0094"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0085","num":"0095"},"figref":["FIG. 3B","FIG. 3A"]},{"@attributes":{"id":"p-0086","num":"0096"},"figref":["FIG. 4","FIGS. 3A and 3B"]},{"@attributes":{"id":"p-0087","num":"0097"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0088","num":"0098"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0089","num":"0099"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0090","num":"0100"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0091","num":"0101"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0092","num":"0102"},"figref":["FIG. 9A","FIG. 4"]},{"@attributes":{"id":"p-0093","num":"0103"},"figref":["FIG. 9B","FIG. 9A"]},{"@attributes":{"id":"p-0094","num":"0104"},"figref":["FIG. 10A","FIG. 4"]},{"@attributes":{"id":"p-0095","num":"0105"},"figref":["FIG. 10B","FIG. 10A"]},{"@attributes":{"id":"p-0096","num":"0106"},"figref":["FIG. 11","FIGS. 9A and 9B"]},{"@attributes":{"id":"p-0097","num":"0107"},"figref":["FIG. 12","FIGS. 10A and 10B"]},{"@attributes":{"id":"p-0098","num":"0108"},"figref":"FIGS. 13A-13B"},{"@attributes":{"id":"p-0099","num":"0109"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0100","num":"0110"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0101","num":"0111"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0102","num":"0112"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0103","num":"0113"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0104","num":"0114"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
