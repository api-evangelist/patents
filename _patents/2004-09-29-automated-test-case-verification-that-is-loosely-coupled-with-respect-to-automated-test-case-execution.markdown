---
title: Automated test case verification that is loosely coupled with respect to automated test case execution
abstract: A system and method for verifying the systemic results of an action applied to an application and for providing the expected state of the application at any time or on demand, in which a verification manager determines an expected application state and a current application state of the application, a test case in communication with the verification manager executes the action, and the verification manager compares the expected application state and the current application state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07823132&OS=07823132&RS=07823132
owner: Microsoft Corporation
number: 07823132
owner_city: Redmond
owner_country: US
publication_date: 20040929
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["This application is related to U.S. patent application Ser. No. 10\/953,238, entitled \u201cSystem and Method for Selecting Test Case Execution Behaviors for Reproducible Test Automation,\u201d filed herewith on Sep. 29, 2004 and U.S. patent application Ser. No. 10\/953,402, entitled \u201cTest Automation Stack Layering,\u201d filed herewith on Sep. 29, 2004.","The invention relates to software for testing applications and in particular to a loosely coupled comparison of expected and actual results in such testing software.","The major stages in the life cycle of software development are the design phase, the coding phase, the code complete phase, the alpha phase, the beta phase, and finally, release to market. During the design phase, the customer problems the software product will address and the functionality of the software product is defined. Typically, the completion of the functional specification marks the end of the design phase. The coding phase may already have begun. The code complete phase is reached when the code has been written but is not necessarily debugged. The alpha phase marks the point in time when the product is stable; that is, most of the major bugs have been found. In the beta phase, the product is ideally free of all major bugs; the only bugs remaining should be essentially harmless. When the product passes a final quality assurance checklist, it is ready for release to market.","As no one wants software that does not work, testing is an important part of the life cycle and can span several phases. Software testing involves devising a test case (or, more likely, a set of test cases), running the software with the test case as input, and checking that the performance of the software with the test case as input yields the expected results. Software testing can be conducted manually by humans or programmatically, referred to as automated software testing. Ideally, testing of the software should begin as soon as possible in the life cycle of the software. Generally, however, the software cannot be tested at all until the design phase has been completed, because until the design phase is complete, expected results cannot be determined. Typically, during the coding phase, the developer manually tests his code as he writes it. Automated software testing usually cannot begin until far later in the development process.","Sometimes, the only testing that is conducted is done by the developer who manually tests as he codes. A developer who tests his own work, however, is likely to overlook bugs that someone not so emotionally invested in the code will find. Furthermore, the scope of the developer's testing is typically limited to the functionality of his code and integration of his code with a limited number of other software applications.","To address these shortcomings, many software development houses have a separate software testing group that also tests the software, often using at least partially-automated testing techniques. Typically, the testing group tests complex interactions across features and across applications by writing and running test cases. It is generally agreed that involving the testing group early in the product life cycle, even as early as the design phase, reaps many benefits, including identification of inconsistencies in the functional specification, identification of hard-to-test areas and others. In general, however, the effort required to keep each test case current in the face of continued changes in feature definition, implementation and user interface (UI) tuning renders this approach impractical. Hence, writing and running test cases is typically a hurried matter that occurs at the tail end of product development. Testing and in particular, automated testing, thus tends to be perpetually behind the curve. It would be helpful if there were a way to write test cases and employ automated testing as soon as possible in the life cycle of a software product, ideally during the design phase.","Development of a suite of test cases is a challenge whenever it occurs. To test a specific feature of an application, numerous sets of tests must be written. For example, an application may permit many modes of interaction with a feature: via a mouse, keyboard, digitizer, accessibility software, programmatically, and so on. Therefore, to provide a comprehensive test for the feature, a suite of tests should include a set of tests interacting with the feature via the mouse (typing text just like a user might); one set interacting with the feature via keyboard, one set interacting with the feature via digitizer, one set interacting with the feature via accessibility software to invoke default actions and otherwise mimic an accessibility application, one set interacting with the feature via the application's coding model, and so on. It would be helpful if there were a way to make sure that the suite of test cases produced provided a comprehensive test of the feature or application and further, to decrease the total number of test cases that must be written to provide that comprehensive test.","Furthermore, much or all of the logic in each of these sets of test is identical to the logic in the other sets of tests and typically, much or all of the verification of results processing is identical as well. Hence, many tests are identical or very nearly so, merely varying execution options. For example, for all the multiple forms of input described above, the expected results are likely identical. Hence, writing a test case for each of these input sources typically requires writing a separate method for executing the test for each of the input sources, and duplicating most of the rest of the test script. Writing the same test over and over again with minor variations is tedious and time-consuming. It would be helpful if there were a way to eliminate or significantly reduce this duplicative coding and to reduce the total number of test cases that must be written.","Code written to determine if the actual results of running the test case coincide with the expected results (called verification of results, or verification) is often included within the test case. Changing the details of a particular result verification or adding new result verification typically requires the modification of each test case. It would be helpful if verification code were separate from the test case, making the test case easier to understand, and the verification code easier to reuse and to maintain.","Execution details are often hard-coded into the test case, requiring the design phase to be complete before the test case is written. It would be helpful if there were a way to define test cases in terms of user actions rather than in terms of specific execution details so that test cases could be written earlier in the software development life cycle. Testing an application is a crucial step in the initial development of the application. Testing an application is also very important when implementing modifications to the application. Developers, scientists, manufacturers and the like exert much effort in the testing phase. Such testing helps ensure that the application responds in an expected manner to a specific stimulus. The testing is typically completed through execution of test cases and verification of the results of test case execution.","A test case typically imposes a stimulus on an application. A test case should also verify that the application responded in an expected manner and did not respond in an unexpected manner. To be comprehensive, a test should verify much of the entire application state to ensure that the stimulus caused expected results and no unexpected results.","A test case is typically executed for the purpose of testing a specific function or aspect of an application. Likewise, the verification of the results of the test case may focus on the function intended to be tested. The execution of the test case, however, may affect or change other aspects of the application state. Such aspects may seem tangential to the purpose of the test case. These tangential aspects may be numerous, and it may be difficult for the tester developing the test case to quantify or specify all or even most of them.","Writing test case code to verify much of the application state has proved problematic for a variety of reasons. Even for a relatively simple application, a vast number of test cases may be required to comprehensively test the application. Adding lengthy and detailed verification code to each test case would be a daunting if not insurmountable task. Additionally test case maintenance is usually as labor-intensive and time-consuming as (if not more than) test case creation. When an application is altered, the test cases as well as the verification code should be altered to ensure continued compatibility with the application. Adding lengthy, comprehensive verification coding to each test case would make such maintenance impractical if not impossible.","Therefore, there is a need to comprehensively verify results of test cases applied to applications without requiring voluminous, tedious, and time-consuming verification code to be written with each test case. There is also a need for verification that requires minimal explicit actions by the tester to setup, execute, or maintain.","The verification of test case implementation may be separated from the test cases and may be completed by a dedicated verification manager. The test cases may not need to include any verification and, indeed, the tester need not even know all of the verification that is being performed. The verification manager may be used to verify one or more test cases such that each test case may execute an action without providing for specific verification of the results of the action.","With a dedicated verification manager, verification may be more comprehensive. The verification manager may more comprehensively verify the results of test cases using a large library of expected state generators. Each expected state generator contained in the library may be focused on various separate and different components of an application. One expected state generator may focus on an aspect of the application state that the tester may consider particularly pertinent to the purpose of the test case. A second expected state generator may focus on an aspect of the application that the tester may consider tangential or unrelated to the purpose of the test case. Therefore, instead of having focused verification included in a test case, the library may enable broad verification for all test cases.","The verification manager may verify test case results by comparing expected values of specified application properties against the actual values of those same properties. In doing this comparison, the verification manager will be able to determine instances where the current and expected application states do not substantially align. Finally, the verification manager may communicate any test failures to the test case, the test case executor, or any other designated entity.","The verification process may be completed such that a test case may not even know, for example, that the state of a button on a file menu has been verified when the test case calls for a graphics application to draw a blue rectangle. In gaining this comprehensive verification, no action is required of the tester except to execute the action with appropriate parameters.","Further, maintenance of test cases is minimized or eliminated when the verification is updated or altered. For example, when an application is updated or otherwise altered, the verification manager or expected state generators may likewise require revision to ensure continued conformity with the application. Because the verification may be separated from the test case, the test case may not require any maintenance.","Additionally, when a test case results in a failure of a particular component of an application, further test cases may be executed without continually receiving notification of the same failure. This ability provides an opportunity to take a failure into account and continue testing the application.","Overview","In an example embodiment of the invention, the verification process is separated from the test case. Each verification element, called an expected state generator, may be stored in a dedicated device, called a verification manager. By separating each verification process from the individual test cases, each test case may be more comprehensively verified without the necessity of duplicating verification code in each test case. Additionally, the verification manager may comprise numerous expected state generators, each operating independently of the others and each calculating an expected state of one or more components of the application. Verification may be completed offline\u2014that is, at a time other than during test case execution and\/or online, or during test execution.","Expected state generators may be embedded in the local verification framework or may be independent objects dynamically loaded, enabled and disabled at runtime. Such expected state generators may be loaded from a database or a network location. In essence, the expected state generators could be plug-ins to the verification framework.","Separating the verification from the individual test cases enables more comprehensive testing of applications. Moreover, having a dedicated verification manager allows test cases to be verified without requiring verification code to be included in each test case. Because verification code is not included in each test case, when verification algorithms are altered to correspond to a modification in an application, such alterations do not affect the test cases. Therefore, separating verification from test cases may reduce the required maintenance on the test cases.","Example Computing Environment",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer or tester, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers (e.g., client workstations, servers, or other devices). Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. An embodiment of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an example system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes volatile and nonvolatile, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, random access memory (RAM), read-only memory (ROM), Electrically-Erasable Programmable Read-Only Memory (EEPROM), flash memory or other memory technology, compact disc read-only memory (CDROM), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, radio frequency (RF), infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as ROM  and RAM . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data . RAM  may contain other data and\/or program modules.","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the example operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit -through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client devices can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.","System and Method for Test Case Verification that is Loosely Coupled with Respect to Test Case Execution",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2","FIG. 1"],"b":["1","1","110","1","30","20","35","36","37","31","10","10","10","10","10","10"]},"The application  may be tested by one or more test cases, represented in  by test cases , etc. The test cases -may be called for integration or functional testing. Integration testing tests the manner in which two or more interacting components combine, work together, and affect each other. In functional testing, the test case focuses on a specific functional behavior of a test case.","In general, each test case -includes a well-defined action with well-defined parameters to be applied to the application . The test cases -may each comprise one or more steps to be executed by the application . Each of the test cases -may be one or a series of tests applied to the application . Test cases -may be written in any appropriate programming language such as, for example, C, C#, C++, Pascal, object-oriented languages, and the like. A test case -or a combination of test cases -may, for example, call for a graphics application to draw a blue rectangle on a document that contains other shapes of various colors. The test cases -also may be unrelated to computer programming language. For example, the test case may call for the manual release of a  pound maul suspended four feet above and at a 30\u00b0 angle to a doorknob attached to a door. It will be understood that the graphics application, doorknob application, and any other examples provided throughout this specification in no way limit the claimed scope of the application and instead are only illustrative embodiments described to facilitate understanding.","The test cases -, shown in  each may test a different aspect of the application . It should be understood that the test cases -merely represent potential test cases, and that there may be any number of test cases -to test the application . Additionally, it should be understood that each of the test cases -may be executed at the same time or at different times. Additionally, it should be understood that, for example, the test case may be executed once while the test case may be run ten times. Additionally, it should be understood that the test cases -may be executed by the tester. In an alternative embodiment, the test cases may be executed by a test case executor or similar device.","In one example embodiment of the invention, the test cases -may be in direct communication with a verification manager . In an alternative embodiment of the invention, the test cases -may call other subroutines that communicate with the verification manager . The test cases -may not know how verification is completed. For example, if many test cases -need a blue rectangle, a subroutine may be written that draws a blue rectangle. This subroutine could communicate with the verification manager . The test cases -using this subroutine would know that the subroutine draws a blue rectangle but would not necessarily know the subroutine is communicating with the verification manager .","The verification manager  may include expected state generators -, a comparer , and expected application state and current application state data structures , . An expected state generator such as each of the expected state generators , etc., may be associated with one or more particular components, data points, or properties. For example, with regard to testing a graphics application in which one, some, or all of the test cases -call for the application  to draw a blue rectangle in a certain position, the expected state generators -may focus on different components of the application state. The expected state generator may focus on the color of the rectangle. The expected state generator may focus on the position of the rectangle. The expected state generator may focus on less obvious results from the running of the test cases -, such as the location of a triangle on the same document as the newly drawn blue rectangle. Alternatively, the expected state generators , may be combined in or replaced by a single expected state generator (not shown) concerned with the location of every shape on the document. The expected state generator may focus on the status of an unrelated option on the toolbar, such as an option to open a new document.","Also for example, if the test cases -individually or collectively test a doorknob attached to a door by hitting the doorknob with a maul, then the expected state generator may focus on the ability of the doorknob to turn. The expected state generators and may focus on an upper and lower hinge attached to the door, or may be combined in or replaced by a single expected state generator (not shown) concerned with the state of the hinge. Expected state generator may focus on the wood portion of the door surrounding the doorknob. Other expected state generators may focus on other areas of the application .","All of the expected state generators -may be called when one or more test cases -are applied to the application  or only one or some of the expected state generators -may be called. In one example embodiment, the expected state generators -may run independent of and therefore be loosely coupled with the test cases -. In this way, the test cases -need not specify to the verification manager which expected state generators -should be called during application of the test cases -. The test cases -, then, may not contain verification mechanisms. Indeed, the test case -may not be aware that any verification is to occur. The verification manager  may be responsible for verifying the results of the test case -and the purpose of the test cases -may be limited to applying a stimulus with specific parameters to the application .","Those skilled in the art will recognize, however, that a test case may, consistent with an example embodiment, contain verification coding. This may be the case particularly if the purpose of running a test case -is to determine if a specific problem has been rectified. In an alternative embodiment, the test case -could also specify one or more expected state generators -to be called and specify that certain other expected state generators -should not be used.","With the separation of verification from the test case -, the verification may be more comprehensive for a test case -. The verification manager  may include expected state generators -that previously may have been a part of individual test cases. For example, the verification manager  may contain the expected state generators -of prior art test cases -designed to test a graphic application's ability to draw a blue square, a red circle, a yellow triangle, or an ellipse, to use an option on a pull-down menu, to respond to various user inputs through use of a mouse or the keyboard, and the like. Each of these test cases would have included specific verification focused on the purpose of the actions of the test case. With a dedicated verification manager  containing the expected state generators , a test case -for drawing a blue rectangle in a graphics application can be more comprehensively verified. The verification manager  can call on the expected state generators  that are specific to the blue rectangle, a red square, a yellow triangle, a pull-down menu, inputs by mouse and by keyboard, and the like. In this way, a test case -that calls for drawing the blue rectangle may invoke expected state generators -to check the obvious and not-so obvious effects of the test case -on the application . The tester may not even know, for example, that the red circle is being verified when the blue rectangle is drawn. If the test results are such that the red circle remained unaffected by the test case -and if this was an expected result, then the tester and\/or test case may not know that the red circle was verified. If however, the red circle unexpectedly moved slightly, then the verification manager  could alert the tester that an unexpected result occurred.","Likewise, if the test case -involves hitting a doorknob attached to a door with a maul, then the verification process may include determining not only the effects of the test on the doorknob, but also on the door, door frame, hinges, and so forth.","Additionally, the verification of test cases -may remain largely unaffected if the application  is changed, updated, and the like. New versions of the application  may be created which could alter the way the application  works. The test case , accordingly, may need to change. For example, a test case -for testing a graphics application may require revision in how it calls for the drawing of a blue rectangle. Also for example, the test case -for testing a doorknob attached to a door may need to change the weight and height of a maul if a new doorknob to be tested has greater resiliency than previous versions. The expected state generators , however, each may not need to be altered. In the graphics application example, the expected state generators  may continue to check the location of a new blue square, and an existing red circle, yellow triangle, and ellipse in the same manner as before the application  was altered. Likewise, the expected state generators  may verify the doorknob, the door, the hinges, and the doorframe in the same manner as before the new doorknob was added and the test case  modified.","The expected state generators -may communicate via the verification manager  with a database . The database  may provide information to the expected state generators  so that the expected state generators may better be able to determine an expected state of the application  from the test case . For example, the test case -may involve hitting a door knob attached to a door with a maul. The expected state generator may determine the effect of the test case on a \u215b inch thick, 2-inch long brass hinge also attached to the door. In doing so, the expected state generator may query database  to retrieve information regarding, for example, the tensile strength of brass. In an alternative embodiment, each expected state generator  may be in communication with one or more databases  independent of the verification manager . Alternatively, each expected state generator  may retrieve or receive information from a pluggable component.","Expected state generators -may be in communication with a comparer . As shown in , the comparer  may be part of the verification manager . However, those skilled in the art will recognize that comparer  may be located outside the verification manager. In this case, the comparer may be in communication with the verification manager  and\/or with the expected state generators . The comparer  may compare an expected state data structure  with an actual state data structure .","More specifically, when one or more test cases -are about to be executed, the test cases -or a test executor may notify the verification manager . The verification manager  may take a snapshot of the present global state of the application. That is, the verification manager may make a copy in memory of the present values of the properties of the application. The verification manager  then may notify the expected state generators  of the pending test cases  to be run. In an example embodiment, only those expected state generators  that may be implicated in the test case -may be notified. In an alternative embodiment, all of the expected state generators  may be notified.","Based on the action and parameters of the action about to be executed and the verification manager's snapshot of the present global state, each expected state generator  calculates its expected outcome state with regard to a component of the application from the prospective execution of the test cases -on the application . For example, if the application  is a graphics application, and the test cases -collectively require the drawing of a blue rectangle, then each expected state generator  determines its expected application state with regard to this action. The expected state generator may determine that the outcome should include a rectangle. The expected state generator may determine that the rectangle should be blue. The expected state generator may be focused on a red circle away from the rectangle and may determine that its expected state should remain unchanged by the test case . Each expected state generator communicates this expected component state to the verification manager , and the verification manager  may place the data in an expected application state data structure  in the comparer . In this way, the verification manager  may have a global expected application state prior to the execution of the test cases -. Additionally, this means that the global expected application state may be determined at any time or on demand. Expected results from execution of a test case -may be deterministic. Alternatively expected results may be non-deterministic if the expected state generators -understand that non-deterministic results are acceptable.","Upon completion of the test case , the verification manager  may take another snapshot or make a copy in memory of the current values of the properties of the application. This snapshot may show the application's current global state. The current value of the properties may be stored in a current application state data structure . The comparer  then compares the expected application state data structure  with the current application state data structure . Any discrepancies indicate areas where further attention may be warranted. In an alternative embodiment, the data structures ,  may be sent to an appropriate vehicle for performing the comparison. For example, the comparison may be completed through the use of extensible markup language (XML).","Discrepancies between the expected and current application state data structures ,  may alert the tester and result in alternative conclusions. Discrepancies between the expected and current application state may indicate areas where the application  is not acting in an appropriate manner. In such cases for example, debugging of source code or changing the structure of a material may be required. That is, for example, if the test case -was intended to result in the drawing of a blue square and instead the test case -resulted in a red square being drawn, then the tester may be inclined to fix the application  and run the test case -again. If the tester is not the person developing the application, then the tester may notify the developer of the incorrect behavior\u2014the red square\u2014by logging a bug in a bug-tracking system, sending an email, walking over to the developer's office, or using some other notification system. Also for example, if the test case -was intended to result in a doorknob that continued to operate, but instead a maul that hit the doorknob knocked the doorknob off the door, then the tester may be inclined to use stronger fasteners to hold the doorknob to the door. Alternatively, if the tester is not also manufacturing the door, then the tester may recommend to the door manufacturer that stronger fasteners be used.","Discrepancies may also indicate that the expected application state of an expected state generator  was unrealistic. In such a case, an alteration to the expected state generator  may be warranted. For example, the application  to be tested may be a graphics application. One or more test cases -may include drawing a rectangle using a mouse. One or more expected state generators  then may expect a perfect rectangle to be drawn. If drawing a perfect rectangle with a mouse is not a realistic possibility in the application , the comparer  may indicate that the test failed because of imperfection in the resultant rectangle. The tester may then add a tolerance into the applicable expected state generators  to allow for an expected application state comprising an essentially rectangular but not quite perfect rectangle.","In an example embodiment, the expected state generators  may determine expected state based not only on the actions and parameters called for in the test case -but also on the current application state. This enables the verification manager  to take into account previous test case failures and determine expected state based on those failures. For example, a test case -may involve hitting a doorknob attached to a door with a maul. If in executing the test case, a hinge attached to the door is damaged, the verification of the hinge for future test cases -may not indicate a failure based on the previous damage. Instead, the verification manager  may determine the expected state of the hinge, taking into account the previous damage.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 3A","b":["200","205","20","30","30","20","20","20","30","210","30","32","20","32","30","32","20","215","32","20","20","32","30","36","35","32","30","220","30","225","20","20","20","230","20"],"i":["a","f","a","f ","a","f ","a","f ","a","f","a","f","a","f ","a","f ","a","f "]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 3B","FIG. 3A"],"b":["235","20","20","30","240","20","245","30","30","37","250","30","255","260","210","260"],"i":["a","f ","a","f "]},"The comparison of the expected and current state data structures ,  may be completed within the verification manager . Alternatively, the data structures may be serialized out to extensible Markup Language (XML) so that the comparison may be completed with XML. In such cases, the XML may compare the data structures ,  and send the results to the verification manager , the test case , or the test executor. In an alternative embodiment of the invention, the comparer  may be decoupled from the test case execution process. This decoupling may enable the comparison between the expected and current application states to be completed at a time unrelated to test case execution. In such event, the expected and current state data may be saved to a database or other data store, or saved in a computer memory.","In an example embodiment of the invention, the verification manager  may make notification of the results of the individual verification results, or may make notification in only those instances in which the expected and current application states data differ (i.e., when there has been a failure). The notification may take place some time after the test case has finished executing, and may come through an avenue completely unrelated to the test case. For example, the comparer  could e-mail verification results to a designated contact.","It should be recognized that, if the same test case -is executed again or if a different test case -is executed, all of the steps of the method  shown in  may not be required. For example, the verification manager  may contain in the comparer  the expected state data structure for the pending test case . If so, then the verification manager  may not need to obtain expected component state data from the expected state generators  prior to the test case -being executed. Therefore, not all steps of method  need be completed each time a test case -is executed.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 4","FIG. 2"],"b":["20","10","20","20","10","20","10","20","10","30","35","36","37","35","30","32","30","32","30","32","30","32","10","32","30","32","32","32","30","32","31"],"i":["a","f ","a","f ","a","f ","a","f ","a","f ","x","z ","t","z ","t","z ","a","b"]},"For example, if a test case -involves hitting a doorknob attached to a door with a maul, an expected state generator may determine the expected state of a hinge that is attached to the door. In doing so, the expected state generator may call on an expected state generator to report on a lower portion of the hinge. Likewise, the expected state generator may call on an expected state generator to report on an upper portion of the hinge. The expected state generator may combine the data in determining expected state, and communicate the combined data, at the appropriate times, to the verification manager . Additionally, if the expected state generator is to determine the effect of the test on an \u215b inch thick, 2-inch long brass hinge attached to the door, the expected state generator may query database to retrieve information regarding, for example, the tensile strength of brass.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Throughout the specification, two primary examples were provided, one dealing with a hypothetical graphics application and the other with a doorknob attached to a door. These specific examples were provided to enhance understanding. In no way is the present invention limited to a graphics application or an application involving a doorknob attached to a door. Moreover, present invention may be included in any test involving any application involving any process, machine, manufacture, composition of matter, program, software, hardware, device, mechanism, or material, or any improvement thereof. Therefore, the present invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of illustrative embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 3A-B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
