---
title: Index-based evaluation of path-based queries
abstract: Systems, methods, and computer program product embodiments are provided for path-based query evaluation. The embodiments include representing a markup language document as a descriptive catalog, and capturing relationships in the descriptive catalog as an index summary. The index summary is utilized for evaluating a path-based query.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08983931&OS=08983931&RS=08983931
owner: Sybase, Inc.
number: 08983931
owner_city: Dublin
owner_country: US
publication_date: 20111129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates generally to data processing environments and, more particularly, to a database system providing methodology for index-based evaluation of path-based queries requesting data from markup language documents.","Computers are very powerful tools for storing and providing access to vast amounts of information. Computer databases are a common mechanism for storing information on computer systems while providing easy access to users. A typical database is an organized collection of related information stored as \u201crecords\u201d having \u201cfields\u201d of information. As an example, a database of employees may have a record for each employee where each record contains fields designating specifics about the employee, such as name, home address, salary, and the like.","Between the actual physical database itself (i.e., the data actually stored on a storage device) and the users of the system, a database management system or DBMS is typically provided as a software cushion or layer. In essence, the DBMS shields the database user from knowing or even caring about the underlying hardware-level details. Typically, all requests from users for access to the data are processed by the DBMS. For example, information may be added or removed from data files, information retrieved from or updated in such files, and so forth, all without user knowledge of the underlying system implementation. In this manner, the DBMS provides users with a conceptual view of the database that is removed from the hardware level. The general construction and operation of database management systems is well known in the art. See e.g., Date, C., \u201cAn Introduction to Database Systems, Seventh Edition\u201d, Part I (especially, Chapters 1-4), Addison Wesley, 2000.","In recent years, applications running on database systems frequently provide for business-to-business or business-to-consumer interaction via the Internet between the organization hosting the application and its business partners and customers. Today, many organizations receive and transmit considerable quantities of information to business partners and customers through the Internet. A considerable portion of the information received or exchanged is in Extensible Markup Language or \u201cXML\u201d format. XML is a pared-down version of SGML (Standard Generalized Markup Language), designed especially for Web documents, which allows designers to create their own customized tags, enabling the definition, transmission, validation, and interpretation of data between applications and between organizations. For further description of XML, see e.g., \u201cExtensible Markup Language (XML) 1.0\u201d (Second Edition, Oct. 6, 2000) a recommended specification from the W3C, the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet (e.g., currently at www.w3.org\/TR\/2000\/REC-xml-20001006). Many organizations utilize XML to exchange data with other remote users over the Internet.","Given the increasing use of XML in recent years, many organizations now have considerable quantities of data in XML format, including Web documents, newspaper articles, product catalogs, purchase orders, invoices, and product plans. As a result, these organizations need to be able to efficiently store, maintain, and use this XML information in an efficient manner. However, this XML data is not in a format that can be easily stored and searched in current database systems. Most XML data is sent and stored in plain text format. This data is not formatted in tables and rows like information stored in a relational DBMS. To search this semi-structured data, users typically utilize keyword searches similar to those utilized by many current Internet search engines. These keyword searches are resource-intensive and are not as efficient as relational DBMS searches of structured data.","Organizations with data in XML format also typically have other enterprise data stored in a structured format in database management systems. Increasingly, database system users are demanding that database systems provide the ability to access and use both structured data stored in these databases, as well as XML and other unstructured or semi-structured data. In addition, users desire flexible tools and facilities for performing searches of this data.","One of the key roles of a database management system (DBMS) is to retrieve data stored in a database based on specified selection criterion. This typically involves retrieving data in response to a query that is specified in a query language. One current solution used in XML-based applications to query the contents of an XML document is XPath. XPath provides basic facilities for manipulation of strings, numbers and booleans. It uses a compact, non-XML syntax to facilitate use of XPath within URIs and XML attribute values. XPath operates on the abstract, logical structure of an XML document, rather than its surface syntax. XPath gets its name from its use of a path notation as in URLs for navigating through the hierarchical structure of an XML document. For further description of XPath, see e.g., \u201cXML Path Language (XPath) Version 2.0\u201d (Jan. 23, 2007), a recommended specification from the W3C, the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet (e.g., currently at http:\/\/www.w3.org\/TR\/XPath20\/).","The XPath query language is commonly used in Extensible Stylesheet Language Transformations (XSLT) to locate and to apply XSLT templates to specific nodes in an XML document. In general, an XPath expression specifies a pattern that selects a set of XML nodes. Thus, XPath queries are commonly used to locate and to process nodes in an XML document that match a specified criteria.","For example, a simple XPath query may take a form such as \/A\/B\/C to select C elements that are children of B elements that are children of the A element that forms the outermost element of the XML document. Selection may take on a more complex form, however, with construction of complex XPath expressions. More complex XPath expressions can be constructed, such as by containing other XPath query language constructs, e.g., filter, functions, parenthesis, union, intersection, etc., specifying an axis other than the default \u2018child\u2019 axis, a node test other than a simple name, or predicates. For example, the complex XPath expression A\/\/B\/*[1] should return the first element (as designated by the use of \u2018[1]\u2019), with any name (as designated by the use of \u2018*\u2019), that is a child (\u2018\/\u2019) of a B element that itself is a child or other deeper descendant (\u2018\/\/\u2019) of an A element that is a child of the current context node (the expression does not begin with a \u2018\/\u2019). When there are several suitable B elements in the document, a set of all their first children needs to be returned.","While XPath has been used as the query language for XML documents with some success, complex XPath querying is not handled effectively in current XML processing engines. One particular need is for a solution that will enable efficient and accurate searches of information in XML documents when queried using complex expression. The present invention addresses this need.","Briefly stated, the invention includes system, method, computer program product embodiments and combinations and sub-combinations thereof for path-based query evaluation. The embodiments include representing a markup language document as a descriptive catalog, and capturing relationships in the descriptive catalog as an index summary. The index summary is utilized for evaluating a path-based query.","Further embodiments, features, and advantages of the invention, as well as the structure and operation of the various embodiments of the invention, are described in detail below with reference to accompanying drawings.","The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings.","While embodiments are described herein with reference to illustrative embodiments for particular applications, it should be understood that the invention is not limited thereto. Those skilled in the art with access to the teachings provided herein will recognize additional modifications, applications, and embodiments within the scope thereof and additional fields in which the invention would be of significant utility.","Glossary","The following definitions are offered for purposes of illustration, not limitation, in order to assist with understanding the discussion that follows.","ASE: Sybase\u00ae Adaptive Server\u00ae Enterprise, an enterprise relational database system available from Sybase, Inc. of Dublin, Calif.","HTML: HTML stands for HyperText Markup Language, the authoring language used to create documents on the World Wide Web. HTML defines the structure and layout of a Web document by using a variety of tags and attributes.","Node: In the context of a markup language document (e.g., an XML document), a node corresponds to an element or value in the markup language document. Unlike conventional data in a database (e.g., relational database) which is maintained in a flat structure, information in a markup language document (e.g., XML document) can be represented as a tree structure. The tree structure of an XML document is generated by transforming each element or value in the XML document into a node in the tree.","Path scan: A path scan returns identifiers of all the nodes that follow a given XPath. In the system of the present invention, a path scan invokes services of a store layer.","Physical query operator (operator): One step in an execution plan is called an operator. The implementation of the execution for one step in the plan (operator) is called the \u201cphysical\u201d operator.","Query: A request for information from a database. A database query is typically written in a database query language, which is a language enabling database users to interactively formulate requests and generate reports. One of the best known query languages is the Structured Query Language (SQL).","Query engine: A query engine is a significant component of a DBMS, which in the currently preferred embodiment of the present invention is comprised of the following sub-components: a parser, a normalization engine, an optimizer\/compiler, and an execution engine. The parser converts query text to a query tree and imposes syntactic correctness. The normalization engine enforces semantic correctness by validating the correctness of information in the query. It also transforms the query into an operator tree or query that is in a form which facilitates processing by other sub-components of the query engine. An optimizer chooses the best among various alternative plans for executing a query. A compiler generates another structure that enumerates the specific execution steps in the appropriate order of execution. In this document the XML engine optimizer and compiler are together referred to as the optimizer, unless otherwise indicated. The execution engine is a virtual machine within a DBMS that interprets the \u201cplan language\u201d. The execution engine executes all the sub-commands necessary to execute the query and return results.","Query plan: A query plan (execution plan or \u201cplan\u201d) is an in-memory data-structure which contains the specific steps (operations) and order of execution for a given query. A query plan is written in a language that the execution engine understands.","Query processing: All phases of query evaluation, parsing, normalization, optimization\/compilation, execution, and result generation, together are termed as \u201cquery processing\u201d. The life of a query includes all of these phases.","Query tree: A query tree is an in-memory data-structure which represents a query. Initially, it is a mirror of \u201cquery text\u201d in the form of an in-memory data-structure. It includes the same information as in the user query.","Relational database: A relational database is a collection of data items organized as a set of formally-described tables from which data can be accessed or reassembled in many different ways without having to reorganize the database tables. The relational database was invented by E. F. Codd at IBM in 1970. A relational database employs a set of tables containing data fitted into predefined categories. Each table (which is sometimes called a relation) contains one or more data categories in columns. The standard user and application program interface to a relational database is the structured query language (SQL), defined below.","SQL: SQL stands for Structured Query Language. The original version called SEQUEL (structured English query language) was designed by IBM in the 1970's. SQL-92 (or SQL\/92) is the formal standard for SQL as set out in a document published by the American National Standards Institute in 1992; see e.g., \u201cInformation Technology\u2014Database languages\u2014SQL\u201d, published by the American National Standards Institute as American National Standard ANSI\/ISO\/IEC 9075: 1992, the disclosure of which is hereby incorporated by reference. SQL-92 was superseded by SQL-99 (or SQL3) in 1999; see e.g., \u201cInformation Technology\u2014Database Languages\u2014SQL, Parts 1-5\u201d published by the American National Standards Institute as American National Standard INCITS\/ISO\/IEC 9075-(1-5)-1999 (formerly ANSI\/ISO\/IEC 9075-(1-5) 1999), the disclosure of which is hereby incorporated by reference.","Storage layer: A storage layer is a component of a DBMS which provides services to the query engine such as running a scan and extracting data from disk to in-memory buffers, storing data from in-memory buffers to disk, and so forth.","URL: URL is an abbreviation of Uniform Resource Locator, the global address of documents and other resources on the World Wide Web. The first part of the address indicates what protocol to use, and the second part specifies the IP address or the domain name where the resource is located.","XML: XML, stands for Extensible Markup Language, a specification developed by the World Wide Web Consortium (W3C). XML is a pared-down version of the Standard Generalized Markup Language (SGML), a system for organizing and tagging elements of a document. XML is designed especially for Web documents. It allows designers to create their own customized tags, enabling the definition, transmission, validation, and interpretation of data between applications and between organizations.","XPath: XPath is a query language for querying data in XML documents. The XPath query language is commonly used in Extensible Stylesheet Language Transformations (XSLT) to locate and to apply XSLT templates to specific nodes in an XML document. XPath queries are also commonly used to locate and to process nodes in an XML document that match a specified criteria. XPath provides basic facilities for manipulation of strings, numbers, and booleans. It uses a compact, non-XML syntax to facilitate use of XPath within URLs and XML attribute values. XPath operates on the abstract, logical structure of an XML document, rather than its surface syntax. X Path gets its name from its use of a path notation as in URLs for navigating through the hierarchical structure of an XML document.","Referring to the figures, exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention, which is implemented in desktop and\/or server software (e.g., driver, application, or the like) operating in an Internet-connected environment running under an operating system, such as the Microsoft Windows operating system. The present invention, however, is not limited to any one particular application or any particular environment. Instead, those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms, including Macintosh, Linux, Solaris, UNIX, FreeBSD, and the like. Therefore, the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts, each block within the flowcharts represents both a method act and an apparatus element for performing the method act. Depending upon the implementation, the corresponding apparatus element may be configured in hardware, software, firmware, or combinations thereof.","The present invention may be implemented on a conventional or general-purpose computer system, such as an IBM-compatible personal computer (PC) or server computer.  is a very general block diagram of a computer system (e.g., an IBM-compatible system) in which software-implemented processes of the present invention may be embodied. As shown, system  comprises a central processing unit(s) (CPU) or processor(s)  coupled to a random-access memory (RAM) , a read-only memory (ROM) , a keyboard , a printer , a pointing device , a display or video adapter  connected to a display device , a removable (mass) storage device  (e.g., floppy disk, CD-ROM, CD-R, CD-RW, DVD, or the like), a fixed (mass) storage device  (e.g., hard disk), a communication (COMM) port(s) or interface(s) , a modem , and a network interface card (NIC) or controller  (e.g., Ethernet). Although not shown separately, a real time system clock is included with the system , in a conventional manner.","CPU  comprises a processor, such as one of the Intel Pentium family of microprocessors or any other suitable processor that may be utilized for implementing the present invention. The CPU  communicates with other components of the system via a bi-directional system bus (including any necessary input\/output (I\/O) controller circuitry and other \u201cglue\u201d logic). The bus, which includes address lines for addressing system memory, provides data transfer between and among the various components. Random-access memory (RAM)  serves as the working memory for the CPU . The read-only memory (ROM)  contains the basic input\/output system code (BIOS)\u2014a set of low-level routines in the ROM that application programs and the operating systems can use to interact with the hardware, including reading characters from the keyboard, outputting characters to printers, and so forth.","Mass storage devices ,  provide persistent storage on fixed and removable media, such as magnetic, optical or magnetic-optical storage systems, flash memory, or any other available mass storage technology (computer-readable media). The mass storage may be shared on a network, or it may be a dedicated mass storage. As shown in , fixed storage  stores a body of program and data for directing operation of the computer system, including an operating system, user application programs, driver and other support files, as well as other data files of all sorts. Typically, the fixed storage  serves as the main hard disk for the system.","In basic operation, program logic (including that which implements methodology of the present invention described below) is loaded from the removable storage  or fixed storage  into the main (RAM) memory , for execution by the CPU . During operation of the program logic, the system  accepts user input from a keyboard  and pointing device , as well as speech-based input from a voice recognition system (not shown). The keyboard  permits selection of application programs, entry of keyboard-based input or data, and selection and manipulation of individual data objects displayed on the screen or display device . Likewise, the pointing device , such as a mouse, track ball, pen device, or the like, permits selection and manipulation of objects on the display device. In this manner, these input devices support manual user input for any process running on the system.","The computer system  displays text and\/or graphic images and other data on the display device . The video adapter , which is interposed between the display  and the system's bus, drives the display device . The video adapter , which includes video memory accessible to the CPU , provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a display device, such as a cathode ray tube (CRT) raster or liquid crystal display (LCD) monitor. A hard copy of the displayed information, or other information within the system , may be obtained from the printer , or other output device.","The system itself communicates with other devices (e.g., other computers) via the network interface card (NIC)  connected to a network (e.g., Ethernet network, Bluetooth wireless network, or the like), and\/or modem  (e.g., 56K baud, ISDN DSL, or cable modem). The system  may also communicate with local occasionally-connected devices (e.g., serial cable-linked devices) via the communication (COMM) interface , which may include a RS-232 serial port, a Universal Serial Bus (USB) interface, or the like. Devices that will be commonly connected locally to the interface  include laptop computers, handheld organizers, digital cameras, and the like.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 2","b":["100","200","100","200","102","116","210","210","201","201","201","201","201","116","102","100","100"],"i":["a","b","c","d"]},"Software system  includes a graphical user interface (GUI) , for receiving user commands and data in a graphical (e.g., \u201cpoint-and-click\u201d) fashion. These inputs, in tarn, may be acted upon by the system  in accordance with instructions from operating system , and\/or client application module(s) . The GUI  also serves to display the results of operation from the OS  and application(s) , whereupon the user may supply additional inputs or terminate the session. Typically, the OS  operates in conjunction with device drivers  (e.g., \u201cWinsock\u201d driver\u2014Windows' implementation of a TCP\/IP stack) and the system BIOS microcode  (i.e., ROM-based microcode), particularly when interfacing with peripheral devices. OS  can be provided by a conventional operating system, such as Microsoft (registered trademark) Windows 9x, Microsoft (registered trademark) Windows NT, Microsoft (registered trademark) Windows 2000, or Microsoft (registered trademark) Windows XP, all available from Microsoft Corporation of Redmond, Wash. Alternatively, OS  can also be an alternative operating system, such as the previously mentioned operating systems.","While the present invention may operate within a single (standalone) computer (e.g., system  of ), the present invention is preferably embodied in a multi-user computer system, such as a client\/server system.  illustrates the general structure of a client\/server database system  suitable for implementing the present invention. As shown, the system  comprises one or more client(s)  connected to a server  via a network . Specifically, the client(s)  comprise one or more standalone terminals  connected to a database server system  using a conventional network. In an exemplary embodiment, the terminals  may themselves comprise a plurality of standalone workstations, dumb terminals, or the like, or comprise personal computers (PCs) such as the above-described system . Typically, such units would operate under a client operating system, such as a Microsoft (registered trademark) Windows client operating system (e.g., Microsoft (registered trademark) Windows 95\/98, Windows 2000, or Windows XP).","The database server system , which comprises Sybase (registered trademark) Adaptive Server (registered trademark) Enterprise (available from Sybase, Inc. of Dublin, Calif.) in an exemplary embodiment, generally operates as an independent process (i.e., independently of the clients), running under a server operating system such as Microsoft (registered trademark) Windows NT, Windows 2000, or Windows XP (all from Microsoft Corporation of Redmond, Wash.), UNIX (Novell), Solaris (Sun), or Linux (Red Hat). The network  may be any one of a number of conventional network systems, including a Local Area Network (LAN) or Wide Area Network (WAN), as is known in the art (e.g., using Ethernet, IBM Token Ring, or the like). The network  includes functionality for packaging client calls in the well-known Structured Query Language (SQL) together with any parameter information into a format (of one or more packets) suitable for transmission to the database server system .","Client\/server environments, database servers, and networks are well documented in the technical, trade, and patent literature. In operation, the client(s)  store data in, or retrieve data from, one or more database tables , as shown at . Data in a relational database is stored as a series of tables, also called relations. Typically resident on the server , each table itself comprises one or more \u201crows\u201d or \u201crecords\u201d (tuples) (e.g., row  as shown at ) A typical database will contain many tables, each of which stores information about a particular type of entity. A table in a typical relational database may contain anywhere from a few rows to millions of rows. A row is divided into fields or columns; each field represents one particular attribute of the given row. A row corresponding to an employee record, for example, may include information about the employee's ID Number, Last Name and First Initial, Position, Date Hired, Social Security Number, and Salary. Each of these categories, in turn, represents a database field. In the foregoing employee table, for example, Position is one field, Date Hired is another, and so on. With this format, tables are easy for users to understand and use. Moreover, the flexibility of tables permits a user to define relationships between various items of data, as needed. Thus, a typical record includes several categories of information about an individual person, place, or thing. Each row in a table is uniquely identified by a record ID (RID), which can be used as a pointer to a given row.","Most relational databases implement a variant of SQL. SQL statements may be divided into two categories: data manipulation language (DML), used to read and write data; and data definition language (DDL), used to describe data and maintain the database. DML statements are also called queries. In operation, for example, the clients  issue one or more SQL commands to the server . SQL commands may specify, for instance, a query for retrieving particular data (i.e., data records meeting the query condition) from the database table(s) . In addition to retrieving the data from database server table(s) , the clients  also have the ability to issue commands to insert new rows of data records into the table(s), or to update and\/or delete existing records in the table(s).","SQL statements or simply \u201cqueries\u201d must be parsed to determine an access plan (also known as \u201cexecution plan\u201d or \u201cquery plan\u201d) to satisfy a given query. In operation, the SQL statements received from the client(s)  (via network ) are processed by the engine  of the database server system . The engine  itself comprises a parser , a normalizer , a compiler , an execution unit , and access methods . Specifically, the SQL statements are passed to the parser  which converts the statements into a query tree (a binary tree data structure) which represents the components of the query in a format selected for the convenience of the system. In this regard, the parser  employs conventional parsing methodology (e.g., recursive descent parsing).","The query tree is normalized by the normalizer . Normalization includes, for example, the elimination of redundant data. Additionally, the normalizer  performs error checking, such as confirming that table names and column names which appear in the query are valid (e.g., are available and belong together). Finally, the normalizer  can also look-up any referential integrity constraints which exist and add those to the query.","After normalization, the query tree is passed to the compiler , which includes an optimizer  and a code generator . The optimizer  is responsible for optimizing the query tree. The optimizer  performs a cost-based analysis for formulating a query execution plan. The optimizer will, for instance, select the join order of tables (e.g., when working with more than one table), and will select relevant indexes (e.g., when indexes are available). The optimizer, therefore, performs an analysis of the query and selects the best execution plan, which in turn results in particular access methods being invoked during query execution. It is possible that a given query may be answered by tens of thousands of access plans with widely varying cost characteristics. Therefore, the optimizer must efficiently select an access plan that is reasonably close to an optimal plan. The code generator  translates the query execution plan selected by the query optimizer  into executable form for execution by the execution unit  using the access methods .","All data in a typical relational database system is stored in pages on a secondary storage device, usually a hard disk. Typically, these pages may range in size from 1 Kb to 32 Kb, with the most common page sizes being 2 Kb and 4 Kb. All input\/output operations (I\/O) against secondary storage are done in page-sized units\u2014that is, the entire page is read\/written at once. Pages are also allocated for one purpose at a time: a database page may be used to store table data or used for virtual memory, but it will not be used for both. The memory in which pages reside that have been read from disk is called the cache or buffer pool.","For enhancing the storage, retrieval, and processing of data records, the server  maintains one or more database indexes  on the database tables . Indexes  can be created on columns or groups of columns in a table. Such an index allows the page containing rows that match a certain condition imposed on the index columns to be quickly located on disk, rather than requiring the engine to scan all pages in a table to find rows that fulfill some property, thus facilitating quick access to the data records of interest. Indexes are especially useful when satisfying equality and range predicates in queries (e.g., a column is greater than or equal to a value) and \u201corder by\u201d clauses (e.g., show all results in alphabetical order by a given column).","A database index allows the records of a table to be organized in many different ways, depending on a particular user's needs. An index key value is a data quantity composed of one or more fields from a record which are used to arrange (logically) the database file records by some desired order (index expression). Here, the column or columns on which an index is created form the key for that index. An index may be constructed as a single disk file storing index key values together with unique record numbers. The record numbers are unique pointers to the actual storage location of each record in the database file.","Indexes are usually implemented as multi-level tree structures, typically maintained as a B-Tree data structure. Pointers to rows are usually stored in the leaf nodes of the tree, so an index scan may entail reading several pages before reaching the row. In some cases, a leaf node may contain the data record itself. Depending on the data being indexed and the nature of the data being stored, a given key may or may not be intrinsically unique. A key that is not intrinsically unique can be made unique by appending a RID. This is done for all non-unique indexes to simplify the code for index access. The traversal of an index in search of a particular row is called a probe of the index. The traversal of an index in search of a group of rows fulfilling some condition is called a scan of the index. Index scans frequently look for rows fulfilling equality or inequality conditions; for example, an index scan would be used to find all rows that begin with the letter \u2018A\u2019.","The above-described computer hardware and software are presented for purposes of illustrating the basic underlying desktop and server computer components that may be employed for implementing the present invention. For purposes of discussion, the following description will present examples in which it will be assumed that there exists a \u201cserver\u201d (e.g., database server) that communicates with one or more \u201cclients\u201d (e.g., personal computers such as the above-described system ). The following discussion also uses examples of queries requesting information from XML documents stored in a database system; however, the present invention may also be used in conjunction with documents written in various other markup languages, including, but not limited to, cHTML, HTML, and XHTML. The present invention, however, is not limited to any particular environment or device configuration. In particular, a client\/server distinction is not necessary to the invention, but is used to provide a framework for discussion. Instead, the present invention may be implemented in any type of system architecture or processing environment capable of supporting the methodologies of the present invention presented in detail below.","The present invention comprises a system providing methodology for index-based evaluation of path-based queries requesting data from markup language documents. The following discussion focuses on an XML document; however the system and methodology of the present invention may also be used for other types of markup language or tag-delimited sources of information. Accordingly, the references to XML in the following discussion are used for purposes of illustration and not limitation.","XML is a widely accepted model for representing data. In recent years, XML has become pervasive both in representing stored data and communicating data over a network. The following discussion illustrates the operations of the present invention using several examples of an XML document including books in a bookstore.","Unlike conventional data in a relational database which is maintained in a flat structure, information in an XML document is usually maintained in a tree structure.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["400","1","33"]},"As previously described, XPath is a query language for querying data in XML documents. XPath consists of a series of step specifications separated by a \u2018\/\u2019. Each of the steps (location step) identifies a set of identities (e.g., elements or attributes) relative to a given context. The first \u2018\/\u2019 in the XPath directly refers to the root node of the document. An example of an XPath query for requesting data in the above example XML document is as follows:","\/bookstore\/book\/title","An example of a SQL version of the above XPath query that can be used in the currently preferred embodiment of the system of the present invention is as follows:","{select xmlextract(\u2018\/bookstore\/book\/title\u2019, xmlcol) from bookstoretable}","where \u201cxmlextract\u2019 represents a built-in function of ASE SQL to run the XPath query. The above XPath query would return the following answer based on the example XML document shown above:",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Answer:<title>Trenton<\/title><title>Kane and Abel<\/title><title>"]},{"entry":[{},"MyTruth<\/title>"]},{"entry":[{},"\u2003\u2003Another example of an XPath query is:"]},{"entry":[{},"\u2003\u2003\/bookstore\/book[title=\u2018Trenton\u2018]\/author"]},{"entry":[{},"\u2003\u2003A SQL version of this query is as follows:"]},{"entry":[{},"\u2003\u2003{select xmlextract(\u2018\/bookstore\/book[title=\u2018Trenton\u2018]\/author\/,"]},{"entry":[{},"xmlcol) from bookstoretable}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown, the above SQL query specifies the path from which data is to be selected (in the form select xmlextract(path)) as well as the column name (xmlcol) and table (bookstoretable). Also, in the above query the \u201c[\u201d operator (or \u201csquare bracket\u201d operator) provides for filtering out books based on comparing the title of the book to \u2018Trenton\u2019. This operator corresponds to a \u201cwhere\u201d clause in a SQL query. The value of the author of such books is then projected. The above query would return the following answer based on the example XML document shown above:","Answer: <author>Mary<\/author><author>Bob<\/author>",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 5","FIG. 5"],"b":["500","500","510","520","520","520","530","550","560","500"]},"The Path Processor  serves as an interface between the XML Query Engine  and the Store Layer . The Path Processor  is an abstract API which accepts path requests from the XML Query Engine  and returns back node ids (corresponding to persisted nodes of the XML document). The Path Processor  invokes services of the Store Layer  to identify the nodes that satisfy the query expression (e.g., XPath expression) and returns an instance of an abstract object named \u201cDompp\u201d. This Dompp object is returned back to the query layer (i.e., XML Query Engine ).","The Store Layer  of the XML Engine  converts the text representation into an internal representation which is efficient for storage. The Store Layer  is also responsible for converting the representation to its textual form when the Path Processor  (path processing layer) requests a certain piece of information during query processing.","The XML Engine  includes parse time functionality that transforms each XML document into a collection of bytes that can be stored in a database or file system. The XML Engine  transforms an XML document by analyzing the document as a tree. During the transformation process, each node is labeled uniquely by assigning an integer to each node in a monotonically increasing order. This integer is referred to as object ID or OID. During this process, each element of the source document is visited in turn, and each element is numbered based upon the order it occurs in the document. An object is created by the XML Engine  which contains data from the transformed document together with auxiliary structures to aid in faster access to the data. During the transformation process, each element of an XML document is treated as a node or leaf (i.e., terminal node) and these nodes and leaves are annotated to provide faster access to data. The structure of the tree itself is derived from the structure of the source document. Furthermore, a streaming interface over this data is defined to provide fast, random access to the structures within it. The streaming interface includes a fast access structure, which is a flexible interface that enables free movement amongst, and efficient access to the underlying XML data. The XML Engine  also has query execution-time functionality for retrieving data in response to queries.","The XPath portion of a query is handled by the XML Query Engine , which includes query execution-time functionality for retrieving data in response to queries. The XML Query Engine  includes an XPath parser , an optimizer , and an execution engine . Within the XML Query Engine , the XPath parser  parses the XPath portion of the query received from the SQL Query Engine  and converts it into a query tree representation. The XPath parser  includes a normalization module (not separately shown at ) for normalization of the XPath expression. The query tree representation generated by the XPath parser  is then sent to the optimizer  which generates a physical query plan (execution plan) for execution of the query. The query plan is then provided to the execution engine  which interprets the query plan and executes it with the support of the store layer .","In a typical XML query engine evaluating a given XPath, all nodes satisfying each of the location steps beginning with the root are evaluated, and subsequently the remaining steps are evaluated relative to the results evaluated in the previous step. This tree traversal requires visiting intermediate nodes, which is not very efficient.","Further, in an ASE system example, for evaluation of complex Xpath queries over XML documents, the queries are broken down to a set of simple absolute paths (an absolute path being a sequence of nodes traversed from the root of the document to a given node). The results of these simple absolute paths (scans) are answered using a catalog containing a map of the absolute paths present in the XML document and the nodes subscribing to those paths. These results are then joined accordingly as per the logic of the query. This approach allows evaluation of complex Xpath that include the forward axes, such as self, child and descendent axes. However, evaluating queries with backward axes, like parent, ancestor or sibling is not possible using this approach alone.","In accordance with embodiments of the invention, an enhancement for an XML engine is provided to evaluate XPath queries, including reverse axes, efficiently using the catalog of paths and nodes mentioned above and additional auxiliary data structures built on top. Through the embodiments, relative path evaluation is enabled and done efficiently.","The evaluation of an XPath query against a given XML document in accordance with an embodiment occurs in three phases, namely Document Parsing, Plan Generation, and Plan Execution. In the Document Parsing phase, a given XML document is parsed and stored as a set of internal indices, referred to as the Store. These indices facilitate the efficient execution of the Plan for the given XPath, with a main index providing a descriptive catalog and referred to as the PathIndex.","By way of example, a PathIndex  for the XML document of  is shown in  and a corresponding PathIndex tree  is shown in . Included in the PathIndex  for each path is a unique id for each path (PathId), a type of the path, e.g., root, element, attribute, text, (Type), names of the last node in each path (Sym), node ids corresponding to nodes that subscribe to each path in the document (Nodes), and the PathId of the parent of this path, i.e., the path without the last node in this path, (ParentPathid).","In ASE, for example, SAX (Simple API for XML) parsing is used to parse the XML document, and the PathIndex  gets generated during the callbacks of the SAX parsing. SAX parsing is a well known example of an event-based API (application programming interface), which is commonly understood to report parsing events (such as the start and end of elements) directly to the application through callbacks, and the application implements handlers to deal with the different events, as is well understood in the art.","When the entire PathIndex  is generated, an additional summary index on the PathIndex  is built as the Path Index Summary.  illustrates an example Path Index Summary  for the PathIndex  of . In general, with the PathIndex  viewed as a tree , the Path Index Summary  captures the parent-child relationship in the tree . As shown in the example of , the Path Index Summary  includes two arrays, a PiKids array and a PiNext array. The PiKids array maps paths to their child paths, while the PiNext array maps each path to the next path (in lexical order) that is not a descendent of itself. If all subsequent paths are a descendent of a path, then its PiNext is set to MaxPaths, where MaxPaths refers to the number of paths in the document ( for the example of ).","With the document parsed, the Plan Generation phase commences and includes generally three sub-phases, nave plan generation, path resolution, and ParentOp processing. For na\u00efve plan generation, the parse tree is walked and for each member, an execution plan operator (plan Op) is generated. By way of example, a parse tree  and execution plan  as shown in  and , respectively, are generated for an example query,","Query 1: \/bookstore\/book [@publisher=\u2018MGH\u2019]\/title","In generating the execution plan, an XPath NAME element corresponds to a ScanOp. An XPath Filter element corresponds to a FilterOp, an XPath Comparison element corresponds to a ComparisonOp, an XPath Set member corresponds to a SetOp, and an XPath Parent(reverse) element corresponds to a ParentOp. In an embodiment, each consecutive sequence of XPath NAMEs is concatenated into one simplepath, and a ScanOp is generated for the simplepath, where a simplepath refers to a contiguous sequence of child-nametest steps in the XPath. For example, \u2018\/bookstore\/book\u2019 is a series of the following steps: root-child-nametest(bookstore)-child-nametest(book).","Further, after a plan Op is generated at any intermediate point, if there are further location steps remaining, then the plan for the remaining XPath becomes the forward step Op to the plan Op. If there is a Filter Op, then its previous step is added as the child of the Filter Op, and the plan for the XPath inside the filter is added as the filter plan for the Filter Op. The plan for any further forward location steps becomes the forward Step Op to the Filter Op.","With the naive plan generated, optimization for plan execution occurs with the path resolution sub-phase. By way of example, the following pseudocode provides a basic path resolution method for a ScanOp in accordance with embodiments of the invention.",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pathresolve(pathid)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003pathexpand(pathid, simplepath) into absolute paths set s1."]},{"entry":[{},"\u2003\u2003for each path p in s1"]},{"entry":[{},"\u2003\u2003\u2003\u2003call pathresolve(p) on the forward step operator."]},{"entry":[{},"\u2003\u2003\u2003\u2003if forward-step returns an empty set then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003remove p from s1."]},{"entry":[{},"\u2003\u2003\u2003\u2003cache [ pathid \u2212 s1] into an internal map"]},{"entry":[{},"\u2003\u2003return s1."]},{"entry":[{},"}"]},{"entry":[{},"pathexpand(pathid, simplepath)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003P = { pathid }"]},{"entry":[{},"\u2003\u2003for each nametest n in simplepath"]},{"entry":[{},"\u2003\u2003\u2003\u2003for each path p in P"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003P\u2032 = lookup PathIndex Summary to get list of child"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003paths to p matching n"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003add P\u2032 to P1"]},{"entry":[{},"\u2003\u2003\u2003\u2003P= P1"]},{"entry":[{},"\u2003\u2003return P"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As can be seen, the path resolution begins by passing the root path to the topmost operator in the plan as the context path. All the paths that would be relevant under the given path for itself are calculated, and each of these paths is then passed down to the forward step plan as the context path. The forward step plan does the path resolution recursively and returns its result paths. If the forward step does not return any result paths for the context path, the context path is discarded by the current operator. The remaining set of relevant paths for the current operator is then returned as the result paths by the operator.","For plan Ops other than a ScanOp, the absolute path set sl would be obtained by merging the paths returned by the pathresolve( ) call to each of the child operators of the current operator. With the internal path representation having both path type (element, attribute, etc.) and also the name of the last element of the path, it is possible to match the names in each step of the simplepath while looking up the Path Index Summary.","All plan Ops, except ParentOp, return the results for each context node in \u2018document order\u2019 so as to support the expectation by each of the Operators that the context nodes are to be passed in incremental document order.","ParentOp can produce results out of order, as well as produce duplicates. To account for this, a SortDistinctOp operator is added over a ParentOp's operation. The SortDistincOp collects all the results for a given context node from its forward step operator (in this case ParentOp) and then sorts them, removes duplicates, and returns results in document order, as is well appreciated by those skilled in the art.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 11","FIG. 10"],"b":["1102","1003","1104","1105","1106","1107"]},"Through the optimization of the path resolution sub-phase to filter out all the unwanted paths at each operator before beginning evaluation of the results, a top down approach is supported by the embodiments of the invention, and for the subsequent Plan Execution phase, each operator only looks at relevant (i.e., potential result producing) paths in the PathIndex for each context node received, the relevant paths being stored in an associative map of the operator.","In accordance with embodiments of the invention, for the Plan Execution phase, the operators in the execution plan are recursively connected, with each operator having zero or more child subplans and the meaning of each child being different for each operator. For example, for SetOp, each of the child plans corresponds to the plan for each of the XPaths that the set operator operates on, and for FilterOp, the child plan corresponds to the plan within the predicates. Additionally, each operator has one internal method, a produce( ) method, to generate a local-result, and zero or one forward step plans.","At a top level, in an embodiment, the plan is executed as",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"top.open(root)"]},{"entry":[{},"while (top.next(root) is valid)"]},{"entry":[{},"\u2003\u2003repeat"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Essentially, on each call to next( ) each operator produces its own result, referred to herein as local-result, relative to the context in the produce( ) method. With all operators having a same next( )method, and only the produce( )method being different for each, the next result of any operator may be evaluated as represented in the following:",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003next( )"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003while ( not fstepresult.valid( ) )"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003if ( not fstepresult.ivalid( ) )"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003local-result = produce( )"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if (not local-result.valid( ) )"]},{"entry":[{},"return no-result."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003forward-step.open(local-result)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fstepresult=forward-step.next( )"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003while ( not fstepresult.valid( ) )"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003fstepresult = forward-step.next( );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"\u2003\u2003return fstepresult"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As can be seen, if there is no forward-step to a current operator, the local-result is returned as the result. However, if there is an forward-step to the current operator, a call is made to forward-step->next( ), passing the local-result as the context. The result returned from the forward-step is then returned as the result of the current operator. When next( ) is called again on that same operator with the same context, next( ) is called on the forward-step with the same local-result as context.","When an invalidnode is received from the forward-step, the operator produces its next local-result, which is then passed to the forward-step->next( ) call as context. The sequence then repeats.","In order to generate the local-result, each operation utilizes its own produce( ) method. For example, a suitable produce( ) method for a ScanOp is represented as",{"@attributes":{"id":"p-0111","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ScanOp:produce(contextnode)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003if (cachedresult[contexnode.id])"]},{"entry":[{},"\u2003\u2003\u2003\u2003return cachedresult[contextnode.id].next( )"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003P = internalmap(contextnode.pathid)"]},{"entry":[{},"\u2003\u2003\u2003\u2003For each path p in P"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003result = result + Store.scan(p)"]},{"entry":[{},"\u2003\u2003\u2003\u2003result.uniquesort( )"]},{"entry":[{},"\u2003\u2003\u2003\u2003cachedresult[contexnode.id] = result"]},{"entry":[{},"\u2003\u2003\u2003\u2003return cachedresult.next(contextnode.id)"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note that the internalmap being utilized is the one generated during Path Resolution.","By way of further example, a suitable produce( )method for a ParentOp is represented as",{"@attributes":{"id":"p-0114","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003ParentOp::produce(contextnode)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Store.parentscan(contextnode.id, contextnode.pathid)"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003Store::parentscan( nodeid, pathid)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003p = lookupParent( pathid)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003S = PathIndex.nodes(p)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return largest s in S not greater than nodeid (using binary"},{"entry":"search)"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"As described, the relative path evaluation of the embodiments of the invention takes a single XML node, i.e., a context node and a relative path, and returns all the nodes matching the given relative path under the context node utilizing a forward scan. To do this efficiently, an auxiliary index summary structure built on top of the catalog speeds up identifying the set of absolute paths matching the given forward scan. With the results of the forward scans cached, computation is efficient when returning the nodes one at time to parent operators in the execution plan. Using these forward scans, a simple plan generation method is provided to evaluate XPath queries, including reverse axes that provides providing high performance and low resource usage by visiting only the relevant nodes in the XML document.","The Summary and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor(s), and thus, are not intended to limit the present invention and the appended claims in any way.","The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.","The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can, by applying knowledge within the skill of the art, readily modify and\/or adapt for various applications such specific embodiments, without undue experimentation, without departing from the general concept of the present invention. Therefore, such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments, based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation, such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance. The breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["Embodiments of the invention are described with reference to the accompanying drawings. In the drawings, like reference numbers may indicate identical or functionally similar elements. The drawing in which an element first appears is generally indicated by the left-most digit in the corresponding reference number.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 9","FIG. 4"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
