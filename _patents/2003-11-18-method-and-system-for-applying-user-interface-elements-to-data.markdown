---
title: Method and system for applying user interface elements to data
abstract: Systems and methods for providing and associating or combining visual style information with data content. The present invention relates to associating a shared set of style information with two or more objects or items that are to be displayed as part of a list or some other visual grouping of the items. By sharing the style information, i.e., the visual representation characteristics information, a program developer need only define the style information or style once. Upon defining the style, the developer can declaratively associate all the items in the list or group with the defined style.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07409642&OS=07409642&RS=07409642
owner: Microsoft Corporation
number: 07409642
owner_city: Redmond
owner_country: US
publication_date: 20031118
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to the general field of computer systems and applications designed to be executed on computer systems. More particularly, the present invention relates to an application development method and system for creating computer applications. More particularly still, the present invention relates to a framework for providing application developers better ways to combine user interface, e.g., display, elements with data, which is displayed in conjunction with a computer application.","Computer systems are important tools used in many different ways, by many different people. Computer systems themselves, however, are only one aspect of the utility provided. Another important tool that works in conjunction with computer systems, are the applications, i.e., computer applications that are executed on the computer systems. These computer applications are programs, typically written by application developers, compiled into object code, and then stored on the various computer systems for operation. The creation and use of computer applications is a well-known aspect of computer technology in general.","When creating a computer application, the developer typically must chose a particular environment, or platform on which the application will ultimately be executed. For example, when writing an application, the developer must choose either the Microsoft Windows\u00ae platform, the LINUX\u2122 platform, or some other platform. As a result of this choice, the program developer may have different options available for writing the application.","As an example, the typical platform provides a user interface display engine that receives commands and information from the application during runtime and responds by displaying that information on a user interface device, such as a computer monitor. Thus, the application developer must create or program the application to make the right call to the platform to thus cause the platform to respond by displaying the right data, in the right format, when desired.","Typically, in order to make the right call, the program developer must create some program code that ties the data to be displayed with the user interface elements, e.g., font type, font size, font color, etc. such that the platform simply interprets the command and renders the correct display. Although functional, this process suffers certain drawbacks.","For instance, when displaying a list of items, wherein each listed item has the same user interface elements, the program developer must explicitly tie each list item to the user interface elements. This is cumbersome and repetitive since the user interface elements must be repeated for each item. Also, when the data is tightly connected to the user interface the process of making changes is very difficult in that each change requires a translation back into the data's native form before storing and\/or propagating to other computer processes and systems. Furthermore, the developer must understand not only the content but how it ties to the user interface control elements.","It is with respect to these and other considerations that the present invention has been made.","The present invention relates to systems and methods for providing and associating or combining visual style information with data content. In particular, the present invention relates to associating a shared set of style information with two or more objects or items that are to be displayed as part of a list or some other visual grouping of the items. By sharing the style information, i.e., the visual representation characteristics information, a program developer need only define the style information or style once. Upon defining the style, the developer can declaratively associate all the items in the list or group with the defined style.","According to aspects, the present invention involves systems and methods for providing a user interface framework that renders data according to a visual style defined for the data type. Typically, the system includes a plurality of objects, wherein the objects have one or more data fields and a style definition module for holding one or more visual style definitions to be selectively applied to the one or objects wherein the objects are independent from the visual styles. Additionally, the system has a style lookup module for locating an associated visual style definition along with a binding module for binding one or more of the plurality of data fields to one of the properties of the appropriate visual style definition. Further, the system has a tree assembler module for generating a visual representation of the data based on the style definition and a rendering engine for displaying the data using the bound style definition. The system may further include a layout engine for providing additional user interface elements and a user interface element factory for adding additional user interface elements to the data. A change in the data causes a relatively automatic change in the present display.","With respect to the object themselves, in an embodiment the objects are displayed as a list, while other embodiments display the objects as menus, parts of combo boxes, or some other control. In accordance with particular aspects, the objects form a group, and the system has a group visual style definition being independently defined from the data items. In such a case the tree assembler module generates the visual representation based on the group visual style.","In accordance with other aspects, the present invention relates to a method of displaying data according to an appropriate style. The method involves receiving a request to display one or more data items and then locating the appropriate visual style, wherein the style is independently defined from the data items. Next the method generates a visual tree using the data items and the appropriate style and binds properties in the visual tree to properties of the data items. Last the method renders the display based on the visual tree. In an embodiment, the process involves declaring the data items using data objects and automatically updating the visual tree in response to a change to a relevant data item. The change to a relevant data item may involve an edition, addition or deletion of a relevant data item.","The invention may be implemented as a computer process, a computing system or as an article of manufacture such as a computer program product. The computer program product may be a computer storage medium readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process.","A more complete appreciation of the present invention and its improvements can be obtained by reference to the accompanying drawings, which are briefly summarized below, and to the following detailed description of presently preferred embodiments of the invention, and to the appended claims.","The present invention will now be described more fully hereinafter with reference to the accompanying drawings, in which embodiments of the invention are shown. This invention may, however, be embodied in many different forms and should not be construed as limited to the embodiments set forth herein; rather, these embodiments are provided so that this disclosure will be thorough and complete, and will fully convey the scope of the invention to those skilled in the art.","In general, the present invention relates to a new and improved method of providing or combining visual style information with data content. In particular, the present invention relates to associating a shared set of style information with two or more objects or items that are to be displayed as part of a list or some other visual grouping of the items. By sharing the style information, i.e., the visual representation characteristics information, a program developer need only define the style once. Upon defining the style, the developer can declaratively associate all the items in the list or group with the defined style. A computer system  that may be used to render a list or group of items onto a display in accordance with the present invention is shown in . As used herein, a \u201ccomputer system\u201d shall be construed broadly and is defined as \u201cone or more devices or machines that execute programs for displaying and manipulating text, graphics, symbols, audio, video, and\/or numbers.\u201d","The computer system  displays information, such as display screen . The display screen  is enlarged to show details of the display. The display  relates to an over-simplified display of an example company application used to manage different portions of a business, employee information for example. Importantly, although display  displays employee content information, many other types of content may be managed and displayed in accordance with the present invention and thus, the employee example is not meant as a limitation, but merely as an illustration.","In this particular example, the display  has a title bar  and an employee window . There may be other windows for managing other information as indicated by scroll bar . Employee window  has a title bar  and a tool bar . Tool bar  provides user controls such as a search control  and an add employee control , among potentially many others. Such user interface controls are generally known in the art and are useful in managing certain types of information.","Within employee window , there are two sub-windows, such as employee list window  and employee detail window . In this particular example, employee window  displays a list of all the employees working for ABC Company. In a particular embodiment, as discussed in more detail below, each set of employee information may be a distinct object stored in a database or other datastore. As an object, e.g., of class \u201cEmployee,\u201d each has a set of properties. For example, the properties for each employee may include a name property, an address property and an employee identification value or ID property. The exemplary window  displays four employee objects , ,  and  and has been designed to display these three properties associated with each employee object. Although four employee objects are represented in the list window , many more may be shown as indicated by the ellipses  and the scroll bar .","In order to create the employee window , a developer of the application may utilize a list control. In an embodiment, the application used to display the window  was created for the operating system platform developed by Microsoft Corporation. In such a case, the use of a control such as \u201cListBox\u201d or others may be implemented to generate the window . ListBox, as well as other controls such as menu controls, are given the ability to manage a collection of items of arbitrary type.","The details window  will be discussed in more detail below, but in general, the details window  displays more object properties for a highlighted object, such as the Mark Jones object shown in . That is, when the object  having the Mark Jones property field is highlighted or selected by the user from window , a details window, such as window  may be displayed, wherein the window  displays many more properties associated with the Mark Jones object.","The present invention relates to the associating of objects, such as the employee objects represented by  in window , with user interface style elements in order to provide such items to a rendering engine, which in turn displays the list of items in a predetermined format, as shown in . The objects , ,  and  are each displayed using the same basic style definition. That is, the font size and type of the name property is the same for all objects when displayed. In display , the name properties of all the employee objects are displayed using italics. Importantly, in an embodiment of the present invention, defining the use of italics for displaying the name properties of the listed objects need only be done once by the developer of the application that is used to list the employee objects.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["200","200","100","200","202","204","204","206"]},"In addition to the memory , the system  may include at least one other form of computer-readable media. Computer readable media, also referred to as a \u201ccomputer program product,\u201d can be any available media that can be accessed by the system . By way of example, and not limitation, computer-readable media might comprise computer storage media and communication media.","Computer storage media includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by system . Any such computer storage media may be part of system .","The exemplary computing system  may also contain a communications connection(s)  that allow the system to communicate with other devices. The communications connection(s)  is an example of communication media. Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.","In accordance with an embodiment, the system  includes peripheral devices, such as input device(s)  and\/or output device(s) . Exemplary input devices  include, without limitation, keyboards, computer mice, pens, or styluses, voice input devices, tactile input devices and the like. Exemplary output device(s)  include, without limitation, displays, speakers, and printers. Each of these \u201cperipheral devices\u201d are well know in the art and, therefore, not described in detail herein.","With the computing environment in mind, embodiments of the present invention are described with reference to logical operations being performed to implement processes embodying various embodiments of the present invention. These logical operations are implemented (1) as a sequence of computer implemented steps or program modules running on a computing system and\/or (2) as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance requirements of the computing system implementing the invention. Accordingly, the logical operations making up the embodiments of the present invention described herein are referred to variously as operations, structural devices, acts or modules. It will be recognized by one skilled in the art that these operations, structural devices, acts and modules may be implemented in software, in firmware, in special purpose digital logic, and any combination thereof without deviating from the spirit and scope of the present invention as recited within the claims attached at the end of this specification.","Referring now to , the functional components used in associating the display elements, e.g., user interface (UI) elements with the data objects are logically illustrated in accordance with an embodiment of the present invention. In an embodiment all the components illustrated in  reside and operate on a single computer system such as system  described in conjunction with . Alternatively, one or more of the components illustrated in  may be performed on separate computer systems in a distributed network, as is known in the art.","An application module  developed in accordance with the present invention is shown in . The application module may represent any number of different computer applications or programs developed for use on many different types of computer systems. Indeed, in an embodiment, the application module  represents the employee management application provided as an example in conjunction with . The application module , therefore executes on a computer system such as computer system  to display a list of items, among other things. In an embodiment, the application module  accesses a datastore , which stores a plurality of objects , wherein the objects may have data content , along with associated methods and events (not shown). In accordance with embodiments of the present invention, the objects relate to items that are to be displayed in a list or other grouping, yet are independent of the user interface elements, i.e., how the object will ultimately be rendered. In other embodiments, the objects may be displayed as menu items or other group items. Although the objects  may be displayed, or some of their properties may be displayed per the present invention, those skilled in the art will recognize that these objects may be used in many other capacities as well. Also, datastore  may store many other items as indicated by the ellipses .","In a particular exemplary embodiment, the objects  may be managed as a set of similar objects in an object collection . An example may be an object collection relating to employee objects and therefore each object has the same properties or fields as the other objects. Of course the content of these properties or fields is different for different employee objects. In other embodiments, there may be other types of objects , such as customer objects as part of another collection  within the same datastore . The other types of objects have different properties or fields. For example, the employee objects have an employee ID value wherein the customer objects do not. Similarly, the customer objects may have an account number property where the employee objects do not. Those skilled in the art will recognize that there are many different potential types of objects having many different properties.","The application module  also accesses or is associated with style definitions . The style definitions may be developed or designed by the developer of the application module  or the definitions  may be created by a third party. The style definitions relate to the actual style properties to be associated with the data content of the objects  when the data is ultimately displayed. These data specific styles are shown as data style . A data style is stored separately from the data objects and is relatively independent of the data itself. A data style influences the display of data in two principal ways: (1) by specifying property values for the item itself, and (2) by specifying an internal representation for the item, e.g., a visual subtree. For instance, style definitions may include font size (such as 12 or 10 point, etc.), type (such as Arial or Courier, etc.), color (such as black or red, etc.), attributes (such as bold or italics, etc.), location (such as position on the display), etc. Also, the style also describes a visual subtree to aid in the creation of an internal visual representation of the items, such as for a given data object which fields should be displayed. The visual tree is discussed in more detail below.","Moreover, the style definitions may be sub-divided into separate style definitions for each of the properties of each object to be displayed. In a particular embodiment, a style definition may be stored for each class of objects. For example, the employee class of objects may have its own predetermined style definition and the customer class of objects may have is own, unique predetermined style definition. However, as discussed below, in an alternative embodiment, one style definition may be used for objects of different types.","The style definitions  may also contain list control style information  which provides visual style information for the list control itself, independent of the data to be displayed in the list control. That is, there may be a significant amount of user interface information regarding the building of a list on a display including size information, border information, shading and color information, how the user interacts with the list, such as mouse interaction, etc. The list control style  is used to provide such information.","In an embodiment, the application module  has a data binding section  that, during operation, causes data content , i.e., properties of the data objects , to be ultimately bound to the UI elements or properties of a style definition such as definition . The data binding section  relates to the declarative program statement(s) that associates one or more data objects to a data style. Such an association may be made by explicitly identifying the data types and the data style for that type, or by providing a style selector call, or by providing a default style, or by some other method.","Application module  operates on platform . Platform  relates to the framework or application programming interface (API) that provides the necessary communication between the application module  and the operating system of the computer, such as computer  shown in . As such, the platform  provides the intermediate functions and services to allow the application module  to ultimately display a list of items, such as objects , on a display . Although not shown, the operating system and its necessary operations occur between platform  and display . In a particular embodiment of the invention, the platform  is the Microsoft Windows\u00ae platform developed by Microsoft Corporation.","Within the platform , a tree assembler module  parses the information received from the application module  in order to build a \u201cvisual tree\u201d which is an internal representation of the display and thus represents the combination of the data from the objects  to be displayed and the information from the style definitions that describes how to display the data. The visual tree is described in more detail below in conjunction with . In an embodiment, the tree assembler module  includes a style lookup module  and a data bind module  which are used to locate the appropriate style elements and to bind a property of a UI element to a data property, i.e., establish the desired links. Essentially, the application module  makes requests to the style lookup module  to lookup the correct style definition and to the data bind module  to make the links. As stated above, these requests may be declarative, i.e., interpreted by the tree assembler module , or procedural, i.e., the application  calls the binding methods at runtime. Moreover, the data styles, such as style  may also have a declarative request for binding to data as well. In such a case the data bind module  handles these requests too. More details of the binding process may be found in copending U.S. patent application Ser. No. 10\/440,081, titled \u201cSYSTEM AND METHOD FOR CONTROLLING USER INTERFACE PROPERTIES WITH DATA\u201d filed on Oct. 23, 2003, assigned to the assignee of the present application, and incorporated herein by reference for all that it discloses and teaches.","In an embodiment, the tree assembler  receives the data content and the style information directly from the application module . In other embodiments, the tree assembler  may access the required content and style information directly from the datastore  and the definition module , respectively, through the operation of the data bind module . In doing so, the tree assembler  understands where to look and what to find based on the binding information received from the application's data bind section .","The tree assembler module  completes the visual tree and passes the tree to the rendering engine . In an embodiment, the tree is passed relatively directly to the rendering engine , which, in turn uses the visual tree to render the display on the user interface display . However, in an alternative embodiment, the visual tree is passed first to a layout engine  that adds more information to the visual tree, using user interface elements from factory  to complete the tree. The layout engine, in an embodiment understands the physical properties of the display such that it can determine where to place certain display items and how large to make them relative to the physical characteristics of a particular computer system.","Of course, the application module  and the tree assembler module  operate in a dynamic environment wherein the tree assembler may make an initial visual tree and as the application  runs, items and displays may change, such that the tree assembler  may rewrite or modify the visual tree to ultimately update the display.","A listing of some exemplary markup language, e.g., XAML code is provided in  to illustrate the defining of a style, such as those defined in style definitions  for use by the tree assembler module  (). As may be appreciated, the code snippet  is only one example of the way in which the concepts described herein may be implemented and should not be considered limiting to the shown syntax. Line  represents the declaration or definition of a new style named \u201cEmployeeStyle\u201d. The name here is merely an example that continues the example shown and described above in conjunction with  wherein a number of employee objects may be listed. Following the definition of the style name, the markup describes the visual tree in the next seven lines. The visual tree consists of a dock panel that contains three text controls ,  and . The visual tree essentially states that when an employee is being displayed, three properties of the employee are to be shown as text (via the Text controls), using layout rules supplied by the surrounding DockPanel. The first control  binds the data from the name field of the employee object to be displayed first, such as in the first column. As may be appreciated other details may be required to make this example work, such as adding width dimensions for the columns to each text control, etc. Text control  binds the data from the address field of the employee object to be displayed second, such as in the second column. Next, text control  binds the data from the employee ID field of the employee object to be displayed third, such as in the third column. The style may be applied to all employee objects at runtime such that the style does not have to be associated with the data until runtime. Further, this one style definition can be applied to all employee objects such that the style does not have to be repeated when the employee objects are created.","As may be appreciated, many other user interface elements may also be built into the example style for employees. For simplicity, the exemplary style  is primarily concerned with displaying three primary employee fields in a particular order. This however, should not be considered a limitation as many other fields could be displayed, in many different orders, along with many other types of user interface elements (images, buttons, sliders, etc) As may be appreciated, the styled display is not limited to text.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 4","b":["402","404","402","500"]},"An exemplary visual tree  is shown in . In accordance with aspects of the present invention, a \u201cvisual tree\u201d is a representation that is in a tree-like structure having nodes for the visual representation of the elements to be displayed. Not all elements are in a visual tree as not all elements have visual information. Visual tree  is bounded by two sets of ellipses  and  to indicate that this is only a portion of a potentially larger visual tree.","The first item in visual tree portion  is the list box item . In essence, when building the tree, the tree assembler, such as tree assembler  shown in  encounters the list box item, such as ListBox command  shown in . Upon encountering the list box command, an entry for the list box is placed in the visual tree at position . Next, an inquiry is performed to determine the style information for the list box itself. Such style information may include properties of the ListBox as well as a visual tree. This visual tree might contain borders or shading information, controls for scrolling, or the like; in an embodiment, the tree contains one element (usually a Panel of some sort) with a property such as \u201cItemsHost=\u201ctrue\u201d\u201d that indicates where the UI for the data items belongs. The tree assembler sets the properties of the ListBox to their desired values, creates a copy of the desired visual tree, and adds it to the main visual tree at position .","Next the tree assembler creates the UI for the data items, one at a time, and adds it to the visual tree underneath the panel . This UI comes from two places. The first piece comes from the list control itself. In the example shown in , the ListBox indicates that it expects the first piece of the UI to be a ListItem; other list controls might indicate a different type of element\u2014for example a Menu might indicate that it expects a MenuItem. In an embodiment, the manner in which the ListBox indicates that it expects a ListItem involves the use of an \u201cItemsControl\u201d object which has a property called \u201cItemUIType.\u201d A derived class like ListBox sets this property to type of (ListItem). The tree assembler module  queries this property, and creates an element of the desired type. The tree assembler creates an element of this type (ListItem , in the present example), performs an inquiry for its style information, and creates the corresponding visual tree . This style information might describe how the user interacts with the list item, such as what happens when the mouse cursor hovers over a list item, etc.","The visual tree  typically contains a special element that indicates where the UI for the data item belongs. In one embodiment, this special element is a ContentPresenter . This is where the second piece of UI is added. The tree assembler performs an inquiry to determine the style information for the data item. It creates a copy of the visual tree described in that style, and adds it to the main visual tree at position . Thus the content presenter functions to \u201cstyle\u201d the data content.","The content presenter acts to retrieve the first object and upon receiving the object, such as an employee object, the tree assembler uses the defined item's style to layout the proper fields in the visual tree. For instance, the first element in the EmployeeStyle  is a Dock Panel command, such that a dock panel entry  is made in the visual tree. Next, with the dock panel, the EmployeeStyle requires that text be displayed, and the first text element be the name from the first employee object. The actual text is not placed here. Instead a binding is made here in order to account for later changes made to the actual data, i.e., when the data changes in the data item, the data associated with the visual tree  will also change. Next, text entries  and  are inserted into the visual tree to account for the lines  and  shown in .","This process is repeated for all the employee objects, such that sub-trees ,  and  are entered into the visual tree. Upon completing the visual tree , the tree  may be passed to a layout engine, such as engine  () for additional user interface elements prior to being sent to the rendering engine . In another embodiment, the layout engine calls the tree assembler as needed to generate the tree just in advance of the layout process. In essence, the layout engine and the tree assembler module are separate but cooperating modules. Rendering engine  accepts the visual tree  and uses the same to display the list of employees on the display.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6","FIGS. 6 and 7","FIG. 3","FIG. 1","FIG. 3"],"b":["600","600","302","100","314"]},"Initially, receive operation  receives a request to display data from a set of objects. The set of objects may be related in that each object is of the same type or the same class, but this is not necessary. Upon receiving the request to display data from the data objects, parse operation  parses the request. In parsing the request, parse operation  identifies that a list is to be displayed and determines whether any style should be applied to the list. Further, parse operation  iterates over the list of items and determines if any particular styles should be applied to the data items themselves.","In an embodiment, the request to display the data also includes some kind of style information. In essence, the style information causes requests, at runtime to the platform to establish links between the data and the associated styles. In establishing the appropriate links, a search operation may be performed to search for and locate the appropriate style.","Upon establishing the appropriate links, apply operation  applies any defined styles for the data objects. Although the style is described independently of the data, apply operation determines the necessary user interface elements to apply from the style such that a visual tree data structure may be built or modified. The modified visual tree may include some kind of binding information. This information causes requests at runtime to the platform to establish links between the properties of the UI elements and the properties of the data items. These requests may be declarative, i.e., interpreted by the platform, or procedural, i.e., the application, such as application  () calls the binding methods at runtime.","In applying the defined style, flow  incorporates enter operation  which enters visual information into a visual tree. Enter operation  receives the results of the apply operation . That is, each data object is essentially associated with some style information, defined independently from the data itself. Enter operation  assembles the result of apply operation , including any links (bindings) as described above, and stores the information into a data structure, i.e., the visual tree. The visual tree has visual information for the all the data (and other user interface elements) to be displayed. Essentially, the application module  makes requests to the data bind module  to make these links. As stated above, these requests may be declarative, i.e., interpreted by the tree assembler module , or procedural, i.e., the application  calls the binding methods at runtime. Moreover, the data styles, such as style  may also have a declarative request for binding to data as well. In such a case the data bind module  handles these requests too.","Next, pass operation  passes the visual tree to the layout engine and rendering engine to apply more style information (if necessary) and to ultimately render the display items on a display device. Upon rendering the display, flow  ends at end operation .","Flow , shown in , provides more details of the process steps ,  and  shown in . That is, when parsing the set of data objects , and applying the defined styles  and entering the information into a visual tree , some added steps may be performed in a particular embodiment.","Initially, flow  begins with apply operation  which first recognizes that a list item is to be displayed. Consequently, since the object is a list item, apply operation determines the particular list-item style that should be applied. The list-item style relates to an independently defined set of user interface elements that apply to list-items in general, and independently from the actual data to be presented\/displayed in the list. For example, the list-item style may define the background color for the list item or how the user may interact with the list item.","Next, as part of the list item display process, the content presenter is invoked at operation , which, in turn provides the indication that a data item is to be displayed. In an embodiment, as the list item display process is progressing, at some point a content presenter action or command is received. This command identifies the actual data object that has the data for display. Next, get style operation  gets the style associated with first list item. Get operation  is the result of invoking the content presenter, which identifies the object collection and the object to be retrieved, along with information regarding the appropriate or relevant visual style. Once the appropriate style is selected, apply operation  applies the appropriate style to the content presenter and inserts the visual information into the visual tree, such as tree  shown in . The visual information typically includes UI properties that are data-bound to data properties of the data object.","Determine operation  determines whether all the objects have been entered into the visual tree. If there are more objects to add to the visual tree then flow branches YES to operation . Operation  repeats the process of applying a list item style to the visual tree. Next operation  gets content presenter operation  which, in turn causes get operation  to get the next style associated with the next data item. As may be appreciated, flow  is repeated for each object until all objects have been evaluated and their visual representations have been entered into the visual tree. In an alternative embodiment, the determine operation  may take other items into account before causing the repetition of flow . That is, the determine operation  may determine at any time, for any reason, to stop adding visual elements to the visual tree. For example, the determine operation may determine that enough user interface elements have been created to fill the available space such that flow  should end at end operation . Alternatively, determine operation may determine that a time threshold limit has been exceeded such that no more objects should be added to the visual tree.","When determining which style to apply to the data content, e.g., operation  described above in conjunction with , there are several contemplated methods of determining the style. One example has been provided and discussed above in conjunction with . In that example, the style was provided to the list box request as portion . In that case, the ItemStyle was specifically provided as the \u201cEmployeeStyle\u201d such that the content presenter recognized that it had to search for and use a defined style named EmployeeStyle (also provided in ). This is considered an explicit reference by name of style.","In another embodiment, the list box request may not provide the item style information and instead may provide only the item source information as shown in line  of code snippet  shown in . In this case, the tree assembler, such as tree assembler  () recognizes the type of the object to apply a style, i.e., an employee object for the example shown in . Using this type information, the tree assembler is able to search for any styles that are defined based on the type of the object.  illustrates such a defined style in lines . In an embodiment, the collection of objects may have many different types of objects, such as employee type objects, customer type objects and others. In order to display a list of these objects, the list box request may simply refer to the types that are to be displayed and the tree assembler identifies the proper style to apply based on this type information.","In yet another embodiment, the style information is identified using an \u201cItemStyleSelector\u201d object in the list box request as shown in line  of code snippet  shown in . \u201cStyle selector\u201d, in an embodiment is a class of objects having one method, i.e., SelectStyle. The application developer may cause a style selector object to be instantiated when a list box function is called in order to allow the developer a means of selecting the appropriate style for the appropriate objects. SelectStyle requires that the developer draft the code necessary to instantiate the object, as is known in the art. A sample declaration of such a resource is provided in lines  in . This class is particularly useful when an application developer wants to apply different styles to objects of the same type, but having different properties.","In order of priority, in an embodiment, the tree assembler looks for an explicit reference first, then determines whether a style selector has been identified when no explicit style references is indicated. Next, if neither an explicit style reference nor a style selector has been identified, the tree assembler identifies the type of object and searches for a style based on the object type, such as described in conjunction with . Last, if no object type style is defined, then a default style may be applied and\/or an error message may be displayed to the user.","The operations described above depend on many different things, such as the collection of items, the values of the properties within the collection of items, the style information, the style selector information, the styles defined for the controls, e.g. the list box control and the list item control, etc. Each of the various elements that help make up the display components may, in fact, change dynamically. The platform, such as platform  () responds to such changes by re-applying the above algorithms as necessary to produce the desired result.","For instance, during the execution of the application, a new object may be added to the object collection, such as object collection  shown in , e.g., by use of an add item control such as control  shown . In such a case, the tree assembler module, such as tree assembler module  is notified of this change. The notification may be an active notification calling to the tree assembler module, or alternatively, the notification may result from the tree assembler module \u201clistening\u201d for such an event. Upon being notified of the change, the tree assembler module may determine whether the insertion is relevant. That is, the tree assembler module may determine whether the change will actually change the current display. In some cases, the tree assembler module may only generate user interface elements to fill one screen or display at a time and thus if the change to the object collection results in an insertion into an \u201coff-screen\u201d area then the tree assembler module may determine that the change is not relevant for the current display and do nothing. If however, the tree assembler module determines that the change is relevant, then the tree assembler module generates or changes the visual tree to include the new objects data items as discussed above and inserts the new user interface elements in the correct place within the visual tree. The new data object will get styled as described above and then the visual tree will be passed to the rendering engine to be displayed as discussed above.","Similarly, when an item is removed from the object collection, the tree assembler module may be notified. The tree assembler module determines the relevance of the removal and, if relevant removes the corresponding user interface elements from the visual tree and thus rebuilds the visual tree. Again, the new tree is passed to the rendering engine for display rendering.","In an embodiment, another type of collection change relates to a \u201crefresh.\u201d That is, in some cases the most, if not all, of an object collection may change in some way. For example, when an application module, such as application  () sorts a collection, the collection may send a refresh notification to the system, which causes the tree assembler module, such as module  () to rebuild the visual tree according to the new order of the data items.","When the item style property is changed, a notification is sent to the tree assembler module as well. In some cases the item style may have been used in styling many different objects such that the tree assembler module must determine whether changes are relevant and where. If relevant, a re-styling in all the necessary locations occurs potentially resulting in a new user interface being displayed according to the new style. Accordingly, the same process occurs when the item style selector property changes as well.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 10","b":["1000","1000"]},"Flow  begins with invalidate operation  which invalidates the visual tree. In essence, since the visual tree is an internal representation of the data to be displayed and since that data has changed due to a change to the object collection or to the defined styles, the visual tree is no longer valid. Such an invalidation step may involve the setting or clearing of a bit to indicate that the present visual tree is no longer valid.","Next recognize operation  recognizes that the tree is no longer valid. Such recognition may relate to the tree assembler module being notified of the invalidation operation, or the tree assembler module may listen for the type of event.","Upon recognizing that the visual tree is no longer valid, then determine operation  determines if the change is relevant. Determine operation  relates to the evaluation of the change and a comparison against the current display to determine if the change would cause a change in the current display. If not, then flow branches NO to end operation . If the change is relevant, then flow branches YES to rebuild operation . In one embodiment, rebuild operation  begins rebuilding the entire visual tree as described above, in order to capture the change. In other embodiments, the rebuild operation simply identifies where the visual tree should change and makes those changes. Upon rebuilding the tree, the tree is passed to the rendering engine to cause the actual presentation of the display, i.e., the re-rendering of the display. As before, the tree may be passed to a layout engine for added user interface elements prior to passing to the rendering engine. Upon passing to the rendering engine, flow ends at operation . As may be appreciated, upon rebuilding the visual tree, the tree is then \u201cvalidated\u201d such that when another change is made, the tree can again be invalidated to restart the flow .","As discussed above in conjunction with , the objects in a set may be managed as a collection. By managing the objects in a collection, additional user interface elements may be added, through the use of a defined style, to a \u201cgroup\u201d of objects. The definition of the group, and how the group-level user interface elements look may therefore be independent of the group itself.","For example, for a collection of data objects, wherein each object relates to one of the past United States Presidents, the collection of objects may be sorted by their last name property. As such, the developer of the user interface elements may decide to display the President objects in groups corresponding to letters of the alphabet. Each group starts on a new line, preceded by a big bold letter, within the group, the names flow left to right. As shown below in Table 1.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of Group User Interface Elements"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["A",{},{},{}]},{"entry":["John Adams","John Q. Adams","Chester Arthur"]},{"entry":["1797-1801","1825-29","1881-85"]},{"entry":"B"},{"entry":["James Buchanan","George H. W. Bush","George W. Bush"]},{"entry":["1857-61","1989-93","2001-present"]},{"entry":"C"},{"entry":["Jimmy Carter","Grover Cleveland","Bill Clinton","Calvin Coolidge"]},{"entry":["1977-1981","1885-89; 1893-97","1993-2001","1923-29"]},{"entry":". . ."},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"In the example shown in Table 1, the big letters are not part of the data. Instead the user interface designer supplies such information as (1) A list of groups, each with its own membership test; in the example, a list of 26 groups corresponding to the letters of the English alphabet\u2014the membership test examines the first letter of the last name property; (2) a group template, i.e. the user interface elements to generate for each group, in which the desired position of the actual items is marked such as lines  shown in ; and (3) an item template, i.e. the user interface elements to generate for each item, such by providing the relevant portions used in defining an item style above (and shown as lines  for the current example).","In an embodiment of the current invention, application module, such as module  (shown in ) provides the ability to list a second window, such as window  (shown in ) that displays details of a listed item from a master list, such as list window  (). Indeed, the details window  may display most or all of the data properties for a particular object, such as an employee object, where the master list only lists some of the data properties. It will be appreciated that when managing large numbers of data objects, a user may wish to only view the abbreviated set of data properties when viewing the list of different objects but when a particular item is selected, then the user may wish to view all of the information. In an embodiment, the use of such a details window in combination with a master list is considered a \u201cmaster-detail\u201d implementation.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 1","b":["120","120","118"]},"To further illustrate this example, assume the field of the Name property is bound to data object for Mark Jones using: \u201c<Text TextContent=\u201c*Bind(Path=NameField)\u201d>\u201d as the command. Since the display command calling the salary information is bound to the actual data record, as soon as a change is made to the data record, the same change is shown in the details window. Similarly, a change in the details window will cause a change in the master window , since its information is also bound to the actual data records.","Using the above systems and methods, an application author can provide many different and flexible styling techniques to data used in the application. The defined styles can be used for one or more different objects, in accordance with aspects of the present invention. Importantly, the application author can assign style information in a declarative manner, i.e., the above systems and methods provide a declarative way to program how data looks when displayed and how an end user might interact with the user interface elements and underlying data. In doing so, the data is separated from the user interface elements and style definitions. Consequently, the author or an end user may change the data objects without changing the user interface elements. Likewise, the author may adjust the user interface elements without changing the data objects.","As may be appreciated, many different types of objects may be used in accordance with principles of the present invention, including but not limited to strings, list items, etc. Also, although many of the examples described above dealt with list items and list controls, many other collections of items may be managed and displayed according to principles of the present invention, including but not limited to menus, combo boxes, list boxes, etc. The present invention may be applied to work with any control that manages a collection of items. In an embodiment, the present invention works with all controls that derive from \u201cItemsControl\u201d as part of the Microsoft Windows\u00ae framework. Also, although the invention has been described in language specific to structural features, methodological acts, and computer readable media containing such acts, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific structure, acts or media described. Therefore, the specific structure, acts or media are disclosed as preferred forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
