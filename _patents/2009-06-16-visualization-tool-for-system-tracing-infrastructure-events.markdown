---
title: Visualization tool for system tracing infrastructure events
abstract: A system and method for identifying a root cause of a wait in a computer system are provided. Given the identity of a thread of interest and time window, a longest wait period for the thread of interest within the time window is identified. The longest wait period is used as a starting node to generate a ready tree by walking backwards through the data in a system trace to construct a tree of readying events that ready threads for running on a processor. A potentially anomalous chain of events is automatically identified and highlighted in the ready tree. A visualization of the ready tree is presented to a user so that the user can explore the events in the tree and annotate the automatically generated tree to aid in problem diagnosis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08464221&OS=08464221&RS=08464221
owner: Microsoft Corporation
number: 08464221
owner_city: Redmond
owner_country: US
publication_date: 20090616
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The subject matter relates generally to tools for identifying causes of long wait times in computer systems.","Software continues to grow in size and complexity to take advantage of increasingly powerful hardware and to cater to the diverse needs of a large and growing market. This increase in software size and complexity when combined with diverse usage scenarios makes it difficult for programmers to develop performant applications. The diverse usage scenarios and software complexity also makes it difficult for system administrators to identify and resolve problems.","To build performant software, developers typically use profiling tools that either instrument a program or use hardware performance counters to identify functions that are time-consuming and to focus their efforts on optimizing these functions. However, this methodology suffers from key limitations. First, only a small subset of likely usage scenarios can be profiled and consequently the application may still perform poorly in many circumstances. Second, with multicore processors quickly becoming mainstream, many applications are multi-threaded and function performance is often dependent on understanding the behavior of other application threads that can execute in parallel.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","This disclosure describes various exemplary methods, user interfaces, and computer program products for building a tree in part upon ready signals sent from thread to thread. Accordingly, this type of tree may be referred to as a ready tree.","In one implementation, the system presented in this disclosure may include a processor and a memory that stores instructions for execution by the processor. The instructions may comprise a system tracing infrastructure, a tree creation module, and a user interface generation module. The system tracing infrastructure creates a trace of events in the system. The tree creation module automatically extracts events from the trace related to wait periods of threads and then structures those events into a ready tree. The tree creation module structures the events into a ready tree by identifying a context switch that ends a wait period of one of the threads designated as a thread of interest. A parent thread that sends a ready signal to the thread of interest and by doing so enables the context switch is also identified. The tree creation module also identifies a wait period of the parent thread that overlaps with the wait period of the original thread of interest. For this overlapping wait period of the parent thread, an ancestor thread which has sent a ready signal to the parent thread enabling a context switch from the ancestor to the parent thread is also identified. The user interface generation module produces a visual display of the tree so that a user can readily perceive information and relationships contained within the trace.","Overview","Developing performant software in computer systems is benefited from an understanding of problems that may detract from a user experience. One type of problem that may be experienced is a long wait during which time a computer system may appear \u201cfrozen\u201d or appear to be waiting for no apparent reason. Some waits may occur frequently during the normal operation of a computer system. Other, longer waits experienced by the software threads may be perceived by the user if the wait is long, and thus, lead to a perception of a problem such as a frozen computer system. Information related to the cause of the problem may be captured by a system tracing infrastructure that creates a trace, or a record, of events in the system. This trace information can be useful to sophisticated users such as software developers or system analysts when those users are trying to diagnose the root cause an abnormally long wait. The trace may contain a large amount of information which is available to a user in a relatively user-unfriendly form such as unfiltered text. The root cause of the abnormally long wait may be contained within the trace, but it may be very time consuming for the user to sort through this information and identify the root cause of the wait.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","102","104","106","104","108","104","110","112","106","104","112","110","104","102"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 1"],"b":["200","202","104","202","204","202"]},"Threads  are running on the processor . A thread of execution results from a fork of a computer program into two or more concurrently running tasks. An operating system  of the computing device  may implement threads  as elements contained within a process. Multiple threads may exist within the same process and share resources such as memory, while different processes may not share these resources.","On a single processor, such as the processor , multithreading generally occurs by time-division multiplexing (e.g. multitasking) in which the processor  switches between different threads . Taking one thread off of the processor and placing another thread onto the processor may be referred to as \u201ccontext switching.\u201d A context switch is the computing process of storing and restoring the state (context) of a central processing unit (CPU) such that multiple processes can share a single CPU resource. The context switch is one feature of a multitasking operating system. Context switches are usually computationally intensive and much of the design of operating systems is to optimize the use of context switches. What constitutes the context is determined by the processor  and the operating system . This context switching generally happens frequently enough that the user  perceives the threads  or tasks as running at the same time. On a multiprocessor or multi-core system, the threads  or tasks will generally run at the same time, with each processor or core running a particular thread  or task.","A single one of the threads  will alternate between running and waiting until the thread's work is complete. If the thread  is waiting for a long period of time that wait may be perceived by the user  of the computing device . One element of the ready tree is a visualization of a thread status . The visualization of a thread status  differentiates between periods of time during which the thread  is running on the processor  and periods of time during which the thread  is waiting. In one implementation, the thread  is represented as a horizontal bar  with run periods represented by a solid line and wait periods represented by a dashed line. Other formats for visualizing run periods and wait periods of a thread are also included within the scope of this disclosure.","Event Tracing","Computing device  may include as part of the operating system  and\/or non-operating system software an infrastructure  to record a log, or \u201ctrace,\u201d of events that have happened on the computing device . One example of a system tracing infrastructure  is Event Tracing for Windows (ETW) which is a high-speed tracing facility provided by the Windows\u00ae Operating System. The data contained in the trace is used to generate the ready tree.","The system tracing infrastructure  may use a buffering and logging mechanism implemented in the operating system kernel to provide a tracing mechanism for events raised by both user-mode applications and kernel-mode device drivers. Additionally, the system tracing infrastructure  may allow for enabling or disabling tracing dynamically, thus making it possible to perform detailed tracing in production environments without requiring reboots or application restarts. A logging mechanism of the system tracing infrastructure  may use per-processor buffers that are written to disk by a separate writer thread. The system tracing infrastructure  may use buffers maintained by the kernel in order to allow system tracing to continue even if the computing device  is experiencing application crashes or hangs.","The system tracing infrastructure  may contain four main components: an event trace session infrastructure, a trace provider, a controller, and a trace consumer. Event trace sessions are where buffering and logging take place. Per-processor kernel buffers may be used to log events from the trace providers without using a lock, and the buffers are then written to a file by a separate writer thread. The trace provider provides events to the event trace session infrastructure. Any recordable activity of importance may be an event, and the event is represented by a piece of data logged to the system tracing infrastructure . In addition to a fixed event header, an event may contain user data from each instrumentation point. A trace provider may include but is not limited to, a user mode application, a kernel mode device driver, or the operating system kernel itself. The trace provider first registers with system tracing infrastructure  and then sends events from various points in the code by calling an appropriate application programming interface (API) for logging the events.","The controller may start, stop, or update trace sessions in the kernel as well as to enable or disable trace providers to send traces. Controller functions are typically invoked by system administrators and performance analysts to collect traces from one or more trace providers.","Finally, the trace consumer is an application that reads trace files or listens to active trace sessions in real time and processes logged events. An event trace session infrastructure works as a broker that relays the events from one or more trace providers to the trace consumer. The trace consumer may use the data regarding the events in the trace to do such things as generate a ready tree.","In the system tracing infrastructure , sessions and providers may exist in different spaces. The controller is the one that starts and stops sessions and maps providers to sessions dynamically. Thus, the controller can choose to map several trace providers to a session, disables some of them after a while, and map another trace provider to the same session. Sessions operate in the kernel and are not tied to providers. Likewise, the providers may not be aware of which sessions their events are being logged to.","When logging events are given by the trace provider, the system tracing infrastructure may add additional data items such as thread and process ID, a current CPU usage of the logging thread, and a timestamp. These fields are recorded in an event header and passed onto event consumers along with the event content. These fields may be used later to assist in provider activity analysis. Traces typically are long and complex, thus manual diagnosis of performance problems (e.g., a wait or hang) using raw trace data may be time consuming and inefficient.","Lock-Contention Problems","Many performance problems in multi-threaded operating systems involve lock-contention, where one thread  spends a long time waiting for another thread to release a lock on a shared resource. Lock-contention occurs when multiple threads try to gain access to the same lock. For example, two threads of an e-mail application may both need to modify a same file on a disk. An operating system  may be set up so that a thread must acquire a file lock exclusively before modifying a file. Only one thread  may have the lock at any given time. Locks may be implemented by an operating system in a variety of ways such as with flags or with mutual exclusion algorithms (mutex). This type of operating system  prevents conflicting changes in the file from multiple threads  attempting to modify the file simultaneously. Accordingly, most locking designs block the execution of the thread  requesting the lock until it is allowed to access the locked resource. Therefore locks are one cause of system waits or hangs.","Ready-Tree Construction",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":["300","302","204","204","208","304","204","306","204","306","304","306","302","304","306","302","304","302","306","306","302","304","306","204","306","304"]},"As previously discussed, a system tracing infrastructure  keeps track of context switch events on the processor  and ready thread events. Context switch events may contain data including a timestamp of the event, a thread being switched out, a thread being switched in, and a CPU. The system tracing infrastructure  also keeps track of call stacks associated with these events such as Thread A Call Stack  and Thread B Call Stack . Stack entries contain information about the functions currently on the stack of a thread, which provide information about what the thread is doing at the moment that the stack entry is recorded. A call stack is a dynamic stacked data structure that stores information about the active subroutines of a computer program. There is usually one call stack associated with each thread. A call stack is composed of stack entries which are also referred to as stack frames or activation records. The stack entries are machine dependent data structures containing subroutine state information. Exemplary call stacks Thread A Call Stack  and Thread B Call Stack  both include a header indicating a thread name and a thread status as well as a plurality of stack entries -","The linking  from the Thread A  to Thread B  may be identified by matching functions from Thread A Call Stack  to Thread B Call Stack . Matching functions such as a context switch event or a ready thread event from the respective call stacks of two threads such as Thread A  and Thread B  may make it possible to verify whether or not the behavior of Thread A  is responsible for Thread B  being switched onto the processor . The link  of Thread A  to Thread B  may be thought of as a causal link explaining why the waiting period of Thread B  has ended.","In one example, the waiting period of Thread B  is caused by a lock contention. For some operating systems there may exist a list of functions that are known to be lock acquire or lock release functions. A lock-related call may be recognized by matching calls from a call stack to a list of calls known to be lock acquire calls or lock release calls. In some implementations, a list of known lock-related calls may be stored in a configuration file. For the known locks, it is possible to examine the functions on the parent thread call stack (e.g., Thread A Call Stack ) and the switched-in thread call stack (e.g., Thread B Call Stack ). Thread A Call Stack  includes a stack entry  for \u201crelease resource lock\u201d and Thread B Call Stack  includes a stack entry  for \u201cacquire resource lock.\u201d Thus, it is possible to verify that Thread A  is releasing the lock for which Thread B  is waiting by matching the acquire resource lock call to the release resource lock call. In other implementations, the configuration file may store list of calls related to possible causes of waits other than just lock-related calls. For example, calls related to waiting for a network packet to arrive may be used to identify a potential root cause of a wait that does not involve a lock.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["304","306","302","304","306","204"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","b":["400","400","204","402","400","102","402","102","102"]},"A time period of interest may also be designated either by the user  or by the system. In some implementations the time period is from the moment the thread of interest was indicated back to the start of the trace file. In other implementations the time period may be a predefined length of time such as 15 or 60 seconds prior to the indication of the thread of interest. Given a time window and a thread of interest it is possible to identify wait periods of the thread of interest. A longest wait period  from the wait periods of the thread of interest may form a base of the ready tree .","A trace may be analyzed to identify an event that signaled the end of the waiting period  and switching of the thread of interest to a period of running  on a processor . The event that signaled the end of the waiting period  may be a context switch event or a ready thread event. The event that allows the thread of interest to finally run may be caused by another thread called a parent thread. For example, work done while the parent thread was running  enabled the thread of interest to be switched onto the processor  so that the thread of interest could run . The event which readied the thread of interest to run is indicated as a link  between the parent thread and the thread of interest.","Like the thread of interest, the parent thread may also have periods of waiting ,  as well as periods of running , . Since the thread of interest is not able to switch from waiting  to running  until the final period of running  of the parent thread, earlier waits ,  of the parent thread are indirectly responsible for the long wait  of the thread of interest. Events in the history of the thread of interest which occurred prior to the long waiting period  may be presumed unrelated to a cause of the long wait because the thread of interest was not waiting during that earlier time. Accordingly, wait periods of the parent thread  and  that overlap in time with the longest wait period  of the thread of interest are used for further expansion of the ready tree .","Events that terminated the wait periods ,  of the parent thread are identified. These events in turn provide links ,  to earlier threads referred to as ancestor threads. Periods of running ,  of each ancestor thread caused an event that ended a corresponding wait period ,  of the parent thread. The process of identifying a \u201cparent\u201d thread that is responsible for ending a wait period of a \u201cchild\u201d thread may be followed backwards in time until all waits that overlap with the long wait period  of the thread of interest are identified. In other implementations, generation of the ready tree  ends when a stop condition is reached. The stop condition may include a wait that is not lock-related, a user-specified recursion depth, or reaching the beginning of the trace file. In other words, the ready tree  is generated by starting with a long wait of a thread of interest  and following ancestor waits which ended after the long wait began.","This process for creating the ready tree  may create a ready tree that includes multiple ready chains leading up to the final long wait  for the thread of interest. The ready chains include a plurality of nodes which are the wait periods (e.g., , , ) and the associated run periods (e.g., , , , , ) of a thread and links , ,  between the nodes. For example, the ready tree  includes two ready chains. The first ready chain begins with nodes \/ connected by link  to nodes \/ which in turn is connected by link  to node . The second ready chain also begins with nodes \/ connected by link  to nodes \/ and then to node .","A typical ready tree may have many more nodes, links, and ready chains than the simplified schematic diagram shown in . Even though ready trees are simplified and organized representations of data from a system trace, the ready trees themselves may be complex. However, in this implementation, there is an interactive graphical user interface that enables the user  to more easily review and interact with a representation of a ready tree  by providing a navigable and zoomable user interface.","Behavior of a thread and a ready tree  may be presented as a binary condition: either running or waiting. The actual behavior of a thread may be somewhat more subtle. Normally when a thread is running, it is doing actual work on its own behalf. Sometimes, however, a thread may be woken up by a timer or an interrupt call. During these \u201cfalse runs,\u201d the cause of the wait has not yet been resolved, but the thread is running in response to a routine timer wake up check, or the thread is performing work for other threads. False runs include, but are not limited to, timer wake up and Asynchronous Procedure Call (APC) interrupts. In both cases the activity of the thread is classified as waiting even though the thread may be running on a processor . The false starts may be identified by examining a call stack of the thread that signaled a timer wake up or an APC interrupt. For example, a call stack may contain the function KiTimerExpiration in the case of a timer wake up or the function KeInsertQueueApc in the case of an APC interrupt.","The period of time the thread spends waiting includes time that the thread spends on the waiting queue as well as the time it spends on the ready queue before the thread is switched in to run on the processor . Time spent in the ready queue is generally unaffected by the type of events which may cause a hang or long wait. Accordingly, in some implementations, analysis is based only on time spent in the waiting queue. Thus, the calculation of wait time includes the time from when the previously running thread was switched out until the time when the ready signal is sent to the next thread. Threads can spend time waiting off the processor  for many different reasons, locks being one of them.","In some implementations the ready tree  may be designed to present information related to lock contention problems. Any other source of waits for threads in a computing device  may also be the basis for creating a ready tree . However, a ready tree  that only looks at lock-related functions is discussed as one exemplary ready tree . When analyzing lock-contention behavior, lock-related waits may be identified by examining the stack ,  of the thread as discussed above with respect to .","Returning to , diagnosis of a lock-contention problem begins with analysis of the trace for the thread of interest to identify a longest lock-related wait period  within the given time window. In some implementations, a wait period may be designated as a lock-related wait period by examining a call stack of a readying thread  at the time of the ready thread event and a call stack of a switched in thread  for the presence of lock-related functions. Lock-related functions include lock acquire calls and lock release calls. In other implementations, a call stack of the readying thread  at the time of the ready thread event is not examined, and only the call stack of the switched in thread  is examined for lock-related functions. If one of the functions is a known lock-related function, the wait period is designated as a lock-related wait.","A ready signal  from the parent thread that ends the long lock-related wait period  of the thread of interest is identified. Next, the parent thread is examined for any lock-related wait periods that overlap in time with the long lock-related wait period  of the thread of interest. Any waits ,  of the parent thread while it is in possession of the lock requested by the thread of interest may delay transfer of the lock to the thread of interest.","In the ready tree , the parent thread is waiting for two separate ancestor threads to finish tasks and release the respective locks. One of the ancestor threads may in turn be waiting for a network operation to complete. The sequence of waits may lead to the thread of interest waiting for an unusually long period of time  for access to the lock. In this situation, the thread of interest is hung, and structuring trace data into a ready tree may assist in indentifying a root cause of the hang. In this example, the root cause may be a delay in the network operation (not shown) which resulted in a chain of lock contentions.","Anomaly Detection",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 5","b":["500","502","102","500","500","500","502","500","502","504","512","510","514","510","500"]},"Anomaly detection strategies include, but are not limited, to chain-based strategies and cross-trace based strategies. In one implementation of chain-based anomaly detection, the ready chain with a longest average wait period is taken to be anomalous and the entire chain is highlighted as the anomalous ready chain. Average wait time is a reasonable metric, because one feature of a ready tree is to serve as a tool for identification of a chain of events leading up to the observed long wait period . If the average wait time along a chain is long, then every thread in the chain experienced a long wait on average. Other possible metrics suitable for chain-based strategies include, but are not limited to, a longest median wait period, a longest total wait period, a greatest number of nodes in the chain, a greatest number of anomalous wait periods, a wait period in a predetermined quantile of wait times, or combinations thereof. The maximum wait time of a chain may also be used as a metric for a chain-based strategy, but every chain in the ready tree includes the long wait period  and the long wait period  could be the longest wait in the chain skewing the results if the maximum weight time is the metric.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 6","b":["600","602","602","212","602","604"]},"Given a probabilistic model of the historical wait times for an event, a probability of a wait period of a certain length of time may be calculated by using the corresponding probabilistic model. If the probability for a wait period falls below a certain probability threshold, then that wait may be identified as an anomalous wait period. The probability threshold may be set at any level, for example, all wait periods with a modeled probability of less than 5% could be identified as an anomalous wait periods. The mixture of Gaussians model  shown in  may be interpreted to indicate that, depending on the probability threshold, all wait times greater than 11 seconds are to be identified as anomalous wait periods.","Interactive User Interface",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 7","b":["700","700","700","702","704"]},"The interactive user interface  also allows for regular expression search of information contained in the ready tree. By searching through the ready tree including the underlying stack events, the user  may be able to determine the root cause of a wait or hang. For example, in response to the user  typing \u201cGetDllHandle\u201d into a search box, a user interface may highlight or emphasize nodes (e.g., node ) for which the corresponding call stack includes the text \u201cGetDllHandle\u201d. The user  may cycle through all the nodes and links matching a certain set of call stack functions by entering the regular expression and repeatedly making a single input such as clicking a \u201cFind\u201d or \u201cTab\u201d button. This is useful for chaining together related events.","The interactive user interface  also allows for the user  to manually annotate the anomalous ready chain if the default highlighted ready chain is not correct.  shows one implementation of a ready chain that is automatically identified as the anomalous ready chain. The user  may decide that the automatic process identified the wrong ready chain. In some implementations of the interactive user interface, clicking on a node opens up a menu where the user can check or uncheck an anomaly flag. For example, a node  is automatically identified as non-anomalous, but in response to a user annotation of the node  the status was changed from non-anomalous to anomalous. Alternatively, a node automatically marked as anomalous may be annotated by the user  so that the nodes status is changed to non-anomalous. Manual changes may be saved to a database or other storage at the time the changes are made or when the program exits. The manual annotations provide feedback that may be used to improve the automatic anomaly detection algorithms.","Exemplary Processes","For ease of understanding, the methods discussed in this disclosure are delineated as separate steps represented as independent blocks. However, these separately delineated steps should not be construed as necessarily order dependent in their performance. The order in which the processes are described is not intended to be construed as a limitation, and any number of the described process blocks may be combined in any order to implement the method, or an alternate method. Moreover, it is also possible that one or more of the provided steps will be omitted.","The processes are illustrated as a collection of blocks in logical flowcharts, which represent a sequence of operations that can be implemented in hardware, software, or a combination of hardware and software. For discussion purposes, the processes are described with reference to the system shown in , the thread visualization shown in , and the user interface shown in . However, the processes may be performed using different architectures and devices. Moreover, the system and ready trees described herein may be used to perform different processes.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 8","FIG. 5"],"b":["800","800","802","212","212","804","806"]},"At block  a longest lock-related wait period from the wait periods of the thread of interest is identified. The wait period is recognized as lock-related when a call stack of the thread of interest includes a lock-related call. In some implementations, the lock-related call is identified from the calls in the call stack by matching calls in the call stack to a list of calls known to be lock acquire or lock release calls. The list of calls may be maintained in a configuration file. The longest lock-related wait period is the wait period that spends a greater amount of time waiting then other lock-related wait periods within the time window. At block , a ready tree of thread status is automatically generated. The longest lock-related wait period of the thread of interest may be thought of as a starting point for generating the ready tree. An exemplary process for generating a ready tree is discussed in more detail with respect to  below.","At block  a path in the ready tree from the longest lock-related wait period for the thread of interest to a potential root cause of the wait is designated as an anomalous path. The ready tree may include many branches and thus many paths that could potentially be an anomalous path. In some implementations, a path is designated as the anomalous path because the average wait period of the nodes in the designated path is longer than an average wait period of nodes in other paths in the ready tree. At block , a visual display of the ready tree is generated for display in the user interface. In some implementations a computing device which creates a data structure representing the ready tree (e.g. server ) is different than a computing device (e.g. computing device ) that presents the data structure as a ready tree in the user interface. The visual display of the ready tree represents wait periods and run periods of threads as nodes and links between the nodes representing respective ready signals or context switches. The visual display may include indication of the nodes and links in the anomalous path by highlighting those nodes and links.","At block  a listing of call stack events for a node in the ready tree is revealed in response to receiving an indication of the node on the visual display of the ready tree. For example, the user  may click on a node in the ready tree and in response to that indication the listing of call stack events may be displayed such as shown in .",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 9","b":["900","902","904"]},"At block  the process  proceeds to the \u201cno\u201d branch to block  if a stop condition is not present. The stop condition may include identification of a not lock-related wait period, reaching a user-specified recursion depth, or reaching a beginning of the trace file. If the stop condition is present, the process  proceeds to the \u201cyes\u201d branch to block . At block  all overlapping wait periods have been followed and processed. After there are no more un-processed overlapping wait periods, at block  nodes and links for inclusion in the ready tree have been identified and it is possible to generate the ready tree.","Returning to block , identification of nodes and links continues. If the parent thread has an overlapping lock-related wait period with the longest lock-related wait period of the thread of interest, the process  proceeds to the \u201cyes\u201d branch and returns to block . Wait periods of the parent thread are also identified as lock-related wait periods when a call stack of the parent thread includes a lock-related call. When the parent thread does not have an overlapping lock-related wait period, because the parent thread is running or in some status other than waiting, the process  follows that \u201cno\u201d branch to block  and waits for any other overlapping wait periods to be processed.","Upon returning to block  the process  repeats for lock-related wait periods of the parent thread. In subsequent iterations a ready signal from a parent of the parent thread, referred to as an ancestor thread in , that ends the lock-related wait period of the parent thread is identified. Upon returning to block , a parent of the parent thread (e.g., ancestor thread) is identified. The process  of identifying previous generations of threads can repeat until either a stop condition is present or the thread being examined does not have a lock-related wait period that overlaps with the longest lock-related wait period for the thread of interest.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 10","FIG. 9","FIG. 5"],"b":["1000","1002","1004","1000","102","102"]},"At block  a user annotation of an anomalous status of a node may be received. If no annotation is received, then the process  proceeds to the \u201cno\u201d branch and generates a visual representation of the anomalous ready chain at block . Prior to receiving user annotation or in the absence of user annotation, the anomalous ready chain displayed in the visual representation of the ready tree may be thought of as a default anomalous ready chain automatically identified by the system. Default identification of the anomalous ready chain may be based on a length of wait periods in the ready chain.","Returning to block , if the user  annotates the ready tree by changing an anomalous flag for one of the nodes in the ready tree, then the process  proceeds to the \u201cyes\u201d branch to block . At block  the algorithm for automatically identifying the ready chain in the ready tree as the anomalous ready chain is adjusted, based on the user annotation of the anomalous status of the node. From block , the process  returns to block  to automatically re-identifies a ready chain as the anomalous ready chain. Depending on the adjustment to the algorithm, the anomalous ready chain may or may not change. The adjustment may occur on-the-fly as a user annotates nodes, or annotations may be aggregated and the algorithm adjusted at a later time.","Exemplary Computing Device",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 11","FIG. 1","FIG. 2"],"b":["1100","1102","1102","104","110","202","1102","1104","1106","1104","1104"]},"For example, the computing device  illustrates architecture of these components residing on one system or one server that may be communicatively coupled to a network, such as the network  shown in . Alternatively, these components may reside in multiple other locations, servers, or systems. For instance, all of the components may exist on a client side. Furthermore, two or more of the illustrated components may combine to form a single component at a single location. The illustrated components may also reside in a computing device without a connection to a network, such as a stand-alone database. The computing device  may in various implementations be similar to either the computing device  or the server computer  shown in .","Memory  may store programs of instructions that are loadable and executable on the processor of , as well as data generated during the execution of these programs. Depending on the configuration and type of computing device , memory  may be volatile (such as RAM) and\/or non-volatile (such as ROM, flash memory, etc.). The computing device  may also include additional removable storage  and\/or non-removable storage  including, but not limited to, magnetic storage, optical disks, and\/or tape storage. The disk drives and their associated computer-readable media may provide non-volatile storage of computer readable instructions, data structures, program modules, and other data.","Turning to the contents of the memory  in more detail, the memory  may include an Operating System , a System Tracing Infrastructure , a Tree Creation Module , an Anomalous Path Identification Module , and\/or a User Interface Generation Module . The memory  may also, in some implementations, include a database .","The system tracing infrastructure  may create a trace of events in the system as discussed above. The Tree Creation Module  may automatically extracts events from the trace related to wait periods of threads. The Tree Creation Module  may further structure the events into a ready tree by identifying a context switch that ends a wait period of a thread of interest. The thread of interest may be designated automatically by the system in response to a performance event or input received from a user  may manually designate the thread of interest. The Tree Creation Module  may further identify a parent thread that sends a ready signal to the thread of interest which enables the context switch. The Tree Creation Module  may also identify any wait periods of the parent thread that overlap with the wait period of the thread of interest. Further processes by the Tree Creation Module  may identify an ancestor thread that in turn sends a ready signal to the parent thread enabling a context switch from the ancestor thread to the parent thread. Identification of parent and previous generations of threads by the Tree Creation Module  creates a ready tree with nodes that are run periods or wait periods of the respective threads and the nodes are linked by respective context switches.","In some implementations the Tree Creation Module  may further expand the ready tree by identifying a wait period of the ancestor thread that overlaps with the wait period of the thread of interest and then for the wait period of the ancestor thread identifying a previous ancestor thread that sends a ready signal to the ancestor thread enabling a context switch from the previous ancestor thread to the ancestor thread. In this process may be recursively repeated (i.e., the \u201cprevious ancestor\u201d thread becomes the \u201cancestor\u201d thread and a \u201cprevious previous ancestor\u201d thread is identified) until a stop condition is reached.","The Anomalous Path Identification Module  identifies an anomalous path or chain of nodes in the ready tree as discussed above. In some implementations the Anomalous Path Identification Module  may identify an anomalous path automatically. In other implementations the Anomalous Path Identification Module  may identify an anomalous path in response to user annotations of the ready tree.","The User Interface Generation Module  may cause an output device  of the computing device  to display a visual representation of the ready tree. In some implementations, an output device displaying the ready tree may be remote from the computing device . The user interface generated by the User Interface Generation Module  may enable the user  to interact with the visual representation of the ready tree.","In some implementations, the User Interface Generation Module  may sequentially highlight anomalous nodes in response to a command from the user . Highlighting includes any method of visually distinguishing a highlighted node from a non-highlighted node such as color, shading, size, text style, and position. The command from the user may include a single input such as pressing a \u201cNext\u201d or \u201cTab\u201d key that shifts the highlighting from one anomalous node to another anomalous node. The highlighting and the ability to toggle between nodes of interest in response to the single input enable the user  of the ready tree to efficiently find and analyze system tracing information of interest.","The database  may store data previously collected by the system tracing infrastructure. Some of the data stored in the database  may include historical wait periods for system events. An event may happen multiple times (e.g., request for a lock on a printer driver) and the system tracing infrastructure may record an associated wait time for a thread every time that same event occurs. All of these associate wait times may be stored in the database  and provide a record of historical wait periods for past occurrences of that system event.","Computer-readable media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable storage , and non-removable storage  are all examples of computer-readable media. Additional types of computer readable-media that may be present include, but are not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computing device .","The computing device  may also contain a communication connection(s)  that allows the device to communicate with other devices such as servers and\/or user terminals on a network, such as the network  of . Communication connection(s)  is an example of a mechanism for receiving and sending communication media. Communication media typically embodies computer readable instructions, data structures, and program modules. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media.","The computing device  may also include input device(s)  such as a keyboard, mouse, pen, voice input device, touch input device, stylus, and the like, and output device(s),  such as a display, monitor, speakers, printer, etc. All these devices are well known in the art and need not be discussed at length.","The subject matter described above can be implemented in hardware, software, or in both hardware and software. Although implementations of ready tree generation have been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts are disclosed as exemplary forms of exemplary implementations of generating ready trees. For example, the methodological acts need not be performed in the order or combinations described herein, and may be performed in any combination of one or more acts."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The Detailed Description is set forth with reference to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different figures indicates similar or identical items.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
