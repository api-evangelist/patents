---
title: Method and system for implementing independent message queues by specific applications
abstract: A flexible message queue system that creates separate message queues for different applications in a content server is described. The message queue system allows for the dynamic creation of message queues by applications on an as-needed basis, the implementation of a message as a persistent object with a defined schema that facilitates inter and intra-application messaging, and the integration of message creation with notification to streamline the message transaction process among users, such as application threads or applications. Embodiments include a message queue that is implemented in a content server as a persistent object type and that acts on messages that are an object of the type, along with API mechanisms that allow for creating and destroying message queues as needed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09436532&OS=09436532&RS=09436532
owner: EMC Corporation
number: 09436532
owner_city: Hopkinton
owner_country: US
publication_date: 20111220
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Message queues are software components that provide an asynchronous communications protocol for applications and interprocess or inter-thread communication. Message queues provide an asynchronous communications protocol in that the sender and receiver do not need to interact with the message queue at the same time. In a typical message queue implementation, a system administrator installs and configures a commercially available message queue manager and defines a named message queue. An application registers a software routine that listens for messages placed in the queue, and other applications may then connect to the queue and transfer messages onto it. The queue manager stores the messages until a receiving application connects and calls the registered software routine. The message can then be processed by the receiving application.","The efficient processing of messages is critical in enterprise software systems and cloud computing platforms that utilize content servers for electronic record management and management of real-time activities and information, such as in business activity monitoring (BAM) and business process management (BPM) solutions. In most current systems, a single message queue, or message service, such as Java Message service is created and used by different applications. This creates a significant message processing bottleneck and limits the flexibility of message processing.","There are several well-established use cases of message queues in a content server, such as a workflow task queue, fulltext index task queue, and business process execution monitoring. For the workflow task queue, a queue table is created to support workflow\/router functionality. As a workflow executes, some tasks become ready for execution and are entered to this queue. The designated performer of the task acquires and executes the task, and brings the workflow execution to the next state. For fulltext indexing, the content server does full-text indexing asynchronously. When an object is created, updated, or destroyed, the content server generates a fulltext indexing request and adds the request to a queue. The fulltext index agent retrieves the request from the queue and calls the indexing server to update the fulltext indexes accordingly. In the BAM context, to monitor business process execution status, various events about business process activities must be recorded and then extracted by the BAM server into an integration table for further format and aggregation processing. Each of these use cases, among others, present certain issues with regard to current single message queue systems. In general, sharing a message queue by multiple features presents performance disadvantages. The workflow task queue is a hot spot in the system because of frequent add\/delete to\/from actions in the queue. For example, a workflow task execution causes frequent updates to set the task state, and updates to individual tasks are done on a one-by-one basis. The same is true for handling fulltext indexing tasks. As the task queue size grows, queries and updates on the queue will slow down because of various indexes defined over the queue table. This is especially true in some special cases, such as when many fulltext indexing requests are generated, while the index agent is not able to consume at a consistent rate to keep the queue at a manageable size.","Another issue with the existing queuing mechanisms is that the message schema is generally fixed. That is, message schemas are specifically defined for specific workflows and cannot be used for other purposes in general. Present message queue systems also suffer from transactional limitations in that they use polling to find available index requests, which presents an intrinsic problem of controlling the polling interval. Frequent polling causes unnecessary system resource consumption while overly long polling intervals result in unacceptable latency.","The issues associated with present message queue systems are generally caused by the content servers not providing a general message queue mechanism that different applications can use to create and manage their own queues. Although the Java Messaging System may provide the possibility of using message services provided by third-party providers, using such external message services may not meet the performance requirements of the use cases in content server environment as listed above. In addition, using JMS introduces additional deployment and administration complexity. For example, transaction management can also be problematic in that two phase commit (2PC) protocols may be needed when using third party message services.","What is needed, therefore, is a generic and flexible message queue mechanism that allows applications to create and manage their own message queues. What is further needed is a message queue system that eliminates unnecessary polling by providing a notification mechanism such that a message consumer will be blocked when there are no pending messages available in the queue, and the blocked message consumer is notified as soon as a message becomes available.","The subject matter presented herein provides a message queue system that creates separate message queues for different applications in content server and other computing environments. The message queue system allows for the dynamic creation of message queues by applications on an as-needed basis, the implementation of a message as a persistent object with a defined schema that facilitates inter and intra-application messaging, and the integration of message creation with notification to streamline the message transaction process among users (i.e., application threads or applications). Embodiments include a message queue that is implemented in a content server as a persistent object type and that acts on messages that are an object of the type, along with API (application program interface) mechanisms that allow for creating and destroying message queues as needed.","Prior to describing the subject matter in detail, an exemplary hardware device in which the subject matter may be implemented shall first be described. Those of ordinary skill in the art will appreciate that the elements illustrated in  may vary depending on the system implementation. With reference to , an exemplary system for implementing the subject matter disclosed herein includes a hardware device , including a processing unit , memory , storage , data entry module , display adapter , communication interface , and a bus  that couples elements - to the processing unit .","The bus  may comprise any type of bus architecture. Examples include a memory bus, a peripheral bus, a local bus, etc. The processing unit  is an instruction execution machine, apparatus, or device and may comprise a microprocessor, a digital signal processor, a graphics processing unit, an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), etc. The processing unit  may be configured to execute program instructions stored in memory  and\/or storage  and\/or received via data entry module .","The memory  may include read only memory (ROM)  and random access memory (RAM) . Memory  may be configured to store program instructions and data during operation of device . In various embodiments, memory  may include any of a variety of memory technologies such as static random access memory (SRAM) or dynamic RAM (DRAM), including variants such as dual data rate synchronous DRAM (DDR SDRAM), error correcting code synchronous DRAM (ECC SDRAM), or RAMBUS DRAM (RDRAM), for example. Memory  may also include nonvolatile memory technologies such as nonvolatile flash RAM (NVRAM) or ROM. In some embodiments, it is contemplated that memory  may include a combination of technologies such as the foregoing, as well as other technologies not specifically mentioned. When the subject matter is implemented in a computer system, a basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computer system, such as during start-up, is stored in ROM .","The storage  may include a flash memory data storage device for reading from and writing to flash memory, a hard disk drive for reading from and writing to a hard disk, a magnetic disk drive for reading from or writing to a removable magnetic disk, and\/or an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM, DVD or other optical media. The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the hardware device .","It is noted that the methods described herein can be embodied in executable instructions stored in a computer readable medium for use by or in connection with an instruction execution machine, apparatus, or device, such as a computer-based or processor-containing machine, apparatus, or device. It will be appreciated by those skilled in the art that for some embodiments, other types of computer readable media may be used which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, RAM, ROM, and the like may also be used in the exemplary operating environment. As used here, a \u201ccomputer-readable medium\u201d can include one or more of any suitable media for storing the executable instructions of a computer program in one or more of an electronic, magnetic, optical, and electromagnetic format, such that the instruction execution machine, system, apparatus, or device can read (or fetch) the instructions from the computer readable medium and execute the instructions for carrying out the described methods. A non-exhaustive list of conventional exemplary computer readable medium includes: a portable computer diskette; a RAM; a ROM; an erasable programmable read only memory (EPROM or flash memory); optical storage devices, including a portable compact disc (CD), a portable digital video disc (DVD), a high definition DVD (HD-DVD\u2122), a BLU-RAY disc; and the like.","A number of program modules may be stored on the storage , ROM  or RAM , including an operating system , one or more applications programs , program data , and other program modules . A user may enter commands and information into the hardware device  through data entry module . Data entry module  may include mechanisms such as a keyboard, a touch screen, a pointing device, etc. Other external input devices (not shown) are connected to the hardware device  via external data entry interface . By way of example and not limitation, external input devices may include a microphone, joystick, game pad, satellite dish, scanner, or the like. In some embodiments, external input devices may include video or audio input devices such as a video camera, a still camera, etc. Data entry module  may be configured to receive input from one or more users of device  and to deliver such input to processing unit  and\/or memory  via bus .","A display  is also connected to the bus  via display adapter . Display  may be configured to display output of device  to one or more users. In some embodiments, a given device such as a touch screen, for example, may function as both data entry module  and display . External display devices may also be connected to the bus  via external display interface . Other peripheral output devices, not shown, such as speakers and printers, may be connected to the hardware device .","The hardware device  may operate in a networked environment using logical connections to one or more remote nodes (not shown) via communication interface . The remote node may be another computer, a server, a router, a peer device or other common network node, and typically includes many or all of the elements described above relative to the hardware device . The communication interface  may interface with a wireless network and\/or a wired network. Examples of wireless networks include, for example, a BLUETOOTH network, a wireless personal area network, a wireless 802.11 local area network (LAN), and\/or wireless telephony network (e.g., a cellular, PCS, or GSM network). Examples of wired networks include, for example, a LAN, a fiber optic network, a wired personal area network, a telephony network, and\/or a wide area network (WAN). Such networking environments are commonplace in intranets, the Internet, offices, enterprise-wide computer networks and the like. In some embodiments, communication interface  may include logic configured to support direct memory access (DMA) transfers between memory  and other devices.","In a networked environment, program modules depicted relative to the hardware device , or portions thereof, may be stored in a remote storage device, such as, for example, on a server. It will be appreciated that other hardware and\/or software to establish a communications link between the hardware device  and other devices may be used.","It should be understood that the arrangement of hardware device  illustrated in  is but one possible implementation and that other arrangements are possible. It should also be understood that the various system components (and means) defined by the claims, described below, and illustrated in the various block diagrams represent logical components that are configured to perform the functionality described herein. For example, one or more of these system components (and means) can be realized, in whole or in part, by at least some of the components illustrated in the arrangement of hardware device . In addition, while at least one of these components are implemented at least partially as an electronic hardware component, and therefore constitutes a machine, the other components may be implemented in software, hardware, or a combination of software and hardware. More particularly, at least one component defined by the claims is implemented at least partially as an electronic hardware component, such as an instruction execution machine (e.g., a processor-based or processor-containing machine) and\/or as specialized circuits or circuitry (e.g., discrete logic gates interconnected to perform a specialized function), such as those illustrated in . Other components may be implemented in software, hardware, or a combination of software and hardware. Moreover, some or all of these other components may be combined, some may be omitted altogether, and additional components can be added while still achieving the functionality described herein. Thus, the subject matter described herein can be embodied in many different variations, and all such variations are contemplated to be within the scope of what is claimed.","In the description that follows, the subject matter will be described with reference to acts and symbolic representations of operations that are performed by one or more devices, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the device in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the subject matter is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.","To facilitate an understanding of the subject matter described below, many aspects are described in terms of sequences of actions. At least one of these aspects defined by the claims is performed by an electronic hardware component. For example, it will be recognized that the various actions can be performed by specialized circuits or circuitry, by program instructions being executed by one or more processors, or by a combination of both. The description herein of any sequence of actions is not intended to imply that the specific order described for performing that sequence must be followed. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context.","In an embodiment, the computer system  includes one or more methods of implementing a message queue mechanism to allow an application to create message queues suited for its specific need. The overall system allows for the creation of separate queues for different applications to avoid using the single queue for multiple purposes. Such a system provides for the following: allowing an application to drop a message queue when it is no longer needed; supporting operations for adding, acquiring, updating, and removing messages; supporting batch processing mode for message add\/acquire and other operations, maintaining messages as always persisted, such that when a message is generated and added to a queue, it is always stored in database and a message is removed from the queue only after the consumer has acknowledged that the message has been consumed. Such a system also provides that when a message is created within an explicit user transaction, the message persistence takes place together with user data when commit( ) is invoked by the application. If a message is created without an explicit user transaction open, message data are committed immediately before the message add API returns. Moreover, a message is consumed by a single client only, so that a message will be processed (or acquired) once only; for example, if there are ten or more queued messages in queue Q and both client A and client B invoke Q, one of the clients will get messages - and the other will - respectively. In this system, a message can be assigned a priority and the message with the highest priority is always consumed first. When there are multiple messages with the same priority, the one that is created earliest is consumed first. A message is removed from the queue only after the consumer has acknowledged that the message has been successfully processed. The message queue system supports non-blocking message acquisition modes only because there are no use cases for blocking message acquisition. In non-blocking mode, acquisition operation returns immediately if there are no ready messages available. In blocking message acquisition mode, operation for acquiring a message may be blocked if there are no pending messages. When a message becomes available later, the blocked consumer is notified of the availability of message and will continue. The system also allows multiple sessions to add\/acquire messages to\/from the same queue concurrently. Message service APIs are made to be multithread-safe.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","204","1","2","1","2","206","206","208","1","208","2","208"]},"In the context of message queue system , a message goes through the following steps from generation to disposal: (1) the producer creates a message and adds it to the message queue; (2) the message consumer acquires the message; (3) the message consumer processes the message; and (4) the message consumer acknowledges that the message has been processed (succeed or fail). The message is deleted from the queue if the message has been successfully processed (succeed). The message may be retained for trouble shooting or retry in case the message processing failed.","As the message is processed by the system, it goes through several state changes.  illustrates a process of message state transitions for a message queue system, under an embodiment. A message is in ready state when it is initially created. Only messages in ready state can be acquired. The message in ready state is set to acquired state when it is acquired by a client. Then the message is deleted after the client has acknowledged that the message has been successfully processed, the message is set to dead state otherwise. As shown in flow diagram , when a message is created and added to the queue, it is in ready state . When a message in ready state  is acquired by a client for processing, its state is set to acquired . After having finished processing the message, the message consumer client acknowledges that the message has been successfully processed and set its state to completed . A message in completed state  will be removed from the queue immediately, as shown in deleted state . If the client acknowledges that the message processing has failed, and the message has not exceeded the retry limit, the message will be reset to ready state  for re-delivery. If message processing has failed and the retry limit is exceeded, the message state is set to dead , and it is removed from the queue, as shown in deleted state . A dead message may be retained in the queue for trouble shooting, and a failed message may be deleted from the queue immediately as soon it is acknowledged. Dead messages will eventually be purged either manually or by a message service daemon process.","In an embodiment, a message consists of a number of attributes of primitive types. Alternatively, the message may be defined as an XML document, which is stored as pure ASCII text. Implementing a message as an XML document allows users to define more flexible message structure, but certain relational database management systems may have a limitation on the maximum size of attribute, and so implementations may need to accommodate such limits.","In an embodiment, a message queue  is implemented in a content server as a persistent object type. A message may simply be an object of the type. A message queue has the following attributes: (1) attributes inherited from a persistent object, (2) attributes defined by an application and specified as API arguments when a message queue is created; and (3) internal attributes, which are attributes that exist for every message queue.  is a table  that lists the internal message queue attributes, under an embodiment.","In general, all messages added to a queue by a single session are guaranteed to be acquired in the order they were created, as specified by the msg_creation_time attribute. If they are assigned different priorities, higher priority messages are always acquired first. For messages with the same priority, the ones with the earlier creation time are acquired first. Messages added by different sessions, however, may not always be in the order of their creation time because of concurrency or delay within individual session threads. In overall processing, the ordering of messages consumed by a client usually has only a rough relationship to the order in which they were produced.","In an embodiment, the message queue is created on an as-needed by an application. A configuration object (e.g., dmc_mq_config) is used to store message queue configuration properties. The message queue (mq) configuration object is derived directly from the system object (SysObject) and has certain inherent attributes.  is a table  that lists the attributes of the message queue configuration object, under an embodiment. The message queue object instance is created when a message queue is created. The attribute object_name (inherited from SysObject) is also set to the name of the message queue. The configuration object is destroyed when the message queue is dropped.","In an embodiment, the message service is implemented through one or more APIs. The message queue mechanism has certain functional characteristics. A message is implemented as a persistent object, and it is the responsibility of application to know which message attributes to set and set them appropriately after a message object is created. APIs are provided for the following tasks: create message queue (DFC and DQL); destroy message queue (DFC and DQL); create a message; set message attributes (which attributes to set is the application's responsibility; add messages to a queue; acquire messages from a queue; update the message state; purge messages from a queue; browse messages in a queue; list all message queues; set message queue configuration properties; and query message queue metrics.","In an embodiment, certain message queue security measures are implemented. For example, the user who creates a message queue is the owner of the message queue. creating message queue requires \u2018create type\u2019 privilege; thus, any users who needs to create message queues must be granted \u2018create type\u2019 privilege. This can be done using DQL grant\/revoke statements. A message queue is virtually created as a type without super type. Superuser privilege may be required to create a type without super type. The owner, sysadmin, or superuser privileges are required to administrate message queue, including updating dmc_mq_config object, granting\/revoking queue access permissions, purging messages from queue, deleting message queue. Certain permissions may be defined for a message queue. These include: (1) produce allow adding messages to the message queue; consume\u2014allow acquiring messages from the message queue; browse\u2014allow browsing messages in the message queue. Though a user with browse permission is allowed to query message queue, it is not allowed to add, delete, or update messages through DQL.","In an embodiment, a message service daemon (process\/thread) is created and runs as internal session for performing the certain house-keeping tasks apart from normal message service operations, such as failure handling. For example, if a client crashes or hangs after having acquired a message but before completing processing the message, the message will remain in acquired state forever. To handle this failure scenario, message server will periodically check if there are any messages that have been acquired for a long time but have not been acknowledged. If yes, it assumes that the message consumer has either crashed or hung, and will reset these acquired messages to ready state. The message service also periodically checks messages that have expired and discards them to keep storage consumption at a minimum. Dead messages are also periodically purged from the message queue.","In an embodiment, the message queue service includes mechanisms to track certain queue metrics, which may include the following: the number of messages in a queue; the average number of messages in queue since server was last restarted; the peak number of messages in queue since server was last restarted; the total number of messages that have been added to queue since server was last restarted; the total number of messages that have been deleted from queue since server was last restarted; the total number messages that failed; the average message waiting time in queue; the maximum message waiting time in queue; and the number of messages that expired since server was last restarted. These metrics can be dynamically maintained in memory and will reset every time the content server is restarted.","In the case that the message server is hosted by a content server, any message service related errors, information, warning, or trace messages will go to the content server log. In an embodiment, the system includes a separate log for each messages queue. The content server can then point to the message queue specific log. When implemented in a content server, certain event subscription mechanisms may need to be added or changed to utilize the flexible message queue mechanism. In general, a content server defines two types of events: (1) notification events and (2) audit events. In an example of a specific implementation, an event subscription is represented as an object of type dmi_registry. The two different event types are differentiated by the value of attribute dmi_registry.is_audittrail. A Notification event is generated as an object of type dmi_queue_item, while an audit event is generated as an object of type dm_audittrail.","With the flexible message queue mechanism, different message queues can be created for notification events generated by different applications, instead of putting all the notification events in table dmi_queue_item. This requires adding one additional attribute \u2018destination_queue\u2019 to type dmi_registry to indicate to which message queue to deliver a notification event. Certain changes to event subscription APIs may also need to be made. For example, the commands register and audit, and the related APIs for event registration in certain interfaces (e.g., PersistentObject and AuditTrailManager) should be updated accordingly to take destination queue information into consideration. Event generation functions in the content server must be made aware of the destination queue of the event and deliver generated events to their designated queues.","In general, content servers generate one event for each subscription. When two or more users subscribe to the same event, each user will have its own subscription and the content server will generate one event for each of these subscriptions. In an embodiment, this situation will remain the same with multiple message queues for a plurality of applications.","In an embodiment, the flexible message queue is implemented as part of an enterprise content management platform, such as the Documentum platform provided by EMC Corp. These platforms provide management capabilities for all types of content including business documents, photos, video, medical images, e-mail, Web pages, fixed content, XML-tagged documents, and so on. They are built around a repository in which the content is stored securely under compliance rules. This repository appears as a unified environment, although content may reside on multiple servers and physical storage devices within a distributed environment. In general, Documentum functionality is available through a variety of user interfaces and through application programming interfaces (APIs).","For an embodiment in which the flexible message queue is implemented in a Documentum system, a Java interface, IDfMessageQueue is defined in a DFC package for the message queue. The class DfMessageQueue implements IDfMessageQueue. An instance of class DfMessageQueue uniquely indentifies a message queue in a Documentum repository.  is a table  that lists all the methods of IDfMessageQueue, under an example embodiment.","Certain configuration properties are defined for a message queue. These include: queue_name, redelivery_count, retain_dead_msg, retain_period, expirationinterval, default_priority, and delivery_timeout. Table  of  provides the description of these properties. Certain set\/get configuration properties are required to save the object to the database.  is a table  that lists the methods of the IDFMessageQueueConfig, under an example embodiment.","In an embodiment, the interface IDFMessage is defined for setting\/getting message properties (internal attributes) as well as message data attributes (application defined).  is a table  that lists the methods of the IDFMessage, under an example embodiment. An interface IDfMessageQueueFactory for creating a message queue can be implemented through a class DfMessageQueueFactory. An application can call the static method DfMessageQueueFactory.getInstance( ) to get a DfMessageQueueFactory instance. In an example implementation, the method idfMessageQueue is defined as follows:","idfMessageQueue createMessageQueue (IDfSession session, String Name, Collection <Attribute> attrs).","This method would create a message queue with the given name, i.e. creating an object type with name dmc_mq_<qName>. The third argument specifies all the attributes of the message queue. \u2018Create type\u2019 privilege is required to call this method. Creating a message queue will also causes a dmc_mq_config object to be created implicitly. Once the message queue is created, one can update the configuration properties either through APIs defined in IDfMessageQueueConfig.","In an embodiment, an interface IDfMessageQueueManager is defined for creating attribute objects that are needed in creating a message queue, destroying\/instantiating the message queue for the given queue name, and listing all message queues.  is a table  that lists all the methods of IDfMessageQueueManager, under an example embodiment.","In an embodiment, certain. DQL (doctrine query language) statements are provided for creating\/destroying message queue. Example statements include:","CREATE MESSAGE_QUEUE queue_name[(property_def{,property_def})]","DROP MESSAGE_QUEUE queue_name","Executing the CREATE MESSAGE_QUEUE statement causes an object type with name dmc_mq_<queue_name> to be created. Creating a message queue also causes a dmc_mq_config object to be created with object_name set to the queue name. Executing the DROP MESSAGE_QUEUE statement causes type dmc_mq_<queue_name> to be dropped and the corresponding dmc_mq_config object to be destroyed. The following DQL statements can optionally be supported for managing message queue security:","GRANT <privilege_list> ON MESSAGE_QUEUE <mq_name> TO <user_list>","REVOKE <privilege_list> ON MESSAGE_QUEUE FROM <user_list>","Where <user_list> is docbase user or group names separated with comma while <privilege_list> is any combination of \u2018produce\u2019, \u2018consume\u2019, and \u2018browse\u2019 separated with comma.","In an alternative embodiment, the flexible message queue system can implement a message as a registered table instead of a persistent object type to avoid including inherent attributes from persistent type. Certain mechanisms may need to be implemented to overcome certain drawbacks, however, such as handling repeating attributes, and leveraging existing code for dealing with reading\/writing message object from\/to database. Additionally, a queue administrator may be appointed to perform administrative operations on the queue. Such a queue administrator may be defined as an attribute of the dm_mq-config object (as opposed to Sysadmin or superuser). A message service daemon can also run as the queue administrator for performing message queue house keeping tasks.","Through the appropriate API interfaces, the flexible message queue system is configured to allow different applications to create\/destroy message queues on-the-fly as needed, and allows for the creation of different queues for different applications. An application can define a message schema to fit its specific needs, instead of having multiple applications share a fixed message schema. An application can define a distinct message schema to be used by its respective processes. The flexible message queue system also allows message persistence to be transactional with other application data, thus making 2PC protocols unnecessary.","The flexible message queue further allows multiple users to add or acquire messages to and from the same queue concurrently. Messages can be assigned a priority for hierarchical processing, and failed messages can be retried for a defined number of times. When a message is created with an explicit user transaction, the message persistence takes place together with the user data. If a message is created without an explicit user transaction open, message data is committed immediately. A simple access control mechanism is provided to control who is allowed to add messages to the queue, acquire messages from the queue, and browse messages in the queue.","In general, the flexible message queue system should be able to support a large number of concurrent sessions, such as expected event generation rate is at least 600 events per second per queue at peak time. There should be near zero latency for adding\/acquiring a message to\/from queue, near zero latency for most queue management operations, and deleting messages from the queue should have minimum impact on other queue operations.","The use of the terms \u201ca\u201d and \u201can\u201d and \u201cthe\u201d and similar referents in the context of describing the subject matter (particularly in the context of the following claims) are to be construed to cover both the singular and the plural, unless otherwise indicated herein or clearly contradicted by context. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range, unless otherwise indicated herein, and each separate value is incorporated into the specification as if it were individually recited herein. Furthermore, the foregoing description is for the purpose of illustration only, and not for the purpose of limitation, as the scope of protection sought is defined by the claims as set forth hereinafter together with any equivalents thereof entitled to. The use of any and all examples, or exemplary language (e.g., \u201csuch as\u201d) provided herein, is intended merely to better illustrate the subject matter and does not pose a limitation on the scope of the subject matter unless otherwise claimed. The use of the term \u201cbased on\u201d and other like phrases indicating a condition for bringing about a result, both in the claims and in the written description, is not intended to foreclose any other conditions that bring about that result. No language in the specification should be construed as indicating any non-claimed element as essential to the practice of the invention as claimed.","Preferred embodiments are described herein, including the best mode known to the inventor for carrying out the claimed subject matter. Of course, variations of those preferred embodiments will become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventor expects skilled artisans to employ such variations as appropriate, and the inventor intends for the claimed subject matter to be practiced otherwise than as specifically described herein. Accordingly, this claimed subject matter includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover, any combination of the above-described elements in all possible variations thereof is encompassed unless otherwise indicated herein or otherwise clearly contradicted by context."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Advantages of the subject matter claimed will become apparent to those skilled in the art upon reading this description in conjunction with the accompanying drawings, in which like reference numerals have been used to designate like elements, and in which:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
