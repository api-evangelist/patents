---
title: Method for providing bitwise constraints for test generation
abstract: A method for enabling bitwise or bit slice constraints to be provided as part of the test generation process, by providing a language structure which enables these constraints to be expressed in a test generation language such as e code for example. The language structure for such bitwise constraints is then handled in a more flexible manner, such that the test generation process does not attempt to rigidly “solve” the expression containing the constraint as a function. Therefore, the propagation of constraints in such a structure do not necessarily need to be propagated from left to right, but instead are generated in a multi-directional manner. The language structure is particularly suitable for such operators as “[:]”, “|”, “&”, “^”, “˜”, “>>” and “<<”.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06918076&OS=06918076&RS=06918076
owner: Verisity Ltd.
number: 06918076
owner_city: Rosh HaAyin
owner_country: IL
publication_date: 20010828
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This Application claims priority from U.S. Provisional Application No. 60\/228,087, filed on Aug. 28, 2000, which is hereby incorporated by reference as if filly set forth herein.","The present invention relates to a method for providing bitwise constraints for test generation, and in particular, to such a method which are operative with a test generation code language such as that provided by the Specman\u2122 functional programming environment (Verisity Design, Inc., Mountain View, Calif., USA).","Design verification is the process of determining whether an integrated circuit, board, or system-level architecture, exactly implements the requirements defined by the specification of the architecture for that device. Design verification for a device under testing (DUT) may be performed on the actual device, or on a simulation model of the device. For the purposes of explanation only and without intending to be limiting in any way, the following discussion centers upon testing which is performed on simulation models of the device.","As designs for different types of devices and device architectures become more complex, the likelihood of design errors increases. However, design verification also becomes more difficult and time consuming, as the simulation models of the design of the device also become more complex to prepare and to test.","The problem of design verification is compounded by the lack of widely generalizable tools which are useful for the verification and testing of a wide variety of devices and device architectures. Typical background art verification methods have often been restricted to a particular device having a specific design, such that the steps of preparing and implementing such verification methods for the simulation model must be performed for each new device.","The process of verifying a design through a simulation model of the device is aided by the availability of hardware description languages such as Verilog and VHDL. These languages are designed to describe hardware at higher levels of abstraction than gates or transistors. The resultant simulated model of the device can receive input stimuli in the form of test vectors, which are a string of binary digits applied to the input of a circuit. The simulated model then produces results, which are checked against the expected results for the particular design of the device. However, these languages are typically not designed for actual verification. Therefore, the verification engineer must write additional programming code in order to interface with the models described by these hardware description languages in order to perform design verification of the device.","Examples of testing environments include static and dynamic testing environments. A static testing environment drives pre-computed test vectors into the simulation model of the DUT and\/or examines the results after operation of the simulation model. In addition, if the static testing environment is used to examine the results which are output from the simulation model, then errors in the test are not detected until after the test is finished. As a result, the internal state of the device at the point of error may not be determinable, requiring the simulation to be operated again in order to determine such internal states. This procedure consumes simulation cycles, and can require the expenditure of considerable time, especially during long tests.","A more useful and efficient type of testing is a dynamic testing environment. For this type of environment, a set of programming instructions is written to generate the test vectors in concurrence with the simulation of the model of the DUT and while potentially being controlled by the state feedback of the simulated device. This procedure enables directed random generation to be performed and to be sensitive to effects uncovered during the test itself on the state of the simulation model of the device. Thus, dynamic test generation clearly has many advantages for design verification.","Within the area of testing environments, both static and dynamic testing environments can be implemented only with fixed-vector or pre-generation input. However, a more powerful and more sophisticated implementation uses test generation to produce input stimuli.","One example of such a test generator is disclosed in U.S. Pat. No. 6,182,258, incorporated by reference as if fully set forth herein. This test generation procedure interacts with, and sits as a higher level over, such hardware description languages as Verilog and VHDL. The test generation procedure is written in a hardware-oriented verification specific object-oriented programming language. This language is used to write various tests, which are then used to automatically create a device verification test by a test generator module. A wide variety of design environments can be tested and verified with this language. Thus, the disclosed procedure is generalizable, yet is also simple to program and to debug by the engineer.","The disclosed language features a number of elements such as structs for more richly and efficiently describing the design of the device to be simulated by the model. Unfortunately, the disclosed language and resultant test generation environment does not include the ability to use bitwise constraints.","A bitwise constraint can also be termed a \u201cbit slice constraint\u201d. In the modeling of hardware entities such as registers, and input data such as computer instruction streams, there is often a need to express a property over some partial segment of the variable. An example would be a computer instruction word that is 32 bits wide composed of an opcode field of 16 bits and an operand field of 16 bits, where the desired property is to keep the operand field to the value of zero.","U.S. patent application Ser. No. 09\/020,792, described above, discloses a method of applying arithmetic constraints which consider the value of the variable as a whole, or the full 32 bits in the example above. Bitwise constraints add the ability to constrain arbitrary sub-fields of a variable and perform bitwise operations on the variable. Bitwise constraints can be defined as arithmetic relations where at least one of the following bit operations is used:\n\n","One example of such a bitwise constraint is the expression:\n\nkeep x[2:0]==0b101\n\nCurrently available code languages for test generation would compute the operator \u201c[:]\u201d as a function, such that in the above example, an unconstrained x variable would first be generated. Next, \u201cx[2:0]\u201d would be computed as a function, after which the value for this computed function would be compared to \u201c0b101\u201d. Such a process would frequently result in an incorrect calculation, and hence an incorrect constraint. A more usefull solution would handle such a bitwise constraint correctly through more flexible generation. Unfortunately, such a solution is not currently available.\n","The background art does not teach or suggest a method for providing bitwise constraints for test generation code languages, such that these constraints are correctly and flexibly handled.","The method of the present invention overcomes these deficiencies of the background art by enabling bitwise or bit slice constraints to be provided as part of the test generation process, by providing a language structure which enables these constraints to be expressed in a test generation language such as e code for example. The language structure for such bitwise constraints is then handled in a more flexible manner, such that the test generation process does not attempt to rigidly \u201csolve\u201d the expression containing the constraint as a function. Therefore, the propagation of constraints in such a structure do not necessarily need to be propagated from left to right, but instead are generated in a multi-directional manner. The language structure is particularly suitable for such operators as \u201c[:]\u201d, \u201c|\u201d, \u201c&\u201d, \u201c^\u201d, \u201c\u02dc\u201d, \u201c>>\u201d and \u201c<<\u201d.","According to the present invention, there is provided a method for providing a bitwise constraint for test generation, the method comprising: providing a language structure for expressing the bitwise constraint, said language structure including a plurality of constraint parameters and at least one operator, said constraint parameter constrained to an interval containing at least one value, said interval having interval limits; propagating information bi-directionally to determine interval limits for said constraint parameters; and generating a test value for the constraint parameter.","The method of the present invention could also be described as a plurality of instructions being performed by a data processor, such that the method of the present invention could be implemented as hardware, software, firmware or a combination thereof. For the present invention, a software application could be written in substantially any suitable programming language, which could easily be selected by one of ordinary skill in the art. The programming language chosen should be compatible with the computing platform according to which the software application is executed. Examples of suitable programming languages include, but are not limited to, C, C++ and Java.","The method of the present invention enables bitwise or bit slice constraints to be provided as part of the test generation process, by providing a language structure which enables these constraints to be expressed in a test generation language such as e code for example. The language structure for such bitwise constraints is then handled in a more flexible manner, such that the test generation process does not attempt to rigidly \u201csolve\u201d the expression containing the constraint as a function. Therefore, the propagation of constraints in such a structure does not necessarily need to proceed from left to right, but instead are preferably generated in a multi-directional manner. The language structure is particularly suitable for such operators as \u201c[:]\u201d, \u201c|\u201d, \u201c&\u201d, \u201c^\u201d, \u201c\u02dc\u201d, \u201c>>\u201d and \u201c<<\u201d.","It should be noted that this language structure is the syntactic form that expresses bit constraints, e.g. \u201ckeep x[5:8]==0\u201d, and should be distinguished from the computational structure, which supports simple computations with arithmetic and bit constraints and which is a range-list with bit representation according to the present invention. Preferably, the computational structure enables arithmetic and bit constraints to be solved simultaneously, or at least in parallel.","According to the method of the present invention, preferably the computational structure for the bitwise constraints is constructed on the basis of range lists. Each range list includes at least one interval, but may optionally include a plurality of intervals, in which case the range list representing an unconstrained parameter includes one interval containing all possible values. One or more intervals may become invalid during the process of range list intersection. The range lists are then extended with a vector of state values, each of which corresponds to one bit of the generated item. The range list representation is of an arithmetical range, which represents possible values. Each arithmetical value in that range is then preferably mapped to a bit, according to the bit constraint, by translating the number into a value from the vector of state values.","Preferably, each element in the vector has four state values. State values more preferably represent four possible states of the corresponding bit:\n\n","This computational structure can then be used in order to preferably simultaneously represent two different types of constraints. The first type of constraint includes any constraint having an operator as previously defined, which is a bit constraint. The second type of constraint includes a constraint which is related to a constraint of the first type through the propagation of \u201cbitwise\u201d information. The second type of constraint is preferably computed by translating the range list into bitwise values, which take one of the above states of the vector, according to the bit constraint as previously described. Preferably, these different types of constraints are propagated in a bi-directional manner within the bitwise constraint structure; in other words, the effect of resolving arithmetical constraints on bitwise constraints is optionally and preferably assessed, as well as the opposing effect.","The combination of both types of constraints is preferably used for assisting in the resolution of structures related to both types of constraints simultaneously. The combination of these two different structures provides for a more efficient process of resolution, since test generation may optionally feature both bit constraints and arithmetic constraints.","For example, the conversion of bit constraints to range list representation, which would be required if both types of structures could not be resolved simultaneously, could possibly result in an unbounded number of ranges. Similarly, bit constraints alone are not operative to define both types of structures, if range list computational structures were not available, since arithmetical constraints cannot be represented efficiently by bitwise values.","According to preferred embodiments of the present invention, the bitwise constraints are generated by being first reduced, more preferably through the manipulation of the two different types of constraints simultaneously, or at least in parallel. The step of reduction preferably is performed by computing a new value for one of the parameters of the constraint, and then intersecting the range of values of the parameter by this new value, using a bitwise &. For example, given two range lists with corresponding bitwise information, the union of the range lists and the bit information can optionally and preferably be performed, while still maintaining the meaning\/effect of the bit constraints and the arithmetical constraints.","More preferably, those bit(s) in the interval which should be zero are indicated by the maximum of the interval.","During the process of value generation with the bitwise constraint structure, preferably the number of solutions for each interval of the interval representation is determined. An interval is then selected randomly according to its weight. Finally, a point is selected from within the selected interval.","According to optional but preferred embodiments of the present invention, an invalid interval may arise when a range list has one or more values that are illegal. Such an interval may optionally and preferably be examined for the effect of other constraints, as well as enabling the constraints on the invalid interval to be handled through the resolution of bitwise constraints in the preferably parallel bitwise structure. In resolving these constraints, the illegal values of the invalid interval may also be resolved by being removed, thereby eliminating the problem of invalid intervals. Such a process may optionally be termed \u201ccorrection of the interval limit\u201d, as the limits of the interval may be changed through this process to remove illegal values, for example. Invalid intervals may also optionally be removed.","The principles and operation of the system and method according to the present invention may be better understood with reference to the drawings and the accompanying description.","Referring now to the drawings,  is a schematic block diagram illustrating an exemplary system according to the present invention for test generation. It should be noted that the illustrated system only includes those functions of the test generation procedure which are required for the description of the present invention. A more complete description of the entire test generation procedure may be found in U.S. patent application Ser. No. 09\/020,792, previously incorporated by reference. It should also be noted that although the present invention is described in the context of a simulation model, the present invention is also useful for verification of a physical device. Both the physical device and the simulation model can be described as a DUT (device under test), which is in a test environment.","A test generation system  features a simulator , which may accept a design  for the device under test (DUT), written in a hardware descriptive language such as Verilog or VHDL. In addition, simulator  interacts with a test engine  for performing the test generation procedure at run-time. The interaction between simulator  and test engine  is shown as bi-directional, since test engine  provides input to simulator , and in turn receives the results from simulator  as input for further operation.","Test engine  features a test generator , connected to a run-time system  for testing DUT  at run-time. Test generator  receives one or more constraints , such as the bitwise constraints described in greater detail below, and an I\/O data model , and then performs the testing and verification of DUT . Run-time system  both drives and samples simulator  during the run-time testing procedure. Run-time system  also evaluates temporal expressions and emits events. These events are defined according to a temporal coverage event definition input , which feeds the definitions of the events to be covered to run-time system .","During the process of testing and verification, a temporal coverage data collector  requests the values for one or more variables from run-time system . These requests are performed according to a triggering event emitted by run-time system , such as a fixed, predefined sampling time and\/or the occurrence of a temporal pattern of state transitions as defined by a temporal expression given in a temporal language, for example. Temporal coverage data collector  is able to communicate with test generator  and to access the requested data through the API (application programming interface) for test generator . Such an API specifies the software function calls required in order to collect the desired data. This collected data is then analyzed by a data analyzer , as described in greater detail below.","After being analyzed by data analyzer , the analyzed data is then displayed to the user, preferably through a GUI (graphical user interface; not shown). For example, the data could be displayed to indicate the presence of particular coverage holes for single coverage items, cross-coverage items and\/or interval coverage items. According to a preferred embodiment of the present invention, the analyzed data is used as feedback to adjust constraints  according to the coverage afforded by these constraints. For example, if a coverage hole or holes were found, constraints  could be adjusted in order to test the absent state or states of DUT . Such feedback is preferably performed automatically, but could also optionally be performed manually by the user.","According to a preferred embodiment of the present invention, constraints , I\/O data model  and temporal coverage  are preferably constructed in e code, which is the code language provided by the Specman\u2122 functional programming environment (Verisity Design, Inc., Mountain View, Calif., USA) and disclosed in U.S. patent application Ser. No. 09\/020,792. Such an embodiment is preferred because of the ease and flexibility of programming in e code. The following description centers upon this preferred embodiment, it being understood that this is for the purposes of description only and is not meant to be limiting in any way.","The e code language is a hardware-oriented verification specific object-oriented programming language. Objects in this language are instances of \u201cstructs\u201d, which contain a field, and one or more functions, or methods, which operate on data stored within the field and which interact with other objects. Optionally, a constraint can operate on the field, thereby altering the data stored in the field, for example by restricting the range of possible values for the data. The field can also be used to store more complex structures, including other structs and lists of scalars or structs.","The process of test generation fills data elements, including structs and fields, with random values. The possible data values for each element can optionally be limited by constraints, which provide the direction for the directed test generation. The method of the present invention is particularly directed toward the provision of bitwise constraints. The following section describes a number of illustrative command structures for such constraints in the e code language, it being understood that these command structures are only being given for the purposes of illustrating a particularly preferred embodiment of the present invention. In addition, a description is provided of exemplary algorithms for solving such bitwise constraints. This example is illustrative only and is not intended to be limiting in any way. For a more complete explanation of the commands, see U.S. patent application Ser. No. 09\/020,792, previously incorporated by reference.","Examples are provided of the ability of the present invention to handle the following constraints:",{"@attributes":{"id":"p-0042","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"keep x[j:i] == y","(1)"]},{"entry":[{},"keep x|y == z","(2)"]},{"entry":[{},"keep x & y == z","(3)"]},{"entry":[{},"keep x {circumflex over (\u2002)} y == z","(4)"]},{"entry":[{},"keep \u02dcx == y","(5)"]},{"entry":[{},"keep x << k == y","(6)"]},{"entry":[{},"keep x >> k == y","(7)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{},{}],"in-line-formulae":[{},{}]},"The present invention provides a new strategy for more flexible handling of the above constraints. The present invention preferably operates by rendering all of the constraints from (1) to (7) as multi-directional constraints, thereby preferably providing several modes of constraint propagation between constraint parameters.","Initial Assumptions","For the problem (1) it is agreed that i and j are generated before x and y, i.e. there is no constraint propagation from x and y to i and j. Similarly, for the problems (6) and (7) there is no propagation from x and y to k. In practice these restrictions mean that constraints like:\n\nkeep 125[j:i]==0b101;\n\nkeep 14>>k==7;\n\ncannot be solved for i, j or k.\n\nBasic Data Structure: bitRL\n","The data structures for bitwise constraints handling are preferably constructed on the basis of RL's (new range lists). A new structure called bitRL is preferably obtained by extending RL type with a vector of 4-state values, each of which corresponds to one bit of the generated item. Values in this vector represent four possible states of the corresponding bit:\n\n","The following notation for bitRL is used through this document: \n\n\nThe two components of this representation are called respectively interval representation and bitwise representation.\n\nThe following two groups of constraint parameters should be represented by bitRLs:\n\n",{"@attributes":{"id":"p-0047","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Reduction of bitwise operations"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"13"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"12","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"|","\u22a5","0","1","T","&","\u22a5","0","1","T","\u02dc",{}]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"12","align":"center","rowsep":"1"}}]},{"entry":[{},"\u22a5","\u22a5","\u22a5","\u22a5","\u22a5","\u22a5","\u22a5","\u22a5","\u22a5","\u22a5","\u22a5","\u22a5"]},{"entry":[{},"0","\u22a5","0","1","T","0","\u22a5","0","0","0","0","1"]},{"entry":[{},"1","\u22a5","1","1","1","1","\u22a5","0","1","T","1","0"]},{"entry":[{},"T","\u22a5","T","1","T","T","\u22a5","0","T","T","T","T"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"12","align":"center","rowsep":"1"}}]}]}}]}}},"Consider the constraint keep x|y==z. Consider only the information about bits. Assume that all x, y and z are four-bit ranges with the following initial values:\n\n","The reduction is then preferably performed as follows:\n\n","Problems (6) and (7) are addressed straightforwardly by shifting the corresponding bitwise representations.","Constraint Propagation Within RLs","The information is preferably propagated in two directions inside bitRLs in order to solve both types of constraints in parallel. The maximum of the interval range indicates which bits in the bitwise representation should always be zero.","Assume, x is a 6-bit uint with the following initial range: \n\n\nThe maximum of the interval representation is 30, which is 011110. Thus, the most significant bit in the bitwise representation should be zero, i.e. \n\n\nPropagation in the opposite direction is preferably used for correction of interval bounds and removing of invalid intervals.\n","If the range used in Example 2 is used, the following facts are observed:\n\n","For this case the correct result of the propagation from bitwise representation to intervals should be: \n\n","The following example shows the above computations in more detail.","Assume the precise lower bound for the interval [21 . . . 30] of Example 3 is to be computed. Namely, a minimal number t, such that 21\u2266t and t satisfies the bitwise representation (010).","The computation goes as follows. First, check if the lower bound satisfies the bitwise representation. In this case we are done. However, 21=(010101)does not match (010). Now, consider only those bits of 21 which correspond to  in the bitwise representation. Namely, the underlined bits from (011)are used to obtain the number 4=(100). The next step is to increment this number getting 5=(101)and assign the obtained bits respectively to -bits in the bitwise representation: the result is (010110)=22.","Similarly, upper bounds are computed by considering all bits corresponding to  in representation of the upper bound. The only difference is that decrement operation is used instead of increment.","As can be observed, the complexity of evaluation of each bound depends linearly on the number of bits in bitwise representation of range.","In general the process of propagation between bitwise and interval representation consists in computing precise bounds for each interval. Consider an interval [l . . . h]. For the lower bound l a minimal number l\u2032 is computed such that l\u2266l\u2032 and l\u2032 matches the bitwise representation. Similarly for the higher bound h, a maximal number h\u2032 is computed such that h\u2032\u2266h and h\u2032 matches the bitwise representation. If the new interval [l\u2032 . . . h\u2032] is valid, i.e. l\u2032\u2266h\u2032, it replaces [l . . . h]. Otherwise the interval [l . . . h] is removed from the representation.","Generation","In this section the question of value generation out of bitRLs is addressed. The following procedure is preferably followed:\n\n","The following examples illustrate how to compute the number of solutions for each interval in the interval representation.","Continuing with the case of Example 3: \n\n\nConsider the interval [22 . . . 30]. The binary representations of the interval bounds are respectively 010 and 010. Only the underlined bits are considered and collected, i.e. those which set to  in the bitwise representation of x. Now, if the underlined bits are collected, two numbers are obtained: 5=(101)and 7=(111). It's clear that each number satisfying the bitwise representation of x and laying inside [22 . . . 30] can be obtained as a bit combination ranging between 101 and 111. There are 3 solutions (7\u22125+1) within the interval [22 . . . 30].\n","Using the same technique, the first interval [4 . . . 6] is used to compute two valid solutions.","Similarly, as binary representations can be used for computing the number of solutions, they can be used for random selection of points.","As it is shown in Example 5, the probability of selecting the interval [2 . . . 6] on the second step of the generation algorithm is \u2156 and the probability of selecting [22 . . . 30] is \u2157 (according to the number solutions in the intervals). Assume that the second step of the algorithm selects [22 . . . 30]. Now, the goal is to find a number in [22 . . . 30] which satisfies the bitwise representation of x. Each solution for this problem can be expressed as a binary combination of three bits ranging from 5=(101)to 7=(111). Thus, a number from the interval [5 . . . 7] is selected randomly. Assume that the selection is 6=(110). The final step consists in taking the three bits of 6 and assigning them to the positions represented by  in the bitwise representation of x. Thus, the final result is (010)=28.","Additional Reordering","In order to increase the number of cases successfully handled by the present invention, the following preferred additional order rules for \u201cbit slicing\u201d and \u201cshift\u201d constraints may optionally and preferably be considered:\n\nkeep x[j:i]==y:(i,j)\u2192(x,y), (y)(x)\n\nkeep x<<k==y:(k)\u2192(x,y)\n\nkeep x>>k==y:(k)\u2192(x,y)\n\nHere \u201c\u2192\u201d and \u201c\u201d denote \u201chard\u201d and \u201csoft\u201d ordering respectively. All \u201chard\u201d order relations shown above are covered by the initial assumptions. The motivation behind the \u201csoft\u201d ordering (y)(x) in bit slicing constraint is preferably explained by example.\n","Assume that the following constraint is present:\n\nkeep x[3:0] in [1,2,4,8];\n\nThis constraint naturally means that only one of four least significant bits of x should be 1 and all the others be 0. This constraint is preferably automatically translated into the following two constraints:\n\nkeep x[3:0]==t;\n\nkeep t in[1,2,4,8];\n\nwhere t is a temporary variable. To avoid problems with this example, preferably the implicit \u201csoft\u201d ordering (t)(x) is used to generate t to one of values from [1,2,4,8]. Then the generated value is propagated to the bits of x and the constraint finally succeeds.\n","The following declarations are assumed through this section:\n\n","Now consider separately the following eight test cases:\n\n","This case can be solved by the present invention as shown in the previous sections.\n\n","An example of the actual process for providing and imposing bitwise constraints in the test generation environment is described in greater detail below, it being understood that this example is for the purposes of illustration only and is without any intention of being limiting. The exemplary constrained system is as follows.","First, a struct S, shown below, is assumed to have two fields, X and Y, of 4 bits each. The struct S also is assumed to have three constraints marked (1), (2) and (3) that impose a relationship between X and Y. The constraint (1) is arithmetic, while constraints (2) and (3) are bit-wise constraints.",{"@attributes":{"id":"p-0074","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"struct S"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"field X (4 bits)"]},{"entry":[{},"field Y (4 bits)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(1) keep X > 4"]},{"entry":[{},"(2) keep Y[1:2]==X[1:2]"]},{"entry":[{},"(3) keep Y[1]==0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The application of constraint (1) to field X results in the following range list, shown in the box below. \n\n","The application of constraint (3) to field Y results in the following bit range (T represents either 1 or 0), shown in the box below. \n\n","Constraint (2) determines a relationship between field X and field Y. The application of constraint (2) first causes a conversion of the field X range list to bit ranges. The arithmetical values in the range list are preferably converted to bit ranges by first determining bit values for each arithmetical value. If the bit does not change throughout the values of the range list, then the bit is set to either 0 or 1. If the bit does change value throughout the arithmetical values, then the bit is preferably set to the \u201c\u201d value. The effect of a bitwise constraint may cause the bit to be converted to \u201c0\u201d, for example. \n\n","Next, the following reduce step results in anding together the bit ranges of fields Y and X to create a new bit range for field X, as shown in the boxes below. \n\n","The generation step that follows assigns values in the permissible range, as determined from the previous step, such as setting field Y to 6 and field X to 7, for example, shown in the boxes below. \n\n\n","While the invention has been described with respect to a limited number of embodiments, it will be appreciated that many variations, modifications and other applications of the invention may be made."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4","EXAMPLE 5","EXAMPLE 6","EXAMPLE 7","Some Examples"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING","p":["The invention is herein described, by way of example only, with reference to the accompanying drawing, wherein:",{"@attributes":{"id":"p-0021","num":"0027"},"figref":"FIG. 1"}]},"DETDESC":[{},{}]}
