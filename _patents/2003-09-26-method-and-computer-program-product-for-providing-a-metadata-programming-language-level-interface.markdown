---
title: Method and computer program product for providing a meta-data programming language level interface
abstract: A method for providing a meta-data programming language level interface is disclosed. The method includes receiving an object name from a client program via a meta-data retrieval API, where the object name corresponds to an object located in a runtime environment that includes one or more methods. Meta-data associated with the object is requested from the runtime environment. Meta-data is received for each method included in the object. The meta-data for each method is transmitted to the client program via the meta-data retrieval API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07308679&OS=07308679&RS=07308679
owner: International Business Machines Corporation
number: 07308679
owner_city: Armonk
owner_country: US
publication_date: 20030926
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present disclosure relates generally to a method for providing a meta-data programming language level interface and in particular, to a method for providing a meta-data programming language interface that may be accessed during program runtime.","Today's Internet driven economy has accelerated users' expectations for unfettered access to information resources and transparent data exchange among applications. One of the key issues limiting data interoperability today is that of incompatible meta-data. Meta-data is information about other data, or simply data about data. Meta-data is typically utilized by tools, databases, applications and other information processes to define the structure and meaning of data objects. Unfortunately, most applications are designed with proprietary schemes for modeling meta-data. Applications that define data using different semantics, structures and syntax are difficult to integrate, impeding the free flow of information access across application boundaries. This lack of meta-data interoperability hampers the development and efficient deployment of numerous business solutions (e.g., data warehousing, business intelligence, software development).","The Common Object Request Broker Architecture (CORBA) specification enforces a language neutral interface, or meta-data, definition for remote distributed object services. There are at least two ways in which a CORBA enabled object or service can be defined. First, by defining a distributed service's interface in an interface definition language (IDL) and deriving each language level interface via an IDL compiler for each language. Second, a CORBA enabled object or service may be defined by taking an existing service defined already in a particular programming language (e.g., Java, C++, Ada) and constructing a language neutral interface definition from the programming language level interface. In the second scenario, a particular programming language level interface must be examined in a purely abstract manner without any programming language specific validation of referenced types in an interface definition so that a language neutral interface definition can be derived from it.","Currently, many object-oriented programming languages define an interface and\/or abstract class definition that describes the API provided by a program module service. This is done to clearly separate the abstract interface from the implementation class that implements one or more of the abstract interface APIs. This type of programming separation technique allows developers to provide distributed objects that expose their remote interfaces in a purely abstract manner. This allows distributed clients of the distributed objects to use that abstract interface information to learn about the service. This information may be utilized for many purposes including dynamic method invocation, client-side proxy of target service generation and client-side tooling for distributed object services. But currently, in order to achieve such interface to implementation separation in a distributed environment, the developer would be required to take the existing interface definitions already defined at its language level and redefine them as distributed object definitions and work back down into the language level to piece them together.","In one embodiment, a method for providing a meta-data programming language level interface is disclosed. The method includes receiving an object name from a client program via a meta-data retrieval API, where the object name corresponds to an object located in a runtime environment that includes one or more methods. Meta-data associated with the object is requested from the runtime environment. Meta-data is received for each method included in the object. The meta-data for each method is transmitted to the client program via the meta-data retrieval API.","In another embodiment, a computer program product for a method for providing a meta-data programming language level interface is disclosed. The computer program product comprises a storage medium readable by a processing circuit and storing instructions for execution by the processing circuit for performing a method. The method includes receiving an object name from a client program via a meta-data retrieval API, where the object name corresponds to an object located in a runtime environment that includes one or more methods. Meta-data associated with the object is requested from the runtime environment. Meta-data is received for each method included in the object. The meta-data for each method is transmitted to the client program via the meta-data retrieval API.","An exemplary embodiment of the present invention provides a tightly integrated programming language level interface\/service meta-data application programming interface implementation within object-oriented or service-oriented programming languages. A client program may introspect the meta-data of any running object in a purely abstract manner using these API methods. An exemplary embodiment of the present invention provides an integrated way for any object-oriented programming language to provide abstract interface level meta-data within its program language runtime environment rather than relying on a separate interface definition language for a given programming language level interface definition. This support allows programming languages that provide this functionality to achieve bottom-up mapping of their programming language level interface definition to more abstract distributed object level interface definition. This bottom-up mapping technique allows any running object with this programming language level interface\/service meta-data retrieval API support to be dynamically introspected during run-time. This includes exposing the running object interface\/service meta-data without prior knowledge to the running object API.","In addition, this type of programming separation technique lends itself to providing distributed objects that expose their remote interfaces in a purely abstract manner. This allows distributed clients of the distributed objects to use that abstract interface information to learn about the service that it is planning to use. The information may be utilized for many purposes including dynamic method invocation, client-side proxy of target service generation, and client-side tooling for distributed object services. In alternate exemplary embodiments of the present invention the same functions are provided within a non-object oriented programming language that clearly define its services in a distributed manner for access by distributed clients within their own programming language.","Exemplary embodiments of the present invention, by utilizing purely abstract interfaces obtained through a meta-data retrieval application API, may dynamically introspect the meta-data within a programming language specific environment and provide an abstract interface to a client environment dynamically. The client tooling program may then assemble client method invocations dynamically. In a similar context, with this type of support, a client tooling environment may also display the meta-data information of any programming language specific services in a purely abstract language neutral manner. An exemplary embodiment of the present invention describes the manner in which programming languages may furnish this purely abstract interface definition without any unnecessary language specific validation and\/or runtime checks. This definition may be furnished by program language providers within a programming language through clearly defined APIs for retrieving meta-data.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["102","102","104","104","102","104","110","104","108","106","112","114","108","106","104"]},"Given a running Java object, a Java client which has a handle to this Java object may discover its interface\/service meta-data which is originally declared in its Java interface source code  by using an API. The Java client will use an API built into the Java object itself to initially retrieve a Java interface meta-data class . Then, the Java interface meta-data class , will request for its containing methods, one or more instances of the Java method meta-data class  as well as its fields, represented as one or more instances of the Java field meta-data class . Each of these classes (Java interface meta-data class , Java field meta-data class , Java method meta-data class ) will hold abstract data such as: its type (in the case of the Java interface meta-data class  the type of its Java interface meta-data); its return type as a Java interface meta-data type  (in the case of the Java method meta-data class , the return type of its Java method meta-data which is an instance of Java interface meta-data); its Java parameter meta-data parameter type  (in case of \u2014parameter type of its Java method meta-data); and its field type as a Java interface meta-data type  type (in the case of the Java field meta-data class , the type of its Java field meta-data which will be an instance of Java interface meta-data or a primitive data type). Note that the Java parameter meta-data type  and an optional additional exception meta-data type may be implemented as sub-interfaces of the Java interface meta-data type .",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 2","FIG. 2"],"b":["202","204","210","204","208","206","212","214","216","208","206","204"]},"Given a running C++ object, a C++ client which has a handle to this C++ object may discover its abstract\/service meta-data which is originally declared in its C++ abstract source code  by using an API. The C++ client will use an API built into the C++ object itself to initially retrieve a C++ abstract meta-data class . Then, the C++ abstract meta-data class , will request for its containing methods, one or more instances of the C++ method meta-data class  as well as its fields, represented as one or more instances of the C++ field meta-data class . Each of these classes (C++ abstract meta-data class , C++ field meta-data class , C++ method meta-data class ) will hold abstract data such as: its type (in the case of the C++ abstract meta-data class  the type of its C++ abstract meta-data); its return type as a C++ abstract meta-data type , (in the case of the C++ method meta-data class , the return type of its C++ method meta-data which is an instance of C++ abstract meta-data); its C++ parameter meta-data parameter type  (in case of \u2014parameter type of its C++ method meta-data); and its field type as a C++ abstract meta-data type  (in the case of the C++ field meta-data class , the type of its C++ field meta-data which will be an instance of C++ abstract meta-data or a primitive data type). Note that the C++ parameter meta-data type  and an optional additional exception meta-data type may be implemented as sub-abstracts of the C++ abstract meta-data type .",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 1","FIG. 2"]},"In an exemplary embodiment of the present invention, the Java programming language API may be provided by utilizing the bytecode of the language level interface class and providing an API to retrieve meta-data information for the given interface class in a purely abstract manner (e.g., via string data). Java class meta-data information such as field(s) and\/or method(s) may be reflected without the required validation of any referenced classes (e.g., required when Java Reflection API is used). This allows applications that require field(s)\/method(s) information at an object interface level for code generation (e.g., ejbdeploy, rmic) and\/or application assembly or deploy tools (e.g., application assembly tool, application server deployment tool) to be able to retrieve such information without burdening itself by having to load all referenced classes during Java Reflection API operations.","Exemplary embodiments of the present invention provide a new static reflection API for retrieving such meta-data information on a Java class. The implementation may be written in the Java programming language, although it may be written in other programming languages and hooked into the Java programming language via an API. In an exemplary embodiment, the byte array of the Java class is reflected along with a ClassLoader instance to be utilized to search for the requested class. An exemplary embodiment of the present invention creates the internal data structure of the input class byte array (also known as the bytecode) and extracts the field_info section along with the method_info section of the bytecode. Then it processes these bytecode fields along with the bytecode constant pool (cp_info) to find any classes that are referred to by the info sections. Once they are all found, a Java object is constructed that holds all necessary information for representing a field and\/or method instance.","An exemplary embodiment of utilizing a meta-data programming language level interface in the Java programming language follows. These same concepts may be applied to other programming languages (e.g., C++, Eiffel, COBOL).  is a block diagram of exemplary objects and interfaces that may be utilized in an exemplary embodiment of the present invention.  depicts a live, running java object called the superman object  that has been initiated from a Java client . The superman object  inherits from the human interface  and from the bird interface . The human interface  includes three methods : walk( ); talk( ) and write( ). The bird interface  includes the methods : fly( ) and talk( ). In an exemplary embodiment of the present invention, the client code has created an instance of the Superman class and wants to inquire about the meta-data associated with the human interface  and bird interface .","The human interface  may be defined in a Java programming language as a Java source file. The human interface  source file may include:",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Human interface - enforces walk, talk, write methods"]},{"entry":[{},"interface Human {"]},{"entry":[{},"\u2003\u2003\u2003\u2003Destination walk (Destination target);"]},{"entry":[{},"\u2003\u2003\u2003\u2003Human talk (Human target);"]},{"entry":[{},"\u2003\u2003\u2003\u2003WriteableObject write (WriteableObject target);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"306"},{"@attributes":{"id":"p-0027","num":"0026"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Bird interface - enforces fly, talk methods"]},{"entry":[{},"interface Bird {"]},{"entry":[{},"\u2003\u2003\u2003\u2003Destination fly (Destination target);"]},{"entry":[{},"\u2003\u2003\u2003\u2003Bird talk (Bird target);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Superman class - which is instantiable during runtime"]},{"entry":[{},"class Superman implements Human, Bird {"]},{"entry":[{},"\u2003\u2003\u2003\u2003String name = \u201cKent, Clark\u201d;"]},{"entry":[{},"\u2003\u2003\u2003\u2003public Superman (String name) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003this.name = name;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["302","308"]},"Also, in this example, a client MAIN function instantiates the Superman class and then disguises it as an interface. Disguising a class as an interface is typical in a distributed environment where the client almost always only works with interfaces since the instantiated object on the client side is a proxy that hides the internal workings of the methods in the class. In addition to disguising the Superman class, the MAIN function calls an exemplary embodiment of a Java interface meta-data class  retrieval API, or hook, called \u201cinterface\u201d on a live Java object to retrieve the Human interface and Bird interface which the Superman class implements to instantiate a \u201cjava.lang.Interface\u201d class for both Human and Bird interface respectively. Input to the \u201cprintInterface\u201d method includes an interface name. Output from the \u201cprintInterface\u201d method includes meta-data (e.g., the interface definition) associated with the interface that was input. An exemplary embodiment of a client MAIN function, written in a Java language follows:",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Client code being driven to use Superman object and its interfaces"},{"entry":"public static void main (String[ ] args) {"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Creating a Superman object"},{"entry":"\u2003\u2003\u2003\u2003Superman clark = new Superman(\u201cKent, Clark\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Superman disguised as a Human"},{"entry":"\u2003\u2003\u2003\u2003Human man = (Human) clark;"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Superman disguised as a Bird"},{"entry":"\u2003\u2003\u2003\u2003Bird bird = (Bird) clark;"},{"entry":"\u2003\u2003\u2003\u2003\/\/ java.lang.Interface class that represents the Human"},{"entry":"\u2003\u2003\u2003\u2003(meta-data) interface"},{"entry":"\u2003\u2003\u2003\u2003printInterface(man.interface);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ java.lang.Interface class that represents the Bird"},{"entry":"\u2003\u2003\u2003\u2003(meta-data) interface"},{"entry":"\u2003\u2003\u2003\u2003printInterface(bird.interface);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The printInterface interface method that is invoked prints out interface information to a screen. This method may be utilized to duplicate the interface definition dynamically during runtime. Other interface methods may be created from the java.lang.Interface class and utilized to duplicate interface definitions, or interface meta-data during runtime. An exemplary embodiment of a printInterface method follows:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"private static void printInterface(java.lang.Interface intf)"},{"entry":"\u2003\u2003\u2003\u2003\/\/Introspect input java.lan.Interface using a meta-data"},{"entry":"\u2003\u2003\u2003\u2003programming"},{"entry":"\u2003\u2003\u2003\u2003\/\/ language level interface"},{"entry":"\u2003\u2003\u2003\u2003Method[ ] intfMethods = intf.getMethods( );"},{"entry":"\u2003\u2003\u2003\u2003System.out.println(\u201cinterface \u201c + intf.getName( ) + \u201c {\u201c);"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Print out interface dynamically during runtime"},{"entry":"\u2003\u2003\u2003\u2003for (inst i=0; i,intfMethods.length; i++) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003String methodName = intfMethods[ ].getName( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003String returnType = intfMethods[i].getReturnType( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003String[ ] paramterTypes = intfMethods[i]."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003getParameterTypes( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003System.out.print(\u201c\\t\u201d + returnType + \u201c \u201d +"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003methodName + \u201c(\u201c);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003for (intfj = 0; j<parameterTypes.length; j++) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003System.out.print(parameterTypes[j]."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003getName( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ If this isn't the last parameter, append \u2018,\u2019"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003If (j < parameterTypes.length\u22121) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003System.out.print(\u201c,\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003System.out.println(\u201c);\u201d);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003System.out.println(\u201c}\u201d);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In an exemplary embodiment of the present invention, executing the MAIN function, including invoking the printInterface method for man.interface (\u201cjava.lang.Interface\u201d class instance of the Human interface meta-data class) and bird.interface (\u201cjava.lang.Interface\u201d class instance of the Bird interface meta-data class) will result in the following output:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface Human {"]},{"entry":[{},"\u2003\u2003\u2003\u2003Destination walk(Destination target);"]},{"entry":[{},"\u2003\u2003\u2003\u2003Human talk(Human target);"]},{"entry":[{},"\u2003\u2003\u2003\u2003WriteableObject write(WriteableObject target);"]},{"entry":[{},"}"]},{"entry":[{},"interface Bird {"]},{"entry":[{},"\u2003\u2003\u2003\u2003Destination fly(Destination target);"]},{"entry":[{},"\u2003\u2003\u2003\u2003Bird talk(Bird target);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["402","404","406","408","410"]},"In an alternate exemplary embodiment another hook may be utilized to provide an interface name to retrieve a Java interface meta-data class. Example code for directly using an interface name includes:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"java.lang.Interface bird = java.lang.Interface.forName(\u201cBird\u201d);"]},{"entry":[{},"\/\/ special built-in static method \u201cforName\u201d returns an instance of"]},{"entry":[{},"\u201cjava.lang.Interface\u201d for Bird interface meta-data class"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Human man = (Human) clark;"},{"entry":"Bird bird = (Bird) clark;"},{"entry":"printInterface(man.interface);"},{"entry":"\/\/ where man.interface is an instance of \u201cjava.lang.Interface\u201d for the"},{"entry":"Human interface meta-data class"},{"entry":"printInterface(bird.interface)"},{"entry":"\/\/ where bird.interface is an instance of \u201cjava.lang.Interface\u201d for the"},{"entry":"Bird interface meta-data class"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"An exemplary embodiment of the present invention may be used by WebSphere for zOS v.4.01 SL4 System Management for Java Programming Language to introspect the Enterprise Java Bean (EJB) method level deployment descriptors. In addition, the exemplary embodiment may be utilized to properly assign method level deployment descriptors without requiring an Enterprise Archive (EAR file which contains one or more EJBs) to contain all Java classes that each of the EJBs reference. In this manner, the zOS's system management deployment strategy where deployment of each EAR may be done separately from the deployment target application server (where each application being deployed is required to provide all referenced classes) may be supported.","Embodiments of the present invention may be utilized to provide dynamic information about what an object is capable of handling. Instead of being forced through a database to collect meta-data (e.g., CORBA implementation) embodiments of the present invention allow the meta-data information to be accessed via a program during runtime. In this manner, the client may dynamically determine the capabilities of a particular object's interface.","As described above, the embodiments of the invention may be embodied in the form of computer-implemented processes and apparatuses for practicing those processes. Embodiments of the invention may also be embodied in the form of computer program code containing instructions embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other computer-readable storage medium, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention. An embodiment of the present invention can also be embodied in the form of computer program code, for example, whether stored in a storage medium, loaded into and\/or executed by a computer, or transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via electromagnetic radiation, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention.","While the invention has been described with reference to exemplary embodiments, it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted for elements thereof without departing from the scope of the invention. In addition, many modifications may be made to adapt a particular situation or material to the teachings of the invention without departing from the essential scope thereof. Therefore, it is intended that the invention not be limited to the particular embodiment disclosed as the best mode contemplated for carrying out this invention, but that the invention will include all embodiments falling within the scope of the appended claims. Moreover, the use of the terms first, second, etc. do not denote any order or importance, but rather the terms first, second, etc. are used to distinguish one element from another."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring to the exemplary drawings wherein like elements are numbered alike in the accompanying Figures:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
