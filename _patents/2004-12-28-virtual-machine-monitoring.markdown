---
title: Virtual machine monitoring
abstract: A system and method for monitoring internal operation of a virtual machine (“VM”). The VM is operated to interpret and execute a program. During operation of the VM, status information regarding internal operation of the VM is stored to an internal memory buffer. The status information is subsequently extracted from the internal memory buffer during operation of the VM to monitor internal operation of the VM from a vantage point external to the VM.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07886294&OS=07886294&RS=07886294
owner: SAP AG
number: 07886294
owner_city: Walldorf
owner_country: DE
publication_date: 20041228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to virtual machines, and in particular but not exclusively, relates to monitoring internal operation of virtual machines.","Enterprise software has transformed the way diverse enterprises, large and small a like, transact and manage day-to-day operations. Businesses use enterprise software (e.g., web based application servers) to control production planning, purchasing and logistics, warehouse and inventory management, production, vendor management, customer service, finance, personnel management, and other basic business activities. As the enterprise software industry continues to mature, the various application and hardware resources enlisted to facilitate this diverse set of tasks are being amalgamated into robust, highly integrated solutions (e.g., SAP NetWeaver, SAP xAPPs, mySAP Business Suite, etc.).","To integrate diverse hardware and software resources, developers of enterprise software have leveraged cross platform engines capable of minimizing or even severing platform dependencies from the enterprise solution. The Java 2 Platform, Enterprise Edition\u2122 (\u201cJ2EE\u201d) (e.g., J2EE Specification, Version 1.4) is a Java based solution supported by the Java Virtual Machine (\u201cJVM\u201d) engine. J2EE simplifies application development and decreases the need for programming and programmer training by creating standardized and reusable modular components. The popularity of Java based solutions is evident as the Information Technology (\u201cIT\u201d) world has gravitated to the Java language.","As enterprise software is woven into the fabric of modern business, failure of an enterprise solution may no longer be a mere nuisance, but has the potential to wreak catastrophic havoc on a business. As such, robust, reliable software is evermore critical. The enterprise software industry is marching toward the ultimate goal of self-healing software capable of sustainable, uninterrupted operation, without human intervention. In pursuit of this goal, IT technicians can benefit from convenient tools capable of monitoring the health of their enterprise software. With appropriate monitoring tools, IT technicians can take appropriate action in a timely manner to ensure a healthful state of their software or to spot delinquent applications and prevent repeat offenders. Currently, JVMs do not provide adequate mechanisms to monitor their internal operation on a real-time basis.","A system and method of monitoring internal operation of a virtual machine (\u201cVM\u201d) is described. The VM is operated to interpret and execute a program. During operation of the VM, status information regarding internal operation of the VM is stored to an internal memory buffer. The status information is subsequently extracted from the internal memory buffer during operation of the VM to monitor internal operation of the VM from an external vantage point of the VM. In one embodiment, the VM is a Java VM.","In one embodiment, the status information is accumulated by executing monitoring code embedded within the program. Execution of the monitoring code can be interleaved with execution of program code of the program.","During execution of the program, objects are created and stored to a heap. When the objects are no longer referenced by the program, an automatic garbage collector erases the unreferenced objects. In one embodiment, the status information includes garbage collecting activity information.","In one embodiment, a native VM monitor is invoked to retrieve the status information from within the internal memory buffer. The retrieved status information may then be communicated to a monitoring console for display on the monitoring console.","In one embodiment, a VM monitoring program is interpreted and executed on the VM. The VM monitoring program is dedicated to gathering at least a portion of the status information from components of the VM and store the portion of the status information to the internal memory buffer.","In one embodiment, the internal memory buffer is insulated from failure of the VM. If the VM should fail, the internal memory buffer may be accessed after the failure to conduct a postmortem investigation of why the VM failed.","Embodiments of the invention may include all or some of the above described features. The above features can be implemented using a computer program, a method, a system or apparatus, or any combination of computer programs, methods, or systems. These and other details of one or more embodiments of the invention are set forth in the accompanying drawings and in the description below.","Embodiments of a system and method for monitoring internal operation of a virtual machine (\u201cVM\u201d) are described herein.  is a block diagram of a system  for monitoring the internal operation of a virtual machine (\u201cVM\u201d) , in accordance with an embodiment of the invention. The illustrated embodiment of system  includes VM , programs , and a monitoring console . Although three programs  are illustrated as operating on VM , more or less programs  may concurrently operate in a time multiplexing manner.","VM  interprets and executes one or more programs  to generate output results . VM  interprets programs  by converting them from an intermediate interpreted language (e.g., bytecode) into a native machine language, which is then executed. In one embodiment, VM  is a Java VM (\u201cJVM\u201d) while programs  represent Java programs compiled into Java bytecode. Although embodiments of the invention are described in connection with the object oriented Java programming language, the techniques described herein are equally applicable to other interpreted languages and VMs used to interpret and execute these languages.","During operation of VM , VM  can provide real-time status information  to monitoring console  for display thereon. Status information  may provide detailed operational information of the internal workings of VM  during interpreting and executing programs . An Information Technology (\u201cIT\u201d) technician can simply scan status information  displayed on monitoring console  to determine whether VM  is operating in a healthful state, whether a failure is imminent, or otherwise. Furthermore, status information  may be accessed after VM  has failed\/crashed to conduct a postmortem investigation as to the cause of the failure.","Status information  may be \u201cpulled\u201d to monitoring console  in response to status queries  issued by monitoring console  or status information  may be \u201cpushed\u201d to monitoring console . Pushing status information  to monitoring console  may be event triggered or periodically triggered. Monitoring console  may be located locally on the same hardware machine executing VM , or advantageously, executed on a remote machine communicatively couple thereto. Status information  may include a variety of data including, but not limited to, garbage collecting activity, heap status, execution activity, thread activity, program activity, and the like.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","105","125","105","200","205","210","105","215"]},"Native wrapper  provides the runtime environment for VM . In an embodiment where VM  is a JVM complaint with the Java 2 Platform, Enterprise Edition\u2122 (\u201cJ2EE\u201d) (e.g., J2EE Specification, Version 1.4), native wrapper  is often referred to as \u201cJLaunch.\u201d Native wrapper  is native machine code (e.g., compiled C++) executed and managed by OS . Once launched, native wrapper  establishes VM  within itself.","During operation, the illustrated embodiment of VM  includes an internal memory buffer , an internal application programming interface (\u201cAPI\u201d) , a native API , a heap , a heap manager , a garbage collector , an input\/output (\u201cI\/O\u201d) system , and multiple threads  to maintain information associated with a variety of tasks (e.g., programs , garbage collector , etc.) currently being executed by VM . Threads  have not been illustrated for all executable entities in , so not to crowd  and obscure the invention. Internal memory buffer  is used by VM  to store status information  collected from various internal components of VM  during operation. Internal API  provides the various internal components of VM  access to internal memory buffer . In an embodiment where VM  is a JVM, internal API  is referred to as a \u201cJava API.\u201d Native API  provides entities external to VM  access to internal memory buffer , and therefore status information , to monitor the internal operation of VM  from an external vantage point. Native API  enables native machine code entities, such as native VM monitor , to access internal memory buffer  without being interpreted and executed on VM  itself. Although  illustrates native VM monitor  as internal to native wrapper , in some embodiments native VM monitor  may be external to native wrapper .","Heap  is established by VM  as a pre-reserved memory pool for future use by programs  and a VM monitoring program  (discussed in detail below) as they are loaded. Heap  is managed by heap manager  of VM  for allocating and deallocating memory as is required by programs  and for storing objects , created by programs  (or VM monitoring program ).","In an embodiment where programs  are object-oriented programs (e.g., Java programs), they generally include objects and classes. When programs  are loaded and executed by VM , objects  are created and then stored to heap . Classes include methods that perform tasks and return information when they complete those tasks. Objects are essentially reusable software components that model pieces of software programs in terms of properties and behaviors. Classes are used to instantiate an object with these properties and behaviors. In other words, each of objects  inherit their properties and behaviors from a class used to instantiate (e.g., create) the particular object .","As programs  consume heap  by filling it with objects , memory within heap  available to accept new objects may become scarce. Accordingly, garbage collector  implements a disciplined procedure for returning consumed memory back to heap . In one embodiment, garbage collector  is automatically executed by VM  to reclaim dynamically allocated memory without explicit instructions to do so by the programmer of programs . When there are no more references to one of objects  within heap , the particular object  is marked for garbage collection. The memory consumed by the marked object  is then reclaimed when garbage collector  executes. Performing regular garbage collection when available memory within heap  becomes scarce helps avoid resource leaks.","However, when available memory within heap  becomes scarce, performance of VM  suffers due to the garbage collecting activity. For example, if heap  exceeds 80% capacity, garbage collecting activities of garbage collector  may result in the productive computing output (e.g., output results , see ) of VM  grinding to a near halt. Although garbage collector  is relative good at deleting unreferenced objects  to reclaim consumed memory, not all idle objects  are reclaimed for a variety of reasons. As such, the older VM  happens to be, the more likely that VM  is to suffer from chronic garbage collecting activity.","In one embodiment, various entities of VM  are \u201cinstrumented\u201d with monitoring code to accumulate\/generate at least a portion of status information  and copy the portion of status information  into internal memory buffer . Execution of the monitoring code may be interleaved with execution of the regular program code of the entities. The portion of status information  which is accumulated\/generated by the monitoring code may include processing start and stop times of each entity, processing runtime of each thread  executing the entity, a number of objects  created by the particular entity, an amount of memory consumed by the entity, and the like. Each entity can be instrumented to accumulate and\/or generate a variety of status information  relating the operation and execution of the particular entity. These entities may include garbage collector , heap manager , I\/O system , and the like. The monitoring code instrumented into each of these entities has the purpose to collect at least a portion of the vast amount of status information available within VM  and report it into internal memory buffer .","In one embodiment, garbage collector  is instrumented with monitoring code  to accumulate\/generate at least a portion of status information  and copy the portion of status information  into internal memory buffer . Execution of monitoring code  may be interleaved with execution of the regular garbage collecting activities of garbage collector . In one embodiment, monitoring code  is executed in response to a garbage collecting event. The portion of status information  which is accumulated\/generated by monitoring code  includes a variety of garbage collecting related information. This garbage collecting related information may include: time stamps and runtimes of garbage collecting events executed by garbage collector , a count of garbage collecting events, a count of the number of objects  collected from heap  during each garbage collecting event, an amount of memory reclaimed within heap  during each garbage collecting event, an amount of memory available within heap , hits rates of objects  within heap  by requesters (e.g., programs ), heap  utilization, and the like. Furthermore, monitoring code  may maintain a history of recent garbage collecting events within internal memory buffer  and index each garbage collecting event to some or all of the above garbage collecting related information.","In one embodiment, VM monitoring program  may be interpreted and executed on VM  for the primary purpose of gathering status information  and copying status information  into internal memory buffer . VM monitoring program  may be provided solely to perform monitoring duties. VM monitoring program  may collect\/generate any or all of the above status information  described above, as well as other monitoring information. Writing an independent program dedicated for monitoring tasks, enables monitoring programs to be written well after programs  and garbage collector  have been designed without need to update programs  and garbage collector . VM monitoring program  enables developers to generate dedicate monitoring programs to investigate problems or \u201cbugs\u201d within VM  or programs , which do not become apparent until after VM  and\/or programs  have been written and released to the public. In fact, many software problems do not become apparent until a software build has been released to a large user base. As such, VM monitoring program  may be designed to aid with alpha testing of programs  and\/or VM  or even included in a beta release of programs  and\/or VM . VM monitoring program  provides an effective mechanism for implementing later developed monitoring code for execution on VM .","The monitoring code, including monitoring code , and VM monitor program  access internal memory buffer  to copy status information  thereto via internal API . In one embodiment, internal API  abstracts access to internal memory buffer  through use of function calls. Each component of VM  that wishes to copy status information  into internal memory buffer  makes a \u201ccall\u201d to one or more functions published internally to VM  by internal API  and passes the accumulated\/generated status information  to the called function. In turn, the called function copies status information  to an appropriate slot or location within internal memory buffer .","Native VM monitor  acts as a proxy for a variety of external entities (e.g., monitoring console ) requesting access to internal memory buffer  to monitor the internal operation of VM . In one embodiment, native VM monitor  may receive status requests  and serve up status information , or portions thereof, in response. Alternatively, or in addition, native VM monitor  may negotiate a reporting contract with monitoring console  to serve up status information  on a regular or periodic basis, without need of status requests . As such, native VM monitor  may be capable of both pushing status information  to monitoring console , as well as, monitoring console  pulling status information  from native VM monitor .","Abstracting access to internal memory buffer  with internal API  insulates and protects the contents of internal memory buffer  from the rest of VM . Should VM  crash, enter an infinite loop, or otherwise fail, status information  may still be protected and preserved from corruption. Since native API  is executed using native code, native API  is not interpreted and executed by VM . Accordingly, if VM  fails, native VM monitor  can still access internal memory buffer  to obtain the latest status information  updated just prior to VM  failing. As such, the contents of internal memory buffer  may be retrieved to conduct a postmortem investigate to determine the cause of VM 's failure.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","b":["300","105","305","110","105","110"]},"During execution of programs , the monitoring code updates internal memory buffer  with status information  pertaining to the operation of a particular program , consumption of resources by the particular program , and other internal workings of VM  (process block ). The monitoring code may be executed in an interleaving manner with program code of the various sub-entites within VM , as discussed above. In one embodiment, the monitoring code accesses internal memory buffer  via function calls to internal API  and passing the collected\/generated status information  to the called function.","As programs  execute, objects  are created and stored to heap  (process block ). As long as heap  has available memory to store new objects , then programs  will continue to execute and create new objects  as needed. However, should heap  approach capacity and available memory within heap  to accept new objects  become scarce (decision block ), then process  continues to a process block .","In process block , garbage collector  performs automatic garbage collection to delete unreferenced objects  and reclaim the consumed memory within heap . In response to the garbage collecting event, monitoring code  updates internal memory buffer  with status information  containing garbage collecting information (process block ), as described above. In one embodiment, monitoring code  accesses internal memory buffer  via function calls to internal API .","In a process block , native VM monitor  extracts some or all of status information  from internal memory buffer  via native API . In one embodiment, native VM monitor  accesses internal memory buffer  via function calls to native API . In a process block , the retrieved status information  is transmitted to monitoring console . As discussed above, status information  may be pushed to monitoring console  or pulled from native VM monitor  by sending status requests . Monitoring console  may execute on the same hardware executing VM  or execute on remote hardware communicatively coupled to native VM monitor  via a network or other communication medium.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 4","b":["400","400","405","410","405","415","417","420","422","425","427","430"]},"AS instances  may be web application servers, such as Web AS by SAP, .NET by Microsoft, or the like. Each AS instance  may include one or more VMs  to execute programs . Programs  executed by VMs  within AS instances  may collectively provide the logic for implementing various sub-layers (e.g., business layer, integration layer, presentation layer, etc.) of AS instances . It should be appreciated that various components of AS instances  have been excluded from  for the sake of clarity and so as not to obscure the invention. In one embodiment, VMs  may be JVMs compliant with the J2EE standard to execute Java programs. In one embodiment, VMs  may be compliant with the .NET framework from Microsoft to execute .NET programs. An AS instance  may even include VMs  compliant with both the J2EE standard and the .NET framework.","Web dispatcher  implements a load-balancing mechanism distributing service requests from client nodes  among server nodes  within cluster . For example, web dispatcher  may implement a round-robin load-balancing mechanism or the like. Web dispatcher  may be one of server nodes  having the task of dispatching service requests among server nodes  of cluster  or a stand alone hardware node. The service requests are processed by server nodes  and subsequently provided to database node . Database node  offers up the requested data to server nodes , which in turn process and format the results for display on client nodes . Each AS instance  may further include its own dispatcher mechanism to distribute the service requests assigned to it among its individual VMs .","In embodiments where VMs  are JVMs, programs  may be servlets providing server-side logic to generate graphical user interfaces (\u201cGUIs\u201d) on clients nodes  and may further include JavaServer Page (\u201cJSP\u201d) extensions for providing dynamic content within the GUI. Programs  may further include business applications providing the business logic of an Enterprise JavaBean (\u201cEJB\u201d), applets providing client side logic, and the like.","One of client nodes  may execute monitoring console  to provide remote monitoring of AS instances , and in particular, remote monitoring of each VM . If an IT technician notices that one of the VMs  has a low heap utilization, overactive garbage collection activity, or the like, the IT technician can take appropriate action including resetting the problematic VM .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5","b":["500","105","200","300","410","415","420","425","500","505","510","515","520","525","530","500"]},"The elements of processing system  are interconnected as follows. Processor(s)  is communicatively coupled to system memory , NV memory , DSU , and communication link , via chipset  to send and to receive instructions or data thereto\/therefrom. In one embodiment, NV memory  is a flash memory device. In other embodiments, NV memory  includes any one of read only memory (\u201cROM\u201d), programmable ROM, erasable programmable ROM, electrically erasable programmable ROM, or the like. In one embodiment, system memory  includes random access memory (\u201cRAM\u201d), such as dynamic RAM (\u201cDRAM\u201d), synchronous DRAM, (\u201cSDRAM\u201d), double data rate SDRAM (\u201cDDR SDRAM\u201d) static RAM (\u201cSRAM\u201d), and the like. DSU  represents any storage device for software data, applications, and\/or operating systems, but will most typically be a nonvolatile storage device. DSU  may optionally include one or more of an integrated drive electronic (\u201cIDE\u201d) hard disk, an enhanced IDE (\u201cEIDE\u201d) hard disk, a redundant array of independent disks (\u201cRAID\u201d), a small computer system interface (\u201cSCSI\u201d) hard disk, and the like. Although DSU  is illustrated as internal to processing system , DSU  may be externally coupled to processing system . Communication link  may couple processing system  to a network such that processing system  may communicate over the network with one or more other computers. Communication link  may include a modem, an Ethernet card, a Gigabit Ethernet card, Universal Serial Bus (\u201cUSB\u201d) port, a wireless network interface card, a fiber optic interface, or the like.","It should be appreciated that various other elements of processing system  have been excluded from  and this discussion for the purposes of clarity. For example, processing system  may further include a graphics card, additional DSUs, other persistent data storage devices (e.g., tape drive), and the like. Chipset  may also include a system bus and various other data buses for interconnecting subcomponents, such as a memory controller hub and an input\/output (\u201cI\/O\u201d) controller hub, as well as, include data buses (e.g., peripheral component interconnect bus) for connecting peripheral devices to chipset . Correspondingly, processing system  may operate without one or more of the elements illustrated. For example, processing system  need not include DSU .","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","Process  explained above is described in terms of computer software and hardware. The techniques described may constitute machine-executable instructions embodied within a machine (e.g., computer) readable medium, that when executed by a machine will cause the machine to perform the operations described. Additionally, process  may be embodied within hardware, such as an application specific integrated circuit (\u201cASIC\u201d) or the like. The order in which some or all of the process blocks appear in process  should not be deemed limiting. Rather, one of ordinary skill in the art having the benefit of the present disclosure will understand that some of the process blocks may be executed in a variety of orders not illustrated.","The above description of illustrated embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. In some examples above, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring certain aspects. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize.","These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification and the claims. Rather, the scope of the invention is to be determined entirely by the following claims, which are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments of the invention are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
