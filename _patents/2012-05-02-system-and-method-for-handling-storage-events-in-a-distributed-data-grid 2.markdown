---
title: System and method for handling storage events in a distributed data grid
abstract: A system and method can handle storage events in a distributed data grid. The distributed data grid cluster includes a plurality of cluster nodes storing data partitions distributed throughout the cluster, each cluster node being responsible for a set of partitions. A service thread, executing on at least one of said cluster nodes in the distributed data grid, is responsible for handling one or more storage events. The service thread can use a worker thread to accomplish synchronous event handling without blocking the service thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09621409&OS=09621409&RS=09621409
owner: ORACLE INTERNATIONAL CORPORATION
number: 09621409
owner_city: Redwood Shores
owner_country: US
publication_date: 20120502
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of priority on U.S. Provisional Patent Application No. 61\/535,238, entitled \u201cUNIFIED EVENT MODEL FOR USE IN A DISTRIBUTED DATA GRID\u201d filed Sep. 15, 2011, which application is herein incorporated by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The current invention relates to data caching and accessing techniques in distributed computing environments and more particularly to handling storage events in a distributed data grid.","In the context of distributed data management systems, event models are sometimes used to provide information about data changes. In a typical example, a client can register a listener to listen for a particular event on a piece of data. When the data changes, an event is generated and the client is informed of the event by way of a listener.","One limitation with this approach is that it is asynchronous in the sense that the event has already occurred, meaning that the client has no effective means to affect the data change because the client is informed after the event has already occurred. Thus, to make a change to the event, the client may be forced to perform a whole new transaction to make that change. Another limitation is often the size and the scalability of the solution because the client is registered to listen to all events in what is a frequently very large data set.","Additionally, various extensible hooks with different semantics and idiosyncratic forms of configuration are often presented to users as separate features. There can be little documentation about how these hooks relate to one another and it is not always clear which one is the most appropriate to use. In addition, the programming model varies for each hook, many of which have unique limitations.","A new solution is thus desirable, one which would address or resolve the above limitations as well as provide a number of other advantages.","Described herein is a system and method that can handle storage events in a distributed data grid. The distributed data grid cluster includes a plurality of cluster nodes storing data partitions distributed throughout the cluster, each cluster node being responsible for a set of partitions. A service thread, executing on at least one of said cluster nodes in the distributed data grid, is responsible for handling one or more storage events. The service thread can use a worker thread to accomplish synchronous event handling without blocking the service thread.","In accordance with various embodiments, a system and method can handle storage events such as data partition transfer and storage entry events in a distributed data grid. The distributed data grid cluster includes a plurality of cluster nodes storing data partitions distributed throughout the cluster, each cluster node being responsible for a set of partitions. One exemplary distributed data grid is an Oracle\u00ae Coherence data grid. A service thread, executing on at least one of said cluster nodes in the distributed data grid, can be responsible for handling one or more storage events. The service thread can use a worker thread to accomplish synchronous event handling without blocking the service thread.","In accordance with various embodiments, the distributed data grid system can use a server-side event model, which can be implemented as a server-side event handling application programming interface (API), to support the raising and handling of server side events. Using a server-side event model in a distributed data grid system is disclosed in U.S. application Ser. No. 13\/462,719, filed May 2, 2012, now U.S. Pat. No. 9,348,668, issued May 24, 2016, entitled \u201cSYSTEM AND METHOD FOR SUPPORTING A SERVER-SIDE EVENT MODEL IN A DISTRIBUTED DATA GRID,\u201d which application is incorporated herein by reference in its entirety.","Storage Events","In accordance with an embodiment, storage events can be raised within the context of storage enabled members in a distributed data grid. The storage events can be defined as a set of interfaces that correspond to the functional area in which they are raised. These storage events can provide the infrastructure for various features provided by a distributed data grid, such as push replication and continuous aggregation.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1","FIG. 1"],"b":"101"},"As shown in , the event hierarchy  also includes a StorageEvent interface  for a storage event. The StorageEvent interface extends directly from the Event interface. Additionally, the event hierarchy includes a StorageCacheEvent interface , a StorageEntryEvent interface , a StorageInvocationEvent interface , and a StorageTransferEvent interface  for different types of storage events.","Attached is Appendix A that provides further information regarding the various aspects of the storage events throughout this disclosure. The information in Appendix A is provided for illustrational purposes and should not be construed to limit all of the embodiments of the invention.","In accordance with an embodiment, the internal architecture of a distributed data grid supports raising storage events directly. The Coherence includes several components for handling the storage events: a PartitionedService component, a PartitionedCache component, and a PartitionedCache$Storage data structure.","The PartitionedService component is the base for clustered service components, which is responsible for managing and handling partition events including partition transfer events. The PartitionedCache component extends PartitionedService and is responsible for handling all distributed caching requests within a storage enabled member. The PartitionedCache component is also responsible for handling requests relating to partitioned cache operations (often referred to as distributed caches) and ultimately asking the underlying storage to perform the requested operation. The PartitionedCache$Storage component is the underlying data structure responsible for storing and managing entries on behalf of Coherence. Coherence can support various storage implementations and the $Storage component facilitates this functionality by providing an abstraction layer between the underlying storage implementations and the PartitionedCache service.","The Coherence includes various methods for handling storage events and supporting the data partition transfer. These methods include:\n\n","Additionally, the Coherence can include different methods and components for supporting continuation. These methods and components include: DispatchUEMevent (in which a message component can be posted back on to the service so that a worker thread can pick up the request to offload it from the service thread), DispatchTransferDeparting, DispatchTransferArrived, PostDeparted, and PostArrived.","Data Partition Transfer","Data partitions can be transferred between the data storage nodes of the distributed data grid. During a partition transfer, an internal transfer request can be sent from one server node to another along with the data that is to be transferred. Upon receiving the request, the recipient can store the data and inform the other cluster nodes that it is now responsible for storing that particular data partition.","Event interceptors can be injected in this critical path of the partition transfer so that events can be fired and actions can be inserted during the partition transfers. Additionally, the event interceptors can follow a synchronous model, which delays the partition transfer until the event interceptors have completed processing, allowing the event interceptors to complete their functionality before the partition transfer is completed.","In one example, the transferred data partition may contain information that relates to a trading account pending several trades, each of which changes the total amount of the trading account. The system can ensure that all trades are fully processed before the data partition transfer is committed, in order to avoid data corruptions of the total amount in the trading account.","In another example, a query can be performed over all the data in the data grid for the purpose of continuous aggregation. The system can ensure that every time after a data partition is transferred, the information on the related cluster node is updated, so that a query result can be quickly returned to the user.","In accordance with an embodiment, all these functionalities can occur on a single thread (e.g. service thread). Partition transfers can be performed on the service thread in order to ensure that the user can lock and unlock a set of partitions from the same thread (the service thread) when dealing with continuations.","In accordance with an embodiment, the synchronous event interceptor completion can be performed without blocking the service thread by supporting continuation. Partition transfer events can lead an event interceptor to iterate over an entire partition. If the main service thread is blocked for a significant period of time, latency can be introduced to the system, or a crash can occur.","The continuation support for the partition transfer events in a distributed data grid can be achieved by posting the storage events to the worker thread. In this manner, the event interceptors can be executed synchronously (complete before the transfer partition is completed) while at the same time without blocking the service thread. As a result, the service thread do not need to wait for the completion of the transfer partition and can continue executing requests while the second thread executes the continuation event dispatch.",{"@attributes":{"id":"p-0032","num":"0038"},"figref":["FIG. 2","FIG. 2"],"b":["201","202"]},"The service thread  on the cluster node A can use a worker thread  to accomplish synchronous event intercepting without blocking the service thread. When the service thread receives an event or a request for handling an event, it can package the event up as a continuation (e.g. a data structure), which includes a task  to be executed by the worker thread. When the worker thread picks up the task, it can execute the task and post a response message  back to the service thread, which allows the handling of the event to switch back to the service thread, which can send a data partition transfer request to a service thread  on the cluster node B. In a similar fashion, the service thread on the cluster node B can dispatch a receiving task  to a worker thread  and receives a response when the data partition transfer operation is done. Finally, the receiving node, cluster node B, can send a message back to the sending node, cluster node A, as well as the rest of the cluster that it is responsible for the transferred data partition.","The following Listing 1 outlines a primary partition transfer workflow. In Coherence, a $PartitiondService.transferPrimary( ) method can be responsible for the flow of control with respect to transferring partitions. It is responsible for transferring a set of partitions at a time while keeping the partition transfers to a reasonable size on the wire. The following workflow can ensure that the system only switch the context once to raise the partition departing events.",{"@attributes":{"id":"p-0035","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"If (pre-commit phase)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003a.","Loop over the available partitions locking the set that we want"]},{"entry":[{},"to transfer"]},{"entry":["\u2003b.","If StorageTransferEvent.DEPARTING is enabled"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003i.","Create a list of DispatchTransferDeparting events"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003c.","Clear the partition set passed in"]},{"entry":["\u2003d.","Loop over the set of locked partitions"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003i.","If the transferControl is full"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u20031.","unlock the partition"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003ii.","else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20031.","Raise the TRANSMIT_BEGIN partition event"]},{"entry":[{},"\u20032.","if (listUEMDispatchers)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003a.","Create a DispatchTransferDeparting and add"]},{"entry":[{},{},"the reference to the set of partitions that exist"]},{"entry":[{},{},"in the method to it"]},{"entry":[{},"\u2003b.","Add the event from a to the"]},{"entry":[{},{},"listUEMDispatchers"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u20033.","Call transferPartition pre-commit phase - passing in"]},{"entry":[{},{},"the DispatchUEMEvent"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003e.","If (DispatchUEMEvent)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003i.","Loop over listUEMDispatchers adding each one"]},{"entry":[{},{},"to the EventDispatcher"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003f.","else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003i.","Call the post-commit phase"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"else (post-commit phase)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003a.","Call transferPartition post-commit phase passing the"]},{"entry":[{},"DispatchTransferDeparting passed in from the response"]},{"entry":["\u2003b.","Pull the set of partitions saved in the event as part of"]},{"entry":[{},"transferPartition in the flow (see below)"]},{"entry":["\u2003c.","Increment the number of sent partitions (we'll need to save"]},{"entry":[{},"this as a shared reference in the DispatchUEMEvent as well)"]},{"entry":["\u2003d.","If the size of the set of partitions from b == the count"]},{"entry":[{},"from c return the count from c"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following Listing 2 outlines a partition transfer workflow. In the example of Coherence, the partition transfer workflow can raise StorageTransferEvents at proper points and support passing an Iterator<BinaryEntries> to the data partition transfer events. A $PartitionedCache.transferPartition( ) method can gather all entries from a partition into a list to be transferred to another member, and raise the StorageTransferEvent.DEPARTING event for a particular partition. The partition transfer workflow can be embedded in the workflow for $PartitionedService.transferPrimary.",{"@attributes":{"id":"p-0037","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"If (pre-commit phase)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003a.","Ensure that storage is valid"]},{"entry":["\u2003b.","Create a list of resources to transfer"]},{"entry":["\u2003c.","If (DispatchTransferDeparting)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003i.","Add the list of resources (entries) to the"]},{"entry":[{},{},"DispatchUEMEvent. This will need to placed into a"]},{"entry":[{},{},"WrapperSet that can translate the"]},{"entry":[{},{},"SimpleMapEntries into BinaryEntries."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Else (post-commit phase)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003a.","Create a list of map leases to transfer"]},{"entry":["\u2003b.","Create a list of map listeners to transfer"]},{"entry":["\u2003c.","Pull the list of resources off of the StorageTransferEvent stored"]},{"entry":[{},"by the DispatchUEMEvent"]},{"entry":["\u2003d.","Send the TransferMessageRequest to the remote member with"]},{"entry":[{},"the above lists"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Additionally, similar continuation flows can be implemented in $PartitionedService.onTransferRequest( ) and $PartitionedCache.receivePartition( ) methods for handling the StorageTransferEvent.DEPARTING event and the StorageTransferEvent.ARRIVED event. A DispatchTransferDeparting component can extend DispatchUEMEvent and be responsible for raising the StorageTransferEvent.DEPARTING event to the event dispatcher on the Coherence EventDispatcher thread. The runAfter method is responsible for posting the PostDeparted message back on the service thread. The PostDeparted message can extend the basic PartitionedCache$Acknowledgement component. A DispatchTransferArrived component can extend the DispatchUEMEvent and be responsible for raising the StorageTransferEvent.ARRIVED event to the event dispatcher on the Coherence EventDispatcher thread. The runAfter method is responsible for posting the PostArrived message back on the service thread. The PostArrived message can also extend the basic PartitionedCache$Acknowledgement component.",{"@attributes":{"id":"p-0039","num":"0045"},"figref":["FIG. 3","FIG. 3"],"b":["301","302","303"]},"Handling Storage Entry Events","In accordance with an embodiment, a set of event interceptors can be utilized in the distributed data grid for handling different storage events. An event interceptor can handle a pre-insert event, e.g. a storage entry event, and defer the completion of the data change pending the completion of the pre-insert event. This allows a server-side client to veto the event, or modify the event, before the handling of the event is completed. Additionally, the event interceptors allow raising post-events which are not mutable and cannot be used to veto the event for example, because they have already completed.",{"@attributes":{"id":"p-0041","num":"0047"},"figref":["FIG. 4","FIG. 4"],"b":["411","414","401","403","405","409","421","415","417","423"]},"It may not be feasible for an entry locking mechanism to lock a key on one thread, and unlock it from another. When multiple worker threads are in use, the system may not be able to control which worker thread will pick up the continuation. If a continuation model can not offload the requests, the INSERTING, UPDATING, and REMOVING storage entry events types need to be executed in the context of the thread processing the operation that triggers these events. In order to keep the service thread safe from user code, a server-side event model can allow that a service configured with event interceptors for these event types is also configured with worker threads.","For a pre-commit storage entry event, the execution of the event interceptors may not be completely isolated, because the pre-commit storage entry event can have the ability to stop\/roll back a request by throwing an exception. In accordance with an embodiment, the pre-commit workflow knows whether the event interceptors finish processing an exception before moving forward to the commit phase of request processing. In order to isolate the execution of the event interceptors, continuation functionality can be added to each of the mutating operations on an data entry (e.g. INSERT, UPDATE, DELETE), such that the request handling can be set aside while the interceptor chains are executed on another thread (and picked up again once the interceptors finish handling the request).","In accordance with an embodiment, by executing the event interceptors on a worker thread instead of a service thread, the system allows the event interceptors to operate in a similar fashion as an entry processor. In Coherence, the following events can be run on a worker thread: StorageEntryEvent.INSERTING, StorageEntryEvent.UPDATING, and StorageEntryEvent.REMOVING","The invocation workflow in Coherence can take into account not only the mutations made to storage, but also the execution of EntryProcessors on entries within storage. As such, handling of invocation requests requires the code to raise not only StorageInvocationEvents but also StorageEntryEvents. The onInvokeRequest( ) and onInvokeAllRequest( ) can be the entry points for raising events caused by invocations.","The following Listing 3 outlines an exemplary storage invocation workflow.",{"@attributes":{"id":"p-0047","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Lock the entry or set of entries."]},{"entry":[{},"Raise the StorageInvocation.EXECUTING event (in line)"]},{"entry":[{},"Call Storage.invoke( ) on the entry or set of entries."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003a.","Storage will invoke the EntryProcessor.process( ) or EntryProcessor.processAll methods."]},{"entry":[{},"\u2003b.","Storage.postInvoke( ) will be called signifying that invocation has completed (note that"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"postInvoke will be called for every entry that was updated during the processing of the"]},{"entry":[{},"EntryProcessor)."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003i.","Triggers are fired"]},{"entry":[{},"\u2003ii.","Raise the StorageEntryEvent.UPDATING|INSERTING|REMOVING event (in-line)"]},{"entry":[{},"\u2003iii.","The updated Binary is committed to storage by calling putPrimaryResource( )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"processChanges and other internal processing to support things like backups (note backups are"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"done asynchronously) are handled"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Raise the StorageInvocation.EXECUTED event (on the EventDispatcher)"]},{"entry":[{},"Unlock the entry or set of entries"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Interceptors can be triggered during this workflow on a worker thread while the entry or set of entries is locked for the before events and after the entry is unlocked for the after events.","Additionally, the workflows for onPutRequest, onPutAllRequest, onRemoveRequest, and onRemoveAll request can be similar. There can be corresponding methods for each of these operations (onPutRequest->Storage.put->storage.postPut etc.).","The following Listing 4 outlines the workflow for a put request, which can be replicated for operations such as putAll, remove and removeAll requests.",{"@attributes":{"id":"p-0051","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"For an(each) entry"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Lock the entry."]},{"entry":[{},"Call Storage.put"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Storage will update the entry in storage"]},{"entry":[{},"Call postPut( )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"processTriggers( )"]},{"entry":[{},"Raise the"]},{"entry":[{},"StorageEntryEvent.INSERTING|UPDATING|REMOVING"]},{"entry":[{},"event. (in-line). This code should"]},{"entry":[{},"the updated Binary is committed to storage by calling"]},{"entry":[{},"mapResource.put( ) or mapResource.putAll( )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"processChanges and other internal processing to support things like"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"backups (note backups are done asynchronously)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"unlock the entry or set of entries."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Again, interceptors can be triggered during this workflow on a worker thread while the entry or set of entries is locked for the before events and after the entry is unlocked for the after events. The above workflow for put\/putall can be implemented for remove\/removeAll as well.","Furthermore, in order to make sure that the system raises events for both standard modifications as well as out of band modifications, all the post modification events can be raised in the publishChanges( ) method.","The following Listing 5 outlines the workflow for publishChanges( ) which is a function called by processChanges( ) and is responsible for collecting all modifications in the current sandbox along with any eviction type changes and publishing them to storage.",{"@attributes":{"id":"p-0055","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Gather all the EntryStatus objects into a statusAll collection."},{"entry":"Iterate over each status object and"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003a.","If no action was performed on the entry remove it from the list"]},{"entry":["\u2003b.","If backups are needed and the result is not null add the key to the"]},{"entry":[{},"partition set for backup"]},{"entry":["\u2003c.","Accumulate the map events that need to be posted"]},{"entry":["\u2003d.","Prepare the backup messages"]},{"entry":["\u2003e.","Raise the StorageEntryEvents to the EventDispatcher. Note that in"]},{"entry":[{},"this method, publish changes will raise updates across instances"]},{"entry":[{},"of storage. At a minimum we should group together all the updates"]},{"entry":[{},"for each \u201ccache\u201d to potentially batch the updates together in"]},{"entry":[{},"this method."]},{"entry":["\u2003f.","Unlock the locked keys"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0056","num":"0062"},"figref":["FIG. 5","FIG. 5"],"b":["501","502","503"]},"Throughout the various contexts described in this disclosure, the embodiments of the invention further encompass computer apparatus, computing systems and machine-readable media configured to carry out the foregoing systems and methods. In addition to an embodiment consisting of specifically designed integrated circuits or other electronics, the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art.","Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.","The various embodiments include a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a general purpose or specialized computing processor(s)\/device(s) to perform any of the features presented herein. The storage medium can include, but is not limited to, one or more of the following: any type of physical media including floppy disks, optical discs, DVDs, CD-ROMs, microdrives, magneto-optical disks, holographic storage, ROMs, RAMs, PRAMS, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs); paper or paper-based media; and any type of media or device suitable for storing instructions and\/or information. The computer program product can be transmitted in whole or in parts and over one or more public and\/or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. The transmission may include a plurality of separate transmissions. In accordance with certain embodiments, however, the computer storage medium containing the instructions is non-transitory (i.e. not in the process of being transmitted) but rather is persisted on a physical device.","The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents.","Appendix A","The following Listing 6 shows an exemplary Event interface. The Event interface is the base of all Events in the system. All Events in the system can have one or more event type associated with it. Consumers of an Event can decide what action to perform based on the event type.",{"@attributes":{"id":"p-0063","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"\u2009* An {@link Event} object captures the necessary information required to"},{"entry":"\u2009* adequately describe"},{"entry":"\u2009* the activity that has occurred."},{"entry":"\u2009*"},{"entry":"\u2009* Note that an {@link Event} object itself is immutable and its state is"},{"entry":"\u2009* only valid in the context"},{"entry":"\u2009* of a single chain of {@link"},{"entry":"\u2009* EventInterceptor#onEvent(EventContext, Event)} calls. Holding a"},{"entry":"\u2009* reference to the Event outside this scope or across calls is not safe."},{"entry":"\u2009*"},{"entry":"\u2009*\/"},{"entry":"public interface Event"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Return the {@link Event}'s type"]},{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the {@link Event}'s type"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public int getType( );"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Call the next {@link EventInterceptor} in the chain if one exists."]},{"entry":[{},"\u2009* After each subsequent"]},{"entry":[{},"\u2009* intercepter has run this method will return giving the caller the"]},{"entry":[{},"\u2009* opportunity to observe any"]},{"entry":[{},"\u2009* side effects caused by down stream {@link EventInterceptor}s."]},{"entry":[{},"\u2009* {@link EventInterceptor}s"]},{"entry":[{},"\u2009* that don't call this method will not prevent the chain from being"]},{"entry":[{},"\u2009* executed, they just won't"]},{"entry":[{},"\u2009* have the opportunity to see any side effects."]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public void nextInterceptor( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following Listing 7 shows an exemplary StorageEvents interface. StorageEvents are Events that occurs for a specific named cache instance.",{"@attributes":{"id":"p-0065","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"\u2009* A {@link StorageEvent} represents a storage side {@link Event} that"},{"entry":"\u2009* occurs for a specific"},{"entry":"\u2009* named cache instance."},{"entry":"\u2009*"},{"entry":"\u2009*\/"},{"entry":"public interface StorageEvent extends Event"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* The {@link Member} on which this event has been raised."]},{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the {@link Member} on which this event has been raised"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"Member getMember( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following Listing 8 shows an exemplary StorageCacheEvents interface. StorageCacheEvents are StorageEvents that can be raised on all storage members supporting a specific named cache. These represent global operations related to the named cache.",{"@attributes":{"id":"p-0067","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"\u2009* A {@link} StorageCacheEvent captures information concerning actions"},{"entry":"\u2009* performed across all"},{"entry":"\u2009* storage members supporting a named cache."},{"entry":"\u2009*"},{"entry":"*\/"},{"entry":"public interface StorageCacheEvent"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"extends StorageEvent"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Return the cache name associated with this event."]},{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the cache name associated with this event"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public String getCacheName( );"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageCacheEvent} is dispatched afterall entries for"]},{"entry":[{},"\u2009* a cache have been"]},{"entry":[{},"\u2009* removed from this particular member."]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int CACHE_CLEARED = 10;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following Listing 9 shows an exemplary StorageEntryEvents interface. StorageEntryEvents are StorageEvents that occurs on a specific Entry in a specific named cache instance. Some instances of this event will be raised before an operation on an Entry has been committed to storage. These before events allow the associated event interceptor to mutate the underlying Entry having these mutations committed to storage (similar to Triggers). Exceptions thrown from the before events prevent the operation from completing successfully and keep it from being committed to storage. Other instances of this event can be raised after an operation on an Entry has been committed to storage. In all of these after events, the contents of the underlying Entry are immutable.",{"@attributes":{"id":"p-0069","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"\u2009* A {@link StorageEntryEvent} captures information concerning actions performed on or with"},{"entry":"\u2009* {@link BinaryEntry}s. Note that the semantics for interceptors handling these events is the"},{"entry":"\u2009* same as the semantics for {@link EntryProcessor}s."},{"entry":"\u2009* From a concurrency model, interceptors will be dispatched on a worker thread while a lock is"},{"entry":"\u2009* held for the entry provided."},{"entry":"\u2009*"},{"entry":"\u2009*\/"},{"entry":"public interface StorageEntryEvent extends StorageCacheEvent"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Returns the {@link BinaryEntry} on which the {@link StorageEntryEvent} occurred."]},{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the {@link BinaryEntry} on which the {@link StorageEntryEvent} occurred"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"Set<BinaryEntry> getEntrySet( );"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageEntryEvent} is dispatched before a {@link BinaryEntry} is inserted into"]},{"entry":[{},"\u2009* storage."]},{"entry":[{},"\u2009* This event is raised before the insert has been committed to storage. The following holds:"]},{"entry":[{},"\u2009* <ul>"]},{"entry":[{},"\u2009* \u2003<li> The BinaryEntry provided for this event type is mutable.<\/li>"]},{"entry":[{},"\u2009* \u2003<li> Throwing an exception from this event will prevent the operation from being"]},{"entry":[{},"\u2009* \u2003committed to memory.<\/li>"]},{"entry":[{},"\u2009* <\/ul>"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int INSERTING = 1;"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageEntryEvent} is dispatched after a {@link BinaryEntry} has been inserted"]},{"entry":[{},"\u2009* into storage."]},{"entry":[{},"\u2009* This event is raised after the insert has been committed to storage but before the operation"]},{"entry":[{},"\u2009* has been backed up."]},{"entry":[{},"\u2009* The BinaryEntry provided for this event type is immutable."]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int INSERTED = 2;"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageEntryEvent} is dispatched before a {@link BinaryEntry} is updated in"]},{"entry":[{},"\u2009* storage."]},{"entry":[{},"\u2009* This event is raised before the update has been committed to storage. The following holds:"]},{"entry":[{},"\u2009* <ul>"]},{"entry":[{},"\u2009*\u2003<li> The BinaryEntry provided for this event type is mutable.<\/li>"]},{"entry":[{},"\u2009*\u2003<li> Throwing an exception from this type of event will prevent the operation from being"]},{"entry":[{},"\u2009*\u2003committed to memory.<\/li>"]},{"entry":[{},"\u2009* <\/ul>"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int UPDATING = 3;"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageEntryEvent} is dispatched after a {@link BinaryEntry} has been updated"]},{"entry":[{},"\u2009* in storage on a"]},{"entry":[{},"\u2009* specific partition. The BinaryEntry provided for this event type is immutable."]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int UPDATED = 4;"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageEntryEvent} is dispatched before an {@link BinaryEntry} has been"]},{"entry":[{},"\u2009* removed from storage."]},{"entry":[{},"\u2009* This event is raised before the remove has been committed to storage. The following holds:"]},{"entry":[{},"\u2009* <ul>"]},{"entry":[{},"\u2009*\u2003<li> The BinaryEntry provided for this event type is mutable.<\/li>"]},{"entry":[{},"\u2009*\u2003<li> Throwing an exception from this type of event will prevent the operation from being"]},{"entry":[{},"\u2009*\u2003committed to partition.<\/li>"]},{"entry":[{},"\u2009* <\/ul>"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int REMOVING = 5;"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageEntryEvent} is dispatched after an {@link BinaryEntry} has been"]},{"entry":[{},"\u2009* removed from storage on a"]},{"entry":[{},"\u2009* specific partition. The BinaryEntry provided for this event type is immutable.<\/li>"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int REMOVED = 6;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The semantics for writing EventInterceptors for StorageEntryEvents can match that of writing EntryProcessors. Using a concurrency model, interceptors handling this type of event can be dispatched on a worker thread with the Entry provided being locked.","The following Listing 10 shows an exemplary StorageInvocationEvents interface. StorageInvocationEvents are StorageEntryEvents and correspond to EntryProcessors that are being executed on a given member. StorageInvocationEvents can be raised before executing an EntryProcessor and after the results of the EntryProcessor have been committed to storage.",{"@attributes":{"id":"p-0072","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"\u2009* The {@link StorageInvocationEvent} represents a storage"},{"entry":"\u2009* side event"},{"entry":"\u2009* corresponding to the invocation of an EntryProcessor."},{"entry":"\u2009*"},{"entry":"\u2002*\/"},{"entry":"public interface StorageInvocationEvent"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"extends StorageEntryEvent"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Return the {@link EntryProcessor} associated with"]},{"entry":[{},"\u2009* this event."]},{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the {@link EntryProcessor} associated"]},{"entry":[{},"\u2009* with this event"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"EntryProcessor getProcessor();"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageInvocationEvent} is raised prior"]},{"entry":[{},"\u2009* to executing an"]},{"entry":[{},"\u2009* EntryProcessor on an entry or set of entries. This event is"]},{"entry":[{},"\u2009* raised before"]},{"entry":[{},"\u2009* the insert has been committed to storage. The following holds:"]},{"entry":[{},"\u2009* <ul>"]},{"entry":[{},"\u2009*\u2003<li>The BinaryEntry provided for this event type is"]},{"entry":[{},"\u2009*\u2003mutable.<\/li>"]},{"entry":[{},"\u2009*\u2003<li>Throwing an exception from this event will prevent the"]},{"entry":[{},"\u2009*\u2003operation from being"]},{"entry":[{},"\u2009*\u2003committed to memory.<\/li>"]},{"entry":[{},"\u2009* <\/ul>"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int EXECUTING = 11;"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageInvocationEvent} is dispatched after"]},{"entry":[{},"\u2009* an {@link EntryProcessor} has been"]},{"entry":[{},"\u2009* executed and its result has been committed to storage."]},{"entry":[{},"\u2009* The BinaryEntry provided in this event type is immutable."]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int EXECUTED = 12;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following Listing 11 shows an exemplary StorageTransferEvents interface StorageTransferEvents are StorageEvents that represent transfers of entries from one member to another. The semantics for writing EventInterceptors for StorageTransferEvents can be different from StorageEntryEvents. Event interceptors can be dispatched on a worker thread while a lock is held for the partition being transferred. This means that while handling a StorageTransferEvent the partition being transferred can be locked across the cluster.",{"@attributes":{"id":"p-0074","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**"},{"entry":"\u2009* A {@link StorageTransferEvent} captures information concerning the transfer of partitions for"},{"entry":"* a specific storage enabled member."},{"entry":"* Transfer events are raised against the set of {@link BinaryEntry}s that are being transferred."},{"entry":"* Note that when {@link StorageTransferEvent}s are raised, {@link StorageEntryEvent}s will not"},{"entry":"* be raised. If there is interest in the movement of entries from one member to another, you"},{"entry":"* must intercept {@link StorageTransferEvents}. In addition, it's important to realize that when a"},{"entry":"* {@link StorageTransferEvent} is being handled, a lock is held on the set of partitions for the"},{"entry":"* data being transferred preventing write operations for that entire partition set."},{"entry":"\u2009*"},{"entry":"*\/"},{"entry":"public interface StorageTransferEvent extends StorageTransferEvent"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Returns the {@link PartitionSet} to which the {@link StorageTransferEvent} applies."]},{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the {@link PartitionSet} to which the {@link StorageTransferEvent} applies"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"int getPartitionId( );"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Returns the {@link PartitionedService} on which the {@link StorageTransferEvent}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"occurred."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the {@link PartitionedService} on which the {@link StorageTransferEvent}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"occurred"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009*\/"]},{"entry":[{},"PartitionedService getPartitionService( );"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* The remote {@link Member} associated with this transfer operation."]},{"entry":[{},"\u2009* For a {@link #DEPARTED} event, this would be"]},{"entry":[{},"\u2009* the member the entries are being transferred to. For a {@link #ARRIVED} event, this would"]},{"entry":[{},"\u2009* be the member the entries are being transferred from."]},{"entry":[{},"\u2009*"]},{"entry":[{},"\u2009* @return the remote {@link Member} associated with the instance of this storage transfer"]},{"entry":[{},"\u2009* event"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"Member getRemoteMember( );"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* Return the {@link BinaryEntry}s associated with this storage transfer event."]},{"entry":[{},"\u2009* @return"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"List<BinaryEntry> getEntries( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/**"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2009* This {@link StorageTransferEvent} is dispatched when a set of {@link BinaryEntry}s are"]},{"entry":[{},"\u2009* being transfered from the current member. When this event is raised the partition that is"]},{"entry":[{},"\u2009* departing is no longer owned by the current member, but the values will still be in the"]},{"entry":[{},"\u2009* backing map. Note that while this event is being executed a lock on the partition being"]},{"entry":[{},"\u2009* transferred is held preventing any write operations for the partition."]},{"entry":[{},"\u2009* The {@link BinaryEntry}s provided from {@link #getEntries( )} will be immutable."]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int DEPARTING = 7;"]},{"entry":[{},"\/**"]},{"entry":[{},"\u2009* This {@link StorageTransferEvent} is dispatched when a set of {@link BinaryEntry}s has"]},{"entry":[{},"\u2009* been transfered to the current member. When this event is raised, the partition is owned"]},{"entry":[{},"\u2009* by the current member and the entries will not yet be in the backing map. Note that while"]},{"entry":[{},"\u2009* this event is being executed a lock on the partition being transferred is held preventing"]},{"entry":[{},"\u2009* any write operations for the partition."]},{"entry":[{},"\u2009* The {@link BinaryEntry}s provided from {@link #getEntries( )} will be immutable."]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"public static final int ARRIVED = 8;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
