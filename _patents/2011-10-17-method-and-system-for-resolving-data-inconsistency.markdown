---
title: Method and system for resolving data inconsistency
abstract: Method, system, and programs for resolving data inconsistency in a distributed system having a plurality of replica instances. In response to a read request of at least one data element, a key-specific probability value for the at least one data element of the read request is retrieved. Based on the retrieved key-specific probability value and a system load of the distributed system, a self-healing probability of the at least one data element of the read request is computed. A self-healing transaction that includes the at least one data element of the read request is then generated based on the self-healing probability of the at least one data element. The generated self-healing transaction is further applied to at least some of the plurality of replica instances in the distributed system to resolve data inconsistency.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08849776&OS=08849776&RS=08849776
owner: Yahoo! Inc.
number: 08849776
owner_city: Sunnyvale
owner_country: US
publication_date: 20111017
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Technical Field","The present teaching relates to methods, systems, and programming for resolving data inconsistency. Particularly, the present teaching is directed to methods, systems, and programming for resolving data inconsistency in a distributed system having a plurality of replica instances.","2. Discussion of Technical Background","Distributed computing\/storage is a field of computer science that studies distributed systems, which include multiple autonomous computers or parallel virtual machines that communicate through a computer network, such as one or more computer clusters each having multiple nodes. Distributed systems and applications may be applied as various paradigms, including grid computing, utility computing, edge computing, and cloud computing by which users may access the server resources using a computer, netbook, tablet, smart phone, or other device through the Internet.","Replication is one of the oldest and most important topics in the overall area of distributed systems. Replication is the process of sharing information so as to ensure consistency between redundant resources, such as software or hardware components, to improve reliability, fault-tolerance, or accessibility. A distributed system where data is replicated can provide better fault tolerance capabilities as well as improved response time. One of the major concerns of replication in distributed systems is data inconsistency. For example, in massively replicated distributed systems with billions of records, each with many entries, and hundreds of geographically dispersed replica instances (each within its own administrative zone), various systemic causes can lead to data divergence, where replicas of some of the records contain entries that have divergent values. Processes that lead to divergence may not always be avoidable or predictable. The inconsistency issues include, for example, missing records in some replicas where they should be represented, missing keys in some records that some of their replicas have, and keys with different values in some records when compared to some of their replicas.","Some known solutions of resolving data inconsistency are based on an anti-entropy model that delivers inconsistencies to users to resolve conflicts. The anti-entropy model, however, is not suitable for massively replicated distributed systems because of its inefficiency. Therefore, there is a need to provide a solution for ensuring that the distributed data replication system can heal the data inconsistency itself and can decrease the occurrence of divergent values within an acceptable half-life.","The present teaching relates to methods, systems, and programming for resolving data inconsistency. Particularly, the present teaching is directed to methods, systems, and programming for resolving data inconsistency in a distributed system having a plurality of replica instances.","In one example, a method, implemented on at least one machine each having at least one processor, storage, and a communication platform connected to a network for resolving data inconsistency in a distributed system having a plurality of replica instances is presented. In response to a read request of at least one data element, a key-specific probability value for the at least one data element of the read request is retrieved. Based on the retrieved key-specific probability value and a system load of the distributed system, a self-healing probability of the at least one data element of the read request is computed. A self-healing transaction that includes the at least one data element of the read request is then generated based on the self-healing probability of the at least one data element. The generated self-healing transaction is further applied to at least some of the plurality of replica instances in the distributed system to resolve data inconsistency.","In a different example, a system for resolving data inconsistency in a distributed system having a plurality of replica instances is presented, which includes a probability assigning module, a transaction generating module, and a transaction dispatcher. The probability assigning module is configured to, in response to a read request of at least one data element, retrieve a key-specific probability value for the at least one data element of the read request. The probability assigning module is also configured to compute a self-healing probability of the at least one data element of the read request based on a system load of the distributed system and the retrieved key-specific probability value. The transaction generating module is operatively coupled to the probability assigning module and is configured to generate a self-healing transaction that includes the at least one data element of the read request based on the self-healing probability of the at least one data element. The transaction dispatcher is operatively coupled to the transaction generating module and is configured to apply, via a data replication bus, the generated self-healing transaction to at least some of the plurality of replica instances in the distributed system to resolve data inconsistency.","Other concepts relate to software for resolving data inconsistency in a distributed system having a plurality of replica instances. A software product, in accord with this concept, includes at least one machine-readable non-transitory medium and information carried by the medium. The information carried by the medium may be executable program code data regarding parameters in association with a request or operational parameters, such as information related to a user, a request, or a social group, etc.","In one example, a machine readable and non-transitory medium having information recorded thereon for resolving data inconsistency in a distributed system having a plurality of replica instances recorded thereon, wherein the information, when read by the machine, causes the machine to perform a series of steps. In response to a read request of at least one data element, a key-specific probability value for the at least one data element of the read request is retrieved. Based on the retrieved key-specific probability value and a system load of the distributed system, a self-healing probability of the at least one data element of the read request is computed. A self-healing transaction that includes the at least one data element of the read request is then generated based on the self-healing probability of the at least one data element. The generated self-healing transaction is further applied to at least some of the plurality of replica instances in the distributed system to resolve data inconsistency.","Additional advantages and novel features will be set forth in part in the description which follows, and in part will become apparent to those skilled in the art upon examination of the following and the accompanying drawings or may be learned by production or operation of the examples. The advantages of the present teachings may be realized and attained by practice or use of various aspects of the methodologies, instrumentalities and combinations set forth in the detailed examples discussed below.","In the following detailed description, numerous specific details are set forth by way of examples in order to provide a thorough understanding of the relevant teachings. However, it should be apparent to those skilled in the art that the present teachings may be practiced without such details. In other instances, well known methods, procedures, systems, components, and\/or circuitry have been described at a relatively high-level, without detail, in order to avoid unnecessarily obscuring aspects of the present teachings.","The present disclosure describes method, system, and programming aspects of resolving data inconsistency in a distributed system having a plurality of replica instances. The present disclosure provides a novel data affinity based approach to create additional transactions to speed-up eventual consistency and recover from lost messages. Often data that has been read and has not been corrected can be presumed to be correct after some time. Based on this correctness, the present disclosure propagates system generated transactions to speed-up eventual consistency and recover from lost messages in a massively replicated data system to achieve \u201cself-healing\u201d of the data inconsistency. This solution may be used in various distributed data replication systems, in particular, those where write\/read ratio is very low, for example, lower than 20\/80. The lower the write\/read ratio is, the more effective the solution may be.","Such method, system, and programming of the present disclosure benefit users in several ways: it provides an advantage in conflict resolution acceleration and inconsistency self-healing in massively replicated data stores with billions of records and hundreds of replicas, with a much larger number of reads than writes; the system will eventually fix itself even if new inconsistencies arise; only active keys will be fixed, so no effort is wasted to fix obsolete data; the system can also be used to adjust probabilities (for read candidate selection based on throttling and key-based probabilities), all to ensure that system write capacity (availability) is not overwhelmed while maintaining a desired data consistency of the distributed data replication system.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","104","106","108","110","108","108","108","108","108"],"i":["a","b"]},"Each cluster -, -, . . . -may be a geographically dispersed replica instance of a massively replicated and globally distributed data system . Each cluster\/replica instance -, -, . . . -may be within its own administrative zone, for example, U.S. West, U.S. Central, or U.S. East. Each cluster -, -, . . . -may include a plurality of nodes, which communicate through the network  or through an internal network (not shown). The distributed system  replicates massively scaled databases which are hosted on multiple nodes in a replica instance -, -, . . . -. In this example, each node of a cluster  may be an autonomous physical machine, such as a server, a workstation, a desktop or laptop computer, a tablet, a smart phone, a television, a game console, or any other suitable machine. In another example, some or all of the nodes may be parallel virtual machines implemented by either software emulation or hardware virtualization. A cluster  may be a set of machines owned by one entity, e.g., an enterprise, and maintained as a server farm or server cluster where the servers are mounted on racks in a server room or data center. A cluster  may also be a collection of machines owned by different entities and that are physically separate from each other at a distance. Each node of each cluster  includes mechanism and instrumentation to ensure that the distributed system  can heal itself and can decrease the occurrence of divergent values within an acceptable half-life. The mechanism depends on system generated transactions based on user interaction patterns and the balancing of writes and reads to regenerate the pool of available records and record entries for self-healing acceleration. Often data that has been read and has not been corrected can be presumed to be correct after some time. Based on this correctness, the mechanism propagates system generated transactions to speed-up eventual consistency and recover from lost messages in the massively replicated data system  to achieve \u201cself-healing\u201d of the data inconsistency.","Users  may be of different types such as users connected to the network via desktop connections -, users connecting to the network via wireless connections such as through a laptop -, a handheld device -, or a built-in device in a motor vehicle -. A user and\/or an application  may access to the user database (UDB) in the distributed system  by sending a request to a cluster  within the same administrative zone via the network  and\/or receiving a response from the cluster  through the network . In this massively replicated distributed system , an operator , who may be a network administrator, operator, developer, or customer of the distributed system , may configure the distributed system  via the host  if needed.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["100","104","110","100","100","100","100","110","104","110","104","202","202"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["300","302","300","100","300","304","306","308","304","304","306","300"]},"The record store  may be a user database where a large number of user data is stored in the form of records. Referring now to  where an exemplary record store  is illustrated, in this example, the record store  contains a number of records , each including a plurality of data elements (data entries) . In this example, the size of each record  (i.e., the number of data elements) in the record store  may vary. Each data element  may include a key K, a value V, and a time stamp is indicating when the value of the key was most recently updated. For example, a write transaction (operation) may include one or more data element updates for a particular record but carry only a single time stamp for all the updated data elements. A response to user read requests may only carry individual elements with no time stamps included. All data elements of a record may eventually have their own time stamps. In other examples, the time stamps may be replaced by sequence numbers or vector clocks to order updates. In addition to the data elements  used for storing, for example, user data, each record  may further include a key-specific probability element , which may be provided based on the transaction history for each data element  in the record . A key-specific probability element  does not replicate itself when the data elements  in the same record  are replicated. The key-specific probability element  will be described later in detail.","Referring back to , the transaction dispatcher , in this example, is operatively coupled to the data replication bus , the request handler , and the record store  The transaction dispatcher  may serve as an interface with other cluster nodes in the same or different replica instances (clusters) of the distributed system . The transaction dispatcher  may receive incoming transactions of replication and apply them to the record store . The transaction dispatcher  may also apply outgoing transactions, such as self-healing transactions, to other replica instances via the data replication bus .","The data inconsistency self-healing controller , in this example, is operatively coupled to the request handler , the record store , and the transaction dispatcher . The self-healing controller  may be configured to generate a self-healing transaction based on user\/application interaction patterns and the load of the distributed system . The generated self-healing transaction may be applied by the transaction dispatcher  to other replica instances via the data replication bus  to resolve data inconsistency. In this example, the self-healing controller  includes a probability assigning module , a transaction generating module , and optionally, a policy checking module . The probability assigning module  may be configured to, in response a read request of at least one data element, retrieve a key-specific probability value for the corresponding data element of the read request. For example, a read request of one or more data elements is initiated by a user\/application and received by the request handler . The request handler  transfers the request as a \u201ctrigger\u201d to the probability assigning module . In response to the trigger, the probability assigning module  identifies the corresponding record and data elements of the read request and retrieves the corresponding key-specific probability value from the record store .","Referring now to  where an exemplary key-specific probability element  is illustrated. The key-specific probability element  is included in each of the records  in the record store . The exemplary key-specific probability element  may include an array of bit sets . Each bit set  may represent a key-specific probability value that a self-healing transaction for that key may occur. For example, the larger the value of a bit set , the higher the probability that a self-healing transaction may be dispatched for the corresponding data element . In one example, bit sets  for each key are of equal size, for example, 1, 2, 3, or 4. Initially, all bit sets  may be set to their maximum values. The value of each bit set  may be provided based on the transaction history of the corresponding data element . For example, the value of a bit set  may decrease when a self-healing transaction that includes the corresponding data element  has been applied; the value of a bit set  may increase when the corresponding data element  has been updated. It is understood that, in addition to transaction history, any other suitable policies may be applied to determine the value of a bit set . It is also understood that, in other examples, a key-specific probability element may include a probability vector to indicate the key-specific probability value for each data element instead of bit sets .","Referring back to , the probability assigning module  may be further configured to determine a self-healing probability P(x) for the corresponding data element of the read request based on a system load of the distributed system  and the retrieved key-specific probability value. The system load is applied to ensure that the system write capacity is not overwhelmed by the system generated self-healing transactions. The system load may serve as a probability scaling factor governed by the whole system throughput available for, the self-healing transactions. The probability of generating a self-healing transaction for a data element may change depending on the write throughput available in the distributed system . The write throughput may be represented by a read\/write transaction ratio of the distributed system . For example, the system load of the distributed system  includes a read\/write transaction ratio of the distributed system , and the self-healing probability of a data element increases as the read\/write transaction ratio of the distributed system  increases. In one example, the read\/write transaction ratio of the distributed system  is about 80\/20. The self-healing probability of a data element, in this example, may be calculated by multiplying the value of the corresponding the bit set  (retrieved key-specific probability value) and the system load in the form of a probability scaling factor.","In this example, the transaction generating module  of the self-healing controller  is operatively coupled to the probability assigning module . The transaction generating module  may be configured to determine whether a self-healing transaction candidate is to be initiated based on the self-healing probability P(x) of at least one data element in response to the read request of the at least one data element. The transaction initiating module  may be further configured to generate a self-healing transaction that includes the at least one data element of the read request based on the self-healing probability of the at least one data element. In other words, self-healing transactions may be generated in response to some read requests by choosing candidate reads at random, at a prescribed probability. In this example, each read request may trigger the transaction generating module  to determine whether a self-healing transaction should be generated. Referring now to , in this example, a user initiates a read request Get(K, K, K, . . . ) to get the values of a plurality of data elements. In response, a self-healing probability P(x) is determined in order to decide whether a self-healing transaction based on the requested data elements should be generated.","A self-healing transaction may be a writing operation on at least one data element of at least some of the plurality of replica instances in response to a read request by a user or an application. It may include directive information that controls an application thereof to each of the some replica instances in the distributed system. A self-healing transaction may carry individual data element along with each individual data element's specific time stamp, as they exist in the record prior to the read. On example of a self-healing transaction, as shown in , is <Directive\u2225K:v|ts, K:v|ts, K:v|ts, . . . >. The directive information may control the application of this self-healing transaction at the target replica instance and condition its execution there. The time stamps ts, ts, ts inherit the existing time stamps of the data elements in the record prior to the read request.","As noted above, the transaction dispatcher  may be configured to apply, via the data replication bus , the generated self-healing transaction to at least some of the plurality of replica instances in the distributed system  to resolve data inconsistency. In other words, the generated self-healing transactions are sent immediately to other replica instances. The application of the self-healing transaction at each target replica instance may be directed by the directive information as noted above. For example, at each target replica instance, the time stamp of the data element in the self-healing transaction is compared with a time stamp of a corresponding data element in the replica instance. If the time stamp of the data element in the self-healing transaction is more recent than a time stamp of a corresponding data element in a replica instance, a value of the corresponding data element in the replica instance is replaced by the value of the data element in the self-healing transaction. Otherwise, the self-healing transaction is discarded from the corresponding replica instance.","Referring back to , optionally, the self-healing controller  may include the policy checking module  operatively coupled to the transaction generating module  and the transaction dispatcher . The policy checking module  may be configured to determine whether the self-healing transaction is to be applied based on one or more self-healing policies. Various self-healing policies, such as invalidation by a more recent write, may be applied to invalid certain self-healing transaction candidates prior to dispatch. In one example, to apply the above-mentioned self-healing policy, the policy checking module  first determines whether a write transaction has been requested, wherein the write transaction applies to the same data element in a corresponding self-healing transaction candidate. If the write transaction has been requested, the transaction generating module  discards the corresponding self-healing transaction. Referring now to , optionally, the generated self-healing transactions may not be immediately applied but instead, are temporally stored in queue. A policy check is applied to any self-healing transaction in the queue or dequeued. In this example, a self-healing transaction may be applied only when it passes the policy check. In one example, a slower rate of queue processing may be applied so that proximal writes on the same data element can trump the queued self-healing transaction that includes any of the same recently written keys in the candidate queue.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 7","b":["110","104","302","104","104","104","104","104","104","104","104","104"],"i":["a","b ","c","b","b ","b","b ","b ","c","c"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 8","b":["802","804","802","804","310","302","806","312","302","808","308","202"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 9(","i":"a","b":["902","904","906"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 9(","i":"b","b":["802","804","802","804","310","302","806","312","302","908","908","314","302","910","912","914","910","912","914","308","202"]},"To implement the present teaching, computer hardware platforms may be used as the hardware platform(s) for one or more of the elements described herein. The hardware elements, operating systems, and programming languages of such computers are conventional in nature, and it is presumed that those skilled in the art are adequately familiar therewith to adapt those technologies to implement the processing essentially as described herein. A computer with user interface elements may be used to implement a personal computer (PC) or other type of work station or terminal device, although a computer may also act as a server if appropriately programmed. It is believed that those skilled in the art are familiar with the structure, programming, and general operation of such computer equipment and as a result the drawings should be self-explanatory.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 10","FIGS. 1-3"],"b":["1000","1000"]},"The computer , for example, includes COM ports  connected to and from a network connected thereto to facilitate data communications. The computer  also includes a central processing unit (CPU) , in the form of one or more processors, for executing program instructions. The exemplary computer platform includes an internal communication bus , program storage and data storage of different forms, e.g., disk , read only memory (ROM) , or random access memory (RAM) , for various data files to be processed and\/or communicated by the computer, as well as possibly program instructions to be executed by the CPU. The computer  also includes an I\/O component , supporting input\/output flows between the computer and other components therein such as user interface elements . The computer  may also receive programming and data via network communications.","Hence, aspects of the method of resolving data inconsistency in a distributed system having a plurality of replica instances, as outlined above, may be embodied in programming. Program aspects of the technology may be thought of as \u201cproducts\u201d or \u201carticles of manufacture\u201d typically in the form of executable code and\/or associated data that is carried on or embodied in a type of machine readable medium. Tangible non-transitory \u201cstorage\u201d type media include any or all of the memory or other storage for the computers, processors or the like, or associated modules thereof, such as various semiconductor memories, tape drives, disk drives and the like, which may provide storage at any time for the software programming.","All or portions of the software may at times be communicated through a network such as the Internet or various other telecommunication networks. Such communications, for example, may enable loading of the software from one computer or processor into another. Thus, another type of media that may bear the software elements includes optical, electrical, and electromagnetic waves, such as used across physical interfaces between local devices, through wired and optical landline networks and over various air-links. The physical elements that carry such waves, such as wired or wireless links, optical links or the like, also may be considered as media bearing the software. As used herein, unless restricted to tangible \u201cstorage\u201d media, terms such as computer or machine \u201creadable medium\u201d refer to any medium that participates in providing instructions to a processor for execution.","Hence, a machine readable medium may take many forms, including but not limited to, a tangible storage medium, a carrier wave medium or physical transmission medium. Non-volatile storage media include, for example, optical or magnetic disks, such as any of the storage devices in any computer(s) or the like, which may be used to implement the system or any of its components as shown in the drawings. Volatile storage media include dynamic memory, such as a main memory of such a computer platform. Tangible transmission media include coaxial cables; copper wire and fiber optics, including the wires that form a bus within a computer system. Carrier-wave transmission media can take the form of electric or electromagnetic signals, or acoustic or light waves such as those generated during radio frequency (RF) and infrared (IR) data communications. Common forms of computer-readable media therefore include for example: a floppy disk, a flexible disk, hard disk, magnetic tape, any other magnetic medium, a CD-ROM, DVD or DVD-ROM, any other optical medium, punch cards paper tape, any other physical storage medium with patterns of holes, a RAM, a PROM and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave transporting data or instructions, cables or links transporting such a carrier wave, or any other medium from which a computer can read programming code and\/or data. Many of these forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to a processor for execution.","Those skilled in the art will recognize that the present teachings are amenable to a variety of modifications and\/or enhancements. For example, although the implementation of various components described above may be embodied in a hardware device, it can also be implemented as a software only solution\u2014e.g., an installation on an existing server. In addition, the units of the host and the client nodes as disclosed herein can be implemented as a firmware, firmware\/software combination, firmware\/hardware combination, or a hardware\/firmware\/software combination.","While the foregoing has described what are considered to be the best mode and\/or other examples, it is understood that various modifications may be made therein and that the subject matter disclosed herein may be implemented in various forms and examples, and that the teachings may be applied in numerous applications, only some of which have been described herein. It is intended by the following claims to claim any and all applications, modifications and variations that fall within the true scope of the present teachings."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The methods, systems, and\/or programming described herein are further described in terms of exemplary embodiments. These exemplary embodiments are described in detail with reference to the drawings. These embodiments are non-limiting exemplary embodiments, in which like reference numerals represent similar structures throughout the several views of the drawings, and wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 9(","i":["a","b"],"b":"9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
