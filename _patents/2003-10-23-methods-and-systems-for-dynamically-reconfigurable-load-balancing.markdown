---
title: Methods and systems for dynamically reconfigurable load balancing
abstract: Techniques for serving data to a plurality of clients in a client-server environment are provided. In one aspect of the invention, the technique provides a plurality of versions of data in which different versions have different overheads associated therewith. Individual clients are assigned to one of a plurality of quality-of-service classes. Requests are satisfied so that a client belonging to a high quality-of-service class is given preferential access to data versions which require higher overheads to serve.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07987268&OS=07987268&RS=07987268
owner: International Business Machines Corporation
number: 07987268
owner_city: Armonk
owner_country: US
publication_date: 20031023
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates to techniques for managing content requests in accordance with an information system, and, more particularly, to techniques for dynamically reconfigurable load balancing.","It is known that the amount of dynamic content on information systems such as the Internet or World Wide Web (WWW or the \u201cweb\u201d) is increasing at a rapid pace. Web sites typically deploy databases for generating dynamic content. Requests come into a front end and are routed to one or more back-end databases. The overhead for satisfying requests from back-end databases can be high. High-performance web sites typically have multiple back-end databases. However, a problem exists regarding how to route requests (including balancing the request load) to multiple back-end databases, as well as other back end-systems such as messaging\/transaction systems, server programs for creating data on-the-fly, etc.","Existing web servers have limited support in performance improvement and Quality-of-Service (QoS) provisioning to access the back-end systems. For example, existing techniques include connection pooling and (possible) server pooling. Connection pooling maintains open connections to the back-end systems and schedules queries in the pooled connections. As a result, the connection overhead in the web applications is reduced. However, this technique has no mechanisms to support load balancing and QoS provisioning.","Moreover, it is difficult to make the web servers unaware of the back-end system configurations without changing the existing applications. Existing protocols, such as the Java Data Base Connectivity (JDBC) protocol, that enable web servers to communicate with the back-end systems typically accept only one system as a data source. Thus, the web server is statically configured to use one back-end system. When configurations such as the server capacity and QoS policy of the back-end systems change, appropriate changes must be made to the web applications to reflect such changes.","Thus, a need exists for techniques which overcome the above-mentioned and other limitations associated with existing load balancing and QoS routing approaches.","The present invention provides techniques for managing content requests in accordance with an information system.","In a first aspect of the invention, a technique for serving data to a plurality of clients in a client-server environment, comprises the following steps\/operations. A plurality (e.g., two or more) of versions of data are provided in which at least two versions have different overheads associated therewith. Individual clients are assigned to one of a plurality of quality-of-service classes. Requests are satisfied so that a client belonging to a high quality-of-service class is given preferential access to data versions which require higher overheads to serve.","Further, the overhead to serve a version may be correlated with a quality of the version. The multiple versions may comprise images of different resolutions and clients belonging to a high quality-of-service class are given preferential access to higher resolution images. The quality of a version may be correlated with a processing time required to create the version. The overhead to serve a version may be correlated with how current the version is. The technique may further comprise, in response to a system load exceeding a threshold, satisfying a higher percentage of requests from clients belonging to a lower quality-of-service class with a version requiring lower overhead to serve. The server may comprise multiple nodes and different nodes may provide data versions requiring different overheads to serve.","Still further, the technique may comprise implementing a quality-of-service policy that specifies at least one of content quality and latency. One or more clients belonging to a premium service class may be served with high content quality and low latency. One or more clients belonging to a medium service class may be served with one of high content quality and low latency. One or more clients belonging to a best-effort service class may be served with unspecified content quality and latency.","A client request may be routed using an identity of the client, a quality of content, a load on at least one server, a data distribution on at least one server, and\/or a capacity of at least one server.","In a second aspect of the invention, a system comprises a plurality of clients, each client belonging to a quality-of-service class; a load balancer for sending requests from clients to at least one back-end server; and at least one back-end server for providing a plurality of versions of different objects in which at least two versions of an object have different overheads associated therewith.","In a third aspect of the invention, a method of providing a data serving service, comprises a service provider: (i) providing a plurality of versions of data in which at least two versions have different overheads associated therewith; (ii) assigning individual clients to one of a plurality of quality-of-service classes; and (iii) satisfying requests so that a client belonging to a high quality-of-service class is given preferential access to data versions which require higher overheads to serve.","In a fourth aspect of the invention, a technique for serving data to a plurality of clients comprises the following steps\/operations. At least two quality-of-service classes are established. Requests are then satisfied so that a client belonging to one quality-of-service class is served with a data version having one overhead associated therewith, while a client belonging to another quality-of-service class is served with a data version having another overhead associated therewith.","Thus, the present invention may advantageously provide efficient load balancing to back-end servers, as well as quality-of-service routing to provide some clients with better quality-of-service than others. Load balancing may follow policies that can be dynamically modified (reconfigured) without having to recompile the application or the intermediary code.","These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.","The present invention will be explained below in the context of an illustrative Internet or web implementation. However, it is to be understood that the present invention is not limited to such an information network architecture. Rather, the invention is more generally applicable to any environment in which it would be desirable to perform efficient and effective load balancing and QoS routing.","For convenience of reference, the remainder of the detailed description will be divided into the following sections: (1) Illustrative Architecture Overview; and (2) Illustrative Methodologies\/Systems.","1. Illustrative Architecture Overview","Referring initially to , a block diagram illustrates an information system implementing techniques of the present invention. As shown, information system  comprises one or more clients -H belonging to a high quality of service class, one or more clients -L belonging to a low quality of service class, one or more web servers , and content sources - through -accessible via uniform resource locators (URLs) - through -. It is to be appreciated that the content sources may be but are not limited to back-end databases and\/or other back end-systems such as messaging\/transaction systems, server programs for creating data on-the-fly, etc. It is to be further appreciated that the components in system  may be part of a larger distributed information system such as the Internet or World Wide Web.","It is possible to have more quality of service classes (e.g., 3, 4, 5, 6, etc.) as well. Clients belonging to higher quality of service classes are given preferential access to higher quality content. In many cases, higher quality content requires more overhead to serve. Examples of higher quality content include but are not limited to more detailed content, more current content, higher resolution images, etc. The system depicts each content source as including content in a high overhead version (- through -) and a low overhead version (- through -). The high overhead version is typically of higher quality than the low overhead version. Note that there may be more than two content versions (e.g., 3, 4, 5, 6, etc.). Different versions may typically require different overheads to serve. The overhead to serve a version is typically correlated with the quality of the version.","The web clients may be satisfied either by high quality content or by lower quality content. The high quality content usually consumes more overhead to generate. In order to meet a wide range of requirements for service satisfaction, the web pages may, be differentiated into versions with different levels of overheads. Such a method can also be adapted to configure web servers with heterogeneous capacity to serve clients with differentiated services. As illustrated in , the web pages have multiple versions, which are usually generated with different overheads.","In data-driven web sites, the contents may be retrieved from back-end information systems such as database servers and mainframes. In such a context, content differentiation is realized through differentiated content replication and query routing.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["20","21","22","23","24","23","24"]},"The high-end server  stores the most updated information with the highest level of quality. The response time could be adversely affected if the high-end server is overwhelmed with too many client requests. Therefore, the high-end server  may only satisfy a fraction of the requests during periods of heavy loads.","The low-end server  periodically replicates content from the high-end server . Low-end server  contains less frequently updated or lower fidelity information. Low-end server  starts serving requests when the traffic is beyond the capacity of high-end server , requests are from less-favored clients, and\/or the contents in low-end server  are sufficient for satisfying the requirements (such as image resolution, document size, etc.) of the clients.","Low-end server  could be different from high-end server  to reduce the cost associated with different query types. For instance, the high-end server  could run DB2 (available from IBM Corporation of Armonk, N.Y.) and the low-end server  could run MySQL (available from MySQL Inc. of Seattle, Wash.). The low-end server may serve selected queries to exploit MySQL's limitations in this type of operation. DB2 DataPropogator\/DataJoiner could be used to propagate the data to MySQL. It is important to resolve the incompatibility that may arise between the two systems.","2. Illustrative Methodologies\/Systems","2.1 QoS Approaches","The overhead of serving a version of content is usually correlated with its quality. A high quality version usually consumes more resources. Based on data quality and system configuration, there are multiple ways to realize the QoS approach of the invention such as: quality differentiation, data partition, and query type differentiation.","In the quality differentiation approach, the back-end servers store contents with different overheads. The high-end server  stores the high quality contents, while the lower-end server  contains data with lower overheads. It is to be understood that there may be more than two servers storing more than two different levels of quality. The low-end server performance in processing the low overhead data can match or even exceed that of the high-end server. In the data partition approach, the data in all of the back-end servers may have the same overhead, but some back-end servers do not fully replicate the whole data set. In the third approach, back-end servers are optimized in different ways to serve specific query types.","In quality differentiation, the client can be served with higher quality content at a cost of more overhead. High quality content may consume more central processing unit (CPU) time. High resolution images consume more network bandwidth. The most current time sensitive content is often not cacheable and thus requires more overhead to retrieve.","The quality differentiation approach may be applicable in the following types of environments:\n\n","Although high quality content is desired in many situations, there are cases where low response latency is preferred. Clients using low bandwidth links like wireless and dial-up networks may prefer the responsiveness of the server over the quality of content. Therefore, the clients have different requirements for the services. QoS can thus be provisioned through differentiating the quality of contents and varying the response latency.","In the data partition approach, data sets are split and assigned to different back-end servers. For instance, in an electronic commerce (e-commerce) web site, one back-end server may store the inventory data while another may store the customer information. Queries that operate on different data sources are routed to the appropriate back-end servers. This approach enables efficient data caching, retrieval, and benefits disk and memory-intensive operations. However, its effectiveness may be contingent on the data dependency. If the operations frequently use both inventory and customer data simultaneously, then multiple connections may be needed to retrieve the data from different back-end servers.","Applications using query type differentiation may be as follows. The back-end servers are of different system types, some of which perform better on particular operations than others. The routing module exploits this difference to gain in both performance and cost. For instance, simple database implementations like MySQL excel in query types such as select. Hence some back-end servers can be customized to serve these type of queries. It is also beneficial to tailor the hardware configuration to expedite the execution of specific operations. For instance, more random access memory (RAM) can substantially expedite join operations. More powerful CPUs can accelerate the execution of computationally intensive queries. This approach may take into account the data layout to improve data locality.","2.2 Load-Based Quality Differentiation",{"@attributes":{"id":"p-0044","num":"0045"},"figref":["FIG. 3","FIG. 3"]},"For instance, a sample policy can be the following: (i) when CPU usage is under 80%, all the requests are serviced with high quality; (ii) when CPU usage is above 90%, all the requests are serviced with low quality; and (iii) when CPU usage is between 80% and 90%, 50% of the requests go to high quality and 50% go to low quality.","In this approach, a version selector  receives the URL from the web server . If the URL has multiple versions with different overheads, the system load monitor  is consulted. System load monitor  monitors the load of the web server, the network, and the back-end systems. The monitor sends load information  to the version selector . The load information  can be in forms such as CPU usage, disk traffic, etc. The version selector  selects the appropriate version (e.g., low overhead version  or high overhead version ) of the URL based on the load information and policies, retrieves the content and communicates with the web server .","2.3 Class-Based Quality Differentiation",{"@attributes":{"id":"p-0047","num":"0048"},"figref":["FIG. 4","FIG. 4"]},"Requests in the higher preferential class are serviced with the contents with higher quality. For instance, a class-based routing policy can be as follows: (i) class 1: 100% to high quality; (ii) class 2: 35% to high quality, 20% to medium quality, 45% to low quality; and (iii) class 3: 50% to medium quality, 50% to low quality.","In this approach, the web server  parses the HyperText Transport Protocol (HTTP) requests, extracts the identity of the client, and the browser characteristics. Such information  is passed to the version selector . The version selector  selects the appropriate version (e.g., low overhead version  or high overhead version ) of the URL based on the QoS information and policies, retrieves the content, and communicates with the web server .","2.4 Hybrid quality differentiation",{"@attributes":{"id":"p-0050","num":"0051"},"figref":["FIG. 5","FIG. 5"]},"In this approach, the version selector  receives the URL and QoS class  of the client from the web server . If the URL has multiple versions with different overheads, the system load monitor  is consulted. System load monitor  monitors the load of the web server, the network, and the back-end systems. Monitor  sends load information  to the version selector . The version selector  selects the appropriate version (e.g., version number ) of the URL based on the load information, QoS class of the client, and policies, retrieves () the content, and communicates with the web server .","2.5 Tiered Configuration","In a multi-tier environment as illustrated in , the contents may be retrieved through back-end servers  and . The requests are routed to the appropriate servers to get the proper service. The routing intermediary  carries out the routing functionality. The tiered back-end servers can be of heterogeneous capacity. For instance, in the database environment, the data tables may not be fully replicated among all the back-end servers. The one with the fullest replication would then be the high-end server , and those with partial replication are low-end servers . The high-end servers  usually have more capacity than the low-end servers .","When the HTTP request arrives, the front-end web server  parses the request and extracts the client identity, if available. The client identity correlates with the QoS level at which the request will be served. The web server  may invoke business application logic in the application server (such as an IBM Corporation WebSphere application server). These business applications do not have to be aware of the back-end server configuration. Thus, rewriting of these applications may not be necessary.","When the business applications communicate with the back-end service, they first pass the queries to the routing intermediary . The latter routes the queries to the appropriate back-end server based on the QoS classes to which the queries belong, the load distribution of the back-end servers, and the type of the queries (e.g., whether they update the data source). The following sections describe illustrative routing policies and implementations.","2.6 Routing Policies","The routing intermediary  routes queries to the back-end servers under specific routing policies. Instances of routing policies in this configuration may include:\n\n","In a multi-node back-end server configuration, the contents with different versions may be replicated across the back-end servers. The back-end servers that contain the high quality versions of contents usually consume more resources to serve the requests. For instance, one server may be a database server that receives external update process frequently. It keeps its data most updated. The other server may be a file server that caches the query results from the database server. The database server may take substantially more CPU time to process a query than the file server. However, the database produces the more current version.",{"@attributes":{"id":"p-0057","num":"0063"},"figref":["FIG. 6","FIG. 6"],"b":["61","61","62","62","63","62","64","62","64","22"]},"2.8 System Implementation Alternatives","The present invention provides for different implementation alternatives, including a centralized mode and a distributed mode.","In centralized mode, the routing decision is made by a centralized routing intermediary which may have knowledge about the traffic, system load, and\/or configuration differences between the back end servers. Web applications communicate with the routing intermediary to get routing instructions.","In distributed mode, the routing decision is not made by a centralized entity. Web applications route queries to the appropriate back end servers based on a local estimation of the load distribution in the back end servers. The web applications periodically converge their individual routing policies and revise them if necessary to keep the policies consistent.","2.8.1 Centralized Mode",{"@attributes":{"id":"p-0061","num":"0067"},"figref":["FIG. 7","FIG. 2"],"b":["71","1","71","72","72","73","72","22","73"],"i":"m "},"One advantage is that the routing intermediary has a global view of the traffic to back-end servers - through -. Switch  can thus ensure that routing decisions are consistent. However, switch  may become a bottleneck when traffic is heavy. Such implementation also may require special application programming interfaces (APIs)  for multiple web applications that reside in different machines, so as to communicate with switch  that interacts with back-end servers - through -. Thus, this mode may require changes to existing applications.","2.8.2 Distributed Mode",{"@attributes":{"id":"p-0063","num":"0069"},"figref":"FIG. 8","b":["81","1","81","84","1","84","83","1","83","82","82","85","81"],"i":["m ","n","m"]},"2.9 Routing Intermediary Implementation",{"@attributes":{"id":"p-0064","num":"0070"},"figref":"FIG. 9"},"As illustrated in , there are two components in the routing intermediary: an invoker servlet  and a virtual JDBC driver . The invoker servlet  can communicate with the virtual JDBC driver  through message passing or shared memory.","In the Java servlet context, an invoker servlet () may refer to the server that obtains the processing handle of the HTTP requests after the web server () finishes the protocol processing. The invoker servlet may resolve the mapping between URLs and actual business application logic and construct the run time environment for the business application logic. Application servlet  may be invoked by invoker servlet , and implements the business logic.","JDBC drivers - through -may be the interfaces between applications (such as Java servlets) and database servers - through -. A JDBC driver receives commands (Structured Query Language commands or SQLs) from the applications, translates them according to the specific protocols, sends the commands to the database server, and retrieves results from the database server.","Virtual JDBC driver  resides between the applications and the actual JDBC drivers - through -that communicate with the database servers - through -. Driver  receives the commands from the applications and relays them to the actual JDBC drivers. During the relay, driver  may adapt the commands according to the specification of the destination driver. Driver  is also able to choose where the commands will be routed.","Invoker servlet  obtains the client information from the HTTP requests. Such information may include the identity of the client that determines its priority and its browser type that indicates the rendering capability. Invoker servlet  then passes this information  to virtual JDBC driver  before sending the requests to the application servlet  that carries out the business logic. When the application servlet  needs to contact the database, it may first set up a database connection.","One exemplary method for setting up a database connection is to invoke a function such as the following:\n\nConnection conn=DriverManager\u00b7getConnection (url, \u201cusername\u201d, \u201cpassword\u201d)\n\nwhere url is a string that points to the address of the database server.\n","Instead of directly connecting to the actual database server, the application servlet  may call virtual JDBC driver  first by assigning its address to the parameter url. Then, subsequent commands may be intercepted by virtual JDBC driver .","Virtual JDBC driver  handles query routing and resolution of query syntactical differences. More specifically, when virtual JDBC driver  is called, the driver decides which actual database server should serve the consequent queries from the application servlet. Such methods are described herein in sections 2.6, 2.7, 2.10 and 2.11.","There are many platform-dependent SQL schemas in different database servers. Therefore, it may be necessary to provide appropriate SQLs to heterogeneous databases. There are multiple solutions, such as: deferred query materialization and query rewriting.","Deferred query materialization provides an abstract layer for query languages. Instead of directly using SQL queries, the application logic uses special APIs that are independent of the back-end database implementations to construct the query logic and then translate it into real platform-dependent database queries. Consequently, the application logic often need not be aware of the actual database that it interacts with, and the programmers can be more focused on the business logic itself. Examples of this kind include Java Data Object (JDO) specifications (Sun Microsystems of Santa Clara, Calif.). A drawback of this method is that existing applications may have to be rewritten to adopt the tiered services. Alternatively, a query can also be rewritten before being directed to the tiered servers to resolve the syntactical differences; thus, the overhead of modifying existing applications is amortized.","After selecting the actual database server and resolving the query syntactical differences, virtual JDBC driver  calls the actual JDBC driver that is associated with the database server and passes the query to that actual JIDBC driver. The latter carries out the database processing logic.","2.10 Load Detection","One way to detect server load is to use response time variation. However, because the access time of a single database query can vary significantly, it may not always be a reliable indicator of server load.","Load detection techniques may be based on the variation of the ratio of the total database access time per URL and the associated HTTP request processing time. The database access time may be determined by the size of the result set, the query complexity, and the degree of query concurrency, which is highly volatile. However, the corresponding servlet might need to process the result set and construct the query command, the complexity of which is approximately linear with that in accessing the database server. Thus, when the data set does not vary significantly, the ratio can signify which server is overloaded. A higher ratio that results from long database access times suggests that the database is more loaded. Conversely, a lower ratio suggests that the web server is less loaded.","More specifically, the database server selection algorithm for those URLs that have no data update operations may be as follows. If the previous accesses reveal that a URL is database intensive (characterized by the total database access time), then upon completion, the ratio of its total database access time and the HTTP processing time may be evaluated and compared to the previous values. If their difference is beyond a certain threshold, the switch may be instructed to route some traffic to the secondary database server. Otherwise, current traffic load may be considered acceptable for the high-end server ( of ) capacity, and the current traffic rate and the ratio value may be recorded for future reference.","The load detection algorithm may determine the maximum number of simultaneous requests Max that use the high-end server . The quantity Max may be defined as follows:",{"@attributes":{"id":"p-0080","num":"0086"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Max","mo":"=","mrow":{"mrow":{"mo":["{","}"],"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":[{"mi":["a","Max"],"mo":"*"},{"mi":["b","Rate"],"mo":"*"}],"mo":"+"},{"mi":"r","mo":">","mrow":{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"+","mi":"\u0394"}},"mo":"*","mover":{"mi":"r","mo":"~"}}}],"mo":","}}},{"mtd":{"mrow":{"mrow":{"mi":"Max","mo":"+","mn":"1"},"mo":",","mi":"otherwise"}}}]}},"mo":"."}}}},"br":{},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["(i) Positive real numbers a and b are tuning parameters and a+b=1. A higher value of a leads to a more gradual decrease in the traffic to the high-end server , while a lower value is more effective in preventing the high-end server  from being overloaded.","(ii) Max\u2032 is the previous value of the maximum number of simultaneous requests.","(iii) Rate is the current traffic rate to the high-end server .","(iv) r is the ratio of the database access time and the HTTP processing time of the monitored query, and {tilde over (r)} is its average value.","(v) \u0394 is the variation threshold that controls how much variation of r is considered normal. Variation beyond that is regarded as occurrence of overload."]}}}},"The idea of the equation is as follows. The current maximum degree of simultaneous connections is determined by its historical values and current traffic rate. The tuning parameters a and b determine how much each component affects the value of Max; larger a and smaller b make Max less subject to traffic variations and vice versa. If the ratio r is within the variation scope, the high-end server  may be considered to be underutilized such that additional traffic can be handled without penalty. Once r is beyond its variation scope, the current traffic rate and the historical value of Max approximate the capacity of the high-end server . One advantage of this methodology is that there is little modification to current applications and it is adaptable for various servlet applications.","One illustrative embodiment of the algorithm is formulated in the exemplary code below (FACILITIES). Variations within the spirit and scope of the invention by one skilled in the art are also possible.",{"@attributes":{"id":"p-0083","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"FACILITIES:"},{"entry":"boolean contain_update(url): boolean function that tells whether"},{"entry":"the given url contains insert\/delete\/update queries."},{"entry":"long db_processing_time(url, db): function that returns the"},{"entry":"processing time (ms) of the given url at the database db."},{"entry":"float ratio(url): function that return the URL's ratio of database"},{"entry":"access time to the HTTP processing time."},{"entry":"R: current traffic rate to the primary server."},{"entry":"delta: threshold of ratio variation."},{"entry":"Max: maximum concurrent connections to the primary server."},{"entry":"Conn DB_select(url)"},{"entry":"{"},{"entry":"if (contain_update(url))"},{"entry":"\u2003\u2003return primary; \/* update queries are routed to the primary server*\/"},{"entry":"if (R>Max)"},{"entry":"\u2003\u2003return secondary; \/* if the traffic to the primary server is high,"},{"entry":"\u2003\u2003the secondary starts to function *\/"},{"entry":"if (db_processing_time (url, primary) > db_processing_time"},{"entry":"(url, secondary))"},{"entry":"\u2003\u2003return secondary; \/* the url is served by the server that can best"},{"entry":"\u2003\u2003handle the queries *\/"},{"entry":"}"},{"entry":"Postprocessing(url)"},{"entry":"{"},{"entry":"compute and store the average database access time of the URL at the"},{"entry":"selected database d b."},{"entry":"compute the ratio of the database access time to the HTTP processing"},{"entry":"time, denoted as r. if the URL is served by the secondary database,"},{"entry":"then exit."},{"entry":"if (r > ratio(url)*(1+delta))"},{"entry":"\u2003\u2003Max = a*Max+b*R;"},{"entry":"else"},{"entry":"\u2003\u2003Max ++;"},{"entry":"}"},{"entry":"Helper modules:"},{"entry":"\u2003\u2003boolean contain_update( )...."},{"entry":"\u2003\u2003long db_processing_time( )...."},{"entry":"\u2003\u2003float ratio( )....."},{"entry":"\u2003\u2003R:..."},{"entry":"\u2003\u2003Delta:..."},{"entry":"\u2003\u2003Max:..."},{"entry":"Functions:"},{"entry":"Conn DB_select( )...."},{"entry":"Postprocessing( )...."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The function DB_select is invoked when the servlet establishes a connection to access the database. The function returns a database connection. The function Postprocessing is invoked when the servlet finishes. This function collects runtime statistics and recomputes the global variables that are used to select the database connections. The complexity of the algorithm is linear with the number of URLs that are tracked, and most of the operations are string matching. The routing overhead is relatively low.","2.11 QoS Policy Coordination","The QoS policy coordination process receives the traffic composition and database selection information from web servers and checks if the collective effect of database scheduling is consistent. If necessary, the QoS policy coordination process notifies web servers to change their local decision function parameters.","Multiple factors may be used to route the database queries, including the following: request priority and the traffic composition from different classes. One illustrative embodiment of the algorithm is formulated as follows. Variations within the spirit and scope of the invention by one skilled in the art are also possible.","For a request r that belongs to class i, the boolean variable Srepresents whether r can access the high-end server :",{"@attributes":{"id":"p-0088","num":"0099"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["S","i"]},"mo":"=","mrow":{"mn":"1","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mfrac":{"mrow":[{"msub":[{"mi":["\u03bb","i"]},{"mi":["W","i"]}],"mo":["*","\u2062"],"mi":"Max"},{"munder":{"mo":"\u2211","mi":"j"},"mo":"\u2062","mrow":{"msub":[{"mi":["\u03bb","j"]},{"mi":["W","j"]}],"mo":"*"}}]},"mo":">","msub":{"mi":["C","i"]}}}}}}},"br":{},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["(i) 1( ) is the boolean function.","(ii) \u03bbis the number of requests which have arrived since time point t that belong to class L","(iii) Wis the priority weight.","(iv) Max is the maximum number of simultaneous requests that the high-end server  can accept.","(v) Cis the number of requests in class i that have used the high-end server  since t."]}}}},"It is inferred from the equation that in a clustered web server environment, where a server makes database selections based on its own traffic conditions, the request routing as a whole across the entire web servers may be incorrect. Therefore, an agent may be set up that mediates the distributed selection algorithms to approximate the ideal value.","The usage of high-end server  at web server p, denoted as N, during time frame T is:",{"@attributes":{"id":"p-0091","num":"0107"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msup":{"mi":["N","p"]},"mo":"=","mfrac":{"mrow":[{"msubsup":[{"mi":["\u03bb","i","p"]},{"mi":["W","i","p"]}],"mo":["*","*"],"msup":{"mi":["Max","p"]}},{"munder":{"mo":"\u2211","mi":"j"},"mo":"\u2062","mrow":{"msubsup":[{"mi":["\u03bb","j","p"]},{"mi":["W","j","p"]}],"mo":"*"}}]}},"mo":","}}},"br":{},"sub":["i","i"],"sup":["p ","p ","p "]},"The ideal collective usage of the high-end server , denoted as N, from all the web servers is:",{"@attributes":{"id":"p-0093","num":"0109"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["N","ideal"]},"mo":"=","mrow":{"mfrac":{"mrow":[{"munder":{"mo":"\u2211","mi":"p"},"mo":"\u2062","mrow":{"msubsup":{"mi":["\u03bb","i","p"]},"mo":["*","*"],"msub":{"mi":["W","i"]},"mrow":{"munder":{"mo":"\u2211","mi":"p"},"mo":"\u2062","msup":{"mi":["Max","p"]}}}},{"munder":{"mo":"\u2211","mi":"j"},"mo":"\u2062","mrow":{"mstyle":{"mtext":"("},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"p"},"mo":"\u2062","mrow":{"msubsup":{"mi":["\u03bb","j","p"]},"mo":["*","\u2062"],"msub":{"mi":["W","j"]},"mstyle":{"mtext":")"}}}}}]},"mo":"."}}}}},"In most cases, W+Wcannot ensure.",{"@attributes":{"id":"p-0095","num":"0111"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["N","ideal"]},"mo":"+","mrow":{"munder":{"mo":"\u2211","mi":"p"},"mo":"\u2062","mrow":{"msup":{"mi":["N","p"]},"mo":"."}}}}},"br":[{},{}],"sub":"i","sup":"p "},"Another aspect of this invention is to externalize program logic that is used either to classify customers or to select the back end. The externalization can be done by instrumenting the system with one or more points of variability which are points in program code which are calls to an externalized repository for the logic that needs to be executed. The binding is dynamic, and the logic can be changed over time without recompiling the system code. Technology such as \u201cBRBeans\u201d (IBM Corporation of Armonk, N.Y.) can be used to that effect, see, e.g., A. Nartovich et al., \u201cWebSphere Application Server Enterprise, A Programmer's Guide,\u201d Edition 4.0, Chapter 3, IBM Redbooks, February 2002, the disclosure of which is incorporated by reference herein.","The logic that is externalized can be further specified as a set of rules which can be authored by nonexperts in information technology, see, e.g., I. Rouvellou et al., \u201cExtending Business Objects with Business Rules,\u201d Proceedings of the 33rd International Conference on Technology of Object-Oriented Languages and Systems, Mont Saint-Michel\/St-Malo, France, IEEE Computer Society Press, pp. 238-249, June 2000, the disclosure of which is incorporated by reference herein.","2.13 Service Provider","A further aspect of this invention is how classes are determined for clients and how differentiated content is created. These functions can be performed by a service provider. The service provider assigns clients to different quality of service classes preferably based on how much they are willing to pay for better services. Higher paying clients are assigned to higher quality of service classes.","The service provider also has the ability to provide differentiated content. The service provider does so by figuring out what the bottleneck resource is during peak periods. For example, the service provider might determine that the bottleneck resource for a web site providing significant dynamic content via databases is the database. In order to reduce database overhead, the service provider could provide a cache for frequent queries. The cache could be used to create dynamic content with lower overhead. A drawback is that the cache might not have data which is completely up-to-date. High paying customers could be given preferential access to the most current versions.","The service provider can periodically monitor the system in order to determine which parts of the system might become bottlenecks at different times. For example, at some points, the bottleneck may be a database. At other points, the bottleneck may be the network. The service provider constantly modifies the differentiated content and how it is served to different clients in response to changing conditions.","By way of example, the service provider, in accordance with previously established service agreements with clients, may specify a quality-of-service policy. The policy may comprise a plurality of subscriptions, each subscription being specified by content quality and service latency. A limited premium service subscription may be served with high content quality in low service latency. A medium service subscription may be served with a high content quality or a low service latency. An unlimited best-effort service subscription may be served with unspecified content quality and latency.","2.14 Illustrative Computing System",{"@attributes":{"id":"p-0102","num":"0118"},"figref":["FIG. 10","FIGS. 1","FIG. 10"],"b":"9"},"Further, it is to be understood that the individual components\/steps may be implemented on one such computer system, or more preferably, on more than one such computer system. In the case of an implementation on a distributed computing system, the individual computer systems and\/or devices may be connected via a suitable network, e.g., the Internet or World Wide Web. However, the system may be realized via private or local networks. The invention is not limited to any particular network.","As shown, the computer system  may be implemented in accordance with a processor , a memory , I\/O devices , and a network interface , coupled via a computer bus  or alternate connection arrangement.","It is to be appreciated that the term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other processing circuitry. It is also to be understood that the term \u201cprocessor\u201d may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices.","The term \u201cmemory\u201d as used herein is intended to include memory associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), flash memory, etc.","In addition, the phrase \u201cinput\/output devices\u201d or \u201cI\/O devices\u201d as used herein is intended to include, for example, one or more input devices (e.g., keyboard, mouse, etc.) for entering data to the processing unit, and\/or one or more output devices (e.g., speaker, display, etc.) for presenting results associated with the processing unit.","Still further, the phrase \u201cnetwork interface\u201d as used herein is intended to include, for example, one or more transceivers to permit the computer system to communicate with another computer system via an appropriate communications protocol.","Accordingly, software components including instructions or code for performing the methodologies described herein may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU.","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
