---
title: Methods and apparatus for communicating changes between a user-interface and an executing application, using property paths
abstract: A method for detecting a change in a current state of a property associated with an element of a user-interface includes the step of associating the element with a property path including a concatenation of a plurality of identifiers defining a path through a plurality of application components to a property at the end of the concatenation. The property path is mapped to a current state of the property at the end of the path. A request is received, from a local machine, for a change in a state of a property mapped to one of said plurality of concatenated identifiers defining the property path. The request for the change is sent to a remote machine. The remote machine applies the change. The local machine updates the element of the user-interface associated with the property path responsive to the change and the received regeneration.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07873965&OS=07873965&RS=07873965
owner: Citrix Systems, Inc.
number: 07873965
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20061201
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present application claims priority to U.S. patent application No. 09\/846,896, entitled \u201cMethods and Apparatus for Communicating Changes Between a User-Interface and an Executing Application, Using Property Paths,\u201d filed May 1, 2001, which is incorporated herein by reference.","The present invention relates to client-server networks and, in particular, to methods and apparatus for communicating changes between a user interface and an executing application.","Contemporary computer networks consist of a number of computer systems, called nodes, communicating with other computer systems via communication links. Typically, some of the nodes are client nodes and other nodes are server nodes. A client node formulates and delivers queries to a server node. A user of the client node enters the queries through a user-interface operating on the client node. The server node evaluates the queries and delivers responses to the client node for display on the client user-interface.","Usually, the server nodes host a variety of application programs or processes that can be accessed and executed by client nodes. When a client node launches an application program, the execution of that application program can occur at either the client node or the server node, depending upon the computing model followed by the computer network.","In a client-based computing model, the application program is packaged and sent down to, or pre-installed on, the client node, allowing the client node to run the application using the resources of the client node. This approach has several drawbacks. First, the client node must have sufficient memory, disk space, and processing power to effectively execute the application. A related problem that occurs using this model is that the number of applications a given client is able to execute is limited due to client resource constraints. Further, applications built this way are complex to develop and maintain and typically require modification or \u201cporting\u201d for all supported client computer system types. Moreover, this technique exacerbates the administration burden on a network administrator.","In a server-based computing model, the server node executes the application program, and only the control information for the client user-interface is transmitted across the computer network to the client node for display. Using this approach, user-interface events must be sent between the client and the server in order for the server application to process the events. This may result in perceived delays of user-interface response. Further, the application program must be specifically written, or changed, to support the user-interface on the client node. This increases the complexity of the application and prevents this technique from being useful with off-the-shelf applications.","A refinement of the server-based model is to supplant the device driver to which the application communicates in order to send screen and device updates back and forth between the client and the server. This approach avoids requiring applications to be rewritten. However, this approach requires device information to be sent between the client and the server in order to maintain the client display, again introducing perceived latency into the interface. Further, server-side processing requirements are increased in order to satisfy resulting device information required for communication with each connected client.","A recent, further refinement of the server-based model is to deploy the user-interface portion of the application as a mark-up language document such as Hyper Text Markup Language (HTML) document. However in using this approach, information sent from the server application to the client begins to \u201cage\u201d immediately. In other words the information may change on the server but the client would not automatically be notified and updated. Further, with this approach, interactivity requires context switching between pages even to perform simple tasks.","Standard and emerging approaches to application development for Web application delivery rely on one of two approaches. The first approach is adapting \u2018page based\u2019 application delivery code (e.g., servlets) to more dynamic use (e.g., sequence of servlets). The second approach is wiring user-interface components to server components. The first approach has the advantage of remaining Web-centric and within the skill set of Web developers, but is limited by its page-based roots. Generating applications with a user-interface using several pages (or dialogues) typically requires coordinating the server-side components to generate each page on an individual basis. This coordination becomes very difficult as the number of pages or the number of clients increases. The second approach, wiring, still requires the application developer to deal with the dynamic aspects of the application, as a developer must wire to existing object instances that the wiring tool knows about. This is typically objects that exist at application start up, or at other well defined times. The second approach typically requires customized tools to perform all aspects of UI design, including layout and formatting.","The present invention avoids these shortcomings. The present invention provides a mechanism by which the user-interface portion of the application can be delivered to the computer user either on the same machine on which the application is executing or on another machine remote from the machine executing the application. The invention separates the user-interface from the underlying application enabling the design of the user interactive portion of the application to be relatively straightforward.","The invention also permits the user interactive portion to be deployed on a wide range of client hardware environments without bringing with it all the required logic for performing the functionality of a particular application. These features give the user the effect of directly interacting with the application even though the application is potentially running somewhere else. User-interface, event handling and screen rendering logic stay on the client, thus dramatically reducing network traffic and latency. The invention also allows the user-interface portion to be connected with objects that do not currently exist, but may exist in the future. This makes it easier to specify connections. The invention connects the user-interface to objects using property paths. Property paths represent abstract paths and this abstract quality allows the UI to be connected to objects that may exist in the future but that do not exist at application startup or any other well defined point in time.","In one aspect the invention relates to a method of associating an element of a user-interface to a current state of a property in a system including an application having a plurality of components, wherein at least one component has a property, wherein each property is identified with an identifier. The method comprises associating the element of the user-interface with a property path, the property path including a concatenation of a plurality of identifiers, the concatenation of identifiers defining a path through the components of the application to a property at the end of the concatenation, and mapping the property path to a current state of the property at the end of the path defined by the concatenation of identifiers, to associate the element of the user-interface with the current state of that property. In another embodiment, the method includes a) examining each identifier in the concatenation of the property path in succession, b) determining, for the first identifier in the concatenation of the property path, a second state of a property with a name identical to the first identifier, a component of the application containing that property becoming a root application component; c) identifying, for the first identifier, a component of the application to which the second state points as a current application component, d) mapping the first identifier to the second state, e) determining for the next identifier in the concatenation of the property path, a next state of a property with a name identical to the next identifier located within the current application component, f) identifying, for the next identifier, a component of the application to which the next state points as a current application component, g) mapping the next identifier to the next state, and h) repeating steps e, f and g until the last identifier of the concatenation is examined to map the property path to the current state of the property with a name identical to the last identifier. In another embodiment, the method includes mapping the property path to an undefined state if no property is found that corresponds to an identifier in the plurality of identifiers in the concatenation.","In another embodiment, the method includes generating a node tree having a plurality of nodes, wherein each node of the node tree represents a mapping of an identifier to one of, a state of a property and an undefined state. In another embodiment, the node tree represents a plurality of property paths. In another embodiment, the method includes monitoring a plurality of states within the application to detect a change in one of the states of the plurality of states, each state in the plurality corresponding to one of the states mapped to an identifier in the concatenation of the property path. In another embodiment, the method includes receiving a property change event from a JAVABEAN-compatible component.","In another embodiment, the method includes re-mapping the property path to a new current state in response to detecting the change in one of the states of the plurality of states. In another embodiment, the method includes re-mapping the identifier the concatenation of identifiers to the changed state in response to detecting the change in one of the states of the plurality of states. In another embodiment, the method includes generating a property change message in response to a change in a state of a property corresponding to one of the identifiers in the concatenation of the property path. In another embodiment, the method includes updating one or more user-interface elements associated with the property path with a new current state in response to a change in the current state of the property.","In another embodiment, the method includes, a) detecting a change in one of a plurality of states in an application, each state in the plurality corresponding to one of the states mapped to an identifier in the concatenation of the property path, b) examining each identifier in the concatenation of the property path in succession, starting with an identifier corresponding to the changed one of the states of the plurality of states, c) determining for a currently examined identifier, a new next state of a property with a name identical to the currently examined identifier, d) re-mapping the currently examined identifier to the new next state in response to a change in a currently mapped state, and e) repeating steps c and d for each subsequent identifier in the concatenation of identifiers. In another embodiment, the method includes terminating the repeating in response to the new next state being identical to a state currently mapped for that currently examined identifier. In another embodiment, the method includes monitoring a new plurality of states within the application, the new plurality including the new next states mapped to an identifier in the concatenation of the property path.","In another embodiment, wherein the property path is a first property path and the concatenation of identifiers includes a wildcard identifier, the method includes mapping a second property path to a first value, and determining a second value for the wildcard identifier in response to the first value mapped to the second property path. In another embodiment, the method includes determining the second value such that replacing the wildcard identifier of the first property path with the second value causes the current state mapped to the first property path with the replaced wildcard identifier to be equal to the value mapped to the second property path. In another embodiment, the method includes dynamically binding the property path to one of the application components including the property corresponding to the current state mapped to that property path.","In another embodiment, the method includes transmitting to the application a request to update the current state of the property mapped to the property path associated with the element of the user-interface in response to a user modification of the value. In another embodiment, the method includes inhibiting a property change message in response to the application updating the current state of the property in response to the request to update. In another embodiment, wherein the user interface comprises an exemplary element associated with a property path including a wildcard identifier, the wildcard identifier corresponding to an indexed property including an index value range from a minimum value to a maximum value, the method includes generating an additional element for each index value of the indexed property from the minimum value to the maximum value by copying the given element associated with the property path, and associating a new property path with each additional element. In another embodiment, the method includes replacing the wildcard identifier associated with the given element with the corresponding index value of the additional element to define the new property path. In another embodiment, the method includes registering interest in the property path. In another embodiment, the method includes mapping one of the identifiers in the concatenation of the property path to a state of a property corresponding to the one of the identifiers.","In another embodiment, the invention relates to a system for associating an element of a user-interface to a current state of a property of an application, wherein the application has a plurality of components, at least one component having a property and each property is identified with an identifier. The system includes a property connector module to identify an association between the element of the user-interface and a property path, the property path including a concatenation of a plurality of identifiers, the concatenation of identifiers defining a path through the components of the application to a property at the end of the concatenation, and to map the property path to a current state of the property at the end of the path defined by the concatenation of identifiers, thereby associating the element of the user-interface with the current state of that property. In another embodiment, the system includes a client node. The client node includes the user interface having one or more elements, and a client portion of the property connector module. In another embodiment, the system includes a server node. The server node includes the application, and a server portion of the property connector module.","In another aspect, the invention relates to a method for creating a user-interface independently of an application with which the user interface interacts, wherein the application includes a plurality of components and at least one component contains a property, wherein each property is identified with an identifier. The method includes inserting at least one element into the user-interface, and associating at least one property path with one inserted element, the property path including a concatenation of a plurality of identifiers, the concatenation of identifiers defining a path through the components of the application to a property at the end of the concatenation. In another embodiment, the method includes determining a list of property paths associated with the application, and selecting the property path from the list to associate with the one inserted element of the user-interface from the list of property paths.","In another embodiment, the method includes receiving a property path description file associated with the application, the property path description file including a plurality of identifiers associated with the application and a relationship between the plurality of identifiers. In another embodiment, the method includes executing the application, and interacting with the executing application to determine a plurality of identifiers associated with the application and a relationship between the plurality of identifiers. In another embodiment, the method includes transmitting a request to register for a property change message corresponding to the property path associated with the element of the user-interface. In another embodiment, the method includes providing at least one predefined element, and enabling selection from the at least one predefined element to insert the selected predefined element into the user-interface. In another embodiment, the predefined element comprises one of an image type user-interface element, an iterator type user-interface element, a text type user-interface element, a hidden type user-interface element, a value type user-interface element, a slider type user-interface element, a treeview type user-interface element, a button type user-interface element, an iframe type user-interface element, a tab type user-interface element, a flipflop type user-interface element, a deck type user-interface element, a dropdown type user-interface element, a radio type user-interface element, and a script type user-interface element.","In another aspect, the invention relates to a system for creating a user-interface independently of an application with which the user interface interacts, wherein the application includes a plurality of components and at least one component contains a property, wherein each property is identified with an identifier. The system includes a property connector module to insert at least one element into the user-interface, and to associate at least one property path with one inserted element, the property path including a concatenation of a plurality of identifiers, the concatenation of identifiers defining a path through the components of the application to a property at the end of the concatenation. In another embodiment, the system includes a client node. The client node includes the user interface having one or more elements, and a client portion of the property connector module. In another embodiment, the system includes a server node. The server node includes the application, and a server portion of the property connector module.","In another aspect, the invention relates to a method using a system having an application comprising one or more objects, with at least one object including one or more properties. The method associates a user-interface element, which is independent of the application, with a property of the application. The method includes executing a process that is independent of the application; representing a property of the application by a property path and associating, by the application-independent process, the user-interface element with the property path. This associates the user-interface element with the property of the independent application. In one embodiment, the method determines whether a property of an object of the application exists that corresponds to the property path. In another embodiment, the determining process includes employing a value of a second property corresponding to a second property path (e.g., cross-mapping).","In another embodiment, the method includes monitoring a state of the property and detecting a change in the state of the property. In another embodiment, the process of detecting includes receiving a property change event from an API of a JAVABEAN\u2122 compatible component. In another embodiment, the method includes updating the user-interface element in response to detecting the change in the state of the property. In another embodiment, the method includes generating a property change message in response to detecting the change in the state of the represented property. In another embodiment, the method includes registering for a property change message for the property represented by the property path. In another embodiment, the method includes detecting a change in a state of one or more properties along the property path, and responding to a detected change in a value that the property path represents.","In another embodiment, the method includes determining at least one property path associated with the application and selecting the property path to associate with the user-interface element from at least one determined property path. In another embodiment the process of determining at least one property path includes traversing from a root object of the application to a corresponding property, using object pointers. In another embodiment, this includes mapping the traversal from a root object of the application to the corresponding property. In another embodiment, the process of mapping includes generating a node tree. In another embodiment, the method includes indicating which nodes in the node tree correspond to a property path that the client has registered interest in. In another embodiment, the method includes dynamically binding the property path to the object containing the represented property.","In another embodiment, the method includes allowing a user to modify a value associated with the user-interface element and updating the property of the application represented by the property path associated with the user-interface element in response to a user modification of the value associated with the user-interface element. In another embodiment, the method includes inhibiting a property change message in response to updating the property of the application in response to the user modification.","In another aspect, the invention relates to a method using a server node having an application comprising a plurality of objects, with each object including one or more properties, the method indicating a property of the application to monitor. The method includes executing a process that is independent of the application, representing a property of the application by a property path and receiving, by the application-independent process, a request to register for a property change message associated with a property path to indicate the property of the independent application to monitor. In one embodiment, this method includes determining whether a property of an object of the application exists that corresponds to the property path. In another embodiment, the process of determining includes employing a value of a second property corresponding to a second property path (e.g., cross-mapping).","In another embodiment, the method includes monitoring a state of the property and detecting a change in the state of the property. In another embodiment, the process of detecting includes receiving a property change event from an API of a JAVABEAN\u2122 compatible component. In another embodiment, the method includes transmitting the changed state in response to detecting the change in the state of the property. In another embodiment, the method includes generating a property change message in response to detecting the change in the state of the property. In another embodiment, the method includes registering the property change message of the request for the property represented by the property path.","In another embodiment, the method includes determining at least one property path associated with the application. In another embodiment, the process of determining at least one property path includes traversing from a root object of the application to a corresponding property by using object pointers. In another embodiment, the method includes mapping the traversal from a root object of the application to the corresponding property. In another embodiment the process of mapping includes generating a node tree. In another embodiment, the method includes indicating which nodes in the node tree correspond to a property path the client has registered interest in. In another embodiment, the method includes dynamically binding the property path to the object containing the represented property.","In another aspect, the invention relates to a method using a client node having a user-interface, including one or more elements, that is independent of an application, the method creating a user-interface element. The method includes executing a process independent of the application, employing an element of the user-interface, representing a property of the application by a property path and selecting, with the application-independent process, the property path or paths to associate with the user-interface element. In one embodiment, the method includes transmitting a request to register for a property change message associated with the selected property path.","In another embodiment, the method includes receiving the property change message in response to a change in a state of the property represented by the property path. In another embodiment, the method includes updating the user-interface element in response to notification of the change in the state of the property. In another embodiment, the method includes receiving at least one property path associated with the application. In another embodiment, the method includes allowing a user to modify a value associated with the user-interface element and transmitting the modified value and the associated property path. In another embodiment, the method includes inhibiting a property change message in response to transmitting the modified value associated with the user-interface element.","In another aspect, the process of employing an element includes providing to the user at least one predefined element for the user-interface, enabling the user to select from at least one predefined element for the user-interface and employing the selected predefined element. In another embodiment, the predefined element includes one or more of the following: displaying a property value as a piece of text, allowing the displayed property value to be edited, enabling a button that may be disabled based on the property value, vertical and horizontal sliders for numeric properties, displaying an image dependent on a property value, displaying an embedded frame dependent on a property value, an anchor dependent on a property value, ability to hide or show part of the UI dependent on a property and expression and the ability to change the style of part of a UI dependent on a property and expression. In another embodiment, the predefined element includes one or more of the following: selections of displaying one of a \u2018deck\u2019 of UI fragments dependent on a property value, a dropdown menu where each choice is a value from an range of indexed properties, one tab per member of a range of indexed properties, a set of radio buttons, a treeview based on property paths and the ability to repeat part of a UI once for each member of a range of indexed properties.","In still another aspect, in a system including an application having a plurality of components, at least one component having a property, each property being identified with an identifier, a method of detecting a change in a current state of a property associated with an element of a user-interface includes the step of associating an element of a user-interface with a property path, the property path including a concatenation of a plurality of identifiers, the concatenation of identifiers defining a path through a plurality of application components to a property at the end of the concatenation, the user interface created independently of the application with which the user interface interacts. The property path is mapped to a current state of the property at the end of the path defined by the concatenation of identifiers to associate the element of the user-interface with the current state of that property. A request is received, from a local machine displaying the user interface, for a change in a state of a property mapped to one of said plurality of concatenated identifiers defining the property path. A remote machine receives the request for the change in the state of the property. The remote machine applies the change to the state of the property. An indication of the state of the property is transmitted to the local machine. The local machine updates the element of the user-interface associated with the property path. In one embodiment, one of the plurality of components of the application is executed to change the state of the property.","In yet another aspect, a system for detecting a change in an element of a user-interface, the element associated with a current state of a property of an application, the application having a plurality of components, at least one component having a property, each property being identified with an identifier, the user-interface created independently of the application with which the user interface interacts, the system comprises a property connector module. The property connector module is configured to identify an association between an element of a user-interface and a property path, the property path including a concatenation of a plurality of identifiers defining a path through a plurality of application components to a property at the end of the concatenation. The property connector module is configured to map the property path to a current state of the property at the end of the path defined by the concatenation of identifiers, thereby associating the element of the user-interface with the current state of that property. The property connector module is configured to receive, from a local machine displaying the user interface, a request for a change in a state of a property mapped to an identifier in the concatenation of identifiers defining the property path. The property connector module is configured to send, to a remote machine, the request for the change in the state of the property. The property connector module is configured to transmit to the local machine an indication of the state of the property. The property connector module is configured to update on the local machine the element of the user-interface associated with the property path. In one embodiment, the property connector module is configured to request execution, by the remote machine, of one of the plurality of components of the application to change the state of the property.","Some objects of this invention are as follows: to allow simple UI development for developers with little or no programming experience; to allow strong separation between application and UI development; to allow separation of UI static and dynamic aspects; to have low bandwidth and latency-tolerance communications; to allow device-clients to be tailored to the devices' capabilities; to require only a small learning curve for application and UI developers; and to allow for scalable servers.","To accomplish some of these objects, the invention includes a system for providing rich\/highly interactive client interfaces to applications running on a centralized server (or servers). A key part of the system is that the interface between client and server is highly abstract and it can function with both other client types (other Web browsers and device specific clients) and other server types (e.g., COM).","The system uses a \u2018loose\u2019 coupling mechanism, which allows the server-side application to be designed with little regard for the user-interface. By maintaining this strong separation it is possible for a user-interface to be completely redesigned without access to the application code, or the infrastructure supporting it. For example a third party could generate a user-interface for a \u2018published\u2019 application without any access to the application code or runtime environment. The system also allows one application and the server on which it is located to be used with many different types of user-interfaces. New client types may be designed and deployed without touching the server code. A third party could design a new client type without the server's involvement. The user-interface for a particular application can be changed or ported to a new device without having to even stop the server application, let alone redesign or rebuild it. This is the \u2018number one want\u2019 on a recent survey of Web application designers. The user-interface can be tuned or given a new look and feel without disrupting the function of the application. This may be done using standard tools. As the user-interface is strongly separated from the server, different user-interfaces can be developed for different device capabilities. There is no intention that user-interfaces on difference clients should look identical. This simply makes it much easier to develop a client \u2018player\u2019 for a new device","The system takes advantage of the fact that most user-interfaces are essentially static. A large portion of a user-interface does not change at all. A typical example is a form. The form itself is not modified during execution, but only the values that appear in the fields of the form. The dynamic aspect of a user-interface generally consists of changes to the static page \u2018template\u2019 such as filling in fields, changing text values and a navigation through a number of dialogs or pages under the control of the user and\/or the application. For a Web-client, the static aspects of a user-interface generation, and the navigation aspects (under user control) are already well understood by users and developers alike. Rather than replace these with different notions, the invention keeps standard Web-metaphors. The invention adds only the ability to fill in a page template dynamically.","By keeping the interface between application and user-interface very small, and by separating the static and dynamic aspects of a UI, the invention allows the static aspect of a user-interface to be developed using standard UI development tools. These tools can be extended (or additional tools provided) to add the dynamic aspect of the UI. Because of the approach taken to the static\/dynamic split, this is extremely straightforward for the UI developer. A unique aspect that the system brings to UI technology is the way in which dynamic aspects of the application (e.g., creation of new objects, changes in values) may be reflected in a static user-interface by linking UI elements.","The foregoing and other objects, features and advantages of the invention will be apparent from the following more particular description of the embodiments of the invention, as illustrated in the accompanying drawings.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 1","b":["10","10","14","18","22","14","18","22","14","26","34","34","34","34","34","34","34","34","34","26"],"i":["a","b","c ","d ","a","b","c ","d "]},"Each of the application components , , and includes zero or more properties , , , , and (generally ). This embodiment includes two types of properties. A first type of properties , for example, , and , have a value for a specific variable. A second type of properties , for example, , and , have a pointer to another application component  (e.g., object, class), thus this second type of property  represents a composite of additional application components  and their properties . In other embodiments, application components  can be generated by a process using a data file. For example, application components  can be representations of nodes within a structured data file, such as XML or a database, where the properties  are attributes specified in the structured file or associated document type definition (\u201cDTD\u201d) (i.e., a specific definition that follows the rules of the Standard Generalized Markup Language). In another embodiment, the application components  support additional standard properties  such as \u2018parent\u2019, \u2018child[i]\u2019, and the like.","Many applications  are object-oriented and as such, generate a structured relationship between the objects . The structured relationship can be illustrated as a node tree. The root node is the first object of the application and each object that the root object points to becomes a child node. Each object that the child node points to becomes a grandchild node and so on. For example, object represents a root node. Objects and are children nodes of the root node . Object is the child node of object and the grandchild node of object . Each part of the application  state (i.e., values of application component properties  at a particular instant in time) is accessible via a traversal of a \u2018path\u2019 from one or more root objects to the state of a property itself by following object pointers (e.g., properties , , ). This path taken by the traversal of the structured relationship is a property path, also referred to as a pathname, and is described in more detail below. An object and\/or property may be addressable by several \u2018paths\u2019 from the root node, for example, an object representing an Employee may be accessible as \u2018the current employee\u2019 (root->current), the 10employee in an index (root->index->item ), the manager of some other employee (root-> . . . ->manager) and the like. These paths correspond to different concepts that happen to have the same object as their current value.","Some models for application development (e.g., JAVABEANS\u2122 component architecture by Sun Microsystems, Inc. of Palo Alto, Calif. and ACTIVEX\u2122 platform by Microsoft Corporation, Redmond, Wash.) provide a link between the application components  of an application  by using a property-based link. A property-based link is an object pointer that is accessible via a standard means (e.g., \u2018get\u2019 and \u2018set\u2019 methods). Applications  using property-based links undertake to inform the server process  about changes in the property-based link using, for example, property change events.","The client process  produces a user-interface (\u201cUI\u201d)  that is displayed to a user. The UI  includes one or more user-interface elements and (generally ). The UI  can be, for example, a Web page, an HTML document, a custom UI and the like. Though the UI is generally hereinafter referred to as a page , this should be without loss of generality as the UI  can be displayed on a non-Web client using a native language. The UI elements  are associated with one or more values , , (generally ) that the UI elements  display or make decisions in response thereto. The user-interface element  is a portion of the UI  that dynamically changes and is associated with a state of property  of an application component . As described in more detail with , a user of the page  associates each of the UI elements  to the one or more properties  of an application component  by indicating one or more property paths. The UI element  can be, for example, an input box for textual or numerical input and display of a value of a property . The UI element  also can be, for example, a horizontal slider for numerical input and display of a value of a property . As shown, the first user-interface element displays and\/or affects a value associated with a state of a property  of one of the application components . The second user-interface element displays and\/or affects two values and ","Between the application components  and the user-interface elements  is the property connector API . The property connector API  includes a client portion and a server portion . The property connector API , and thus the client portion and the server portion , is a process that is independent of the application  (i.e., not a part of nor generated from the application ). The property connector API  process can be implemented as software, as hardware or as a combination of both. The execution of the property connector API  can be initiated in several ways. A computing device on which the property connector API  resides can initiate execution of the property connector API  upon power up or upon a authorized user log-in. The computing device can initiate execution of the property connector API  when the computing device downloads a page  containing UI elements  associated with property paths. The computing device can initiate execution of the property connector API  when the user initiates execution of the application  or requests delivery of the page . In one embodiment, when the computing device initiates execution of the property connector API , the computing device also receives a startup argument including the name of a file containing the UI page  details, and details of the server node  to connect to and the application  to start.","As explained in more detail below, the property connector API  maps each dynamic user-interface element  to a property  of an application component  using the associated property path. The property path defines the interaction between the client process  and the server process  in terms of properties  of the application  rather than in terms of the user-interface elements .","In its mapping, the property connector API  represents a property  of an application component  within an application  as a property path. The property path is the concatenation of one or more identifiers. An identifier corresponds to a property  within an application component, which can be a value or a pointer. The property path defines a path through the application  from a root component  to the particular application component , and a property  itself of that application component. For example, property points to application component and the property of application component points to application component that contains property . The property path that corresponds to the property in this example is \u2018App.PropertyID.PropertyID.PropertyID\u2019.","Each part of the property path (i.e., App, PropertyID, PropertyID, PropertyID) is an identifier. The property connector API  uses these identifiers to traverse the path in the application  defined by the property path. The \u2018App\u2019 identifier identifies the root node. The \u2018identifies the property within the root component and property points to application component . The property connector API  determines the value of \u2018PropertyID\u2019 by obtaining the present state (i.e., value) of a property with the same name within the root component of the application  identified by \u2018App\u2019. For example, the property connector API  determines the value by using a \u2018get\u2019 method of an API for the application . The property connector API  determines the present state points to the application component . Because the value of property corresponding to identifier \u2018PropertyID\u2019 is component , the \u2018PropertyID\u2019 identifier identifies the property within the component . The property connector API  determines the value of \u2018PropertyID\u2019 by obtaining the present state (i.e. . . . , value) of the property with the same name within the component , which was identified using \u2018PropertyID\u2019, The property connector API  determines the present state points to the application component . Because the value of property corresponding to identifier \u2018PropertyID\u2019 is component , the \u2018PropertyID\u2019 identifier identifies the property within the component . The property connector API  determines the value of \u2018PropertyID\u2019 by obtaining the present state (i.e., value) of the property with the same name within the component , which was identified using \u2018PropertyID\u2019. Property is not a pointer, but a number, for example, salary. The property connector API  maps the current state of this property to the property path \u2018App.PropertyID.PropertyID.PropertyID\u2019. While mapped, the property path \u2018App.PropertyID.PropertyID.PropertyID\u2019 has the value of the salary of property ","Property paths are not \u201cwired\u201d connections from a user-interface element  to the associated application component , but more analogous to a description of what \u201ctype\u201d of data the user-interface can display and\/or affect (i.e., a loosely coupled, flexible connection). This means that during execution, the application  can create or delete application components  without any adverse affect on the user-interface elements . For example, the property path \u2018App.PropertyID.PropertyID.PropertyID\u2019 corresponds, at one point in time, to property , as stated above. However, if the application  changed property , \u2018PropertyID\u2019, to subsequently point to application component , instead of application component , the property path \u2018App.PropertyID.PropertyID.PropertyID\u2019 subsequently corresponds to property , not property . When notified of the change, the property connector API  updates the value  of the user-interface element  associated with the property path \u2018App.PropertyID.PropertyID.PropertyID\u2019 to reflect the current state of property ","In another example, for a human resources application, the property path to the \u201csalary\u201d property of the twenty-seventh employee in a list of employees of a certain department is \u2018HRApp.Dept.Employee[].Salary\u2019 (counting from 0). The property path describes an abstract property of the application  as a whole, not a specific property of a particular instantiated object. In other words, if the user-interface element  was to be associated with a specific property, then the path could be simply, for example, \u2018property . Then regardless of which components  pointed to which other components  would not matter, because the property path would always reflect the state of property . This, however, is not how property paths work. The property path identifies a path through the application  and not one specific property located in the application . The path can change as one of the properties  corresponding to one of the identifiers in the concatenation changes. When a component  changes and points to a different component, the property path follows that change and the property path reflects the state of the new property the path now ends at.","Similarly, a property path can also represent a property with a potential to exist, but that does not exist at the present time. For example, if the list of employees only contains twenty-six employees (numbered 0 to 25), the property path \u2018HRApp.Dept.Employee[].Salary\u2019 does not correspond to any property. When another employee is added, the property path \u2018HRApp.Dept.Employee[].Salary\u2019 would then point to the salary property of the twenty-seventh employee. This example illustrates how property paths can be used to describe properties that do not exist presently, but can exist in the future, in addition to those properties that exist only at application startup, or at some other well defined point. In the human resources application example, this means that as the list of employees change, the actual employee who is twenty-seventh in the list of employees can change, but the property path remains pointing to the salary property of the twenty-seventh employee, regardless of who that may be. This method of using the structured relationship between application components  to create a property path is important in allowing strong separation between UI elements  and application components .","Using this example in connection with , the second value of UI element displays the salary of the twenty-seventh employee of a specific department because the value is associated with the property path \u2018HRApp.Dept.Employee[].Salary\u2019. The client portion maps this association between the value  and the property path. The server portion maps the same property path \u2018HRApp.Dept.Employee[].Salary\u2019 to the property of application component . To obtain this mapping, the server portion follows the pointers with the application components  that correspond to the property path. In one embodiment, the server portion follows the pointers by using \u2018get\u2019 methods and constructing a structure tree map  ().","The \u2018HRApp\u2019 portion of the property path corresponds to the application  and the first created application component (i.e., the root application component). The \u2018Dept\u2019 portion of the property path corresponds to the property that points to the application component , which in this example represents a list of employees of the indicated department. The \u2018Employee[]\u2019 portion of the property path corresponds to the property that points to the application component , which in this example represents information about the twenty-seventh employee. The \u2018Salary\u2019 portion of the property path corresponds to the property that contains a value, which in this example represents the amount of the salary of the twenty-seventh employee. The application component can also contain other properties (not shown) that have values representing information about that particular employee, such as name, social security number, date of hire and the like.","As the list of employees for the indicated department changes, the property that pointed to application component changes and subsequently points to another application component (not shown). In this example, before the change, the application component represented information about the twenty-seventh employee. After the change, the new application component (not shown) to which the property points now represents the new twenty-seventh employee. But even with the change, the property path \u2018HRApp.Dept.Employee[].Salary\u2019 still points to the twenty-seventh employee of the indicated department and thus the second value of UI element displays the appropriate value of the salary of the new twenty-seventh employee, whoever that employee may now be.","The following are additional examples of property paths. For example, the property path \u2018App.CurrentSelection.Price\u2019 represents the price property  of the currently selected item within a shopping application . If no item is selected or the current selection changes, then the value  of this property  changes, even though the price property  of each of the individual items  (e.g., objects) within the application  does not. For another example, the property path \u2018App.SelectedEmployee.Boss.Boss.Name\u2019 represents the name property  of the selected employee's boss's boss. This property path will display the appropriate value  even if the selection changes (e.g., a different employee is selected), if there is a reorganization, or if the boss changes his\/her name. In another example, the property path \u2018App.Employee[].Name\u2019 represents the name property  of the twenty-second employee in a table. If the table is sorted or changes size, then this property path will correctly reflect the name property  of the employee who is, after the revision, currently the twenty-second employee in the table.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 2","b":["54","60","64","94","94","60","108","22","90","26","34","60","94","232","22","60","22","26","90","22"],"i":["b","b ","b","b. "]},"The client node  includes a client transceiver  and an optional page interface . The page interface  includes the client portion and generates (or edits) a page , containing dynamic UI elements . The client node  can be any computing device (e.g., a personal computer, set top box, phone, handheld device, kiosk, etc) used to provide a user-interface . The client node  can be connected to the communication channel  through a variety of connections including standard telephone lines, LAN or WAN links (e.g., T1, T3, 56 kb, X.25), broadband connections (ISDN, Frame Relay, ATM), and wireless connections. As shown, the client portion is part of the page interface . The page interface  can be, for example, a Web browser (e.g., a MICROSOFT\u2122 INTERNET EXPLORER browser manufactured by Microsoft Corporation of Redmond, Wash. and\/or a NETSCAPE\u2122 NAVIGATOR browser, manufactured by Netscape Communications Corporation of Mountain View, Calif.). In another embodiment, for example, one without a page interface , the client portion is a separate process on the client node .","In other embodiments, interaction between the client node  and the server node  occurs if the application  is executing and the user is interacting, via the page , with the application  (i.e., run time). If the user is creating a page  (i.e., build time), then there is no interaction between the client node  and the server node . For example, the user creates a page  using the page interface  (e.g., HTML editor, DREAMWEAVER\u2122 software by Macromedia, Inc. of San Francisco, Calif.), as described in more detail with relation to . The user locates UI elements  using the page interface . In one embodiment, the user selects a UI element  from a set of predefined UI elements  (). The user associates a property path with the selected UI element . In one embodiment, a property file has the following form:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"---start property file---"]},{"entry":[{},"\/\/ List of types used in this property files (identifiers)"]},{"entry":[{},"\/\/ String and Number are built in"]},{"entry":[{},"Types:"]},{"entry":[{},"Person"]},{"entry":[{},"Company"]},{"entry":[{},"\/\/ Identify the type of the root object"]},{"entry":[{},"RootType: Company"]},{"entry":[{},"\/\/ List the properties. Of the format"]},{"entry":[{},"\/\/ <type of object><name of property> <type of property>"]},{"entry":[{},"\/\/ or"]},{"entry":[{},"\/\/ <type of object><name of property>[ ] <type of property>"]},{"entry":[{},"\/\/ (for indexed properties)"]},{"entry":[{},"\/\/ A RW on the end of the line indicates they property is read\/write"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ May contain multiple entries for a certain object, property pair"]},{"entry":[{},"\/\/ if the property can have several types."]},{"entry":[{},"\/\/ Any property may also be undefined"]},{"entry":[{},"Properties:"]},{"entry":[{},"Company.Name String"]},{"entry":[{},"Company.Boss Person"]},{"entry":[{},"Company.Staff[ ] Person"]},{"entry":[{},"Company.EBW[ ] Person"]},{"entry":[{},"Company.SalaryTotal Number"]},{"entry":[{},"Person.Name String"]},{"entry":[{},"Person.Salary Number RW"]},{"entry":[{},"Person.ID String"]},{"entry":[{},"Person.Boss Person"]},{"entry":[{},"Person.Staff[ ] Person"]},{"entry":[{},"\/\/ List of methods that may be called from the client"]},{"entry":[{},"\/\/ in format <object type><method name>(<argument type...>)"]},{"entry":[{},"Methods:"]},{"entry":[{},"\/\/ Hire someone given name, id, salary, boss"]},{"entry":[{},"App.Hire(String, String, Number, Person)"]},{"entry":[{},"\/\/ Fire someone"]},{"entry":[{},"Person.Fire( )"]},{"entry":[{},"---end property file---"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In another embodiment, the property file has the following form:",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"---start property file---"]},{"entry":[{},"RootType: Company"]},{"entry":[{},"Company.Name String"]},{"entry":[{},"Company.Boss Person"]},{"entry":[{},"Company.Staff[ ] Person"]},{"entry":[{},"Company.EBW[ ] Person"]},{"entry":[{},"Company.SalaryTotal Number"]},{"entry":[{},"Person.Name String"]},{"entry":[{},"Person.Salary Number RW"]},{"entry":[{},"Person.ID String"]},{"entry":[{},"Person.Boss Person"]},{"entry":[{},"Person.Staff[ ] Person"]},{"entry":[{},"App.Hire(String, String, Number, Person)"]},{"entry":[{},"Person.Fire( )"]},{"entry":[{},"---end property file---"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, the property file containing property paths is stored on the client node  for the page interface  to access. The property file can contain the types of application components  that the application  creates and the type of properties  that each of the type of application components  contain. The property file can also contain information regarding the structured relationship between application components  and\/or the children application components  of each type of application component . The file can be manually created and\/or manually augmented.","In other embodiments, the page interface  and\/or the client portion has a property browser. In one embodiment, the browser may examine the code of the application  (e.g., JAVA\u2122 compatible classes or source code) and determine possible property paths by examining the type of the get\/set property methods. In another embodiment the property browser temporarily communicates with the server node  and initiates execution of the application . Upon execution, the property browser can obtain the instantaneous values of available application components , their properties  and the relationship (e.g., child nodes) between the application components . After this information is obtained, the execution of the application  and communication between the client node  and server node are terminated. The property browser can save the obtained results in the property file.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 3","FIG. 2","FIG. 4"],"b":["22","22","22","22","70","74","70","104","22","78","46","22","46","42"],"i":["a ","b ","a ","b ","a "]},"The server portion includes a protocol module  and a property path manager . In another embodiment, the protocol module  is located within the server transceiver  (e.g., ). The server portion is in communication with the application components  of the application  through a property\/event interface . The client portion and the server portion communicate with each other over the communication channel , using a property path protocol as described below. In another embodiment, as shown in , the client portion and the server portion are located on the same machine and are directly connected to each other.","The property connector API  associates the user-interface elements  with the application components  using property paths as described above. In overview, the functions of the property connector API  can include:\n\n","The client-side event manager  maps the UI elements  to the associated property paths. The event manager  maintains a database of the mapping of UI elements  to property paths. The event manager  may or may not examine the individual identifiers in the concatenation of a property path. This affects the amount of information that has to be transmitted between the client portion and the server portion . In one embodiment, the event manager  treats property paths as opaque names. In this embodiment, the event manager  does not breakup or examine the individual identifiers in the concatenation of a property path, but instead treats the property path as a single, long variable name or as a placeholder. This allows a compression algorithm in the protocol between the client portion and the server portion that replaces each property path in the page  with a single id (e.g., $1). In this embodiment, there is a dictionary (not shown) on the server node  so the sever portion can lookup each id and convert the id into a property path prior to accessing the corresponding property. In this embodiment, the server portion must track all changes to any of the properties corresponding to identifiers in the property path and determine how those changes affect the value of the one or more property paths including the identifier. The server portion also only communicates changes to the client portion in terms of complete property paths.","In another embodiment, the client portion does examine changes corresponding to each individual identifier in the property path and can determine itself how a change to a property corresponding to a single identifier affects one or more property paths including that identifier. In one embodiment, for example, a copy of the property path manager  is located on the client node  and sends all changes (rather than just the changes in leaf values) in a tree structure  () between the client portion and the server portion . This embodiment adds complexity to the system , but may give bandwidth\/performance gains, because the server node can communicate changes to the client portion in terms of individual identifiers. For example, consider an indexed property A with A[]=X, A[]=Y and A[]=Z and each of X, Y, and Z application components  with three properties and If the table is resorted so that A[]=Y A[]=Z and A[]=X, in the system  (), nine property change events are sent from server portion to the client portion (i.e., one each for the properties A[]A[]A[]A[]A[]A[]A[]A[]and A[]). In the embodiment where a copy of the property path manager  is located on the client node , the server portion sends three property change events (i.e., A[], A[] and A[]), to the client portion because the copy of the property path manager  on the client node  has all of the children node information and can make the applicable changes.","As depicted in , the event manager  sends to the server-side property path manager  all of those property paths in which the event manager  has interest. The event manager  registers interest in a property path using, for example, a \u2018ListenTo\u2019 command shown in Table 1. When the event manager  informs the server portion about which property paths are of interest, the event manager  does not need to inform the server portion specifically which (or how many) UI elements  are interested in each property path. The property path manager  monitors the properties  of the application components  corresponding to the identified property paths and notifies the event manager  when any of the property paths in which the client portion has registered interest in changes. When the user provides some input, by interacting with one of the user-interface elements , the event manager  notifies the property path manager  about the change and to which property path the change corresponds. Because the communication references property paths, the communication about the change is in terms of the effect on the application components , rather than in terms of the user-interface elements . For example, if the user slides a horizontal slider to the 50% point, the UI element determines the value the 50% point represents and signals an event to the event manager .","When a property path is no longer of interest, the event manager  can send a notice of lack of interest to the server portion in one of several different ways. For example, the event manager  can immediately inform the server portion , not inform the server portion  at all, or inform the server portion after some time period or other event (e.g., when first notified about a change in the corresponding property of the property path). The server portion transmits to the client portion any change events associated with those property paths in which the client portion has indicated interest. When the event manager  receives a property change event for a change in the state (e.g., value) of a property  associated with a property path from the server portion , the event manager  determines, using the mapping, which UI elements  must be notified. The event manager  communicates the updates due to the change event to each of the UI elements  mapped to the property path. In one embodiment, there are multiple pages  located in separate sub-windows. The event manager  is configured to inform UI elements  that are located in other sub-windows about any applicable changes. In this embodiment, the event manager  manages the database of the mapping so that the closure of a window does not adversely affect the other UI elements . In this embodiment, the event manager  and\/or associated data structures may be replicated or distributed between the different pages. For example, each page may contain a portion of the event manager , and a table of UI elements  that are present on that page.","If the user updates a UI element , the UI element  signals a change event to the event manager  and is updated on the display as the user makes a change. When the event manager  receives a change event from the UI element , the event manager  determines, using the mapping, which other UI elements  are mapped to the same property path as the UI element  that changed. The event manager  communicates the updates due to the change event to each of the other UI elements  mapped to the same property path. The event manager  also sends a change event to the server portion so that the server portion can update the associated property  of the application component  in response to the user change of the UI element .","In another embodiment, the event manager  does not make any immediate changes to the UI element  that the user changes or any other UI elements  mapped to the same property path. Instead, the event manager  first sends a change event to the server portion so that the server portion can update the associated property  of the application component  in response to the user change of the UI element . The application  can reject the change initiated by the user for security or other reasons. The event manager  waits until the server portion sends back a change event indicating that the property  of the application component  associated with the property path has changed. After the event manager receives that change event from the server portion , then the event manager  communicates the updates due to the change event to each of the other UI elements  mapped to the same property path. If the application rejects the change, then the event manager  updates the UI element  that the user changed back to its pre-user intervention state.","In some embodiments, the property connector API  takes steps to avoid looping of change events, which can result in trying to update a UI element  or an application component  that generated the change event and has already been updated. For example a UI element  only generates a change event if a user updates the UI element , for example, but does not generate a change event if the event manager  updates the UI element . In another embodiment, for example, the property connector API  does not inform the original generator (i.e., UI element , application component ) of the change event, as that originator is already updated.","A page  can also be altered dynamically when, for example, an iterator type predefined UI element  creates additional UI elements for indexed properties, a process described in more detail below. If a page  is being altered dynamically, then when a UI element  is generated, the event manager  determines those property paths in which the UI element  is interested. Similarly, when a UI element  is destroyed, the event manager  determines that the UI element  is no longer interested in those property paths. In one embodiment, the user has previously created the page  separately (i.e., at build time) and thus some or all of the UI elements  on the page  are created prior to the application  executing. In an embodiment using treeview type or iterator type predefined UI elements , an example of a portion of the UI (e.g., a row in the table) is included in the page  at build time. At runtime, the client portion duplicates\/clones the example (e.g., row) for all of the members of the indexed property associated with the treeview type or iterator type predefined UI element , as described in more detail below. The example portion of the UI may be a single UI element or a more complex set of UI elements.",{"@attributes":{"id":"p-0085","num":"0088"},"figref":["FIG. 4","FIG. 2","FIG. 2"],"b":["128","112","42","128","130","42","112","134","78","138","46"]},"The palette  of available predefined UI elements  includes predefined UI elements , , , , , and . Predefined UI element represents an image type UI element. The image type predefined UI element displays an image dependent on the value of the associated property (e.g., \u2018property-value\u2019.gif). Predefined UI element represents an iterator type UI element. An iterator type repeats a UI element for each member of a range of indexed properties (e.g., once each for i=0, i=1, i=2, . . . in App.Staff[i]). The element \u2032 represents an iterator type element, where the row  is an exemplary row that the client portion copies when dynamically creating elements for each index value.","Predefined UI element represents a text type UI element. The text type predefined UI element displays a property value as a piece of text. The elements ,  and  represent text type elements. With a text type predefined UI element , numeric values may be scaled, stepped and\/or clipped. Predefined UI element represents a hidden type UI element. A hidden type hides and shows part of the UI element, dependent on a property and an expression. Predefined UI element represents a value type UI element. The value type predefined UI element is an input box that displays a property value and allows it to be edited by a user. The element  represents a value type element.","Predefined UI element represents a slider type UI element. The slider type predefined UI element includes a vertical slider and\/or a horizontal slider for numeric properties. The element  represents a slider type element. When the user selects the slider type UI element, the user also enters values associated with \u2018min\u2019 \u2018max\u2019 and \u2018step\u2019 values for that slider element. In another embodiment, the user enters the property paths for the values associated with \u2018min\u2019 \u2018max\u2019 and \u2018step\u2019 values for that slider element and the properties corresponding to those property paths determine the associated values. Predefined UI element represents a treeview type UI element. The element represents a treeview type element. The treeview type predefined UI element is based on the levels of a property path. For example, for the property path \u2018App.Boss.Staff[i].Staff[j]\u2019 the treeview has a root level, a child level and a child's child level. The root level is App.Boss, the child level is App.Boss.Staff[i], and the child's child level is App.Boss. Staff[i].Staff[j].","In other embodiments, the palette  can include other predefined UI elements . For example, a button type disables a button based on a property value associated with a property path. An iframe type displays an embedded frame, where the contents of the frame are constructed from a page described by the value of property path. An anchor type creates an anchor which links to a page described by the value of a property path. The tab type predefined UI element displays associated properties as tabs, with one tab per member of a range of indexed properties. A flipflop type changes the style of part of a UI, dependent on a property and an expression. For example the flipflop will set the style of the part of the UI to one state (the flip state) if the expression evaluates to \u2018false\u2019 when a placeholder in the expression is substituted by the current value of the property. If the expression evaluates to \u2018true\u2019 then the style of the part of the UI is set to an alternative state (the flop state).","A deck type displays one of a \u2018deck\u2019 of portions of a UI, dependent on a property value (each UI portion is associated with a value, an the one whose value matches the current value of the property is displayed). A dropdown type is a nested dropdown menu, where each choice is a value from a range of indexed properties. A radio type has one or more radio buttons, where each has a property path and an associated value to set the property path to if the button is selected. All UI elements may contain an expression in terms of a number of property paths, rather than a simple property path. For example, the expression App.Employee[]. Salary+App.Employee[]. Salary would use the sum of the value of these two properties to update the UI element, rather than an individual property value. A script type element executes a script on the client node  whenever a value of a specified property changes, and passes the value of the property as an argument to the script.","To create the HTML page \u2032, the user selects a UI element \u2032 generated by the page interface  and places the selected UI element \u2032 at the desired location in the page \u2032. The user can also select from the predefined UI elements  shown in the palette . The user selects a predefined UI element  and places the selected predefined UI element  at the desired location in the page \u2032. This placement can be done, for example by the click and drag method. Alternatively, the user can move the cursor to the desired insertion point, and then click on the item from the palette . The client portion generates a dialog box that prompts the user to enter relevant attributes (e.g., property path, min\/max values, etc). When the user enters all of the relevant attributes, the client portion locates the selected element  at the cursor position.","The user uses the entry display  to edit a property path associated with a UI element \u2032 selected in the page \u2032. To make the association, the user can type in the property path. In another embodiment, to make the association, the user can search through a list (e.g., structured tree) of available property paths for the application  and select a property path from the list. As described above, in one embodiment the list is provided through a property file containing identifiers and their relationships, and the page interface  accesses the property file, which is stored on the client node . In other embodiments, the page interface  and\/or the client portion includes a property browser. The property browser obtains the instantaneous values of available application components , their properties  (e.g., identifiers) and the relationship (e.g., child nodes) between the application components  and properties  to provide a list of available property paths. In another embodiment the property browser examines the code of the application and determines possible property paths by examining the types of the application objects.","Once a user locates all desired UI elements \u2032 in the page \u2032 and associates them with property paths, the page \u2032 is ready to be used with the application .  depicts a screenshot  of a page \u2033 being used in conjunction with an executing application (i.e., run time). The page \u2033 contains a treeview type UI element  that displays the structured relationship between the employees. The page \u2033 also contains a large number of text type UI elements. Text type UI elements ,  and  that display the text values of properties that correspond to the \u2018selected\u2019 employee. This current selection is also reflected in (and may be changed using) the tab type UI element . Image type UI element  displays an image that corresponds to the selected employee. The value type UI element (i.e., input box) and the slider type UI element  display the salary that corresponds to the selected employee. The user can use any of the UI elements associated with the \u2018salary\u2019 property path (e.g., , ) to change the salary that corresponds to the selected employee. As discussed above, when a user changes any one of these UI elements , , the client portion changes all of the other UI elements \u2033 with the same property path so that they all stay consistent. This change to the UI elements \u2033 is done entirely on the client node  without any interaction from the server node . The client portion also notifies the server portion of the change, so the server portion can update the appropriate property . However, the application  may veto the change either by not providing a \u2018set\u2019 method for the property , or by rejecting the call via veto means available in the property\/event interface  (e.g., for JAVABEANS\u2122 compatible components, this veto might be in the form of a \u201cthrow\u201d statement using an \u201cexception\u201d sub-class). If the change is vetoed, the property path manager  informs the client portion that the value has changed back to its old value, so that the correct value is displayed on the client node .","Other text type elements on the page \u2033 include -, which are all dynamically created by copying an example treeview entry  () and substituting in the appropriate property path for the position in the treeview (e.g., App.Boss.Name, App.Boss. Staff[].Name, App.Boss. Staff[]. Staff[].Name, App.Boss. Staff[] . Staff[].Name, App.Boss. Staff[].Name respectively). The client portion similarly creates text elements - in the table from an exemplary row of the table (e.g.,  of ) and by substituting the index values 0, 1, 2, 3, and 4 into the indexed property path \u2018App.Employee[*]Name\u2019.",{"@attributes":{"id":"p-0095","num":"0098"},"figref":["FIG. 6","FIG. 4"],"b":["86","86","22","38","34","86","160","160","26","34","34","34","34","34","38","38","38","38","164","164","164","164","164","160","34","38","34","26","34","34","164","34","86","160","86","22","42"],"i":["a ","a\u2032","b\u2032","c\u2032","d\u2032","a\u2032","b\u2032","c\u2032","a","b","c","d ","a\u2032","a "]},"As shown, the client portion has registered interests in property paths \u2018App.X.Y\u2019 and \u2018App.X.Z\u2019, represented by tree nodes and , respectively. X, Y and Z represent properties of the application components \u2032 and these properties correspond to the identifiers of the property paths. For further illustration, property path \u2018App.X.Y\u2019 can represent the property path \u2018App.Employee[].Name\u2019 and \u2018App.X.Z\u2019 can represent the property path \u2018App.Employee[].Boss\u2019. The initial value that corresponds to the property path \u2018App.Employee[].Name\u2019 is represented by property , or the value \u2018Alf\u2019. The application component that corresponds to the property path \u2018App.Employee[].Boss\u2019 is represented by application component  and the name property of that application component is , or \u2018Chris\u2019.","When the state of the application component \u2032 changes, the property\/event interface  notifies the property path manager . The property path manager  updates the corresponding tree node(s)  in the property path tree . If the updated tree node(s)  represents a complete property path in which the client portion has registered interest, the property path manager  sends, or queues for sending, a change event to the client portion . The property path manager  subsequently recursively examines each of the tree node's children nodes. In this examination, the property path manger , via the property\/event interface , obtains a new value of a property \u2032 from the application \u2032, and if another value of a registered property changes, transmits a change event to the client portion . The results are that the change in the state of one property can result in many property change events being notified to the client portion . The property path manager  terminates the recursive examination when something is found to be unchanged. For example, any child node of tree node is not examined, as the value of the tree node is unchanged.","In the embodiment shown in , the value of property path \u2018App.X\u2019 changes from application component  to . In the \u2018App.Employee[]\u2019 property path example, this change represents a change in the third employee. The client portion is not interested in the \u2018App.X\u2019 property path, so the property path manager  does not generate a change event for this change. However, the client portion registered interest in the property path \u2018App.X.Y\u2019, and the value of the property corresponding to that property path has now changed from , \u2018Alf\u2019, to , \u2018Betty\u2019. The property path manager  determines this change when it recursively examines the children tree nodes Y and Z of tree node X . Significantly, this recursive examining is what allows the property connector API  to maintain the loosely coupled connection between UI elements  and application components \u2032.","For example, consider when the application \u2032 is not configured to generate a change event when the name of the third employee has changed, the value represented by the property path \u2018App.Employee[].Name\u2019, but that the application \u2032 is configured to generate a change event when application components \u2032 are generated and\/or deleted and when properties \u2032 of existing application components \u2032 change. The property path manager  converts those change events that the application \u2032 can generate into change events associated with property paths in which the client portion has interest by examining its tree structure .","Referring back to the change from application component  to , both of these application components , point to application component . The client portion has registered in the property path \u2018App.X.Z\u2019 and this value remains unchanged, despite that fact that App.X now refers to a different application component . In the \u2018App.Employee[].Boss\u2019 property path example, this represents that the boss of the new third employee, represented by application component , is still the application component represented by . Because there is no change associated with the registered property path \u2018App.X.Z\u2019, the property path manager  does not generate a change event.","Because the property path manager  converts changes to states of a properties within an application \u2032 to change events associated with property paths, the client portion can register interest in special type property paths. One special type is a cross-mapped property path. The cross-mapped property path is in the form, for example, Map(\u201cv#r\u201d). The cross-mapped special type represents a relationship between a value \u201cv\u201d, specified with a property path, and a range of possible values \u201cr\u201d, specified with a wildcard property path. The value of the cross-mapped property path is the property path within the range \u201cr\u201d that has the same value as \u201cv\u201d. For example, if \u201cv\u201d is \u201cSession.CurrentEmployee\u201d, \u201cr\u201d is \u201cApp.Employee[*]\u201d, and the currently selected employee is the 3entry within the App.Employee enumeration then the value of Map(\u201cSession.CurrentEmployee#App.Employee[*]\u201d) is 2.","Described another way, cross-mapping is a lookup of one property path, dependent on information from a second property path. For example, when the property path manager  receives the command Map(\u201cSession.Current#App.Employee[*]\u201d), the property path manager  examines the first property path \u201cSession.Current\u201d and determines the value v of the property path. The property path manager  then looks up the value v within the second property path, where the value v replaces a wildcard identifier of the second property path. The value of the cross-mapping is the index that matches. For example if the state of the first property path \u201cSession.Current\u201d is \u2018Barbara\u2019 and the corresponding states of the second indexed property paths are:",{"@attributes":{"id":"p-0103","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"App.Employee[0] is Abe"]},{"entry":[{},"App.Employee[1] is Barbara"]},{"entry":[{},"App.Employee[2] is Charlie"]},{"entry":[{},"App.Employee[3] is Diane,"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The second property path may contain several wildcards identifiers, and the value will be the \u2018route\u2019 through all of these wildcard identifiers. For example, for the cross mapping is \u201cSession.Current#App.Boss.Staff[*].Staff[*]\u201d. The state mapped to the first property path is \u201cSession.Current\u201d=Ben. The corresponding states of the second indexed property are:",{"@attributes":{"id":"p-0105","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"App.Boss.Staff[0].Staff[0] = Alice"]},{"entry":[{},"App.Boss.Staff[0].Staff[1] = Ben"]},{"entry":[{},"App.Boss.Staff[1].Staff[0] = Chelsea."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The value of the cross-mapping of \u201cSession.Current#App.Boss.Staff[*].Staff[*]\u201d is equal to 0,1.","Another special type is an indexed property path. In the JAVABEAN\u2122 compatible API, and other similar APIs, there is a concept of \u2018indexed\u2019 properties. The indexed property A acts like a number of properties \u2018A.size, A. A., A.. . . . A.(size-)\u2019. The property connector API  follows this indexing by representing such properties in property paths \u2018A[ ], A[], A[],A[]. . . . A[size-]\u2019, respectively. The iterator type predefined UI element  () uses the special type indexed property path.","The iterator type predefined UI element  includes a template and is linked to an indexed property path. The template represents the layout of the iterator type predefined UI element  for a single member (i.e., a single index value) of the property path. During execution, the iterator type predefined UI element  creates a copy of the template for each member of the indexed property, and modifies the copy so that it is associated with a property path with the corresponding index value. These new copies are inserted into the user interface as additional UI elements . If the range of the indexed property increases (or decreases), more copies are inserted (or removed) as required, so that there is one UI element  for each currently available index value. Each copy is linked to the application via its associated property path. An identical approach is taken for treeviews, and rows of drop-down menus.","For example, the \u2018iterator\u2019 UI element  provides a table with a \u2018template\u2019 row. The \u2018iterator\u2019 UI element  duplicates this \u2018template\u2019 row for each member of the indexed property. Each row can contain arbitrary UI elements  with \u2018wildcard\u2019 pathnames (i.e., property paths) that have the current row number substituted in prior to registration. This is shown in the following exemplary code:",{"@attributes":{"id":"p-0110","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<table>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<tbody style=\u2018display:none\u2019 widget=\u2018iterator\u2019"]},{"entry":[{},"range=\u2018App.Employee[ ]\u2019>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<tr>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<td>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<span widget=\u2018text\u2019 variable=\u2018App.Employee"]},{"entry":[{},"[%idx].Name\u2019>Name<\/span>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/td>"]},{"entry":[{},"<td>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<span widget=\u2018text\u2019 variable=\u2018App.Employee"]},{"entry":[{},"[%idx].Salary\u2019>Salary<\/span>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/td>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/tr>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/tbody>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/table>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Referring back to , the property\/event interface  transmits data (e.g., change events, value changes) between the property path manager  and the application . This interface  uses an appropriate API for the implementation of the application . In one embodiment, for example, the application  is JAVA\u2122 technology-based, and the standard \u2018JAVABEAN\u2122 Property API\u2019 provides the required semantics and is thus used as the property\/event interface . This standard API  allows the property path manager  to change the values of properties  of application components  when those values have been changed by a user through a UI element . This standard API  also notifies the property path manager  about changes within the application . Other embodiments can include COM objects  and a COM property change API  and\/or C++ objects  with associated API .","The client portion and the server portion communicate with each other over the communication channel . The protocol modules  and  establish low-level communication by use of a communications layer. An exemplary protocol is described in Table 1. The protocol can vary from Table 1 depending on how the client portion and the sever portion are divided between the client node  and the server node  (e.g., copy of property manager  on the client node , server portion and client portion directly connected to each other on same node, etc.). In another embodiment, the protocol modules  and  are part of the client transceiver  () and the server transceiver  (), respectively.","During communication, the server node  and the client node  batch the communication into a number of messages, which may be compressed or encrypted. For example, in one embodiment, the server node  and the client node  use HTTP as the transport protocol. The client node  sends the server node  one or more messages. The server node  processes the one or more messages, which may result in various property change events. The server node  batches all of the messages queued to be sent to the client node  and sends them as the response to the HTTP request from the client node . In one embodiment, batching involves the removal of \u2018outdated\u2019 changes. For example if a change list in the batch of queued messages includes A.B.C=x. . . A.B.C=y, the entry \u2018A.B.C=x\u2019 is overwritten by the subsequent entry \u2018A.B.C=y\u2019 and can be safely discarded. In one embodiment, the batching process also sorts the entries lexicographically in order to aid compression.","The communications protocol, as illustrated in Table 1, relies on informing the client node  about which property paths within the application  have changed. Communicating in terms of changes to values of property paths is typically a lower overhead than informing the client node  about which of the client's display elements  to update, and how to update them. In the system , the role of the client node  is to reflect the current state of the application . If network or communication channel latency is high, then the client node  displays an incomplete state, but the application  can continue functioning correctly. The application  continues because the client node  and the server node  are more loosely coupled than in traditional systems. The server node  can be completely unaware of the type of client, or the way in which the client node  chooses to reflect the changes in the state of the application .","This makes the server node  more stable and scalable, as new client node  features do not affect the server node  or the execution of the application .",{"@attributes":{"id":"p-0116","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Direction","Message","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["C->S","Start","Inform the server that a client wishes to start a"]},{"entry":[{},"(identifier","new application or reconnect to a running one."]},{"entry":[{},"for","One client may simultaneously run several"]},{"entry":[{},"application","applications. The server may veto the"]},{"entry":[{},"instance,","execution of an application, based on a stored"]},{"entry":[{},"application","security policy"]},{"entry":[{},"descriptor)"]},{"entry":["C->S","ListenTo","Register interest in an application property."]},{"entry":[{},"(application","The server should immediately generate a"]},{"entry":[{},"identifier,","property-change event for the property to tell"]},{"entry":[{},"pathname)","the client the current value."]},{"entry":["C->S","Map","Register interest in a cross-mapped property."]},{"entry":[{},"(application","Cross-mapped properties are described above."]},{"entry":[{},"identifier,"]},{"entry":[{},"map"]},{"entry":[{},"identifier,"]},{"entry":[{},"pathname 1,"]},{"entry":[{},"pathname 2)"]},{"entry":["C->S","Drop","Remove interest in specified property."]},{"entry":[{},"(application"]},{"entry":[{},"identifier,"]},{"entry":[{},"pathname)"]},{"entry":["C->S","Set","Set the specified property to the specified"]},{"entry":[{},"(application","value."]},{"entry":[{},"identifier,"]},{"entry":[{},"pathname,"]},{"entry":[{},"value)"]},{"entry":["S->C","Application","Inform the client that the value of a property"]},{"entry":[{},"identifier,","has changed."]},{"entry":[{},"Pathname="]},{"entry":[{},"value"]},{"entry":["C->S","Invoke","Tell the server to parse and execute the"]},{"entry":[{},"(Application","specified string. This must represent a call to"]},{"entry":[{},"identifier,","an accessible method on an object within an"]},{"entry":[{},"string)","application (specified by pathname). Any"]},{"entry":[{},{},"return value from the call is discarded."]},{"entry":[{},{},"The call is represented by a string of the"]},{"entry":[{},{},"following form Pathname.MethodName (arg,"]},{"entry":[{},{},"arg, arg...) where arg is either a constant (a"]},{"entry":[{},{},"number or string) or a property path."]},{"entry":[{},{},"The server may veto the execution of such"]},{"entry":[{},{},"methods based on a stored security policy."]},{"entry":["C->S","Null","Used as a heartbeat to indicate to the server"]},{"entry":[{},{},"that the client is still in existence."]},{"entry":["C->S","Close","End the application."]},{"entry":[{},"(application"]},{"entry":[{},"identifier)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":"Notes:"},{"entry":"S= server node 60, C= client node 64, pathname \u2261 property path."}]}}}}},"In other embodiments, the protocol modules  and  are configured to employ compression schemes within the communications layer that they establish. A property path compression scheme is used within a batch of messages sent within the client node , within the server node  and\/or between the server node  and the client node . Whenever a batch of messages is sent, the property names used in the second and subsequent message is compressed by sending only the difference between the required property name and the previous property name. For example, rather than sending the message C->S","\u2018ListenTo(\u201cSession. Current.Name\u201d),ListenTo(\u201cSession. Current. Salary\u201d)\u2019, the client node  sends the message \u2018C->S ListenTo(\u201cSession.Current.Name\u201d),ListenTo(16+\u201cSalary\u201d)\u2019, where 16 is the number of characters of \u201cSession.Current.Name\u201d that also occur in \u201cSession.Current.Salary\u201d. The client node  takes advantage of the preceding message by shortening the subsequent message.","Another scheme to shorten the length of messages is for the client node  to register interest in a number of property paths by using a wild card. For example, this scheme is used to register interest in all the property paths that supply values for a table. To illustrate this example, the single message \u2018C->S ListenTo(\u201cApp.Employee[*].Name\u201d)\u2019 registers interest in the property paths \u2018App.Employee[] .Name\u2019, \u2018App.Employee[].Name\u2019 . . . \u2018App.Employee[n\u22121].Name\u2019, where n is the size of the App.Employee indexed property. In addition, if the size of the App.Employee property changes, then the client node  has implicitly registered interest in all App.Employee[ to m\u22121].Name values, where m is the new size.","The property connector API  also compresses the property path names. From the server portion to the client portion , in response to a wildcard ListenTo request (as in the example above) the server portion compresses its responses by omitting property path names. Rather than sending the messages:",{"@attributes":{"id":"p-0121","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"S->C App.Employee[0].Name = Alf"]},{"entry":[{},"S->C App.Employee[1].Name = Bert"]},{"entry":[{},"S->C App.Employee[2].Name = Carl,"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"the server portion sends",{"@attributes":{"id":"p-0123","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"S->C array = App.Employee[*].Name"]},{"entry":[{},"S->C arrayelement = Alf"]},{"entry":[{},"S->C arrayelement = Bert"]},{"entry":[{},"S->C arrayelement = Carl,"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"where array and arrayelement are special property names that may be sent efficiently.","The system  uses a data compression scheme in messages sent from the server node  to the client node . The client node  stores, at all times, the \u2018last known\u2019 value  of each of the property paths that it is displaying in the page  in a current value table. In one embodiment, the server node  optionally stores a copy of this information, and uses this as a data dictionary to compress values sent. For example, the server node  needs to transmit to the client node  the message S->C App.Employee[].Name =\u201cAlbert\u201d. The server node  determines, by examining the data dictionary, that the client node  already has the value App.Employee[].Name =\u201cAlbert\u201d by a previous transmission, and upon determining the value that was sent, then the server node  compresses its message to S->C App.Employee[].Name=copyValue(App.Employee[].Name), where copyValue is a directive to the client node  to use a value  from its current value table.","In another embodiment, the protocol modules  and  are configured to employ the data compression scheme in parallel with the property path compression scheme and an array name compression scheme. The protocol modules  and  utilize this combination of schemes when the size of the description of the \u2018copyValue\u2019 expression is smaller than the literal value. The array name compression scheme is of particular benefit when an array of data on the server node  is sorted, and this data is displayed in the UI  on the client node . The combination of compression schemes described above compresses the message",{"@attributes":{"id":"p-0127","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"S->C\u2003\u2003App.Employee[0].Name = \u201cAlbert\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"App.Employee[1].Name = \u201cBert\u201d"]},{"entry":[{},"App.Employee[2].Name = \u201cCathy\u201d"]},{"entry":[{},"App.Employee[3].Name = \u201cDoug\u201d"]},{"entry":[{},"App.Employee[4].Name = \u201cElsie\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"to",{"@attributes":{"id":"p-0129","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"S->C\u2003\u2003array=\u201dApp.Employee[*].Name\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"arrayelement = copy Value 4"]},{"entry":[{},"arrayelement = copy Value 3"]},{"entry":[{},"arrayelement = copy Value 2"]},{"entry":[{},"arrayelement = copy Value 1"]},{"entry":[{},"arrayelement = copy Value 0."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In other embodiments, the property connector API  is configured so that the server node  resource utilization is low. Generally, there are no \u2018per-client\u2019 threads and little \u2018per-client\u2019 state and background processing. There are three classes of applications  that can be optimized for scalability, by reducing the amount of processing or storage done per client, or per change. The first class of applications  that can be optimized are responsive to user input, but do not pro-actively change values of properties . If the client node  is dormant, the property connector API  can optimize the resource usage on the server node  by suspending the application  and\/or storing client-specific state on the client node  until the client node  becomes active again.","The second class of applications  that can be optimized are those that act as data feeds, for example stock prices. With this class of applications , the per-client data is small, whereas the shared data may be large. The property connector API  again stores client-specific state on the client node  rather than the server node , allowing the server node  to scale to more client nodes . For this class of applications , the property connector API  allows a single \u2018worker application instance\u2019 to service many clients .","The third class of applications  that can be optimized are those that generate events faster than the client node  can collect them. An example is a stock ticker application that sets the price of a stock every second and communicates with a client node  that reads the stock price once every minute. The property connector API  reduces the rate of event generation, without involvement from the application , to reduce the per-event processing load. This is particularly important for the third class of applications with a large number of clients . For applications where the rate of event generation is high compared to the rate of polling by clients, there is a higher than necessary per-client event processing load for connected clients. In one embodiment, the property connector API  adds event buffering mechanisms so that the per-event cost is much lower. For example, only one record is updated on the server per event, rather than one per client. At a lower period of event generation, the property connector API  scans these records and forwards events to the client records. The property connector API  matches, in effect, the rate of event generation to the rate of polling.","For these three classes of applications , the property connector API  supports different modes of operation where the per-client state and\/or processing on the server node  is further reduced. This is at the expense of increased bandwidth and\/or processing requirements when communication does take place, or at the expense of reduced timeliness of event notification. A client connection may move from a \u2018highly interactive\u2019 mode of operation to a \u2018resource saving\u2019 mode of operation and back many times during its lifetime. Equally, the rate of event generation may be varied according to the server load.","In one embodiment, there are two operating modes for property connector API , and additional operations within the operating modes. The normal mode of operation, described above, is called connected mode. The server  stores, for each client , an instance of the application  and a property graph of listener objects . In connected mode, there is high per-client state stored on the server  and high per client event processing load. However this is low per client poll\/invocation processing load, and thus low bandwidth is required.","The second mode of operation is disconnected mode. In disconnected mode, the client state is removed from the server  and stored on the client . No per client event processing takes place. Either no application  is running on the server , or only a single shared instance is executing. However, sufficient state is stored on the client  to allow the per-client application  to be recreated when necessary. The client  also stores a description of each property it is interested in, as in connected mode. The property connector API  allows a client  in disconnected mode to poll. This poll has higher processing and bandwidth costs associated with it than in connected mode. A disconnected client  wishing to perform an invoke command (Table 1) must reconnect. Moving from disconnected mode to connected mode, and back, incurs relatively high bandwidth and processing overhead.","The additional operations are specific optimization techniques for fine tuning the connected and disconnected modes of operation for deployments with a large client population. The additional operations are disconnect, reconnect, and one-shot. For the disconnect operation, issued by client , the property connector API  commands the application  to save its state and shut down. This saved state is then sent to the client . No per-client state remains on the server . The connection then enters the disconnected mode. Heuristics determine when to enter the disconnected state. Entering the disconnected state is only possible for applications  that provide a suitable interface, or where a saved state can be created by logging the history of all operations invoked.","During the reconnect operation, issued by client , the client  sends the saved application state to the server  along with a list of properties  that the client  is interested in. The server  restarts the application  using the saved state, re-registers interest in all properties , and continues in the connected mode. This operation is invoked by a disconnected client  that wishes to update the server state (i.e., invoke an operation or set a property).","During the one-shot operation, issued by client , the client  sends the saved application state to the server  along with the list of properties  that the client is interested in. The server  may restart the application , return the current values of the properties  and then shut down the application . For an application  to use this optimization, it must provide the required static method, for example, a single shared instance, or static method, that can take a saved state and return a suitable application instance. This suitable instance may be a shared instance between several clients or may be a new per-client instance. After the property connector API  obtains the property values, the property connector API  commands the application  to stop execution. The one-shot operation is invoked by a disconnected client  that wishes to poll, but not change the server state.","In other embodiments, the property connector API  is further configured with additional optimizations such as timestamp, slow garbage collector, connectivity check and property set. One optimization that the property connector API  uses is the timestamp. For many applications based on data feeds (e.g. stock tickers), the majority of properties  that a client  has registered interest in may not change between polls. In the disconnected mode, this may result in one-shot operations providing a large amount of unnecessary state data. To alleviate this, the property connector API  adds a timestamp-based property interface. For example, in one embodiment, the property connector API  uses the two commands \u2018Timeid getCurrentTimestamp( )\u2019 and \u2018Object getChangedProperty(String name, Timeid since)\u2019. The \u2018getChangedProperty\u2019command returns a property value if it has changed since the specified timestamp. The \u2018getCurrentTimestamp\u2019command returns the current time. In replies from disconnect or one-shot operations, the server  provides the current timestamp as an additional parameter. In calls to one-shot or reconnect operations, the client  provides this timestamp, and is informed of property values if they have changed since this timestamp was issued.","In another embodiment, the property connector API  uses the slow garbage collector optimization, which requires the cooperation of the application . When a client  performs a reconnect and\/or one-shot operation, if the previous application instance is still available (i.e., has not been garbage collected), then this instance can be used as in connected mode. This optimization does not apply if the application  has been \u2018stopped\u2019 explicitly on disconnect, but many applications are \u2018passive\u2019 and do not require a stop interface.","In another embodiment, the property connector API  uses the Connectivity Check collector optimization. When using the \u2018slow garbage collector\u2019 optimization, above, a client  wishing to perform reconnect or one-shot operations first determines whether the server  still has a valid application instance. If the server  does, then the saved state and property list does not need to be sent. When successful, this optimization reduces the bandwidth requirement. When unsuccessful, it incurs an additional \u2018round trip\u2019 from the client  to the server  and back.","In another embodiment, the property connector API  uses the property set optimization. It is noted that if a server  is supporting a large number of clients , all of which use the same user-interface, then it is likely that many of the clients  will be interested in exactly the same set of properties. During disconnect mode, the server  associates the set of properties  that the client  is interested in with an set identifier, and the client  uses this set identifier during one-shot and reconnect operations, rather than sending the complete list of properties . Using the set identifier incurs a small additional memory requirement on the server , as many clients share the same property set, but saves considerably in the bandwidth requirement of the one-shot and reconnect operations.",{"@attributes":{"id":"p-0143","num":"0146"},"figref":"FIG. 7","b":["60","64","64","60","200","26","200","26","60","64","26","26","204"]},"The client portion scans the UI  and identifies (step ) a UI element  within the UI  that is associated with a property path and has not been initialized (e.g., inserted into table and registered). The client portion inserts (step ) into its table the identified UI element  and its associated property path. The client portion registers (step ) interest in this property path with the server portion . The client portion determines (step ) whether there are any more UI elements  in the UI  that are associated with a property path and have not been initiated. If there are more UI elements  in the UI  that have not been initiated, then the client portion repeats steps ,  and  for each of the additional UI elements  that are not initiated. When all of the UI elements  have been initiated, the client portion monitors (step ) the UI elements  for user changes.","When the client portion registers (step ) interest in a property path, the server portion , through the property\/event interface , determines (step ) the initial value for the registered property path. The server portion sends (step ) the determined initial value to the client portion . The client portion updates (step ) the identified UI element  with the initial value. If there are any other UI elements  associated with the same property path, the client portion updates (step ) those elements  with the initial value also. The server portion updates (step ) the tree structure map  with the registration of interest for the property path, received from the client portion , and the determined initial value.","The client portion determines (step ) whether the update of the UI element(s)  resulted in creating one or more additional UI elements  (e.g., additional employees were added to the list). If one or more additional UI elements  were added, then the client portion repeats steps ,  and  for each of the additional UI elements . If no additional UI elements  are added, the client portion monitors (step ) the UI elements  for user changes.","While monitoring (step ) the UI elements , the client portion determines (step ) whether the user changed the value of an existing UI element . If the user does not change the value of an existing UI element , then the client portion continues to monitor (step ) the UI elements . If the user does change the value of an existing UI element , then the client portion informs (step ) the server portion of the change. If there are any other UI elements  associated with the same property path as the changed UI element , the client portion also updates (step ) those UI elements  with the changed value and determines (step ) whether any new UI elements  are created as a result of the change.","Upon being informed (step ) by the client portion , the sever portion attempts to update (step ), via the property\/event interface , the value of the property  of the application component  affected by the user change (i.e., the property  at the end of the property path associated with the user-interface element  the user changed). The application  determines (step ) whether to accept the change or to veto the change. If the application  accepts the change, the application  changes the state (e.g., value) of the property  as requested by the server portion and generates a change event. The server portion receives the change event and determines (step ) whether the change corresponds to a property path in which the client portion has interest and acts in response to that determination. In one embodiment, the server portion inhibits sending a change event to the client portion for the changed property , because the client portion originated the change.","If the application  does not accept the change (e.g., vetoes the change), the server portion generates (step ) a special change message to change the value of the property path, as displayed on the UI , back to the original (i.e., pre-user modification) value. The server portion continues by sending (step ) the change message with the original value back to the client portion ","After the tree structure  has been updated (step ), the server portion continues to monitor (step ) the properties corresponding to the tree structure map . If a state (e.g., value) of a property changes, the server portion determines (step ) whether the change corresponds to a property path in which the client portion has interest. If the server portion determines (step ) the changed state of the property does not correspond to a registered property path, the server portion continues to monitor (step ) the states of properties corresponding to the tree structure map . If the server portion determines (step ) the changed state of the property does correspond to a registered property path, the server portion generates and sends (step ) to the client portion a change event for the corresponding property path. The client portion updates (step ) any UI elements  associated with the property path with the changed value.","The property connector API  also can be configured to provide additional features. For one example, if in the system  of  the client node  and\/or page interface  (e.g., browser) is unable to run the client portion or support some or all of the UI elements  required for the specific user-interface , then the property connector API  can generate a proxy process (not shown). The proxy process can execute on the server node , or on another server node \u2032 (not shown) logically located between the client node  and the server node  executing the application . The proxy process acts as a client portion in as far as communications with the server portion , and acts as a standard server process, using an alternative, compatible protocol, to communicate with the client node .","For example, a system \u2032 includes a client node \u2032 that has an older version of a Web browser \u2032 that is unable to support the client process . The proxy process receives the interactive page  and the dynamic changes indicated by the property connector API  and, in real-time, converts the page  and the dynamic changes into a static page \u2032 that is compatible with the older version Web browser \u2032. The converted static page \u2032 includes traditional style links and input boxes to replace the dynamic mouse events and text fields used with the client portion . When the user clicks on a link, the client node \u2032 requests a new page \u2032 from the proxy process. The proxy process interprets this as a click on a portion of the interactive page , and if this results in a change to a state of a property, the proxy process sends the change to the state of the property to the server portion . The proxy process then generates a new static page \u2033 , in real time, to represent the new UI state and sends the new page \u2033 to the client node \u2032.",{"@attributes":{"id":"p-0153","num":"0156"},"figref":"FIG. 8","b":["22","22","270","22","86","90","90","270","274","270","278","34","270","26","26","22","270","26","26","270","22","274","86","282","270","42","112","42","22","22","22","270"],"i":["b\u2032","b\u2032","a","a","b","a","a","b ","a ","a ","b "]},"\u2018Session.PageView=newExtension(\u2018PageView\u2019, \u2018App.Employee[ ]\u2019,)\u2019. With receipt of this command, the server portion initiates execution of the named extension \u2018PageView\u2019 on the server node . In accordance with the parameters of the command, the server portion initializes the extension  with the values \u2018App.Employee[ ]\u2019 and . The extension  registers interest in the App.Employee[ ] property path with the property path manager , and is told of all members of this indexed property, and any changes.","The PageView extension  provides an indexed property Page[i], which is an indexed property of \u2018Page\u2019 objects . Each Page object  in turn provides an indexed property \u2018Item[j]\u2019, which is an indexed property of items on the current page . The PageView extension  allows the App.Employee property to be accessed via a number of pages to , where i is the number of pages. For example the property path \u2018Session.PageView.Page[].Item[]\u2019 is equivalent to property path \u2018App.Employee[]\u2019. The first employee is displayed on the first page. Similarly, the property path \u2018Session.PageView.Page[].Item[]\u2019 is equivalent to the property path \u2018App.Employee[]\u2019 because after the first ten employees (the entered parameter was ten), the next ten employees are displayed on a second page. The PageView extension  also provides other properties such as NoPages, CurrentPage, NextPage, LastPage, and the like, to make it easy to build page based interfaces to applications  that do no themselves support multiple pages to ","Another extension is the \u2018Form\u2019 extension. The form extension provides a means for \u2018batch processing\u2019 of application data. The form extension allows transactional input to an application . For example, a user may fill in a form (not shown) displayed in a UI  and then cancel or submit the filled in form as a whole, instead of piecemeal data. If the server portion is configured with a form extension , the client portion creates a form by a call to Session.newExtension. This command takes two mandatory parameters, \u2018String id\u2019 and \u2018String type\u2019 and one optional parameter \u2018String args\u2019. The \u2018String id\u2019 parameter includes the name of the extension (e.g. \u2018myform\u2019) and is in the format \u2018Session.myform\u2019. The \u2018String type\u2019 parameter includes the type of the extension, which for a form extension, is in the format \u2018Form\u2019. The \u2018String args\u2019 parameter includes an optional argument string. For the form extension, the format is one of \u2018 \u2019 (i.e., null), \u2018snapshot\u2019, \u2018weakchanges\u2019 or \u2018snapshot, weakchanges\u2019. The snapshot and weakchanges modes are described in more detail below.","The form extension  is configured to accept several methods. One method is \u2018submit( )\u2019, which transmits all changed values to the form extension  to update the application . Another method is \u2018refresh( )\u2019, which refreshes all values within the form , including changed ones, to be the same as the corresponding application properties . Another method is \u2018update( )\u2019, which refreshes all of the unchanged values to be the same as the corresponding application properties . The method is useful for unconnected forms. Another method is \u2018clear( )\u2019, which resets all changed values to null. This method is useful for complex forms. Another method is \u2018clear(v)\u2019, which resets all changed values to v.","The call to create a form is usually made in a script type UI element to ensure that the form is initialized before UI elements  using the form are displayed. The form is global and may be used anywhere on the page , not just inside the script UI element .","An exemplary code used to create a form is as follows:",{"@attributes":{"id":"p-0159","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<div widget=\u201cscript\u201d onstart=\u201cinvoke_server"},{"entry":"(this,\u2018Session.newExtension(\\\u2018F\\\u2019,\\\u2018Form\\\u2019)\u2019)\u2033>"},{"entry":"<table>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<tr>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<td><b>Employee<\/b><\/td>"]},{"entry":[{},"<td>b>Salary<\/b><\/td>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/tr>"]},{"entry":[{},"<tbody style=\u2032display:none\u2032widget=\u2032iterator\u2032"]},{"entry":[{},"range=\u2032Session.F.App.Employee[ ]\u2032>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<tr>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<td><span widget=\u2032text\u2032"]},{"entry":[{},"variable=\u2032%itm.Name\u2032>Name<\/span><\/td>"]},{"entry":[{},"<td><input widget=\u2032value\u2032 variable=\u2032%itm.Salary\u2032>\/td>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/tr>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/tbody>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/table>"},{"entry":"<input type=\u2033button\u2033 value=\u2033Clear\u2033 onclick=\u2033invoke_server"},{"entry":"(this,\u2032Session.F.clear(0)\u2032)\u2033>"},{"entry":"<input type=\u2033button\u2033 value=\u2033Reset\u2033 onclick=\u2033invoke_server"},{"entry":"(this,\u2032Session.F.refresh( )\u2032)\u2033>"},{"entry":"<input type=\u2033button\u2033 value=\u2033Submit\u2033 onclick=\u2033invoke_server"},{"entry":"(this,\u2032Session.F.submit( )\u2032)\u2033>"},{"entry":"<\/div>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"When the server portion  is configured with a form extension , the property paths \u2018Session.Form.App.Name\u2019 and \u2018Session.Form.App.Employee[].Salary\u2019 have the same value as the property paths \u2018App.Name\u2019 and \u2018App.Employee[].Salary\u2019. Any change to a property starting \u2018Session.Form\u2019 is recorded in the form extension  and not applied to the application  until the client portion invokes a Session.Form.submit( ) method. In one embodiment, the client portion invokes a \u2018Session.Form.submit( )\u2019 when the user clicks on a UI element button labeled submit. Alternatively, the client portion invokes a Session.Form.cancel( ) method, in which case nothing will change.","The form extension  works by acting as a filter over other properties . For example a form can be identified as \u2018Session.Form\u2019. For example, this form displays values associated with property paths such as \u2018Session.Form.App.Name\u2019,","\u2018Session.Form.App.Employee[].Salary\u2019 and the like. There is no need to define what properties correspond to a form , as the properties  are associated dynamically as they are referred to by UI elements  within the page .","By default, a form is connected and set to preservesChanges. That is, if an application property  changes during the lifetime of the form , the form reflects the change unless the user has already changed the value. This also means that if the page  wishes to display new values in the form , then this will happen automatically (e.g., iterator type UI elements or treeview type UI elements ).","In various embodiments, the form can be set to different modes. In one embodiment, the form may optionally be set to \u2018snapshot\u2019 mode, where it is unconnected and all values will be null until entered by the user or the form is manually refreshed. In another embodiment, the form may also be optionally set to \u2018weakchanges\u2019 mode, where changes to values from the application  will overwrite changes made by the user.","In one embodiment, if an application property  changes that is an ancestor of a property  displayed on the form , and the form is connected or manually updated, then the dependent properties on the form are updated even if the user has changed them. For example, a form displays App.Employee[].Name (=Fred) and App.Employee[].Salary (=100). If the user changes the salary to  (e.g., Fred's salary), and then the application  changes who App.Employee[] is (e.g. to Bill, Salary ), then the form correctly displays App.Employee[].Name =Bill and App.Employee[].Salary=50, discarding the users original, and now invalid, user change. As a consequence, if ancestor properties change as a result of submitting a number of changes in a form , then it is possible that some of the changes are discarded.","In some embodiments, data is not batched and sent to the server node  all at once. For example, the updates can be transmitted to the application sequentially, or in a random order. The application  reacts to the data as if it were entered all at the same time, due to the interaction of the form extension  on the server node .","Equivalents","While the invention has been particularly shown and described with reference to several exemplary embodiments thereof, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention.","For example, although the methods and apparatus of the present invention are described in the context of a Web server and Web client process communicating over the Internet, those skilled in the art will recognize that the present invention also can be practiced in non-Web and\/or non-Internet embodiments. The invention also can be practiced over any other type of network (e.g., telephone, cable, LAN, WAN, wireless, fiber), within the same physical computer system, or with portions of the invention (e.g. the application independent client process) operating in an Internet appliance or cable TV set-top box."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects, features and advantages will occur to those skilled in the art from the following description of a preferred embodiment and the accompanying drawings, in which:",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
