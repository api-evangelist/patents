---
title: Method for adding device information by extending an application programming interface
abstract: A method or apparatus that allows new devices to be easily integrated with computer aided design (CAD) tools via an easily extensible application programming interface (API). In an embodiment, new devices are added by reading a new device type and assigning a sequential index value. Index values are assigned to the new devices by appending a new device type to the end of an enumeration construct. When the data structure is compiled, the new device type is converted to a sequential index value. Data values for the new device are added to a data structure and can be accessed via the index value. Because the added device type is appended to the end of the enumeration construct, the index values assigned to the original data types remain unchanged. Consequently, recompilation is only required for applications that need to access the new devices and is unnecessary for the applications that do not use the new devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08516504&OS=08516504&RS=08516504
owner: Altera Corporation
number: 08516504
owner_city: San Jose
owner_country: US
publication_date: 20030128
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The invention relates in general to software interfaces, and in particular to extending application programming interfaces to include new devices.","Many software and hardware applications use application programming interfaces (APIs) to access other hardware or software applications. APIs can be used to retrieve data or to invoke a specific function from another application. For example, software tools, which are used to develop hardware or software applications, can use an API to access a database of devices or functions available for developing specific applications.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1","b":["100","100","105","110","115","120","100","105","110","115","120"]},"The design modules communicate with a device database  to retrieve device information for the numerous devices available to a designer. Device information includes operating parameters, which define a device, and an API, which enables access to a device's operating parameters and functions. The device information, including the operating parameters and API associated with each device, are stored in data classes in the device database .","When a new device becomes available, the operating parameters and API associated with the new device must be integrated with the CAD tool  before designers can use the device in their designs. Device data files  define device operating parameters and API. A parser  processes the device data files and inserts the device operating parameters and API into an appropriate data class stored in the device database . Header files  contain programming declarations for a device's operating parameters and API. Both the design modules and user applications use the programming declarations in the header files  to identify and access devices. A location class  stores location information for devices. As discussed below, the device data files , the header files , and the location class  must be modified to integrate new devices with the CAD tool .",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2","b":["200","100","210","220","230","135","125","240","250","260"]},"The method  for integrating new devices into the CAD tool  is fraught with complications. Not only do the numerous steps of the method require substantial engineering effort for each device added, each step introduces the possibility of human error. Moreover, device operating parameters and APIs are constantly being added or modified, making device integration a continuous chore.","Recompilation of design modules and user applications is another substantial flaw with this method. Recompilation of complicated design modules and user applications can take many hours to process. Further, the integration of new devices breaks older versions of the design modules and user applications until they are recompiled, even when the design modules and user applications do not use the new devices.","Thus, it is desirable to: 1) minimize the engineering effort needed to integrate new devices with CAD tools; 2) reduce the possibility of human error when adding new devices; and 3) eliminate the need to recompile design modules and user applications when new devices are added.","The invention, generally, is a method or apparatus that allows new devices to be easily integrated with CAD tools via an easily extensible API. In an embodiment, new devices are added by reading a new device type from a file. Each new device type is assigned a sequential index value. Data values associated with the new device are read and added to a data structure used by the CAD tool.","In an embodiment, index values are assigned to the new devices by appending a new device type to the end of an enumeration construct. When the data structure is compiled, the new device type is converted to a sequential index value. Because the added device type is appended to the end of the enumeration construct, the values assigned to the original data types remain unchanged. Applications that depend on previous versions of the original data structure will operate correctly with the modified data structure. This makes recompilation unnecessary for the applications that do not use the new devices. Recompilation is only required for applications that need to access the new devices.","In a further embodiment, a header file is created to declare the data structure with the new device type. Applications using a new device are compiled with the header file. When the applications are compiled, at least one reference to the new device type is converted to a reference to the sequential index value.","In another embodiment, the data structure includes a data vector having a plurality of data elements. The data elements include a data attribute, or alternately a reference to a function. In an alternate embodiment, the data structure includes a conditional branch statement for selecting one of a plurality of actions. An action selected by the conditional branch statement includes returning a data attribute or calling a function.","API functions and device operating parameters are typically arranged into data classes. Data classes are widely used in many different object-oriented programming languages. Traditionally, new functions are added to the class interface to add new functionality, for example API functions or device operating parameters. A new function declaration is also added to a header file to enable access to the new functionality by other data classes or applications. The modified data class, along with any dependent data classes or device operating parameters, are then recompiled.","To avoid the difficulties inherent in constantly modifying data classes, as discussed above, one embodiment of the present invention combines several functions and their associated declarations into a single general function which is easily extensible. Table 1 illustrates a group of function declarations written in the C++ programming language for several functions in an example API.",{"@attributes":{"id":"p-0022","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"int get_apple_id(apple_class* apple);",{}]},{"entry":[{},{},"int get_orange_id(orange_class* orange);",{}]},{"entry":[{},{},"int get_banana_id(banana_class* banana);",{}]},{"entry":[{},{},"float get_apple_count( );",{}]},{"entry":[{},{},"float get_orange_count( );",{}]},{"entry":[{},{},"float get_banana _count( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"In an embodiment, the function declarations can be grouped together according to their type of return value (for example float or integer), the number and type of parameters, or by both characteristics. Table 2 shows the grouping of three of the functions of Table 1 with both the same parameter type (void) and the same return value type (float).",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"float get_apple_count( );",{}]},{"entry":[{},{},"float get_orange_count( );",{}]},{"entry":[{},{},"float get_banana_count( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"All three of the functions in Table 2 can be described generally as \u201cfruit counting functions.\u201d A generic function containing these three functions is declared in Table 3.",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"float get_fruit_count(FRUIT_TYPE fruit);",{}]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The generic function \u201cget_fruit_count\u201d has the member functions \u201cget_apple_count\u201d, \u201cget_orange_count\u201d, and \u201cget_banana_count\u201d. The addition of the function parameter \u201cfruit\u201d selects between these member functions.","An enumeration construct can be used to select the functions. Enumeration constructs are natively supported in many different programming languages, or can be added. An enumeration construct assigns sequential values to each of the elements of a construct. Table 4 illustrates an enumeration construct to be used with the generic function of Table 3.",{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum FRUIT_TYPE",{}]},{"entry":[{},"{",{}]},{"entry":[{},"APPLE,",{}]},{"entry":[{},"ORANGE,",{}]},{"entry":[{},"BANANA",{}]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In the enumeration construct of Table 4, the compiler will automatically assign \u201cAPPLE\u201d a value of \u201c1\u201d, \u201cORANGE\u201d a value of \u201c2\u201d, and \u201cBANANA\u201d a value of \u201c3\u201d. As will be discussed below, this sequential assignment of values is useful in easily extending data class. The values assigned by the compiler will be used by the generic function to select the appropriate member function.","Table 5 illustrates an example implementation of the \u201cget_fruit_count\u201d function of Table 3.",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int get_fruit_count(FRUIT_TYPE fruit)",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003switch(fruit)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003case APPLE:",{}]},{"entry":[{},"\u2003\u2003\u2003return get_apple_count( );",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003\u2003case ORANGE:",{}]},{"entry":[{},"\u2003\u2003\u2003return get_orange_count( );",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003\u2003case BANANA:",{}]},{"entry":[{},"\u2003\u2003\u2003return get_banana count( );",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In this example, a programmer would replace a call to \u201cget_apple_count( )\u201d function with a call to \u201cget_fruit_count(APPLE)\u201d. The enumeration construct that defines the value of the \u201cAPPLE\u201d parameter is included in a header file so that any reference to this parameter is interpreted correctly by the compiler. During compilation, the compiler replaces the parameter \u201cAPPLE\u201d with the appropriate value in both the function call and the function implementation, ensuring that the parameter \u201cAPPLE\u201d selects the appropriate function.","Adding functionality to a class is greatly simplified using this arrangement. First, a new function type is appended to the end of the enumeration. Second, the new function and its function type are added to the generic function. Tables 6 and 7 illustrate adding a function to the API according to an embodiment of the invention.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum FRUIT_TYPE",{}]},{"entry":[{},"{",{}]},{"entry":[{},"APPLE,",{}]},{"entry":[{},"ORANGE,",{}]},{"entry":[{},"BANANA,",{}]},{"entry":[{},"PEACH",{}]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"int get_fruit_count(FRUIT_TYPE fruit)",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003switch(fruit)",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003case APPLE:",{}]},{"entry":[{},{},"\u2003\u2003\u2003return get_apple_count( );",{}]},{"entry":[{},{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},{},"\u2003\u2003case ORANGE:",{}]},{"entry":[{},{},"\u2003\u2003\u2003return get_orange_count( );",{}]},{"entry":[{},{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},{},"\u2003\u2003case BANANA:",{}]},{"entry":[{},{},"\u2003\u2003\u2003return get_banana_count( );",{}]},{"entry":[{},{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},{},"\u2003\u2003case PEACH:",{}]},{"entry":[{},{},"\u2003\u2003\u2003return get_peach_count( );",{}]},{"entry":[{},{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"As discussed above, the compiler automatically assigns sequential values to elements of the enumeration construct. For the example of Tables 6 and 7, the type \u201cPEACH\u201d is assigned a value of \u201c4\u201d. Because the added data type is appended to the end of the enumeration, the values assigned to the original data types (\u201cAPPLE\u201d, \u201cORANGE\u201d, and \u201cBANANA\u201d) remain unchanged. Applications that depend on the original data types will operate correctly with the modified API function. This makes recompilation unnecessary for the applications that do not use the added API functionality. Recompilation is only required for applications that need to access the added API functionality.","In another embodiment, functions with different parameters or return values can be grouped together. For example, Table 8 illustrates three functions with the same type of return value, but with different parameters.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"int get_apple_id(apple_class* apple);",{}]},{"entry":[{},{},"int get_orange_id(orange_class* orange);",{}]},{"entry":[{},{},"int get_banana_id(banana_class* banana);"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"A generic function encompassing these three functions can use a void pointer or other generic data type for its input parameter. Table 9 is one example of a function declaration for this type of generic function. Alternatively, if the data types \u201capple_class\u201d, \u201corange_class\u201d, and \u201cbanana_class\u201d are all derived from a single parent data class, then the generic function can use the parent class as a function parameter. Table 10 illustrates an example of a function declaration using a parent data class. Generic types or parent data classes can also be used for groups of functions with different return value data types.",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int get_fruit_id(void* fruit);",{}]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int get_fruit_id(fruit class* fruit);",{}]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The use of void pointers or other generic data types introduces the possibility of data type mismatch errors. In a further embodiment, the generic function includes type-checking code to ensure the proper data type is used for each function within the broader generic function.","Data classes are frequently modified to include additional member variables. The generic function for these types of modifications can be implemented more efficiently than the example of Table 7. Instead of using a \u201cswitch\u201d statement to select different functions or member variables within the generic functions, member variables are stored in a vector or array. The enumeration construct is then used to define the index in the vector for each member variable. Table 11A illustrates an example implementation of a generic function using a switch statement to select and return a member variable.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11A"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum FRUIT_TYPE",{}]},{"entry":[{},"{",{}]},{"entry":[{},"APPLE,",{}]},{"entry":[{},"ORANGE,",{}]},{"entry":[{},"BANANA",{}]},{"entry":[{},"MAX",{}]},{"entry":[{},"};",{}]},{"entry":[{},"int get_fruit_count_switch(FRUIT_TYPE fruit)",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003int apple_count, orange_count, banana_count;",{}]},{"entry":[{},"\u2003switch(fruit)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003case APPLE:",{}]},{"entry":[{},"\u2003\u2003\u2003return apple_count;",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003\u2003case ORANGE:",{}]},{"entry":[{},"\u2003\u2003\u2003return orange_count;",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003\u2003case BANANA:",{}]},{"entry":[{},"\u2003\u2003\u2003return banana_count;",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table 11B illustrates an example implementation of a generic function using a vector, rather than a switch statement, to select and return a member variable. In this example, a class \u201cFRUIT_DATA\u201d has two methods \u201cget_fruit_count\u201d and \u201cset_fruit_count\u201d. The first method retrieves data from the class, and the second method stores data in the class. Both methods access elements of a private data vector through an index defined by the",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11B"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cFRUIT_TYPE\u201d enumeration.",{}]},{"entry":[{},"enum FRUIT_TYPE",{}]},{"entry":[{},"{",{}]},{"entry":[{},"APPLE,",{}]},{"entry":[{},"ORANGE,",{}]},{"entry":[{},"BANANA",{}]},{"entry":[{},"MAX",{}]},{"entry":[{},"};",{}]},{"entry":[{},"class FRUIT_ DATA",{}]},{"entry":[{},"{",{}]},{"entry":[{},"public:",{}]},{"entry":[{},"\u2003int get_fruit_count(FRUIT_TYPE fruit);",{}]},{"entry":[{},"\u2003void set_fruit_count(FRUIT_TYPE fruit, int count);",{}]},{"entry":[{},"private:",{}]},{"entry":[{},"\u2003int fruit_count[MAX];",{}]},{"entry":[{},"};",{}]},{"entry":[{},"int FRUIT_DATA::get_fruit_count(FRUIT_TYPE fruit)",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003return this->fruit_ count[fruit];",{}]},{"entry":[{},"}",{}]},{"entry":[{},"void FRUIT_DATA::set_fruit_count(FRUIT_TYPE fruit, int count)",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003this->fruit_count[fruit] = count;",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In this example implementation, the variables \u201capple_count\u201d, \u201corange_count\u201d, and \u201cbanana_count\u201d from the \u201cget_fruit_count_switch\u201d function correspond to the elements of the vector \u201cfruit_count[ ]\u201d in the \u201cget_fruit_count_vector\u201d function. The vector implementation can be extended to select member functions in a similar manner.","As discussed above, additional member variables can be added to a data class by modifying the data class and adding new member variables to the end of the enumeration construct. When the data class is modified in this manner, any applications depending on the unmodified data class will operate correctly with the modified data class without the need for recompilation. Recompilation is only required for applications accessing the added member variables or functions of the data class.","In another embodiment, functions with a varying number of parameters can be grouped together into a single generic function. Many programming languages, such as C++, support variable length argument lists for functions. Table 12 illustrates two different functions declarations that can be combined into a generic function.",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int count_apples_in_tree(apple_tree* tree);",{}]},{"entry":[{},"int count_apples_in_grove(list_of_groves* groves, int grove_id);"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"As discussed above, an enumeration construct is used to select between the functions. Table 13 illustrates an example enumeration construct for the functions of Table 12.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum APPLE_COUNTING_MODE",{}]},{"entry":[{},"{",{}]},{"entry":[{},"FROM_TREE,",{}]},{"entry":[{},"FROM_GROVE_IN_LIST_OF_GROVES",{}]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Table 14 illustrates a generic function using the enumeration construct of Table 13 to select one of the functions of Table 12.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int count_apples(APPLE_COUNTING_MODE mode, . . . )",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003va_list ap;",{}]},{"entry":[{},"\u2003va_start(ap, mode);",{}]},{"entry":[{},"\u2003switch(mode)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003case FROM_TREE:",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003\u2003apple_tree* tree = va_arg(ap, apple_tree*);",{}]},{"entry":[{},"\u2003\u2003\u2003\/\/Code to count and parse arguments",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003\u2003case FROM_GROVE_IN_LIST_OF_GROVES:",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003list_of_groves* groves = va_arg(ap, list_of_groves*);",{}]},{"entry":[{},"\u2003\u2003\u2003int grove_id = va_arg(ap, int);",{}]},{"entry":[{},"\u2003\u2003\u2003\/\/Code to count and parse arguments",{}]},{"entry":[{},"\u2003\u2003\u2003break;",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The use of a generic function to select between several member functions allows any API to be easily modified or extended with new functionality. In one embodiment, this programming model is used by a CAD tool to minimize the engineering effort needed to integrate new devices with CAD tools; reduce the possibility of human error when adding new devices; and eliminate the need to recompile design modules and user applications when new devices are added.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 3","b":["300","300","305","310","315","320","300","305","310","315","320"]},"The design modules communicate with a device database  to retrieve device information for the numerous devices available to a designer. Device information includes operating parameters, which define a device, and an API, which enables access a device's operating parameters and functions. The device information, including the operating parameters and API associated with each device, are stored in data classes in the device database .","When a new device becomes available, the operating parameters and API associated with the new device must be integrated with the CAD tool  before designers can use the device in their designs. Device data files  define device operating parameters and APL. In an embodiment, each device data file lists data in the form of attribute\/value pairs. Table 14 illustrates an example of a portion of a device data file. In some applications, device data files may have hundreds of attribute\/value pairs.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Device","Foo",{}]},{"entry":[{},"Number_of_IO","6",{}]},{"entry":[{},"Number_of_PLL","2",{}]},{"entry":[{},"Package_Type","200",{}]},{"entry":[{},"VCC_Power","1.5",{}]},{"entry":[{},"Bar","False",{}]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"A parser  processes the device data files and inserts the device operating parameters and API into a data class stored in the device database . In an embodiment, the parser matches attributes in the device data file with a list of recognized attributes stored in a hash table. The hash table identifies the data class and member variable corresponding with each matching attribute. The corresponding value of the attribute\/value pair is then stored in the appropriate member variable.","Header files  contain programming declarations for a device's operating parameters and API. Both the design modules and user applications use the programming declarations in the header files  to identify and access devices. In an embodiment, an enumeration construct is used to select device attributes or functions, as discussed above. A location class  retrieves location information for devices.","In an embodiment, a family generator  uses the techniques discussed above to integrate new devices with the CAD tool . A device descriptor file  lists all of the available devices. Additionally, the device descriptor file lists the attributes for each device and the data type associated with each attribute. Table 15 illustrates a portion of a device descriptor file corresponding to the device data of Table 14.",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Foo","\u201cFoo\u201d",{}]},{"entry":[{},"Number_of_IO","Integer",{}]},{"entry":[{},"Number_of_PLL","Integer",{}]},{"entry":[{},"Package_Type","Integer",{}]},{"entry":[{},"VCC_Power","Float",{}]},{"entry":[{},"Bar","Boolean"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"As new devices are added to the device descriptor files , the family generator  uses the information from the device descriptor files  to locate device data files for new devices and integrate the new devices with the CAD tool . The family generator  reads all of the attributes associated with the new device from the device descriptor files . The family generator  adds the attribute names to the appropriate enumeration constructs. In an embodiment, each data type is associated with a different enumeration construct. If an attribute introduces a new data type, the family generator modifies the data class to handle the new data type and creates a new enumeration construct.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 4","b":["400","300","405"]},"At step , device operating parameters and APIs for the new device are defined in a device data file. As discussed above, in an embodiment, new device data can be listed in the form of attribute\/value pairs.","At step , the family generator reads the device descriptor file and determines if new devices have been added. For each new device, the family generator reads a corresponding device data file. The family generator compares a list of attribute names stored in the parser hash table with the attributes listed in the device data file for the new device. If the device data file contains new attributes, then the family generator adds the new attribute names to the parser's hash table.","At step , the parser processes the device data file to add the new device attribute values to the data classes. In an embodiment where the member variables of a data class are stored as data vectors, the parser appends the new device values to the end of the data vectors. This ensures that the addition of new device data does not change the location of older device data, and allows applications not using the new device data to continue operating without recompilation. In an embodiment where new device functionality is selected with a \u201cswitch\u201d statement, the family generator modifies the data classes to include \u201ccase\u201d statements for the added functionality.","At step , the family generator modifies the header files to include the added device information. As discussed above, an enumeration construct included in the header files is used to select device attributes or functions. One or more new function types are appended to the end of the enumeration constructs in the header files. New device attributes or functions can be selected from the data class using the added function types. As before, the new data types are added to the end of the enumeration construct so that the compiler-assigned values for the older function types are unchanged, which allows applications not using the new device data to continue operating without recompilation.","At step , the modified data classes and any applications requiring access to new devices are recompiled. The method  for integrating new devices with the CAD tool  has numerous advantages. Applications that do not need access to the new devices do not need to be recompiled. Additionally, only two of the steps of the method  require user effort. The remaining steps are performed automatically by the parser and the family generator. This automation reduces the engineering effort needed to integrate new devices and significantly decreases the possibility of human error.","Another benefit of this system is the addition of a script interface . The script interface  allows external applications or users to access the device database  directly through a scripting language, such as TCL, Perl, or Python. The script interface  can be used to provide engineers and customers with updated device data. Because the addition of new devices does not alter the interface for selecting older devices, the script interface does not have to be modified each time new devices are added.","Those skilled in the art will appreciate that the present invention establishes a method for modifying or extending any type of software interface without the need to recompile other dependent software. The present invention has been described in relation to particular embodiments that are intended in all respects to be illustrative rather than restrictive. Therefore, it should be understood that the method and apparatus of the present invention could be practiced with modification and alteration within the spirit and scope of the claims herein. Furthermore, the invention may be implemented in any combination of hardware and\/or software. Alternative embodiments will become apparent to those skilled in the art to which the present invention pertains without departing from its spirit and scope."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be described with reference to the drawings, in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
