---
title: Visual and scene graph interfaces
abstract: A method and system implemented in an application programming interface (API) and an object model allows program code developers to interface in a consistent manner with a scene graph data structure to output graphics. Via the interfaces, program code writes drawing primitives such as geometry data, image data, animation data and other data to visuals that represent a drawing surface, including validation visual objects, drawing visual objects and surface visual objects. The code can also specify transform, clipping and opacity properties on visuals, and add child visuals to other visuals to build up a hierarchical scene graph. A visual manager traverses the scene graph to provide rich graphics data to lower-level graphics components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07466315&OS=07466315&RS=07466315
owner: Microsoft Corporation
number: 07466315
owner_city: Redmond
owner_country: US
publication_date: 20031023
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention is a continuation-in-part of U.S. patent application Ser. No. 10\/402,268 filed Mar. 27, 2003.","The invention relates generally to computer systems, and more particularly to the processing of graphical and other video information for display on computer systems.","The limits of the traditional immediate mode model of accessing graphics on computer systems are being reached, in part because memory and bus speeds have not kept up with the advancements in main processors and\/or graphics processors. In general, the current (e.g., WM_PAINT) model for preparing a frame requires too much data processing to keep up with the hardware refresh rate when complex graphics effects are desired. As a result, when complex graphics effects are attempted with conventional graphics models, instead of completing the changes that result in the perceived visual effects in time for the next frame, the changes may be added over different frames, causing results that are visually and noticeably undesirable.","A new model for controlling graphics output is described in U.S. patent application Ser. Nos. 10\/184,795, 10\/184,796, 10\/185,775, 10\/401,717, 10\/402,322 and 10\/402,268, assigned to the assignee of the present invention and hereby incorporated by reference. This new model provides a number of significant improvements in graphics processing technology. For example, U.S. Ser. No. 10\/184,795 is generally directed towards a multiple-level graphics processing system and method, in which a higher-level component (e.g., of an operating system) performs computationally intensive aspects of building a scene graph, updating animation parameters and traversing the scene graph's data structures, at a relatively low operating rate, in order to pass simplified data structures and\/or graphics commands to a low-level component. Because the high-level processing greatly simplifies the data, the low-level component can operate at a faster rate, (relative to the high-level component), such as a rate that corresponds to the frame refresh rate of the graphics subsystem, to process the data into constant output data for the graphics subsystem. When animation is used, instead of having to redraw an entire scene with changes, the low-level processing may interpolate parameter intervals as necessary to obtain instantaneous values that when rendered provide a slightly changed scene for each frame, providing smooth animation.","U.S. Ser. No. 10\/184,796 describes a parameterized scene graph that provides mutable (animated) values and parameterized graph containers such that program code that wants to draw graphics (e.g., an application program or operating system component) can selectively change certain aspects of the scene graph description, while leaving other aspects intact. The program code can also reuse already-built portions of the scene graph, with possibly different parameters. As can be appreciated, the ability to easily change the appearance of displayed items via parameterization and\/or the reuse of existing parts of a scene graph provide substantial gains in overall graphics processing efficiency.","U.S. Ser. No. 10\/185,775 generally describes a caching data structure and related mechanisms for storing visual information via objects and data in a scene graph. The data structure is generally associated with mechanisms that intelligently control how the visual information therein is populated and used. For example, unless specifically requested by the application program, most of the information stored in the data structure has no external reference to it, which enables this information to be optimized or otherwise processed. As can be appreciated, this provides efficiency and conservation of resources, e.g., the data in the cache data structure can be processed into a different format that is more compact and\/or reduces the need for subsequent, repeated processing, such as a bitmap or other post-processing result.","While the above improvements provide substantial benefits in graphics processing technology, there still needs to be a way for programs to effectively use this improved graphics model and its other related improvements in a straightforward manner. What is needed is a comprehensive yet straightforward model for programs to take advantage of the many features and graphics processing capabilities provided by the improved graphics model and thereby output complex graphics and audiovisual data in an efficient manner.","Briefly, the present invention provides an object model, and an application programming interface (API) for accessing that object model in a manner that allows program code developers to consistently interface with a scene graph data structure to produce graphics. A base object in the model and API set is a visual, which represents a virtual surface to the user; the scene graph is built of visual objects. Such Visuals include container visual objects, retained visual objects, drawing visual objects and other visual objects. Visuals themselves can hold onto resource objects, such as clip objects, transform objects and so forth, and some type of Visuals (e.g., DrawingVisual, RetainedVisual) can hold on to drawing instruction lists that may reference resource objects, such as images, brushes and\/or gradients.","Most resource objects in the scene graph are immutable once created, that is, once they are created they cannot be changed. For those objects that a developer wants to easily change, mutability is provided by a changeables pattern and implementation, as described in copending U.S. patent application entitled \u201cChangeable Class and Pattern to Provide Selective Mutability in Computer Programming Environments\u201d filed concurrently herewith, assigned to the assignee of the present invention and herein incorporated by reference.","Via the application programming interfaces, program code writes drawing primitives such as geometry data, image data, animation data and other data to the visuals. For example, program code writes drawing primitives such as draw line instructions, draw geometry instructions, draw bitmap instructions and so forth into the visuals. Those drawing instructions are often combined with complex data like geometry data that describes how a path is drawn, and they also may reference resources like bitmaps, videos, and so forth.","The code can also specify clipping, opacity and other properties on visuals, and methods for pushing and popping transform, opacity and hit test identification are provided. In addition, the visual may participate in hit testing. The program code also interfaces with the visuals to add child visuals, and thereby build up a hierarchical scene graph. A visual manager processes (e.g., traverses or transmits) the scene graph to provide rich graphics data to lower-level graphics components.","Container visuals provide for a collection of children visuals and in one implementation, are the only visuals that can define hierarchy. The collection of children on a container visual allows for arbitrary insertion, removal and reordering of children visuals.","Drawing visuals are opened with an open call that returns a drawing context (e.g., a reference to a drawing context object) to the caller. In general, a drawing context is a temporary helper object that is used to populate a visual. The program code then uses the drawing context to add drawing primitives to the visual. The open call may clear the contents (children) of a visual, or an append call may be used to open a visual for appending to that current visual. In addition to receiving static values as drawing parameters, drawing contexts can be filled with animation objects.","A retained visual operates in a similar manner to a drawing visual, except that its drawing context is filled when the system requests that it be filled, instead of when the program code wants to fill it. For example, if a particular Visual's content will be needed in rendering a scene, the system will call IRetainedVisual.Render to fill the content of the Visual, replacing any content already in memory.","Thus, different types of primitives may be drawn into a visual using a drawing context, including geometry, image data and video data. Geometry is a type of class that defines a vector graphics skeleton without stroke or fill, e.g., a rectangle. Each geometry object corresponds to a simple shape (LineGeometry, EllipseGeometry, RectangleGeometry), a complex single shape (PathGeometry), or a list of such shapes (GeometryList) with a combine operation specified (e.g., union, intersection and so forth.) These objects form a class hierarchy. There are also shortcuts for drawing frequently used types of geometry, such as a DrawRectangle method.","When geometry is drawn, a brush or pen may be specified. A brush object defines how to graphically fill a plane, and there is a class hierarchy of brush objects. A pen also has a brush specified on it describing how to fill the stroked area. A special type of brush object (the VisualBrush) can reference a visual to define how that brush is to be drawn. A drawing brush makes it possible to fill a shape or control with combinations of other shapes and brushes.","Other benefits and advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, tablet devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, Accelerated Graphics Port (AGP) bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules  and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a tablet (electronic digitizer) , a microphone , a keyboard  and pointing device , commonly referred to as mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . The monitor  may also be integrated with a touch-screen panel  or the like that can input digitized input such as handwriting into the computer system  via an interface, such as a touch-screen interface . Note that the monitor and\/or touch screen panel can be physically coupled to a housing in which the computing device  is incorporated, such as in a tablet-type personal computer, wherein the touch screen panel  essentially serves as the tablet . In addition, computers such as the computing device  may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface  or the like.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Interfaces to Scene Graph Data Structures","One aspect of the present invention is generally directed to allowing program code, such as an application or operating system component, to communicate drawing instructions and other information (e.g., image bitmaps) to graphics components in order to render graphical output on the system display. To this end, the present invention provides a number of defined functions and methods, e.g., in the form of application programming interfaces (APIs) to an object model, that enable programs to populate a scene graph with data structures, drawing primitives (commands), and other graphics-related data. When processed, the scene graph results in graphics being displayed on the screen.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","204","206","212","204","202","206","206","208","210","212","206","208","210"]},"In one implementation, the graphics layer architecture  includes a high-level composition and animation engine , which includes or is otherwise associated with a caching data structure . The caching data structure  contains a scene graph comprising hierarchically-arranged objects that are managed according to a defined object model, as described below. In general, the visual API layer  provides the program code  (and the layout system ) with an interface to the caching data structure , including the ability to create objects, open and close objects to provide data to them, and so forth. In other words, the high-level composition and animation engine  exposes a unified media API layer  by which developers may express intentions about graphics and media to display graphics information, and provide an underlying platform with enough information such that the platform can optimize the use of the hardware for the program code. For example, the underlying platform will be responsible for caching, resource negotiation and media integration.","In one implementation, the high-level composition and animation engine  passes an instruction stream and possibly other data (e.g., pointers to bitmaps) to a fast, low-level compositing and animation engine . As used herein, the terms \u201chigh-level\u201d and \u201clow-level\u201d are similar to those used in other computing scenarios, wherein in general, the lower a software component is relative to higher components, the closer that component is to the hardware. Thus, for example, graphics information sent from the high-level composition and animation engine  may be received at the low-level compositing and animation engine , where the information is used to send graphics data to the graphics subsystem including the hardware .","The high-level composition and animation engine  in conjunction with the program code  builds a scene graph to represent a graphics scene provided by the program code . For example, each item to be drawn may be loaded with drawing instructions, which the system can cache in the scene graph data structure . As will be described below, there are a number of various ways to specify this data structure , and what is drawn. Further, the high-level composition and animation engine  integrates with timing and animation systems  to provide declarative (or other) animation control (e.g., animation intervals) and timing control. Note that the animation system allows animate values to be passed essentially anywhere in the system, including, for example, at the element property level , inside of the visual API layer , and in any of the other resources. The timing system is exposed at the element and visual levels.","The low-level compositing and animation engine  manages the composing, animating and rendering of the scene, which is then provided to the graphics subsystem . The low-level engine  composes the renderings for the scenes of multiple applications, and with rendering components, implements the actual rendering of graphics to the screen. Note, however, that at times it may be necessary and\/or advantageous for some of the rendering to happen at higher levels. For example, while the lower layers service requests from multiple applications, the higher layers are instantiated on a per-application basis, whereby is possible via the imaging mechanisms  to perform time-consuming or application-specific rendering at higher levels, and pass references to a bitmap to the lower layers.","In accordance with an aspect of the present invention, a Visual application programming interface (API) provides a set of objects that define the visual tree in accordance with an aspect of the present invention. The visual tree represents a data structure that can be rendered by the graphics system to a medium (a screen, printer or surface). When rendered, the data in the visual tree is the \u201cscene\u201d a viewer sees. Visual objects (or simply Visuals) contain and manage the other graphical objects that make up a drawn scene like geometries, primitives, brushes, color gradients, and animations.","Although the present invention also provides access to drawing and rendering services at a higher level of abstraction using a more familiar object and property system, and provides vector graphics objects at the markup level through markup language (code-named \u201cXAML\u201d), the Visual API will be of most interest to developers who want greater control over drawing functionality than they can easily achieve using the property system or markup.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIGS. 3 and 4","FIG. 5"],"b":["300","400"]},"A DrawingVisual is a Visual that can contain graphical content. This Visual exposes a number of drawing methods. The child objects of a DrawingVisual are organized in a zero-based, z-order space. A RetainedVisual is A Visual that introduces a \u201cretained instruction stream\u201d that can be used for drawing. In simpler terms, the RetainedVisual allows the developer to retain the visual's content and redraw it only when necessary. It is possible to use the RetainedVisual imperatively, like a DrawingVisual, by calling RenderOpen and using the returned DrawingContext for drawing. The RetainedVisual provides validation callback functionality and an InvalidateVisual method. To use validation functionality, the user implements the IRetainedRender interface on the RetainedVisual or a class that derives from it.","Returning to , yet another visual is an HwndVisual , which is a Visual used to host a legacy Microsoft\u00ae Win32\u00ae control or window as a child visual inside a visual scene of a scene graph. More particularly, legacy programs will still operate via the WM_PAINT method (or the like) that draws to a child HWnd (or the like) based on prior graphics technology. To support such programs in the new graphics processing model, the HwndVisual allows the Hwnd to be contained in a scene graph and moved as the parent visual is repositioned. Other types of visuals are also feasible, such as three-dimensional (3D) visuals which enable a connection between two-dimensional and three dimensional worlds, e.g., a camera-like view is possible via a two-dimensional visual having a view into a three-dimensional world.","As shown in , a VisualManager  comprises an object that connects a visual tree to a medium. The VisualManager establishes a retained connection between the visual data structure (the root visual ) and the target to which that data is rendered, offering the possibility of tracking differences between the two. The VisualManager  receives window messages and provides methods for transforming a point in drawing coordinates to device coordinates and vice versa.","A typical application might draw graphics by defining a layout in \u201cXAML\u201d as described in the aforementioned U.S. patent application Ser. No. 10\/401,717, and also by specifying some drawing operations in C#. Developers may create Shape elements, or draw geometries using the Geometry classes with primitives. In the following scenario, the code demonstrates drawing an ellipse in the Visual that underlies the Canvas:",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"private void CreateAndShowMainWindow (\u2009)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mainWindow = new MSAvalon.Windows.Window (\u2009);"]},{"entry":[{},"Canvas myCanvas = new Canvas(\u2009);"]},{"entry":[{},"mainWindow.Children.Add(myCanvas);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ellipse e1 = new Ellipse(\u2009);"]},{"entry":[{},"e1.Fill = Brushes.Blue;"]},{"entry":[{},"e1.Stroke = Brushes.Black;"]},{"entry":[{},"e1.StrokeThickness = new Length(10);"]},{"entry":[{},"e1.CenterX = new Length(100);"]},{"entry":[{},"e1.CenterY = new Length(75);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"e1.RadiusX = new Length(50);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"e1.RadiusY = new Length(50);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"myCanvas.Children.Add(e1);"]},{"entry":[{},"mainWindow.Show(\u2009);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Using the Visual API, developers can instead draw directly into the Visual (that would otherwise be accessed via by the layout element).","To render the content of a DrawingVisual object, an application typically calls the RenderOpen method on the DrawingVisual. RenderOpen returns a DrawingContext with which the application can perform drawing operations. To clear the Visual's contents, the application calls Close on the DrawingContext. After the application calls Close, the DrawingContext can no longer be used.","The following code draws an ellipse (the same ellipse as in the previous example) into a DrawingVisual, using a Geometry object rather than the Ellipse shape. The example creates a DrawingVisual, gets the DrawingVisual's DrawingContext, and calls the DrawingContext's DrawGeometry method to draw the ellipse. Note that you must add the Visual to the visual tree of the top-level object, which in this case is the window.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mainWindow = new MSAvalon.Windows.Window(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mainWindow.Show(\u2009);"]},{"entry":[{},"DrawingVisual myDrawingVisual = new"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DrawingVisual(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DrawingContext myDrawingContext ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myDrawingVisual.RenderOpen(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SolidColorBrush mySolidColorBrush\u2003= new"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SolidColorBrush(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mySolidColorBrush.Color = Colors.Blue;"]},{"entry":[{},"Pen myPen = new Pen(Brushes.Black, 10);"]},{"entry":[{},"EllipseGeometry aGeometry = new EllipseGeometry(new"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Point(100,75), 50, 50);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myDrawingContext.DrawGeometry(mySolidColorBrush,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myPen, aGeometry);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"myDrawingContext.Close(\u2009);"]},{"entry":[{},"((IVisual)mainWindow).Children.Add(myDrawingVisual)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following example further builds on the previous example by adding similar ellipses to a ContainerVisual; note that this example is verbose for clarity). Using ContainerVisual can help organize scene objects and allow the developer to segregate Visual objects on which to perform hit-testing or validation (RetainedVisual objects) from ordinary drawn content, and minimize unnecessary redrawing of content.",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mainWindow = new MSAvalon.Windows.Window(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mainWindow.Show(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/Create some Visuals"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ContainerVisual myContainer = new ContainerVisual(\u2009);"]},{"entry":[{},"DrawingVisual myDrawingVisual = new DrawingVisual(\u2009);"]},{"entry":[{},"DrawingVisual myDrawingVisual_1 = new DrawingVisual(\u2009);"]},{"entry":[{},"DrawingVisual myDrawingVisual_2 = new DrawingVisual(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/Perform some drawing"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"DrawingContext myDrawingContext ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"myDrawingVisual.RenderOpen(\u2009);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SolidColorBrush mySolidColorBrush = new SolidColorBrush(\u2009);"]},{"entry":[{},"mySolidColorBrush.Color = Colors.Violet;"]},{"entry":[{},"Pen myPen = new Pen(Brushes.Black, 10);"]},{"entry":[{},"EllipseGeometry aGeometry = new EllipseGeometry(new"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Point(100,75), 50, 50);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myDrawingContext.DrawGeometry(mySolidColorBrush, myPen,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"aGeometry);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"myDrawingContext.Close(\u2009);"]},{"entry":[{},"DrawingContext myDrawingContext_1 ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"myDrawingVisual_1.RenderOpen(\u2009);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mySolidColorBrush.Color = Colors.Red;"]},{"entry":[{},"Pen myPen1 = new Pen(Brushes.Orange, 10);"]},{"entry":[{},"EllipseGeometry aGeometry1 = new EllipseGeometry(new"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Point(100,175), 50, 50);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myDrawingContext_1.DrawGeometry(mySolidColorBrush, myPen1,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"aGeometry1);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"myDrawingContext_1.Close(\u2009);"]},{"entry":[{},"DrawingContext myDrawingContext_2 ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"myDrawingVisual_2.RenderOpen(\u2009);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mySolidColorBrush.Color = Colors.Yellow;"]},{"entry":[{},"Pen myPen2 = new Pen(Brushes.Blue, 10);"]},{"entry":[{},"EllipseGeometry aGeometry2 = new EllipseGeometry(new"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Point(100,275), 50, 50);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myDrawingContext_2.DrawGeometry(mySolidColorBrush, myPen2,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"aGeometry2);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"myDrawingContext_2.Close(\u2009);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/Add DrawingVisuals to the ContainerVisual's VisualCollection"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"myContainer.Children.Add(myDrawingVisual);"]},{"entry":[{},"myContainer.Children.Add(myDrawingVisual_1);"]},{"entry":[{},"myContainer.Children.Add(myDrawingVisual_2);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/Add the ContainerVisual to the window"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"((IVisual)mainWindow).Children.Add(myContainer);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A RetainedVisual is similar to a DrawingVisual, but allows for selective redrawing of visual content. As its name suggests, the RetainedVisual can retain content for multiple appearances on the medium. It also provides callback and validation functionality. This functionality can help with rendering performance by offering the developer greater control over re-rendering of content.","At a basic level, the user can create and use a RetainedVisual much like a DrawingVisual; that is, the user can call RenderOpen and get a DrawingContext. Alternatively, the user can implement the IRetainedRender interface on a RetainedVisual. By doing so, users ensure that the graphics system will use the value set in the RenderBounds property as the bounds for the content to be rendered at the IRetainedVisual.Render call.","When rendering the scene, the graphics system will examine any child Visual. If the value of the RenderBounds property indicates that a particular Visual's content will be needed in rendering a scene, the system will call IRetainedVisual.Render to fill the content of the Visual, replacing any content already in memory. The application can also call InvalidateVisual directly to flush content from a Visual. If the application has not implemented IRetainedRender on the RetainedVisual, any call to InvalidateVisual will throw an exception.","The following code instantiates a class that implements IRetainedRender on a RetainedVisual and draws into it.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public class Rectangle : RetainedVisual, IRetainedRender"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public Rectangle(Color color, Rect rect) :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"base(\u2009)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"m_color = color;"]},{"entry":[{},"m_rect = rect;"]},{"entry":[{},"RenderBounds = rect;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public void SetColor(Color color)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"m_color = color;"]},{"entry":[{},"InvalidateVisual(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public void Render(DrawingContext ctx)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ctx.DrawRectangle("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new SolidColorBrush(m_color),"]},{"entry":[{},"null,"]},{"entry":[{},"m_rect);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The Visual API, like the rest of the graphics system of the present invention, is a managed API and makes use of typical features of managed code, including strong typing and garbage collection. It also takes advantage of the hardware acceleration capability for rendering. To accommodate developers working with existing unmanaged applications, the Visual API provides limited interoperability between the present graphics system and Microsoft Windows\u00ae Graphics Device Interface (GDI)-based rendering services.","This interoperability allows developers to host GDI-based windows in Visual-aware applications using the Hwnd Visual object, write controls and theming that are based on the present invention's drawing and rendering, but still work in legacy GDI applications, and Modify GDI HWND-based applications to take advantage of the new rendering features, including hardware acceleration and the color model.","The HwndVisual enables hosting of Win32 content in a Visual-aware application. As represented in , HwndVisual inherits from ContainerVisual. Note that it is not possible to mix GDI and the new drawing models in the same HwndVisual. Instead, this visual might be more useful for legacy controls of limited scope. The following example demonstrates creating a control in an HwndVisual and adding it to the visual tree.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/Import Win32 resources and define variables for a control."]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"\/\/Create the control."]},{"entry":[{},"hwndControl = CreateWindowEx("]},{"entry":[{},"0,"]},{"entry":[{},"WC_TREEVIEW,"]},{"entry":[{},"\u201c \u201d,"]},{"entry":[{},"WS_CHILD | WS_VISIBLE | TVS_HASLINES |"]},{"entry":[{},"TVS_LINESATROOT |"]},{"entry":[{},"TVS_HASBUTTONS,"]},{"entry":[{},"x,"]},{"entry":[{},"y,"]},{"entry":[{},"cx,"]},{"entry":[{},"cy,"]},{"entry":[{},"hwndParent,"]},{"entry":[{},"IntPtr.Zero,"]},{"entry":[{},"IntPtr.Zero,"]},{"entry":[{},"0);"]},{"entry":[{},"\/\/Create an HwndVisual for the control and add it to a"]},{"entry":[{},"previously-defined"]},{"entry":[{},"\/\/collection."]},{"entry":[{},"s_visual1 = HwndVisual.GetHwndVisual(hwndControl);"]},{"entry":[{},"s_visual1.Size = new Size(150, 150);"]},{"entry":[{},"s_visual1.IsHwndDpiAware = false;"]},{"entry":[{},"s_visual0.Children.Add(s_visual1);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As with other objects, you can apply transforms and other property changes to the control once hosted in a Visual.",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TransformCollection t = new TransformCollection(\u2009);"]},{"entry":[{},"t.AddScale(1.4, 1.4);"]},{"entry":[{},"t.AddTranslate(130, 80);"]},{"entry":[{},"s_visual0.Children.SetTransform(s_visual1, t);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As represented in , a top-level (or root) Visual  is connected to a Visual manager object , which also has a relationship (e.g., via a handle) with a window (HWnd)  or similar unit in which graphic data is output for the program code. The VisualManager  manages the drawing of the top-level Visual (and any children of that Visual) to that window .  shows the VisualManager as one of a set of objects  in the object model of the graphics system described herein.","To draw, the Visual manager  processes (e.g., traverses or transmits) the scene graph as scheduled by a dispatcher , and provides graphics instructions and other data to the low level component  () for its corresponding window , such as generally described in the aforementioned U.S. patent applications. The scene graph processing will ordinarily be scheduled by the dispatcher  at a rate that is relatively slower than the refresh rate of the lower-level component  and\/or graphics subsystem .",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 3","FIG. 5"],"b":["310","314","302","316","317","318","319"]},"Visuals offer services by providing clip, opacity and possibly other properties that can be set, and\/or read via a get method. In addition, the visual has flags controlling how it participates in hit testing. A Show property is used to show\/hide the visual, e.g., when false the visual is invisible, otherwise the visual is visible. Furthermore, these objects (whether Visuals at the Visual API layer or elements at the element layer) exist in a hierarchy. A coordinate system is inherited down through this hierarchy. In this way, a parent can push a coordinate transform that modifies the rendering pass and gets applied to that parent's children.","The transform for a visual is on the connection to that visual. In other words, it is set via the [Get|Set]ChildTransform on the parent's IVisual interface.","Note that the coordinate transforms may be applied in a uniform way to everything, as if it were in a bitmap. Note that this does not mean that transformations always apply to bitmaps, but that what gets rendered is affected by transforms equally. By way of example, if the user draws a circle with a round pen that is one inch wide and then applies a scale in the X direction of two to that circle, the pen will be two inches wide at the left and right and only one inch wide at the top and bottom. This is sometimes referred to as a compositing or bitmap transform (as opposed to a skeleton or geometry scale that affects the geometry only).  is a representation of scaling transformation, with a non-transformed image  appearing on the left and a transformed image  with a non-uniform scale appearing on the right.  is a representation of scaling transformation, with the non-transformed image  appearing on the left and a transformed image  with geometry scaling appearing on the right.","With respect to coordinate transformation of a visual, TransformToDescendant transforms a point from the reference visual to a descendant visual. The point is transformed from the post-transformation coordinate space of the reference visual to the post-transformation coordinate space of the descendant visual. TransformFromDescendant transforms a point from the descendant visual up the parent chain to the reference visual. The point is transformed from post-transformation coordinate space of the descendant visual to post-transformation coordinate space of the reference visual. A user may get a Matrix to and from a descendant and from and to any arbitrary visual. Two properties are available that may be used to determine the bounding box of the content of the Visual, namely DescendantBounds, which is the bounding box of the descendants, and ContentBounds which is the bounds of the content. Applying a Union to these provides the total bounds.","The clip property sets (and gets) the clipping region of a visual. Any Geometry (the geometry class is shown in ) can be used as a clipping region, and the clipping region is applied in Post-Transformation coordinate space. In one implementation, a default setting for the clipping region is null, i.e., no clipping, which can be thought of as an infinite big clipping rectangle from (\u2212\u221e, \u2212\u221e) to (+\u221e, +\u221e).","The Opacity property gets\/sets the opacity value of the visual, such that the content of the visual is blended on the drawing surface based on the opacity value and the selected blending mode. The BlendMode property can be used to set (or get) the blending mode that is used. For example, an opacity (alpha) value may be set between 0.0 and 1.0, with linear alpha blending set as the mode, e.g., Color=alpha*foreground color+(1.0-alpha)*background color). Other services, such as special effects properties, may be included in a visual, e.g., blur, monochrome, and so on.","The various services (including transform, opacity, and clip) can be pushed and popped on a drawing context, and push\/pop operations can be nested, as long as there is an appropriate pop call for each push call.","The PushTransform method pushes a transformation. Subsequent drawing operations are executed with respect to the pushed transformation. The pop call pops the transformation pushed by the matching PushTransform call:",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void PushTransform(Transform transform);"]},{"entry":[{},"void PushTransform(Matrix matrix);"]},{"entry":[{},"void Pop( );."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Similarly, the PushOpacity method pushes an opacity value. Subsequent drawing operations are rendered on a temporary surface with the specified opacity value and then composite into the scene. Pop( ) pops the opacity pushed by the matching PushOpacity call:",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void PushOpacity(float opacity);"]},{"entry":[{},"void PushOpacity(FloatAnimation opacity);"]},{"entry":[{},"void Pop( );."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The PushClip method pushes a clipping geometry. Subsequent drawing operations are clipped to the geometry. The clipping is applied in post transformation space. Pop( ) pops the clipping region pushed by the matching PushClip call:",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void PushClip(Geometry clip);"]},{"entry":[{},"void Pop( );."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note that push operations can be arbitrarily nested as long as the pop operations are matched with a push. For example, the following is valid:",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PushTransform (. . .) ;"]},{"entry":[{},"DrawLine (. . .) ;"]},{"entry":[{},"PushClip (. . .) ;"]},{"entry":[{},"DrawLine (. . .) ;"]},{"entry":[{},"Pop (\u2009) ;"]},{"entry":[{},"PushTransform (. . .) ;"]},{"entry":[{},"DrawRect (. . .) ;"]},{"entry":[{},"Pop (\u2009) ;"]},{"entry":[{},"Pop (\u2009) ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A ProxyVisual is a visual that may be added more than once into the scene graph, e.g., below a container visual. Since any visual referred to by a ProxyVisual may be reached by multiple paths from the root, read services (TransformToDescendent, TransformFromDescendent and HitTest) do not work through a ProxyVisual. In essence, there is one canonical path from any visual to the root of the visual tree and that path does not include any ProxyVisuals.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 4","b":"400"},"As described above, visuals can be drawn on by populating their drawing contexts with various drawing primitives, including Geometry, ImageSource and MediaData. Furthermore, there are a set of resources and classes that are shared through this entire stack. This includes Pens, Brushes, Geometry, Transforms and Effects. The DrawingContext abstract class exposes a set of drawing operations that can be used to populate a DrawingVisual, ValidationVisual, ImageData, etc. In other words, the drawing context abstract class exposes a set of drawing operations; for each drawing operation there are two methods, one that takes constants as arguments, and one that takes animators as arguments.","Geometry is a type of class () that defines a vector graphics skeleton, without stroke or fill. Each geometry object is a simple shape (LineGeometry, EllipseGeometry, RectangleGeometry), a complex single shape (PathGeometry) or a list of such shapes GeometryCollection with a combine operation (e.g., union, intersection, and so forth) specified. These objects form a class hierarchy as represented in .","As represented in , the PathGeometry is a collection of Figure objects. In turn, each of the Figure objects is composed of one or more Segment objects which actually define the figure's shape. A Figure is a sub-section of a Geometry that defines a segment collection. This segment collection is a single connected series of two-dimensional Segment objects. The Figure can be either a closed shape with a defined area, or just a connected series of Segments that define a curve, but no enclosed area.","As represented in , when geometry (e.g., a rectangle) is drawn, a brush or pen can be specified, as described below. Furthermore, the pen object also has a brush object. A brush object defines how to graphically fill a plane, and there is a class hierarchy of brush objects. This is represented in  by the filled rectangle  that results when the visual including the rectangle and brush instructions and parameters is processed. A Pen object holds onto a Brush along with properties for Width, LineJoin, LineCap, MiterLimit, DashArray and DashOffset, as described below. As also described below, some types of Brushes (such as gradients and nine grids) size themselves. When used, the size for these brushes is obtained from the bounding box, e.g., when the GradientUnits\/DestinationUnits for the Brush is set to RelativeToBoundingBox, the bounding box of the primitive that is being drawn is used. If those properties are set to Absolute, then the coordinate space is used.","The graphics object model of the present invention includes a Brush object model, which is generally directed towards the concept of covering a plane with pixels. Examples of types of brushes are represented in the hierarchy of FIG. , and, under a Brush base class, include Gradient Brush, NineGridBrush, SolidColorBrush and TileBrush. GradientBrush includes LinearGradient and RadialGradient objects. DrawingBrush and ImageBrush derive from TileBrush. Alternative arrangements of the classes are feasible, e.g., deriving from TileBrush may be ImageBrush, VisualBrush, VideoBrush, NineGridBrush and Drawing Brush. Note that Brush objects may recognize how they relate to the coordinate system when they are used, and\/or how they relate to the bounding box of the shape on which they are used. In general, information such as size may be inferred from the object on which the brush is drawn. More particularly, many of the brush types use a coordinate system for specifying some of their parameters. This coordinate system can either be defined as relative to the simple bounding box of the shape to which the brush is applied, or it can be relative to the coordinate space that is active at the time that the brush is used. These are known, respectively, as RelativeToBoundingBox mode and Absolute mode.","A SolidColorBrush object fills the identified plane with a solid color. If there is an alpha component of the color, it is combined in a multiplicative way with the corresponding opacity attribute in the Brush base class. The following sets forth an example SolidColorBrush object:",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public sealed class System.Windows.Media.SolidColorBrush : Brush"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructors"]},{"entry":[{},"public SolidColorBrush(\u2009); \/\/ initialize to black"]},{"entry":[{},"public SolidColorBrush(Color color);"]},{"entry":[{},"public SolidColorBrush"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(System.Windows.Media.Animation.ColorComposer"]},{"entry":[{},"colorComposer);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Properties"]},{"entry":[{},"public Color Color { get; }"]},{"entry":[{},"public IEnumerator ColorAnimations { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class System.Windows.Media.SolidColorBrushBuilder :"},{"entry":"BrushBuilder"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructors"]},{"entry":[{},"public SolidColorBrushBuilder(\u2009);"]},{"entry":[{},"public SolidColorBrushBuilder(Color color);"]},{"entry":[{},"public SolidColorBrushBuilder(SolidColorBrush scp);"]},{"entry":[{},"\/\/ Properties"]},{"entry":[{},"public Color Color { get; set; }"]},{"entry":[{},"public AnimationList ColorAnimations { get; }"]},{"entry":[{},"\/\/ Methods"]},{"entry":[{},"public virtual Brush ToBrush(\u2009);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The GradientBrush objects, or simply gradients, provide a gradient fill, and are drawn by specifying a set of gradient stops, which specify the colors along some sort of progression. The gradient is by drawn by performing linear interpolations between the gradient stops in a gamma 2.2 RGB color space; interpolation through other gammas or other color spaces (HSB, CMYK and so forth, is also a feasible alternative. Two types of gradient objects include linear and radial gradients.","In general, gradients are composed of a list of gradient stops. Each of these gradient stops contains a color (with the included alpha value) and an offset. If there are no gradient stops specified, the brush is drawn as a solid transparent black, as if there were no brush specified at all. If there is only one gradient stop specified, the brush is drawn as a solid color with the one color specified. Like other resource classes, the gradient stop class (example in the table below) is derives from the changeable class and thus is selectively mutable, as described in the U.S. patent application entitled \u201cChangeable Class and Pattern to Provide Selective Mutability in Computer Programming Environments.\u201d","Gradients are drawn by specifying a set of gradient stops. These gradient stops specify the colors along some sort of progression. There are two types of gradients presently supported, namely linear and radial gradients. The gradient is drawn by doing interpolations between the gradient stops in the specified color space.","Gradients are composed of a list of gradient stops. Each of these gradient stops contains a color (with the included alpha value) and an offset. If there are no gradient stops specified, the brush is drawn as transparent (as if there were no brush specified). If there is only one gradient stop specified, the brush is drawn as a solid color with the one color specified. Any gradient stops with offsets in the range of zero to one (0.0 . . . 1.0) are considered, with the largest stop in the range (\u2212\u221e. . . 0.0] and the smallest stop in the range [1.0 . . . +\u221e). If the set of stops being considered includes a stop which is outside of the range zero to one, an implicit stop is derived at zero (and\/or one) which represents the interpolated color which would occur at this stop. Also, if two or more stops are set at the same offset, a hard transition (rather than interpolated) occurs at that offset. The order in which stops are added determines the behavior at this offset; the first stop to be added is the effective color before that offset, the last stop to be set is the effective color after this stop, and any additional stops at this offset are ignored.","This class is a Changeable like other resource classes:",{"@attributes":{"id":"p-0111","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public sealed class System.Windows.Media.GradientStop : Changeable"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public GradientStop(\u2009);\u2003public GradientStop(Color color, double"]},{"entry":[{},"offset);"]},{"entry":[{},"public GradientStop(Color color, ColorAnimationCollection"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"colorAnimations,"]},{"entry":[{},"double offset, DoubleAnimationCollection offsetAnimations);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public new GradientStop Copy(\u2009); \/\/ hides Changeable.Copy(\u2009)"]},{"entry":[{},"\/\/ Default is transparent"]},{"entry":[{},"[Animation(\u201cColorAnimations\u201d)]"]},{"entry":[{},"public Color Color { get; set; }"]},{"entry":[{},"public ColorAnimationCollection ColorAnimations { get; set; }"]},{"entry":[{},"\/\/ Default is 0"]},{"entry":[{},"[Animation(\u201cOffsetAnimations\u201d)]"]},{"entry":[{},"public double Offset { get; set; }"]},{"entry":[{},"public DoubleAnimationCollection OffsetAnimations { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Like SolidColorBrush, this has nested Changeables in the animation collections.","The GradientSpreadMethod enum specifies how the gradient should be drawn outside of the specified vector or space. There are three possible values, including Pad, in which the end colors (first and last) are used to fill the remaining space, Reflect, in which the stops are replayed in reverse order repeatedly to fill the space, and Repeat, in which the stops are repeated in order until the space is filled. The default value for properties of this type is Pad:",{"@attributes":{"id":"p-0114","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Media.GradientSpreadMethod"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pad,"]},{"entry":[{},"Reflect,"]},{"entry":[{},"Repeat"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIGS. 14 and 15"},"In general, a LinearGradientBrush is used to fill an area with a linear gradient. A linear gradient defines a gradient along a line. The line's end point is defined by the linear gradient's StartPoint and EndPoint properties. By default, the StartPoint of a linear gradient is (0,0), the upper-left corner of the area being filled, and its EndPoint is (1,1), the bottom-right corner of the area being filled. As represented in , using the default values, the colors in the resulting gradient are interpolated along a diagonal path. The black line formed from the start and end points of the gradient has been added herein to highlight the gradient's interpolation path.","The ColorInterpolationMode enum defines the interpolation mode for colors within a gradient. The two options are PhysicallyLinearGamma10 and PerceptuallyLinearGamma22.",{"@attributes":{"id":"p-0118","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum ColorInterpolationMode"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Colors are interpolated in Gamma 1.0 space"]},{"entry":[{},"PhysicallyLinearGamma10,"]},{"entry":[{},"\/\/ Colors are interpolated in Gamma 2.2 space"]},{"entry":[{},"PerceptuallyLinearGamma22"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"This is an abstract base class.",{"@attributes":{"id":"p-0120","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public abstract class System.Windows.Media.GradientBrush : Brush"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal GradientBrush(\u2009);"]},{"entry":[{},"public new GradientBrush Copy(\u2009);\/\/ hides Changeable.Copy(\u2009)"]},{"entry":[{},"\/\/ Default is \u201cPerceptuallyLinearGamma22\u201d"]},{"entry":[{},"public ColorInterpolationMode ColorInterpolationMode { get; set; }"]},{"entry":[{},"\/\/ Default is RelativeToBoundingBox"]},{"entry":[{},"public BrushMappingMode MappingMode { get; set; }"]},{"entry":[{},"\/\/ Default is Pad"]},{"entry":[{},"public GradientSpreadMethod SpreadMethod { get; set; }"]},{"entry":[{},"\/\/ Gradient Stops"]},{"entry":[{},"public void AddStop(Color color, double offset);"]},{"entry":[{},"public GradientStopCollection GradientStops { get; set; }"]},{"entry":[{},"\/\/ ColorInterpolationMode"]},{"entry":[{},"public ColorInterpolationMode ColorInterpolationMode { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As described above in the Changeables section, GradientBrush is a complex-type with respect to Changeables, because its GradientStops property itself holds Changeables. That means that GradientBrush needs to implement the protected methods MakeUnchangeableCore( ), and PropagateEventHandler( ), as well as CloneCore( ) that Changeable subclasses implement. It may also choose to implement ValidateObjectState( ) if there are invalid combinations of GradientStops that make up the collection, for instance.","The LinearGradient specifies a linear gradient brush along a vector. The individual stops specify colors stops along that vector.",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed class System.Windows.Media.LinearGradient :"]},{"entry":[{},"GradientBrush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public LinearGradient (\u2009);\u2003\/\/ initializes to transparent"]},{"entry":[{},"\/\/ Sets up a gradient with two colors and a gradient"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"vector"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ specified to fill the object the gradient is applied"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ This implies RelativeToBoundingBox for the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"GradientUnits"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ property"]},{"entry":[{},"public LinearGradient(Color color1, Color color2, double"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"angle);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public LinearGradient(Color color1, Color color2,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Point vectorStart, Point vectorEnd);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public new LinearGradient Copy(\u2009);\u2003\/\/ hides"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Changeable.Copy(\u2009)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Gradient Vector Start Point"]},{"entry":[{},"\/\/ Default is 0,0"]},{"entry":[{},"[Animation(\u201cStartPointAnimations\u201d)]"]},{"entry":[{},"public Point StartPoint { get; set; }"]},{"entry":[{},"public PointAnimationCollection StartPointAnimations {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"get; set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is 1,1"]},{"entry":[{},"[Animation(\u201cEndPointAnimations\u201d)]"]},{"entry":[{},"public Point EndPoint { get; set; }"]},{"entry":[{},"public PointAnimationCollection EndPointAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"set; }"]},{"entry":[{},"}"]},{"entry":[{},"linear-gradient-brush:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cHorizontalGradient\u201d comma-wsp color comma-wsp color |"]},{"entry":[{},"\u201cVerticalGradient\u201d comma-wsp color comma-wsp color |"]},{"entry":[{},"\u201cLinearGradient\u201d comma-wsp coordinate-pair comma-wsp"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"color comma-wsp color"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The markup for LinearGradient allows specification of a LinearGradient with two color stops, at offsets zero and one. If the \u201cLinearGradient\u201d version is used, the start point and end point are specified, respectively. If \u201cHorizontalGradient\u2019 is used, the start point is set to 0,0 and the end point is set to 1,0. If \u201cVerticalGradient\u201d is used, the start point is set to 0,0 and the end point is set to 0,1. In these cases, the default MappingMode is used, which is RelativeToBoundingBox. The RadialGradient is similar in programming model to the linear gradient. However, whereas the linear gradient has a start and end point to define the gradient vector, the radial gradient has a circle along with a focal point to define the gradient behavior. The circle defines the end point of the gradient\u2014in other words, a gradient stop at 1.0 defines the color at the circle's circumference. The focal point defines center of the gradient. A gradient stop at 0.0 defines the color at the focal point.  represents a RadialGradient that (in grayscale) goes from white to grey. The outside circle represents the gradient circle while the solid dot denotes the focal point. This gradient has SpreadMethod set to Pad.",{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed class System.Windows.Media.RadialGradient :"]},{"entry":[{},"GradientBrush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public RadialGradient(\u2009);\u2003\/\/ initialize to transparent"]},{"entry":[{},"\/\/ Sets up a gradient with two colors."]},{"entry":[{},"\/\/ This implies RelativeToBoundingBox for the"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"GradientUnits"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ property along with a center at (0.5,0.5)"]},{"entry":[{},"\/\/ a radius of 0.5 and a focal point at (0.5,0.5)"]},{"entry":[{},"public RadialGradient(Color color1, Color color2);"]},{"entry":[{},"public new RadialGradient Copy (\u2009);\u2003\/\/ hides"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Changeable.Copy (\u2009)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is 0.5,0.5"]},{"entry":[{},"[Animation(\u201cCenterAnimations\u201d)]"]},{"entry":[{},"public Point Center { get; set; }"]},{"entry":[{},"public PointAnimationCollection CenterAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is 0.5"]},{"entry":[{},"[Animation(\u201cRadiusXAnimations\u201d)]"]},{"entry":[{},"public double RadiusX { get; set;}"]},{"entry":[{},"public DoubleAnimationCollection RadiusXAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is 0.5"]},{"entry":[{},"[Animation(\u201cRadiusYAnimations\u201d)]"]},{"entry":[{},"public double RadiusY { get; set; }"]},{"entry":[{},"public DoubleAnimationCollection RadiusYAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is 0.5,0.5"]},{"entry":[{},"[Animation(\u201cFocusAnimations\u201d)]"]},{"entry":[{},"public Point Focus { get; set; }"]},{"entry":[{},"public PointAnimationCollection FocusAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"set; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The markup for RadialGradient allows specification of a RadialGradient with two color stops, at offsets 0 and 1 respectively. The default MappingMode is used, which is RelativeToBoundingBox, as are the default radii, 0.5:",{"@attributes":{"id":"p-0127","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"radial-gradient-brush:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cRadialGradient\u201d comma-wsp color comma-wsp color"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The TileBrush is an abstract base class which contains logic to describe a tile and a means by which that tile should fill an area. Subclasses of TileBrush contain content, and logically define a way to fill an infinite plane.","The Stretch enum is used to describe how a ViewBox (source coordinate space) is mapped to a ViewPort (destination coordinate space). This is used in TileBrush:",{"@attributes":{"id":"p-0130","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Stretch"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Preserve original size"]},{"entry":[{},"None,"]},{"entry":[{},"\/\/ Aspect ratio is not preserved, ViewBox fills ViewPort"]},{"entry":[{},"Fill,"]},{"entry":[{},"\/\/ Aspect ratio is preserved, VewBox is uniformly scaled"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"as large as"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ possible such that both width and height fit within"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ViewPort"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Uniform,"]},{"entry":[{},"\/\/ Aspect ratio is preserved, VewBox is uniformly scaled"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"as small as"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ possible such that the entire ViewPort is filled by"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"the ViewBox"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UniformToFill"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0131","num":"0130"},"figref":"FIG. 18"},"The TileMode enum is used to describe if and how a space is filled by Tiles. A TileBrush defines where the base Tile is (specified by the ViewPort). The rest of the space is filled based on the TileMode value.",{"@attributes":{"id":"p-0133","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Media.TileMode"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Do not tile - only the base tile is drawn, the remaining"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"area is"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ left as transparent"]},{"entry":[{},"None,"]},{"entry":[{},"\/\/ The basic tile mode - the base tile is drawn and the"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"remaining area"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ is filled by repeating the base tile such that the right"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"edge of one"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ tile butts the left edge of the next, and similarly for"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bottom and top"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Tile,"]},{"entry":[{},"\/\/ The same as tile, but alternate columns of tiles are"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"flipped"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ horizontally. The base tile is drawn untransformed."]},{"entry":[{},"FlipX,"]},{"entry":[{},"\/\/ The same as tile, but alternate rows of tiles are"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"flipped vertically"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ The base tile is drawn untransformed."]},{"entry":[{},"FlipY,"]},{"entry":[{},"\/\/ The combination of FlipX and FlipY. The base tile is"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"drawn"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ untransformed"]},{"entry":[{},"FlipXY"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 19"},"The VerticalAlignment enum is used to describe how content is positioned within a container vertically:",{"@attributes":{"id":"p-0136","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.VerticalAlignment"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Align contents towards the top of a space"]},{"entry":[{},"Top,"]},{"entry":[{},"\/\/ Center contents vertically"]},{"entry":[{},"Center,"]},{"entry":[{},"\/\/ Align contents towards the bottom of a space"]},{"entry":[{},"Bottom,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The HorizontalAlignment enum is used to describe how content is positioned within a container horizontally.",{"@attributes":{"id":"p-0138","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.HorizontalAlignment"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Align contents towards the left of a space"]},{"entry":[{},"Left,"]},{"entry":[{},"\/\/ Center contents horizontally"]},{"entry":[{},"Center,"]},{"entry":[{},"\/\/ Align contents towards the right of a space"]},{"entry":[{},"Right,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The TileBrush properties select a rectangular portion of the infinite plane to be a tile (the ViewBox) and describe a destination rectangle (ViewPort) which will be the base Tile in the area being filled. The remaining destination area will be filled based on the TileMode property, which controls if and how the original tile is replicated to fill the remaining space:",{"@attributes":{"id":"p-0140","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public abstract class System.Windows.Media.TileBrush : Brush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public new TileBrush Copy (\u2009);\u2003\/\/ hides Brush.Copy (\u2009)"]},{"entry":[{},"\/\/ Default is RelativeToBoundingBox"]},{"entry":[{},"public BrushMappingMode ViewPortUnits { get; set; }"]},{"entry":[{},"\/\/ Default is RelativeToBoundingBox"]},{"entry":[{},"public BrushMappingMode ContentUnits { get; set; }"]},{"entry":[{},"\/\/ Default is Rect.Empty"]},{"entry":[{},"[Animation(\u201cViewBoxAnimations\u201d)]"]},{"entry":[{},"public Rect ViewBox { get; set; }"]},{"entry":[{},"public RectAnimationCollection ViewBoxAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is Fill"]},{"entry":[{},"public Stretch Stretch { get; set; }"]},{"entry":[{},"\/\/ Default is None"]},{"entry":[{},"public TileMode TileMode { get; set; }"]},{"entry":[{},"\/\/ Default is Center"]},{"entry":[{},"public HorizontalAlignment HorizontalAlignment { get; set;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is Center"]},{"entry":[{},"public VerticalAlignment VerticalAlignment { get; set; }"]},{"entry":[{},"\/\/ Default is 0,0,1,1"]},{"entry":[{},"[Animation(\u201cViewPortAnimations\u201d)]"]},{"entry":[{},"public Rect ViewPort { get; set; }"]},{"entry":[{},"public RectAnimationCollection ViewPortAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"set; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A TileBrush's contents have no intrinsic bounds, and effectively describe an infinite plane. These contents exist in their own coordinate space, and the space which is being filled by the TileBrush is the local coordinate space at the time of application. The content space is mapped into the local space based on the ViewBox, ViewPort, Alignments and Stretch properties. The ViewBox is specified in content space, and this rectangle is mapped into the ViewPort rectangle.","The ViewPort defines the location where the contents will eventually be drawn, creating the base tile for this Brush. If the value of ViewPortUnits is Absolute, the value of ViewPort is considered to be in local space at the time of application. If, instead, the value of ViewPortUnits is RelativeToBoundingBox, then the value of ViewPort is considered to be in the coordinate space where 0,0 is the top\/left corner of the bounding box of the object being painted and 1,1 is the bottom\/right corner of the same box. For example, consider a RectangleGeometry being filled which is drawn from 100,100 to 200,200. Then, if the ViewPortUnits is Absolute, a ViewPort of (100,100,100,100) would describe the entire content area. If the ViewPortUnits is RelativeToBoundingBox, a ViewPort of (0,0,1,1) would describe the entire content area. If the ViewPort's Size is empty and the Stretch is not None, this Brush renders nothing.","The ViewBox is specified in content space. This rectangle is transformed to fit within the ViewPort as determined by the Alignment properties and the Stretch property. If the Stretch is None, then no scaling is applied to the contents. If the Stretch is Fill, then the ViewBox is scaled independently in both X and Y to be the same size as the ViewPort. If the Stretch is Uniform or UniformToFill, the logic is similar but the X and Y dimensions are scaled uniformly, preserving the aspect ratio of the contents. If the Stretch is Uniform, the ViewBox is scaled to have the more constrained dimension equal to the ViewPort's size. If the Stretch is UniformToFill, the ViewBox is scaled to have the less constrained dimension equal to the ViewPort's size. Another way to think of this is that both Uniform and UniformToFill preserve aspect ratio, but Uniform ensures that the entire ViewBox is within the ViewPort (potentially leaving portions of the ViewPort uncovered by the ViewBox), and UniformToFill ensures that the entire ViewPort is filled by the ViewBox (potentially causing portions of the ViewBox to be outside the ViewPort). If the ViewBox's area is empty, then no Stretch will apply. Alignment will still occur, and it will position the \u201cpoint\u201d ViewBox.","Once the ViewPort is determined (based on ViewPortUnits) and the ViewBox's destination size is determined (based on Stretch), the ViewBox needs to be positioned within the ViewPort. If the ViewBox is the same size as the ViewPort (if Stretch is Fill, or if it just happens to occur with one of the other three Stretch values), then the ViewBox is positioned at the Origin so as to be identical to the ViewPort. If not, then HorizontalAlignment and VerticalAlignment are considered. Based on these properties, the ViewBox is aligned in both X and Y dimensions. If the HorizontalAlignment is Left, then the left edge of the ViewBox will be positioned at the Left edge of the ViewPort. If it is Center, then the center of the ViewBox will be positioned at the center of the ViewPort, and if Right, then the right edges will meet. The process is repeated for the Y dimension.","If the ViewBox is Empty it is considered unset. If it is unset, then ContentUnits are considered. If the ContentUnits are Absolute, no scaling or offset occurs, and the contents are drawn into the ViewPort with no transform. If the ContentUnits are RelativeToBoundingBox, then the content origin is aligned with the ViewPort Origin, and the contents are scaled by the object's bounding box's width and height.","When filling a space with a TileBrush, the contents are mapped into the ViewPort as above, and clipped to the ViewPort. This forms the base tile for the fill, and the remainder of the space is filled based on the Brush's TileMode. If set, the Brush's transform is applied, which occurs after the other mapping, scaling, offsetting, and so forth.","A VisualBrush is a TileBrush whose contents are specified by a Visual. This Brush can be used to create complex patterns, or it can be used to draw additional copies of the contents of other parts of the scene.",{"@attributes":{"id":"p-0148","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed class System.Windows.Media.VisualBrush :"]},{"entry":[{},"TileBrush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public VisualBrush(\u2009);\u2003\/\/ initializes to transparent"]},{"entry":[{},"public VisualBrush(Visual v);"]},{"entry":[{},"public new VisualBrush Copy(\u2009);\u2003\/\/ hides TileBrush.Copy(\u2009)"]},{"entry":[{},"\/\/ Visual - Default is null (transparent Brush)"]},{"entry":[{},"public Visual Visual { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"ImageBrush is a TileBrush having contents specified by an ImageData. This Brush can be used to fill a space with an Image.",{"@attributes":{"id":"p-0150","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed class System.Windows.Media.ImageBrush :"]},{"entry":[{},"TileBrush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public ImageBrush(\u2009);\u2003\/\/ Initializes to transparent"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"contents"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Sets the image, sets ViewBox to (0,0,Width,Height)"]},{"entry":[{},"\/\/ and Stretch to Fill"]},{"entry":[{},"public ImageBrush(ImageData image);"]},{"entry":[{},"public new ImageBrush Copy(\u2009);\u2003\/\/ hides TileBrush.Copy(\u2009)"]},{"entry":[{},"\/\/ Default is null"]},{"entry":[{},"public ImageData ImageData { get; set; }"]},{"entry":[{},"\/\/ Default is true"]},{"entry":[{},"\/\/ If this is true, the ViewBox property will be"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"overridden"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ and effectively set to the native size of the Image"]},{"entry":[{},"public bool SizeViewBoxToContent { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"VideoBrush is a TileBrush having contents specified by a VideoData. This Brush can be used to fill a space with a Video.",{"@attributes":{"id":"p-0152","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed class System.Windows.Media.VideoBrush :"]},{"entry":[{},"TileBrush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public VideoBrush(\u2009);\u2003\/\/ Initializes to transparent"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"contents"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Sets the image, sets ViewBox to (0,0,Width,Height) and"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Stretch to Fill"]},{"entry":[{},"public VideoBrush(VideoData video);"]},{"entry":[{},"public new VideoBrush Copy(\u2009);\u2003\/\/ hides TileBrush.Copy(\u2009)"]},{"entry":[{},"\/\/ Default is null"]},{"entry":[{},"public VideoData VideoData { get; set; }"]},{"entry":[{},"\/\/ Default is true"]},{"entry":[{},"\/\/ If this is true, the ViewBox property will be"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"overridden"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ and effectively set to the native size of the Video"]},{"entry":[{},"public bool SizeViewBoxToContent { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"NineGridBrush is a Brush which always fills the object bounding box with its content image, and the image stretch isn't accomplished purely via a visual scale. The Image source is divided into nine rectangles by four borders (hence the name NineGrid). The contents of the image in each of those nine regions are scaled in 0, 1 or 2 dimensions until they fill the object bounding box. The dimensions in which each section is scaled can be seen in this diagram:  represents the concept of a NineGrid, being enlarged from a first instance  to a second instance , with four types of showing the nine grids which are defined by the Top, Left, Bottom and Right borders. The arrows in each grid square show the dimension(s) in which those contents will be stretched to meet the ViewPort size.","In addition to the nine grid regions pictured above, there is an optional \u201ctenth\u201d grid. This takes the form of an additional image which is centered in the ViewPort and which is not scaled. This can be used to place a shape in the center of a button, etc. This \u201ctenth grid\u201d is called a glyph, and is exposed by the GlyphImageData property:",{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed class System.Windows.Media.NineGridBrush : Brush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public NineGridBrush(ImageData imageData,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int LeftBorder,"]},{"entry":[{},"int RightBorder,"]},{"entry":[{},"int TopBorder,"]},{"entry":[{},"int BottomBorder) ;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public NineGridBrush(ImageData imageData,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int LeftBorder,"]},{"entry":[{},"int RightBorder,"]},{"entry":[{},"int TopBorder,"]},{"entry":[{},"int BottomBorder,"]},{"entry":[{},"ImageData glyphImage);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public new NineGridBrush Copy(\u2009);\u2003\/\/ hides Brush.Copy(\u2009)"]},{"entry":[{},"\/\/ Default is null"]},{"entry":[{},"public ImageData ImageData { get; set; }"]},{"entry":[{},"\/\/ Default is 0"]},{"entry":[{},"public int LeftBorder { get; set; }"]},{"entry":[{},"\/\/ Default is 0"]},{"entry":[{},"public int RightBorder { get; set; }"]},{"entry":[{},"\/\/ Default is 0"]},{"entry":[{},"public int TopBorder { get; set; }"]},{"entry":[{},"\/\/ Default is 0"]},{"entry":[{},"public int BottomBorder { get; set; }"]},{"entry":[{},"\/\/ Default is null"]},{"entry":[{},"public ImageData GlyphImageData { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Note that the border members count in from the edge of the image in image pixels","The Pen is an object that takes a Brush and other parameters that describe how to stroke a space\/Geometry. Conceptually, a Pen describes how to create a stroke area from a Geometry. A new region is created which is based on the edges of the Geometry, the Pen's Thickness, the PenLineJoin, PenLineCap, and so forth. Once this region is created, it is filled with the Brush.",{"@attributes":{"id":"p-0158","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed class System.Windows.Media.Pen : Changeable"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructors"]},{"entry":[{},"Public Pen(\u2009);"]},{"entry":[{},"public Pen(Brush brush, double thickness);"]},{"entry":[{},"public new Pen Copy(\u2009);\u2003\/\/ hides Changeable.Copy(\u2009)"]},{"entry":[{},"\/\/ Properties"]},{"entry":[{},"\/\/ Default is DashArrays.Solid (no dashes)"]},{"entry":[{},"public DoubleCollection DashArray { get; set;}"]},{"entry":[{},"\/\/ Default is 0"]},{"entry":[{},"[Animations(DashOffsetAnimations)]"]},{"entry":[{},"public double DashOffset { get; set;}"]},{"entry":[{},"public DoubleAnimationCollection DashOffsetAnimations {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"get; set;}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Default is Flat"]},{"entry":[{},"public PenLineCap StartLineCap { get; set;}"]},{"entry":[{},"\/\/ Default is Flat"]},{"entry":[{},"public PenLineCap EndLineCap { get; set;}"]},{"entry":[{},"\/\/ Default is Flat"]},{"entry":[{},"public PenDashCap DashCap { get; set;}"]},{"entry":[{},"\/\/ Default is Miter"]},{"entry":[{},"public PenLineJoin LineJoin { get; set;}"]},{"entry":[{},"\/\/ Default is 10"]},{"entry":[{},"public double MiterLimit { get; set;}"]},{"entry":[{},"\/\/ Default is null"]},{"entry":[{},"public Brush Brush { get; set;}"]},{"entry":[{},"\/\/ Default is 1.0"]},{"entry":[{},"[Animations(ThicknessAnimations)]"]},{"entry":[{},"public double Thickness { get; set;}"]},{"entry":[{},"public DoubleAnimationCollection ThicknessAnimations {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"get; set;}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The PenLineCap determines how the ends of a stroked line are drawn:",{"@attributes":{"id":"p-0160","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Media.PenLineCap"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ This is effectively no line cap - the line is squared"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"off"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ at the last point in the line"]},{"entry":[{},"Flat,"]},{"entry":[{},"\/\/ The line is capped by a hemi-circle of diameter equal"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ the line width"]},{"entry":[{},"Round,"]},{"entry":[{},"\/\/ The dash is capped by a triangle"]},{"entry":[{},"Triangle,"]},{"entry":[{},"\/\/ The line is capped with a square of side with equal to"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ line width, centered on the end point"]},{"entry":[{},"Square"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The PenDashCap determines how the ends of each dash in a dashed, stroked line are drawn:",{"@attributes":{"id":"p-0162","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Media.PenDashCap"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ This is effectively no dash cap - the line is squared"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"off"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ at the last point in the line"]},{"entry":[{},"Flat,"]},{"entry":[{},"\/\/ The dash is capped by a hemi-circle of diameter equal"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ the line width"]},{"entry":[{},"Round,"]},{"entry":[{},"\/\/ The dash is capped by a triangle"]},{"entry":[{},"Triangle"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The PenLineJoin determines how joints are draw when stroking a line:",{"@attributes":{"id":"p-0164","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Media.PenLineJoin"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ A sharp corner is created at the intersection of the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"outer"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ edges of the intersecting line segments"]},{"entry":[{},"Miter,"]},{"entry":[{},"\/\/ Similar to Miter, but the corner is rounded"]},{"entry":[{},"Round,"]},{"entry":[{},"\/\/ A beveled join, this produces a diagonal corner"]},{"entry":[{},"Bevel"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The DashArrays class comprises static properties which provide access to common, well-known dash styles:",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public sealed System.Windows.Media.DashArrays"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ A solid Dash array (no dashes)"]},{"entry":[{},"public static DoubleCollection Solid { get; }"]},{"entry":[{},"\/\/ Dash - 3 on, 1 off"]},{"entry":[{},"public static DoubleCollection Dash { get; }"]},{"entry":[{},"\/\/ Dot - 1 on, 1 off"]},{"entry":[{},"public static DoubleCollection Dot { get; }"]},{"entry":[{},"\/\/ DashDot - 3 on, 1 off, 1 on, 1 off"]},{"entry":[{},"public static DoubleCollection DashDot { get; }"]},{"entry":[{},"\/\/ DashDotDot - 3 on, 1 off, 1 on, 1 off, 1 on, 1 off"]},{"entry":[{},"public static DoubleCollection DashDotDot { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Another brush object represented in  is a VisualBrush object. A VisualBrush is a TileBrush whose contents are specified by a Visual. This Brush can be used to create complex patterns, or it can be used to draw additional copies of the contents of other parts of the scene.",{"@attributes":{"id":"p-0168","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002public sealed class System.Windows.Media.VisualBrush :"]},{"entry":[{},"TileBrush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public VisualBrush(\u2009);\u2003\/\/ initializes to transparent"]},{"entry":[{},"public VisualBrush(Visual v);"]},{"entry":[{},"public new VisualBrush Copy(\u2009);\u2003\/\/ hides TileBrush.Copy(\u2009)"]},{"entry":[{},"\/\/ Visual - Default is null (transparent Brush)"]},{"entry":[{},"public Visual Visual { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Conceptually, the VisualBrush provides a way to have a visual drawn in a repeated, tiled fashion as a fill. This is represented in  by the visual brush referencing a visual (and any child visuals) that specifies a single circular shape , with that circular shape filling a rectangle . Thus, the VisualBrush object may reference a visual to define how that brush is to be drawn, which introduces a type of multiple use for visuals. In this manner, a program may use an arbitrary graphics \u201cmetafile\u201d to fill an area via a brush or pen. Since this is a compressed form for storing and using arbitrary graphics, it serves a graphics resource.","In one implementation, a VisualBrush's contents have no intrinsic bounds, and effectively describe an infinite plane. These contents exist in their own coordinate space, and the space which is being filled by the VisualBrush is the local coordinate space at the time of application. The content space is mapped into the local space based on the ViewBox, ViewPort, Alignments and Stretch properties. The ViewBox is specified in content space, and this rectangle is mapped into the ViewPort (as specified via the Origin and Size properties) rectangle.","The ViewPort defines the location where the contents will eventually be drawn, creating the base tile for this Brush. If the value of DestinationUnits is UserSpaceOnUse, the Origin and Size properties are considered to be in local space at the time of application. If instead the value of DestinationUnits is ObjectBoundingBox, then an Origin and Size are considered to be in the coordinate space, where 0,0 is the top\/left corner of the bounding box of the object being brushed, and 1,1 is the bottom\/right corner of the same box. For example, consider a RectangleGeometry being filled which is drawn from 100,100 to 200,200. In such an example, if the DestinationUnits is UserSpaceOnUse, an Origin of 100,100 and a Size of 100,100 would describe the entire content area. If the DestinationUnits is ObjectBoundingBox, an Origin of 0,0 and a Size of 1,1 would describe the entire content area. If the Size is empty, this Brush renders nothing.","The ViewBox is specified in content space. This rectangle is transformed to fit within the ViewPort as determined by the Alignment properties and the Stretch property. If the Stretch is none, then no scaling is applied to the contents. If the Stretch is Fill, then the ViewBox is scaled independently in both X and Y to be the same size as the ViewPort. If the Stretch is Uniform or UniformToFill, the logic is similar but the X and Y dimensions are scaled uniformly, preserving the aspect ratio of the contents. If the Stretch is Uniform, the ViewBox is scaled to have the more constrained dimension equal to the ViewPort's size. If the Stretch is UniformToFill, the ViewBox is scaled to have the less constrained dimension equal to the ViewPort's size. In other words, both Uniform and UniformToFill preserve aspect ratio, but Uniform ensures that the entire ViewBox is within the ViewPort (potentially leaving portions of the ViewPort uncovered by the ViewBox), and UniformToFill ensures that the entire ViewPort is filled by the ViewBox (potentially causing portions of the ViewBox to be outside the ViewPort). If the ViewBox is empty, then no Stretch will apply. Note that alignment will still occur, and it will position the \u201cpoint\u201d ViewBox.",{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIG. 18","b":["1800","1800","1802","1804","1806"]},"Once the ViewPort is determined (based on DestinationUnits) and the ViewBox's size is determined (based on Stretch), the ViewBox needs to be positioned within the ViewPort. If the ViewBox is the same size as the ViewPort (if Stretch is Fill, or if it just happens to occur with one of the other three Stretch values), then the ViewBox is positioned at the Origin so as to be identical to the ViewPort. Otherwise, HorizontalAlignment and VerticalAlignment are considered. Based on these properties, the ViewBox is aligned in both X and Y dimensions. If the HorizontalAlignment is Left, then the left edge of the ViewBox will be positioned at the Left edge of the ViewPort. If it is Center, then the center of the ViewBox will be positioned at the center of the ViewPort, and if Right, then the right edges will meet. The process is repeated for the Y dimension.","If the ViewBox is (0,0,0,0), it is considered unset, whereby ContentUnits are considered. If the ContentUnits are UserSpaceOnUse, no scaling or offset occurs, and the contents are drawn into the ViewPort with no transform. If the ContentUnits are ObjectBoundingBox, then the content origin is aligned with the ViewPort Origin, and the contents are scale by the object's bounding box's width and height.","When filling a space with a VisualBrush, the contents are mapped into the ViewPort as above, and clipped to the ViewPort. This forms the base tile for the fill, and the remainder of the space is filled based on the Brush's TileMode. Finally, if set, the Brush's transform is applied\u2014it occurs after all the other mapping, scaling, offsetting, etc.","The TileMode enumeration is used to describe if and how a space is filled by its Brush. A Brush which can be tiled has a tile rectangle defined, and this tile has a base location within the space being filled. The rest of the space is filled based on the TileMode value.  provides a representation of example graphics with various TileMode settings, including \u201cNone\u201d , \u201cTile\u201d , \u201cFlipX\u201d , \u201cFlipY\u201d  and \u201cFlipXY\u201d . The top left-most tile in the various example graphics comprises the base tile.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":["FIG. 20","FIG. 21"]},"Returning to , image brush derives from tile brush and thus can be tiled. NineGridBrush is very similar to ImageBrush except the image is warped based on the size. In essence, NineGridBrush may be thought of a custom type of Stretch, in which certain parts of the image stretch, while others (e.g., borders) do not. Thus, while the Size of the image in the ImageBrush will cause a simple scale, the NineGridBrush will produce a non-uniform scale up to the desired size. The units for the non-scaled areas are the user units when the brush is applied, which means that ContentUnits (if it existed for NineGridBrush) would be set to UserUnitsOnUse. The Transform property of the Brush can be used effectively. Note that the border members count in from the edge of the image.","As generally described above, the graphics object model of the present invention includes a Transform object model, which includes the types of transforms represented in the hierarchy of , under a Transform base class. These different types of components that make up a transform may include TransformList, TranslateTransform, RotateTransform, ScaleTransform, SkewTransform, and MatrixTransform. Individual properties can be animated, e.g., a program developer can animate the Angle property of a RotateTransform.","Matrices for 2D computations are represented as a 3\u00d73 matrix. For the needed transforms, only six values are needed instead of a full 3\u00d73 matrix. These are named and defined as follows.",{"@attributes":{"id":"p-0182","num":"0181"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"00"}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"01"}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"10"}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"11"}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"20"}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"21"}},{"mn":"1"}]}]}}}}}},"When a matrix is multiplied with a point, it transforms that point from the new coordinate system to the previous coordinate system:",{"@attributes":{"id":"p-0184","num":"0183"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":{"mtd":[{"msub":{"mi":["X","newCoordSys"]}},{"msub":{"mi":["y","newCoordSys"]}},{"mn":"1"}]}}},{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"00"}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"01"}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"10"}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"11"}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"20"}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"21"}},{"mn":"1"}]}]}}],"mo":"\u00b7"},{"mo":"\u2003","mrow":{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":{"mtd":[{"msub":{"mi":["X","oldCoordSys"]}},{"msub":{"mi":["y","oldCoordSys"]}},{"mn":"1"}]}}}}],"mo":"="}}}},"Transforms can be nested to any level. Whenever a new transform is applied it is the same as post-multiplying it onto the current transform matrix:",{"@attributes":{"id":"p-0186","num":"0185"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mo":["[","]"],"mtable":{"mtr":{"mtd":[{"msub":{"mi":["X","newCoordSys"]}},{"msub":{"mi":["y","newCorrdSys"]}},{"mn":"1"}]}}},{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["00","2"]}}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["01","2"]}}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["10","2"]}}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["11","2"]}}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["20","2"]}}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["21","2"]}}},{"mn":"1"}]}]}},{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["00","1"]}}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["01","1"]}}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["10","1"]}}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["11","1"]}}},{"mn":"0"}]},{"mtd":[{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["20","1"]}}},{"mrow":{"mi":"m","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mn":["21","1"]}}},{"mn":"1"}]}]}}],"mo":["\u00b7","\u00b7"]},{"mo":"\u2003","mrow":{"mo":["[","]"],"mtable":{"mtr":{"mtd":[{"msub":{"mi":["X","oldCoordSys"]}},{"msub":{"mi":["y","oldCoordSys"]}},{"mn":"1"}]}}}}],"mo":"="}}}},"Most places in the API do not take a Matrix directly, but instead use the Transform class, which supports animation.",{"@attributes":{"id":"p-0188","num":"0187"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public struct System.Windows.Media.Matrix"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construction and setting"]},{"entry":[{},"public Matrix(\u2009); \/\/ defaults to identity"]},{"entry":[{},"public Matrix("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"double m00, double m01,"]},{"entry":[{},"double m10, double m11,"]},{"entry":[{},"double m20, double m21);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Identity"]},{"entry":[{},"public static readonly Matrix Identity;"]},{"entry":[{},"public void SetIdentity(\u2009);"]},{"entry":[{},"public bool IsIdentity { get; }"]},{"entry":[{},"public static Matrix operator * (Matrix matrix1, Matrix matrix2);"]},{"entry":[{},"public static Point operator * (Matrix matrix, Point point);"]},{"entry":[{},"\/\/ These function reinitialize the current matrix with"]},{"entry":[{},"\/\/ the specified transform matrix."]},{"entry":[{},"public void SetTranslation(double dx, double dy);"]},{"entry":[{},"public void SetTranslation(Size offset);"]},{"entry":[{},"public void SetRotation(double angle); \/\/ degrees"]},{"entry":[{},"public void SetRotation(double angle, Point center); \/\/ degrees"]},{"entry":[{},"public void SetRotationRadians(double angle);"]},{"entry":[{},"public void SetRotationRadians(double angle, Point center);"]},{"entry":[{},"public void SetScaling(double sx, double sy);"]},{"entry":[{},"public void SetScaling(double sx, double sy, Point center);"]},{"entry":[{},"public void SetSkewX(double angle); \/\/ degrees"]},{"entry":[{},"public void SetSkewY(double angle); \/\/ degrees"]},{"entry":[{},"public void SetSkewXRadians(double angle);"]},{"entry":[{},"public void SetSkewYRadians(double angle);"]},{"entry":[{},"\/\/ These function post-multiply the current matrix"]},{"entry":[{},"\/\/ with the specified transform"]},{"entry":[{},"public void ApplyTranslation(double dx, double dy);"]},{"entry":[{},"public void ApplyTranslation(Size offApply);"]},{"entry":[{},"public void ApplyRotation(double angle); \/\/ degrees"]},{"entry":[{},"public void ApplyRotation(double angle, Point center); \/\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"degrees"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void ApplyRotationRadian(double angle);"]},{"entry":[{},"public void ApplyRotationRadian(double angle, Point center);"]},{"entry":[{},"public void ApplyScaling(double sx, double sy);"]},{"entry":[{},"public void ApplyScaling(double sx, double sy, Point center);"]},{"entry":[{},"public void ApplySkewX(double angle); \/\/ degrees"]},{"entry":[{},"public void ApplySkewY(double angle); \/\/ degrees"]},{"entry":[{},"public void ApplySkewXRadians(double angle);"]},{"entry":[{},"public void ApplySkewYRadians(double angle);"]},{"entry":[{},"public void ApplyMatrix(Matrix matrix);"]},{"entry":[{},"\/\/ Inversion stuff"]},{"entry":[{},"public double Determinant { get; }"]},{"entry":[{},"public bool IsInvertible { get; }"]},{"entry":[{},"public void Invert(\u2009);\u2003\/\/ Throws ArgumentException if"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"!IsInvertable"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static Matrix Invert(Matrix matrix);"]},{"entry":[{},"\/\/ Individual members"]},{"entry":[{},"public double M00 { get; set; }"]},{"entry":[{},"public double M01 { get; set; }"]},{"entry":[{},"public double M10 { get; set; }"]},{"entry":[{},"public double M11 { get; set; }"]},{"entry":[{},"public double M20 { get; set; }"]},{"entry":[{},"public double M21 { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"As can be seen from the foregoing detailed description, there is provided a system, method and object model that provide program code with the ability to interface with a scene graph. The system, method and object model are straightforward to use, yet powerful, flexible and extensible.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 8 and 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 14 and 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
