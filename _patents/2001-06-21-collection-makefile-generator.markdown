---
title: Collection makefile generator
abstract: Collection makefile generators generate comprehensive makefiles for processing collections of computer files. In operation, the present collection makefile generator dynamically discovers collection content files, classifies them according to content type and required processing actions, and then generates a makefile for performing those actions. Importantly, all build order dependencies are properly maintained among multiple collection products and among individual collection content files. Automated collection makefile generators drastically improve the productivity of human workers by effectively reducing makefile creation and maintenance costs to zero. Collection makefile generators thus enable humans to easily generate complex makefiles in an automated, scalable way that was not previously possible.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07003759&OS=07003759&RS=07003759
owner: Codefast, Inc.
number: 07003759
owner_city: San Jose
owner_country: US
publication_date: 20010621
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCES TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","OBJECTS AND ADVANTAGES","LIST OF DRAWING REFERENCE NUMBERS","DETAILED DESCRIPTION","CONCLUSION","RAMIFICATIONS","SCOPE"],"p":["The present invention uses inventions from the following patent applications that are filed contemporaneously herewith, and which are incorporated herein by reference:","US PTO Ser. No. 09\/885,078 Collection Information Manager; Kevin Jameson.","US PTO Ser. No. 09\/885,076 Collection Content Classifier; Kevin Jameson.","This invention relates to automated software systems for processing collections of computer files in arbitrary ways, thereby improving the productivity of software developers, web media developers, and other humans and computer systems that work with collections of computer files.","The general problem addressed by this invention is the low productivity of human knowledge workers who use labor-intensive manual processes to work with collections of computer files. One promising solution strategy for this software productivity problem is to build automated systems to replace manual human effort.","Unfortunately, replacing arbitrary manual processes performed on arbitrary computer files with automated systems is a difficult thing to do. Many challenging subproblems must be solved before competent automated systems can be constructed. As a consequence, the general software productivity problem has not been solved yet, despite large industry investments of time and money over several decades.","The present invention provides one piece of the overall functionality required to implement automated systems for processing collections of computer files. In particular, the current invention has a practical application in the technological arts because it provides both humans and software programs with an easy, convenient way of generating complex makefiles to control the automated processing of collections of computer files.","Introduction to Makefiles","Makefiles are input files for application \u201cmake\u201d programs that interpret input makefiles and subsequently issue useful computer processing commands specified by input makefiles. The first make program was created to manage the efficient construction of software programs that were comprised of many program source files.","The main problem to be solved by the original make program was that humans could not reliably figure out which source files needed to be recompiled after each program source code modification was made. Specifically, humans could not easily keep track of the various interdependencies that typically existed among multiple source files. Missing dependency relationships frequently lead to failed compilations, incorrect results, wasted time, and overall lower software development productivity. Prior to the invention of make programs, the only reliable way of ensuring a correct software build was to rebuild all files after each modification. This was very costly in terms of computer resources and wasted human programming time.","The first make program was invented to solve this dependency tracking problem. Input makefiles record dependency information and computer processing commands, such that only an optimal number of commands need be executed to propagate changed source file information into final software build products. Makefiles use a convenient declarative syntax for recording interdependencies among source files. In operation, make programs read makefiles, dynamically calculate full dependency graphs among program source files, and then execute an optimal number of commands to correctly rebuild software products.","In particular, make programs compare relative timestamp values between source files and derivative files to avoid unnecessary processing of unchanged source files. Specifically, if the timestamp on a derivative file is newer than the timestamp on the associated source file, the derivative file is not recalculated. In contrast, if the source file is newer than the derivative file, then commands are issued to rebuild the derivative file from the newer, more recently modified source file. The avoidance of unnecessary computational work ensures that a minimum number of commands are executed to correctly rebuild software products, leading to very significant increases in human productivity.","Make programs and makefiles are ubiquitous and heavily used within the software industry. Decades of industry experience have shown that make programs are very useful for many other applications beyond compiling and linking software products. Thus to a first approximation, make programs are useful programs for managing and executing arbitrary command sequences for arbitrary computational purposes.","High Manual Makefile Costs","Unfortunately, make programs give rise to another significant productivity problem, which is the ubiquitous problem of manually creating and maintaining makefiles. Manually creating and maintaining makefiles is time consuming, costly, and error prone for several reasons.","First, a significant amount of human time is required for programmers to first learn about make programs and makefiles. The knowledge burden imposed on individual programmers is consequential, especially if advanced or complex features of make programs must be understood.","Second, creating makefiles typically requires that programmers manually list all source files, dependencies, processing commands, processing variations, and makefile targets that are involved in make operations. These requirements are not demanding for trivially simple programs when only a few processing operations are involved. However, the requirements rapidly become very demanding, time consuming, and complex as the number of source files, dependencies, performed command sequences, process variations, and makefile targets increase in number.","Third, software maintenance costs caused by ongoing development activities are significant, especially for makefiles that are used to manage medium or large software systems. Because makefiles describe precise, particular computerized processes, makefiles must be frequently modified to produce variations in makefile processes to satisfy various processing situations. For example, it is common to modify makefiles to do the following things: to add debugging flags to compiler command lines; to add new versions of link libraries; to add program optimization flags to linkers; to change the location of imported or exported files; to add or remove source files to create a functional variation of the final software product; and to clone and modify a makefile for use on another computing platform, or to use with a different make program.","Fourth, evolutionary changes in computer environments often cause precision makefiles to \u201cbreak\u201d in some way. For example, program names might change, locations of installed software tools might change, command options of installed software tools might change, source file locations might be changed by reorganizations as projects grow, and so on. Since makefiles describe precise, complex processes, even small changes in computing environments can generate disproportionately large makefile maintenance costs.","Fifth, human programming mistakes or modifications that \u201cbreak\u201d makefiles may trigger many downstream costs, ranging from wasted program test runs to increased makefile debugging costs. For example, it is easy for humans to miss a dependency, omit a source file, or make a mistake when working on complex makefiles for large software systems. These increased downstream costs can be significant, ranging from trival losses of a few minutes here and there on small projects to consequential losses of several days or weeks on large, more complex projects where feedback cycle times are longer.","As can be seen from the above, manual makefile techniques clearly lower human productivity. One obvious approach for solving the problem is to automate the creation and maintenance of makefiles. But that is not a simple problem, as the following discussion will show.","Process Variance in Makefiles","The makefile generator problem is very difficult, primarily because of the large amounts of variance within every dimension of the makefile problem. In general, makefiles were designed to manage the application of arbitrary computer command sequences to arbitrary collections of computer files written in arbitrary computer languages, and containing arbitrary interdependencies in those languages. Further practical complications include using arbitrary computing platforms, arbitrary software toolsets, and arbitrary administrative policies.","A final complication is that many of the factors listed above are coupled, so that decisions in one dimension affect decisions in other dimensions. For example, choosing to use a particular software tool may affect the design of the overall processing sequence. Choosing a particular computing platform affects the software tools that must be used, and thus the command sequences that can be used, and so on. The knowledge content of complex makefiles can stretch across many coupled dimensions.","Importantly, each completed makefile must rationalize all of the influences and factors listed above, and ultimately embody a singular, precise, and particular solution to a particular set of problem parameters. Since even human programmers have practical difficulties working with such makefiles, constructing automated makefile generators to produce makefiles of similar complexity is obviously difficult.","To simplify description of the makefile generation problem, the next section identifies several important subproblems that must be solved in order to build a competent collection makefile generator. The following discussion contemplates a fully automated makefile generator program, capable of producing industrial-strength makefiles suitable for large software projects.","Further, the discussion uses the term \u201ccollection\u201d to mean a structured collection of arbitrary computer files. Collections are described in detail later in this document.","Problems to be Solved","The Collection Information Management problem is an important, fundamental problem that must be solved to enable the construction of automated collection processing systems. It is the problem how to model, manage, and provide collection instance information, collection content file information, and collection data type information for eventual use by application programs that process collections.","Some interesting aspects of the Collection Information Management Problem are these: large numbers of collections can exist; collections can have arbitrary per-instance specifier data; collections can contain many arbitrary computer files for content; collections can require that arbitrary processes be run on the collection content; collections can share sets of structural and processing characteristics; many software programs can require access to information about collections; collection representations must accommodate variances in computing platforms, administrative policies, and software processing tools; and collections must be resistant to scale up failure.","The Collection Information Management Problem is addressed by the \u201cCollection Information Manager\u201d patent application listed at the beginning of this document.","The Collection Content Classification Problem is another important problem that must be solved to enable the construction of automated collection processing systems. It is the problem of how to determine collection content members, content types, content processing actions, and content processing interdependencies. Solving the content classification problem is important because a solution would enable application programs to process collections of computer files in more powerful, more automated ways than were previously possible.","Some interesting aspects of the Collection Content Classification Problem are these: arbitrary collection types may be involved, containing arbitrary internal structures, numbers of internal products and product types. Arbitrary numbers of files and file types may be involved, requiring arbitrary content processing actions, platform dependent processing actions, and arbitrary administrative preferences for all of the above.","The collection content classification problem is addressed by the \u201cCollection Content Classifier\u201d patent application listed at the beginning of this document.","The Collection Makefile Generator Problem is another important problem that must be solved to enable the construction of automated collection processing systems. It is the problem of how to automatically calculate and generate a precision makefile for managing the efficient application of complex computer command sequences to various collections of computer files. Solving the makefile generator problem is important because a solution would drastically increase human productivity and decrease makefile creation and maintenance costs.","Some interesting aspects of the Collection Makefile Generator Problem are these: collections may have arbitrary data types, internal structures, internal products and product types. Arbitrary numbers of content files and file types may be involved, written in various programming languages, and requiring arbitrary processing actions and platform dependent processing actions. Arbitrary administrative preferences for all of the above may be required. In addition, variations may be required on all of the above for purposes such as debugging, testing, optimizing, and for varying final product contents. As those skilled in the art can appreciate, the overall Collection Makefile Generator Problem is not a simple problem.","The Multiple Product Build Order Problem is another important problem to solve. It is the problem of how to ensure that multiple products within one collection are processed in correct dependency order to ensure proper software build results.","Some interesting aspects of the Collection Product Build Order Problem are that an arbitrary number of user-defined product types may be involved, with arbitrary interdependency relationships among the various product types.","The Product File Build Order Problem is another important problem to solve. It is the problem of how to ensure that particular files within one product within one collection are processed in correct dependency order to ensure proper software build results.","Some interesting aspects of the Product File Build Order Problem are that an arbitrary number of special file types may be involved, with arbitrary interdependency relationships among the various file types.","The Include File Directory Problem is another important problem to solve. It is the problem of ensuring that there is a one-to-one match between (a) the include files that are found using makefile generator search rules and that are subsequently listed as dependencies within the makefile, and (b) the include files that are found using compiler search rules at compiler runtime. If a mismatch occurs, an incorrect build sequence or a wasteful build sequence may occur.","Some interesting aspects of the Include File Directory Problem are these: multiple search directories may be used; multiple different compilers may be used; include file search directories can vary with compilers; include files selected for makefile dependencies must match include files selected for compilation; and administrative policy conventions may include or exclude the use of include file dependencies in generated makefiles.","The Library File Directory Problem is another important problem to solve. It is the problem of ensuring that there is a one-to-one match between (a) the library files that are found by makefile generator library search rules and that are subsequently listed as dependencies within a makefile, and (b) the library files that are found by linker search rules at linker runtime. If a mismatch occurs, an incorrect build sequence or a wasteful build sequence may occur.","Some interesting aspects of the Library File Directory Problem are these: multiple search directories may be used; multiple different linkers may be used; library file search directories can vary with linkers; platform-dependent libraries may be used; and administrative policy conventions may include or exclude the use of library file dependencies in generated makefiles.","The Multiple Product Naming Problem is another important problem to solve. It is the problem of managing name conflicts within makefiles that build multiple products from the same set of source files, where the build command sequences differ among products. Each product must use its own namespace to avoid macro, file, and target name collisions with other products that are part of the same makefile.","Some interesting aspects of the Makefile Multiple Product Problem are these: many collection products may be involved; products can have arbitrary product types and product content files; each product may require different, platform-dependent processing actions; each file name, target name, or macro name reused by multiple products must be distinguished from other uses of the name; and multiple platform-dependent versions of same-name products may be required, increasing the probability of name conflicts within the final makefile.","The Makefile Parallel Processing Problem is another important problem to solve. It is the problem of how to optimally use available parallel processing power to perform makefile operations in a minimum amount of time. The main goal is to identify makefile targets that can benefit from parallel processing, and to emit further makefile targets to implement the desired makefile processing parallelism.","Some interesting aspects of the Parallel Makefile Target Problem are these: there is an inherent limit to the amount of parallelism that can be achieved within each collection of files to be processed; there is a physical limit to the amount of parallel processing power available in each computational environment; and there is a policy limit to the amount of parallelism that can be used by makefiles in each administrative environment. Ideally, the inherent problem parallelism limit should be less than the physical parallelism limit, and the physical parallelism limit should be less than the administrative parallelism limit.","The Template Sharing Problem is another important problem to solve. It is the problem of how to optimally share makefile generator template files among various computing platforms to maximize software reuse and minimize software maintenance costs. For example, some (platform-independent) templates can be used by all platforms, some templates by all \u201cwin\u201d (windows) platforms, and some templates only by the single \u201cwin98.plt\u201d platform.","Some interesting aspects of the Template Sharing Problem are these: many platforms may be involved; many templates may be involved; several different levels of sharing between platform-independent and platform-specific abstraction levels may be required; and desired templates may vary with collection type, product type, content type, and action type.","The Makefile Customization Problem is another important problem to solve. It is the problem of effectively representing and using all the variances in platforms, processes, programs, policies, etcetera, that were mentioned earlier, so that humans can customize all inputs to the makefile generation process. Competent automated makefile generators must clearly be able to accommodate the kind of customizations and variances found in real world industrial environments. If they cannot, a general solution to the makefile generation problem cannot be achieved. A workable solution to this problem is very, very important for the utility and success of automated makefile generators.","As the foregoing discussion suggests, makefile generation is a complex problem. Many important issues must be solved in order to create competent makefile generators. No competent general solution to the overall makefile generation problem is visible in the prior art today, even though the first make program was created in the 1970s, well over two decades ago.","General Shortcomings of the Prior Art","A professional prior art search for the present invention was performed, but produced no meaningful, relevant works of prior art. Therefore the following discussion is general in nature, and highlights the significant conceptual differences between file-oriented mechanisms in the prior art and the novel collection-oriented mechanisms represented by the present invention.","Prior art approaches lack support for collections. This is the largest limitation of all because it prevents the use of high-level collection abstractions that can significantly improve productivity.","Prior art approaches lack automated support for dynamically determining lists of collection content files to be processed by makefiles, thereby requiring humans to manually construct content file lists, and thereby increasing makefile creation and maintenance costs.","Prior art approaches lack automated support for multiple software products that are to be produced from the same collection of files, thereby requiring humans to manually create makefile code for multiple products, and thereby increasing makefile creation and maintenance costs.","Prior art approaches lack automated support for determining relative build order among multiple software products that are to be produced from the same collection of files, thereby requiring humans to manually declare relative build orders for multiple products, and thereby increasing makefile creation and maintenance costs.","Prior art approaches lack automated support for resolving name conflicts within makefiles that produce multiple software products from the same set of source files, thereby requiring humans to manually repair name conflicts, and thereby increasing makefile creation and maintenance costs.","Prior art approaches lack automated support for dynamically locating include files to participate in dependency relationships within the makefile, thereby requiring humans to manually declare such dependencies, and thereby increasing makefile creation and maintenance costs.","Prior art approaches lack automated support for dynamically locating library files to participate in dependency relationships within the makefile, thereby requiring humans to manually declare such dependencies, and thereby increasing makefile creation and maintenance costs.","Prior art approaches lack automated support for dynamically determining dependencies in arbitrary programming languages, thereby requiring humans to manually declare such dependencies, and thereby increasing makefile creation and maintenance costs.","Prior art approaches lack automated support for generating makefiles that support parallel execution behavior, thereby preventing the general use of parallel computing capacity to reduce makefile execution times.","Prior art approaches lack well-structured support for sharing makefile templates among across multiple computing platforms, thereby requiring multiple copies of makefile template information, and thereby increasing software maintenance costs.","Prior art approaches lack well-structured support for modelling large ranges of process variance and makefile customizations found within industrial software environments, thereby preventing the widespread use of fully automated makefile generators within industrial environments.","As can be seen from the above description, prior art mechanisms in general have several important disadvantages. Notably, general prior art mechanisms do not provide fully automated support for collections, dynamic determination of content files, multiple products, extensive makefile variance, or parallel execution support.","In contrast, the present collection makefile generator invention has none of these limitations, as the following disclosure will show.","Specific Shortcomings in Prior Art","Several examples of prior art makefile generators are discussed below. The examples fall into two main categories: makefile generator programs and integrated development environment (IDE) programs. Both types of programs generate makefiles so that project source files can be processed efficiently in an automated manner.","Prior Art Makefile Generators","Makefile generator programs generate makefiles for humans who are building software programs. Typically, makefiles contain computer instructions for compiling source code files and linking compiled object files to produce executable files or libraries of object files. Also typically, programmers include a variety of other useful command sequences in makefiles to increase productivity.","Some examples of popular freeware makefile generators include automake, imake, and mkmf (make makefile). One example of a patented makefile generator is U.S. Pat. No. 5,872,977 \u201cObject-Oriented Method and Apparatus For Creating A Makefile\u201d by Thompson, which describes an object-oriented method of generating makefiles from input build files and input rule files. Although each of these prior art approaches is useful in some way, each approach has several important shortcomings.","GNU automake has no dynamic content discovery mechanism; instead it requires programmers to manually list all files that require processing. Neither does it have a mechanism for sharing content classification information, so multiple automake files cannot easily share user-provided policy information. Finally, it uses an input file that must be manually constructed, and so its classification operations are not fully automated.","Imake has no support for dynamic content discovery; no automated support for multiple products, or for parallel targets. Finally, it uses an input file that must be manually constructed, and so its classification operations are not fully automated.","Mkmf does have a dynamic content discovery mechanism that dynamically includes all source files in the current directory in the output makefile. However, only the current directory is used to find source files; no other directories are supported. Moreover, all source files in the directory are included in the makefile, whether they should be or not. Finally, all files are used to build one product only; files cannot be grouped into multiple products.","The makefile generator approach described by Thompson in U.S. Pat. No. 5,872,977 has no support for dynamic content discovery; no automated support for multiple products, or for parallel targets. Finally, it uses a platform-independent input build file that must be manually constructed, and so its classification operations are not fully automated.","Prior Art IDEs","Integrated development environments provide programmers with a development program that integrates many software development tools such as editors, compilers, linkers, debuggers, and online documentation. Importantly, many IDE programs contain a small internal makefile generator to generate makefiles to control the software build process.","However, IDEs typically have no support for dynamic content discovery; no fully automated support for multiple products (human interaction is typically required), no support for parallel targets; and no support for collections in general.","As can be seen from the above description, prior art approaches have several important disadvantages. In contrast, the present makefile generator invention has none of these limitations, as the following disclosure will show.","A Collection Makefile Generator automatically generates complex, precision makefiles for processing collections, thereby significantly improving the productivity of humans that work with makefiles.","In operation, a collection makefile generator performs the following operations: dynamically determines a list of collection content files and a list of collection products; analyzes and classifies the content files to determine their data types; determines dependencies for content files with respect to include files and library files; determines appropriate command sequences for processing the content files to build the collection products; determines a set of parallel targets to support parallel makefile executions; determines customizations in accordance with site administrative policies, and finally emits a customized makefile for processing the host collection of computer files.","Thus the present collection makefile generator invention uses extensive amounts of dynamically obtained knowledge to generate correct, efficient, and complex makefiles, in a convenient, fully automated way that was not previously available.","The main object of collection makefile generators is to automatically generate competent, industrial-strength makefiles for processing collections, thereby promoting the construction of fully automated collection processing systems. Fully automated collection processing systems can significantly improve human productivity by processing collections of computer files in ways that were not possible before.","Other objects of the present invention, based on the limitations described above, include: to support collections; to dynamically determine collection content; to support multiple products; to determine relative build orders among multiple products; to resolve name conflicts caused by multiple products using the same source files; to dynamically locate include files and library files; to support determination of processing dependencies in multiple programming languages; to generate makefiles that support parallel execution behavior; to provide well-structured organizational support for template sharing; and to provide modeling support for large variances in makefile processes and site customization conventions.","A final object is to provide a general, scalable, and automated collection makefile generator means, thereby promoting the construction of scalable automated collection processing systems.","As can be seen from the objects above, collection makefile generators can provide many useful services to humans and application programs that process collections. Collection makefile generators improve human productivity by making it both possible and convenient to automatically generate complex makefiles for processing collections in complex, scalable, and automated ways that were not previously possible.","Further advantages of the present collection makefile generator invention will become apparent from the drawings and disclosure below.",{"@attributes":{"id":"p-0147","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":[{"@attributes":{"id":"ul0001-0001","num":"0146"},"b":"100"},{"@attributes":{"id":"ul0001-0002","num":"0147"},"b":"101"},{"@attributes":{"id":"ul0001-0003","num":"0148"},"b":"102"},{"@attributes":{"id":"ul0001-0004","num":"0149"},"b":"103"},{"@attributes":{"id":"ul0001-0005","num":"0150"},"b":"104"},{"@attributes":{"id":"ul0001-0006","num":"0151"},"b":"105"},{"@attributes":{"id":"ul0001-0007","num":"0152"},"b":"106"},{"@attributes":{"id":"ul0001-0008","num":"0153"},"b":"107"},{"@attributes":{"id":"ul0001-0009","num":"0154"},"b":"110"},{"@attributes":{"id":"ul0001-0010","num":"0155"},"b":"111"},{"@attributes":{"id":"ul0001-0011","num":"0156"},"b":"112"},{"@attributes":{"id":"ul0001-0012","num":"0157"},"b":"113"},{"@attributes":{"id":"ul0001-0013","num":"0158"},"b":"114"},{"@attributes":{"id":"ul0001-0014","num":"0159"},"b":"115"},{"@attributes":{"id":"ul0001-0015","num":"0160"},"b":"116"},{"@attributes":{"id":"ul0001-0016","num":"0161"},"b":"117"},{"@attributes":{"id":"ul0001-0017","num":"0162"},"b":"120"},{"@attributes":{"id":"ul0001-0018","num":"0163"},"b":"121"},{"@attributes":{"id":"ul0001-0019","num":"0164"},"b":"122"},{"@attributes":{"id":"ul0001-0020","num":"0165"},"b":"130"},{"@attributes":{"id":"ul0001-0021","num":"0166"},"b":"131"},{"@attributes":{"id":"ul0001-0022","num":"0167"},"b":"132"},{"@attributes":{"id":"ul0001-0023","num":"0168"},"b":"133"},{"@attributes":{"id":"ul0001-0024","num":"0169"},"b":"134"},{"@attributes":{"id":"ul0001-0025","num":"0170"},"b":"135"},{"@attributes":{"id":"ul0001-0026","num":"0171"},"b":"140"},{"@attributes":{"id":"ul0001-0027","num":"0172"},"b":"141"},{"@attributes":{"id":"ul0001-0028","num":"0173"},"b":"142"},{"@attributes":{"id":"ul0001-0029","num":"0174"},"b":"143"},{"@attributes":{"id":"ul0001-0030","num":"0175"},"b":"144"},{"@attributes":{"id":"ul0001-0031","num":"0176"},"b":"145"},{"@attributes":{"id":"ul0001-0032","num":"0177"},"b":"146"},{"@attributes":{"id":"ul0001-0033","num":"0178"},"b":"150"},{"@attributes":{"id":"ul0001-0034","num":"0179"},"b":"151"},{"@attributes":{"id":"ul0001-0035","num":"0180"},"b":"152"},{"@attributes":{"id":"ul0001-0036","num":"0181"},"b":"153"},{"@attributes":{"id":"ul0001-0037","num":"0182"},"b":"160"},{"@attributes":{"id":"ul0001-0038","num":"0183"},"b":"161"},{"@attributes":{"id":"ul0001-0039","num":"0184"},"b":"162"}]}},"Overview of Collections","This section introduces collections and some related terminology.","Collections are sets of computer files that can be manipulated as a set, rather than as individual files. Collection information is comprised of three major parts: (1) a collection specifier that contains information about a collection instance, (2) a collection type definition that contains information about how to process all collections of a particular type, and (3) optional collection content in the form of arbitrary computer files that belong to a collection.","Collection specifiers contain information about a collection instance. For example, collection specifiers may define such things as the collection type, a text summary description of the collection, collection content members, derivable output products, collection processing information such as process parallelism limits, special collection processing steps, and program option overrides for programs that manipulate collections. Collection specifiers are typically implemented as simple key-value pairs in text files or database tables.","Collection type definitions are user-defined sets of attributes that can be shared among multiple collections. In practice, collection specifiers contain collection type indicators that reference detailed collection type definitions that are externally stored and shared among all collections of a particular type. Collection type definitions typically define such things as collection types, product types, file types, action types, administrative policy preferences, and other information that is useful to application programs for understanding and processing collections.","Collection content is the set of all files and directories that are members of the collection. By convention, all files and directories recursively located within an identified set of subtrees are usually considered to be collection members. In addition, collection specifiers can contain collection content directives that add further files to the collection membership. Collection content is also called collection membership.","Collection is a term that refers to the union of a collection specifier and a set of collection content.","Collection information is a term that refers to the union of collection specifier information, collection type definition information, and collection content information.","Collection membership information describes collection content.","Collection information managers are software modules that obtain and organize collection information from collection information stores into information-rich collection data structures that are used by application programs.","Collection Physical Representations\u2014Main Embodiment",{"@attributes":{"id":"p-0157","num":"0194"},"figref":"FIGS. 1\u20133"},{"@attributes":{"id":"p-0158","num":"0195"},"figref":["FIG. 1","FIG. 2","FIG. 4","FIG. 4"],"b":["100","102","5","101","103"]},{"@attributes":{"id":"p-0159","num":"0196"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 4"],"b":["100","5","103","100"]},"First is a policy to specify that the root directory of a collection is a directory that contains a collection specifier file. In this example, the root directory of a collection  is a directory named \u201cc-myhomepage\u201d  Line , which in turn contains a collection specifier file  named \u201ccspec\u201d  Line .","Second is a policy to specify that all files and directories in and below the root directory of a collection are part of the collection content. Therefore directory \u201cs\u201d  Line , file \u201chomepage.html\u201d  Line , and file \u201cmyphoto.jpg\u201d  Line  are part of collection content   for said collection .",{"@attributes":{"id":"p-0162","num":"0199"},"figref":["FIG. 3","FIG. 2"],"b":["102","5"]},"Collection Information Types",{"@attributes":{"id":"p-0163","num":"0200"},"figref":"FIGS. 4\u20135"},{"@attributes":{"id":"p-0164","num":"0201"},"figref":"FIG. 4","b":["101","102","103","100","102","103"]},{"@attributes":{"id":"p-0165","num":"0202"},"figref":["FIG. 5","FIG. 4","FIG. 4","FIG. 5","FIG. 4","FIG. 5","FIG. 5"],"b":["101","103","101","103","103","102","104","105","106","104","106","102"]},"Suppose that an application program means   knows (a) how to obtain collection processing information , (b) how to obtain collection content information , and (c) how to relate the two with per-collection-instance information . It follows that application program means  would have sufficient knowledge to use collection processing information  to process said collection content  in useful ways.","Collection specifiers  are useful because they enable all per-instance, non-collection-content information to be stored in one physical location. Collection content  is not included in collection specifiers because collection content  is often large and dispersed among many files.","All per-collection-instance information, including both collection specifier  and collection content , can be grouped into a single logical collection  for illustrative purposes.","Collection Application Architectures",{"@attributes":{"id":"p-0169","num":"0206"},"figref":"FIGS. 6\u20137"},{"@attributes":{"id":"p-0170","num":"0207"},"figref":"FIG. 6","b":["111","110","107","101","103","101","103","107","111","110","101","103"]},{"@attributes":{"id":"p-0171","num":"0208"},"figref":"FIG. 7","b":["110","111","112","114","115","117"]},"Collection type definition API means  provides access to collection type information available from collection type definition server means . Collection specifier API means  provides access to collection specifier information available from collection specifier server means . Collection content API means  provides access to collection content available from collection content server means .","API means \u2013, although shown here as separate software components for conceptual clarity, may optionally be implemented wholly or in part within a collection information manager means , or within said server means \u2013, without loss of functionality.","API means \u2013 may be implemented by any functional communication mechanism known to the art, including but not limited to command line program invocations, subroutine calls, interrupts, network protocols, or file passing techniques.","Server means \u2013 may be implemented by any functional server mechanism known to the art, including but not limited to database servers, local or network file servers, HTTP web servers, FTP servers, NFS servers, or servers that use other communication protocols such as TCP\/IP, etc.","Server means \u2013 may use data storage means that may be implemented by any functional storage mechanism known to the art, including but not limited to magnetic or optical disk storage, digital memory such as RAM or flash memory, network storage devices, or other computer memory devices.","Collection information manager means , API means \u2013, and server means \u2013 may each or all optionally reside on a separate computer to form a distributed implementation. Alternatively, if a distributed implementation is not desired, all components may be implemented on the same computer.","Collection Data Structures",{"@attributes":{"id":"p-0178","num":"0215"},"figref":"FIGS. 8\u201310"},{"@attributes":{"id":"p-0179","num":"0216"},"figref":"FIG. 8"},"In particular, preferred implementations would use collection datastructures to manage collection information for collections being processed. The specific information content of a collection datastructure is determined by implementation policy. However, a collection specifier typically contains at least a collection type indicator  Line  to link a collection instance to a collection type definition.",{"@attributes":{"id":"p-0181","num":"0218"},"figref":["FIG. 9","FIGS. 9\u201310"]},{"@attributes":{"id":"p-0182","num":"0219"},"figref":["FIG. 10","FIG. 9","FIG. 10"]},"Overview of Makefile Generation","This section provides a high-level overview of the major players in makefile generation for collections.","One player is a Collection Makefile Generator Program , whose overall architecture is shown by , , ,  and . This program is responsible for generating a specific and correct makefile for processing the host collection.","Another player is a Collection Content Classifier Means . This subsystem is responsible for analyzing the host collection, and providing detailed collection content classification information to the Collection Makefile Generator Program . Collection content classification is a significant problem in its own right. Thus Collection Content Classifiers are discussed at length in a separate patent application \u201cCollection Content Classifier\u201d listed in the related applications section of this document.","Another player is collection information for the host collection. In particular, the collection specifier part of the collection information for the host collection contains additional information that is not picked up and passed on by the Collection Content Classifier Means  described above. Instead, Collection Makefile Generator Manager  reads collection specifier information directly.","Another player is collection type definition information, for characterizing the particular collection type of the host collection. Collection type definition information such as shown in  not only describes characteristics of particular collection types, but also specifies various makefile code fragments for processing collections of particular collection types.","In overall operation, a Collection Makefile Generator Program  uses a Collection Content Classifier Means  to obtain classification information for a host collection. Further, Collection Makefile Manager  also obtains collection information from the collection specifier of the host collection, and associated collection type definition for the collection. Having thus obtained all relevant knowledge about the collection instance (from the collection specifier), its classified contents, and its collection type and makefile processing conventions, Collection Makefile Manager  generates a correct makefile.","The following description of the main embodiment is organized as follows. First, overall program architecture and simplified operation will be described. Second, collection classification information will be described. Third, type definition information will be described. And fourth, additional makefile generator operations will be described.","Program Architecture",{"@attributes":{"id":"p-0190","num":"0227"},"figref":"FIG. 11","b":"120"},"Module Get Runtime Information  obtains initial configuration, command line argument, and environment variable information, and makes it available to the program invocation.","Module Collection Content Classifier Means  provides a list of organized collection content information to the invocation, including lists of collection content members, their content types, processing actions that should be applied to the content members, and processing dependencies among the content members.","Module Collection Makefile Generator Manager  uses collection information, type definition information, and collection content classifier information to generate a makefile for processing the host collection in arbitrary ways.","Operation","In operation, Collection Makefile Generator  proceeds according to the simplified algorithm shown in .","First, Collection Makefile Generator  calls Get Runtime Information  to obtain useful invocation runtime information, including configuration settings, command line arguments, and environment variable settings.","Next, Collection Content Classifier Means  is used to obtain classification information for the current collection being processed. In general, the output classification information answers the following four questions about a collection: (1) What content does the collection contain? (2) What is the content type of each content file? (3) What processing actions should be carried out on each content file? (4) What processing dependencies exist among content files?","Finally, Collection Makefile Generator Manager  generates a working makefile for the host collection, in accordance with the previously obtained classification information, thereby fulfilling the overall function of Collection Makefile Generator Program .","Collection Content Classifier","Collection Content Classifier Means  is described at length in a related patent application (see reference information at the beginning of this document).","The main function of Collection Content Classifier Means  is to dynamically analyze a collection for the purpose of obtaining and organizing lists of collection content files, file content types, processing actions, and content file interdependencies. A Collection Content Classifier Means  is not responsible for executing processing actions on collections; instead, a Collection Content Classifier Means  performs only an information gathering role.","Having obtained lists of collection content members and their corresponding content types, action values, and processing interdependencies, Collection Content Classifier Manager Means  has completed its main function of classifying a collection, and returns classification information to Collection Makefile Generator Program  for use in generating a makefile for the host collection.",{"@attributes":{"id":"p-0201","num":"0238"},"figref":"FIGS. 23\u201324","b":"122"},"Collection Makefile Manager",{"@attributes":{"id":"p-0202","num":"0239"},"figref":"FIG. 13","b":"123"},"Process Collection Services  identifies and processes makefile services for the overall collection. Makefile services are symbolic services that eventually resolve to makefile code fragments for the final output makefile.","Makefile services for the overall collection abstraction level are defined in two places: in the collection type definition  and in the collection section of a collection specifier file  Lines \u2013. Makefile services from the two sources are processed by Do Collection Type Definition Services  and Do Collection Standalone Services , respectively.","Sort Product Build Orders  organizes multiple products within a collection into proper build order, thereby ensuring that processing dependencies among products are correctly followed, and thereby assuring valid product build results.","Calculate Collection Parallel Targets  determines the names of parallel makefile targets for supporting parallel makefile computations within parallel computing environments. Parallel computations can significantly improve computational performance by applying more computing resources to a computation.","Product Makefile Manager  determines makefile information for a single collection product, and inserts the resulting information into the output makefile.","Operation","In operation, Collection Makefile Manager  proceeds according to the simplified algorithm shown in .","Process Collection Services  retrieves collection makefile services from the collection specifier and from the associated collection type definition information. The two helper modules Do Collection Type Definition Services  and Do Collection Standalone Services  perform the work of inserting the resulting makefile code into the output makefile.","Sort Product Build Orders  is discussed as a special topic later in this document.","Calculate Collection Parallel Targets  is discussed as a special topic later in this document.","Product Makefile Manager  oversees the generation of product-specific makefile code.","Product Makefile Manager",{"@attributes":{"id":"p-0213","num":"0250"},"figref":"FIG. 15","b":"140"},"Process Product Services  retrieves product makefile services from the collection specifier and from the associated product type definition information. Two helper modules Do Product Type Definition Services  and Do Product Standalone Services  perform the work of inserting resulting makefile code into the output makefile.","Sort File Build Orders  organizes multiple files within a product into proper build order, thereby ensuring that processing dependencies among files are correctly followed, and thereby assuring valid build results.","Calculate Library Search Directories  determines the names of directories that contain library files that are required by collection products, usually for program linking purposes. Relevant directory names are passed to linker commands in the output makefile.","Calculate Product Parallel Targets  determines the names of parallel makefile targets for supporting parallel makefile computations within parallel computing environments. Parallel computations can significantly improve computational performance by applying more computing resources to a computation.","File Makefile Manager  determines makefile information for a single collection file, and inserts the resulting information into the output makefile.","Operation","In operation, Product Makefile Manager Module  proceeds according to the simplified algorithm shown in .","Process Product Services  retrieves collection makefile services from the collection specifier and from the associated collection type definition information. Two helper modules Do Product Type Definition Services  and Do Product Standalone Services  perform the work of inserting resulting makefile code into the output makefile. Sort File Build Orders  operation is discussed as a special topic later in this document. Calculate Library Search Directories  operation is discussed as a special topic later in this document.","Calculate Product Parallel Targets  operation is discussed as a special topic later in this document.","File Makefile Manager  oversees the generation of file-specific makefile code.","File Makefile Manager",{"@attributes":{"id":"p-0223","num":"0260"},"figref":"FIG. 17","b":"150"},"File Makefile Manager  retrieves file and action makefile services from the collection specifier, and from the associated type definition information.","Calculate Include Search Directories  determines the names of directories that contain include files required by content file dependencies, usually for compiling purposes. Relevant directory names are passed to compiler commands in the output makefile.","Do File Type Definition Services  processes makefile services originating in file type definition files.","Do Action Type Definition Services  processes makefile services originating in action type definition files.","In operation, File Makefile Manager Module  proceeds according to the simplified algorithm shown in .","Detailed algorithmic operations relating to include file search directories and processing makefile services are discussed later in this document.","Process Makefile Service",{"@attributes":{"id":"p-0230","num":"0267"},"figref":"FIG. 19","b":"160"},"This architecture shows that all modules for processing collection, product, file, and action services call Process Makefile Service Module  to perform low-level makefile service processing.","Process Makefile Service Module  performs low-level makefile service processing with the help of two helper modules, Substitute Makefile Fragment  and Insert Makefile Fragment .","Substitute Makefile Fragment  substitutes replacement string values from the current collection instance into makefile fragment templates that contain placeholder strings. This creates working, instance-specific templates that can be inserted into the output makefile.","Insert Makefile Fragment  inserts substituted makefile fragments into the output makefile, in proper makefile position according to various makefile fragment positioning criteria.","In operation, Process Makefile Service Module  proceeds according to the simplified algorithm shown in .","Now that overall program architecture has been described, discussion will continue by describing Type Definition Information.","Collection Classifier Information",{"@attributes":{"id":"p-0237","num":"0274"},"figref":"FIGS. 21\u201324"},{"@attributes":{"id":"p-0238","num":"0275"},"figref":["FIG. 21","FIG. 22"],"b":["3","6","10","11","14"]},{"@attributes":{"id":"p-0239","num":"0276"},"figref":"FIG. 23","b":["8","12","13","19","17","8","12"]},{"@attributes":{"id":"p-0240","num":"0277"},"figref":"FIG. 24","b":["10","15","16","22","21","10","15"]},"Collection classification information is obtained by Collection Content Classifier Means , and is passed to Collection Makefile Manager  for use in generating a makefile for the host collection.","This completes the presentation of collection classification information. Discussion continues with a description of type definition information, and is then followed by a detailed discussion of low level makefile generation operations.","Type Definition Information","The process of generating makefiles is essentially a matching process between collection instance information and predetermined makefile generation information. For example, a makefile generator will typically match a C program source file within a collection instance to predetermined makefile code templates for processing the C source file. Type definition information provides the required predetermined type definition information used in this matching process.","This section therefore describes a preferred implementation for type definition information.",{"@attributes":{"id":"p-0245","num":"0282"},"figref":"FIG. 25","b":"120"},"Lines \u2013 show four important major levels in the type definition hierarchy. The first level Line  models whole collection types. The second level Line  models product types within collection types. The third level Line  models content types within product types. The fourth level Line  models action types within content types.","Importantly, each level provides human users an opportunity to customize subsequent type definition information lower in the tree. For example, two different collection types Lines \u2013 could have two completely different product type definitions for the same product name. Similarly, two different product types within the same collection type could specify lists of completely different content types, or different content definitions for the same content type name. Two different content types within the same product type could specify completely different action types, and so on.","In practice, closely related types frequently share type definition information because sharing reduces type information maintenance costs. Typically, environments that use closely related type definitions will contain more shared information than environments that use unrelated collection types. Particular amounts of information sharing and overlap are determined by implementation policy.",{"@attributes":{"id":"p-0249","num":"0286"},"figref":"FIG. 25","b":["5","23"]},"In what follows, the excerpts will be used to show how type definitions are chained together to form a type definition hierarchy for a typical collection representing a program and library written in the \u201cC\u201d programming language. Afterwards, discussion will continue onward with an explanation of how to construct a collection content list using the type definition hierarchy.",{"@attributes":{"id":"p-0251","num":"0288"},"figref":["FIG. 25","FIG. 2","FIG. 3"],"b":["5","5","6","6"]},"Lines \u2013 represent an index file of collection types known to the implementation. Using the collection type \u201cct-program\u201d Line  as a key into the index table, Line  Column  provides the name of a corresponding collection type definition file \u201cct-program.def\u201d.","Lines \u2013 represent an excerpt of a collection type definition file for the \u201cct-program\u201d collection type. Each collection type definition file must provide a list of known products for its collection type. Line  Column  provides the filename of an index file that lists known product types for the \u201cct-program\u201d collection type.","Lines \u2013 represent an index file of known product types for the \u201cct-program\u201d collection type. Line  contains a product type name \u201cpt-program\u201d that points to a product type definition file \u201cpt-program.def\u201d.","Lines \u2013 represent a product type definition file for the \u201cpt-program\u201d product type. Line  provides the filename of an index file of known content types for the product type \u201cpt-program\u201d.","Lines \u2013 represent an index file of known content types for the \u201cpt-program\u201d product type. Line  contains a content type name \u201ccontent-c\u201d that points to a content type definition file \u201ccontent-c.def\u201d.","Lines \u2013 represent a content type definition file for the \u201ccontent-c\u201d content type. Line  provides the filename of an index file of known action types for the content type \u201ccontent-c\u201d.","Lines \u2013 represent an index file of known action types for the \u201ccontent-c\u201d content type. Line  contains an action type name \u201caction-c\u201d that points to an action type definition file \u201caction-c.def\u201d.","Lines \u2013 represent an action type definition file for the \u201caction-c\u201d action type.","The four levels shown above closely correspond to natural, practical boundaries found in collections. First, the collection type level models the types and characteristics of whole collections. Second, since collections may contain multiple products, a product type level is useful to model products. Third, since products are comprised of files containing various types of content, a content type level is useful to model content files. And fourth, since various types of content files require different processing actions, an action type level is useful to model various actions.","Example Type Definitions",{"@attributes":{"id":"p-0261","num":"0298"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0262","num":"0299"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0263","num":"0300"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0264","num":"0301"},"figref":"FIG. 29"},"Now that an overview of the fundamental four-level type hierarchy has been presented, the discussion proceeds to a detailed description of makefile generation operations.","Makefile Services and Fragments","Makefile services and makefile fragments are the fundamental building blocks of a collection makefile generator. Conceptual makefile services are implemented by physical makefile fragments.","The overall process of generating a makefile consists of obtaining collection instance information, substituting that information into various makefile fragments, and then assembling the substituted fragments into a completed makefile.",{"@attributes":{"id":"p-0268","num":"0305"},"figref":"FIG. 30","b":["1","2","2","9","10","14"]},"In operation, makefile services that are specified in type definition files (eg.  Lines \u2013) are used as look up keys into a makefile service index table to obtain the names of associated makefile fragments. Collection instance information is substituted into the obtained makefile fragments, and the substituted fragments are then added to the output makefile.","Collection Services and Fragments","This section explains how an output makefile is constructed. It assumes that collection content classification information has already been obtained. Software modules Process Collection Services  and Do Collection Type Definition Services  are primarily responsible for the work that follows.",{"@attributes":{"id":"p-0271","num":"0308"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0272","num":"0309"},"figref":["FIG. 22","FIG. 21"],"b":"3"},{"@attributes":{"id":"p-0273","num":"0310"},"figref":"FIG. 25","b":["5","6","5","23"]},"Continuing, the collection type value \u201cct-program\u201d from  Line  is used as a lookup key into the example collection type index table shown in . Line  column  provides the name of a corresponding collection type definition file.",{"@attributes":{"id":"p-0275","num":"0312"},"figref":["FIG. 26","FIG. 38","FIG. 26"],"b":["5","17","8","9","15"]},{"@attributes":{"id":"p-0276","num":"0313"},"figref":["FIG. 26","FIG. 30"],"b":["9","3"]},{"@attributes":{"id":"p-0277","num":"0314"},"figref":"FIG. 31"},"Now that a template has been identified, it can be processed and inserted into the output makefile. Do Collection Type Definition Services  calls Process Makefile Service  to oversee fragment substitution and insertion operations.","Process Makefile Service  calls Substitute Makefile Fragment  to substitute collection instance values into fragment placeholder strings. But since this first template has no placeholder strings for collection instance data, it requires no substitution operations. Therefore fragment substitution is explained later in this document.","Process Makefile Service  next calls Insert Makefile Fragment  to insert the completed \u201ccoll-macro-platform.tpl\u201d fragment into the output makefile.  shows the fragment.  shows a base template that is copied to form the initial output makefile.  Lines \u2013 show the results of inserting the fragment into the output makefile.","Fragment Insertion","Fragment insertion generally proceeds by inserting fragment text into the makefile, above a specified location marker. The structure of a makefile fragment carries the necessary information.",{"@attributes":{"id":"p-0282","num":"0319"},"figref":"FIG. 31","b":["4","8","10","15","5"]},"Thus to complete the previous example, Insert Makefile Fragment  would first locate the marker string \u201cmarker-htree\u201d in the base template  Line , then copy  Lines \u2013 into the makefile, above the marker string. The results of this particular insertion are shown by  Lines \u2013.","Similarly, Insert Makefile Fragment  would copy  Lines \u2013 into the output makefile above the \u201cmarker-macros\u201d marker, thereby producing the results shown by  Lines \u2013.","Having thus described how insertion works, it can be seen that  shows the results of inserting all makefile services shown by  Lines \u2013 into the output makefile. The associated makefile fragment template files are shown in . None of these fragments require substitution.","Other services specified in the host collection type definition would be inserted accordingly. The number and names of location markers are determined by implementation policy. The number of services, fragments, and the content of fragments are also determined by implementation policy.",{"@attributes":{"id":"p-0287","num":"0324"},"figref":"FIG. 37","b":["1","2","3","4","5","6"]},"Product Services and Fragments","This section describes product services, product fragments, and fragment substitution operations.",{"@attributes":{"id":"p-0289","num":"0326"},"figref":["FIG. 22","FIG. 21"],"b":"7"},{"@attributes":{"id":"p-0290","num":"0327"},"figref":"FIG. 25","b":["10","14"]},{"@attributes":{"id":"p-0291","num":"0328"},"figref":"FIG. 27","b":["6","14","13"]},{"@attributes":{"id":"p-0292","num":"0329"},"figref":"FIG. 30","b":["2","11","13"]},"In particular, the three fragments represent platform independent Line , operating system dependent Line , and platform dependent Line  information. Separating the total service information into these categories provides two small conveniences. First, it enables technical sharing of platform independent and operating system information among multiple platforms, if site policy permits. Second, it provides human administrators with a few more abstraction levels for modelling makefile information, if so desired.","There is no requirement for splitting total service information into multiple fragment files. However, not splitting and not sharing information may require that multiple copies of some information be created. The particular amount of splitting and sharing used is determined by implementation policy.","Continuing,  shows the \u201cprod-prog-pi.tpl\u201d fragment template file. This fragment file contains placeholder strings that must be replaced with product instance values before the completed fragment is inserted into the output makefile. For example, Line  contains a replacement string \u201c_prod_\u201d that is replaced with the current product name  Line  \u201cmyprog\u201d during the substitution process.","Substituting product instance values into fragment strings has the effect of generating product-specific makefile code in the output makefile. That way, the same fragment can be used to generate compatible makefile code for multiple products or files.",{"@attributes":{"id":"p-0297","num":"0334"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0298","num":"0335"},"figref":["FIG. 44","FIG. 40","FIG. 22"],"b":["4","7","6"]},"Insertable Location Markers","Not all location markers must be in the initial base template file.  Line  shows an example of an insertable marker string. The main idea of insertable marker locations is that inserted fragments can themselves contain markers to support further insertions. That way fragment administrators can design their own marker locations and corresponding fragments.  Line  shows the inserted marker string from  Line .","Continuing with the example,  shows an operating system dependent fragment for appending build dependencies to makefile targets.  Line  shows how the fragment \u201c_target_\u201d command from  Line  adds a dependency relationship to the \u201cbuild\u201d target for the current product \u201cmyprog\u201d. The value of the replacement string \u201c_mprod_\u201d is defined in  Line . The macro \u201c$(X)\u201d in  Line  represents a file suffix value defined in  Line .",{"@attributes":{"id":"p-0301","num":"0338"},"figref":"FIG. 42","b":["7","8","15","16","21","23","28"]},{"@attributes":{"id":"p-0302","num":"0339"},"figref":["FIG. 45","FIGS. 40\u201342"]},"This concludes discussion of product level services and fragments.","Content Services and Fragments","This section describes content services and fragments. Content services and fragments are processed in the same way as collection and product fragments.","Continuing with the example,  shows a collection that contains a C program source file \u201ccmdline.c\u201d on Line . The content type of C source files is \u201cctype-c-source\u201d, as shown by the collection content classifier output shown in  Line .",{"@attributes":{"id":"p-0306","num":"0343"},"figref":"FIG. 25","b":["10","18"]},{"@attributes":{"id":"p-0307","num":"0344"},"figref":"FIG. 28","b":["6","13","12"]},{"@attributes":{"id":"p-0308","num":"0345"},"figref":"FIG. 30","b":["20","2"]},{"@attributes":{"id":"p-0309","num":"0346"},"figref":"FIG. 46","b":"6"},{"@attributes":{"id":"p-0310","num":"0347"},"figref":["FIG. 48","FIG. 46"],"b":["3","5"]},"Action Fragments","This section describes action services and fragments. Action services and fragments are processed in the same way as collection, product, and content fragments.","Continuing with the example, the current content type definition file  Line  specifies an action type of \u201caction-c-source\u201d for the current content file \u201ccmdline.c\u201d.",{"@attributes":{"id":"p-0313","num":"0350"},"figref":"FIG. 25","b":["18","22"]},{"@attributes":{"id":"p-0314","num":"0351"},"figref":"FIG. 29","b":["6","9","9"]},{"@attributes":{"id":"p-0315","num":"0352"},"figref":"FIG. 30","b":["27","2"]},{"@attributes":{"id":"p-0316","num":"0353"},"figref":["FIG. 47","FIG. 43"],"b":"9"},{"@attributes":{"id":"p-0317","num":"0354"},"figref":["FIG. 48","FIG. 47"],"b":["21","23"]},"This concludes a general description of how makefiles are generated using collection instance information, type definition information, and makefile base templates, services, and fragments. The discussion now turns to special topics in makefile generation.","Standalone Makefile Services","In addition to specifying makefile services as part of a type definition, it is also possible to specify standalone makefile services in collection specifiers. Standalone makefile services can appear in both collection and product sections of collection specifiers.","Standalone makefile services are very practical and useful for adding additional functionality to a generated makefile, where the additional functionality is not directly associated with building the collection products. For example, standalone services can be used to clean up build directories after a build completes, or to insert makefile code for installing newly built products into site installation directories.",{"@attributes":{"id":"p-0321","num":"0358"},"figref":"FIG. 49","b":["4","9"]},"Although these two standalone service examples are simple, standalone services can be arbitrarily complex to satisfy the processing needs at hand. Standalone services are a very practical and convenient way of adding custom makefile code to a generated makefile.","In operation, standalone makefile services are processed in the same way as all other makefile services. Do Collection Standalone Services  and Do Product Standalone Services  retrieve standalone services from collection specifiers, and pass the retrieved information to Process Makefile Service  for normal substitution and insertion operations.","Product Replacement Names","This section discusses how multiple collection products can each use the same root filename in their output files without causing name collisions within the output makefile.","The main problem arises under the following conditions: multiple collection products are involved; products have different names in the collection specifier; and output product files should have the same base filename.","For example, consider the case where two products are defined within a collection \u201cmyprog\u201d to produce an executable program file and a shared object executable file. The first product is named \u201cmyprog\u201d, and produces an executable file named \u201cmyprog\u201d. The second product is named \u201cmyprog-2\u201d and produces a shared object file \u201cmyprog-2.so\u201d. But it is desirable to have the same base filename \u201cmyprog\u201d on both output files, giving \u201cmyprog\u201d and \u201cmyprog.so\u201d.","The second product cannot be named \u201cmyprog\u201d to give an output filename of \u201cmyprog.so\u201d, because then a product name collision would result in the collection specifier; both products would have the same name.","One solution to the problem is to use a replacement name directive within the collection specifier to specify the base name of the product output file.",{"@attributes":{"id":"p-0329","num":"0366"},"figref":"FIG. 50","b":["1","11","10"]},"Lines \u2013 summarize how product and replacement names map on to substitution strings that will be used during substitution operations. The normal product name is stored in the \u201c_prod_\u201d substitution string, and the replacement product name is stored in the \u201c_mprod_\u201d (makefile product name) substitution string.","Lines \u2013 show an example fragment containing both substitution strings. The purpose of this fragment is to create an executable file by linking together object files. The control values in the LDFLAGS macro tell the linker whether to produce an executable file or a shared object file. Since LDFLAGS is unimportant for this example, specific linker flags are not shown.","Lines  and  use the \u201c_mprod_\u201d substitution string, because these lines work with the final product output file. Therefore they must use the product replacement name value. In contrast, Line  uses the \u201c_prod_\u201d substitution string, because Line  must avoid name collisions between different linker names and linker flag macro names.","Lines \u2013 show the substituted fragment for the first product that produces a normal executable program file.","Lines \u2013 show the substituted fragment for the second product that produces a shared object executable file.","Name collisions between final product output files are avoided because the filename suffixes for the two output products are different. The executable product uses a \u201c$(X)\u201d suffix substitution string, whereas the shared object product uses a \u201c$(SO)\u201d suffix substitution string.","As can be seen, the replacement name substitution string method achieves the desired goals. The base filenames of both output products are identical, yet name collisions among collection specifier product names, linker macro definitions, and output filenames are avoided.","Product Build Order","The main problem of product build order is caused by multiple products having dependencies among themselves. As a consequence, particular product build orders must sometimes be followed in order to ensure correct build results.","For example, consider a collection that contained a library product and a program product. Further suppose the program product used the library product, thereby creating a dependency relationship. It is clear that the library product must therefore be built first, so that the library exists when the program executable file is linked together.","One solution to the problem is to use product types as keys into a product build order table that provides a precedence ranking of product types.",{"@attributes":{"id":"p-0340","num":"0377"},"figref":"FIG. 51","b":["6","7"]},"In operation, module Sort Product Build Orders  obtains the product types for all products that must be built, and obtains associated build order values from a product build order table such as . Product build order values are then sorted and returned to Collection Makefile Manager  for use in building products in the desired build order.",{"@attributes":{"id":"p-0342","num":"0379"},"figref":"FIG. 52","b":"6"},"File Build Order","The main problem of file build order is caused by multiple files having external dependencies among themselves. External dependencies are not the same as include file dependencies that are created by internal contents of files. Instead, external dependencies are usually imposed on files by outside factors such as the computational environment. As a consequence, particular file build orders must sometimes be followed in order to ensure correct build results.","For example, some software development environments for personal computers require that graphical user interface resource files (.rc files) be processed before other files that reference the resource files. In this example, resource output files (.rc files) are similar to include files, in that they must exist before other files that use the output resource files can themselves be compiled.","As another example taken from a software development environment for personal computers, a precompiled header file in the C++ language must be compiled before other files that use it.","One solution to the problem is to use file or content types as keys into a file build order table that provides a precedence ranking of file types.",{"@attributes":{"id":"p-0347","num":"0384"},"figref":"FIG. 53","b":["4","6"]},"In operation, module Sort File Build Orders  obtains the file types for all files that must be built, and obtains associated build order values from a file build order table such as . File build order values are then sorted and returned to Product Makefile Manager  for use in building files in the desired build order.",{"@attributes":{"id":"p-0349","num":"0386"},"figref":"FIG. 54","b":["10","10"]},"Include Search Directories","The main problem of include file search directories is caused by the need to share include files that are external to the collection being processed.","Specifically, compilers can normally locate include files located in the same directory as source files that are being compiled, but compilers cannot normally locate include files in some arbitrary external directory within a computer filesystem. Instead, a list of external include file search directories must be provided to compilers for locating external include files.","It follows that makefile generators that generate compiler command lines must determine a list of relevant include file search directories and then add the list of include directories to compiler command lines.","One solution to the problem is to use product-dependent include file search directory lists. The main idea is that each product type definition can specify a set of directories containing include files for that product. A collection makefile generator can then search those directories to resolve include file dependencies obtained from parsing source code files.",{"@attributes":{"id":"p-0354","num":"0391"},"figref":"FIG. 27","b":"10"},{"@attributes":{"id":"p-0355","num":"0392"},"figref":"FIG. 55","b":"2"},"In operation, Calculate Include Search Directories  performs the work of identifying required include file search directories, and associates them with the substitution replacement string \u201c_incl_dirs_\u201d.",{"@attributes":{"id":"p-0357","num":"0394"},"figref":["FIG. 56","FIG. 23"],"b":["2","3","19","20"]},{"@attributes":{"id":"p-0358","num":"0395"},"figref":["FIG. 56","FIG. 55","FIG. 55"],"b":["5","6","151"]},{"@attributes":{"id":"p-0359","num":"0396"},"figref":"FIG. 56","b":"7"},{"@attributes":{"id":"p-0360","num":"0397"},"figref":["FIG. 56","FIG. 47"],"b":["12","7","8"]},"Thus the compiler command in the output makefile is provided with an optimal, correct list of include directories to search for include files.","Library Search Directories","The main problem of library file search directories is caused by the need to share library files that are external to the collection being processed.","Specifically, linkers can normally locate library files located in the same directory as object files that are being linked, but linkers cannot normally locate library files in some arbitrary external directory within a computer file system. Instead, a list of external library file search directories must be provided to linkers for locating external library files.","It follows that makefile generators that generate linker command lines must determine a list of relevant library file search directories and add the list of directories to linker command lines.","One solution to the problem is to use product-dependent library file search directory lists. The main idea is that each product type definition can specify a set of directories containing library files for that product. A collection makefile generator can then search those directories to resolve library file dependencies specified for the product.",{"@attributes":{"id":"p-0366","num":"0403"},"figref":"FIG. 22","b":"9"},{"@attributes":{"id":"p-0367","num":"0404"},"figref":"FIG. 27","b":"9"},{"@attributes":{"id":"p-0368","num":"0405"},"figref":"FIG. 57","b":"2"},"In operation, Calculate Library Search Directories  performs the work of identifying required library file search directories, and associating them with the substitution replacement string \u201c_lib_dirs_\u201d.",{"@attributes":{"id":"p-0370","num":"0407"},"figref":["FIG. 58","FIG. 22"],"b":["2","3","9"]},{"@attributes":{"id":"p-0371","num":"0408"},"figref":["FIG. 58","FIG. 57"],"b":["5","6","145"]},{"@attributes":{"id":"p-0372","num":"0409"},"figref":"FIG. 58","b":"7"},{"@attributes":{"id":"p-0373","num":"0410"},"figref":"FIG. 58","b":"8"},{"@attributes":{"id":"p-0374","num":"0411"},"figref":["FIG. 58","FIG. 42"],"b":["11","12","15","16"]},"Thus the linker command in the output makefile is provided with an optimal, correct list of library directories to search for library files.","Virtual Platforms","As can be appreciated from the foregoing discussion, a large number of makefile fragments are required to effectively model the makefile needs of a typical industrial software environment. For example, several hundreds of fragments might be involved.","One helpful technique for managing large numbers of fragments is to organize them into virtual platform directories, and then use virtual platform search directories to find specific fragment files. A virtual platform is one that is invented by fragment administrators to represent a desired abstraction level for sharing makefile information.","There are two main benefits of this approach.","The first benefit is that information can be more easily shared at various operating system abstraction levels. For example, virtual platform \u201cpi\u201d information can be shared among all platforms, virtual platform \u201cgnulinux\u201d information can be shared among all GNUlinux systems, and virtual platform \u201cgnulinux2\u201d information can be used only by Gnulinux2 systems.","The second benefit is that virtual platform search rules make it possible to more easily override more generic information with more specific information. For example, placing \u201cgnulinux2\u201d ahead of \u201cpi\u201d in a set of virtual platform search rules ensures that the \u201cgnulinux2\u201d version of a same-named file will always be found before the \u201cpi\u201d version of the same-named file.",{"@attributes":{"id":"p-0381","num":"0418"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0382","num":"0419"},"figref":["FIG. 60","FIG. 59"]},"For example,  Line  contains a virtual platform entry for the \u201cgnulinux2\u201d virtual platform. Column  holds the name of the virtual platform (the \u201c.plt\u201d suffix is a convention, but is not required). Columns \u2013 specify increasingly more general abstraction levels for possible sharing. The search rules shown in  Lines \u2013 correspond to the virtual platform names in  Columns \u2013.","In operation, a software module such as Process Makefile Service  might need to resolve a makefile service name into a fragment template file by performing a lookup through a makefile service index table such as shown in . The module would perform the lookup, and would obtain a filename for the desired fragment template.","Now the module must find the physical fragment file. This is where virtual platform search rules can be effectively used. Process Makefile Service  would use a virtual platform table such as the one shown in  to construct a set of virtual platform search directories such as shown in . Then, following the constructed search rules, the module would search for the desired fragment template file.","Platform Dependent Standalone Services","Virtual platforms can also be effectively used in collection specifiers to delineate platform dependent information such as makefile services or library names.",{"@attributes":{"id":"p-0387","num":"0424"},"figref":"FIG. 61"},"Line  specifies a library name \u201cmylib\u201d that should be used for all platforms. However, Line  overrides the Line  directive for all \u201clinux\u201d virtual platforms. Line  specifies that for \u201clinux\u201d platforms an additional library is required for linking. Calculate Library Search Directories , when calculating for \u201cgnulinux\u201d platforms, would use Line  instead of Line  as the source for library names.","Lines \u2013 show the use of virtual platforms in standalone makefile service directives. In this example, module Do Product Standalone Services  would use Line  when processing \u201cwin98\u201d platforms, Line  when processing \u201cgnulinux\u201d platforms, and Line  for when processing all other platforms.","Parallel Targets","The main problem addressed by parallel makefile targets is non-utilization of parallel processing resources, leading to lower than necessary execution performance of makefile operations.","Typical makefiles contain only \u201csequential\u201d targets that are structured to support sequential computational operations using one computational execution resource. In contrast, parallel makefile targets can significantly improve computational performance by enabling the use of parallel computing resources that might be available.","Limits to Parallelism","Three main factors limit the amount of parallelism that can be used in a computation: (a) the inherent problem parallelism within the set of files that is being processed, (b) the physical parallelism available within the computational hardware and software environment, and (c) administrative limits on the amount of parallelism that can be used.","Problem parallelism is inherently determined by processing interdependencies among the files that must be processed. That is, only some files can be processed in parallel. The maximum number of files that can be processed in parallel determines the maximum problem parallelism.","Physical parallelism is determined by the physical limits of the computational environment. For example, operating systems usually limit the number of parallel processes that can be created, and computers always limit the number of physical CPU chips that are available for use.","Administrative parallelism is determined by administrative policy. This is because system administrators may want to limit the computational resources that can be accessed by any one parallel computation. For example, parallel calculations can generate significant amounts of computer load, so system administrators may want to protect other system users from big parallel calculations that hog scarce computational resources.","Useful parallelism is the maximum amount of parallelism that can usefully be applied to a particular computation under particular parallelism limits. Suppose that administrative parallelism limits are set high enough to be ignored. Then useful parallelism would be calculated as the minimum of problem parallelism and physical parallelism.","Parallel Target Examples",{"@attributes":{"id":"p-0397","num":"0434"},"figref":"FIG. 62"},"Line  shows a sequential makefile target that has 100 object file dependencies. As written, Line  will cause the 100 object files to be compiled in sequence.","Line  shows how parallelism can be obtained using the a make program, which is capable of spawning multiple parallel computational processes using sequential targets. GNU Make accepts a control argument \u201c-j N\u201d that specifies the number of parallel processes to spawn. In this example, 4 parallel processes are requested. Thus make would simultaneously build file-.o through file-.o.","Lines \u2013 shows an example set of parallel targets that might be generated by the present makefile generator invention. Line  is the top level target, with 4 dependencies that are the 4 parallel targets.","Lines \u2013 are parallel targets, each responsible for building 25 of the 100 example object files.","Lines \u2013 show how parallel targets can be executed using multiple machines with network filesystem access to the same makefile.","Lines \u2013 show how parallel targets can be executed using multiple shell windows on the same machine.","Lines \u2013 show how parallel targets can be executed using multiple background processes in one window on one machine.","Operation","In operation, module Calculate Collection Parallel Targets  calculates the number of parallel targets for the host collection.","The number of parallel targets to use is calculated by considering the parallelism limit information as described above. The problem parallelism limit corresponds to the number of dependencies on the build target. The physical parallelism limit is unknown (and is thus usually ignored) by the makefile generator, which is responsible only for generating the makefile and not for executing the makefile in particular hardware computing environments containing unknown parallel resources. The administrative parallelism limit is obtained from the collection type definition, because maximum administrative parallelism can be effectively represented as a characteristic property of a collection type. For example, a \u201cct-program-parallel\u201d collection type could be defined.","The number of parallel targets required is calculated by dividing the total number of dependencies (the inherent problem parallelism) by the administrative parallelism limit obtained from a collection type definition such as  Line .","The names of parallel targets are constructed by using substitution strings in fragment templates.  shows a more detailed version of the file processing fragment of FIG. , but here extended with more fragments for constructing parallel targets. Line  uses the \u201c_zpln_\u201d (parallel number) substitution string to define a makefile macro for holding the names of all object files for all parallel targets for one collection product. Line  uses \u201c_zpln_\u201d to define a product-specific macro for holding the names of all object files for one parallel target. Line  uses \u201c_zpln_\u201d to define the names of parallel build targets.",{"@attributes":{"id":"p-0409","num":"0446"},"figref":["FIG. 64","FIG. 63"]},"Parallel Targets for Multiple Products","Parallel targets have been described for building a whole collection using a top level \u201cbuild\u201d target, under the control of module Calculate Collection Parallel Targets .","The mechanism for generate parallel targets for multiple products is identical but for several trivial changes. First, module Calculate Product Parallel Targets  is used at the product level instead of module Calculate Collection Parallel Targets  at the collection level. Second, product-specific target names based on the \u201c_mprod_\u201d substitution string are used instead of the collection-level \u201cbuild\u201d target name. For example, target names such as shown in  Line  are extended by adding a parallel number substitution string such as \u201c_zpln_\u201d to the target name. Third, new macro names for holding object files such as those shown in  Line  and Line  are extended by adding a parallel number substitution string such as \u201c_zpln_\u201d to the macro name.",{"@attributes":{"id":"p-0412","num":"0449"},"figref":"FIG. 65"},"Further Advantages","As can be seen from the foregoing disclosure, fully automated makefile generators provide a scalable, fully-automated way of generating parallel target makefiles for processing collections. In addition, the four-level type hierarchy provides a flexible, extensible means for implementing local site makefile generation policies. Thus makefile generators provide a very useful service to humans and application programs that want to process collections automatically.","The present Collection Makefile Generator invention provides practical solutions to nine important makefile generation problems faced by builders of automated collection processing systems. The problems are: (1) the general collection makefile generator problem, (2) the multiple product build order problem, (3) the product file build order problem, (4) the include file directory problem, (5) the library file directory problem, (6) the multiple product naming problem, (7) the makefile parallel processing problem, (8) the template sharing problem, and (9) the makefile customization problem.","As can be seen from the foregoing disclosure, the present collection makefile generator invention provides automated collection processing systems with a competent, industrial-strength means for generating complex parallel makefiles in a convenient, automated, and scalable way that was not previously possible.","Although the foregoing descriptions are specific, they should be considered as sample embodiments of the invention, and not as limitations. Those skilled in the art will understand that many other possible ramifications can be imagined without departing from the spirit and scope of the present invention.","General Software Ramifications","The foregoing disclosure has recited particular combinations of program architecture, data structures, and algorithms to describe preferred embodiments. However, those of ordinary skill in the software art can appreciate that many other equivalent software embodiments are possible within the teachings of the present invention.","As one example, data structures have been described here as coherent single data structures for convenience of presentation. But information could also be could be spread across a different set of coherent data structures, or could be split into a plurality of smaller data structures for implementation convenience, without loss of purpose or functionality.","As a second example, particular software architectures have been presented here to more strongly associate primary algorithmic functions with primary modules in the software architectures. However, because software is so flexible, many different associations of algorithmic functionality and module architecture are also possible, without loss of purpose or technical capability. At the under-modularized extreme, all algorithmic functionality could be contained in one software module. At the over-modularized extreme, each tiny algorithmic function could be contained in a separate software module.","As a third example, particular simplified algorithms have been presented here to generally describe the primary algorithmic functions and operations of the invention. However, those skilled in the software art know that other equivalent algorithms are also easily possible. For example, if independent data items are being processed, the algorithmic order of nested loops can be changed, the order of functionally treating items can be changed, and so on.","Those skilled in the software art can appreciate that architectural, algorithmic, and resource tradeoffs are ubiquitous in the software art, and are typically resolved by particular implementation choices made for particular reasons that are important for each implementation at the time of its construction. The architectures, algorithms, and data structures presented above comprise one such conceptual implementation, which was chosen to emphasize conceptual clarity.","From the above, it can be seen that there are many possible equivalent implementations of almost any software architecture or algorithm, regardless of most implementation differences that might exist. Thus when considering algorithmic and functional equivalence, the essential inputs, outputs, associations, and applications of information that truly characterize an algorithm should also be considered. These characteristics are much more fundamental to a software invention than are flexible architectures, simplified algorithms, or particular organizations of data structures.","Practical Applications","A collection makefile generator can be used in various practical applications.","One possible application is to improve the productivity of human computer programmers, providing them with an automated means of generating makefiles to replace their current manual methods.","Another possible application is in integrated development environments, which could use a collection makefile generator to generate makefiles for collections being worked on by the integrated development system.","Type Information Hierarchy","A four-level collection type definition information hierarchy was presented here, but other organizations of type information are also possible. One example is a linear type definition organization, such as shown in . Another example is a three-level hierarchy that has no action types, or no content types. Another example is a five-level hierarchy that supports sub-products of products.","Type definition hierarchies are stored externally outside collection subtrees in preferred implementations, but other implementations are also possible. One example is storing type information internally, within the main collection subtree. Another example is storing type definition information within a collection specifier file. Another example is storing type definition information in a relational database format, either inside or outside the collection boundaries.","Makefile Fragments","The preferred embodiment described above represented makefile fragments as simple text files. However, other methods of representing fragments are also possible. One example is to use the SGML (Standard Generalized Markup Language) language, which has greater expressive power and stronger syntax conventions than text files. Another example is to use the XML language, which is simpler than SGML, but which still has greater expressive power and stronger syntax conventions than text files. Another example is to use a relational database to store fragments, which would allow the use of standard query languages to manipulate fragments.","The preferred embodiment described above assembled an output makefile by adding fragments to a simple \u201clinked list of lines\u201d data structure in computer memory. However, other methods of assembling an output makefile are also possible. One example is to store makefile lines in database records. Another example is to perform fragment additions using an external disk file to store the output makefile. Another example is to use an external program to perform fragment additions. Another example is to use an external makefile assembly server that maintains an internal, persistent copy of the output makefile during construction, and which passes back the constructed makefile on demand.","Virtual Platforms","The preferred embodiment described above uses a four-level virtual platform hierarchy to organize makefile fragment information into specific, generic, family, and platform independent operating system categories. However, other organizational schemes are also possible. One example is to use a linear structure that aggregates related information into fewer fragments, but that still permits sharing. Another example is to use a hierarchical structure organized by company, department, team, and individual.","Standalone Makefile Services","The preferred embodiment described above uses standalone makefile services comprised of single lines within collection specifiers. However, other methods are also possible. One example is to use multi-line standalone services. Another example is to use named standalone makefile services that are stored outside collection specifiers.","Simplifications","The preferred embodiment described above contains several advanced features that help to improve human productivity in various ways. However, advanced features are not always required, and simpler embodiments are possible. One example is to omit parallel makefile targets. Another example is to omit multiple product support within collections. Another example is to omit virtual platform sharing support. Another example is to use a simpler type definition hierarchy more suited to simpler processing situations that contain less process variance within the processing environment.","As can be seen by one of ordinary skill in the art, many other ramifications are also possible within the teachings of this disclosure. Collection makefile generators use collection information and makefile fragment information to generate precisely customized, high-performance makefiles for processing collections, in an automated, scalable way that was not previously available.","The full scope of the present invention should be determined by the accompanying claims and their legal equivalents, rather than from the examples given in the specification."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["100","102","5"]},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 3","b":"102"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 4","b":["101","102","103","100"]},{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 6","b":["111","110","107","101","103"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 7","b":["110","111","112","114","115","117"]},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 11","b":"120"},{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 12","b":"120"},{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 13","b":"130"},{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 14","b":"130"},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 15","b":"140"},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 16","b":"140"},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 17","b":"150"},{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 18","b":"150"},{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 19","b":"160"},{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 20","b":"160"},{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0103","num":"0102"},"figref":["FIG. 22","FIG. 21"]},{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 23","FIG. 23"],"b":"1"},{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 24","FIG. 23"],"b":"2"},{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0110","num":"0109"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0120","num":"0119"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0125","num":"0124"},"figref":["FIG. 44","FIG. 40"]},{"@attributes":{"id":"p-0126","num":"0125"},"figref":["FIG. 45","FIG. 41","FIG. 42"]},{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0128","num":"0127"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0129","num":"0128"},"figref":["FIG. 48","FIG. 46","FIG. 47"]},{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0131","num":"0130"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0136","num":"0135"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0137","num":"0136"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 57"},{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0140","num":"0139"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0141","num":"0140"},"figref":"FIG. 60"},{"@attributes":{"id":"p-0142","num":"0141"},"figref":"FIG. 61"},{"@attributes":{"id":"p-0143","num":"0142"},"figref":"FIG. 62"},{"@attributes":{"id":"p-0144","num":"0143"},"figref":["FIG. 63","FIG. 47"]},{"@attributes":{"id":"p-0145","num":"0144"},"figref":["FIG. 64","FIG. 63"]},{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIG. 65"}]},"DETDESC":[{},{}]}
