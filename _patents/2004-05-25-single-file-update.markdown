---
title: Single file update
abstract: A system and method are described for performing updating of an application using a single file update. In one embodiment, a request from a client is received at a server to amend a deployed application by updating a single file of the application. The request is received at a deploy service of the server. The file to be update is accessed and updated to amend the application. The transaction for successful updating of the file is committed to a database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07882502&OS=07882502&RS=07882502
owner: SAP AG
number: 07882502
owner_city: Walldorf
owner_country: DE
publication_date: 20040525
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","This invention relates generally to the field of application deployment. More particularly, an embodiment relates to a system and method for performing application update by using a single file update.","2. Description of the Related Art","Traditional client-server systems employ a two-tiered architecture such as that illustrated in . Applications  executed on the client-side  of the two-tiered architecture are comprised of a monolithic set of program code including a graphical user interface (GUI) component, presentation logic, business logic and a network interface that enables the client  to communicate over a network  with one or more servers . A database  maintained on the server  provides non-volatile storage for the data accessed and\/or processed by the application .","As is known in the art, the \u201cbusiness logic\u201d component of the application represents the core of the application, i.e., the rules governing the underlying business process (or other functionality) provided by the application. The \u201cpresentation logic\u201d describes the specific manner in which the results of the business logic are formatted for display on the user interface. The \u201cdatabase\u201d  includes data access logic used by the business logic to store and retrieve data.","The limitations of the two-tiered architecture illustrated in  become apparent when employed within a large enterprise. For example, installing and maintaining up-to-date client-side applications on a large number of different clients is a difficult task, even with the aid of automated administration tools. Moreover, a tight coupling of business logic, presentation logic and the user interface logic makes the client-side code very brittle. Changing the client-side user interface of such applications is extremely hard without breaking the business logic, and vice versa. This problem is aggravated by the fact that, in a dynamic enterprise environment, the business logic may be changed frequently in response to changing business rules. Accordingly, the two-tiered architecture is an inefficient solution for enterprise systems.","In response to limitations associated with the two-tiered client-server architecture, a multi-tiered architecture has been developed, as illustrated in . In the multi-tiered system, the presentation logic , business logic  and database  are logically separated from the user interface  of the application. These layers are moved off of the client  to one or more dedicated servers on the network . For example, the presentation logic , the business logic , and the database  may each be maintained on separate servers, ,  and , respectively.","This separation of logic components and the user interface provides a more flexible and scalable architecture compared to that provided by the two-tier model. For example, the separation ensures that all clients  share a single implementation of business logic . If business rules change, changing the current implementation of business logic  to a new version may not require updating any client-side program code. In addition, presentation logic  may be provided which generates code for a variety of different user interfaces , which may be standard browsers such as Internet Explorer\u00ae or Netscape Navigator\u00ae.","The multi-tiered architecture illustrated in  may be implemented using a variety of different application technologies at each of the layers of the multi-tier architecture, including those based on the Java 2 Platform, Enterprise Edition\u2122 (J2EE) standard, the Microsoft NET standard and\/or the Advanced Business Application Programming (ABAP) standard developed by SAP AG.","For example, in a J2EE environment, such as the one illustrated in , the business layer  is to handle the core business logic of the application having Enterprise JavaBean\u2122 (EJB or enterprise bean) components with support for EJB containers . While the presentation layer  is responsible for generating servlets and Java ServerPages\u2122 (JSP or JSP pages) interpretable with support for Web containers  by different types of browsers at the client  via a web server  a network  (e.g., Internet or intranet).","The J2EE engine  is a tool commonly used in software development and deployment today. Generally, using the J2EE engine  reduces the costs and complexity associated with developing multi-tier enterprise services. Another advantage of J2EE engine  is that it can be relatively rapidly deployed and enhanced as the need arises. J2EE engine  is currently used in many large-scale application development and deployment projects for these reasons.","However, as application development projects grow larger and are diversified, deployment of applications becomes increasingly important. For example, it is useful to have an improved deployment service and management including a variety of containers, application interfaces, transaction management and modules, notification and information status systems, file updates, application updates and duplications, partial application deployments, resource pooling, and security checks.","A system and method are described for performing updating of an application using a single file update. In one embodiment, a request from a client is received at a server to amend a deployed application by updating a single file of the application. The request is received at a deploy service of the server. The file to be update is accessed and updated to amend the application. The transaction for successful updating of the file is committed to a database.","Described below is a system and method for updating an application by using a single file update. Throughout the description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.","In the following description, numerous specific details such as logic implementations, opcodes, resource partitioning, resource sharing, and resource duplication implementations, types and interrelationships of system components, and logic partitioning\/integration choices may be set forth in order to provide a more thorough understanding of various embodiments of the present invention. It will be appreciated, however, to one skilled in the art that the embodiments of the present invention may be practiced without such specific details, based on the disclosure provided. In other instances, control structures, gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate functionality without undue experimentation.","Various embodiments of the present invention will be described below. The various embodiments may be performed by hardware components or may be embodied in machine-executable instructions, which may be used to cause a general-purpose or special-purpose processor or a machine or logic circuits programmed with the instructions to perform the various embodiments. Alternatively, the various embodiments may be performed by a combination of hardware and software.","Various embodiments of the present invention may be provided as a computer program product, which may include a machine-readable medium having stored thereon instructions, which may be used to program a computer (or other electronic devices) to perform a process according to various embodiments of the present invention. The machine-readable medium may include, but is not limited to, floppy diskette, optical disk, compact disk-read-only memory (CD-ROM), magneto-optical disk, read-only memory (ROM) random access memory (RAM), erasable programmable read-only memory (EPROM), electrically erasable programmable read-only memory (EEPROM), magnetic or optical card, flash memory, or another type of media\/machine-readable medium suitable for storing electronic instructions. Moreover, various embodiments of the present invention may also be downloaded as a computer program product, wherein the program may be transferred from a remote computer to a requesting computer by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","200","200","210","220","230","210","220","230","200","200"]},"The distributed services level  serves as an interface between the JMA  and one or more users or clients. As illustrated, the distributed services level  includes one or more user terminals -. One or more of the user terminals - to collect and gather user input and send it to the agent level  over a network connection. Network connection may be a wired or wireless connection to a LAN, a Wide Area Network (WAN), a Metropolitan Area Network (MAN), an intranet, and\/or the Internet. Distributed services level terminals - include personal computers, notebook computers, personal digital assistants, telephones, and the like. According to one embodiment in which the network connection connects to the Internet, one or more of the user terminals - may include a Web browser (e.g., Internet Explorer or Netscape Navigator) to interface with the Internet.","According to one embodiment, the distributed services level  also includes management applications , such as a JMX-compliant management application, a JMX manager, and\/or a proprietary management application. The management applications  also include one or more graphical management applications, such as a visual administrator, operating to, for example, retrieve and display information received from the agent level  and\/or the instrumentation level .","The visual administrator includes a monitor viewer to display such and other information. The monitor viewer may be GUI-based or Web-based monitor viewer. Management applications  may include third party tools including a file system to store the information. The distributed services level  includes the CCMS system described above.","The agent level  includes one or more application servers -. An application server may refer to a computing device that performs data processing. The agent level  also includes a computing device (e.g., a dispatcher) to perform load balancing among application servers -. According to one embodiment in which the agent level  exchanges information with the distributed services level  via the Internet, one or more of the application servers - include a Web application server. According to one embodiment, the application servers - are implemented in accordance with J2EE v1.3, final release Sep. 24, 2001, published on Jul. 18, 2002 (the J2EE Standard). An update of J2EE v1.3 was recently released, on Nov. 24, 2003, as J2EE v1.4. In one embodiment, the management techniques described herein are used to manage resources within a \u201ccluster\u201d of server nodes. An exemplary cluster architecture is described below with respect to . However, the underlying principles of the invention are not limited to any particular application server architecture.","The applications servers - may include one or more dedicated Java Managed Bean (MBean or managed bean) servers having agent services. According to one embodiment, for and at each Java virtual machine (JVM) with managed resources, there may be one or more agents operating at the agent level . The one or more agents include one or more MBean servers, agent services, a set of MBeans, one or more connectors, and\/or one or more protocol adaptors. An MBean Server includes a registry for MBeans and acts as a single entry point for calling MBeans in a uniform fashion from management applications at other JVMs.","The instrumentation level  provides a data storage medium for the JMA . As illustrated, according to one embodiment, the instrumentation level  includes one or more database management systems (DBMS) - and data sources -. According to one embodiment, the data sources - may include databases and\/or other systems capable of providing a data store. Furthermore, the instrumentation level  includes one or more hosts including one or more resources having MBeans, such as instrumentation MBeans. The instrumentation level  may make Java objects available to management applications . The Java objects instrumented according to the JMX-standard may include MBeans. The resources represented by MBeans include managed resources , including a kernel, a server component, or the like. MBeans may expose a management interface including constructors, attributes, operations, and notifications.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["300","314","304","306","328","340","342","300","314","304","306","350","350","314","304","306","348","320","306","348","324"]},"The J2EE containers - and the client application  are, directly or indirectly, in communication with the database , located at the Enterprise Information Systems (EIS) tier  of the multi-tiered J2EE architecture . The database  may include one or more database servers, EJB servers, old systems, and mySAP components. The client application  may include standard a J2EE application to help facilitate the running of applications in standalone JVMs. Furthermore, the clients may access one or more of the applications via standalone Java programs and programs that help access an application via, for example, using Internet Inter-Object Request Broker Protocol (IIOP)\/Common Object Request Broker Architecture (COBRA) written using any programming language (e.g., \u2212C, C, and C++).","The J2EE containers - in the middle tier  are associated with various J2EE services and APIs , examples of which, include Java Naming Directory Interface (JNDI), Java Database Connectivity (JDBC), J2EE connector Architecture (JCA), Remote Invocation (RMI), Java Transaction API (JTA), Java Transaction Service (JTS), Java Message Service (JMS), Java Mail, Java Cryptography Architecture (JCA), Java Cryptography Extension (JCE), and Java Authentication and Authorization Service (JAAS), and dbpool service. The J2EE services  further include EJB_service, servlet_JSP, application_client_service, connector_service to provide (J2EE containers -, namely) EJB containers, Web containers, application client containers, and connector containers, respectively. It is contemplated the client application  may also be associated with a set of J2EE services and APIs . However, each of the containers - may be associated with a different set of J2EE services. For example, on the client tier , the client application may be associated with different J2EE services  than the J2EE containers - associated with the J2EE services  on the server-side . Furthermore, the client-side  may or may not be J2EE-based.","According to one embodiment, as illustrated, the J2EE server  includes a non-J2EE container  and a set of non-J2EE services and interfaces . An example of a non-J2EE container  and non-J2EE services  may include an SAP container and a set of SAP services and APIs, respectively. The non-J2EE services  include Webdynpro service, log_configurator service, and monitoring service. According to one embodiment, non-J2EE components deployed in the non-J2EE container  may be used to assemble non-J2EE applications (e.g., SAP applications). In one embodiment, the management of the non-J2EE applications is performed during and after deployment, while the assembly of the non-J2EE applications is conducted prior to deployment. According to one embodiment, both the J2EE and non-J2EE containers -,  may have access to the J2EE and non-J2EE services -.","According to one embodiment, some of the non-J2EE services  may include parallel or similar services to the J2EE services . The container API may be used to facilitate registration, unregisteration, implementation, and management of not only the J2EE containers -, but also one or more non-J2EE containers  on the J2EE server . Using a common container API, both the standard J2EE containers - and the non-J2EE containers  may be deployed on the server-side , and the J2EE server , as whole, regards them as the same. Stated differently, when deploying a non-J2EE container , the specific details in the implementation and logic of the non-J2EE container  may be kept hidden from the J2EE server  so all J2EE and non-J2EE containers -,  are to be recognized and regarded the same way as part of the J2EE architecture .","The container API, according to one embodiment, is encapsulated in a service -. This is to, for example, expand the J2EE architecture  to provide a relatively easy implementation and deployment of services, interfaces, and libraries, and to provide one or more non-J2EE containers , which in turn can deploy any non-J2EE components with relative ease using the same infrastructure. The container API may be represented by an interface defined as a development component with the name, e.g., <container_api>. The implementation of container API may be performed using the deploy service.","According to one embodiment, the deploy service may be used as an entry point for extending the J2EE architecture  and for enhancing the functionality of the J2EE engine  by deploying the non-J2EE containers  along with the J2EE containers -. The deploy service may also be used for the deployment of applications, standalone modules (containing both J2EE and non-J2EE components), service, and libraries.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4","b":["400","404","406","402","402","404","406","404","416","406","418","406","418"]},"The J2EE architecture  further includes connectors  to provide standard services and APIs to connect the J2EE server  and its elements with the rest of the J2EE architecture . The connectors  may be J2EE or non-J2EE based. The J2EE architecture  also includes a JVM  to process platform-independent bytecode into platform-specific native code or binary machine code at runtime. The binary machine codes is executed on a hardware  using an operating system . The operating system  may include Microsoft Windows\u00ae, Macintosh, Unix, Linux, and the like. The hardware  may include a computer processing unit, a storage device, a random access memory, and the like.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":["500","524","524","500","524","518","514","516","510","512","518"]},"Serving as an entry point for expanding and enhancing the J2EE architecture , the deploy service  is also used for correct distribution of the deployable entities to their services\/containers and a storage place. The storage place is retrieved from configuration manager in the database and the deploy service  is to facilitate the storage of all applications so that the containers - may rely on a consistent storage for the entire application. The application components - and standalone modules are managed by the containers -, the libraries, services, and interfaces are managed by server's deploy context, which is located at a deeper level in the core of the server because these deployable components are used by applications - found on a higher level in the J2EE architecture . Stated differently, deploy service  is used to manage an entire application -, the container - is used to manage the applications' components -, and the deploy context is used to manage the server components, such as the libraries, services and interfaces. According to one embodiment, the deploy service  may obtain the deploy context using its application service context.","According to one embodiment, the container API  provides a container interface  that is implemented by container services associated with the containers - (e.g., com.sap.engine.services.deploy.container.ContainerInterface). Such implementation is to facilitate the deploy service  to identify and process various actions on those containers - that are implemented according to a set of rules including the implementation of the container API  by container services. A container service may listen for the availability of the container interface by implementing a container event listener (e.g., com.sap.engine.frame.container.event.ContainerEventListener).","The container API  provides a container management for registration of containers - by container services when an event indicating the availability of the container API  (e.g., <container_api>) is received or listened to by a container service via the container event listener. The container service may then register the container - using container management. In contrast, when a container - is rendered not available that container - is unregistered using the container management (e.g., <com.sap.engine.services.deploy.container.ContainerManagement>). Stated differently, the contianer services are provided with an opportunity to register their corresponding containers - with the conatiner API  and the deploy service  when the continers - become available and are ready to to perform deployment operations. In contrast, the containers - may be unregsitered when once they stop or become unavailable.","According to one embodiemnt, the container API  also incldues deploy communicator  in combination with the container interface . The availability of the deploy communciator  allows the deploy service  and the containers - to communicate bi-directionally. Stated differently, using the container interface , the information flows from the deploy service  to the containers -. Each of the containers - may obtain an instance of the deploy communicator  during its registration to communicate back with the deploy service .","Using the deploy communicator , the information may flow from the containers to the deploy service . Such information may include information relating to the status, requesting runtime information, initiating operations from containers -, etc., flowing back to the deploy service . Such information allows the deploy service  to be more efficient by, for exmaple, allowing the containers - to request to lock the application or changes that may occur due to some property changes in the container -, or by having the deploy service  request the changes by update. Another exmaple includes allowing a container - to stop its deployed applications in the container service stop method, since applications are usually consisting of more than one component and the deploy service  may know the entire configuration of an application.","According to one embodiment, the instance of <container info> including information for identification of a container - may have a set of properties with set\/get methods. Some of the properties include: (1) determination of whether a container - is a J2EE container  (e.g., EJB, Web, application, client, resource adapter) or a non-J2EE container  (e.g., SAP container); (2) for J2EE containers , specification of the type of the components  deployed (e.g., String j2eeModuleName); (3) for non-J2EE containers , specification of the type of the components  deployed (e.g., String moduleName); (4) for specification of the priority of a container - (e.g., when an application is being deployed, stopped, and started), the deploy service  knows in what order to notify the concerned containers -. During deployment and start of an application, the containers - having higher priority are notified first, and during stop of an application the containers - with lower priority are first notified (e.g., int priority); (5) specification of a container's unique name (e.g., String name); (6) specification of a set of extensions of files which represents components - deployed on the respective containers - (e.g., String [ ] fileExtentions); (7) specification of a set of names of files which represent components - deployed on the respective containers - (e.g., String [ ] filenames); (8) specification of the name of the service that provides the container (e.g., String [ ] serviceName); (9) determination of whether the container - supports the operation \u201csingle file update\u201d (e.g., Boolean supportsSingleFileUpdate); and (10) specification of the kind of resource types that are supported by the container (e.g., String [ ] resourceTypes).","According to one embodiment, filenames and extensions may be used by the deploy service  for distribution of the deployable deploy components - on the containers -. The deploy service  may include a mechanism for automatic recognition of the container - to which the corresponding deploying components - may be distributed, in accordance with the filenames and extensions contained in the <container info> of each of the containers -. For example, if a standalone module file has an extension Web Archive (e.g., WAR or war) and the J2EE Web container has specified this extension in its <container info>, the deploy service  may distribute the WAR file to the Web container.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 6","b":["600","600","602","614","602"]},"In one embodiment, the process of single file update may include removing of the file to be updated from an application, updating of the file, and deploying of the file. In another embodiment, the application is removed for updating the file and after the updating of the file, the application is re-deployed. The process of deployment may include: (1) configuration; (2) distribution; and (3) execution. To perform configuration, the client , as a deployer, may follow the assembly instructions provided, for example, by the application assembler and help resolve any external dependencies declared by the application component provider. For distribution, the application archive and the deployment configuration information may be installed on various servers in the clusters via a deployment application programming interface (API). The execution includes making of a request  by a client  with a deploy service  at server A  via a deploy service API  using a deploy tool . The request  is for updating one or more files of an already deployed application.","Partially updating an application with specified files from its components is useful during development, because it might not require a full restart of the application. In one embodiment, the updating of an application with specified files from the components of the application is used in cases when the changes are minimal (e.g., changes in only a few files) and it may not be necessary to rebuild the entire Enterprise ARchive (e.g., EAR or ear) file. According to one embodiment, a transaction scheme for updating a single file may include receiving a request  at a deploy service  via a deploy service API  from a client . In response to the request , the deploy service  communicates with the container  via a container API  to update the file. The update to the file is made at the container  working with the deploy service . Once the update is made, the transaction relating to the successful updating the single file is committed  to the database . Once the transaction is committed  to the database , the deploy service  at server A  notifies  other servers B and C - in the cluster of the successful updating of the file and application. The other servers B and C - may then update information (e.g., the application) at servers B and C -, in accordance with the contents and status of the updated application, by accessing the updated information on the database .","In one embodiment, the deploy service API  and the container API  invoke certain methods to facilitate the updating of one or more files of an application using the deploy service  and the container . The deploy service API  may use the following methods: (1) <public void singleFileUpdate(FileUpdateInfo[ ] files, String appName, Properties props) throws java.rmi.RemoteException>; and, (2) <public void singleFileUpdate(FileUpdateInfo[ ] files, String providerName, String appName, Properties props) throws java.rmi.RemoteException>.","The container API , according to one embodiemnt, may use the following six methods: (1) <public boolean needStopOnSingleFileUpdate(FileUpdateInfo[ ] files, ContainerDeploymentInfo dInfo, Properties props) throws DeploymentException, WarningException> (method one); (2)<public ApplicationDeployInfo makeSingleFileUpdate(FileUpdateInfo[ ] files, ContainerDeploymentInfo dInfo, Properties props) throws DeploymentException> (method two); (3)<public void prepareSingleFileUpdate(String applicationName) throws DeploymentException, WarningException> (method theree); (4) <public ApplicationDeployInfo commitSingleFileUpdate(String applicationName) throws WarningException> (method four); (5)<public void rollbackSingleFileUpdate(String applicationName, Configuration config) throws WarningException> (method five); and, (6) <public void notifySingleFileUpdate(String applicationName, Configuration config, Properties props) throws WarningException> (method six).","Method one checks to verify whether the application needs to be restarted to updated its one or more specified files. The parameter used may include \u201cfiles\u201d for holding the information about the files that are to be updated and \u201cdinfo\u201d may function as <containerdeploymentinfo> during the deployment and \u201cprops\u201d may represent properties holding information necessary for the process of update the file. The properties may be unlimited and specific for each container . A true signal is returned if one of the files to be updated is such that it may be necessary or desirable to stop the application before the performing of the update. A false signal is returned if the stopping of the application is not necessary or desirable. If the application is stopped, it may be automatically started after the update process.","For method one, the exceptions may include deployment exception (e.g., <DeploymentException>) and warning exception (e.g., <WarningException>). The deployment exception is triggers if one or more errors occur during a check of the file to be update or when an update could not be performed for the selected file. At deployment exception, the process is stopped. The warning exception is triggered when an error of little importance occurs during the check. The process may continue despite the exception.","Method two, in one embodiment, facilitates the performing of the update of a single file of the application on the container . The parameters are the same as for method one. Information returns about application components needed for the deploy service and provided from the container \u2014the same as the returned result of during deployment. A deployment exception is thrown if an error occurs during the check or if the update could not be performed for the selected files. In case of the deployment exception, the deploy operation is rolled back. On all corresponding containers  that have gone through <makeSingleFileUpdate( ) rollbackSingleFileUpdate( )> is invoked to notify the failure of the operation.","Method three is regarded as the prepare (or preparation) step of the update procedure where the application integrity is checked. This may be the last method to cause unsuccessful update of the selected files and rolling back of the deploy operation, because once a transaction is committed , it may not be rolled back to its previous step. The parameter used may include the name of the updated application. A deployment exception may be thrown if an error occurs during the check or if the update of the selected file could not be performed. If the deploy exception is triggered, the deploy operation may be rolled back. On all corresponding containers  that have gone through <makeSingleFileUpdate( ), rollbackSingleFileUpdate( )> is invoked to notify the failure of the operation. The warning exception is thrown if an error of little importance occurs during the check. The process may continue despite the warning exception.","Method four facilitates providing a confirmation about the successful completion of the updating of the single file. The updating of the file includes successful completion of the updating of the components from the application, and the initiation and availability of the components for use. The only parameter used may be the name of updated application. The information return may be provided about the application components needed for the deploy service  and provided from the container . The status for the application components may be regarded as final and committed  to the database . A warning exception may be thrown if an error of little importance occurs during the update of the file; however, the process may still be regarded as successful.","Method five relates to providing the rollback notification  regarding the failure of the updating of the specified file. The failure in updating the file (e.g., failure in updating the application or components) may occur at the makeSingleFileUpdate or the prepareSingleFileUpdate phase, at which point, and in response to the failure, the application may revert back (e.g., roll back) to its previous state. In one embodiment, the updating of the file may not fail or be unsuccessful once it is committed  to the database . The parameters for method five may include application name representing the name of the application to be updated and configuration representing the configuration of the application and opened for WRITE access. A warning exception may be thrown if an error of little importance occurs during the rollback. The rollback refers to the rolling back of the file updating process or of a deploy operation when an error or exception has occurred. In case of a rollback, the client  receives an exception  from the server A .","Once the updating of the file is (successfully) completed and committed  to the database , using method six, other servers B and C - in the cluster are notified of the changes to the application. The client  is then notified of the completion and that the request  has been fulfilled. The parameters used for method six are application name representing the name of the updated application and configuration representing the configuration for the application and opened for READ access. The parameters may also include props represnting properties holding information necessary for the process of performing the update of the file. The properties may be unlimited and specific for each container . A warning exception may be thrown if an error of little importance occurs during the update process.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 7","b":["700","702","714","704","716","718","706","720"]},"In case of a failure of file update  or of application integrity during the check , the transaction may be rolled back to its previous state. A notification  regarding the rollback is then submitted to the deploy service at server A  to be forwarded as an exception  to the client . If, however, the file update  is completed and the check  is successfully performed, the transaction is committed  to the database . A notification  regarding the commitment is then sent to the deploy service at server A . Once the notification  is received (or once the deploy service at server A  becomes aware of the commitment ), a result  is compiled and forwarded to the client . The deploy service at server A  also provides notification - of the commitment to other servers B and C - in the cluster. The notification - of the commitment includes informing the servers B and C - of the updating of the application so that the servers B and C - may access the updated information from the database  to synchronize the information on the servers B and C - with the update information on the database .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 8","b":["802","804","806","808"]},"At decision block , a determination is made as to whether the file update has been successfully completed and\/or the application integrity is up to the specified or acceptable level of integrity required or needed. In case of a failure with regard to the file update or if the application integrity is below the expected level of integrity, the transaction for updating the file is rolled back to its previous state at processing block . On the other hand, if the file update is performed successfully and the application integrity is satisfactory, the transaction is committed to a database at processing block . Once the transaction is committed, the server, where the transaction was performed, provides notification of the commitment to other servers present in the cluster at processing block . By providing the notification, other servers become aware of the changes in the application by accessing the amended application or related information on the database and use that information to synchronize the applications stored on the other servers with the amended application on the database.","At processing block , a determination is made as to whether the application needs a start. The application may need a start if it was previously stopped at processing block . If the start is needed, the application is started at processing block . If the start is not needed (e.g., the application was not stopped before update at processing block ), the process may continue at processing block . At processing block , a result or exception is then provided to the client to complete the process by fulfilling the client's request. The result is provided if the transaction is committed to the database (e.g., file update is successfully completed). The exception is provided if the transaction is not committed to the database (e.g., the file update fails due to an error or lack or proper integrity). The client may receive the result and\/or exception using various administrative tools, including the deploy tool, and may view the information using a viewer including a GUI-based or Web-based viewer.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 9A","FIG. 9B"],"b":["902","902","904","906","906","908","908","910","910","912"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 9B","FIG. 9A"],"b":["910","950","950","952","954","956","958","960","962","950","964","952","958","966"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 10","b":["1000","1020","1000","1004","1018","1018","1016","1018","1018","1018","1004","1018"]},"As illustrated, the J2EE connector architecture  includes a resource adapter , also referred to as a component, to provide connectivity to a specific EIS or EIS system . The resource adapters  are provided by various EIS vendors. The J2EE connector architecture  may also include various J2EE or non-J2EE products to allow the resources adapters  to be plugged in to the platform implementation. A resource adapter  may be stored in a Resource Adapter Archive (RAR) file and deployed on a J2EE server, similar to an EAR file of a J2EE application. Also, the RAR file may be contained in an EAR file or it may exist as a separate file.","According to one embodiment, a deploy service  communicates with various containers , each having application components , via a container API . The deploy service  facilitates the management of the container  and of the application assembled using the application component . The deploy service  and the container  communicate with the resource adapter  via application contracts or APIs -. The resource adapter  is then used by the deploy service  and the container  to communicate with the EIS . Similarly, the mangers or services  are linked with the resource adapter  via an API or services contract  to link the EIS  with various services, such as security, transaction, and connectivity, managed by the server. The APIs - are implemented by the resource adapter .","A system architecture according to one embodiment of the invention is illustrated in . The architecture includes a central services instance  and a plurality of application server instances , . As used herein, the application server instances,  and , each include a group of server nodes , ,  and , , , respectively, and a dispatcher, , , respectively. The central services instance  includes a locking service  and a messaging service  (described below). The combination of all of the application server instances ,  and the central services instance  is referred to herein as a \u201ccluster.\u201d Although the following description will focus solely on instance  for the purpose of explanation, the same principles apply to other instances such as instance .","The server nodes , ,  within instance  provide the business and\/or presentation logic for the network applications supported by the system. Each of the server nodes , ,  within a particular instance  may be configured with a redundant set of application logic and associated data. In one embodiment, the dispatcher  distributes service requests from clients to one or more of the server nodes , ,  based on the load on each of the servers. For example, in one embodiment, the dispatcher  implements a round-robin policy of distributing service requests.","The server nodes , ,  may be Java 2 Enterprise Edition (\u201cJ2EE\u201d) server nodes which support Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). Of course, the embodiments of the invention described herein may be implemented in the context of various different software platforms including, by way of example, Microsoft NET platforms and\/or the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG, the assignee of the present application.","In one embodiment, communication and synchronization between each of the instances ,  is enabled via the central services instance . As illustrated in , the central services instance  includes a messaging service  and a locking service . The message service  allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via the messaging service  (e.g., such as the cache configuration messages described below). Alternatively, messages may be addressed directly to specific servers within the cluster (i.e., rather than being broadcast to all servers).","In one embodiment, the locking service  disables access to (i.e., locks) certain specified portions of configuration data and\/or program code stored within a central database  or resources shared in the cluster by different services. The locking manager locks data on behalf of various system components which need to synchronize access to specific types of data and program code (e.g., such as the configuration managers , ). As described in detail below, the locking service enables a distributed caching architecture for caching copies of server\/dispatcher configuration data.","In one embodiment, the messaging service  and the locking service  are each implemented on dedicated servers. However, the messaging service  and the locking service  may be implemented on a single server or across multiple servers while still complying with the underlying principles of the invention.","As illustrated in , each server node (e.g., , ) includes a lock manager ,  for communicating with the locking service ; a cluster manager ,  for communicating with the messaging service ; and a configuration manager ,  for communicating with a central database  (e.g., to store\/retrieve configuration data as described herein). Although the lock manager , , cluster manager ,  and configuration manager ,  are illustrated only with respect to server nodes  and  in , each of the server nodes , ,  and  and\/or on the dispatchers ,  may be equipped with equivalent lock managers, cluster managers and configuration managers while still complying with the underlying principles of the invention.","Referring now to , in one embodiment, configuration data  defining the configuration of the central services instance  and\/or the server nodes and dispatchers within instances  and , is stored within the central database . By way of example, the configuration data may include an indication of the kernel, applications and libraries required by each dispatcher and server; network information related to each dispatcher and server (e.g., address\/port number); an indication of the binaries required during the boot process for each dispatcher and server, parameters defining the software and\/or hardware configuration of each dispatcher and server (e.g., defining cache size, memory allocation, . . . etc), and various other types of information related to the cluster. It should be noted, however, that the underlying principles of the invention are not limited to any particular set of configuration data.","In one embodiment of the invention, to improve the speed at which the various servers and dispatchers access the configuration data, the configuration managers ,  cache configuration data locally within configuration caches , . As such, to ensure that the configuration data within the configuration caches ,  remains up-to-date, the configuration managers ,  implement cache synchronization policies, as described herein.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 13","b":["1300","1300","1302","1306","1302","1306","1302","1306","1312"]},"Processor bus , also known as the host bus or the front side bus, may be used to couple the processors - with the system interface . Processor bus  may include a control bus , an address bus , and a data bus . The control bus , the address bus , and the data bus  may be multidrop bi-directional buses, e.g., connected to three or more bus agents, as opposed to a point-to-point bus, which may be connected only between two bus agents.","System interface  (or chipset) may be connected to the processor bus  to interface other components of the system  with the processor bus . For example, system interface  may include a memory controller  for interfacing a main memory  with the processor bus . The main memory  typically includes one or more memory cards and a control circuit (not shown). System interface  may also include an input\/output (I\/O) interface  to interface one or more I\/O bridges or I\/O devices with the processor bus . For example, as illustrated, the I\/O interface  may interface an I\/O bridge  with the processor bus . I\/O bridge  may operate as a bus bridge to interface between the system interface  and an I\/O bus . One or more I\/O controllers and\/or I\/O devices may be connected with the I\/O bus , such as I\/O controller  and I\/O device , as illustrated. I\/O bus  may include a peripheral component interconnect (PCI) bus or other type of I\/O bus.","System  may include a dynamic storage device, referred to as main memory , a RAM, or other devices coupled to the processor bus  for storing information and instructions to be executed by the processors -. Main memory  also may be used for storing temporary variables or other intermediate information during execution of instructions by the processors -. System  may include a ROM and\/or other static storage device coupled to the I\/O bus  for storing static information and instructions for the processors -.","Main memory  or dynamic storage device may include a magnetic disk or an optical disc for storing information and instructions. I\/O device  may include a display device (not shown), such as a cathode ray tube (CRT) or liquid crystal display (LCD), for displaying information to an end user. For example, graphical and\/or textual indications of installation status, time remaining in the trial period, and other information may be presented to the prospective purchaser on the display device. I\/O device  may also include an input device (not shown), such as an alphanumeric input device, including alphanumeric and other keys for communicating information and\/or command selections to the processors -. Another type of user input device includes cursor control, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to the processors - and for controlling cursor movement on the display device.","System  may also include a communication device (not shown), such as a modem, a network interface card, or other well-known interface devices, such as those used for coupling to Ethernet, token ring, or other types of physical attachment for purposes of providing a communication link to support a local or wide area network, for example. Stated differently, the system  may be coupled with a number of clients and\/or servers via a conventional network infrastructure, such as a company's Intranet and\/or the Internet, for example.","It is appreciated that a lesser or more equipped system than the example described above may be desirable for certain implementations. Therefore, the configuration of system  may vary from implementation to implementation depending upon numerous factors, such as price constraints, performance requirements, technological improvements, and\/or other circumstances.","It should be noted that, while the embodiments described herein may be performed under the control of a programmed processor, such as processors -, in alternative embodiments, the embodiments may be fully or partially implemented by any programmable or hardcoded logic, such as field programmable gate arrays (FPGAs), TTL logic, or application specific integrated circuits (ASICs). Additionally, the embodiments of the present invention may be performed by any combination of programmed general-purpose computer components and\/or custom hardware components. Therefore, nothing disclosed herein should be construed as limiting the various embodiments of the present invention to a particular embodiment wherein the recited embodiments may be performed by a specific combination of hardware components.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 14","FIG. 13","FIG. 13","FIG. 13"],"b":["1400","1400","1402","1302","1306","1404","1316","1406","1330","1408","1410","1412","1402","1404"]},"The J2EE architecture  may include a deploy service to update a single file based on various J2EE and non-J2EE containers, components, resources, services, and interfaces. The J2EE and non-J2EE components may include executable content, control logic (e.g., ASIC, PLD, FPGA, etc.), firmware, or some combination thereof, in one embodiment of the present invention. In embodiments of the invention in which the J2EE architecture  may include executable content, it may be stored in the memory device  and executed by the control processor .","Memory devices  may encompass a wide variety of memory devices including ROM, EPROM, EEPROM, RAM, non-volatile random access memory (NVRAM), cache memory, flash memory, and other memory devices. Memory devices  may also include one or more hard disks, floppy disks, ZIP disks, compact disks (e.g., CD-ROM), digital versatile\/video disks (DVD), magnetic random access memory (MRAM) devices, and other system-readable media that store instructions and\/or data. Memory devices  may store program modules, such as routines, programs, objects, images, data structures, program data, and other program modules that perform particular tasks or implement particular abstract data types that facilitate system use.","The I\/O devices  may include hard disk drive interfaces, magnetic disk drive interfaces, optical drive interfaces, parallel ports, serial controllers or super I\/O controllers, serial ports, universal serial bus (USB) ports, display device interfaces (e.g., video adapters), network interface cards (NICs), sound cards, modems, and the like. System interconnect or network  may permit communication between the various elements of node . System interconnects  may include a wide variety of signal lines including one or more of memory buses, peripheral buses, local buses, host buses, and bridge, optical, electrical, acoustical, and other propagated signal lines.","It should be appreciated that reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore, it is emphasized and should be appreciated that two or more references to \u201can embodiment\u201d or \u201cone embodiment\u201d or \u201can alternative embodiment\u201d in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined as suitable in one or more embodiments of the invention.","Similarly, it should be appreciated that in the foregoing description of exemplary embodiments of the invention, various features of the invention are sometimes grouped together in a single embodiment, figure, or description thereof for the purpose of streamlining the disclosure aiding in the understanding of one or more of the various inventive aspects. This method of disclosure, however, is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus, the claims following the detailed description are hereby expressly incorporated into this detailed description, with each claim standing on its own as a separate embodiment of this invention.","While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive, and that the embodiments of the present invention are not to be limited to specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The appended claims set forth the features of the invention with particularity. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
