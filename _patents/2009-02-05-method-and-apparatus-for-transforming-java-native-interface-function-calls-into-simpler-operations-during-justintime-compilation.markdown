---
title: Method and apparatus for transforming java native interface function calls into simpler operations during just-in-time compilation
abstract: A method, apparatus, and computer instructions for transforming JAVA Native Interface function calls to constants, internal just-in-time (JIT) compiler operations or simpler intermediate representation. A compiler generates plurality of intermediate representations for a plurality of native interface function calls. During inlining of native code, matching is performed on each native function call (against this list) and a list of native interface function calls is generated. For each native interface function call, a (JIT) call transformer attempts to replace the native interface function call with a constant, internal JIT compiler operation or a simpler intermediate representation depending on the type of native interface function call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07913240&OS=07913240&RS=07913240
owner: International Business Machines Corporation
number: 07913240
owner_city: Armonk
owner_country: US
publication_date: 20090205
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention is related to the following application entitled \u201cMethod and Apparatus for Inlining Native Functions into Compiled Java Code\u201d, Ser. No. 11\/062,293, filed on Feb. 18, 2005.","This application is a continuation of application Ser. No. 11\/062,306, filed Feb. 18, 2005, status allowed.","1. Technical Field","The present invention relates to an improved data processing system. In particular, the present invention relates to Java\u2122 native function calls in a data processing system. Still more particular, the present invention relates to transforming Java\u2122 Native Interface function calls into constants, internal compiler operations or simpler operations in a data processing system.","2. Description of Related Art","In this disclosure, Java\u2122 (\u201cJava\u201d) and all Java-based marks, such a Java virtual machine, JVM\u2122 (\u201cJVM\u201d), Java Native Interface, JNI\u2122 (\u201cJNI\u201d), and Java Development Kit, JDK\u2122 (\u201cJDK\u201d), are trademarks or registered trademarks of Sun Microsystems, Inc., or its subsidiaries in the United States and other countries.","Java is an object oriented programming language and environment focusing on defining data as objects and the methods that may be applied to those objects. Java supports only single inheritance, meaning that each class can inherit from only one other class at any given time. Java also allows for the creation of totally abstract classes known as interfaces, which allow the defining of methods that may be shared with several classes without regard for how other classes are handling the methods. Java provides a mechanism to distribute software and extends the capabilities of a Web browser because programmers can write an applet once and the applet can be run on any Java enabled machine on the Web.","The Java virtual machine (JVM) is a virtual computer component. The JVM allows Java programs to be executed on different platforms as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java run time system. The Java compiler generates Bytecode instructions that are non-specific to particular computer architectures. A Bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is a module in the JVM that alternatively decodes and executes a Bytecode or Bytecodes. These Bytecode instructions are designed to be easy to interpret on any machine and easily translated on the fly into native machine code.","A development environment, such as the Java Development Kit (JDK) available from Sun Microsystems, Inc., may be used to build Java Bytecode from Java language source code and libraries. This Java Bytecode may be stored as a Java application or applet on a Web Server, where it can be downloaded over a network to a user's machine and executed on a local JVM.","The Java run-time environment is specifically designed to limit the harm that a Java application can cause to the system that it is running on. This is especially important with the World Wide Web, where Java applets are downloaded and executed automatically when a user visits a Web page that contains Java applets. Normally one would not want to execute random programs; they might contain viruses, or they might even be potentially malicious themselves and not merely carrying unwelcome code unintentionally. Unless the user specifically allows it (by setting the appropriate flags in the user-interface to the JVM), a Java applet cannot read or write to attached storage devices (except perhaps to a specific, restricted area), nor can it read or write to memory locations (except to a specific, restricted area).","Not only are Java applets designed for downloading over the network, standard Java libraries also specifically support client-server computing. The Java language includes provisions for multi-threading and for network communications. Compared to other languages (such as C), it is much easier to write a pair of programs, one executing locally on the user's computer that is handling the user-interaction, and the other executing remotely on a server, which is performing potentially more sophisticated and processor-intensive work.","While the Java language is designed to be platform-independent and to execute primarily in a secure environment, programmers can extend Java applications through the use of compiled native binary code on the host operating system using C-style calling conventions through the Java Native Interface (JNI). In this fashion, a Java application can have complete access to the host operating system, including reading and writing to attached I\/O devices, memory, etc. Because of this, Java programs can accomplish tasks that are not normally allowed via the JVM at the cost of being platform-specific. However, with a well-designed architecture, a Java language programmer can cleanly isolate the platform-independent portion, and present a clean, platform-independent object API to other Java components while at the same time accomplishing platform-specific tasks.","With the JNI API, parameters and class data residing inside the Java Virtual Machine (JVM) as well as services provided by the JVM are accessible and may be modified. However, since JNI exposes a very platform independent and opaque representation of the JVM, its data and services, overheads exist. The JNI API is typically exposed by a pointer to a table of function pointers (referred to as the JNI environment pointer, or JNIEnv) to JNI function implementations. Although the pointer is essential to JNI's platform independence, the pointer may also be costly because additional branches and table lookups are performed during a JNI function call. The cost of a JNI invocation depends on the type of JNI function being called.","For example, to access string and array parameters passed from Java to native code, special invocations of JNI functions are required. These special invocations cause expensive runtime copy operations to avoid touching the JVM's copy of the data. The JNI API thus provides accessor functions that attempt to increase the chances of native code receiving direct references to underlying JVM data. However, these functions are implemented at the JVM's discretion and the use of these functions places certain restrictions on the programmer's freedom.","For field and method access, JNI function calls are also required to modify objects and access JVM services from the native code. For example, to modify an object's field or call a class's method, a handle to the appropriate data must first be retrieved. This retrieval is typically implemented as a traversal on the JVM's reflective data structures, in addition to expensive string-based signature comparison operations at runtime. This traversal is orders of magnitude slower than direct field accesses in Java. In addition, JNI function calls may stall if a non-asynchronous JVM is performing blocking work.","Other JNI functions have a unique set of overheads similar to JNI functions for field and method access. These JNI functions include functions that instantiate objects, manage references, handle exceptions, support synchronization and reflection, and ones that are in the Java invocation API for embedding JVMs inside native code.","Several attempts have been made to minimize the overhead of JNI function calls. The first of these attempts are programmer-based optimizations in the form of efficient coding techniques when writing native code that uses the JNI API. The JNI specification also provides a set of critical functions that may return direct references to JVM data and objects and suggests ways to avoid calling into JNI API, for example, caching field and method IDs during static initialization of classes.","Another attempt involves removing native function related overheads by minimizing dependencies on JNI API functions by restricting the type of functionality that can be offered in native code. However, this mechanism may only be used for methods that are guaranteed not to require garbage collection, exception handling, synchronization or any type of security support since these are the types of functionality the wrappers provide.","In yet another attempt to minimize the overhead of JNI function calls, compilers may use proprietary native interfaces that are tightly coupled to the VM, since the interfaces have knowledge of the internals of the VM. An example of such compilers is the Jcc compiler, which is an optimizing compiler that compiles directly to native code using a proprietary native interface reminiscent of the original Native Method Interface (NMI), from Sun Microsystems, Inc. However, the NMI has been replaced by the JNI. In Jcc, a Java method that is marked \u2018native\u2019 will be treated as a C method to be called with C calling conventions and emitting a C structure for every Java class. In this way, Jcc may inline short assembly segment to speed up native calls.","While the above attempts minimizes some of the overhead associated with JNI function calls, there is no existing mechanism that does not restrict the type of functionality implemented in native code, as mentioned in the second attempt, or does not couple to a specific VM implementation, as mentioned in the third attempt.","Therefore, it would be advantageous to have a method, an apparatus, and computer instructions for use by a Just in Time (JIT) compiler transforming JNI function calls to constants, internal compiler operations or a simpler intermediate representation, such that performance of native codes accessing JVM data and services may be improved without coupling to a specific VM implementation or sacrificing type safety of the JNI.","The present invention provides a method, an apparatus, and computer instructions for transforming native function calls into simpler operations during just-in-time compilation. After compiling a program to generate a list of shapes for a plurality of Java Native Interface (JNI) function calls, an inliner is provided to identify a list of native interface function or JNI calls made in native code for transformation.","The just-in-time (JIT) compiler then performs a definition and use (def\/use) analysis on the list of native interface function calls and a plurality of arguments passed to the native interface function calls. Subsequently, a JIT call transformer is provided to transform a portion of the list of native interface function calls into constants, internal just-in-time compiler operations or simpler intermediate representation using results of the definition and use analysis.","During inlining of native functions calls, the just-in-time inliner determines, for each native interface call occurring in the inlined code, if the native interface environment variable used in the call is in the same position as it appears in a list of pre-defined shapes representing all known native interface calls. The shape of a JNI call includes (1) the means (represented in the intermediate representation) to access the actual target native interface or JNI function (2) the treatment (again in the intermediate representation) each actual argument receives. The shape of a representative JNI call (as created when building the list of shapes) uniquely determines the actual JNI routine. If the native interface environment variable used in a call is in the same position as in one of the shapes in the list of pre-defined shapes representing native interface calls, the inliner determines if a match exists between the shape and the intermediate representation of the JNI call made by an inlined native function.","If a match exists between the shape and the intermediate representation of the JNI function call, the inliner adds the JNI call to a list of JNI function calls for the currently inlined native method, wherein the list of calls is sorted in an order of appearance in the intermediate representation of the plurality of JNI calls.","After performing definition and use analysis, the just-in-time call transformer determines, for each native interface function call in the list of native interface function calls, the type of the native interface function calls, and attempts to replace each native interface function call with a constant value, internal just-in-time compiler operation or a simpler intermediate representation depending on the type of JNI function call.","Since the newly generated constants, internal just-in-time compiler operations or simpler intermediate representation perform without using the JNI, they in turn provide direct and faster access to the services and data of the Java virtual machine.","With reference now to the figures and in particular with reference to , a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. A computer  is depicted which includes system unit , video display terminal , keyboard , storage devices , which may include floppy drives and other types of permanent and removable storage media, and mouse . Additional input devices may be included with personal computer , such as, for example, a joystick, touchpad, touch screen, trackball, microphone, and the like. Computer  can be implemented using any suitable computer, such as an International Business Machines, IBM\u00ae, eServer computer or IntelliStation\u00ae computer, which are products of IBM\u00ae Corporation, located in Armonk, N.Y. Although the depicted representation shows a computer, other embodiments of the present invention may be implemented in other types of data processing systems, such as a network computer. Computer  also preferably includes a graphical user interface (GUI) that may be implemented by means of systems software residing in computer readable media in operation within computer .","With reference now to , a block diagram of a data processing system is shown in which the present invention may be implemented. Data processing system  is an example of a computer, such as computer  in , in which code or instructions implementing the processes of the present invention may be located. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Accelerated Graphics Port (AGP) and Industry Standard Architecture (ISA) may be used. Processor  and main memory  are connected to PCI local bus  through PCI bridge . PCI bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus  may be made through direct component interconnection or through add-in connectors. In the depicted example, local area network (LAN) adapter , small computer system interface (SCSI) host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . SCSI host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in . The operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on the data processing system . \u201cJava\u201d is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive , and may be loaded into main memory  for execution by processor .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the present invention may be applied to a multiprocessor data processing system.","For example, data processing system , if optionally configured as a network computer, may not include SCSI host bus adapter , hard disk drive , tape drive , and CD-ROM . In that case, the computer, to be properly called a client computer, includes some type of network communication interface, such as LAN adapter , modem , or the like. As another example, data processing system  may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not data processing system  comprises some type of network communication interface. As a further example, data processing system  may be a personal digital assistant (PDA), which is configured with ROM and\/or flash ROM to provide non-volatile memory for storing operating system files and\/or user-generated data.","The depicted example in  and above-described examples are not meant to imply architectural limitations. For example, data processing system  also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system  also may be a kiosk or a Web appliance.","The processes of the present invention are performed by processor  using computer implemented instructions, which may be located in a memory such as, for example, main memory , memory , or in one or more peripheral devices -.","With reference now to , a block diagram illustrating the relationship of software components operating within a computer system that may implement the present invention. Java-based system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. JVM  is one software application that may execute in conjunction with the operating system. JVM  provides a Java run-time environment with the ability to execute a Java application or applet , which is a program, servlet, or software component written in the Java programming language. The computer system in which JVM  operates may be similar to data processing system  or computer  described above. However, JVM  may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core.","At the center of a Java run-time environment is the JVM, which supports all aspects of Java's environment, including its architecture, security features, mobility across networks, and platform independence.","The JVM is a virtual computer, i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement, with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example, all JVMs must execute Java Bytecodes and may use a range of techniques to execute the instructions represented by the Bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.","The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM, which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java run-time system. The Java compiler generates Bytecode instructions that are nonspecific to a particular computer architecture. A Bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a Bytecode or Bytecodes. These Bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecode may be translated into native code by a just-in-time compiler or JIT.","A JVM loads class files and executes the Bytecodes within them. The class files are loaded by a class loader in the JVM. The class loader loads class files from an application and the class files from the Java application programming interfaces (APIs) which are needed by the application. The execution engine that executes the Bytecodes may vary across platforms and implementations.","One type of software-based execution engine is a just-in-time (JIT) compiler. With this type of execution, the Bytecodes of a method are compiled to native machine code upon successful fulfillment of criteria for JIT compiling a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java Bytecodes are executed natively. JVMs usually interpret Bytecodes, but JVMs may also use other techniques, such as just-in-time compiling, to execute Bytecodes.","When an application is executed on a JVM that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language, compiled to Bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","With reference now to , a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM  includes class loader subsystem , which is a mechanism for loading types, such as classes and interfaces, given fully qualified names. JVM  also contains runtime data areas , execution engine , native method interface , and memory management . Execution engine  is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine  may be, for example, Java interpreter  or just-in-time compiler . Native method interface  allows access to resources in the underlying operating system. Native method interface  may be, for example, the Java Native Interface (JNI).","Runtime data areas  contain native method stacks , Java stacks , PC registers , method area , and heap . These different data areas represent the organization of memory needed by JVM  to execute a program.","Java stacks  are used to store the state of Java method invocations. When a new thread is launched, the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks: it pushes and pops frames. A thread's Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method, the JVM pushes a new frame onto the Java stack of the thread. When the method completes, the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values; any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java instruction set is well-defined for a variety of platform architectures.","Program counter (PC) registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a JVM method, the value of the PC register indicates the next instruction to execute. Native method stacks  stores the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM implementations, native method stacks  and Java stacks  are combined.","Method area  contains class data while heap  contains all instantiated objects. The constant pool is located in method area  in these examples. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap, each of which are shared by all threads running inside the JVM, such as JVM . When JVM  loads a class file, it parses information about a type from the binary data contained in the class file. JVM  places this type of information into the method area. Each time a class instance or array is created, the memory for the new object is allocated from heap . JVM  includes an instruction that allocates memory space within the memory for heap  but includes no instruction for freeing that space within the memory. Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a garbage collector, which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","The present invention provides a method, an apparatus, and computer instructions during JIT compilation for transforming JNI function calls into simpler compiler operations which ultimately results in the generation of constants and more efficient intermediate representation. In a preferred embodiment, the present invention utilizes a JIT compiler intermediate representation that is converted from an inlined native function intermediate representation. The present invention provides a JNI call transformer that performs analysis on each generated JIT compiler intermediate representation instruction searching for JNI function calls. The JNI call transformer then transforms as many JNI function call's intermediate representations into internal JIT compiler operations or constants in order to generate simpler operations that are equivalent to JNI calls but do not require calling the JNI function. In this way, faster access to JVM services and data is provided.","To discover the actual JNI methods that the program intends to invoke, the JNI call transformer first has to understand the shape of the JIT compiler intermediate representation for each JNI function call. In order to understand each shape, the JIT compiler is called by the JNI call transformer to compile non-executable C or C++ programs which call each JNI function in turn. The JNI call transformer gains knowledge of how each JNI function uses the JNIEnv argument and the use of each user provided arguments to each call, and maintains a list of known shapes. Alternatively, the JIT call transformer may determine the shapes dynamically at the start of Java program execution or as part of the JIT compiler build process. Alternatively, knowledge of the shapes may be hardcoded into the source code of the JIT compiler.","The shape of a JNI call includes (1) the means (represented in the intermediate representation) to access the actual target JNI function (2) the treatment (again in the intermediate representation) each actual argument receives. The shape of a representative JNI call (as created when building the list of shapes) uniquely determines the actual JNI routine. The process of building the list of shapes (by processing the special C and C++ programs) occurs, in the preferred embodiment when the Java process (and hence the JIT) begins execution. It is also possible to create the list of shapes when the JIT itself is constructed. By performing shape determination as part of the building the JIT compiler, a certain set of shapes is determined when the compiler is restarted. Thus, the shape for each JNI function could be statically encoded in the JIT compiler. The only requirement for performing shape determination as part of building the JIT compiler is that the intermediate representation used is correct for both the current version of the JIT compiler and the virtual machine. As a result of this process, a list of JNI function call intermediate representation shapes is generated.","Once shapes are determined, they will be used by the inliner as mentioned in related patent application entitled \u201cMETHOD AND APPARATUS FOR INLINING NATIVE FUNCTIONS IN COMPILED JAVA CODE,\u201d which is incorporated by reference above. Specifically, the related patent application provides a conversion engine to convert native function intermediate representation to JIT compiler intermediate representation, as well as an inliner which replaces the intermediate representation of an inlineable native function call with the actual implementation of the function in the JIT compiler intermediate representation. The inliner also performs inlining work including mapping parameters to arguments, merging native compiler and JIT compiler intermediate representations, control flow graphs, and materializing the JNIEnv pointer so that it can be used by an inlined statement to make calls to the JNI API.","During the inlining of native code, the inliner analyzes inlined code for intermediate representation statements generated representing JNI calls. It does so by matching inlined intermediate representation against the list of shapes generated from C or C++ programs, or during the JIT build process. The inliner records all the uses of the JNIEnv variable in the inlined native function, which may be passed to recursively inlined functions. When the inliner encounters a use of the JNIEnv variable, if the JNIEnv variable is not used in the same position as it appears in any of the list of shapes, the inlining process continues. However, if the JNIEnv variable is used in the same position as it appears in one of the list of shapes, the entire shape is matched to the intermediate representation for the JNI function callsite. A shape (of a JNI method call) matches a member of the list of shapes if it has the same number of arguments and each argument in the actual call is compatible with the type of argument in the member of the list of shapes. If a match is found, meaning that the callsite corresponds to a JNI function call, the callsite is not eligible for inlining, but may be eligible for transformation.","In this case, the JIT compiler inliner records the callsite that it determines to correspond to a JNI function call. A list of such JNI function calls is generated, which is sorted in the order of appearance in the intermediate representation for the inlined method. If one method call uses results of another method call, the inner most method call will appear in the list before the use of the result. Once the analysis of callsites is complete, a list of JNI function calls that are non-inlineable but potentially transformable is identified by the inliner. The JNI call transformer then performs transformations on the list of JNI function calls using results of a JNI def\/use analysis.","A number of JNI function calls are used to identify elements that are normally identified via the class' constant pool. Examples of these JNI function calls include getObjectClass, getMethodID, and getFieldID. Other JNI function calls may perform more concrete actions, such as getting or setting object field values. However, it is necessary to know the specific types of objects that are passed to the JNI function before optimization can be performed. Therefore, a JNI def\/use analysis is performed.","The JNI def\/use analysis, which is similar to a well understood definition\/use analysis commonly used in optimizing compilers, is performed by tracking objects that are passed to the inlined native method through the inlined code to the points where they are passed as arguments to JNI functions. Each argument is represented by a set of possible objects depending on the flow of control from the start of the inlined native method to the invocation of the JNI function. This set of objects may include more than one element and the elements may all come from the same class.","The def\/use analysis computes all possible classes, fields and methods reaching uses in JNI function calls. That is, when it cannot conclusively determine, for example, the class that an object must be an instance of at a JNI callback, it produces sufficient information to allow the transformation phase to consider all possible classes that the object may be an instance of.","It is possible that the def\/use analysis is unable to compute even conditional results. This would arise, for example if arguments to a JNI function call are fetched from storage (having been written there by a previous process) for use in a subsequent JNI function call.","In the JNI def\/use analysis, the results of getObjectClass, getSuperClass, findClass, getMethodID and getFieldID are treated as definitions and their uses are tracked. The result can normally be transformed into constant values that will be used instead of the usual constant pool indices.","In addition, the JNI def\/use analysis also tracks the string arguments to findClass, getMethodID, and getFieldID. In this way, the JIT compiler may positively resolve some of these calls while a more na\u00efve implementation would be unable to. However, one complication with JNI def\/use analysis is that the results of NewObjectType JNI calls can reach various uses of objects in the list of JNI function calls. Thus, these results have an abstract type that may become concrete if the class and methodIDs used as arguments to NewObjectType become fixed during the JNI def\/use phase.","As mentioned above, the JNI call transformer performs transformation on the list of JNI function calls using results of a JNI def\/use analysis. During transformation, the JNI call transformer iterates over the list of JNI function calls and replaces the JNI function call with a constant value or generation of new JIT compiler intermediate representation that is simpler and replaces the JNI function call with the new JIT compiler intermediate representation.","Depending on the type of JNI function calls, the possible outcome of the transformation may be different. For example, if all the possible definitions reaching a getObjectClass are of the same class, the call is replaced by the appropriate constant. As noted below, in the case where the def\/use analysis produced known results including information about multiple, incompatible classes (of objects) reaching the getObjectClass, conditional logic and code replication are used to make the correct actual class available to subsequent uses.","If all possible classes reaching a getFieldID or getMethodID are compatible (in the Java sense) and the string arguments can be uniquely determined, the call is replaced by the appropriate constant. (If objects of incompatible classes reach the getFieldID or getMethodID, conditional logic may be inserted as described below.)","If all possible fieldIDs reaching a get<type>Field method or put<type>Field method, which retrieves or stores into a field of a Java class, are the same and all possible objects reaching the call are of compatible class types, the call is replaced by a corresponding sequence of the JIT compiler's intermediate representation. Note that this form of internal representation defers throwing of any exceptions in accordance with the Java rules for executing native methods. (The notation get<type>Field refers to any of the JNI API functions intended to retrieve a field from an object and similarly for other uses of the <type>notation. Those familiar with the JNI API will easily understand this notation).","Similar transformations are performed for the various call<type>Method JNI function calls in the list of JNI functions by removing the intermediate representation of the method being called and generating JIT intermediate representation that calls the function directly. For any of the entries in the list of JNI functions that are not handled using the steps above, the call is treated as an ordinary call to an appropriate VM service routine.","It is important to note, that for any of the abovementioned functions, if the JNI def\/use phase produced known but not conclusive information, conditional logic based on the type of actual receiver objects or the actual values passed into the JNI function calls (i.e. jfieldID or jmethodID) is inserted along with the appropriate intermediate-representation to represent the semantics of the specific JNI function being transformed.","Turning now to , a diagram illustrating JNI function call transformations performed by the JNI call transformer is depicted in accordance with a preferred embodiment of the present invention. As shown in , JNI call transformer  is provided by the present invention.","JNI call transformer  iterates over each JIT compiler intermediate representation instruction  that is inlined by an inliner provided by the related patent application. Some of JIT compiler intermediate representation instructions  may be JNI function calls , which utilize the JNI API functions.","For those instructions that are JNI function calls, JNI call transformer  transforms the instructions into transformed calls  and internal JIT compiler operations . Transformed calls  may be simpler JIT compiler intermediate representation that provides more direct and faster access to the JVM services and data. Internal JIT compiler operations  may be constant values or simplified intermediate representation that does not use the JNI.","In this way, JNI call transformer  modifies some or many JNI function calls to remove the need to actually call the JNI function. The transformation is performed by an analysis using the inliner, matching the shape of JIT compiler intermediate representation for each JNI function against a list of known shapes. To perform this matching, a list of shapes is first generated in a manner as described below in .","Turning now to , a diagram illustrating generation of intermediate representation shapes for JNI function calls is depicted in accordance with a preferred embodiment of the present invention. As shown in FIG. , JIT compiler  compiles non-executable C and C++ programs containing representative calls to all JNI functions  and generates a list of shapes  representing intermediate representation for JNI function calls.","Turning now to , a diagram illustrating native inlining preparation for JNI transformation is depicted in accordance with a preferred embodiment of the present invention.","As depicted in , JIT compiler inliner  may be provided by the related patent application, which inlines native functions by replacing the intermediate representation for the native call with the actual implementation of the function in the JIT compiler intermediate representation format.","During inlining, JIT compiler inliner  may analyze native function intermediate representation  that includes a number of JNI function calls. In this example, native function intermediate representation  includes JNI call , JNI call , JNI call , and JNI call . For each of the JNI function calls matched by the JIT compiler inliner, the JIT compiler inliner  adds the JNI function call to the list of JNI function calls  in order of appearance in the intermediate representation of the inlined native function .","Thus, JNI call  is added to the list of JNI function calls  followed by JNI call . If one JNI function call uses the result of another JNI function call, the inner most call will appear first in the list.","Turning now to , a diagram illustrating an exemplary def\/use analysis performed by the compiler is depicted in accordance with a preferred embodiment of the present invention. As shown in , in JNI def\/use analysis, the compiler analyzes the program and determines if further optimizations can be performed.","In this example, def\/use analysis determines what variables are defined. For example, program  includes definitions object \u2018obj\u2019 , integer \u2018a\u2019 , class \u2018cls\u2019  and field \u2018fid\u2019 . In addition, def\/use analysis determines where the defined variables are being used. For example, \u2018obj\u2019 is used in getObjectClass method  and setIntField method , \u2018cls\u2019 is used in getFieldID method , and \u2018fid\u2019 is used in setIntField method . Since \u2018cls\u2019  is a result of getObjectClass method , it is treated as a definition and its uses are tracked. In the code presented by this figure, it is possible to replace the JNI function call to GetFieldID with a constant value representing the field's ID. Furthermore, since \u2018fid\u2019  is also an input argument to the setIntField method , it will be possible to transform the intermediate representation for the call to the setIntField method  to an intermediate representation that modifies the respective field in the object directly (i.e. without having to make a JNI function call to do so).","Turning now to , a flowchart of an exemplary process for transforming JNI function calls to constants, internal compiler operations or simpler intermediate representation is depicted in accordance with a preferred embodiment of the present invention. The process assumes that the JNI call transformer has run the JIT compiler to generate JIT compiler intermediate representation and a list of JNI function call shapes, as depicted in .","As depicted in , the inliner is run to its standard inlining phase (step ). It checks to see if it encounters any inlineable native callsites (step ). If it doesn't, it continues to step  which resumes the rest of JIT compilation. If a native callsite, however, is encountered, it continues to step , at which point it checks whether an inlineable native function contains any function calls. If it doesn't, then the inliner proceeds to step  which resumes the rest of JIT compilation. If the inlineable native call does contain function calls, then the process continues to step  at which point the native code is matched against the JNI function call shapes that were generated by the process depicted in . In step , a callsite is checked for a match, and if a match is found, step  adds the callsite to a list of JNI calls and proceeds to step  which repeats this last process for any additional callsites. If a callsite doesn't match, the process repeats itself until all callsites have been examined.","Once all callsites have been analyzed, step  performs the JNI def\/use analysis, and continues by processing the first identified JNI call in step . If JNI def\/use analysis produced a conclusive result for the callsite (step ), then the intermediate representation for the call is replaced by a constant, simpler compiler operations or simpler intermediate representation, possibly with conditional logic for known results (step ). If JNI def\/use produced unknown results for this particular callsite, then the callsite and any others that use its result are discarded from the list of JNI function calls (step ).","Once the results of JNI def\/use have been used to transform the callsite, the process checks for additional JNI callsites (step ). If there are more JNI callsites, the process continues to step . If there are no more callsites to process, step  continues with the rest of JIT compilation and the process terminates thereafter.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. For example, although the depicted embodiment is directed towards processing Bytecodes in Java, the processes of the present invention may be applied to other programming languages and environments that process instructions, which are nonspecific to a computer on which the instructions are to be executed. In such a case, a virtual machine on the computer may interpret the instructions or send the instructions to a compiler to generate code suitable for execution by the computer on which the virtual machine is located.","The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
