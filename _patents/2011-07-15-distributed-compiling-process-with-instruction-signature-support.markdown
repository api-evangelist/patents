---
title: Distributed compiling process with instruction signature support
abstract: A compiler module for providing instruction signature support to a compiler includes a language construct identifier and a placeholder insertion component. The language construct identifier is configured to identify an instruction signature-relevant language construct in a high level language source code supplied to the compiler. The placeholder insertion component is configured to interact with the compiler for inserting at least one instruction signature-related placeholder based on the instruction signature-related language construct into a compiled code processed by the compiler on the basis of the high level language source code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08694977&OS=08694977&RS=08694977
owner: Infineon Technologies AG
number: 08694977
owner_city: Neubiberg
owner_country: DE
publication_date: 20110715
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application relates to a compiler module for providing instruction signature support to a compiler, and more particularly to processing instruction signature-relevant information during a compiling process of a high level language source code.","A programmable computing unit is typically designed to process a sequence of instructions to perform a certain task. The sequence of instructions may also be referred to as program code. The program code is typically stored in a memory and provided to the computing unit at runtime. With a view to information security, it may be desired to protect the instructions from being analyzed while they are stored in the memory or transmitted from the memory to the computing unit. On the other hand, errors may occur during an execution of the program code if the instructions reaching the computing unit differ from desired instructions. Differences between the instruction actually processed by the computing unit and the desired instructions may have a random cause or could be deliberately provoked by an intruder. In any event, errors caused by altered instructions should be detected early.","Control flow checking methods may be used to detect such differences between the instructions actually processed by the computing unit and the desired instructions. The underlying principle of control flow checking methods that are based on instruction signatures is to sum up the instructions executed during runtime of a program in a checksum (i.e., the signature) during the runtime of the program and to verify at predetermined program points whether the checksum matches a reference value. A difference between the checksum and the reference value indicates a possible deviation between the actual program execution and an intended program execution.","When a program supporting control flow checking is created or compiled, most of the commonly known control flow checking methods require that so-called update values are inserted at specific points in the program. If, for example, a program jump or branching point occurs and the two different paths (different in the sense that different instruction sequences are executed and lead to different signatures) merge again, the signatures resulting from an execution of the paths need to be consistent at the merge point. To this end, an update value is inserted into at least one of the paths. Branches occur at conditional (direct) jumps, indirect jumps, direct and indirect function calls. Furthermore, reference values are required at the program point where the comparison of the signature calculated during runtime and the reference value are performed. These reference values need to be introduced at the appropriate program points into the program, as well.","Embodiments described herein provide a compiler module for providing instruction signature support to a compiler. The compiler module comprises a language construct identifier configured to identify an instruction signature-relevant language construct in a high level language source code supplied to the compiler and a placeholder insertion component configured to interact with the compiler for inserting at least one instruction signature-related placeholder based on the instruction signature-related language construct into a compiled code processed by the compiler on the basis of the high level language source code.","Further embodiments described herein provide an instruction signature generator, including an input for a compiled code, a placeholder identifier, a signature calculator, and a placeholder replacer. The placeholder identifier is configured to identify an instruction signature-related placeholder in the compiled code. The signature calculator is configured to determine a signature value for a program point in the compiled code at which the instruction signature-related placeholder occurs. The placeholder replacer is configured to insert a compiled code segment on the basis of the signature value at the program point.","Further embodiments described herein provide a compiler interface data structure, including compiled instructions, wherein at least one of the compiled instructions is an instruction signature-related placeholder.","Further embodiments described provide a method for processing instruction signature-relevant information during a compiling process of a high level language source code, the method including: identifying an instruction signature-relevant language construct in the high level language source code; interacting with the compiling process in order to insert at least one instruction signature-related placeholder based on the instruction signature-relevant language construct into a compiled code processed by the compiling process on the basis of the high level language source code.","Further embodiments described herein provide a computer readable digital storage medium having stored thereon a computer program having a program code for performing, when running on a computer, a method for processing instruction signature-relevant information during a compiling process of a high level language source code, the method including: identifying an instruction signature-relevant language construct in the high level language source code; interacting with the compiling process in order to insert at least one instruction signature-related placeholder based on the instruction signature-relevant language construct into a compiled code processed by the compiling process on the basis of the high level language source code.","Further embodiments described herein provide a method for generating an instruction signature, the method including: determining the program location where an instruction signature-related placeholder should be inserted in a compiled code, determining a signature value for a program location in the compiled code at which the instruction signature-related placeholder occurs, and inserting a compiled code segment at the program location, which implicitly or explicitly generates the update on the basis of the determined signature value.","Those skilled in the art will recognize additional features and advantages upon reading the following detailed description, and upon viewing the accompanying drawings.","Instruction stream signatures typically provide a relatively strong integrity protection of the program code. As can be seen in , each code sequence with conditional branch instructions (e.g. instruction i) has one \u201cdefault path\u201d, in  via the instructions i and i to the merging point at instruction i. For this \u201cdefault path\u201d a signature S is calculated by a static code analyzer. To handle a \u201cnon default path\u201d (e.g. from instruction i directly to instruction i), at each conditional branch an update of the signature is performed so that the signature is the same as if the default path would have been taken. This is illustrated in  by the arrow labeled \u201cupdate S+\u0394\u201d which means that S is modified in the same manner as S would have been modified by the instruction i and i if the default path would have been taken. Which path is the default path may be implicitly defined by the user or the programmer if the default path is the only path without update from start to end. In general any of the paths can be the default path.","A realistic program typically contains a plurality of program points with update values or reference values. The update and reference values are herein commonly referred to as signature values. The positions or program points where the signature values are inserted are referred to as signature positions. The abbreviation ISS stands for Instruction Stream Signature.","One method for creating control flow protected code is that the programmer manually inserts the signature values in selected parts of the code at the signature positions that are known to him. To this end, the programmer has to determine both the signature values and the signature positions himself. However, many compilers and linkers perform optimizing steps and modifications of the instruction sequences within the program code, which are difficult to anticipate by the programmer.","Having the programmer determine the signature values and the signature positions himself may lead to an elaborate, error-prone, iterative work flow and to restrictions depending on which level the signature values can be inserted. Some of the restrictions that may arise are:\n\n","Optimizations performed by the compiler and\/or the linker may compel the programmer to further limitations and\/or efforts. In particular, the code modifications by the compiler and linker may be addressed as follows:\n\n","The compiler module, the instruction signature generator, the compiler interface data structure, the method for processing instruction signature-relevant information during a compiling process of a high level language source code, and a corresponding computer readable digital storage medium according to the embodiments described herein address the shortcomings of the existing instruction signature methods. According to the embodiments described herein, measures performed during the compiling step and a subsequent signature generation step are combined in an effective way. The embodiments described herein thus enable a complete support for common programming languages so that i) the syntax of the programming language may be used to the full extent in control flow protected programs and program parts, and ii) the generation of control flow protected programs or program parts from, e.g., unprotected program parts may be performed in a virtually fully automated manner. The embodiments described herein thus relate to a distributed compiling process with instruction signature support and\/or to a generation of (computer) programs with instruction flow control.","The embodiments described herein facilitate the automation of the insertion and the calculation of signature values, as well as the separation of the process in two main stages (substantially the insertion of placeholders and the calculation). The embodiments described herein also relate to the interface(s) between the two steps. The two main stages are performed by separate tools, a compiler module (\u201csignature compiler\u201d) and an instruction signature generator.","The programmer may influence the application of the instruction signature support via the high level language source code that is provided to the compiler.","For example, at the beginning of the code to be protected the user may enable the ISS (instruction stream signature) by a function FCT_ISS_Start( ). At the end of the code sequence (or protected program code segment) to be protected a function FCT_ISS_Stop( )checks the signature and switches the ISS off again. A constant parameter ref used in the function FCT_ISS_Start( )is calculated at a later time by the signature instruction generator and patched in a file (.elf file) including the compiled code by a static code checker (or instruction signature generator). At the very beginning of the function an ISS_UPDATE a placeholder has to be inserted where the constant value is calculated and patched by the static code checker. After each function call, direct and indirect calls, an additional ISS_UPDATE placeholder has to be inserted where the constant is calculated and patched such that the correct value at the next FCT_ISS_Check( )or FCT_ISS_STOP( ) is reached.","With the function FCT_ISS_Status( )the user can check whether an ISS code sequence has been executed correctly. During a running ISS code sequence the user can insert additional checkpoints at security critical points via FCT_ISS_Check( ), where the constant parameter ref is calculated and patched such that the expected value is in a dedicated register (ISS_DATA register) of the processor or of a signature module, provided that the execution of the instruction did not contain an error.",{"@attributes":{"id":"p-0030","num":"0040"},"figref":"FIG. 2","ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":{"@attributes":{"id":"ul0008-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":["the compiler support (e.g., in the form of an external or internal compiler module) for ISS_UPDATE placeholder insertion and forwarding of some information to the static code checker; the compiler support to recognize program regions (e.g. functions) which should be ISS protected; the compiler support to recognize special ISS related functions, such as FCT_ISS_Check( ) The compiler extended by the instruction signature support facility is also referred to as \u201csignature compiler\u201d herein.","an instruction signature generator or static code checker, being a post processing tool that does the signature calculation and replacing of ISS_UPDATE placeholder by the signature values."]}}}},"In order to provide a general understanding of the interaction of the two parts, the main functions of the signature compiler and the instruction signature generator are briefly described as follows.","The signature compiler typically implements the following aspects:\n\n","The instruction signature generator typically implements the following aspects:\n\n","In , one or more source files  (for example in the high level language C, as indicated by the file name extension \u201c.c\u201d) is\/are supplied to a compiler . The compiler  includes a compiler module  (\u201cISS extension\u201d) which adds support for instruction signature-specific processing to the compiler . As shown in , the compiler module  may be integrated with the compiler . In the alternative, the compiler module  may be an external module in the form of, for example, a dynamically linked library, dynamic shared object, an add-on, a plug-in, or a software extension. The compiler  produces an object file  with the file name extension \u201c.o\u201d on the basis of the source file(s) . In addition, the compiler  may produce a list file , mostly for informative and\/or debugging purposes. The compiled code within the object file  typically includes several instruction signature-related placeholders at various program points. The instruction signature-related placeholders have been added to the compiled code by the compiler module  in order to reserve memory space which is available for a future insertion of the signature values. The compiler module  may perform the insertion of the placeholders substantially concurrently with the compiler  compiling the source code. In this manner the compiler  is aware of the inserted placeholders at an early stage of the compiling process and may take the information about the placeholders, their locations and their sizes into account when continuing with the compiling process, in particular when calculating branch or jump destinations. The compiler module  may monitor the progress of the compiling process, i.e., which language construct within the source code  is currently processed by the compiler . The insertion of the signature-related placeholder preserves the logical function of original high-level language code given to the compiler . The compiler  is aware that optimization stages do not modify or move the inserted placeholders in a way that destroys the error checking capabilities of ISS, e.g. by hoisting signature updates outside a loop during loop invariant optimization.","The compiled code may be a machine language code. The placeholder insertion component may be configured to select the at least one instruction signature-related placeholder so that a size of the at least one instruction signature-related placeholder has a size equal to a size of a machine language instruction or a sequence of machine language instructions eventually replacing the at least one instruction signature-related placeholder in the compiled code.","In the alternative to using a source file written in a high level language such as C in connection with the compiler , a programmer may also chose to write a source file  in an assembler language which may then be processed by an assembler . The assembler  also generates an object file  and an optional list file . In  the assembler  does not include a module which would add support for instruction signature-specific processing to the assembler . Hence, the programmer adds any instruction signature-related placeholders into the assembler listing himself, for example, via a macro which writes a predetermined binary code at the program point where it occurs. Although not illustrated in , the assembler  could, in general, include or interact with an assembler module providing similar functionality as the compiler module .","Depending on whether it is intended to generate an executable program or a software library file from the object file , the object file  is fed to a library manager  or a linker\/locator . In a similar manner, the object file  created by the assembler  may be fed to the library manager  or the linker\/locater . Furthermore, one or more library files may be supplied to the library manager  or the linker\/locater . The library manager  outputs a library file . The linker\/locator  outputs an ELF (executable and linkable file) image . The linker\/locator  may use a scatter file  as another input for the linking and locating process which basically determines how the memory layout of a processor is organized when the resulting ELF image  is loaded. The linker\/locator  includes an instruction stream signature (ISS) extension  which may produce an option map file .","Except for the instruction signature-related extensions  and  in the compiler  and the linker\/locator , respectively, the compiling and linking environment is substantially equal to a standard build flow up to the point indicated by the horizontal dashed line in .","The ELF image  still contains the instruction signature-relevant placeholders inserted by the compiler module . In order to convert these placeholders into useful instructions or data for the processor on which the program will eventually run, an instruction signature generator  processes the ELF image  to create a modified ELF image . In the modified ELF image  the instruction signature-related placeholders have been replaced by signature values that correspond to the program point, i.e., the signature location, at which the placeholder occurs. The instruction signature generator  (also referred to as \u201c(static) code checker\u201d) searches the placeholders in the compiled code. Furthermore, the instruction signature generator  may perform a basic block analysis and a default path analysis in order to find out via which instruction sequence the program point of the placeholder can be reached as these determine the signature value at the program point. In the alternative, the instruction signature generator  may receive corresponding basic block and default path information from, e.g., the compiler  or the linker\/locator  in the form of the list file  or map file . On the basis of the basic block and default path analysis or information and an initial signature value the instruction signature generator  may then determine the reference signature values at the program points where the placeholders occur. The instruction signature generator  may \u201cwade through\u201d the ELF image  from placeholder to placeholder in the order they may be executed when the program is running in order to find out which instructions are performed between two placeholder program points if the default path or a non-default path (if present) is taken. In the ELF image  output by the instruction signature generator  the placeholders have been replaced with the signature values calculated by the instruction signature generator .","The modified ELF image  is input to a postlocator  which creates a physical ELF image  and\/or a hexadecimal file . Furthermore, the postlocator  may use one or more additional ELF images , a derivative configuration , and an optional project configuration . Optionally, the postlocator  may output a map file .","The physical ELF image  or the hexadecimal file  may be executed on a processor  which supports instruction signature tracking. In the alternative, the physical ELF image  or the hexadecimal file  may be executed on a simulator (not shown).","The basic functionality of the signature compiler has been briefly described above. In more detail, the signature compiler performs the typical actions of a standard compiler, supplemented with actions specific to the embodiments described herein. During an action of parsing and syntax\/grammar analysis, an additional action of recognizing particular pragmas and keywords is performed. Examples of possible keywords are:\n\n","The pragmas or keywords may be resolved as library functions. Thus, the following library functions may be provided for:","void FCT_ISS_Start(const ret)\n\n","void FCT_ISS_Stop( )\n\n","void FCT_ISS_Check(const ref)\n\n","void FCT_ISS_Status( )\n\n","int FCT_ISS_Suspend( )\n\n","int FCT_ISS_SuspendRestart(const ref)\n\n","void FCT_ISS_Resume(save)\n\n","FCT_ISS_Suspend and FCT_ISS_Suspend. The function FCT_ISS_Resume turns off the instruction stream signature tracking and restores the ISS_DATA and ISS_CTRL registers for example from variables previously stored in the working memory. The values of the ISS_DATA and ISS_CTRL registers, stored e.g. in the working memory, is input to the function in the form of the single parameter save.","These library functions provide functionality needed for the instruction stream signature support. Furthermore, most programs use (standard) libraries for frequently used functions. These standard libraries typically do not provide instruction stream signature tracking so that the invocation of an unprotected function in one of the standard libraries could result in an undetected error and consequently a security breach. Therefore, a second set of runtime libraries compiled with instruction stream signature support is needed, if a more complete coverage, including runtime library calls, is desired. The binder\/linker is controlled by means of signature control information produced by the signature compiler (compiler  and compiler module ) and\/or the instruction signature generator  that the binder\/linker, within instruction signature-protected code segments, uses instruction signature-protected library functions. In particular, the language construct identifier may be configured to identify a protected program code segment for which the instruction signature support is enabled. The compiler module may further include a library call information collector configured to collect library call information relative to software library calls occurring within the protected program code segment and to provide the library call information for usage during a subsequent linking process.","The compiler  typically performs a basic block analysis. Preferably the compiler  performs also a default path analysis. As an additional action the compiler module  may insert implicit signature instructions according to rules for: a) do-while-loop construct; b) while-do-loop construct; c) if-then-else construct; d) various multiple switch constructs. These insertions are done in the code segments marked as instruction signature-protected (e.g., code segments between keywords ISS_ON and ISS_OFF). The language construct identifier  may be configured to identify a start and an end of a protected program code segment within the high level language source code for which the instruction signature support is enabled. The placeholder insertion component may be configured to use a result of a corresponding protected segment identification in order to activate the inserting of the at least one instruction signature-related placeholder within the protected program code segment and to deactivate it in a non-protected program code segment.","A further additional action performed by the compiler module  (or the compiler  upon corresponding invitation by the compiler module ) is the insertion of explicit signature instructions at program points defined by pragmas and\/or keywords:\n\n","Another issue affecting the compiler  is the optimization that the typical compiler performs when compiling code. In particular the following two situations may require an adaptation of the optimization behavior of the compiler : loop invariants optimization and ISS function calls.","With respect to loop invariants optimization the compiler  may come to the conclusion that an instruction signature-related placeholder within a loop is apparently unaffected by the loop and could in fact be moved in front of the loop in order to reduce the number of \u201cexecutions\u201d of the placeholder. However, in this case the placeholder shall not be optimized but remain within the loop, as every iteration of the loop constitutes a new conditional branch.","Some of the ISS function have a parameter which is patched by the instruction signature generator . The instruction signature generator  assumes the following code (translated to assembler language):\n\n","MOVW moves the constant word value #<const> to the register Rd. Then, using the instruction \u201cBL FCT_ISS_Start\u201d the program (unconditionally) jumps to the label FCT_ISS_Start. These two instructions typically have to be atomic and especially a MOVW instruction independent of the length of the parameter has to be generated.","With respect to code optimization the placeholder insertion component  may be configured to verify whether a code optimization of the compiler  conflicts with the at least one instruction signature-related placeholder. Upon verifying or determining a conflict, the compiler  may be prevented from performing an optimization of the compiled code that affects the at least one instruction signature-related placeholder.","To ease the ISS patching and reference value calculation the compiler\/linker \/ will provide additional information in a .debug_info DWARF section of the (.elf) file :\n\n","To be able to provide the additional instruction stream signature information the linker  has to be extended (e.g., by means of the extension ) to provide the required addresses, e.g. for the placeholder list.",{"@attributes":{"id":"p-0062","num":"0119"},"figref":["FIG. 3","FIG. 2"],"b":["210","212","210","202"]},"The language constructs may be passed from the compiler  to the compiler module  which may check whether the language construct gives rise to an insertion of an instruction-signature-related placeholder. To this end the compiler module  includes a language construct identifier . In case an instruction signature-relevant language construct has been detected, the language construct identifier  may inform a placeholder insertion component . In particular, the language construct identifier  may provide information about where the signature-relevant language construct is located in the source file (e.g., by means of a line number) and the type of the signature-relevant language construct.","Besides the automatic insertion of instruction signature-relevant placeholders, the compiler  and\/or the compiler module  may further provide for an adaptation of the standard code generation to keep the placeholders at the right position. Furthermore, the compiler  and\/or the compiler module  may further provide additional information to make the instruction signature generator  more reliable. If possible, the extension of the compiler  in order to add instruction signature support to the compiler  should have a minimal impact on the code generation and the high level language code should work without special code adaptation beside the usage of instruction stream signature library functions.","The compiler  and\/or the compiler module  may do a basic syntax checking for the ISS library functions. The following rules may be checked:\n\n","The placeholder insertion component  may then determine a placeholder to be inserted into the compiled code  or . For example, the placeholder insertion component  may determine the (binary) value of the placeholder, its size and its exact location (upstream, downstream, or within the standard instruction(s) of the compiled code produced by the compiler  in response to the instruction signature-relevant language construct). This placeholder information may then be sent back to the compiler  which uses it to insert it into the compiled code. The compiling of the source code  and the insertion of the instruction signature-relevant placeholders may be done step-by-step, i.e., as the compiling process advances, new placeholders are inserted at the program point currently under consideration by the compiler .","In the compiled code  or  the placeholder is inserted into the remainder of the compiled code, in particular the standard compiled instructions.","For the functions and code sequences enclosed with keywords or pragmas indicating the start and the end of ISS-enabled portions of the code, the compiler  may automatically insert instruction signature-relevant placeholders according to some basic rules described below.","For conditional code sequences the automatic insertion may be as follows: to handle a non-default path the compiler  has to insert an instruction signature-related placeholder for each conditional instruction. All conditional sequences (if-then-else, switch-case, while loop, do while loop, etc.) can be reduced to two base cases which have to be identified by the compiler  or the compiler module  and handled differently.","It is not required that the compiler  or the compiler module  does a default path analysis. The compiler  or the compiler module  may add instruction signature-related placeholders in all conditional paths. In case of unnecessary instruction signature-related placeholders the instruction signature generator  may patch them with NOPs (no operations).","A general rule may be that the compiler  or the compiler module  has to insert a placeholder in front of the next instruction executed after a conditional jump. However, for a do-while loop the compiler  or the compiler module  has to insert the placeholder directly at the label of the conditional jump (the back edge of the control flow graph).","The compiler module  may further include a database interface configured to query a database including a plurality of possible instruction signature-relevant language constructs and corresponding instruction signature-related placeholders for use by the language construct identifier and the placeholder insertion component. The database could also be a part of the compiler module . The database may include at least one insertion rule (typically a plurality of insertion rules) for controlling the placeholder insertion component regarding the inserting of the at least one instruction signature-related placeholder.",{"@attributes":{"id":"p-0073","num":"0134"},"figref":["FIG. 4","FIG. 3"],"b":["202","210","212","222","215","215","210","250","222"]},"The instruction signature generator  is configured to detect the placeholder and to determine the appropriate signature value which is then inserted into the compiled code  at the location of the placeholder. The instruction signature generator  outputs the compiled code  with instruction signatures .",{"@attributes":{"id":"p-0075","num":"0136"},"figref":["FIG. 5","FIG. 4"],"b":["250","250","251","253","255","251","222","246","210","251","212","253","253"]},"Once a placeholder has been found or generated by the placeholder identifier , information about the placeholder is forwarded to the signature calculator . As explained above, the signature calculator  is configured to calculate the actual signature value for the placeholder location that is currently processed. The signature value may be a start value, an update value, or a reference value as previously described herein. The signature calculator  may be configured to perform a basic block analysis on the compiled code on the basis of which the signature value is calculated.","The signature value determined by the signature calculator  and the information about, e.g., the placeholder location is supplied to the placeholder replacer  which is configured to perform the replacing of the placeholder with the calculated signature value. The compiled code segment provided or generated by the placeholder replacer  typically occupies a space in the compiled code that is equal to a space occupied by the instruction signature-related placeholder. The compiled code segment may include a processor instruction. The placeholder replacer  may be configured to select a particular processor instruction from a plurality of processor instructions and to generate the compiled code segment on the basis of the particular processor instruction.",{"@attributes":{"id":"p-0078","num":"0139"},"figref":"FIG. 6"},"At an action  an instruction signature-relevant language construct in a high level language source code is identified. This may be done on the basis of an identification of keywords or pragmas within the high level language source code.","An interaction with a compiling process is performed during a subsequent action  in order to insert at least one instruction signature-related placeholder based on the instruction signature-relevant language construct into a compiled code that is currently processed (or has already been processed) by a compiling process.","Although some aspects have been described in the context of an apparatus, these aspects also represent a description of the corresponding method, where a block or device corresponds to a method step or a feature of a method step. Analogously, aspects described in the context of a method step also represent a description of a corresponding block or item or feature of a corresponding apparatus. Some or all of the method steps may be executed by (or using) a hardware apparatus, like for example, a microprocessor, a programmable computer or an electronic circuit. In some embodiments, some one or more of the most important method steps may be executed by such an apparatus.","Depending on certain implementation requirements, embodiments of the invention can be implemented in hardware or in software. The implementation can be performed using a digital storage medium, for example a floppy disk, a DVD, a Blue-Ray, a CD, a ROM, a PROM, an EPROM, an EEPROM or a FLASH memory, having electronically readable control signals stored thereon, which cooperate (or are capable of cooperating) with a programmable computer system such that the respective method is performed. Therefore, the digital storage medium may be computer readable.","Some embodiments include a data carrier having electronically readable control signals, which are capable of cooperating with a programmable computer system, such that one of the methods described herein is performed.","Generally, the embodiments described herein can be implemented as a computer program product with a program code, the program code being operative for performing one of the methods when the computer program product runs on a computer. The program code may for example be stored on a machine readable carrier.","Other embodiments include the computer program for performing one of the methods described herein, stored on a machine readable carrier.","In other words, one embodiment is, therefore, a computer program having a program code for performing one of the methods described herein, when the computer program runs on a computer.","A further embodiment is, therefore, a data carrier (or a digital storage medium, or a computer-readable medium) including, recorded thereon, the computer program for performing one of the methods described herein. The data carrier, the digital storage medium or the recorded medium are typically tangible and\/or non-transitionary.","A further embodiment is, therefore, a data stream or a sequence of signals representing the computer program for performing one of the methods described herein. The data stream or the sequence of signals may for example be configured to be transferred via a data communication connection, for example via the Internet.","A further embodiment includes a processing means, for example a computer, or a programmable logic device, configured to or adapted to perform one of the methods described herein.","A further embodiment includes a computer having installed thereon the computer program for performing one of the methods described herein.","A further embodiment includes an apparatus or a system configured to transfer (for example, electronically or optically) a computer program for performing one of the methods described herein to a receiver. The receiver may, for example, be a computer, a mobile device, a memory device or the like. The apparatus or system may, for example, include a file server for transferring the computer program to the receiver.","In some embodiments, a programmable logic device (for example a field programmable gate array) may be used to perform some or all of the functionalities of the methods described herein. In some embodiments, a field programmable gate array may cooperate with a microprocessor in order to perform one of the methods described herein. Generally, the methods are preferably performed by any hardware apparatus.","Terms such as \u201cfirst\u201d, \u201csecond\u201d, and the like, are also used to describe various elements, regions, sections, etc. and are also not intended to be limiting. Like terms refer to like elements throughout the description.","As used herein, the terms \u201chaving\u201d, \u201ccontaining\u201d, \u201cincluding\u201d, \u201ccomprising\u201d and the like are open ended terms that indicate the presence of stated elements or features, but do not preclude additional elements or features. The articles \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural as well as the singular, unless the context clearly indicates otherwise.","It is to be understood that the features of the various embodiments described herein may be combined with each other, unless specifically noted otherwise.","Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and\/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts. The features of the various illustrated embodiments can be combined unless they exclude each other. Embodiments are depicted in the drawings and are detailed in the description which follows.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
