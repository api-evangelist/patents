---
title: Data compression system
abstract: A data compression scheme implemented based on V.42bis implemented in hardware within mobile units of a cellular system is disclosed. The data compression scheme includes a number of hardware state machines that perform data compression and decompression functions. Additionally, a dictionary of codewords and character strings is organized according to keys and is implemented as a balanced binary tree.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06961011&OS=06961011&RS=06961011
owner: Freescale Semiconductor, Inc.
number: 06961011
owner_city: Austin
owner_country: US
publication_date: 20010827
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND ART","SUMMARY OF THE PREFERRED EMBODIMENTS","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention is directed to communication systems and, more particularly, to data compression systems for efficiently transferring data.","Data compression systems seek to minimize an amount of information that needs to be stored or sent to convey a particular message. Data compression may be thought of as transferring a shorthand message to convey a long hand meaning. For example, if a sender and a receiver have agreed to the word \u201cHello\u201d by sending the number 5, as represented by eight bits, rather than sending five seven-bit ASCII (American Standard Code for Information Interchange) characters representative of the text, \u201cHello,\u201d the receiver knows that if it receives a 5, that 5 corresponds to the text \u201cHello.\u201d Such a system is a data compression system because eight bits representative of the number 5 may be transferred rather than the 35 bits associated with the ACSII text for \u201cHello.\u201d Various data compression schemes are known and are implemented in various systems such as, for example, data storage and data transfer.","One application in which data compression algorithms may be used is in digital communication systems. Digital communication systems typically include a mobile unit, which may be embodied in a digital cellular telephone or any other portable communication device, and an infrastructure unit, which may be embodied in a cellular base station or any other suitable communication hardware. During operation, the mobile unit and the infrastructure unit exchange digital information using one of a number of communication protocols. For example, the mobile and infrastructure units may exchange information according to a time division multiple access (TDMA) protocol, a code division multiple access (CDMA) protocol or a global system for mobile communications (GSM) protocol. The details of the TDMA protocol are disclosed in the IS-136 communication standard, which is available from the Telecommunication Industry Association (TIA). The GSM protocol is widely used in European countries and within the United States. The details of the GSM protocol are available from the European Telecommunications Standards Institute. The details of the second generation CDMA protocol are disclosed in the IS-95 communication standard. Third generation CDMA standards are typically referred to as Wideband CDMA (WCDMA). The most prevalent WCDMA standards that are currently being developed are the IS-2000 standard, which is an evolution of the IS-95 protocol, and the uniform mobile telecommunication system (UMTS) protocol, which is an evolution of the GSM protocol.","In addition to the conventional voice handling capabilities of digital communication systems, the integration of display screens into mobile units enable such units to receive graphical and text-based information. Additionally, as various other electronic devices such as, for example, personal digital assistants (PDAs) are used as wireless communication devices, such devices need to display graphical and text-based information. As mobile communication devices such as cellular telephones and PDAs receive text-based information, there is a need to compress and decompress information in an efficient manner so that mobile communication devices can provide textual information to users in a manner that is efficient from both a bandwidth perspective and a processing perspective.","One compression algorithm that is widely known and used is the Ziv and Lempel algorithm, which converts input strings of symbols or characters into fixed length codes. As strings are converted into the fixed length codes, the algorithm stores, in a dictionary, a list of strings and a list of fixed length codes to which the strings correspond. Accordingly, as the algorithm encounters strings that have already been encountered, the algorithm merely reads and transmits the fixed length code corresponding to that particular previously-encountered string. As will be readily appreciated, and as with most any compression technique, both the data transmitter and the data receiver must maintain identical codeword dictionaries containing codewords and the strings to which the codewords correspond.","Data compression for telecommunication applications is the focus of CCITT (The International Telegraph and Telephone Consultative Committee) Recommendation V.42bis, which is entitled \u201cData Compression Procedures for Data Circuit Terminating Equipment (DCE) Using Error Correction Procedures\u201d and is available from the International Telecommunication Union (ITU) (1990). The Recommendation V.42bis is hereby incorporated herein by reference. While the Recommendation V.42bis provides guidelines for data compression, the Recommendation does not provide specific details regarding the implementation of a system that is compliant with V.42bis.","As will be readily appreciated by those having ordinary skill in the art, processing speed and power are of great interest to those who implement a V.42bis based compression system. To that end, U.S. Pat. No. 5,701,468 to Benayoun et al. discloses a technique for organizing a codeword dictionary having four data fields. Benayoun et al. indicates that the proffered codeword dictionary structure facilitates the easy manipulation of codewords and strings and makes accesses to memory storing the dictionary faster. Benayoun et al. discloses that an instruction state machine reads software instructions from an external memory and executes such software instructions to coordinate the operation of various portions of hardware.","According to one aspect, the present invention may be embodied in an encoding system adapted to encode data strings into codewords. The encoding system may include a first memory portion adapted to store a dictionary of data strings and codewords corresponding to the data strings, wherein the dictionary is implemented as a balanced binary tree and a second memory portion adapted to store a data string to be processed. The system may also include an encoder adapted to receive from the second memory portion the data string to be processed, to determine if a codeword corresponding to a portion of the data string to be processed is stored in the dictionary and to output a codeword corresponding to a data string previously found in the dictionary if the codeword corresponding to the portion of the data string to be processed is not stored in the dictionary, wherein the encoder is further adapted to balance the dictionary.","According to a second embodiment, the present invention may be a decoding system adapted to decode codewords into data strings. The decoding system may include a memory adapted to store a dictionary of data strings and codewords corresponding to the data strings, wherein the dictionary is implemented as a balanced binary tree and an input buffer adapted to receive and store a set of codewords to be processed. Further, the system may include a decoder adapted to receive from the input buffer the set of codewords to be processed, to decode a first codeword into a first character string, to decode a second codeword into a second character string and to assign a third codeword to a combination of the first codeword and the second character string if a codeword corresponding to the combination of the first codeword and the second character string is not stored in the dictionary, wherein the decoder is further adapted to balance the dictionary.","According to a third aspect, the present invention may be embodied in an encoder adapted to operate with a first memory portion adapted to store a dictionary of data strings and codewords corresponding to the data strings, wherein the dictionary is implemented as a balanced binary tree, and a second memory portion adapted to receive and store a data string to be processed. In such an arrangement, the encoder may include a first hardware state machine adapted to receive from the second memory portion the data string to be processed and a second hardware state machine adapted to determine if a codeword corresponding to a portion of the data string to be processed is stored in the dictionary and to output a codeword corresponding to a data string previously found in the dictionary if the codeword corresponding to the portion of the data string to be processed is not stored in the dictionary. The encoder may also include a third hardware state machine adapted to balance the dictionary.","According to a fourth embodiment, the present invention may be embodied in a decoder adapted to operate with a memory adapted to store a dictionary of data strings and codewords corresponding to the data strings. The dictionary is implemented as a balanced binary tree, and an input buffer adapted to receive and store a set of codewords to be processed. In such an arrangement, the decoder may include a first hardware state machine adapted to receive from the input buffer the set of codewords to be processed and a second hardware state machine adapted to decode a first codeword into a first character string, to decode a second codeword into a second character string and to assign a third codeword to a combination of the first codeword and the second character string if a codeword corresponding to the combination of the first codeword and the second character string is not stored in the dictionary. The decoder may also include a third hardware state machine adapted to balance the dictionary.","These and other features of the present invention will be apparent to those of ordinary skill in the art in view of the description of the preferred embodiments, which is made with reference to the drawings, a brief description of which is provided below.","As described hereinafter, a data compression scheme implemented based on V.42bis may be implemented in hardware within mobile units. As opposed to a software implementation, the hardware implementation eliminates the need to retrieve instructions from memory and to execute the retrieved instructions. Rather, the hardware implementation operates using a number of hardware state machines that do not require the retrieval and execution of software instructions from memory. Accordingly, because a hardware implementation eliminates the need to retrieve instructions, a hardware implementation typically requires fewer clock cycles than a software implementation requests to achieve the same result.","Additionally, as described in detail hereinafter, the data compression hardware in the mobile unit uses an Adelson-Velskii and Landis (AVL) algorithm for storing codewords and their corresponding strings in a data dictionary that is a balanced binary tree. A balanced binary tree is most efficient directory structure to search because each search decision eliminates half of the remaining unsearched dictionary.","Because the mobile unit implements data compression in hardware and uses the AVL algorithm to create AVL trees, the data compression techniques used in the mobile unit allow for rapid codeword dictionary searching, codeword addition and codeword deletion to accommodate data rates up to 384 kilobits per second (kbps). The codeword dictionary, which is implemented as an AVL tree that is balanced binary tree, may be searched in O(logn) time, wherein n is the size of the dictionary. The speed of searching an AVL tree is due to the fact that an AVL tree is balanced at that each binary search operation eliminates half of the unsearched AVL tree entries.","As shown in , a data communication system generally includes a first and second data transceivers  and , respectively. For example, the first data transceiver  may be embodied in a cellular infrastructure base station having a data source  and a data sink , each of which is connected to a V.42bis module . The V.42bis module  is further connected to a radio frequency (RF) module, which, in turn, is coupled to an antenna . In general, the V.42bis module  translates between codewords and characters.","For example, in data transmission operation, the data source  couples characters for transmission to the second data transceiver  to the V.42bis module , which compresses the characters into codewords that are coupled to the RF module  and broadcast as RF energy from the antenna . Conversely, during data reception operation, the antenna  receives RF energy that the RF module  converts into data signals representative of codewords that are coupled to the V.42bis module . In the receive path, the V.42bis module  converts the codewords from the RF module  into characters that are coupled to the data sink . In the example provided, the data source  and the data sink  are representative of any suitable data processing or storage hardware and\/or software.","The second data transceiver  may be embodied in the hardware of a mobile unit such as a cellular telephone or a PDA. Because most of the following description contained herein pertains to the second data transceiver , sufficiently more detail is provided with respect to the second data transceiver  than was provided with respect to the first data transceiver . The second data transceiver  includes an antenna  coupled to an RF module , which, in turn, is coupled to a digital signal processor (DSP) . The DSP  is coupled to a host interface , which communicatively couples the DSP  to a processor data bus .","As shown in , numerous components are coupled to the processor data bus . Such components include a processor , a direct memory access (DMA) module , an external memory controller  and a bridge . The bridge  communicatively couples the processor data bus  and, therefore, each of the components coupled thereto to a peripheral data bus .","A keypad interface , a serial interface  and a V.42bis module , of which further details are provided below, are each coupled to the peripheral data bus . The V.42bis module  is further coupled to both the processor data bus  and the DMA module .","Each of the components - may be embodied in integrated hardware that is fabricated from semiconductor material. Interfaced to the EMC , the keypad interface and the serial interface  are a memory , a keypad  and a display , respectively. Each of the memory , the keypad  and the display  are external to the integrated hardware embodying components -.","As with the first data transceiver , the second data transceiver  is adapted both to send and to receive information. In general, in the receive path, the second data transceiver  receives signals representative of codewords and processes those codewords to obtain the characters the codewords represent by looking the received codewords up in a data dictionary, which, as described in further detail below, is contained in the V.42bis module . The characters may then be displayed to the user via the display , which may be embodied in a liquid crystal display (LCD), a light emitting diode (LED) display or any other suitable display technology.","Alternatively, in the receive path, the second data transceiver  may receive characters for which codewords are not yet selected and may display such characters to the user. Additionally, when characters are received, the V.42bis module  may assign codewords to those characters so that, in the future, relatively short codewords, as opposed to the relatively long characters, may be exchanged between the first and second data transceivers , .","In the transmit path, previously used characters or strings of characters from the memory  or the keypad  are processed into codewords by the V.42bis module  and the codewords may be transmitted from the second data transceiver  to the first data transceiver . If, however, the characters or string of characters has not been previously transmitted, the V.42bis module  may assign a codeword thereto so that the codeword may be used to represent the string of characters. Further detail regarding the operation of the V.42bis module  is provided hereinafter in conjunction with .","As noted with respect to , certain components of the second data transceiver  may be integrated into hardware.  illustrates the process by which such an integration may be performed. For example, as shown at the block , code written in a software language, such as a register-transfer-level (RTL) synthesis language like Verilog, is provided to a well known synthesis module . Verilog, for example, is a hardware description language used to design and document electronic systems, which allows designers to design at various levels of abstraction. The code represents the functionality that is desired for a particular portion of hardware that will be designed by the synthesis module . The code may be written in programming structures such as routines and subroutines that may be used to create hardware state machines that operate without the need to read instructions from a memory. As further shown in , constraints , such as clocks and I\/O timing, are provided to the synthesis module .","The synthesis module  processes the RTL programming or code  and the constraints  to produce a netlist. The netlist specifies all of the hardware blocks and interconnections that must be fabricated in semiconductor material to carry out the functionality written in the RTL programming. The netlist may be sent to a semiconductor foundry, which will process the netlist into a semiconductor hardware device.","Having generally described the first and second data transceivers ,  and the process by which hardware components are specified and fabricated, the details of the V.42bis module  will now be described. In particular, the various hardware blocks and state machines that comprise the V.42bis module will be described, it being understood that such hardware blocks and state machines could be produced as described in conjunction with  or in any other suitable manner.","Table 1 below includes a number of definitions that are used hereinafter in conjunction with the description of the data compression system.",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Character Single","Data element encoded using a predefined number of"]},{"entry":[{},"bits (N= 8)."]},{"entry":["Ordinal Value","Numerical equivalent of the binary encoding of the"]},{"entry":[{},"character. For example, the character \u201cA\u201d, when"]},{"entry":[{},"encoded as 01000001, would have an ordinal value"]},{"entry":[{},"of 65."]},{"entry":["Alphabet","Set of all possible characters that may be sent or"]},{"entry":[{},"received across the interface. It is assumed that the"]},{"entry":[{},"ordinal values of the alphabet are contiguous from 0"]},{"entry":[{},"to N\u2212 1, where Nis the number"]},{"entry":[{},"of characters."]},{"entry":["Codeword","The binary number in the range 0 to N\u2212 1"]},{"entry":[{},"that represents a string of characters in compressed"]},{"entry":[{},"form. A codeword is encoded using a number of bits"]},{"entry":[{},"C, where Cis initially 9 (N+ 1) and increases"]},{"entry":[{},"to a maximum of Nbits."]},{"entry":["Control Codeword","Reserved for use in signaling of control information"]},{"entry":[{},"related to the compression function while in the"]},{"entry":[{},"compressed mode of operation."]},{"entry":["Command Code","Octet which is used for signaling of control"]},{"entry":[{},"information related to the compression function"]},{"entry":[{},"while in the transparent mode of operation."]},{"entry":[{},"Command codes are distinguished from normal"]},{"entry":[{},"characters by a preceeding escape character."]},{"entry":["Tree Structure","Abstract data structure to represent a set of strings"]},{"entry":[{},"with the same initial character."]},{"entry":["Leaf Node","Point on a tree that represents the last character in a"]},{"entry":[{},"string."]},{"entry":["Root Node","Point on a tree that represents the first character in a"]},{"entry":[{},"string."]},{"entry":["Compressed","Compressed operation has two modes as defined"]},{"entry":[{},"below."]},{"entry":["Operation","Transitions between these modes may be automatic"]},{"entry":[{},"based on the content of the data received."]},{"entry":["Compressed Mode","A mode of operation in which data is transmitted in"]},{"entry":[{},"codewords."]},{"entry":["Transparent Mode","A mode of operation in which compression has been"]},{"entry":[{},"selected but data is being transmitted in uncom-"]},{"entry":[{},"pressed form. Transparent mode command code seq-"]},{"entry":[{},"uences may be inserted into the data stream."]},{"entry":["Uncompressed","A mode of operation in which compression has not"]},{"entry":["Operation","been selected. The data compression func-"]},{"entry":[{},"tion is inactive."]},{"entry":["Escape Character","Character that during transparent mode indicates the"]},{"entry":[{},"beginning of a command code sequence. This has an"]},{"entry":[{},"initial value of zero, and is adjusted on each app-"]},{"entry":[{},"earance of the escape character in the data stream,"]},{"entry":[{},"whether in transparent or compressed mode."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 2 is a list of parameters that are used hereinafter in description of the compression system.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["N","Maximum codeword size (bits)"]},{"entry":["N","Total number of codewords"]},{"entry":["N","Character size (bits). N= 8."]},{"entry":["N","Number of characters in the alphabet. N= 2N."]},{"entry":["N","Index number of first dictionary entry used to store a string. N="]},{"entry":[{},"N+ N."]},{"entry":["N","Number of control codewords. N= 3."]},{"entry":["N","Maximum string length."]},{"entry":["C","Next empty dictionary entry."]},{"entry":["C","Current codeword size."]},{"entry":["C","Threshold for codeword size change."]},{"entry":["P","V.42bis data compression request."]},{"entry":["P","Number of codewords (negotiation parameter)."]},{"entry":["P","Maximum string size (negotiation parameter)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The V.42bis module , as shown in , includes a register file  or buffer that is coupled to the peripheral bus . The register file  is coupled to an encoder  and to a decoder . The details of the encoder  and the decoder  are described in conjunction with . The V.42bis module  further includes a bus interface  that couples the encoder  and the decoder  to the processor bus . The encoder  and the decoder  are further coupled to the DMA .","During operation of the V.42bis module , the encoder  receives character strings and produces codewords corresponding to the character strings and the decoder  receives codewords and produces the character strings corresponding to the codewords. The character strings and codewords may be coupled to the processor bus  via the bus interface . Alternatively, the encoder  and the decoder  may receive characters or codewords from the DMA .","Referring now to , the encoder  includes a controller module , a process character module , a data engine module  and a codeword dictionary module , all of which may be interconnected by a bus . In operation, the encoder  compresses character data into codewords and exchanges data, either character data or codewords, with the processor  or the DMA . The main functions of the encoder , as described in detail hereinafter, include communications with an encoder dictionary that may be implemented in the memory  to, for example, look up strings, to update the encoder dictionary and to remove nodes from the encoder dictionary. The encoder  supports both transparent and compressed modes of operation and also performs compressibility tests to switch between the compressed and transparent modes of operation. Further, the encoder  supports peer-to-peer communication.","Each of the modules of the encoder modules -module  is described in detail hereinafter with respect to  and -. In particular,  and - represent a number of state machines having various states through which the state machines cycle. As will be readily appreciated by those having ordinary skill in the art, such state machines may be implemented in hardware using gates such as flip-flops, or any other suitable hardware components. The following description of state machines adopts the nomenclature of all capital letters when referring to states and lower case letters when referring to transitions between states. Additionally, the following description refers to various register, signals or variable names, which are shown in italic typeface.","The controller module  controls the overall functionality of the encoder  and may be represented by a state machine , which is shown in FIG. . The state machine  begins operation in an IDLE state . Once the encoder  is enabled, the state machine  transitions from the IDLE state  to a RESET_DICT state , where the state machine  asserts a reset_dictionary output to the codeword dictionary module , which initializes the codeword dictionary module . Initialization consists of ensuring that each tree includes only root nodes (the alphabet plus the control codewords), ensuring that the codeword associated with each root shall be Nplus the ordinal value of the character and ensuring that the counter, C, used in the allocation of new nodes, shall be set to N.","If the encoder  is in test mode, the state machine  transitions from the RESET_DICT state  to a DICT_TEST state  after initialization. The test mode is used for verification of the AVL algorithm and provides a direct register interface to the codeword dictionary module . While in the DICT_TEST state , three dictionary functions (search, insert and delete) are accessible through a test register.","If, however, the encoder  is not in test mode, control passes from the RESET_DICT state  to a WAIT_FOR_INPUT state , in which the state machine  waits for a character input from one of several sources, such as, for example, a new character, change mode request, flush request or a reset request. If the data engine  indicates that a new character is received, the state machine transitions  to a PROC_CHAR state , at which the process character module  is enabled. In the PROC_CHAR state , the controller  asserts a proc_char output to the process character module . Once the process character module  completes its execution, it asserts a proc_char_done output, which causes the state machine  to transition back to the WAIT_FOR_INPUT state .","If the processor  requests a mode change, the state machine  transitions from the WAIT_FOR_INPUT state  to a CHANGE_MODE state . In the CHANGE_MODE state , the state machine  asserts a change_mode output to the data engine module . Once the data engine module  has sent the appropriate characters\/codewords to change modes, it asserts change_mode_done output, which causes the state machine  to transition back to the WAIT_FOR_INPUT state .","If the processor  requests reset of the codeword dictionary module , the state machine  transitions to the RESET_DICT state . Alternatively, if the processor  requests a flush, the state machine transitions  to a FLUSH state . In the FLUSH state , the state machine  asserts a flush output to the data engine module . The data engine module  sends any queued bits and asserts flush_done, at which point the state machine  transitions to the WAIT_FOR_INPUT state .","The controller  maintains the mode of the encoder  in a mode register, which is initialized to zero to indicate that the encoder  is in transparent mode. When the state machine  is in the CHANGE_MODE state  and the change_mode_done signal is asserted, the mode register toggles, thereby switching the mode of the encoder . If the state machine  is in the RESET_DICT state , the mode register is reset to zero, thereby placing the encoder in transparent mode.","The controller  also includes a storage element named string_empty to indicate if the current string is empty. When set, string_empty indicates there are is no accumulated string of characters and the next character is the beginning of a new string. When zero, string_empty indicates that there exists a string and that the next character should be appended to that string. String_empty is initialized to one on system reset and it is cleared when the state machine  transitions from the WAIT_FOR_INPUT state  to the PROC_CHAR state . String_empty is set when the state machine  transitions from either the FLUSH state  or CHANGE_MODE state .","Another register, named exception, informs the process character module  when an exception occurs. The exception register is initialized to zero on system reset and it is set when the state machine  transitions from either the CHANGE_MODE state  or the FLUSH state . The exception register is cleared on a transition from the PROC_CHAR state .","The process character module , as represented by a state machine  shown in  receives a new character from the data engine  and implements the decision making logic needed to process the character. The process character module  maintains string_code and char storage elements, which are used to store the current string and new character, respectively. An 11-bit register, last_inserted_codeword, indicates the codeword most recently inserted into the codeword dictionary module , which prevents the encoder  from sending a codeword before defying it. Finally, a 5-bit register, string_length, tracks how many characters are contained in string_code+char.","The state machine  of , begins operation in an IDLE state  upon system reset. Once the controller  asserts the proc_char signal, the state machine  transitions from the IDLE state  to a SEARCH state . During this transition, the string_length registers are incremented, thereby indicating the string has added another character.","In the SEARCH state , the search output is asserted to the codeword dictionary module  as an indication to search for string_code+char. Once the search is complete, the next state is determined by the state of exception. If exception is zero and string_code+char is not found, the state machine  transitions from the SEARCH state  to a SEND_CODEWORD , if the encoder  is in compressed mode. Alternatively, if the encoder  is in transparent mode and exception is zero and sting_code+chair is not found, the state machine  transitions from the SEARCH state  to an UPDATE_DICT state .","If string_code+char is found with codeword equal to last_inserted_codeword, the state machine  transitions from the SEARCH state  to a FOUND_LAST_INSERTED_CODEWORD state . Finally, if string_code+char is found and its codeword does not equal last_inserted_codeword, the state machine  transitions from the SEARCH state  to an ADD_TO_STRING state . If string_code+char is not found, it will be added to the to the codeword dictionary module , as described below in detail with respect to the codeword dictionary . Additionally, the process character module  will store C(the codeword string_code+char is assigned) in last_inserted_codeword register.","In the FOUND_LAST_INSERTED_CODEWORD state , the state machine  resets last_inserted_codeword to zero, which indicates that the codeword of the most recent string_code+char added to the codeword dictionary module  can be sent. If the variable exception is set, the state machine  transitions from the FOUND_LAST_INSERTED_CODEWORD state  to a RESET_STRING state . If exception is not set, the next state is SEND_CODEWORD  if the encoder  is in compressed mode or UPDATE_DICT  if the encoder  is in transparent mode.","In the ADD_TO_STRING state , the state machine  stores the codeword corresponding to string_code+char, which was found in the codeword dictionary module , in string_code. If the encoder  is in compressed mode, the state machine  transitions from the ADD_TO_STRING state  to a DONE state . Alternatively, if the encoder  is in transparent mode, the state machine  transitions from the ADD_TO_STRING state  to a SEND_CHAR state .","In the SEND_CODEWORD state , the state machine  informs the data engine  to send the codeword stored in string_code, because string_code+char was not found and the encoder  is in compressed mode. Once the data engine  indicates that the transmission is complete, the state machine  transitions from the SEND_CODEWORD state  to the UPDATE_DICT state .","In the SEND_CHAR state , the state machine  informs the data engine  to send char. Once the transmission is complete, the state machine  transitions from the SEND_CHAR state  to the DONE state .","In the UPDATE_DICT state , the state machine  waits for the codeword dictionary module  to complete the insertion of string_code+char. Once the codeword dictionary module  indicates that the insertion is finished, the state machine  transitions from the UPDATE_DICT state  to the RESET_STRING state .","In the RESET_STRING state , the state machine  resets string_code to (char+3), which is the codeword for char. Also, string_length is reset to 1. On the next clock cycle, the state machine  transitions from the RESET_STRING state  to the DONE state .","In the DONE state , the state machine  asserts the proc_char_done output, which indicates to the controller  that the character has been processed. On the next clock cycle, the state machine  transitions from the DONE state  back to the IDLE state , in which the state machine  waits for a new character.","The data engine module  of  includes both a receive state machine and a transmit (TX) state machine, which are described hereinafter in conjunction with , respectively. In general, the data engine module  is responsible for receiving input characters and transmitting output characters and codewords. The data engine module  contains a first-in, first-out (FIFO) buffer that accepts variable length bit inputs, but always outputs 8-bit data, as described in conjunction with .","Turning now to , an RX state machine  begins execution at an RX_IDLE state . Once the controller state machine  () reaches the WAIT_FOR_INPUT state , the RX state machine  transitions to a RX_DMA_WAIT_STAT state . In the RX_DMA_WAIT_STAT state , the encoder  requests the DMA  to retrieve a next character from the memory . Once the DMA  indicates that the character is available, the RX state machine  stores the character in an 8-bit character register and transitions to a RX_DMA_STB state .","In the RX_DMA_STB state , the RX state machine  indicates to the DMA  that the character has been received. On the next clock cycle, the RX state machine  transitions to a RX_CHAR_VALID state . In this state, the RX state machine  asserts a character_valid output to the controller , thereby indicating that the encoder  has a new character to be processed. Once the process character module  asserts the proc_char_done signal, which indicates that the character has been processed, the RX state machine  transitions back to the RX_IDLE state .","The transmit state machine , as shown in , operates in both transparent and compressed modes of operation. The compressed mode of operation is complicated by the fact that the process character module  sends 9, 10 or 11-bit codewords, but only 8 bits are transmitted at a time by the FIFO buffer of the data engine module . A variable bit input FIFO is used to solve this problem. While 8, 9, 10 or 11-bit inputs are pushed on the FIFO, only 8-bit outputs are popped from the FIFO buffer.","An 8-bit register, escape_char, is used to maintain the value of the escape character. A 4-bit register, C, is used to maintain a record of the current codeword size. A 12-bit register, C, maintains a record of the threshold for codeword size changes. Cand Care defined as being the current codeword size and the threshold for codeword size change, respectively.","Referring to , the TX state machine  is initialized to TX_IDLE state  upon system reset. If the process character module  informs the TX state machine  indicates to send data and if the encoder  is in compressed mode, the TX state machine  transitions from the TX_IDLE state  to a TX_CHECK_SIZE state . Alternatively, if the encoder  is in transparent mode and the process character module  indicates to send data, the TX state machine  transitions from the TX_IDLE state  to a TX_WRITE_CHAR state .","If the controller  indicates to change the mode of the encoder  and the encoder  is in compressed mode, the TX state machine  transitions from the TX_IDLE state  to a TX_EMPTY_STRING . Alternatively, if the controller  indicates to change mode and the encoder  is in transparent mode, the TX state machine  transitions from the TX_IDLE state  to a TX_WRITE_ESC state .","If the controller  indicates that the encoder  should be flushed and, if the encoder  is in compressed mode, the TX state machine  transitions from the TX_IDLE state  to the TX_EMPTY_STRING state . Alternatively, if the controller  indicates to flush the encoder  and the encoder  is in transparent mode, the TX state machine  transitions from the TX_IDLE state  to a TX_DONE state .","If the controller  indicates that the encoder  is to be reset, the TX state machine  transitions from the TX_IDLE state  to a TX_WRITE_ESC_RESET state . Finally, if none of the foregoing conditions are met, the TX state machine  remains in the TX_IDLE state .","In the TX_CHECK_SIZE state , the TX state machine  compares string_code (from the process character module ) with C, which is the threshold for codeword size change. If string_code is greater than or equal to C, the number of bits used to represent the codeword must be incremented. Accordingly, the next state is a TX_WRITE_STEPUP state . Otherwise, codeword can be represented in Cbits, and the next state is a TX_WRITE_CODEWORD state .","In the TX_WRITE_STEPUP state , the control codeword for STEPUP (0x2) is pushed onto the FIFO with a width of Cbits and Cis incremented and Cis multiplied by 2. On the next clock cycle, the TX state machine  transitions to the TX_CHECK_SIZE state .","In the TX_WRITE_CODEWORD state , string_code is pushed onto the FIFO with a width of Cbits. If the change_mode signal from the controller is not asserted, the next state is a TX_CHECK_FIFO state . Otherwise the next state is a TX_WRITE_ETM state , in which the control codeword for ETM (0x0) is pushed onto the FIFO with a width of Cbits.","In the TX_WRITE_CHAR state , the TX state machine  pushes character onto the FIFO with a width of 8 bits. On the next clock cycle, the TX state machine  transitions from the TX_WRITE_CHAR state  to a TX_CHECK_ESC state .","In the TX_CHECK_ESC state , char is compared with escape_char. If the two are equal and the encoder  is in transparent mode, the TX state machine  transitions from the TX_CHECK_ESC state  to a TX_WRITE_ED state . Alternatively, if the two are equal and the encoder is in compressed mode, the TX state machine  transitions to a TX_CYCLE_ESC state . If char does not equal escape_char, the next state is the TX_CHECK_FIFO state .","In the TX_WRITE_EID state , the command code for EID (0x1) is pushed onto the FIFO with a width of 8 bits. On the next clock cycle, the TX state machine  transitions to the TX_CYCLE_ESC state . In the TX_CYCLE_ESC state , escape_char is incremented by  modulo . On the next clock cycle, the TX state machine  transitions to the TX_CHECK_FIFO state .","In the TX_EMPTY_STRING state , the TX state machine  evaluates string_empty from the controller . If string_empty is clear (zero), the TX state machine  transitions from the TX_EMPTY_STRING state  to the TX_CHECK_SIZE state , because valid data that must be sent is stored in string_code. If both string_empty and flush_encoder are set by the controller  and the FIFO is not empty, the TX state machine  transitions to a TX_WRITE_FLUSH state . Alternatively, if both string_empty and flush_encoder are set from the controller  and the FIFO is empty, the TX state machine  transitions to the TX_DONE state . Finally, if string_empty is set, but flush_encoder is clear, the TX state machine  transitions to the TX_WRITE_ETM state .","In the TX_WRITE_FLUSH state , the control codeword for FLUSH (0x1) is pushed onto the FIFO with a width of Cbits. At the same time, the local register wrote_flush is set to one, indicating that FLUSH was written to the FIFO. On the next clock cycle, the TX state machine  transitions to the TX_CHECK_FIFO state .","In the TX_WRITE_ESC state , the current value of escape_char is pushed onto the FIFO with a width of 8 bits. On the next clock cycle, the TX state  machine transitions to a TX_WRITE_ECM state . In this state, the command code for ECM (0x0) is pushed onto the FIFO with a width of 8 bits. On the next clock cycle, the TX state machine  transitions to the TX_CHECK_FIFO state .","In the TX_WRITE_ESC_RESET state , the current value of escape_char is pushed onto the FIFO with a width of 8 bits. On the next clock cycle, the TX state machine  transitions to a TX_WRITE_RESET state , in which the command code for RESET (0x2) is pushed onto the FIFO with a width of 8 bits. On the next clock cycle, the TX state machine  transitions to the TX_CHECK_FIFO state .","In the TX_CHECK_FIFO state , the depth of the FIFO (in bits), which is represented by fifo_depth, is compared with 8. If fifo_depth is greater than or equal to 8, there is sufficient data in the FIFO to transmit and the TX state machine  transitions to a TX_POP_FIFO state . Alternatively, there is insufficient data in the FIFO to transmit an octet of data. If flush_encoder is asserted and the FIFO is empty, the TX state machine  transitions to the TX_DONE state , because there are no more data to transmit. Alternatively, less than 8 bits of data remain to be transmitted. If wrote_flush is one, the TX state machine  transitions from the TX_CHECK_FIFO state  to a TX_FLUSH_FIFO state . If wrote_flush is zero, the TX state machine  transitions from the TX_CHECK_FIFO state  to the TX_WRITE_FLUSH state . Alternatively, if fifo_depth is less than 8 and change_mode is asserted, all data in the FIFO must be flushed. Accordingly, the TX state machine  transitions from the TX_CHECK_FIFO state  to the TX_FLUSH_FIFO state . If none of the foregoing conditions is met, no further action is required and the TX state machine  transitions to the TX_DONE state .","In the TX_POP_FIFO state , the oldest value in the FIFO is popped and denoted as a variable called fifo_data_out. On the next clock cycle, the TX state machine  transitions to a TX_DMA_WAIT_STAT state , in which the TX state machine  waits for the DMA  to indicate that it transmitted fifo_data_out. After the execution of the TX_DMA_WAIT_STAT state , the TX state machine  transitions to a TX_DMA_STB state . In this state, the TX state machine  acknowledges the DMA  and transitions to the TX_CHECK_FIFO state .","In the TX_FLUSH_FIFO state , the TX state machine  requests a FIFO flush. The FIFO responds by zero-padding any remaining bits onto fifo_data_out to preserve octet alignment. On the next clock cycle, the TX state machine  transitions to the TX_DMA_WAIT_STAT state .","Referring now to , the decoder  includes a controller module , a process data module , a data engine module  and a decoder dictionary module , all of which may be interconnected by a bus . In operation, the decoder  decompresses codewords into character data and exchanges data, either character data or codewords, with the processor  or the DMA . The main functions of the encoder , as described in detail hereinafter, include communications with the decoder dictionary that may be embodied in the memory  to, for example, look up strings, to update the decoder dictionary and to remove nodes from the decoder dictionary. The decoder  supports both transparent and compressed modes of operation and also performs compressibility tests to switch between the compressed and transparent modes of operation. Further, the decoder  supports peer-to-peer communication.","Each of the decoder modules - is described in detail hereinafter with respect to . In particular,  represent a number of state machines having various states through which the state machines cycle. As will be readily appreciated by those having ordinary skill in the art, such state machines may be implemented in hardware using gates such as flip-flops, or any other suitable hardware components. The following description of state machines adopts the nomenclature of all capital letters when referring to states and lower case letters when referring to transitions between states. Additionally, as with the previous description pertaining to state machines, the following description refers to various registers, signals or variable names, which are shown in italic typeface.","As shown in , the controller module  of  may be represented as a controller state machine , which controls the overall functionality of the decoder . The controller module  maintains the following registers: escape_character, C, exception, and mode. Escape_character contains the current value for the escape character, which is a special character used for peer-to-peer communications. Cstores the codeword size. The exception register indicates if the data must be processed as an exception (after a flush), which is thoroughly described in the V.42bis specification. The mode register stores the current mode of the decoder . If mode is 0, the decoder  is in transparent mode and if mode is 1, the decoder  is in compressed mode.","The controller state machine  initializes to an IDLE state  upon system reset. Once the decoder  is enabled, the controller state machine  transitions from the IDLE state  to a RESET_DICT state . In the RESET_DICT state , the codeword dictionary module  is directed to initialize itself. Additionally, after initialization, both escape_character and mode are reset to 0. Once these operations are complete the controller state machine  transitions to a WAIT_FOR_INPUT state .","In the WAIT_FOR_INPUT state , the controller state machine  requests the data engine module  to retrieve data. If the decoder  is in transparent mode, the data engine module  will retrieve an 8-bit character. Alternatively, if the decoder  is in compressed mode, the data engine module  will retrieve a Cbit codeword. Once the data engine  indicates that data is available by asserting a variable called data_valid, the controller state machine  determines the next state.","If the decoder  is in transparent mode and the character equals escape_char, the controller state machine  transitions to a PROCESS_ESC state . Otherwise the controller state machine  transitions to a PROCESS_DATA state . If the decoder  is in compressed mode, the codeword is compared with the control codewords. If the codeword is ETM (0x0), the controller state machine  transitions from the WAIT_FOR_INPUT state  to a CHANGE_MODE state . If the codeword is FLUSH (0x1), the controller state machine  transitions to a FLUSH state . If the codeword is STEPUP (0x2), controller state machine  transitions to a STEPUP state . Finally, if the codeword does not equal any of the above control codewords, the next state is the PROCESS_DATA state .","In the PROCESS_ESC state , another character is requested from the data engine module . The requested character is compared with the command codes. If the requested character equals ECM (0x0), the next state is the CHANGE_MODE state . If the requested character equals EID (0x1), the next state is the PROCESS_DATA state  and escape_char is incremented by  modulo . Alternatively, if the new character equals RESET (0x2), the controller state machine  transitions to a RESET_DECODER state .","In the RESET_DECODER state , escape_character is reset to 0x0 and Cis reset to 0x9. On the next clock cycle, the controller state machine  transitions from the RESET_DECODER state  to the RESET_DIC state .","In the PROCESS_DATA state , proc_data is asserted to the process data module  to indicate that data was retrieved. Once the process data module is finished, which is indicated by a variable called proc_data_done, exception is reset to 0 and the controller state machine  transitions back to the WAIT_FOR_INPUT state .","In the CHANGE_MODE state , exception is set to 1 and mode is toggled. On the next clock cycle, the controller state machine  transitions to the WAIT_FOR_INPUT state .","In the FLUSH state , if the decoder  is in compressed mode, exception is set to 1. On the next clock cycle, the controller state machine  transitions to the WAIT_FOR_INPUT state .","In the STEPUP state , Cis incremented. On the next clock cycle, the controller state machine  transitions to the WAIT_FOR_INPUT state .","As shown in , a state machine  for the process data module  of  includes number of states with state transitions therebetween. In general, the process data module  processes received characters\/codewords from the data engine module . The process data module  maintains a number of registers. A register called tx_data represents the decoded data to be transmitted. A registered called last_inserted_codeword stores the most recent codeword added to the codeword dictionary module  and is used in the same manner as the encoder process character module  of FIG. . Registers called String_code and char represent the current string_code+char combination, respectively. A register called string_length represents the length of the string represented by string_code+char. Additionally, the process data module  includes a stack that is used in compressed mode to decode input codewords.","The state machine  of  is initialized to an IDLE state  upon system reset. The lower 8 bits of the input data from the controller , which are referred to as data_to_process, are stored in a register called tx_data when the state machine  is in the IDLE state . Once the controller  asserts proc_data, the state machine  transitions from the IDLE state  to a READ_CODEWORD state  if the decoder  is in compressed mode. Alternatively, if the decoder  is in transparent mode, the state machine  transitions from the IDLE state  to a SEND_CHAR state . As the state machine  transitions out of the IDLE state , string_length is incremented.","In the READ_CODEWORD state , the decoder  reads the dictionary entry stored at data_to_process, which is a codeword. The contents of data_to_process are stored locally as prev_code and attach_char. Once the read operation is complete, the state machine  transitions to a PUSH_STACK state .","In the PUSH_STACK state , attach_char is pushed onto the stack. If prev_code is zero (indicating the first character of the string has been found), char is set to attach_char (the first character of the string) and the stack depth is stored locally as new_string length (number of characters in the string), after which the state machine  transitions to POP_STACK . If prev_code does not equal zero, the state machine  transitions back to the READ_CODEWORD state , where the dictionary entry stored at prev_code is read.","In the POP_STACK state , the most recent entry in the stack is removed and stored in tx_data. On the next clock cycle, the state machine  transitions to the SEND_CHAR state .","In the SEND_CHAR state , the data engine module  is directed to send tx_data. If the decoder  is in transparent mode, char is set to data_to_process[:]. Once tx_data has been transmitted, the next state is determined. If the decoder  is in transparent mode, the state machine  transitions to a SEARCH state . Alternatively, if the decoder  is in compressed mode and character stack is not empty, the state machine  transitions to the POP_STACK state  to get the next character in the string. Finally, if the decoder  is in compressed mode and the character stack is empty, the state machine  transitions to the SEARCH state , because the last character in the string has been transmitted.","In the SEARCH state , the codeword dictionary module  is directed to search for string_code+char. The codeword dictionary module  will automatically assign a codeword (C) to string_code+char. Alternatively, if string_code+char is not found, it will be added to the codeword dictionary module . Once the codeword dictionary module  indicates that the search is complete, the next state is determined.","If the decoder  is in transparent mode and string_code+char is not found, the next state is an UPDATE_DICT state . If string_code+char is found and the codeword corresponding to string_code+char equals last_inserted_codeword, the next state is a RESET_STRING state . Additionally, if string_code+char is found and exception is set, the next state is the RESET_STRING. Finally if string_code+char is found and the above two conditions are not met, the state machine  transitions to an ADD_TO_STRING state  and last_inserted_codeword is reset to zero. In compressed mode, the state machine  transitions to a SET_STRING state  if string_code+char is found and transitions to the UPDATE_DICT state  if string_code+char is not found. Also, if string_code+char is not found, last_inserted_codeword is replaced with C, the codeword that string_code+char will be assigned.","In the ADD_TO_STRING state , string_code is replaced with codeword found in the SEARCH state . On the next clock cycle, the state machine  transitions to a DONE state .","In the UPDATE_DICT state , the state machine  waits for the codeword dictionary module  to complete its operation. Once complete, the state machine  transitions to the SET_STRING state  if the decoder  is in compressed mode or to the RESET_STRING state  if the decoder  is in transparent mode.","In the SET_STRING state , string_code is assigned the input codeword, data_to_process and string_length is assigned new_string_length, which is the length of the string represented by data_to_process. On the next clock cycle, the state machine  transitions to the DONE state .","In the RESET_STRING state , string_code is assigned the codeword that represents the input character, or data_to_process[:]+3 and String_length is reset to 1. On the next clock cycle, the state machine  transitions to the DONE state .","In the DONE state , the state machine  asserts proc_data_done to the decoder controller module , thereby indicating that the process data module  has processed data_to_process. On the next clock cycle, the state machine  transitions to the IDLE state .","The data engine module  of the decoder  receives character\/codeword data and transmits decoded characters. As shown in , the data engine module  includes a receive (RX) state machine  and a transmit (TX) state machine .","The data engine module  also includes a variable bit output, 8-bit input RX FIFO. The RX FIFO is used to align the data according to the mode of the decoder  (compressed or transparent). The RX FIFO receives 8-bit inputs, but can output variable bit length data. A 32-bit register, named mem, is used to store the data. A 5-bit register, named addr_in, is a pointer to the next available bit in mem.","When data is written to the RX FIFO, it is shifted by addr_in, and stored in mem so that data[] is stored in mem[addr_in] and data[] is stored in mem[addr_in+7], and addr_in is incremented by 8. When data is read from the RX FIFO, the data engine  of  must indicate how many bits are to be read. The number of bits to be read is denoted as fifo_data_out_size. The appropriate number of bits are stored in the 11-bit register named fifo_data_out. If fifo_data_out_size equals 8, fifo_data_out is set to {3\u2032b, mem[:]}. If fifo_data_out_size equals 9, fifo_data_out is set to {2\u2032b, mem[:]}, and so on. Subsequently, mem is left shifted by fifo_data_out_size so that mem[:] is assigned {0x0, mem[:fifo_data_out_size]}. Finally, addr_in is decremented by fifo_data_out_size.","The RX state machine  is initialized to an RX_IDLE state  upon system reset. Once the decoder  is enabled, the state machine  transitions from the RX_IDLE state  to an RX_CHECK_FIFO state . In this state, the depth of the RX FIFO is analyzed. If there are not enough data stored in the RX FIFO (at least Cbits if the decoder  is in compressed mode or 8 bits if the decoder  is in transparent mode) the state machine  transitions to from the RX_CHECK_FIFO state  to a RX_DMA_WAIT_STAT_state  to request more data from the DMA . Otherwise, there is enough data and the state machine  transitions to an RX_DATA_WAIT state .","In the RX_DMA_WAIT_STAT state , the state machine  waits for data from the DMA . Once the DMA  signals it has new data, the state machine  transitions to an RX_DMA_STB state . In this state, the data from the DMA  is pushed onto the RX FIFO and a strobe is sent to the DMA  to acknowledge receipt of the data. On the next clock cycle, the state machine  transitions back to the RX_CHECK_FIFO state .","In the RX_DATA_WAIT state , the state machine  awaits a data request from the controller module . Once the state machine  receives the request, the state machine  transitions to an RX_FIFO_READ state , in which the oldest data in the RX FIFO is popped. The size of the data in the RX FIFO depends on the mode of the decoder . If the decoder  is in compressed mode, Cbits will be popped from the RX FIFO. If the decoder  is in the transparent mode, 8 bits will be popped from the RX FIFO. On the next clock cycle, the state machine  transitions to an RX_DATA_VALID state .","In the RX_DATA_VALID state , the state machine  asserts the rx_data_valid signal to inform the controller  that valid data is ready to be processed. On the next clock cycle, the state machine  transitions back to the RX_CHECK_FIFO state .","The TX state machine  of  begins operation in a TX_IDLE state . Once the process data module  indicates that it has a character to send, the state machine  transitions to a TX_DMA_WAIT_STAT state . In this state , the state machine  waits for the DMA  to send a character. Once the DMA  sends a character, the state machine  transitions to a TX_DMA_STB state . In this state, the state machine  acknowledges that the DMA transfer is complete and transitions to a TX_DONE state  on the next clock cycle. In the TX_DONE state , the state machine  asserts tx_done to the process data module  to indicate that the state machine  is finished sending the character. On the next clock cycle, the state machine  transitions back to the TX_IDLE state .","Turning now to , a block diagram of a codeword dictionary , such as either of the codeword dictionary modules  and  shown in the encoder  and the decoder  respectively, is shown. Although only a single description of the codeword dictionary  is provided, it should be understood that the same codeword dictionary may be instantiated two times, one for each of the encoder  and decoder . The codeword dictionary  performs various functions involving the encoder and decoder dictionaries, each of which may be embodied in the memory . The following description makes general reference to a dictionary or to dictionaries, it being understood that such a dictionary or dictionaries may be either or both of the encoder or decoder dictionaries. The various functions performed by the codeword dictionary  include, for example, initializing a dictionary, searching a dictionary for the existence of a string and adding strings or nodes to a dictionary. Additionally, the codeword dictionary  removes nodes from a dictionary when the dictionary is full.","In general, the codeword dictionary  stores a codeword and its corresponding string. To reduce the storage requirements, each node of the dictionary stores an attach character and the previous string code. The V.42bis standard allows for deletion of leaf nodes, which are nodes whose codewords are not used as a previous string code of any other node. A reference count is used for each node to track how many other nodes reference it. Table 3 shows an example of strings, their codeword, their previous codeword, their attach character, and their reference count values.",{"@attributes":{"id":"p-0134","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},"Reference"]},{"entry":[{},{},"Previous","Attach","Count"]},{"entry":["String","Codeword","Codeword","Character","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["123","260","259","3","0"]},{"entry":["12","259","4","2","1"]},{"entry":["1","4","0","1","1"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Each node also stores the AVL node information including, for example, the left and right child pointers and a balance factor. Because the dictionary size is limited to 2048 codewords, the left and right child pointers must be 11 bits long. The balance factor can range between \u22122 and +2 and is, therefore, 3 bits in length.","Each node of the dictionary uses 64 bits of memory that are arranged as follows:\n\n","As shown in , the codeword dictionary  includes a number of functions or modules that may be represented in detail as state machines. In particular, the codeword dictionary  includes a main module  that is coupled to each of an insert module , a delete module  and a search module . Additionally, the codeword dictionary  includes a disconnect min module  that is coupled to each of the delete module , an address stack module  and a rebalance module . Further detail on each of the modules - is provided hereinafter in conjunction with .","Referring to , a main state machine , which represents further detail of the main module  of , is shown. The main state machine  controls the functionality of the codeword dictionary  and also includes logic that initializes the codeword dictionary . The main module  includes register elements that may be used to store the tree root, tree depth and C.","The main state machine  begins execution in an IDLE state . Upon a dictionary reset request, the main state machine  transitions to an INIT_MEM state . According to the V.42bis standard, the dictionary (e.g., the encoder dictionary or the decoder dictionary) must be preloaded with characters 0 through 255, which correspond to codewords 3 through 258, respectively (because codewords 0, 1 and 2 are reserved). The balance of the dictionary (from codeword 259 to N\u22121), must be initialized to zero. Because inserting 256 codewords using a standard AVL insert algorithm would be time consuming, the initialization is performed by storing the absolute node values because the number and value of the nodes is known. Accordingly, initialization requires just Nmemory accesses. The tree root is initialized to 130, the tree depth is initialized to 256 and Cis initialized to 259. Once initialization is complete, the state machine transitions from the INIT_MEM state  back to the IDLE state .","On a search request for string_code+char, the main state machine  transitions from the IDLE state  to a SEARCH state , at which point the main state machine  signals the search module  to begin execution. If the search module  finds the string_code+char in the AVL tree, the main state machine  returns to the IDLE state . Alternatively, if the search module  does not find the string_code+char in the AVL tree, the string_code+char must be inserted only if the maximum string length (N) is not exceeded. If these conditions are met, the main state machine  transitions to the READ_REF_FOR_INS state . If string_code+char is not found and exceeds the maximum string length, string_code+char will not be inserted and the main state machine  will transition back to the IDLE state .","In the READ_REF_FOR_INS state , the main state machine  will read the tree node that represents the codeword string_code. Next, the main state machine  transitions to an INCR_REF state  in which the reference count for string_code is incremented and the tree node for string_code is written with the updated reference count. Once the functions of the state  are complete, the main state machine  transitions to an INSERT state .","In the INSERT state , the main state machine  enables the insert module  to add a new node to the AVL tree with codeword Crepresenting string_code+char. Once the insertion is complete, the main state machine  transitions to an INCR_C state , at which Cis incremented.","After the state  has completed, the main state machine  transitions to a CHECK_C_UNUSED state . If the tree is not fill, meaning (tree_depth+3)<N, no deletion is required and the main state machine  transitions back to the IDLE state . Otherwise, the tree is full and the main state machine  transitions to a READ_MEM state .","In the READ_MEM state , the tree node represented by codeword Cis read. Once the read operation is complete, the main state machine  transitions to a CHECK_C_LEAF state . This state is used to determine if the codeword stored in Cis a leaf node, which is a point on a tree representing the last character in a string. If the reference_count of a codeword is zero, the codeword is not a prev_code of any other node and is, therefore, a leaf node. For example, as shown in Table 3, the string \u201c123\u201d is a leaf node.","If the node is a leaf node, the main state machine  will transition from the CHECK_C_LEAF state  to a DELETE state . Alternatively, if reference_count is non-zero, the node is not a leaf and the main state machine  transitions from the CHECK_C_LEAF state  back to the INCR_C state  to repeat the process until a leaf node is found.","Once in the DELETE state , the main state machine  enables the delete module  to delete the tree node representing the codeword C. Once the node deletion is complete, the main state machine  transitions from the DELETE state  to the READ_REF_FOR_DEL state , in which the node represented by the prev_code field of the deleted Ccodeword is read. Once the read operation is complete, the main state machine  transitions to a DECR_REF state , in which the reference_count of the codeword is decremented and the updated node information is stored. Once this operation is complete, the state machine transitions back to the IDLE state .","Further detail regarding the search module  is shown in a search state machine  of FIG. . An 11-bit storage element named addr_offset is used as the address of the tree node to be read and is initialized to be the tree root, which is where the search algorithm begins.","The search state machine  begins operation at an IDLE state . Upon receiving a search request, the search state machine  transitions from the IDLE state  to a NOT_FOUND state , if the tree is empty (if tree_depth=0). Otherwise, the search state machine  transitions to a READ state . In the READ state , the tree node located at addr_offset is read from the memory  and stored locally. Also, addr_offset is pushed onto the address stack to provide a path to backtrack through the dictionary (e.g., the encoder dictionary or the decoder dictionary) in the event that a new node must be inserted into one of the dictionaries, which causes the need for a balance factor adjustment. Once the read operation is complete, the search state machine  transitions to a COMPARE state .","In the COMPARE state , string_code+char is compared with the prev_code+attach_char read from the tree node. If string_code+char is less than prev_code+attach_char, then string_code+char is in the left subtree and the state machine transitions to a SEARCH_LEFT state . Conversely, if string_code+char is greater than prev_code+attach_char, then string_code+char is in the right subtree and the search state machine  transitions to a SEARCH_RIGHT state . Finally, if string_code+char is equal to prev_code+attach_char, string_code+char is in the AVL tree, the search state machine  transitions to a FOUND state .","In the SEARCH_LEFT state , left_child is evaluated. If left_child equals zero, there is no left subtree, and, therefore, string_code+char is not in the AVL tree and the search state machine  transitions to the NOT_FOUND state . Alternatively, addr_offset is set to left_child, which causes the search state machine  to transition to the READ state .","In the SEARCH_RIGHT state , right_child is evaluated. If right_child equals zero, there is no right subtree, and, therefore, string_code+char is not in the AVL tree and the search state machine  transitions to the NOT_FOUND state . Otherwise addr_offset is set to right_child, which causes the search state machine  to transition to the READ state .","In the FOUND state , the search state machine  sets the found output and sets the search_done output. After the search state machine  completes execution of the FOUND state , the search state machine  transitions to the IDLE state . Conversely, in the NOT_FOUND state , the search state machine  clears the found output and sets the search_done output and transitions to the IDLE state .","Further detail regarding the insert module  is shown in an insert state machine  of FIG. . In general, the insert state machine  is responsible for adding a new node to the AVL tree.","The insert state machine  begins operation at an IDLE state . When the main module  requests string_code+char be added to the dictionary (e.g., the encoder dictionary or the decoder dictionary), which is indicated by start_insert, the insert state machine  transitions from the IDLE state  to a CREATE_NEW_NODE state . In state , a new node, called child, is created using Cas its codeword and the following contents:\n\n","Once child has been stored to memory , the address stack is analyzed. If the stack is empty, the search module  did not find a parent with which to attach the new node and, therefore, a new tree root must be created. Such a situation will only arise when the tree is empty and is only used for testing. After the state  has completed, the insert state machine  transitions to a CREATE_TREE_ROOT state . Alternatively, if the address stack is not empty, the insert state machine  transitions to a POP_STACK state .","When the insert state machine  is in the CREATE_TREE_ROOT state , the tree_root storage elements located in the main module  are updated with the codeword of the new node as this is the new tree root. After the state  completes execution, control passes to a DONE state .","In the POP_STACK state , the insert state machine  requests that the address stack be popped. Two 11-bit storage elements, parent_addr and child_addr are used to handle addresses. The address popped from the address stack is stored in parent_addr. The old value of parent_addr is stored in child_addr. This process is a technique to maintain a parent node with its child. The address on the top of the address stack represents the parent of the new node since the search module  stored each node address during its search for string_code+char. This structure provides backtracking information and must be used to update the AVL balance factors. Once the address stack is popped, the insert state machine  transitions to a READ_PARENT state .","In the READ_PARENT state , parent_addr is read from the memory  and stored locally in a node that is denoted as a parent. Once the state  completes its operation, the insert state machine  transitions to an UPDATE_PARENT state , in which the contents of parent are updated. If child is a left child of parent, meaning string_code+char of child is less than parent's prev_code+attach_char, parent's left_child is set to child's codeword and parent's balance_factor is decremented. Similarly, if child is a right child of parent, meaning string_code+char of child is greater than parent's prev_code+attach_char, parent's right_child is set to child's codeword and parent's balance_factor is incremented. All other contents of parent remain the same. Once the write operation of the UPDATE_PARENT state  completes, the next state is determined based on a number of factors. In particular, if the parent's new balance_factor is +\/\u22122, the subtree is unbalanced and the next state is a ROTATE state . Alternatively, if parent's balance_factor is 0, the subtree is balanced and not further height adjustments need to be made and the next state is the DONE state . Further, if the stack is empty, there are no further nodes that may have their heights adjusted. Accordingly, the next state is the DONE state . Alternatively, height adjustments must continue, so that the next state is a POP_STACK state .","When the insert state machine  is in the ROTATE state , the state machine  signals the rebalance module  to perform rotations on the subtree whose root is the unbalanced node (balance factor is +\/\u22122) and returns the address of the root of the balanced subtree, denoted rotate_root_addr. Once the rebalance completes, the next state is determined by the status of the address stack. If the stack is empty, meaning the unbalanced parent node that was rotated was the root of the tree, the next state is an UPDATE_TREE_ROOT state . Alternatively, the next state is a POP_UNBAL_PARENT state .","In the UPDATE_TREE_ROOT state , the insert state machine  signals the main module  to update the address of the tree root because the address of the root tree has been changed due to a rotation about the tree root. Once complete, the state machine transitions to the DONE state .","In the POP_UNBAL_PARENT state , the insert state machine  requests the address stack to be popped. Once again, the value popped from the address stack is stored in parent_addr, with the previous value of parent_addr stored in child_addr. The address stack must be popped after a rotation because a child of this node has changed and must be updated to rotate_root_addr. This node represents the parent of the unbalanced node upon which a rotation was performed, called unbal_parent. The insert state machine  transitions to a READ_UNBAL_PARENT state  on the next clock cycle.","In the READ_UNBAL_PARENT state , the insert state machine  reads the contents of the unbal_parent node and stores it locally. Once the read operation completes, the insert state machine  transitions to an UPDATE_UNBAL_PARENT state .","In the UPDATE_UNBAL_PARENT state , the insert state machine  writes the updated contents of the unbal_parent node. Only the left_child or right_child contents of the node require updating as the balance factor must remain the same. If string_code+char is less than the prev_code+attach_char of unbal_parent, the left_child of unbal_parent is updated to rotate_root_addr. Otherwise the right_child of unbal_parent is updated to rotate_root_addr. Once this operation is complete, the insert state machine  transitions to the DONE state .","Finally, in the DONE state , the insert state machine  sets the insert_done output to the main module  and transitions to the IDLE state .","Turning now to , a delete state machine  reveals the details of the delete module  of FIG. . The delete state machine , and, therefore, the delete module , is responsible for removing nodes from the AVL tree. In general, during operation the delete module  is provided with a string_code+char to remove from the tree. The delete module  begins by searching the AVL tree for string_code+char while storing the nodes in the path to string_code+char in the address stack in a manner similar to the operation of the search module  of FIG. . Once the desired string is identified and deleted by removing its node from the tree, the tree is rebalanced.","The delete state machine  begins operation in an IDLE state . Once the start_delete signal is asserted, the delete state machine  transitions from the IDLE state  to a READ state . Each of the READ, COMPARE, SEARCH_LEFT and SEARCH_RIGHT states -, respectively, operate in substantially the same manners in the delete state machine  as they function in the search state machine , which was described in conjunction with FIG. .","Once the node representing string_code+char is found, it is denoted as node_to_remove and the delete state machine  transfers execution from the COMPARE state  to a POP_NODE state . In the POP_NODE state , the address stack is popped and the node address for the entry that is to be deleted is stored locally as parent_addr. Parent_addr is initialized to the tree root when the state machine is in the IDLE state  and each time the address stack is popped, the old value of parent_addr is placed in child_addr and parent_addr is set to the value popped from the address stack. This technique is a manner in which a relationship between a parent and its child is maintained. On the next clock cycle, the delete state machine  transitions from the POP_NODE state  to a REMOVE_NODE state .","In the REMOVE_NODE state , the node named node_to_remove is removed by clearing its contents in memory. Also, its node type is stored locally in node_type, which can be either a tree, a branch or a leaf as defined below:\n\n","In the CHECK_NODE_TYPE state , the delete state machine  evaluates node_type, and takes action based on the node type. If node_type is tree, the delete state machine  transitions to a DELETE_SUCCESSOR state . Alternatively, if node_type is leaf and the address stack is empty, no further height updates are required and the delete state machine  transitions to a DONE state . Further, if node_type is a leaf and the address stack is not empty, further height adjustments are necessary and the delete state machine  transitions to a POP_REMOVED_NODE_PARENT state . If node_type is a branch and the address stack is empty, the tree root must be updated to the removed node's child, so the delete state machine  transitions to an UPDATE_DELETED_TREE_ROOT state . Finally, if node_type is branch and the address stack is not empty, further height adjustments are required and the delete state machine  transitions to the POP_REMOVED_NODE_PARENT state .","In the UPDATE_DELETED_TREE_ROOT state , the tree root is updated to be the codeword of the deleted node's only child. On the next clock cycle, the delete state machine  transitions to the DONE state .","In the DELETE_SUCCESSOR state , the disconnect min module  of  is called to delete the smallest element of the right subtree of node_to_remove denoted successor_subtree. The smallest element of successor_subtree will be denoted as successor. The disconnect min module  will search successor_subtree and return the codeword for successor, the contents of successor, the address of the new root of successor_subtree, and indicate if the height of the successor_subtree changed due to the removal of successor. Once the disconnect min module  indicates that it has completed operation, the delete state machine  transitions to an UPDATE_SUCCESSOR state .","In the UPDATE_SUCCESSOR state , successor is updated by swapping it with node_to_remove as denoted below.\n\n","If the height of the successor_subtree did not change, height propagation is complete so successor_height_change is set to zero. If the new balance factor of successor is +\/\u22121, height propagation is complete so successor_height_change is set to zero. If neither of these conditions occurs, successor_height_change is set to one, thereby indicating further height change propagation must continue.","The UPDATE_SUCCESSOR state  then determines the next state to which control must be transferred. If the new balance factor of successor is +\/\u22122, the delete state machine transitions to a ROTATE state . Alternatively, if the address stack is empty, the successor node is the new tree root so the state machine transitions to the UPDATE_DELETED_TREE_ROOT state . If neither of the foregoing criteria are met, control passes from the UPDATE_SUCCESSOR state  to the POP_REMOVED_NODE_PARENT state .","In the POP_REMOVED_NODE_PARENT state , the address stack is popped to obtain the address of the removed node's parent, denoted removed_node_parent. On the next clock cycle the delete state machine  transitions to a READ_REMOVED_NODE_PARENT state . In the state , the contents of removed_node_parent is read from the memory  and stored locally. Once the read operation is complete, the delete state machine  transitions to an UPDATE_REMOVED_NODE_PARENT state .","In the UPDATE_REMOVED_NODE_PARENT state , the contents of removed_node_parent are updated depending on node_type, which is the type of node that was deleted. If node_type is leaf or branch and the deletion occurred in the left_child of removed_node_parent, it is updated as follows:\n\n","Alternatively, if the deletion occurred in the right_child of removed_node_parent, it is updated as follows:\n\n","Finally, if node_type is tree and the deletion occurred in the left_child of removed_node_parent, it is updated as follows:\n\n","The next state of the delete state machine  is dependent upon node_type. If node_type is tree, the next state of the delete state machine  will be the ROTATE state , if the new balance factor of removed_node_parent is +\/\u22122. Alternatively, if successor_height_change is zero, meaning height change propagation is complete, the next state of the delete state machine  is the DONE state . The same is true if the address stack is empty or the new balance factor of removed_node_parent is +\/\u22121. If none of these cases occur, the next state of the delete state machine  is a POP_STACK state .","If node_type is not tree, meaning it is leaf or branch, the next state will again be the ROTATE state , if the new balance factor is +\/\u22122. Height change propagation is complete if the new balance factor is +\/\u22121 or the address stack is empty and, therefore, the next state will be the DONE state . Alternatively, the next state will be the POP_STACK state , which continues height change propagation.","In the POP_STACK state , the address stack is popped, and the address is stored locally in parent_addr with the old value of parent_addr stored in child_addr. On the next clock cycle the delete state machine  transitions to a READ_NODE state . In the READ_NODE state , the contents of parent_addr are read from memory  and stored locally. Once the read operation is complete the delete state machine  transitions to an UPDATE_NODE state .","In the UPDATE_NODE state , parent_addr is updated to reflect the height change. If the delete was performed in its left subtree, the left_child of parent_addr is set to child_addr and its balance factor is incremented. Alternatively, if the delete was performed in its right subtree, parent_addr's right_child is set to child_addr and its balance factor is decremented. Once the memory  is written the delete state machine  transitions to the next state, which is determined based on the value of the balance factor. If the new balance factor is +\/\u22122 or larger, the next state is the ROTATE state  because the tree needs to be balanced. If the new balance factor is +\/\u22121 or the address stack is empty, the next state is the DONE state  because further height change propagation is not necessary. Finally, if neither of these conditions is met, the next state is the POP_STACK state , which causes the delete state machine  to continue height change propagation.","In the ROTATE state , the delete state machine  invokes the rebalance module  of  to rotate the subtree whose root has a balance factor of +\/\u22122 or larger. The rebalance module  rotates the tree or subtree to fix subtree imbalance. Once the rebalance module  has finished the rotation, the delete state machine  transitions to an UPDATE_TREE_ROOT state , if the address stack is empty. Alternatively, if the address stack is not empty, the delete state machine  will transition to a POP_UNBAL_PARENT state .","In the UPDATE_TREE_ROOT state , the tree root stored in the main module  of  is updated with the root of the rotated tree. On the next clock cycle, the delete state machine  transitions to the DONE state .","In the POP_UNBAL_PARENT state , the address stack is popped, which causes the popped address to be stored in parent_addr and the prior value of parent_addr is stored in child_addr. On the next clock cycle, the delete state machine  transitions to a READ_UNBAL_PARENT state , in which the contents of parent_addr are read from memory  and stored locally. Once this operation is complete, the state machine transitions to an UPDATE_UNBAL_PARENT state .","In the UPDATE_UNBAL_PARENT state , the node pointed to by parent_addr, which is the parent of the unbalanced node, is updated. If the deletion occurred in the left subtree, left_child is updated to rotate_root_addr. Otherwise, right_child is updated with rotate_root_addr. The balance factor must be updated as well, if the imbalance was not caused by the special case where a rotation does not cause a height change described in \u201cAn Introduction to AVL Trees and Their Implementation,\u201d which was written by Brad Appleton and is available at http:\/\/www.enteract.com\/\u02dcbradapp\/ftp\/src\/libs\/C++\/AvlTrees.html. The balance factor is incremented if the deletion occurred in the left subtree or decremented if the deletion occurred in the right subtree. All other contents of the node remain the same.","If the new balance factor is +\/\u22122 or larger, the next state will be the ROTATE state , which seeks to correct the imbalance. Alternatively, if the new balance factor is +\/\u22121, or the special case where a rotation does not cause further height changes, or the address stack is empty, the next state is the DONE state . If none of these conditions are met, further height changes are required and the next state is the POP_STACK state .","When the delete state machine  is in the DONE state , the delete module  outputs a delete_done signal to the main module . On the next clock cycle, the delete state machine  transitions to the IDLE state .","As shown in , a disconnect min state machine  (hereinafter \u201cthe state machine \u201d) includes a number of states that collectively implement the disconnect min module . In general, the disconnect min module  is called by the delete module  to remove the smallest element of a subtree. The delete module  provides the address of the root of the subtree with which to remove the smallest element.","The state machine  begins operation in an IDLE state  in which parent_addr, which is an 11-bit register is used to store the address for accessing the AVL tree, is initialized to the root of the subtree passed from the delete module . Once the start_disconnect_min input is asserted, the state machine  transitions to a START state , in which the address stack depth is saved in the init_stack_depth register. On the next clock cycle, the state machine  transitions to a READ state , in which the node pointed to by parent_addr is read from memory  and stored locally. Additionally, the parent_addr is pushed onto the address stack. Once the read operation carried out by the READ state  is complete, the state machine  transitions to a COMPARE state .","In the COMPARE state , the left child is evaluated. If the left child is equal to zero, the smallest element of the subtree is found. This node is denoted successor_node and its contents are stored locally. On the next clock cycle, the state machine transitions to a POP_NODE state . Alternatively, if the foregoing conditions are not met, the state machine  transitions to a SEARCH state .","In the SEARCH state , parent_addr is set to the left child of the node just read from memory  to continue the search. On the next clock cycle, the state machine  transitions back to the READ state .","In the POP_NODE state , the address stack is popped and the address is stored in parent_addr. The previous value of parent_addr is stored in child_addr. On the next clock cycle the state machine  transitions to a CHECK_STACK_DEPTH state , in which the current depth of the address stack is compared with init_stack_depth. If the current depth of the address stack is equal to the init_stack_depth, the root of the subtree is the smallest element and, therefore, the state machine  transitions to a DONE state . Alternatively, the state machine  transitions to a POP_NODE_PARENT state .","In the POP_NODE_PARENT state , the address stack is popped and the popped address is stored in parent_addr. Additionally, the right child of successor_node is stored in child_addr. On the next clock cycle, the state machine  transitions to a READ_NODE state , in which the node pointed to by parent_addr is read from memory  and its contents are stored locally before parent_addr is pushed onto the address stack. Once the READ_NODE state  has completed operation, the state machine  transitions to an UPDATE_NODE state .","In the UPDATE_NODE state , the node pointed to by parent_addr is updated. Its left child is updated to child_addr and its balance factor is incremented. Once the write operation is complete, the state machine  determines its next state of operation. If the new balance factor is +\/\u22122 or larger, the subtree is imbalanced and the next state is a ROTATE state . Alternatively, if the current address stack depth is equal to init_stack_depth, the current node is the root of the subtree and, therefore, the next state is the DONE state . Alternatively, if the new balance factor is +\/\u22121, further height adjustments are not necessary and the address stack must be restored to the condition that it was in before it was modified by the state machine . Accordingly, control passes to a RESTORE_STACK state . Finally, if none of the foregoing conditions is satisfied, the state machine  transitions to a POP_STACK state  to further propagate height changes.","In the ROTATE state , the state machine  signals the rebalance module  of  to rotate the subtree to maintain balance. Once the rebalance module  has completed its operation, the state machine  transitions from the ROTATE state  to an UPDATE_TREE_ROOT state , if the current depth of the address stack is equal to init_stack_depth. Alternatively, the state machine  transitions to a POP_UNBAL_PARENT state.","In the UPDATE_TREE_ROOT state , the state machine  stores the new root of the subtree. On the next clock cycle, the state machine  transitions to the DONE state .","In the POP_UNBAL_PARENT state , the state machine  pops the last value from the address stack and stores it in parent_addr. The previous value of parent_addr is stored in child_addr. On the next clock cycle, the state machine  transitions to a READ_UNBAL_PARENT state , in which the node pointed to by parent_addr is read from memory  and its contents are stored locally. Once the read operation is complete, the state machine  transitions to UPDATE_UNBAL_PARENT .","In the UPDATE_UNBAL_PARENT state , the parent of the unbalanced node is updated to child\/balance factor changes, which is performed in substantially the same manner as it is performed by other modules. Once the write operation completes, the next state is determined. If the new balance factor is +\/\u22122 or larger, the state machine  transitions to the ROTATE state . Alternatively, if the current address stack depth is equal to init_stack_depth, the next state is the DONE state . Further, if the balance factor is +\/\u22121 or the special case of rotation after delete without causing height change propagation occurs, the next state is the RESTORE_STACK state . Finally, if none of the foregoing criteria is satisfied, further height adjustments are necessary and the state machine transitions to the POP_STACK state .","In the RESTORE_STACK state , the current address stack depth is compared to the init_stack_depth. If the two are equal, the stack is restored to its original state and the state machine  transitions to the DONE state . Alternatively, the state machine  transitions to a POP_STACK_FOR_RESTORE state .","In the POP_STACK_FOR_RESTORE state , the last address on the address stack is popped. On the next clock cycle, the state machine  transitions to the RESTORE_STACK state .","In the DONE state , the disconnect min module  provides a disconnect_min output signal to the delete module , along with the new root of the subtree and successor_node.","As shown in , the rebalance module  of  may be implemented by a rebalance state machine  having a number of different states. The rebalance state machine  is called by the ROTATE states of the insert, delete, and disconnect min modules ,  and , respectively, whenever the balance factor of a node is +\/\u22122. In general, the rebalance state machine  receives as input the root of the unbalanced subtree and returns the root of the new balanced subtree.","The state machine  begins execution at an IDLE state . Upon receiving the start_rotate input, the rebalance state machine  transitions to a READ_PARENT state . In the READ_PARENT state , the root of the unbalanced subtree, denoted parent, is read from memory  and its contents are stored locally. Once the read operation is complete, the rebalance state machine  transitions to a CALCULATE_IMBALANCE state .","The CALCULATE_IMBALANCE state  determines the direction of the imbalance and stores an indication of the direction of imbalance in a register called imbalance_dir. If the balance factor is \u22122, there is a left imbalance and 0 is stored in imbalance_dir. If the balance factor is 2, there is a right imbalance and 1 is stored in imbalance_dir. On the next clock cycle, the rebalance state machine  transitions to a READ_CHILD state .","In the READ_CHILD state , the child in the direction of the imbalance of the parent is read from memory . For example, if parent has a left imbalance, its left child is read from memory and this node is denoted as child. Once the read operation is complete, the rebalance state machine  transitions to a CALCULATE_HEAVY state .","In the state , the heavy direction of child is calculated and stored in a 2-bit register called heavy_dir. If child's balance factor is \u22121, the heavy direction is to the left and 0x3 is stored in heavy_dir. Alternatively, if child's balance factor is 1, the heavy direction is to the right and 0x1 is stored in heavy_dir. Finally, if balance factor is zero, the child is balanced and 0x0 is stored in heavy_dir. On the next clock cycle, the rebalance state machine  transitions from the CALCULATE_HEAVY state  to a COMPARE_CHILD_BF state .","In the COMPARE_CHILD_BF state , the type of rotation that needs to be performed is determined as shown in Table 4. If a RR or LL rotation is selected, the next state is an UPDATE_PARENT state . Otherwise, a RL or LR rotations is needed, so the next state is a READ_GRANDCHILD state .",{"@attributes":{"id":"p-0209","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Imbalance Direction","Heavy Direction","Rotation Needed"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Left","Left","RR"]},{"entry":[{},"Left","Right","RL"]},{"entry":[{},"Left","Balanced","RR"]},{"entry":[{},"Right","Left","LR"]},{"entry":[{},"Right","Right","LL"]},{"entry":[{},"Right","Balanced","LL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In the READ_GRANDCHILD state , the left or right child of child is read from memory  and denoted as grandchild. If child is left heavy, the left child is read, otherwise the right child is read. Once the read operation is complete and the contents of grandchild is stored, the rebalance state machine  transitions to the UPDATE_PARENT state .","In the UPDATE_PARENT state , parent's contents are updated depending on the rotations that are performed. Updates are carried out as follows:\n\n","Once the write operation is complete, the rebalance state machine  transitions to an UPDATE_CHILD state . In the UPDATE_CHILD state , the child is updated based on rotations as follows:\n\n","The rebalance module  provides the address of the root of the new subtree, denoted new_root_addr as outputs. If either a RR or LL rotation is performed, child is stored in new_root_addr because the rotation is complete and child is now the root of the new subtree. Once the update operation is complete, the rebalance state machine  transitions to a DONE state  if an RR or LL rotation is required. Alternatively, the next state of the rebalance state machine  is an UPDATE_GRANDCHILD state .","In the UPDATE_GRANDCHILD state , grandchild is updated, depending on rotation type, as follows:\n\n","After the rotations are complete, grandchild is stored in new_root_addr and grandchild is the root of the new subtree. Once grandchild is updated, the rebalance state machine  transitions to the DONE state . In the DONE state , the rebalance state machine  signals to the main module  that the rotate operation is complete by asserting the rotate_done output.","Turning now to , five different states of a dictionary, which may be either or both of the encoder and decoder dictionaries, are shown as represented by the encircled Arabic numerals.  is described hereinafter in conjunction with Table 5 below to describe the various states of a dictionary as the string CABCAB is sent. For simplicity sake, the following description presupposes the use of an alphabet including only the letters A, B and C. As will be readily understood, other implementations of the dictionary may include any or all ASCII characters and the implementation of such a dictionary would follow directly from the simplified example provided herein. Where appropriate, the following description includes references to the state machines previously described.","As shown below, Table 5 includes a number of rows, each of which represents a codeword (cw). Additionally, Table 5 includes rows designating prev_code, attach_char, balance factor, left child, right child and reference count, which are represented as pc, ac, bf, lc, rc and ref, respectively. The encircled Arabic numerals of Table 5 correspond to the various dictionary states shown in FIG. . As used hereinafter the term key means the concatenation of prev_code and attach_char. The key, balance factor, left child, right child and reference count are all stored in a memory, as shown in Table 5.",{"@attributes":{"id":"p-0218","num":"0283"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"{circle around (1)}","{circle around (2)}","{circle around (3)}","{circle around (4)}","{circle around (5)}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cw","pc,ac,bf,lc,rc,ref","pc,ac,bf,lc,rc,ref","pc,ac,bf,lc,rc,ref","pc,ac,bf,lc,rc,ref","pc,ac,bf,lc,rc,ref"]},{"entry":["1","0,A,0,0,0,0","0,A,0,0,0,0","0,A,0,0,0,0","0,A,0,0,0,0","0,A,0,0,0,0"]},{"entry":["2","0,B,0,1,3,0","0,B,1,1,3,0","0,B,1,1,5,0","0,B,0,1,3,0","0,B,0,1,3,0"]},{"entry":["3","0,C,0,0,0,0","0,C,1,0,4,0","0,C,0,0,0,0","0,C,0,0,0,0","0,C,0,0,0,0"]},{"entry":["4",{},"3,A,0,0,0,0","3,A,0,0,0,0","3,A,0,0,0,0","3,A,0,5,7,1"]},{"entry":["5",{},{},"1,B,0,3,4,0","1,B,1,0,4,0","1,B,0,0,0,0"]},{"entry":["6",{},{},{},"2,C,0,2,5,0","2,C,0,2,4,0"]},{"entry":["7",{},{},{},{},"4,B,0,0,0,0"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"As shown in state 1of Table 5 and , the dictionary tree is initialized, or seeded, with all of the letters of the alphabet (i.e., in this example, A, B and C). The keys of each of A, B and C are 0,A; 0,B and 0,C because seed entries in the dictionary do not have any previous codeword values. As shown in FIG.  and reflected in Table 5 , key 0,B is the root node of the tree, with 0,A and 0,C forming the left and right children, respectively. Accordingly, the lc and rc entries for codeword 2, which corresponds to B, are 1 and 3, respectively. This represents that codeword 1 is the left child of codeword 2 and codeword 3 is the right child of codeword 2. The dictionary tree may be filled by an encoder that receives strings and encodes the strings into codewords. Alternatively, the dictionary tree may be filled by an encoder that receives codewords and decodes the codewords into strings. Both of the encoding and decoding processes are described below.","When the string CABCAB is received by the encoder, the dictionary is searched for C, which is found at codeword 3. Searching may be carried out by the state machine  of FIG. . After C is found at codeword 3, prev_code is set to 3 and the dictionary is searched for 3,A, which is the prev_code and the second letter of the string. Because 3,A is not found in the dictionary, codeword 3, which represents the first C of the string, is transmitted and 3,A is inserted into the dictionary at the next available codeword, which, in this case, is codeword 4. Insertion may be carried out by, for example, the state machine . After 3,A is inserted into the dictionary, the dictionary has the structure shown at state 2, which is represented by the encircled Arabic numeral 2 in Table 5 and on FIG. . As shown in , 3,A is inserted as the right child of 0,C, which is represented in Table 5 by the codeword 4 being place in the rc field of codeword 3.","After 3,A is inserted into the dictionary, the codeword for A, which is 1, is designated as the prev_code and the next character of the string, which is B, is read. After the character B is read, the dictionary is searched for 1,B, an entry that is not in the dictionary. Because 1,B is not found in the dictionary, the codeword 1, which represents the A of the string, is transmitted and 1,B is added to the dictionary at the next available codeword, which, in this case, is codeword 5. Additionally, the codeword 2, which is the codeword for B, is designated as prev_code. As shown in , the addition of 1,B to the node 3,A creates an imbalance in the directory tree. The imbalance is corrected by the state machine , which performs a left-right rotation on the dictionary. The results of the left-right rotation are shown as state 3 in both Table 5 and FIG. .","After 1,B is inserted into the dictionary and the dictionary is rotated so that it is balanced, the next character of the string, which is C, and the dictionary is searched for 2,C. Because 2,C is not in the dictionary, it is added at the next available codeword, which is codeword 6. Additionally, the codeword 2 is transmitted and prev_code is set to codeword 3, which represents C. Because the insertion of 2,C imbalances the dictionary, the state machine  performs a left-right rotation on the dictionary to result in the dictionary structure shown in Table 5 and  at encircled Arabic numeral 4.","After 2,C has been inserted into the dictionary, and the dictionary has been rebalanced, the next character of the string, which is A is read and the dictionary is searched for 3,A. Because 3,A is found in the dictionary, prev_code is set to the codeword 4, which is the codeword for 3,A.","After prev_code is set to 4, the next character of the string, which is a B is read. Accordingly, the dictionary is searched for 4,B, which is not in the dictionary. Because 4,B is not found in the dictionary, codeword 4, which is the codeword for 3,A, is transmitted. It will be readily appreciated that 3,A, in turn, represents C,A. Accordingly, by transmitting a codeword of 4, the characters C,A are transmitted. After the codeword 4 is transmitted, prev_code is set to 2 and 4,B is inserted into the dictionary.","The insertion of 4,B into the dictionary creates a dictionary imbalance and the state machine  performs a left-left rotation on the dictionary structure to result in the structure shown in the encircled Arabic numeral 5 in Table 5 and in FIG. . Additionally, as shown in codeword 4 of Table 5, the ref of codeword 4 is changed from a zero to a one at state 5. A ref of 1 indicates that codeword 4 is referenced by one other codeword (in this case codeword 7) and, therefore, codeword 4 cannot be deleted. It should be noted that even though the ref numbers of the seeds (i.e., the dictionary entries corresponding to codewords of 3 or less) is zero, such codewords will never be deleted because seeds of a dictionary are never deleted.","In the foregoing description, codewords are referred to as having been transmitted. When transmitted codewords are received, a decoder recovers the character or character string that the codeword represent. For example, with reference to Table 5 and , if a decoder receives the codeword 3, the decoder knows the character corresponding to codeword 3 is a C. By way of further example, if a decoder receives the codeword 7, such a codeword is decoded into the codeword 4 and the character B. The codeword 4 is, in turn, decoded into the codeword 3 and the character A. Further, the codeword 3 is then decoded into the character C. By assembling the characters the string CAB can be recovered from the codeword 7. As will be readily appreciated, if each codeword is 11 bits long and if each character is 8 bits in length, sending one codeword, as opposed to three characters, is a compression ratio of 24:11\u2014over two to one. The longer the string of characters, the potentially larger the compression ratio may be when sets of those characters are sent using codewords.","When a decoder receives the codewords 3,1,2,4,2, which were sent by the encoder to represent CABCAB, the codewords are processed as follows to build a codeword dictionary within the decoder. The codeword dictionary within the decoder is formed in the same states as shown in Table 5 at the encircled Arabic numerals.","In particular, at state 1, when the receiver receives the codeword 3, the decoder processes the codeword 3 to determine that codeword 3 represents the character C. At this point, the prev_code is 0 and the attach_char is C. The decoder searches the dictionary for 0,C, which it finds at codeword 3 and, therefore prev_code is set to 3.","After prev_code is set to 3, the decoder receives and decodes the codeword 1, which is decoded into the character A. At this point, prev_code is set to 3 and attach_char is set to A. The decoder then searches for 3,A, which is not found in the dictionary. At the Arabic numeral 2 of Table 5, 3,A is inserted into the dictionary as codeword 4. After 3,A is inserted into the dictionary as codeword 4, prev_code is set to 1.","After setting prev_code to 1, the decoder receives codeword 2, which the decoder decodes into the character B. After codeword 2 is decoded into the character B, prev_code is set to 1 and attach_char is set to B. Accordingly, the dictionary is searched for 1,B, which is not present in the dictionary. Because 1,B is not in the dictionary, it is added thereto at codeword 5, as shown at Arabic numeral 3 in Table 5.","After 1,B is inserted into the dictionary, prev_code is set to 2, which is the codeword for B, and the decoder receives the codeword 4. The decoder decodes the codeword 4 into the characters CA and sets prev_code to 2 and attach_char to C before searching the dictionary for 2,C. Because the dictionary does not contain 2,C, 2,C is added thereto at codeword 6, as shown at the Arabic numeral 4 in Table 5. Subsequently, prev_code is set to 4, which is the codeword for CA.","The decoder then receives the codeword 2, which it decodes into character B. At this point prev_code is set to 4 and attach_char is set to B. The dictionary is then searched for 4,B, which is not found in the dictionary. Accordingly, at shown at the Arabic numeral 5 in Table 5, 4,B is added to the dictionary at codeword 7.","As will be readily appreciated, the events described in conjunction with FIG.  and Table 5 are exemplary and can be carried out for any suitable alphabet and any suitable text string. Accordingly, the foregoing example should be regarded as merely exemplary and not as limiting.","Numerous modifications and alternative embodiments of the invention will be apparent to those skilled in the art in view of the foregoing description. Accordingly, this description is to be construed as illustrative only and not as limiting to the scope of the invention. The details of the structure may be varied substantially without departing from the spirit of the invention, and the exclusive use of all modifications, which are within the scope of the appended claims, is reserved."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 4"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 7","FIG. 4"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 8","FIG. 4"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 9","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 11","FIG. 9"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 12","FIG. 9"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 13","FIG. 9"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 14","FIG. 3"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 15","FIG. 14"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 16","FIG. 14"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 17","FIG. 14"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 18","FIG. 14"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 19","FIG. 14"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 20","FIG. 14"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
