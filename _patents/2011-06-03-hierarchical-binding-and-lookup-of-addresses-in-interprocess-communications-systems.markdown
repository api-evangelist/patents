---
title: Hierarchical binding and lookup of addresses in inter-process communications systems
abstract: Systems/methods of looking up an address of a target server include receiving a first lookup request at a first lookup server that manages a first database that contains data relating to a first plurality of servers. First metadata relating to the target server is retrieved from the first database, and a second lookup request including the first metadata is sent to a second lookup server that manages a second database that contains data relating to a second plurality of servers. The second plurality of servers is a subset of the first plurality of servers and includes the target server. Second metadata relating to the target server is retrieved from the second database, and a response based on the first and second metadata is transmitted to the client. Corresponding systems/methods of binding a server address to a lookup key are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713198&OS=08713198&RS=08713198
owner: Telefonaktiebolaget L M Ericsson (publ)
number: 08713198
owner_city: Stockholm
owner_country: SE
publication_date: 20110603
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to process based computing models, and more particularly to computer programs that use inter process communication mechanisms.","Many software applications are physically or logically split into separate components, or services, which communicate with each other via an inter-process communication (IPC) mechanism. For example, some components\/services of a software application may act as server components that provide defined services to other software components. Software components that utilize the services of other software components may be referred to as client components.","In an IPC service, it is useful for one component to be able to send a message to another component without knowing its physical location. That is, the sending component should be able to reach a destination component using an address that is not tied to a specific physical location. In this manner, the sending component does not have to keep track of an address that may change when the destination component is moved. This feature becomes increasingly important in the currently evolving cloud based infrastructures.","It is also useful if a sending component can rely on a constant semantic meaning of an access key that can be used to reach a particular type of service. For example, it is useful for a sending component to be aware that \u201ca destination that is reachable with key X always provides service Y\u201d. This way, the key can safely be hard-coded into the sending component without risking that it will ever become obsolete. This type of key is referred to herein as a destination name, or simply a name.","When a constant semantic access key is used, a lookup step must be performed in the IPC system to obtain a physical address corresponding to the destination name. In the lookup process, a destination name is translated to a location-specific address that may be used during the subsequent message transmission. The lookup process can be done in a number of ways.","For example, a lookup can be performed in the data transmission phase each time a message is sent. In this approach, a lookup is done for each message by the transport service itself. The sending component uses a destination name as if it were an address. The actual address of the destination component is resolved by the transport mechanism at transfer time.","Another approach is for the sending component to perform a lookup for each destination component. For example, the lookup can be done explicitly by using a supporting library in each component at startup, or just before sending the first message to a particular destination. The library may keep a table (e.g., a cache) of destination names and their corresponding destination addresses. The table can be updated as destination addresses change. Alternately, the application code of the sending component may itself ask for the lookup done by a service, and store the resulting address for later use.","The transport address format that is to be used for a particular transmission depends on the selected transport protocol. For example, for UDP and TCP transmissions, the address will be IP addresses. For Unix Sockets, the address will be a Unix path. Other transport protocols and address formats are possible.","To do the address lookup or translation, a lookup key, such as a URL, an integer or set of integers, etc., may be provided by the client to a lookup or address resolution service.","The binding, or relationship, between the lookup keys and the server addresses must be maintained somewhere in the system, for example, in one or more tables in a database. The lookup table may be consulted by the client component during lookup, and the client component may cache the returned address values. There may be one single instance of this table, but also several replicated versions of it.","The management of a system for global name-to-address translation may present a number of problems. For example, such systems may suffer from a lack of flexibility, decreased efficiency, and\/or large memory and\/or bandwidth requirements.","Methods of looking up an address of a target server component according to some embodiments include receiving a first lookup request from a client component at a first lookup server that manages a first database that contains data relating to a first plurality of server components. The first lookup request identifies the target server component, which is among the first plurality of server components. The methods further include retrieving first metadata relating to the target server component from the first database, and sending a second lookup request including the first metadata to a second lookup server that manages a second database that contains data relating to a second plurality of server components. The second plurality of server components is a subset of the first plurality of server components and includes the target server component.","The methods further include retrieving second metadata relating to the target server component from the second database. The first and second metadata together include information that can be used to resolve an address associated with the target server component. The methods further include transmitting a response based on the first and second metadata to the client component.","The first lookup request may include a lookup key that identifies the target server component. The lookup key may include a type of the target server component. The second lookup request may include the lookup key.","The first metadata may identify a node to which a system that hosts the target server component belongs, and the second metadata may identify a port on the system that is associated with the target server component.","Transmitting the response to the client component may include transmitting the first and second metadata to the client component.","The methods may further include generating an address of the server component in response to the first and second metadata, and transmitting the response to the client component may include transmitting the address of the server component to the client component.","The first lookup request may include meta-metadata that instructs the second lookup server how to process the first metadata and the second metadata.","The methods may further include generating an address of the server component from the first and second metadata at the second lookup server, and transmitting the response to the client component may include transmitting the address of the server component to the client component.","The methods may further include appending meta-metadata to the second lookup request before sending the second lookup request to the second lookup server.","A method of looking up an address according to some embodiments includes receiving a lookup request from a client component for a target server component of an identified type at a lookup server that manages a first database that identifies nodes that contain address resolution information regarding the identified type of server component, identifying a node associated with the identified type of server component, retrieving first metadata from the first database relating to the identified type of server component, appending the first metadata to the lookup request and forwarding the lookup request to a second lookup server that manages a second database associated with the identified node.","The method further includes retrieving second metadata from the second table, the first and second metadata together including information that can be used to resolve an address associated with the target server component, and transmitting the first and second metadata to the client component.","The method may further include appending meta-metadata to the lookup request before forwarding the lookup request to the second lookup server, the meta-metadata instructing the second lookup server how to process the first metadata.","Some embodiments provide methods of binding an address of a publishing server component to a lookup key in an inter-process communication system. The methods include receiving a first publication request from a publishing server component at a first lookup server that manages a first database that contains data relating to a first plurality of server components that includes the publishing server component. The first publication request includes first and second metadata relating to an address of the publishing server component. The methods further include storing the first metadata in the first database and sending a second publication request including the second metadata to a second lookup server that manages a second database that contains data relating to a second plurality of server components. The second plurality of server components is a superset of the first plurality of server components and includes the publishing server component. The methods further include storing the second metadata in the second database.","The first metadata may include a node in which the publishing server component is resident and the second metadata may include a port associated with the publishing server component.","The first publication request may include the lookup key. The lookup key may include a type associated with the publishing server component and a process instance associated with the publishing server component. The lookup key may include a suite of process instances associated with the publishing server component.","The first publication request may include meta-metadata that instructs the first lookup server and\/or the second lookup server on how to manage the first metadata and\/or the second metadata. The second publication request may also include the meta-metadata.","The first lookup server may generate meta-metadata that instructs the second lookup server on how to manage the second metadata, and the second publication request may include the meta-metadata.","An interprocess communication system according to some embodiments includes a first lookup server that is configured to manage a first database that contains data relating to a first plurality of server components, and configured to receive a first lookup request identifying a target server component from among the first plurality of server components from a client component, and configured to retrieve first metadata relating to the target server component from the first database.","The system further includes a second lookup server that is configured to manage a second database that contains data relating to a second plurality of server components. The second plurality of server components is a subset of the first plurality of server components and includes the target server component.","The first lookup server is further configured to send a second lookup request including the first metadata to the second lookup server, and the second lookup server is further configured to retrieve second metadata relating to the target server component from the second database. The first and second metadata together include information that can be used to resolve an address associated with the target server component. The second lookup server is further configured to transmit a response to the client component based on the first and second metadata.","An interprocess communication system according to further embodiments includes a first lookup server that is configured to manage a first database that contains data relating to a first plurality of server components that includes a publishing server component, and that is configured to receive a first publication request from the publishing server component. The first publication request includes first and second metadata relating to an address of the publishing server component and a lookup key associated with the publishing server component. The first lookup server is further configured to store the first metadata in the first database along with the lookup key.","The system includes a second lookup server that is configured to manage a second database that contains data relating to a second plurality of server components. The second plurality of server components is a superset of the first plurality of server components and includes the publishing server component. The first lookup server is further configured to send a second publication request including the second metadata and the lookup key to a second lookup server, and the second lookup server is configured to store the second metadata in the second database together with the lookup key.","Other systems, methods, and\/or computer program products according to embodiments of the invention will be or become apparent to one with skill in the art upon review of the following drawings and detailed description. It is intended that all such additional systems, methods, and\/or computer program products be included within this description, be within the scope of the present invention, and be protected by the accompanying claims.","Embodiments of the present invention are described herein with reference to the accompanying drawings, in which embodiments of the invention are shown. This invention may, however, be embodied in many different forms and should not be construed as limited to the embodiments set forth herein. Rather, these embodiments are provided so that this disclosure will be thorough and complete, and will fully convey the scope of the invention to those skilled in the art. Like numbers refer to like elements throughout.","It will be understood that, although the terms first, second, etc. may be used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another. For example, a first element could be termed a second element, and, similarly, a second element could be termed a first element, without departing from the scope of the present invention. As used herein, the term \u201cand\/or\u201d includes any and all combinations of one or more of the associated listed items.","The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding\u201d when used herein, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.","Unless otherwise defined, all terms (including technical and scientific terms) used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this invention belongs. It will be further understood that terms used herein should be interpreted as having a meaning that is consistent with their meaning in the context of this specification and the relevant art and will not be interpreted in an idealized or overly formal sense unless expressly so defined herein.","Some embodiments of the invention provide systems\/methods for inter-process communications that employ a set of hierarchical name tables that are arranged so that all instances of the tables do not need to keep all information about the name-to-address bindings. Information in the tables may be distributed as far as necessary or desired in the system, but not further, thus potentially reducing memory consumption and\/or bandwidth consumption in the system.","According to some embodiments, systems\/methods are provided for storing, managing and looking up addresses, such as addresses of servers in a computer communication system. For example,  illustrates a system in which a client component  desires to look up an address of a server component  using a hierarchical inter-process communication (IPC) lookup system .  illustrates a logical hierarchy of lookup tables as it relates to a set of server components SC that are known to the hierarchical lookup system .  is a flowchart that illustrates operations associated with publishing an address to the IPC lookup system  and binding the address to a lookup key, while  is a flowchart that illustrates operations associated with looking up an address in the IPC lookup system .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 1A","b":["10","20","30","30"]},"Referring to , the client component  issues a lookup request  to a high level lookup server - in the IPC lookup system  that manages a high level table, i.e. a Level 1 Table. As shown in , the high level Level 1 Table contains metadata that relates to set of server components SC including the server component .","The lookup request  includes a lookup key, which may, for example, be the name of the server component  whose address is sought by the client component .","The high level lookup server - retrieves a record from the high level table containing metadata MD that relates to a particular instance of the server component . If the information is incomplete, the high level lookup server - sends a lookup request - to a lower level lookup server - along with the metadata MD. The identity of the lower level lookup server - and or an associated lookup table may be determined in some embodiments from the metadata MD.","The second level lookup server - retrieves further information regarding the record from a lower level table (the Level 2 Table), including metadata MD. As shown in , the Level 2 Table contains metadata that relates to a subset of server components that are known to the Level 1 Table. If the information is still incomplete, the second level lookup server - sends a lookup request - including the metadata [MD, MD] collected to that point the next lower level lookup server. The identity of the next lower level lookup server and or an associated lookup table may be determined in some embodiments from the metadata [MD, MD].","This process may be repeated by sending the collected metadata to lower level lookup servers that manage lower level tables until a lowest level table, i.e., the Level N Table shown in , is reached. In the example shown in , the Level N lookup server -N receives a lookup request -N- from a next higher level lookup server that includes the metadata [MD, MD, . . . , MDN-] collected up to that point.","Each lower level table contains metadata that relates to a subset of server components that are known to the next higher level table and that includes the server component  identified by the lookup key contained in the lookup request .","The Level N table may return the metadata MDN stored therein to the next highest level table via a response message -N, as shown in . Each subsequent level may return the accumulated metadata via response messages -, -, etc., until the complete set of collected metadata [MD, . . . , MDN-, MDN] is returned to the highest level lookup server - in the IPC lookup system .","If a particular lookup table includes multiple entries corresponding to a set of metadata provided by a higher level lookup server, the lookup server for that level may issue multiple lookup requests, e.g. one for each table entry corresponding to the set of metadata, to lower level lookup servers and accumulate all of the metadata collected in response to the multiple lookup requests in formulating its response to the higher level server.","Once the accumulation of metadata by the IPC lookup system  is complete, the IPC lookup system  returns a response  to the client component including the accumulated metadata MD to MDN, which the client component  may use for reconstructing the address of the server component . The client component  may then send a message  to the server component  using the reconstructed address.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 1C","b":["40","1","40","2","30","20","40","1","40","2","20","72","20","40","1","40","2","20","10","20","40","1","40","2","20","74"]},"The metadata may be parsed according to pre-determined rules stored in the lookup server -, -, etc., or may be parsed in accordance with instructions or meta-metadata supplied in the Publish request as described in more detail below.","The lookup server -, -, etc., then determines if there is additional metadata in the request that needs to be propagated to a higher level lookup server (Block ). If so, the Publish request including the additional metadata is forwarded to the higher level lookup server (Block ). However, the metadata processed and stored by the original lookup server need not be sent to the higher level lookup server.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 1D","b":["40","1","40","2","30","20","40","1","40","2","80","10","40","1","40","2"]},"In response to the Lookup request, the lookup server -, -, etc., checks its local table and retrieves a record corresponding to the provided scope and name of the desired server (Block ). The lookup server -, -, etc. retrieves the metadata from the record and analyzes the record and the retrieved metadata to determine if additional metadata is needed in order to formulate a response to the Lookup request (Block ). Analysis of the record and the retrieved metadata may be based on predetermined instructions known to the lookup server and\/or may be based on meta-metadata provided in the Lookup request and\/or in the record itself.","If no additional metadata is needed, the lookup server -, -, etc. sends a response to the client component including the accumulated metadata from which the client component can reconstruct the address of the desired server component (Block ).","If additional metadata is needed to formulate a response to the Lookup request, the lookup server -, -, etc. sends a lookup request and the retrieved metadata to a lower level lookup server specified in the record and receives additional metadata from the lower level lookup server in response (Block ).","The lookup server then checks to see if additional lower level lookup servers are indicated in its table as corresponding to the desired server (Block ). If there is an additional matching record indicating another lower level lookup server, operations return to Block  and another lookup request is sent. If no additional lower level lookup servers are indicated in the lookup table, the lookup server -, -, etc. sends a response to the client component including the accumulated metadata from which the client component can reconstruct the address of the desired server component (Block ).",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 2","b":"20"},"Referring to , the server component  may issue a Publish command  to a low level lookup server  associated with the server component . The Publish command may contain one or more metadata fields MD, MD that can be used by client components to reconstruct the address of the server component .","The format of the metadata fields is arbitrary, and needs to be known only to the server component  and the client components. The IPC lookup system  does not need to know what the metadata references; rather, the IPC lookup system  only needs to know how to process and store the metadata for a particular type of server component. Techniques for providing the IPC lookup system  with instructions for managing the metadata are discussed in more detail below.","Still referring to , the publish command  is received by the low level lookup server , which processes a portion of the metadata, e.g., metadata MD, and updates a low level table managed by the low level lookup server  (block ). For example, in some embodiments, the low level lookup server  may store the metadata MD in the low level table in an entry associated with the server component .","The low level lookup server  may then publish the remaining metadata MD to a higher level lookup server  via a publication message . The high level lookup server  may then process the metadata MD and update the high level table (block ). For example, the high level lookup server may store the metadata MD in the high level table in an entry associated with the low level lookup server .",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 3","b":["60","62","20","50","50","1","20","54"]},"The high level lookup server  may then issue a lookup request  to the low level lookup server. The lookup request  may include the metadata MD retrieved from the high level table in block .","Upon receipt of the lookup request  from the high level lookup server , the low level lookup server  may retrieve metadata MD from the low level table (block ), and may send a Resolved message  back to the high level lookup server  that contains at least the metadata MD, but may include both MD and MD. The high level lookup server  may then send a Resolved message  back to the client component  that contains both metadata MD and metadata MD.","The client component  may process the metadata MD, MD to generate an address for the server component  (block ) and then send a message  to the server component  using the resolved address.","Further examples are illustrated in . In particular,  is a schematic block diagram of a system according to some embodiments that includes a cluster of nodes A, B and C in which various client and server components are located. Each node may represent a separate computing system, a separate partition within a single computing system, etc.","In the example illustrated in , a first node A (Node ), hosts a client component . A second node B (Node ), hosts a server component B, while a third node C (Node ), hosts server components C and D.","Each server component B, C, D, includes or is associated with a low level table, namely, process local tables B, C and D that store information relating to processes handled by their associated server components.","Node  includes a node level lookup server B and an associated node local table I B, while Node  includes a node level lookup server C and an associated node local table C. The node level tables B, C are higher level tables than the process local tables B-D, and store information relating to multiple server components within their associated nodes.","A cluster level lookup server  manages a cluster table , which represents the highest level table in the system illustrated in . The cluster table  stores information regarding server components within the all of nodes in the cluster. Although illustrated as a standalone component, the cluster level lookup server  may be hosted in one of the nodes.","The nodes A to C and the cluster level lookup server communicate with one another over a communication network , which may, for example, include a system bus, a wide area network, a local area network, the Internet or any other communication pathway.","In the examples illustrated in , a logical key format is used that consists of two integers. One integer represents the type of functionality associated with the name, and the other integer represents the instance of that functionality, e.g. a process, that is being contacted. This just an example of a format, and other formats are possible. In the following discussion, the logical key that is used for server address lookup is referred to as a \u201cdestination name\u201d or simply a \u201cname.\u201d","In order to keep the size of the lookup tables down, and to limit the size and frequency of updates having to be distributed between nodes, it may be desirable to treat multiple instances of a particular server functionality type as suites, and only distribute and store information regarding suites of instances instead of information regarding individual instances. This may be facilitated by keeping instances numerically adjacent, which can be achieved either through rigorous application design, or by using an offline or run-time identity provider. An IPC application programming interface (API) for a system according to some embodiments may support, and even enforce, the use of such a concept.","The key\/name scheme used as an example herein is used as shown in . As shown therein, a system may include a client component , a first server component C that is resident in a first partition of a node (e.g., Partition A of Node ) and a second server component D that is resident in a second partition of a node (e.g., Partition B of Node ).","In the example illustrated in , the lookup key consists of a type and an instance identifier, while a destination is given the ability to bind to a key range, by indicating the upper\/lower bound of the range.","The first server component C binds its address (addr=xxx) to a server type (4711) and a range of instances [0:99] via a Publish command (such as a bind call)  to the IPC lookup system . The second server component D binds its address (addr=yyy) to the same server type (4711) and a different range of instances [100:199] via a bind call  to the IPC lookup system .","The client component  may desire to send a message to a server indicated by server type=4711 and instance=33. The client component  would therefore send a lookup request  to the IPC lookup system . The lookup request includes the two-integer name of the server, i.e. server type=4711 and instance=33, as the lookup key. The IPC lookup system would thus return the address (addr=xxx) of the first server component C, since that server component has the correct server type and hosts the instance identified in the lookup request.","Since the type of endpoint represented by a destination name is defined by the user application, it is also possible that the structure of the name may be defined by the application. Therefore, in addition to or instead of the two integer format described above, systems\/methods according to some embodiments may allow for a superset of user-defined name formats. The lookup and translation process may be slightly less efficient in such an approach due to increased overhead requirements. However, for some applications, the lookup efficiency may be less important than the flexibility of having a custom name format.","In systems\/methods according to some embodiments, the lookup table to be used by the IPC system can be seen as a generic database that provides the ability to bind or associate user data (i.e., metadata) to a lookup key. The format of the key must be known by the system\/database server, while the format and semantics of the metadata may be opaque, and may only be known by the application issuing and using it.","For example, the IPC system may be regarded as only one such application among others and having its own interpretation of the metadata. However, in systems\/methods according to some embodiments, some of the metadata may represent a destination address, while other metadata may represent other data, such as, for example, the execution state of the destination component (e.g., active\/standby\/reserve).","To avoid exhausting the key space, and to easily separate the different services, the database may be sub-divided into name spaces, e.g. \u201cIPC\u201d, \u201cVirtual Router #8\u201d, \u201cOSPF\u201d, or any other desired name space, without prescribing any particular format for the name space identifier. Inside each name space, the lookup key may have a format that can be interpreted by the lookup server. The name spaces may have one or a few fixed formats, or may have formats that are themselves described by metadata, e.g. XML. For an IPC service, a simple, fixed format may be a suitable approach.","In order to reduce signaling intensity and\/or memory footprint, it may be desirable to define which metadata should be propagated to which level in the hierarchy. Such a property may be determined not only on a \u201cneed-to-know\u201d basis, but also on the assumed update frequency of each part of the metadata. In the examples illustrated in , a three level lookup hierarchy is illustrated. However, the principle may apply to a lookup system having any number of levels",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIGS. 6-9","FIGS. 6 and 7","FIGS. 8 and 9","FIG. 4"]},"In particular,  illustrates a system including two nodes, Node  A and Node  B. A client component  resides in Node  along with a cluster level lookup server  which manages a cluster level table , which is the highest level table in the system illustrated in .","A server component  resides in Node . The server component B also includes a process local table B, which represents the lowest level table in the system illustrated in . The process local table B refers to objects (e.g. instances or flows) that are operated by the server component B. Those instances are enumerated  to  in this example. Although virtually addressable all the time, these objects (instances) only need to exist when there is any need for them. Hence, when an object is created or deleted, an operation that may be frequent, only the process local lookup table needs to be updated, and the impact on the overall system may be minimal.","Node  also includes a node level lookup server B that manages a node level table B, which is intermediate the process local table B and the cluster level table  in the IPC table hierarchy.","The node level table B contains references to all the local processes in the node. The only extra information this table needs to keep is the port number to reach the process in question. The table stores those port numbers (64 and 118 in the example) as first metadata MD, without knowing anything about their meaning. The table does not necessarily store the node identity of the destination processes. This table only needs to be updated when a process with a new range and port number, on the same node, is created or killed.","In the example illustrated in , the node level table B stores records that identify processes by scope, type, and lower and upper instance range boundaries. In the example illustrated in , the node level table B includes two records for servers having the scope \u201cIPC.\u201d The first IPC record indicates a server type of \u201c42\u201d and an instance range of 100 to 199. The metadata MD, which refers to the port of the server, is \u201c64.\u201d The second IPC record indicates a server type of \u201c42\u201d and an instance range of 200 to 299 with metadata MD of \u201c118.\u201d","The node level table B also includes an entry for a server having the scope of \u201cVR8.\u201d That entry indicates a server type of 4711 with an instance range of 8-10. However the metadata MD stored with this entry is the alphanumeric string \u201cghi.\u201d Thus, it is understood that the metadata MD has a different meaning for servers within the VR8 scope than it does for IPC-scope servers. The meaning attached to the metadata MD may only be important to clients and servers within that scope, however, and it need not be known to the IPC lookup system.","The highest level in the example shown in  is the cluster level table , which is managed by a cluster level lookup server  in Node . The cluster level table  stores information indicating the process instance ranges served at particular nodes, but does not store the local port numbers used on those nodes or other information identifying the particular servers that handle those instance ranges. Hence, only the metadata representing the node address (i.e., MD) may be propagated to this level, and the cluster level table  may only need to be updated whenever a node is added or removed from serving this particular server process type.","It may also be desirable for the IPC lookup system  to have the capability to receive and process \u201cmeta-metadata\u201d, i.e., data that describes the metadata in some way. For example, the meta-metadata may provide a way for the publisher to indicate which metadata should be propagated to a particular level. The use of meta-metadata according to some embodiments is described in more detail below.","Referring to , when the server component B wants to publish (bind) its address to a given type and instance suite (e.g., type 42 and instance suite [100:199] in the example), the server component B may first issue a Publish call  the node level lookup server B. The Publish call  includes the node and port of the server component B as the metadata MD, MD, e.g., the Publish call  may have the form Publish (scope=ipc, type=42, lower=100, upper=199, md=64, md=2). Only the client component  and the server component B may know that md and md refer to a node and port, respectively.","The node level lookup server B parses the first metadata MD {64} from the Publish call and stores it in the node level table B (block ) along with the published instance suite [100:199], and then issues a Publish call  to the next-level lookup server, which is the cluster level lookup server  in this case, that includes the metadata MD, {2}. The form of the Publish call  may be Publish (scope=ipc, type=42, lower=100, upper=199, md=2). Note that the cluster level lookup server may independently store the name of the node (Node ) from which the Publish call was received to facilitate later forwarding of lookup requests that identify a particular record.","The cluster level lookup server  stores the received metadata in the cluster level table  (block ). In this example, it is assumed that there already is an entry for this type (42) and for this node () in the cluster level table  published by some other server on Node . However, the existing entry is for the instance range [200; 299]. The cluster level lookup server  determines that the existing entry happens to have the same metadata as the new publication, so the two publications may be merged in the same entry, which relates to the name suite {42,[100,299]}. The entry has common metadata, and points to the same node of origin (). If the metadata or the original node ID differ, the new publication would be placed into a new, separate entry.",{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIGS. 8 and 9","b":["160","160","150","151","151","151"]},"The cluster level lookup server  retrieves the metadata MD from the cluster level table that corresponds to servers of the specified scope, type and instance range (block ). The cluster level lookup server  does not have the full information about name type 42. However, it may determine, for example from metadata MD, that more information about instance  can be found in the node level table on Node . Thus, the cluster level lookup server forwards the lookup request to Node  along with the metadata it has stored {2} to the node level lookup server B in Node  in a Lookup request , which may have the form Lookup(scope=ipc, type=42, instance=198, md=2).","In response to the Lookup request , the node level lookup server B in Node  checks the node level table B and determines that the range of instances from 100 to 199 is served by a server having metadata MD {64}. The node level lookup server B then returns a Resolved message  to the cluster level lookup server  containing both the supported range ([100:199]) and the full metadata {2,64}. The Resolved message  may have the form Resolved(lower=100, upper=199, md=64, md=2). The cluster level lookup table  may then send a corresponding Resolved message  to the client component .","The client component  processes the returned metadata MD, MD to generate an address for the server component B. In this example, the client component simply interprets the metadata MD, MD as an address consisting of node and port number. The client component  may then send a message  to the server component E using this address. The name instance () that the client component wants to reach may also be sent in the message . The send message  may have the form Send (inst=198, node=2, port=64).","In the server component B, the local name table can translate the instance contained in the message  to whatever meaning it has locally, e.g. an instance, flow, thread, data object, etc. The server component can thereafter perform a task in response to the message .",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 10","FIG. 10"],"b":"20"},"Referring to , a server component  issues a Publish request  to a low level lookup server  that specifies, among other things, first and second metadata MD, MD, as well as meta-metadata MMD.","The low level lookup server  processes the metadata MD in accordance with the instructions and\/or configuration information provided in the meta-metadata MMD and updates the associated low level name table (block ). The low level lookup server  may then send a Publish request  including the metadata MD and optionally including the meta-metadata MMD to a high level lookup server . The high level lookup server  processes the metadata MD in accordance with the instructions and\/or configuration information provided in the meta-metadata MMD and updates the associated high level name table (block ).",{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 11","b":"40"},"Referring to , a server component  issues a Publish request  to a low level lookup server  that specifies, among other things, first and second metadata MD, MD.","The low level lookup server  processes the metadata MD and updates the associated low level name table (block ). The low level lookup server  may then send a Publish request  including the metadata MD and including meta-metadata MMD that specifies how the metadata MD is to be processed to a high level lookup server . The high level lookup server  processes the metadata MD in accordance with the instructions and\/or configuration information provided in the meta-metadata MMD and updates the associated high level name table (block ).",{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 12"},"Referring to , a client component  issues a Lookup request  to a high level lookup server . The Lookup request  specifies, among other things, a server name and meta-metadata that provides instructions for processing metadata retrieved from name tables in the IPC lookup system.","In response to the Lookup request , the high level lookup server  retrieves metadata MD stored in the high level name table that is associated with the specified server name in accordance with instructions and\/or configuration information provided in the meta-metadata (Block ).","The high level lookup server  then issues a Lookup request  to a low level lookup server . The Lookup request  includes the metadata MD retrieved by the high level lookup server  and also includes the meta-metadata provided by the client component.","In response to the Lookup request , the low level lookup server  retrieves metadata MD stored in the low level name table that is associated with the specified server name in accordance with instructions and\/or configuration information provided in the meta-metadata (Block ). Optionally, the low level lookup server may process the first and second metadata MD, MD in accordance with instructions and\/or configuration information contained in the meta-metadata and generate an address of the server component.","The low level lookup server  then sends a Resolved message  to the high level lookup server  that may include the metadata MD, MD or, optionally, the address of the server component. The high level lookup sever  may resolve the address of the server component if it has not already been resolved. The high level lookup server  may then send a corresponding Resolved message  to the client component . The client component  may then send a message  to the server component  using the resolved address.","An example of a situation in which the cluster level table includes multiple entries corresponding to a particular server type is illustrated in .","In the example illustrated in , a client component  wants to send a message to a server of type 42. The client  first calls the nearest instance of the highest level lookup server, which in this example is the cluster level lookup server , by issuing a lookup command  specifying the name of the desired server component. In this example, the name of the server component includes a two integer value of type=42 and instance=198. The lookup command  also specifies the scope of the desired server, which in this example is \u201cIPC.\u201d The lookup command  may have the form Lookup(scope=ipc, type=42, instance=198).","The cluster level table  managed by the cluster level lookup server  has two entries corresponding to server type 42 and instance . The first entry specifies MD=2, while the second entry specifies MD=3.","The cluster level lookup server  retrieves the metadata MD from the cluster level table that corresponds to servers of the specified scope, type and instance range (block ). The cluster level lookup server  does not have the full information about name type 42. However, it is aware that more information about instance  can be found in the node level table on Nodes  and . Thus, the cluster level lookup server  first sends a lookup request  along with the first metadata MD it has stored {2} to the node level lookup server B in Node . The Lookup request  may have the form Lookup(scope=ipc, type=42, instance=198, md=2).","In response to the Lookup request , the node level lookup server B in Node  checks the node level table B and determines that the range of instances from 100 to 199 is served by a server having metadata {64}. The node level lookup server B then returns a Resolved message  to the cluster level lookup server  containing both the supported range ([100:199]) and the full metadata {2,64}. The Resolved message  may have the form Resolved(lower=100, upper=199, md=64, md=2).","Next, the cluster level lookup server  sends a lookup request  along with the second metadata MD\u2032 it has stored {3} to the node level lookup server C in Node . The Lookup request  may have the form Lookup(scope=ipc, type=42, instance=198, md=3).","In response to the Lookup request , the node level lookup server C in Node  checks the node level table C and determines that the range of instances from 100 to 199 is served by servers having metadata {72} and {255}. The node level lookup server C then returns a Resolved message  to the cluster level lookup server  containing both the supported range ([100:199]) and the full metadata {3,[72, 255]}. The Resolved message  may have the form Resolved(lower=100, upper=199, md=[72,255], md=3).","The cluster level lookup table  may then send a Resolved message  to the client component  including all of the values of MD received from the node level lookup servers B, C. The Resolved message  may have the form Resolved(lower=100, upper=199, [{md=64, md=2}, {md=[72,255], md=3}). The client component  may use this information to select and resolve the address of a desired server component.","One potential advantage of systems\/methods according to the present invention is flexibility, in the sense that the systems\/methods described herein may permit practically any destination format to be used, without letting the lookup server be aware of what type of address (or indeed that it actually is an address) it is storing.","Another potential advantage is that these systems\/methods may save memory by only distributing detailed data about a destination as far as strictly necessary.","For the same reason, these systems\/methods can save system and\/or CPU bandwidth, since publication and update messages may not need to be sent to all nodes.","Address lookup of destination components is similar in nature to domain name lookup services provided by domain lookup servers (DNS). In a DNS system, a client component provides a uniform resource locator, such as an alphanumeric host name (e.g., www.ericsson.com), as a key to a domain lookup server. The domain lookup server resolves the alphanumeric host name into a numeric host IP address (e.g., 192.168.1.100). However, while DNS resolves parts of the key at each level in a hierarchical fashion, systems\/methods according to some embodiments may resolve the entire key at each step.","While DNS only stores and returns the full lookup result at the last (lowest) level, systems\/methods according to some embodiments may store the result piece by piece in a hierarchical fashion. Those partial results are built up step by step for each level the lookup process goes through, and is only complete when the last level is reached.","Furthermore, systems\/methods according to some embodiments provide for the addition of meta-metadata, describing (if necessary) not only the type of data the metadata (e.g. lookup address) consists of, but also how it should be treated at each level in the storage hierarchy.","Some existing solutions, such as domain name lookup services by domain lookup servers (DNS), provide hierarchical lookup services. One disadvantage with the DNS approach is that it has a completely rigid structure. The lookup key is a string, nothing else, and the result is an IP address and a port. There is no concept of integer keys, key suites, metadata that describes the lookup result, or meta-metadata that describes what should happen to the metadata.","Such systems may also suffer from decreased efficiency. Because DNS is based on parsing of strings, it is not suitable for embedded clusters with high requirements on lookup times.","Such systems may further require increased memory consumption. In a large system, the translation table may become huge. This can partly be remedied by managing name ranges, rather than individual ranges, however.","Communication bandwidth requirements of address translations may be large. In a large system, there will be a lot of binding\/unbinding activity going on, and the burden of keeping the translation table instances updated at any time may become excessive. Hierarchical address\/name lookup and delegation as described herein may solve this problem, apart from further reducing the memory footprint of the translation table.","As will be appreciated by one of skill in the art, the present invention may be embodied as a method, a system, and\/or computer program product. Furthermore, the present invention may take the form of a computer program product on a tangible computer usable storage medium having computer program code embodied in the medium that can be executed by a computer. Any suitable tangible computer readable medium may be utilized including hard disks, CD ROMs, optical storage devices, or magnetic storage devices.","Some embodiments of the present invention are described herein with reference to flowchart illustrations and\/or block diagrams of methods, systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer readable memory produce an article of manufacture including instruction means which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","It is to be understood that the functions\/acts noted in the blocks may occur out of the order noted in the operational illustrations. For example, two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order, depending upon the functionality\/acts involved. Although some of the diagrams include arrows on communication paths to show a primary direction of communication, it is to be understood that communication may occur in the opposite direction to the depicted arrows.","Computer program code for carrying out operations of the present invention may be written in an object oriented programming language such as Java or C++. However, the computer program code for carrying out operations of the present invention may also be written in conventional procedural programming languages, such as the \u201cC\u201d programming language. The program code may execute entirely on the user's computer, partly on the user's computer, as a standalone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer. In the latter scenario, the remote computer may be connected to the user's computer through a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Many different embodiments have been disclosed herein, in connection with the above description and the drawings. It will be understood that it would be unduly repetitious and obfuscating to literally describe and illustrate every combination and subcombination of these embodiments. Accordingly, all embodiments can be combined in any way and\/or combination, and the present specification, including the drawings, shall be construed to constitute a complete written description of all combinations and subcombinations of the embodiments described herein, and of the manner and process of making and using them, and shall support claims to any such combination or subcombination.","In the drawings and specification, there have been disclosed typical embodiments of the invention and, although specific terms are employed, they are used in a generic and descriptive sense only and not for purposes of limitation, the scope of the invention being set forth in the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are included to provide a further understanding of the invention and are incorporated in and constitute a part of this application, illustrate certain embodiment(s) of the invention. In the drawings:",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 1C and 1D"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 10 and 11"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
