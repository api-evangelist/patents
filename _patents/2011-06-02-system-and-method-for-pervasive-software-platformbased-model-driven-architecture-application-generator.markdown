---
title: System and method for pervasive software platform-based model driven architecture application generator
abstract: In developing applications for a plurality of node types, a meta-data definition of the application can be captured into an application definition module. The meta-data definition can describe the application for the plurality of node types. A code generation module can then automatically generate the application code for the plurality of node types. The code can be compiled per node type and the packaging necessary to deploy the application to the plurality of node types can also be automatically generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09250883&OS=09250883&RS=09250883
owner: Open Invention Network, LLC
number: 09250883
owner_city: Durham
owner_country: US
publication_date: 20110602
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is related to the Applicants and\/or Assignees co-pending patent application Ser. No. 13\/151,671, titled ARCHITECTURE FOR PERVASIVE SOFTWARE PLATFORM-BASED DISTRIBUTED KNOWLEDGE NETWORK (DKN) AND INTELLIGENT SENSOR NETWORK (ISN), filed on Jun. 2, 2011, Ser. No. 13\/151,707, titled SYSTEM AND METHOD FOR PROVIDING SELF-HEALING CAPABILITIES IN A DISTRIBUTED KNOWLEDGE NETWORK\/INTELLIGENT SENSOR NETWORK, filed on Jun. 2, 2011 and Ser. No. 13\/151,782, titled SYSTEM AND METHOD FOR PERVASIVE SOFTWARE PLATFORM-BASED MODEL DRIVEN ARCHITECTURE TRANSACTION AWARE APPLICATION GENERATOR, filed on Jun. 2, 2011. The entire contents of each of these patent applications is incorporated herein by reference.","This disclosure relates to applications that run on multiple node and device types, and in particular to systems and methods for generating pervasive applications.","There is currently no model\/meta-data driven approach to generating code for applications that span heterogeneous networks, devices and their underlying operating systems, software languages, software protocols and messaging capabilities. This is not only true for simple client-server mobile environments, but also environments that involve peer-2-peer and peer-2-group communication.","There is a need to provide a complete solution (Platform and tools to generate applications on such) for advanced applications including those that fall into the category of Distributed Knowledge Networks and Intelligent Sensor Network based applications. These types of advanced applications will run on the Internet of Things that include smartphones, MIDs, UMPCs, Netbooks, eBooks, Auto-based Computers, Home Storage Devices, Desktops\/Laptops, Routers, Switches, Sensors and on and on.","There are no solutions that solve the problem above. There are code generation capabilities for applications with homogenous platforms and\/or client-server web services\/HTTP based architecture. There are also such capabilities for specific device subsets (smartphones or desktops for example). But there is no MDA solution to enable pervasive applications that are defined by the characteristics above.","What is required is a system and method for improved generation of pervasive applications.","In one aspect of the disclosure, there is provided a method for creating pervasive applications executable by a plurality of node types. The method comprises capturing a meta-data definition of the application into an application definition module, the meta-data definition describing at least the plurality of node types. Code per node type may be automatically generated and compiled for the plurality of node types in a code generation module. The packaging necessary to deploy the application to the plurality of node types may also be generated.","In one aspect of the disclosure, there is provided a system for generating applications comprising an application object model definition module and a code generator module. The application object model definition module provides an interface to receive inputs from a user that define an object model for an application. The code generator module generates the application code for an object model of an application defined through the application object model definition module.","In one aspect of the disclosure, there is provided a computer-readable medium comprising computer-executable instructions for execution by at least one processor, that, when executed, cause the at least one processor to provide an interface that allows a user to enter a meta-data definition of an application, the meta-data definition comprising a plurality of node types; generate application code per node type for the plurality of node types; and compile the code per node type.","The systems and methods to be described in the embodiments below provide a means for the development of pervasive applications that can deployed to multiple node types. The applications may be developed in conjunction with a pervasive computing platform of the type described in the present Applicant's co-pending patent application Ser. No. 13\/151,671, referenced above.","The pervasive software platform provides a single set of APIs for discovering, accessing and hosting services and data, across operating systems, languages and protocols. The code generation approaches are not intelligent enough, thereby enabling simplification of the code generation process.","The pervasive platform could be part of the application or application library, a dependent library for the application or application library and\/or part of the device. The pervasive platform may also be dependent on the target type, similar to the application\/application library.","An embodiment of the process for development of pervasive applications is depicted in the flowchart  of . At step , an application developer defines an object model and associated meta-data for an application through a development interface. The specification of the meta-data includes the target types. At step , the development interface processes the meta-data as per the application object model to generate the code for the application. At step , the development interface generates the packaging for deployment of the application to the indicated device types.","A process for capturing the application definition is shown in more detail in the flowchart  of . At step , the development interface receives inputs from the application developer that specify an application object model for the application. At step , the development interface receives inputs that define the application nodes and node connectivity. At step , the development interface receives a definition of the user interface.","In capturing the meta-data, a first step is to describe the Application Object Model through a tool and store it in an Object Model Repository. Above and beyond the typical data captured in an object model (classes, interfaces and their attributes, methods, exceptions etc.), certain additional information is captured such as whether the class is mobile or persistent or location-aware. For interfaces, the meta data may include whether they are remotely accessible. All classes and interfaces are associated with one or more applications.","Once the application object model has been defined, various meta-data may then be captured. This usually is only done once. For example Language Types (Java, .NET Languages, Unmanaged C++, Javascript, PHP, etc.). Virtual Machine Language Type (JME, JSE, Dalvik, .NET, CF, Silverlight etc.), Operating System Types (Linux, Win Mobile\/CE\/XP, Unix, Blackberry, MAC\/iPhone, Symbian, etc.), Platform Types (JSE, .NET\/CF, Android, Limo, Symbian, Meego, iPhone, etc.), Network Types (Wire, WiFi, GSM\/CDMA, WiMax\/LTE, Bluetooth, Zigbee, NFC), Database Types (Relational, Object, Object-relational, XML), Database Type Instances (SqlLite, DB2, DB2e, Oracle, Oracle Light, DB40), Protocol Types (SOAP, HTTP, XML-RPC, IIOP, RMI\/IIOP, OBEX, REST, etc.) Message Types (JMS, MSMQ, RPC, Socket, DDS, etc.), Serialization Type (Binary, XML, JSON, Character etc.).","A process is used to capture information about the pervasive application. The process may comprise defining the node types, associating the business processes with the particular device types, and defining the messaging that occurs between node types associated with the application. For example the various Node Types participating in the application are first specified. This may be performed, for example, from drop down menus on the development interface or by dragging and dropping device types into the application. The main attributes that describe a Node Type are its device type, platform type, operating system, supported networks, preferred software development languages and virtual machines. Then the business processes that are desired are associated with the particular device type. The business process involves message flows between objects etc. This may be captured through conventional OOA\/OOD tools such as use cases, sequence diagrams and interaction diagrams.","When a business object is configured onto a node, the development interface prompts the user (developer) to specify a) whether the business object is remotely accessible, b) whether the business object is mobile (can migrate between devices), and c) whether the business object is persistable. The business intelligence objects may also be rules aware.","In the pervasive computing world with applications spanning heterogeneous device sets, there is the additional need for capturing additional type of messaging that occurs between node types associated with the application. This is done as follows. In the case of peer-2-peer messaging between two node types, there are two important pieces of information. The first is the network type that connects the two devices (IP-based or some other non-IP based network). The second is the preference for distributed protocols to be used when invoking services on the two devices. For example a first preference of Binary XML followed by IIOP, XML-RPC and SOAP, if performance is a concern. The process is similar in the case of peer-2-group messaging between groups of node types. After the collection of node types is selected, again, as above, the network type that connects these devices is selected. Then the messaging protocol is established. This list would include such protocols as TCP\/IP, UDP, JMS, MSMQ or DDS for example.","The above described processes may be performed using an application development system  as illustrated in . The development system  may include a plurality of software modules including a reference table setup module , an application object model module , an application node connectivity module , a user interface module , a source code generation module  and a distribution file generation module . The development interface  also includes one or more databases  for storing pervasive meta-data and application data in various tables , , , , , as will be described in more detail below.","The reference table setup module  is shown in more detail in . The reference table module  operates to provide a user interface by which a user, such as an application developer, may define pervasive environment reference data . This data describes the device types, the device type platforms, networks etc that can be utilized by any application within the organization utilizing the MDA Tool.","Through this module, the enterprise architect, system administrator or application developer can populate tables based on suggestions provided and knowledge of targeted devices, networks, platforms etc. The reference table setup module  generates one or more reference data tables  that are added  to the pervasive meta-data database . The reference data tables  may be stored in XMI\/MOF Format. The reference data may include the following:\n\n","By way of example, a process for defining the language type is depicted in . The designer provides the language type name and description at step  and defines if the language is a scripting language at step . A language table in the reference database is then updated with the new language type data at step , including generating and storing an ID for the language type. Similar processes may be followed for defining the other types of reference table data mentioned above.","The system  includes an Application Object Model Definition module  which performs as shown in more detail in . The Application Object Model Definition module  provides an interface enabling an application developer to define an object model  for the application under development by way of one or more application object model tables . The Application Object Model Definition module  may prompt the developer to define:\n\n","In prompting the developer for these definitions, the Application Object Model Definition module  may make reference to the reference data tables  stored in the database. Once the object model has been defined for the application, the Application Object Model Definition module  stores the provided definitions as meta-data in one or more application object model tables  in the database . The object model may be stored in XMI\/MOF Format including data for:\n\n","To define an application, a designer may initially define an application include a name and description. The application may be given an application ID which is added to an application table in the Application Object Model database. The designer may then provide an application UI type name and description, which is also assigned an ID and added to an Application UI Type table in the Application Object Model database in association with the application ID for the application. Any Application Instance UI types can be similarly defined.","A process for defining an application component is depicted in . The designer selects through the development interface the application that is being developed (step ). The designer then enters the application component name and a description of the application component (step ). At step , the defined application component is added to the application component table in the application object model database. Application Component Packages can be defined for an application component by selecting the application and the application component and then entering the application component package name and description. The Application Component Package data is then added to an Application Component Package Table in the Application Object Model database.","The designer may then define any classes for the application component package following a process depicted in . At step , the designer enters the class name and description. The designer then selects the application component, application component package, parent class and interface for this class (step ). The designer may then provide indicators that specify whether the class is persistent, location aware and mobile as well as data transfer class and agent indicators (step ). The data is then stored in a class table in the application object database (step ). Data for each of the application parameters and components mentioned above may be added in a similar manner to the process depicted in . Data fields for each of the respective application object model data tables is provided in an example database schema described below.","The system  may include a User Interface Definition module  which may provide an interface to receive inputs from the application developer. Through this interface, the developer may:\n\n","The meta-data provided via the User Interface Definition module  may be stored in one or more Application Instance User Interface tables . The meta-data stored may include:\n\n","An example schema for the UI tables is provide in the sample database schema below. A process for defining the application instance UI data representation class is depicted in . At step , the developer enters the application instance name and description. The developer then enters the respective application instance UI data representation class and name and description (step ). The developer then selects an application instance UI type and class (step ). After selection, the application instance UI type class table is updated (step ). The developer then sets the CRUDs and Browse indicators (step ) (CUD indicators only being set if the class is persistent). These indicators are then updated in the relevant table in the Application Object Database (step ).","A process for defining the application instance UI Webview Source callback is depicted in . At step , the developer enters the application instance UI webview page name and description. The developer then sets the application instance UI class (step ). A javascript HTML template file is then generated (step ) which is used to update the class and class source tables for the application instance UI web view page class (step ). At step , the javascript functions are generated from the class methods and CRUD indicators and used to update the Application Instance UI WebView JavaScript Function Table in the application object database (step ). At step  the Javascript callback Classes for each Javascript function are generated. The callback class delegates calls from the corresponding javascript function to the WebView Page. This data is added to the respective Application Instance UI Source Callback table (step ). At step , the Class and Class Source Tables in application object database are updated with Application Manager Class, which contains methods to show\/hide each WebView Page.","The application development system  may include an Application Node Connectivity module  that provides an interface configured to receive input from the application developer that defines Application Node Types as well as connectivity between the node types. The developer may indicate node types in various ways, such as by selecting from drop down menus that reference defined node types in the reference data tables , by drag & drop into an application window, etc. A target type may have subtypes. For example, a mobile device type may have subtypes such as MiD, UMPC, Smartphone, PND, etc.","The Application Node Connectivity module  may also enable the application developer to define Peer-2-Peer Connectivity between node types. For example, the user may select two Application Nodes, select or indicate Network Type(s) between the Application Nodes and then select or indicate Distributed Protocol Type(s) between both Application Nodes. The network types and distributed protocol types may be indicated by selecting the available types from data provided in the reference data tables .","The Application Node Connectivity module  may also enable the application developer to define Peer-2-Group Connectivity. Through this interface, the developer may:\n\n","The meta-data provided via the Application Node Connectivity module  may be stored in the pervasive meta-data database  in one or more application node connectivity tables . The connectivity tables may include fields for\n\n","To enable the application developer to describe the node connectivity, the system  may provide information from the reference data tables  as well as definitions from the Application Object Model tables . An example schema for the connectivity tables discussed above is provided below.","A process for defining a peer-to-peer link is depicted in . At step , the developer enters a peer-to-peer link name and description. The developer then selects two node types that will communicate peer-to-peer (step ). This information is then added to a peer-to-peer link table in the application object database (step ).","A process for defining a peer group node type is depicted in . At step , the developer enters a peer group node type name and description. The developer then selects a peer group node type (step ). If the selected node type hosts a peer group, an indicator is turned on (step ). The data is then updated to a peer group node type pay table in the application object database (step ).","The system  may include a Generate Source Code module . The generate source code module  is the module that produces the application code based upon the definitions provided by the application developer in the respective tables , ,  and with reference to the reference data tables . Once the definitions for the application have been provided, the Generate Source Code module  reads all of the tables (i.e. tables , , , ) as well as tables joined from other repositories. In the code generation phase, the code generator module  generates the source code and either byte code or machine code for the specified target types. The Code Generator accesses class libraries or executables , ,  which are provided per target type. The code generator  may generate the whole application or parts of the application.","For each node type of the application node connectivity table , the generate source code module  generates code for the node type using the application class library or executable library , ,  for that node type. The process for generating the source code is depicted in the flowchart  of . At step , the code generator module  generates all Interface source code. This is generated from the Application Object tables , , , , , and put in table ","At step , the code generator module  generates source code for all Mobile\/Data Transfer Object (DTO) Classes and Classes needed to support various distributed messaging, payload serialization and network protocols. The source code is generated using the data from the Application Object Model tables , , , , ,  and .","These classes represent the data (complex objects) that is passed\/returned as part of method invocations and responses. This process utilizes the Universal Serialization Sub-Module\/API of the Pervasive Computing Platform described in the present Applicant's co-pending application Ser. No. 13\/151,671, referenced above. The Universal Serialization API is accomplished by interfaces and accompanying methods that are implemented for a DTO to be universally Serializable. The DTO classes are generated with these interfaces\/methods implemented. These methods utilize the Universal Serialization Sub-Module\/API of the Pervasive Computing Platform. At step , the code generator module  reads the Application Object Model tables , , , , ,  and  and generates Business Object Classes with stubbed out business process methods.","At step , the code generator module processes the data tables to generate Application Data \u201cClient\u201d Access classes that allow for access to any node (P2P) or group of nodes (P2Group) using any protocol specified in the application node connectivity tables.","For P2P, the code generator module  utilizes the Universal Service Discovery\/Access\/Host Sub-Module\/APIs of Pervasive Computing Platform. These modules provide the capability for services running on a device, to be discovered via any other devices by name (White Pages) or description (Yellow Pages).","For P2Group, the code generator module  utilizes the Universal Pub\/Sub Group Messaging Sub-Module\/API of Pervasive Computing Platform. These modules provide the capability for devices to invoke method services on each other in a Peer-2-Peer manner, or can publish\/subscribe Universal Business Objects (i.e. Universally Serializable DTOs) to virtual groups of heterogeneous devices.","The Universal Pub-Sub API may include the following interface.","1) An Interface which allows you to Publish\/Subscribe to data by Topic:\n\n","2) A Callback Interface which allows you to receive messages:\n\n","There is Pub-Sub Messaging Factory, which loads an instance of the appropriate class that implements the above Pub-Sub interface; based on the platform the application is running on and configuration settings describing the type of publish and subscribe messaging capability desirable on such a platform.","The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal Directory, with a well-known name. From that point on the local application communicates with the Universal Pub-Sub Messaging interface described above. Remote nodes can communicate with the remotely accessible interface, by discovering it via the Universal Directory, based on its well-known name.","At step , the code generation module  generates JavaScript\/HTML UI JavaScript\/HTML to support CRUDS interface Presentation Layer.","At step , the code generate module  generates Native SDK Presentation Layer code to provide\/interact with JavaScript\/HTML code to\/with underlying Web Engine is also generated leveraging the Universal User Interface Sub-Module\/API of the Pervasive Computing Platform. This module provides a UI API that allows for communicating bi-directionally with the platforms underlying web-engine (WebKit, IE\/Silverlight etc) via JavaScript and support HTML 5. It allows for Bi-directional communication between Application Process Layer and Presentation Layer utilizing Universal API's of Pervasive Computing Platform.","The Universal UI Interface may include two interfaces.","1) A remotely accessible Interface, which represents the type of actions that can be done to render or access a User Interface's state\n\n","2) A locally accessible Interface, which represents additional actions that are needed to interact with the underlying user interface engine\n\n","There is Universal UI Factory, which loads an instance of the appropriate class that implements the above interfaces; based on the platform the application is running on. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages, with a well-known name. From that point on the local application simply communicates with the Universal UI interface described above. Remote nodes can communicate with the remotely accessible interface, by discovering it via the Universal White Pages, based on its well-known name.","At step , the code generation module  generates code for Bi-directional communication between Application Process Layer and Presentation Layer utilizing Universal API's of Pervasive Computing Platform. At step , the code generation module  generates Application Data Service Hosting classes for any services hosted on a device. This process leverages the Universal White Pages, Yellow Pages and Peer-2-Peers Sub-Modules\/API of Pervasive Computing Platform. This step includes generating any Proxy classes that are responsible for serialization\/de-serialization of payload (object reference, method arguments, exceptions and return values). These Proxy classes communicate with underlying Universal Core Request Brokering Sub-Module\/API of the Pervasive Computing Platform.","For those classes marked as persistent, the corresponding database persistence code is generated at step , leveraging the Universal Database Sub-Module\/API of the underlying Pervasive Computing Platform.","The Universal UI Database consists of:","1) An Interface, (UniversalDBAction) which represents the type of actions that can be done on a database:\n\n","There is Database Factory, which loads an instance of the appropriate class that implements the above interfaces; based on the platform the application is running on and configuration settings describing the desired database type. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages, with a well-known name. From that point on the local application simply communicates with the Universal Database interface described above. Remote nodes can communicate with the remotely accessible interface, by discovering it via the Universal White Pages, based on its well-known name.","For those classes marked as agents, the corresponding agent code is generated at step , leveraging the Universal Agent Sub-Module\/API of the underlying Pervasive Computing Platform.","The Universal Agent Interface may include:","1) An Agent Interface, which represents the type of actions that can be done on a Software Agent:\n\n","There is an Agent Factory, which loads an instance of the appropriate class that implements the above interface; based on the platform the application is running on, as well as configuration information describing any particularly desired agent platform. The implementation class is exposed as a remotely accessible object via the first interface described above. The object is bound to the Universal White Pages, with a well-known name. From that point on the local application communicates with the Universal Agent interface described above.","For those classes marked as location-aware, the corresponding location awareness code is generated at step , leveraging the Universal Location & PIM Sub-Module\/API of the underlying Pervasive Computing Platform.","For those classes methods associated with rule sets, the corresponding logic to interface with the rule engine is generated at step , leveraging the Universal Rules Sub-Module\/API of the underlying Pervasive Computing Platform.","At step , the Classes and Interfaces are aggregated based on the packages they were associated with in duration definition of the Object Model for the application, i.e. as described in the Application Object Model tables  described above.","Finally, at step  generated source code for the node type may be stored in Class\/Interface Tables  in the database . The Class\/Interface Tables may define:\n\n","The system  may include an Application Node Type Distribution File Generation Module . This module generates the corresponding application distribution file (Midlet JAD, Windows Mobile CAB, Android APK, Apple APP, Blackberry COD, etc) based on device type, platform type and selected language. Classes and Interfaces are put into libraries based on the Components they were associated with during definition of the object model for the application. The module  associates specific node instances to deploy files and stores Application Node Type Distribution File in Deployment Tables including:\n\n","Examples tables are provided in the sample database schema discussed below.","A process for generating the node application component is depicted in . At step , the developer enters the node application component name and description. The developer then selects node type, application instance, application instance UI type and application components for an application component (step ). At step , the generation module  generates the resource file for modification. The application component table is then updated with the resource file data (step ). A process for generating the node application deployment file is depicted in . At step , the developer enters the node application deployment file name and description and selects the node application components (step ). At step  the generation module  generates the application descriptor for modification and then creates the application deployment file (step ). The node application deployment file table is then updated (step ).","The Application Node Type Distribution File Generation Module  may also be responsible for generating the data and files required to deploy Application Deployment File to Specific Devices. The data required may be provided in tables including:\n\n","A process for deploying the files to the devices is depicted in . At step , the developer enters the node instance application deployment file name and description and selects a node instance (step ). The deployment file for the selected node instance is then deployed to the relevant device (step ). In addition, the resource file and application description files are updated as necessary (step ) and the node instance application deployment file table is updated (step ).","As described above, the data, meta-data and application code may be stored as one or more tables in one or more databases, such as the database . An example database design may be as follows:","1) Language Type (Java, .NET Languages, Unmanaged C++, Javascript, PHP . . . )\n\n","2) Virtual Machine Language Type (JME, JSE, Dalvik, .NET, CF, Silverlight . . . )\n\n","3) OS Type (Linux\/Unix, WinMobile\/CE\/XP, Blackberry, Mac, Symbian, TinyOS)\n\n","4) Platform Type (JSE, .NET\/CF, Android, Limo, Symbian, Meego, iPhone . . . )\n\n","5) Network Type (Wire\/WiFi, GSM\/CDMA, WiMax\/LTE, Bluetooth, Zigbee, NFC)\n\n","6) Database Type (Relational, Object, Object-relational, XML)\n\n","7) Database Type Instance (Sqlite, DB2, DB2e, Oracle, Oracle Light, DB40)\n\n","8) Rules Engine Type (RETE, other)\n\n","9) Rules Engine Type Instance (Drools, JRules, Jess, Advisor, Oracle BRules . . . )\n\n","10) Node Type (phone, netbook, laptop, eBook, setTop, camera, router, sensor . . . )\n\n","11) Node Type Network (node can support many network types)\n\n","12) Protocol Type (SOAP, HTTP, XML-RPC, IIOP, RMI\/IIOP, OBEX, REST . . . )\n\n","13) Protocol Network Type\n\n","14) Message Type (JMS, MSMQ, RPC, Socket, DDS etc.)\n\n","15) Serialization Type (Binary, XML, JSON, Character etc.)\n\n","16) Message Serialization Type\n\n","17) Application\n\n","18) Application UI Type (NA, SWT\/eSWT, .NET, Java\/ActionScript, PHP . . . )\n\n","19) Application Instance UI Type (NA, SWT\/eSWT, .NET, Java\/ActionScript . . . )\n\n","20) Application Component\n\n","21) Application Component Package\n\n","22) Class\n\n","23) Interface\n\n","24) Class Attribute\n\n","25) Rule Set\n\n","26) Rule\n\n","27) Rule Property\n\n","28) Rule for Rule Set\n\n","29) Class Method\n\n","30) Interface Method\n\n","31) Method Argument\n\n","32) Exception\n\n","38) Method Exception\n\n","34) Class Source\n\n","35) Interface Source\n\n","36) Class Method Source\n\n","37) Node Type Application\n\n","38) Peer-2-Peer Link\n\n","39) Peer-2-Peer Link Dist Protocol\n\n","40) Peer Group\n\n","41) Peer Group Node Type\n\n","42) Peer-2-Group Protocol (groups can communicate using many Protocols)\n\n","43) Application Instance UI Data Representation Class\n\n","44) Application Instance UI WebView Page Source\n\n","45) Application Instance UI WebView JavaScript Function\n\n","46) Application Instance UI WebView Source Callback\n\n","47) Node Application Component\n\n","48) Node Application Deployment File\n\n","49) Node Instance\n\n","49) Node Instance Application Deployment File\n\n","Although embodiments of the present invention have been illustrated in the accompanied drawings and described in the foregoing description, it will be understood that the invention is not limited to the embodiments disclosed, but is capable of numerous rearrangements, modifications, and substitutions without departing from the spirit of the invention as set forth and defined by the following claims. For example, the capabilities of the invention can be performed fully and\/or partially by one or more of the blocks, modules, processors or memories. Also, these capabilities may be performed in the current manner or in a distributed manner and on, or via, any device able to provide and\/or receive information. Further, although depicted in a particular manner, various modules or blocks may be repositioned without departing from the scope of the current invention. Still further, although depicted in a particular manner, a greater or lesser number of modules and connections can be utilized with the present invention in order to accomplish the present invention, to provide additional known features to the present invention, and\/or to make the present invention more efficient. Also, the information sent between various modules can be sent between the modules via at least one of a data network, the Internet, an Internet Protocol network, a wireless source, and a wired source and via plurality of protocols."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Reference will now be made, by way of example only, to specific embodiments and to the accompanying drawings in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
