---
title: A-Buffer compression for different compression formats
abstract: One embodiment of the present invention sets forth a technique for efficiently creating and accessing an A-Buffer that supports multi-sample compression techniques. The A-Buffer is organized in stacks of uniformly-sized tiles, wherein the tile size is selected to facilitate compression techniques. Each stack represents the samples included in a group of pixels. Each tile within a stack represents the set of sample data at a specific per-sample rendering order index that are associated with the group of pixels represented by the stack. Advantageously, each tile includes tile compression bits that enable the tile to maintain data using existing compression formats. As the A-Buffer is created, a corresponding stack compression buffer is also created. For each stack, the stack compression buffer includes a bit that indicates whether all of the tiles in the stack are similarly compressed and, consequently, whether the GPU may operate on the stack at an efficient per pixel granularity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08654135&OS=08654135&RS=08654135
owner: NVIDIA Corporation
number: 08654135
owner_city: Santa Clara
owner_country: US
publication_date: 20091209
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of co-pending U.S. patent application Ser. No. 12\/208,204, filed Sep. 10, 2008, hereby incorporated herein by reference.","1. Field of the Invention","The present invention relates generally to the field of graphics processing and, more specifically, to A-Buffer compression for two-color compression format.","2. Description of the Related Art","In conventional approaches for rendering an image, a graphics processing unit (GPU) determines a color associated with each pixel of the rendered image. The color of a pixel is determined based on sample data associated with one or more polygons covering the pixel, where each sample data corresponds to a different location within the image. For example, for a pixel that is covered by first and second objects and includes four sample data, one of the sample data may reflect the color of the first object, and three of the sample data may reflect the color of the second object. Color information from each of the four sample data may contribute to the color of the pixel using well-known techniques that improve image quality by, among other things, reducing edge artifacts in images. An example of such a technique is multi-sample anti-aliasing.","GPUs often increase the efficiency of operations such as multi-sample anti-aliasing by using a variety of compression techniques to reduce memory bandwidth and computational load. For example, if each of the four samples included in a particular pixel has one of two colors, then the GPU may determine that the pixel is compressible and may represent all four samples (i.e., the pixel) using the color information needed to represent only two colors. Further, the GPU groups proximally located pixels into an image tile for efficient processing. If all of the pixels included in an image tile are compressible, then the GPU determines that the image tile is compressible and represents the image tile using a reduced amount of color information. Reducing the data used to represent the pixels and image tiles reduces the memory bandwidth used when accessing the pixels and tiles in memory.","To manage a large amount of sample data, the GPU may generate an A-Buffer\u2014a memory structure that maintains sample data associated with each polygon that intersects the pixels of an image frame being rendered. Traditionally, an A-Buffer stores linked lists of the sample data, where each linked list is associated with different sample data corresponding to a different pixel. One drawback to storing sample data in an A-buffer is that compression techniques that are often implemented by GPUs to reduce memory bandwidth and increase efficiency cannot be supported in the A-Buffer due to the discrete nature of the A-Buffer.","As the foregoing illustrates, what is needed in the art is a more effective technique for creating and accessing an A-Buffer that can stored compressed sample data.","One embodiment of the present invention sets forth a method for storing in a graphics processing unit (GPU) memory pixel data associated with one or more pixels in an image. The method includes the steps of identifying within a buffer residing within the GPU memory a first stack associated with a first set of pixels included in the image, wherein each stack stored in the buffer is associated with a different set of pixels included in the image, populating a first tile included in the first stack with pixel data associated with a first subset of pixels included in the first set of pixels, wherein each tile included in the first stack stores pixel data associated with a different subset of pixels included in the first set of pixels, generating tile compression information associated with the first tile based on the pixel data associated with the first subset of pixels, wherein the tile compression information specifies a compression format used to compress the pixel data associated with the first subset of pixels and a compression state associated with each pixel in the first subset of pixels, and storing the tile compression information in the first tile.","One advantage of the disclosed method is that the compression information, including the compression format and the compression bits, in each tile allows the GPU to create a stack compression buffer indicating whether the tiles in a stack are all similarly compressible. Such a technique enables the GPU to fully utilize existing compression techniques that reduce memory bandwidth and increase computational efficiency. Consequently, the overall performance of the graphics pipeline is improved.","In the following description, numerous specific details are set forth to provide a more thorough understanding of the present invention. However, it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances, well-known features have not been described in order to avoid obscuring the present invention.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","100","160","102","150","110","120","152","102","120","160","120"]},"The system data bus  connects the CPU , the input devices , the system memory , and the graphics processing subsystem . In alternate embodiments, the system memory  may connect directly to the CPU . The CPU  receives user input from the input devices , executes programming instructions stored in the system memory , operates on data stored in the system memory , and configures the graphics processing subsystem  to perform specific tasks in the graphics pipeline. The system memory  typically includes dynamic random access memory (DRAM) used to store programming instructions and data for processing by the CPU  and the graphics processing subsystem . The graphics processing subsystem  receives instructions transmitted by the CPU  and processes the instructions in order to render and display graphics images on the display devices .","The system memory  includes an application program , an application programming interface (API) , high-level shader programs , and a graphics processing unit (GPU) driver . The application program  generates calls to the API  in order to produce a desired set of results, typically in the form of a sequence of graphics images. The application program  also transmits one or more high-level shading programs  to the API  for processing within the GPU driver . The high-level shading programs  are typically source code text of high-level programming instructions that are designed to operate on one or more shaders within the graphics processing subsystem . The API  functionality is typically implemented within the GPU driver . The GPU driver  is configured to translate the high-level shading programs  into machine code shading programs that are typically optimized for a specific type of shader (e.g., vertex, geometry, or fragment).","The graphics processing subsystem  includes a graphics processing unit (GPU) , a GPU local memory , and a GPU data bus . The GPU  is configured to communicate with the GPU local memory  via the GPU data bus . The GPU  may receive instructions transmitted by the CPU , process the instructions in order to render graphics data and images, and store these images in the GPU local memory . Subsequently, the GPU  may display certain graphics images stored in the GPU local memory  on the display devices .","The GPU  includes one or more streaming multiprocessors . Each of the streaming multiprocessors  is capable of executing a relatively large number of threads concurrently. Advantageously, each of the streaming multiprocessors  can be programmed to execute processing tasks relating to a wide variety of applications, including but not limited to linear and nonlinear data transforms, filtering of video and\/or audio data, modeling operations (e.g. applying of physics to determine position, velocity, and other attributes of objects), and so on. Furthermore, each of the streaming multiprocessors  may be configured as one or more programmable shaders (e.g., vertex, geometry, or fragment) each executing a machine code shading program (i.e., a thread) to perform image rendering operations. The GPU  may be provided with any amount GPU local memory , including none, and may use GPU local memory  and system memory  in any combination for memory operations.","The GPU local memory  is configured to include machine code shader programs , an A-Buffer , a stack compression buffer , and a frame buffer . The machine code shader programs  may be transmitted from the GPU driver  to the GPU local memory  via the system data bus . The machine code shader programs  may include a machine code vertex shading program, a machine code geometry shading program, a machine code fragment shading program, or any number of variations of each. The A-Buffer  may be used to store a collection of sample data associated with each polygon that intersects the pixels in an image frame that is being rendered for display. The stack compression buffer  may be used to store information related to the A-Buffer for purposes of compression. The frame buffer  stores data for at least one two-dimensional surface that may be used to drive the display devices . Furthermore, the frame buffer  may include more than one two-dimensional surface so that the GPU  can render to one two-dimensional surface while a second two-dimensional surface is used to drive the display devices .","The display devices  are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example, a display device may be built using a cathode ray tube (CRT) monitor, a liquid crystal display, or any other suitable display system. The input data signals to the display devices  are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","130","200","200","202","204","206","208","210","212","214","142"]},"The data assembly unit  is a fixed-function unit that collects vertex data from the application program  for high-order surfaces, primitives, and the like, and passes the vertex data to the vertex shader . The data assembly unit  may gather data from buffers stored within system memory  and the GPU local memory  as well as from API calls from the application program  used to specify vertex attributes. The vertex shader  is a programmable execution unit that is configured to execute a machine code vertex shading program, processing vertex data as specified by the vertex shading program. For example, the vertex shader  may be programmed to transform the vertex data from an object-based coordinate representation (object space) to an alternatively based coordinate system such as world space or normalized device coordinates (NDC) space. The vertex processing unit  may access data that is stored in GPU local memory .","The primitive assembly unit  is a fixed-function unit that receives processed vertex data from vertex shader  and constructs graphics primitives, e.g., points, lines, triangles, or the like, for processing by the geometry shader . In alternative embodiments, a second primitive assembler (not shown) may be included subsequent to the geometry shader  in the data flow through the GPU . The geometry shader  is a programmable execution unit that is configured to execute a machine code geometry shading program, processing graphics primitives received from the primitive assembly unit  as specified by the geometry shading program. For example, in addition to well-known per-primitive operations such as clipping, the geometry shader  may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters, such as plane equation coefficients, that are used when the new graphics primitives are rasterized. The geometry shader  may access data that is stored in the GPU local memory . The geometry shader  outputs the parameters and new graphics primitives to the rasterizer .","The rasterizer  is a fixed-function unit that scans the new graphics primitives and outputs fragments, each containing fragment data, which may include raster position or interpolated vertex attributes, such as texture coordinates and opacity, to the fragment shader .","The fragment shader  is a programmable execution unit that is configured to execute a machine code fragment shading program, processing fragments received from rasterizer  as specified by the machine code fragment shading program. For example, the fragment shader  may be programmed to perform operations such as perspective correction, shading, blending, and the like, to produce shaded fragments that are output to the raster operations unit . The fragment shading engine  may access data that is stored in buffers in the GPU local memory , such as the A-Buffer  and the stack compression buffer . The raster operations unit  optionally performs fixed-function computations such as near and far plane clipping and raster operations, such as stencil, z test, blending and the like, and outputs pixel data as processed graphics data for storage in a buffer in the GPU local memory , such as the A-Buffer  or the frame buffer . Together, the rasterizer , the fragment shader  and the raster operations unit  represent the fragment processing domain of the GPU , where the raster operations unit  may be used to operate on individual pixels or small squares of pixels, and the fragment shader  may be programmed to iterate across groups of pixels. Further, the fragment shader  and the raster operations unit  may be configured to treat samples as pixels.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3A","FIG. 1"],"b":["144","310","310","310"]},"As shown in detail for the array -S-,T-, each of the stacks  may be subdivided into any number of two-dimensional tiles . The size of the tiles , and consequently the size of the group of pixels represented by each stack , may be chosen by the designer and may be uniform across the A-Buffer . The size of the tiles  in conjunction with the size of the image frame may determine the number of the stacks  in the A-Buffer . Suppose, for example, that a tile size of eight-by-four samples is chosen and that each pixel includes four samples, arranged in a two-by-two configuration. And, suppose the size of a given image frame is eight-by-four pixels. The pixels in the image frame may be divided into four subsets of four-by-two pixels, and the A-Buffer  may be configured to include four stacks  of eight-by-four tiles , each tile  including eight pixels represented by thirty-two samples. In other embodiments, the tile size may be chosen to be more or less than eight-by-four, and the number of stacks  in the A-Buffer  may be more or less than four. Furthermore, the tiles may be chosen to be the units of compression and, consequently, the size of the tiles  may be chosen in any technically feasible fashion to facilitate various compression techniques.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 3B","FIG. 3A","FIG. 3B"],"b":["320","144","320","330","310","330","340","330","340","320","340","320"]},"Each tile  may be further configured to include only sample data  at a given per-sample rendering order index (PSROI). In such a configuration, the tiles  included in a given stack  may, together, represent all of the sample data  associated with the N-by-M group of pixels represented by the stack , where each of the tiles  represents the subset of the sample data  at a particular PSROI. As set forth in greater detail herein, organizing the sample data  in such a manner, by both PSROI and associated pixel proximity, optimizes the locality of memory accesses.","Referring back now to , the number of tiles  in each stack  may differ. Since each of the tiles  corresponds to a specific PSROI, the number of tiles  in a given stack  corresponds to the maximum depth complexity associated with any of the samples represented by the stack . For example, if a given stack  were to represent samples having two different per-sample rendering order indices, such as indices zero and one, then the stack  would include two tiles  that include one or more sample data  at each of these two indices. Similarly, if a given stack  were to include three tiles , then the stack  would include sample data  at three different PSROI, such as indices zero, one, and two. The GPU  is configured to assign tiles to each of the stacks , calculating the maximum depth complexity associated with the F*N-by-G*M group of samples represented by a particular stack  to determine the appropriate number of tiles to allocate for that stack .","When populating the A-Buffer  with sample data , the GPU  is configured to optimally pack the sample data  by allowing the set of sample data  included in each pixel data  to represent the intersection of one or more polygons with that particular pixel. Suppose, for example, each pixel includes four samples and four polygons intersect a particular pixel. If each polygon covers a different one of the samples included in the pixel, then the PSROI for each of the four samples would be one. And, the GPU  may configure a single pixel data included in a single tile included in the A-Buffer to represent the intersection of all four polygons with this particular pixel.","As shown in detail in , each tile  also includes tile compression information  reflecting any technically feasible compression format that is supported by the GPU . The tile compression information  indicates whether the sample data  is stored in a compressed form and, if so, the specific compression format to which the sample data  is compressed.","As is well-known, accessing a compressed tile typically involves transferring less data than accessing an uncompressed tile. Consequently, the memory bandwidth used to access compressed tiles included in the A-Buffer  is usually less than the memory bandwidth used to access uncompressed tiles included in the A-Buffer . In alternate embodiments, the tiles may not include the tile compression bits, and the tile compression bits may be stored in another location that is accessible by the GPU. In other embodiments, the A-Buffer may not support compressed tiles and, consequently, the tile compression bits may not exist.","Although any number of the tiles  included in the A-Buffer  may be compressed in various embodiments, the computing system  is configured to ensure that the A-Buffer  is large enough to store all of the tiles  included in the A-Buffer  in an uncompressed fashion. Again, the computing system  determines the structure of the A-Buffer  by the size and complexity of each image frame. In one embodiment, the CPU  preallocates a fixed-size buffer. If the size of the A-Buffer  for a given image frame turns out to be larger than the size of the fixed-size buffer, then the CPU  subdivides the image frame into image subsets. The CPU  ensures that each image subset fits within the preallocated fixed-size buffer and then configures the GPU  to process each image subset separately. In alternative embodiments, the GPU may reallocate the A-Buffer for each image frame, allocating only enough memory to store the A-Buffer specific to the image frame.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 4","FIG. 3B"],"b":["350","350","402","404","320","402","320","404","320","402","320","404","404","130"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 5","FIG. 3A"],"b":["360","144","360","370","144","370","370","144","360","144","370"]},"As part of determining the structure of the A-Buffer , the GPU  receives pixel writes indicating the intersection of polygons associated with the various graphics objects in an image frame with the pixels, expands the pixel writes into sample writes, and, for each covered sample, increments the PSROI associated with the covered sample. In this fashion, the GPU  configures the maximum PSROIs  to represent the maximum rendering order index of every sample in a particular image frame. Subsequently, for each stack , the GPU  determines the maximum of the subset of maximum PSROIs  that correspond to the subset of samples represented by the stack . For each stack , this stack-specific maximum maximum PSROI determines the number of tiles  that the GPU  allocates for the stack . As will be clear to one skilled in the art, operations on the depth complexity image itself may also be compressed in accordance with existing techniques.","The GPU  typically, but not necessarily, uses the fragment shader  to create the sample depth complexity images  and to determine the structure of the A-Buffer . Subsequently, the GPU  may use either the raster operations unit  or the fragment shader  to populate and access the A-Buffer . The raster operations unit  may be more efficient at performing some A-Buffer  operations; however, since the fragment shader  may execute a machine code geometry shading program, the fragment shader  may be more flexible.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 6A","FIG. 3A"],"b":["146","144","146","410","310","144","310","410","130","320","310"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 6B","FIG. 6A"],"b":["146","410","310","420","320","310","320","310","130","310","420","130","310"]},"The stack compression bits  associated with a particular stack  also include per-sample compression bits  that store the compression state of each sample included in the pixels of the first tile stored in the stack . In addition, the stack compression bits  associated with a particular stack  also include an N-by-M set of pixel coverage masks , selected and arranged to correspond to the N-by-M group of pixels represented by the stack . Each pixel coverage mask  includes an F-by-G set of sample bits . The set of sample bits  includes a separate sample bit  for each sample included in the pixel. In the example of , each pixel includes four samples arranged in a two-by-two array. Consequently, each pixel coverage mask  also includes four sample bits  arranged in a two-by-two array. For each pixel coverage mask , the included sample bits  indicate a specific coverage of the corresponding pixel on a per sample basis. For example, the sample bits  included in a particular pixel coverage mask  may be set to the same value, indicating that all of the samples included in the corresponding pixel are covered by the same polygon.","In some embodiments, the per-sample compression bits  and the set of pixel coverage masks  included in the stack compression bits  are evaluated only when the \u201call compressed\u201d bit  is set to true. When the \u201call compressed\u201d bit  is set to true, compression bits  within the compression information  of each of the tiles  included in the stack  corresponding to the stack compression bits  is the same, matching the per-sample compression bits  stored in the stack compression bits . Similarly, the sample coverage of each of the tiles  included in the stack  corresponding to the stack compression bits  is the same, matching the sample bits  in the set of pixel coverage masks .","While populating the A-Buffer , the GPU  also populates the stack compression buffer . When the GPU  writes the first tile  to a particular stack , the GPU  initializes the stack compression bits  corresponding to the stack . If the first tile  in a particular stack  is compressed, as indicated by the tile compression information , then the GPU  sets the \u201call compressed bit\u201d  to true. The GPU  also sets the per-sample compression bits  to the compression bits  included in the tile . In addition, the GPU  initializes the set of pixel coverage masks  to depict the coverage of the samples included in the first tile  in the stack . Subsequently, as the GPU  adds each additional tile  to the stack , if the GPU  determines that the additional tile  and the first tile in the stack  are not similarly compressed, then the GPU  sets the \u201call compressed bit\u201d  to false.","In operation, a particular tile  included in a particular stack , and the first tile  included in the stack  are similarly compressed when two criteria are met. The first criterion is that both of the tiles  are compressed in the same fashion. The GPU  makes this determination by comparing the compression bits  within the tile compression information  included in the particular tile  to the per-sample compression bits  within the stack compression bits . The second criterion is that the per sample coverage of the tiles  match. In other words, the coverage of each sample included in the particular tile  should match the coverage of the corresponding sample included in the first tile . The GPU  makes this second determination by comparing the sample coverage of the particular tile  to the set of pixel coverage masks  associated with the stack .","In alternative embodiments, the stack compression buffer may include an \u201call compressed\u201d bit corresponding to each stack in the A-Buffer and the per-sample compression bits , but may not include pixel coverage masks. In such an embodiment, the GPU may determine that all of the tiles in a particular stack are similarly compressed when all of the tiles included in the stack are compressed in the same fashion (i.e., the compression bits  included in the tiles are the same).","Again, the GPU  may use either the raster operations unit  or the fragment shader  to populate and access the stack compression buffer . In alternative embodiments, the information in the stack compression buffer may be stored in any technically feasible fashion using any number and type of data structures. In other embodiments, the GPU may not maintain any stack compression information in conjunction with the A-Buffer and, consequently, the stack compression buffer may not exist.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 7","FIG. 1","FIGS. 1-6B"],"b":["144","146"]},"The method  begins at step , where the GPU  receives an image subset consisting of an entire image frame and a compression-efficient tile size, F*N-by-G*M. As described above in conjunction with , the tile size corresponds to the size of the group of samples represented by each of the stacks  in the A-Buffer . At step , the raster operations unit  creates a sample depth complexity image  by calculating the maximum rendering order index for each sample included in the image subset. A series of method steps for calculating a sample depth complexity image  is described in greater detail below in .","At step , the fragment shader  calculates the maximum PSROI for each stack  in the A-Buffer  based on the sample depth complexity image . More specifically, the fragment shader  divides the sample depth complexity image  into F*N-by-G*M groups of maximum PSROIs , where F*N-by-G*M is the tile size received in step . As part of step , the fragment shader  assigns each F*N-by-G*M group of samples to a specific stack  in the A-Buffer . Also as part of step , the fragment shader  evaluates the maximum PSROI  of each of the samples associated with each of the F*N-by-G*M groups of samples and determines a single maximum maximum per-sample rendering order index for each F*N-by-G*M group of samples. The single maximum maximum PSROI defines the number of tiles  assigned to the stack  in the A-Buffer  associated with the F*N-by-G*M group of samples.","At step , the CPU  or the GPU  calculates the total number of tiles  in the A-Buffer . In one embodiment, the CPU sums the total number of tiles  assigned to each of the stack  in the A-Buffer  to determine the total number of tiles  in the A-Buffer . At step , if the CPU  or the GPU  determines that the size of the A-Buffer  is not supported by a preallocated, fixed-sized buffer, then the method  proceeds to step . The determination of whether the size of the A-Buffer  is supported by the preallocated, fixed-size buffer may be made in any technically feasible fashion. For example, the total number of tiles required to represent the A-Buffer may be compared with the total number of tiles that may be represented using the preallocated, fixed-size buffer. At step , the CPU  alters the image subset (e.g., the CPU may halve the image subset), and the method  returns to step . The method  continues in this fashion, looping through steps -, until an image subset is identified that fits in the preallocated, fixed-size buffer reserved for the A-Buffer structure.","If, at step , the CPU  or the GPU  determines that the size of the A-Buffer  is supported by the preallocated, fixed-size buffer, then the method  proceeds to step . At step , the fragment shader  or the raster operations unit  populates the preallocated A-Buffer  and the associated stack compression buffer  using the various sample data associated with the image subset, as described herein, and the method  terminates.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 8","FIG. 5","FIGS. 1-6B"],"b":["360","214","212","214","214"]},"As shown, the method  begins at step , where the raster operations unit  initializes the sample depth complexity image  by setting all of the maximum PSROIs  included in the sample depth complexity image  to zero. At step , the raster operations unit  receives a write to a target pixel. At step , the raster operations unit  selects the first covered sample in the target pixel. The raster operations unit  may order the samples in any technically feasible fashion, such as primarily by X-coordinates and secondarily by Y-coordinates. At step , the raster operations unit  increments the maximum PSROI  associated with the selected sample. At step , if the raster operations unit  determines that the selected sample is not the last covered sample included in the target pixel, then the method  proceeds to step .","At step , the raster operations unit  selects the next covered sample in the target pixel, and the method  returns to step , where the raster operations unit  increments the maximum PSROI  associated with the selected sample. The method  continues in this fashion, looping through steps -, until the raster operations unit  increments each of the sample depth complexities  that are associated with a covered sample in the target pixel.","If, at step , the raster operations unit  determines that the selected sample is the last covered sample in the target pixel, then the method  proceeds to step . At step , if the raster operation unit  determines that there are more pixel writes, then the method  returns to step , where the raster operations unit  receives a pixel write to a target pixel. The method  continues in this fashion, looping through steps -, until the raster operations unit  receives all of the pixel writes and reflects the pixel writes in the sample depth complexity image .",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 9","FIG. 1","FIGS. 1-6B"],"b":["144","214","212","214","214"]},"As shown, the method  begins at step , where the raster operations unit  receives a compressed write to a target tile of pixels. At step , the raster operations unit  determines the A-Buffer stack index and identifies the stack  associated with the stack index and included in the A-Buffer . The raster operations unit  may determine the two-dimensional stack index in any technically feasible fashion. For example, the raster operations unit may use the tile size of the A-Buffer to calculate the stack index using integer division operations. At step , the raster operations unit  determines the tile index within the identified stack  and identifies the tile  associated with the tile index and included in the identified stack . The raster operations unit  may determine the one-dimensional tile index in any technically feasible fashion. For example, the raster operations unit may maintain an index for each stack that indicates the index of the next unpopulated tile, and the raster operations unit may set the tile index to match the index of the next unpopulated tile for the identified stack.","At step , the raster operations unit  populates the identified tile  using the data received during the compressed write. As part of step , the raster operations unit  updates the tile compression information  included in the identified tile  to reflect the compression format for the identified tile . At step , the raster operations unit  identifies the stack compression bits  included in the stack compression buffer  and associated with the stack index. At step , if the raster operations unit  determines that the tile index equals zero (i.e., the identified tile  is the first tile  in the identified stack ), then the method  proceeds to step .","At step , the raster operations unit  sets the \u201call compressed\u201d bit  included in the identified stack compression bits  to true. In other words, the raster operations unit  sets the \u201call compressed\u201d bit  included in the identified stack compression bits  to indicate that the single tile  in the identified stack  is compressed. At step , the raster operations unit  sets the per-sample compression bits  included in the identified stack compression bits  to the compression bits  included in the compression information  of the identified tile , and the method  terminates.","If, at step , the raster operations unit  determines that the tile index does not equal zero (i.e., the identified tile  is not the first tile  in the identified stack ), then the method  proceeds to step . At step , if the raster operations unit  determines that the value of the \u201call compressed\u201d bit  included in the identified stack compression bits  is not equal to true, then the method  terminates. If, at step , the raster operations unit  determines that the value of the \u201call compressed\u201d bit  included in the identified stack compression bits  is equal to true, then the method  proceeds to step .","At step , the raster operations unit  determines whether the compression bits  included in the identified tile  match the per-sample compression bits  included in the identified stack . In such a fashion, the raster operations unit  determines whether the identified tile  is compressed in a similar manner as all of the previous tiles  in the identified stack . As previously described herein, the compression bits  included in the identified tile  indicate the compression state of each pixel within the tile  and\/or each sample included in the pixels within the tile . For example, if each sample included in each of the pixels has one of two colors, the compression bits store one bit for each sample, indicating which of the two colors is correct for that sample.","At step , if the per-sample compression bits  and the compression bits  do not match, then the identified tile  is not compressed in the same manner as all of the previous tiles  included in the identified stack  and the method proceeds to step . At step , the raster operations unit  sets the \u201call compressed\u201d bit  included in the identified stack compression bits  to false, and the method  terminates.","If, at step , the per-sample compression bits  and the compression bits  do match, then the identified tile  is compressed in the same manner as all of the previous tiles  included in the identified stack  and the \u201call compressed\u201d bit  remains set to true. The method  then terminates.","In sum, image rendering performance may be improved by using an A-Buffer structure that allows sample data to be stored in a way that increases the memory locality and supports existing compression techniques. The A-Buffer is organized in three-dimensional stacks of uniformly-sized two-dimensional rectangular tiles, each stack representing a group of pixels and the samples included in the group of pixels. Each tile in a given stack includes the set of sample data associated with the group of pixels represented by the stack and also includes tile compression bits.","For a particular tile, the tile compression information may specify a tile compression format that is supported by the GPU and compression bits indicating the compression status of each pixel in the tile and\/or of each sample within the pixels in the tile. In one embodiment, the compression format may specify a compression format that allows a two color compression scheme where two colors are stored for each pixel represented by the tile. For such a compression scheme, the compression bits store one bit for each sample included in each of the pixels, indicating which of the two colors is correct for that sample.","Further, during A-Buffer creation, a corresponding stack compression buffer is created. For each stack in the A-Buffer, the stack compression buffer includes an \u201call compressed\u201d bit that indicates whether all of the tiles in the stack are similarly compressed. If the tile compression bits associated with all the tiles in a particular stack are the same, then the \u201call compressed\u201d bit is set to true. The \u201call compressed\u201d bit may be used by the GPU to determine whether to operate on the data included in a particular stack on a more efficient per pixel basis or a less efficient per sample basis.","Advantageously, the compression information, including the compression format and the compression bits, in each tile allows the GPU to create a stack compression buffer indicating whether the tiles in a stack are all similarly compressible. Such a technique enables the GPU to fully utilize existing compression techniques that reduce memory bandwidth and increase computational efficiency. Consequently, the overall performance of the graphics pipeline is improved.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example, aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored. Such computer-readable storage media, when carrying computer-readable instructions that direct the functions of the present invention, are embodiments of the present invention.","Therefore, the scope of the present invention is determined by the claims that follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3A","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3B","FIG. 3A"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 4","FIG. 3B"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 3A"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6A","FIG. 3A"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 7","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 8","FIG. 5"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 9","FIG. 1"]}]},"DETDESC":[{},{}]}
