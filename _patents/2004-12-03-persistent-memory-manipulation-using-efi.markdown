---
title: Persistent memory manipulation using EFI
abstract: Systems, methodologies, media, and other embodiments associated with performing a manipulation of a persistent memory using an extensible firmware interface are described. One exemplary method embodiment includes selectively refreshing a persistent memory from an EFI level application and providing to a user level application a signal concerning the persistent memory refreshing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07574593&OS=07574593&RS=07574593
owner: Hewlett-Packard Development Company, L.P.
number: 07574593
owner_city: Houston
owner_country: US
publication_date: 20041203
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":[{"@attributes":{"id":"p-0002","num":"0001"},"figref":"FIG. 1","b":["100","110","120","130","110","100","100","130","120","100","130"]},"At one point in time, system  may have included a BIOS  stored in a ROM (Read Only Memory). In this example, changing the BIOS  (e.g., installing new version), may have involved manually removing the ROM in which the BIOS  was stored and installing a new ROM. This required some technical skill and required the system  to be turned off and on.","At a later point in time, system  may have included a BIOS  stored in an EEPROM (Electrically Erasable Programmable ROM). An EEPROM is a type of PROM (Programmable ROM) that can be erased by exposing it to an electrical charge. The PROM may then be reprogrammed. Like other ROMs, an EEPROM may retain its contents when power to a system is turned off, which makes it suitable for storing a BIOS. In this example, changing the BIOS  may have included electrically erasing the PROM in which the BIOS  was stored and reprogramming it. In one example, this may have involved removing the PROM and reburning it. In another example, this may have involved reprogramming the PROM without removing it from system . However, reprogramming a PROM may have included writing the PROM byte-by-byte, which could be a time-consuming process. Even in an EEPROM based system, changing a BIOS  may have required technical skill and may have required a system to be turned off and on manually.","Recently is has become popular to store a BIOS associated with a computing system in a flash memory. Flash memory is a type of EEPROM that can be erased and reprogrammed in block sized amounts rather than byte by byte, thus making it typically faster to reprogram than a traditional EEPROM. When a BIOS is stored in a flash memory, it may be referred to as a flash BIOS. Also recently, in attempts to update boot processing, an interface between operating systems and platform firmware has developed. One example interface is the EFI (Extensible Firmware Interface), which includes, for example, data tables containing platform related information, boot services, runtimes services available to an operating system, an operating system loader, and so on. The EFI attempts to provide a standard environment for booting an operating system and\/or running pre-boot applications.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2","b":["200","220","230","210","240","220","210","230","220","230"]},"Example systems and methods described herein concern refreshing system firmware stored in a reprogrammable persistent memory. The refreshing may be initiated by a user level process that interacts with a firmware interface like EFI. The system firmware may be, for example, a BIOS and may be stored in a persistent memory like a flash memory. The persistent memory may be stored, for example, on a motherboard, a cell board, a node board, and so on. The user level process and firmware interface may interact, for example, by communicating parameters, error codes, and so on, through firmware interface variables (e.g., EFI variables) that are visible to both user level processes and EFI level processes.","Rather than manually removing a chip in which a BIOS is stored, or invoking an EFI shell and performing various technical tasks, a user may initiate a firmware refresh from a user level application. The user level application may be tasked, for example, with examining a current firmware associated with the system, determining whether a different (e.g., improved, more recent) firmware is available for the system, and communicating firmware refresh data to an EFI level application. The user level application may invoke an EFI level application that can reconfigure the EFI by, for example, establishing an update tool as an application to be run by a booting EFI. The update tool may include and\/or be configured to locate the firmware with which the reprogrammable persistent memory is to be refreshed. Pre-boot actions taken by the EFI may, therefore, locate and run the update tool, which in turn will attempt to reprogram the persistent memory with the desired firmware. Success or failure can be reported back to the user application through EFI variables.","The following includes definitions of selected terms employed herein. The definitions include various examples and\/or forms of components that fall within the scope of a term and that may be used for implementation. The examples are not intended to be limiting. Both singular and plural forms of terms may be within the definitions.","As used in this application, the term \u201ccomputer component\u201d refers to a computer-related entity, either hardware, firmware, software, a combination thereof, or software in execution. For example, a computer component can be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and a computer. By way of illustration, both an application running on a server and the server can be computer components. One or more computer components can reside within a process and\/or thread of execution and a computer component can be localized on one computer and\/or distributed between two or more computers.","\u201cComputer communication\u201d, as used herein, refers to a communication between two or more computing devices (e.g., computer, personal digital assistant, cellular telephone) and can be, for example, a network transfer, a file transfer, an applet transfer, an email, a hypertext transfer protocol (HTTP) transfer, and so on. A computer communication can occur across, for example, a wireless system (e.g., IEEE 802.11, IEEE 802.15), an Ethernet system (e.g., IEEE 802.3), a token ring system (e.g., IEEE 802.5), a local area network (LAN), a wide area network (WAN), a point-to-point system, a circuit switching system, a packet switching system, combinations thereof, and so on.","\u201cComputer-readable medium\u201d, as used herein, refers to a medium that participates in directly or indirectly providing signals, instructions and\/or data. A computer-readable medium may take forms, including, but not limited to, non-volatile media, and volatile media. Non-volatile media may include, for example, optical or magnetic disks, and so on. Volatile media may include, for example, optical or magnetic disks, dynamic memory and the like. Common forms of a computer-readable medium include, but are not limited to, a floppy disk, a flexible disk, a hard disk, a magnetic tape, other magnetic media, a CD-ROM, other optical media, punch cards, paper tape, other physical media with patterns of holes, a RAM, a ROM, an EPROM, a FLASH-EPROM, or other memory chip or card, a memory stick, and other media from which a computer, a processor or other electronic device can read.","\u201cData store\u201d, as used herein, refers to a physical and\/or logical entity that can store data. A data store may be, for example, a database, a table, a file, a list, a queue, a heap, a memory, a register, and so on. A data store may reside in one logical and\/or physical entity and\/or may be distributed between two or more logical and\/or physical entities.","\u201cLogic\u201d, as used herein, includes but is not limited to hardware, firmware, software and\/or combinations of each to perform a function(s) or an action(s), and\/or to cause a function or action from another logic, method, and\/or system. For example, based on a desired application or needs, logic may include a software controlled microprocessor, discrete logic like an application specific integrated circuit (ASIC), a programmed logic device, a memory device containing instructions, or the like. Logic may include one or more gates, combinations of gates, or other circuit components. Logic may also be fully embodied as software. Where multiple logical logics are described, it may be possible to incorporate the multiple logical logics into one physical logic. Similarly, where a single logical logic is described, it may be possible to distribute that single logical logic between multiple physical logics.","An \u201coperable connection\u201d, or a connection by which entities are \u201coperably connected\u201d, is one in which signals, physical communications, and\/or logical communications may be sent and\/or received. Typically, an operable connection includes a physical interface, an electrical interface, and\/or a data interface, but it is to be noted that an operable connection may include differing combinations of these or other types of connections sufficient to allow operable control. For example, two entities can be operably connected by being able to communicate signals to each other directly or through one or more intermediate entities like a processor, operating system, a logic, software, or other entity. Logical and\/or physical communication channels can be used to create an operable connection.","\u201cSignal\u201d, as used herein, includes but is not limited to one or more electrical or optical signals, analog or digital signals, data, one or more computer or processor instructions, messages, a bit or bit stream, or other means that can be received, transmitted and\/or detected.","\u201cSoftware\u201d, as used herein, includes but is not limited to, one or more computer or processor instructions that can be read, interpreted, compiled, and\/or executed and that cause a computer, processor, or other electronic device to perform functions, actions and\/or behave in a desired manner. The instructions may be embodied in various forms like routines, algorithms, modules, methods, threads, and\/or programs including separate applications or code from dynamically and\/or statically linked libraries. Software may also be implemented in a variety of executable and\/or loadable forms including, but not limited to, a stand-alone program, a function call (local and\/or remote), a servelet, an applet, instructions stored in a memory, part of an operating system or other types of executable instructions. It will be appreciated by one of ordinary skill in the art that the form of software may depend, for example, on requirements of a desired application, the environment in which it runs, and\/or the desires of a designer\/programmer or the like. It will also be appreciated that computer-readable and\/or executable instructions can be located in one logic and\/or distributed between two or more communicating, co-operating, and\/or parallel processing logics and thus can be loaded and\/or executed in serial, parallel, massively parallel and other manners.","Suitable software for implementing the various components of the example systems and methods described herein may be produced using programming languages and tools like Java, Pascal, C#, C++, C, CGI, Perl, SQL, APIS, SDKS, assembly, firmware, microcode, and\/or other languages and tools. Software, whether an entire system or a component of a system, may be embodied as an article of manufacture and maintained or provided as part of a computer-readable medium as defined previously. Another form of the software may include signals that transmit program code of the software to a recipient over a network or other communication medium. Thus, in one example, a computer-readable medium has a form of signals that represent the software\/firmware as it is downloaded from a web server to a user. In another example, the computer-readable medium has a form of the software\/firmware as it is maintained on the web server. Other forms may also be used.","\u201cUser\u201d, as used herein, includes but is not limited to one or more persons, software, computers or other devices, or combinations of these.","Some portions of the detailed descriptions that follow are presented in terms of algorithms and symbolic representations of operations on data bits within a memory. These algorithmic descriptions and representations are the means used by those skilled in the art to convey the substance of their work to others. An algorithm is here, and generally, conceived to be a sequence of operations that produce a result. The operations may include physical manipulations of physical quantities. Usually, though not necessarily, the physical quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in a logic and the like.","It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like. It should be borne in mind, however, that these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, it is appreciated that throughout the description, terms like processing, computing, calculating, determining, displaying, or the like, refer to actions and processes of a computer system, logic, processor, or similar electronic device that manipulates and transforms data represented as physical (electronic) quantities.","Example methods may be better appreciated with reference to the flow diagrams of ,  and . While for purposes of simplicity of explanation, the illustrated methodologies are shown and described as a series of blocks, it is to be appreciated that the methodologies are not limited by the order of the blocks, as some blocks can occur in different orders and\/or concurrently with other blocks from that shown and described. Moreover, less than all the illustrated blocks may be required to implement an example methodology. Furthermore, additional and\/or alternative methodologies can employ additional, not illustrated blocks.","In the flow diagrams, blocks denote \u201cprocessing blocks\u201d that may be implemented with logic. The processing blocks may represent a method step and\/or an apparatus element for performing the method step. A flow diagram does not depict syntax for any particular programming language, methodology, or style (e.g., procedural, object-oriented). Rather, a flow diagram illustrates functional information one skilled in the art may employ to develop logic to perform the illustrated processing. It will be appreciated that in some examples, program elements like temporary variables, routine loops, and so on, are not shown. It will be further appreciated that electronic and software applications may involve dynamic and flexible processes so that the illustrated blocks can be performed in other sequences that are different from those shown and\/or that blocks may be combined or separated into multiple components. It will be appreciated that the processes may be implemented using various programming approaches like machine language, procedural, object oriented and\/or artificial intelligence techniques.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":"300"},"Thus, method  may include, at , receiving a first signal in an extensible firmware interface (EFI) level logic configured to operate at a pre-boot time without operating system support. A computing system may have executables that are configured to operate at various logical levels. For example, an EFI level may exist below an operating system level and a user level. The EFI level may be programmed to operate at a time before an operating system has been loaded, which may be referred to as a pre-boot time. An operating system level may exist between the EFI level and the user level. The operating system may facilitate user level logics interacting with system resources, and so on. A user level may exist above the operating system and EFI level. Typically a user level logic would not communicate, directly and\/or indirectly, with an EFI level logic. Additionally, EFI operations are conventionally performed from an EFI shell and not from a user level logic.","The first signal may be received from a user level logic configured to operate at a post-boot time with operating system support. The first signal may be an indication to manipulate a persistent memory operably connected to a system configured with the EFI level logic and the user level logic. In one example, the first signal may be provided to the EFI level logic by the user level logic through an EFI variable. EFI variables may be visible to user level logics, operating system processes, EFI level logics, and so on, thus making them candidates for transferring information between the various levels. Information that may be transferred between the user level logic and the EFI level logic by the first signal may include, for example, an identifier of a first system firmware stored in a persistent memory to be manipulated, an identifier of a second system firmware to replace the first system firmware, an identifier of a persistent memory to manipulate, an identifier of an extensible firmware interface (EFI) level pre-boot process to employ to manipulate the persistent memory, and an identifier of a location of the second system firmware. Thus, the user level logic may specify that a certain version of an update process is to be tasked with replacing an existing BIOS in a certain persistent memory with a replacement BIOS stored somewhere on a computing system. Therefore it is to be appreciated that various examples of the example systems and methods described herein may be employed in computing system configurations including, but not limited to, single processor\/single persistent memory\/single BIOS systems, multiple processor\/multiple persistent memory\/multiple BIOS systems, and so on.","The persistent memory may be configured to store a system firmware like a BIOS. Thus, a user level logic may examine a system firmware stored in the persistent memory and determine that a newer version is desired and should be installed. Rather than undertaking conventional actions like pulling the chip or using an EFI shell approach to update the system firmware, the user level logic may communicate information designed to control the EFI level logic to automatically manipulate (e.g., replace) the existing system firmware with a newer version of the system firmware.","Thus, method  may include, at , selectively manipulating, from the EFI level logic, the persistent memory. Example actions associated with manipulating the persistent memory are described in connection with .","Method  may also include, at , providing, from the EFI level logic, to the user level logic, a second signal concerning the manipulating of the persistent memory. The second signal may be, for example, an error code, a success code, a code that identifies the current system firmware that was installed in the persistent memory, and so on. Thus, information typically provided to an EFI shell layer may be made available to a user level logic. Like the first signal may be provided form the user level logic to the EFI level logic through an EFI variable, the second signal may also be provided to the user level logic from the EFI level logic through an EFI variable.","In one example, methodologies are implemented as processor executable instructions and\/or operations provided on a computer-readable medium. Thus, in one example, a computer-readable medium may store processor executable instructions operable to perform a method that includes receiving, in an EFI level logic configured to run at a pre-boot time without operating system support, from a user level logic configured to run at a post-boot time with operating system support, through an EFI variable, a first signal to manipulate a flash memory operably connected to a system configured with the EFI level logic and the user level logic. The first signal may include data including, but not limited to, for example, an identifier of a first BIOS stored in a flash memory, an identifier of a second BIOS to replace the first BIOS, an identifier of a flash memory to manipulate, an identifier of an EFI level process to employ to manipulate the flash memory, and an identifier of a location of the second BIOS. The method may also include selectively manipulating the flash memory from the EFI level and, in response to manipulating the flash memory, providing, from the EFI level logic, to the user level logic, through an EFI variable, a second signal concerning the manipulating of the flash memory. In view of the various and alternative processes of method  described above, it will be appreciated that one embodiment of method  may include receiving, in an extensible firmware interface (EFI) level logic configured to operate at a pre-boot time without operating system support, from a user level logic configured to operate at a post-boot time with operating system support, a first signal to manipulate a persistent memory operably connected to a system configured with the EFI level logic and the user level logic, the persistent memory being configured to store a system firmware; selectively manipulating , from the EFI level logic, the persistent memory; and providing , from the EFI level logic, to the user level logic, a second signal concerning the manipulating of the persistent memory. Another embodiment of method  may include receiving, in an extensible firmware interface (EFI) level logic configured to run at a pre-boot time without operating system support, from a user level logic configured to run at a post-boot time with operating system support, through an EFI variable, a first signal to manipulate a flash memory operably connected to a system configured with the EFI level logic and the user level logic, the first signal including one or more of, an identifier of a first Basic Input Output System (BIOS) stored in a flash memory, an identifier of a second BIOS to replace the first BIOS, an identifier of a flash memory to manipulate, an identifier of an EFI level process to employ to manipulate the flash memory, and an identifier of a location of the second BIOS; selectively manipulating  the flash memory from the EFI level logic; and providing , from the EFI level logic, to the user level logic, through an EFI variable, a second signal concerning the manipulating of the flash memory.","While the above method is described being provided on a computer-readable medium, it is to be appreciated that other example methods described herein can also be provided on a computer-readable medium.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4","b":["440","430","400","440","440","430"]},"The communication logic  may be configured to receive the signal through an EFI . The signal may be received from a user level logic  that is configured to run at a post-boot time with operating system support. In one example, the user level logic  may be configured to run automatically, without the input of user, thus facilitating remote updating of systems. In another example the user level logic  may present a graphical user interface to a user displaying information like information about a BIOS currently installed in the system, information about a BIOS that is available to replace the currently installed BIOS, and so on. Thus, the system may facilitate online and\/or telephone based support for less sophisticated users.","The communication logic  may also be configured to provide a response to the user level logic  concerning the manipulation of the persistent memory . For example, the communication logic  may report on the success\/failure of an update of the system firmware .","The system may also include an update logic  that is operably connected to the communication logic . The update logic  may be configured to selectively manipulate the persistent memory  as part of an EFI pre-boot process. For example, when a system is booted, a mounted EFI partition may provide various pre-boot processes that can run before an operating system is loaded. One of these pre-boot processes may interact with the update logic  and be tasked with manipulating persistent memory . For example, a system firmware  stored in persistent memory  may be replaced by a more up-to-date firmware.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIG. 4","FIG. 5"],"b":["540","530","510","500","550","500","520","510","500","520","510"]},"In addition to these elements, the system may also include a mountable EFI system partition  that is accessible to the update logic . The mountable EFI system partition  may be mounted in a computing system so that when a system reset occurs, the EFI system partition  is booted rather than an operating system partition. Therefore, executables associated with the EFI system partition  may get an opportunity to run during pre-boot time, before an operating system is loaded. This may facilitate, for example, replacing system firmware  stored in persistent memory .","The mountable EFI system partition  may be configured to store an item like a digital image of a replacement system firmware. The digital image of a firmware may be referred to as a binary, and is illustrated as binary . The EFI system partition  may also store an item like an executable image of an update process. An executable image of a process may be referred to as a utility, and is illustrated as update utility .","To facilitate communications between the communication logic  and the user level logic , the EFI  may include a set of EFI variables (not illustrated) that are visible to both the communication logic  and the user level logic . Thus information concerning which persistent memory to manipulate, which version of a BIOS to store in the selected persistent memory, which update logic to use to perform the update, and so on may be communicated from the user level logic  to the EFI level logics (communication logic , update logic ) through EFI variables associated with EFI .","The system may also include a boot logic  that is configured to selectively invoke an EFI pre-boot process that is resident on the mountable EFI system partition . The boot logic  may receive control of a computing system upon assertion of a power good signal from a computing system power supply and thus may facilitate mounting EFI system partition  and using update logic  to reprogram persistent memory . A pre-boot process may, for example, manipulate EFI variables, invoke the update logic  to manipulate the persistent memory , and so on. By way of illustration, the update logic  may be configured to employ the update utility  to perform the manipulation of the persistent memory  by replacing system firmware  with the binary . The binary  may be, for example, a BIOS. The persistent memory  may be, for example, a flash memory.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6","b":["650","650"]},"The system may include a first logic like a user level application  that is configured to determine whether to request an update of the system level firmware. If the user level application  determines that an update is to be requested, then the user level application  may request the update. Requesting the update may include, for example, communicating data through an operating system  and an EFI  to executables associated with a platform hardware  using, for example, an EFI variable .","The system may include an update logic like an update utility  that is configured to facilitate updating the system level firmware in response to the request from the user level application . The update utility  may be accessible from a pre-boot application like those associated with a mountable EFI system partition . In some examples different update utilities may be employed to perform different system firmware upgrades. Thus, update utility  may be copied, for example, from an operating system partition  that stores various executables like update utility .","In addition to storing the update utility , the mountable EFI partition  may store, for example, an operating system loader . Thus, when a user level application  requests a system firmware update, an update utility  may be run at a system reset. However, if a user level application  has not requested a system firmware update, an operating system loader  may be run to facilitate booting an operating system associated with operating system partition . The decision to run the update utility  instead of the operating system loader  may depend, at least in part, on a value stored in an EFI variable. For example, the EFI variable BootNext may be programmed with the address of a pre-boot executable to run during processing performed during a pre-boot EFI time.","The mountable EFI partition  may also store a binary image of a replacement firmware. Thus, the update logic may, at a pre-boot time, update firmware stored in integrated circuit  by replacing the firmware with the binary image stored in the EFI system partition . Different update requests from the user level application  may lead to different firmware binaries being copied to the integrated circuit . Thus, the operating system partition  may store various firmware binaries  that can be copied to the EFI system partition .","While a single EFI system partition  and a single operating system partition  are illustrated, it is to be appreciated that systems may include multiple partitions. Similarly, while a single integrated circuit  and a single user level application  are illustrated, it is to be appreciated that multiple integrated circuits could be manipulated in response to requests from multiple user level applications.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 7","b":"700"},"Method  may include, at , receiving a signal to manipulate a persistent memory. The signal may be received, for example, from a user level application. In one example, the signal may be received as the result of a user indicating an action through a graphical user interface.","Method  may also include, at , mounting a bootable EFI partition into a system configured with a user level logic, an EFI system, and a reprogrammable persistent memory like an EEPROM or flash memory. Mounting the EFI partition may make the EFI partition bootable on a subsequent reset of the system.","Method  may also include, at , copying an executable associated with performing a manipulation process from an operating system partition mounted in the system to the mounted EFI partition. For example, the executable may be a refresh tool configured to facilitate copying a binary from the EFI partition to the persistent memory to be manipulated. In one example, the refresh tool may include a binary version of the second system firmware. In another example, the refresh tool may include information concerning where a binary version of the second system firmware may be retrieved.","Method  may also include, at , updating an EFI variable like the BootNext variable to indicate that the refresh tool should be executed from the mounted EFI partition on the next reset of the system. Thus, the signal received from the user level application may have caused the system to be reconfigured so that EFI pre-boot activities will occur. One of these activities may be running the refresh tool instead of running an operating system loader.","Having mounted the EFI partition and reconfigured the system to run the refresh utility, method  may include, at , rebooting the system so that the EFI partition will be mounted and the refresh tool will be executed. Therefore, at , the EFI system is booted, and at , the refresh tool is run. More generally, the refresh tool may be referred to as the manipulation process. As described above, manipulation may include erasing, reprogramming, editing, and so on, firmware stored in a persistent memory. Thus, method  may include, as part of the actions at , copying a binary of the second system firmware to the persistent memory. Persistent memories may require different actions to be erased, written, rewritten, edited, and so on. Thus, in one example, copying a binary of the second system firmware to the persistent memory may include reconfiguring the persistent memory to be writeable, writing the binary to the persistent memory, and reconfiguring the persistent memory to be not writeable.","The copying may proceed normally, in which case the EFI system may wish to inform the user level application from which the initiating signal was received of the success. Alternatively, the copying may not proceed successfully, in which case the EFI system may wish to inform the user level application of an error. Therefore, running the refresh tool at  may include storing an error code in an EFI variable, where the error code concerns the status of copying the binary to the persistent memory.","Having performed the manipulation, the system may once again be rebooted. In one example, since the EFI system was booted and followed a pointer located in the BootNext variable to the refresh utility, that pointer may now be stale, and thus not followed on a subsequent reboot. This facilitates the EFI running an operating system loader on the subsequent reboot.","Therefore, method  may include, at , rebooting the system. Rebooting the system may include restarting the user level application that provided the initiating signal received at . Thus, method  may include, at , providing a signal to the user level application. The signal may include, for example, the success\/error code, a pointer to an EFI variable storing the success\/error code, updated firmware information, and so on.","In view of the above, it will be appreciated that one embodiment of method  may include receiving , in an extensible firmware interface (EFI) level logic configured to run at a pre-boot time without operating system support, from a user level logic configured to run at a post-boot time with operating system support, through an EFI variable, a first signal to manipulate a flash memory operably connected to a system configured with the EFI level logic and the user level logic, the first signal including one or more of, an identifier of a first Basic Input Output System (BIOS) stored in a flash memory, an identifier of a second BIOS to replace the first BIOS, an identifier of a flash memory to manipulate, an identifier of an EFI level process to employ to manipulate the flash memory, and an identifier of a location of the second BIOS; mounting  an extensible firmware interface (EFI) partition into the system; copying  an executable associated with performing a manipulation process from an operating system partition mounted in the system to the mounted EFI partition, where the executable includes a binary version of the second Basic Input Output System (BIOS); manipulating  an EFI BootNext variable to point to the copy of the executable on the mounted EFI partition; rebooting  the system; invoking the  manipulation process; copying a binary of the second BIOS to the flash memory, where copying a binary of the second BIOS to the flash memory includes: reconfiguring the flash memory to be writeable; writing the binary to the flash memory; and reconfiguring the flash memory to be not writeable; storing an error code in an EFI variable, where the error code concerns the status of copying the binary to the flash memory; rebooting  the system; and providing , from the EFI level logic, to the user level logic, through an EFI variable, a second signal concerning the manipulating of the flash memory.","The actions illustrated in method  may be one example of action  in method  () described as manipulating persistent memory.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 8","b":["800","800","810","820","830"]},"Method  may include, at , copying an update tool and a binary from a first location like an operating system partition to a second location like a mountable EFI system partition. Thus, pre-boot EFI processes may be able to execute the update tool at pre-boot time to copy the binary and thus reflash the system firmware.","Method  may include, at , updating an EFI by, for example, manipulating a pointer or record to facilitate locating and executing the update tool copied at . At , the system may be rebooted. Thus, the update tool copied to the mounted EFI system partition may be run which will cause, at , the system firmware (e.g., BIOS) to be reflashed.","Reflashing may or may not succeed. Thus, at  a determination is made concerning whether it succeeded. If the determination is No, then at  an error code may be established. This may include, for example, writing a value into an EFI variable visible to both the EFI system and user level applications. If the determination is Yes, then at  a success code may similarly be established.","Having attempted the reflash, at  the system may be rebooted, which in turn leads, at , to booting EFI. Since EFI already ran the update tool once, it will not run it on this reboot, but rather will proceed, at , to boot an operating system. Since a user level application took the action that started method , at  the user level application may be restarted. The use level application may then examine the success code established at  or the error code established at .",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 9","b":["900","910","920","960","970","970","950","950","930","950","930","980"]},"In a non-firmware update process configuration, the logic flow  will proceed to the EFI operating system loader load process at , whereupon boot services will terminate at  and an operating system loader  will be invoked.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 10","b":["1000","1002","1004","1010","1008","1000","1030","1030","1000","1030"]},"The processor  can be a variety of various processors including dual microprocessor and other multi-processor architectures. The memory  can include volatile memory and\/or non-volatile memory. The non-volatile memory can include, but is not limited to, ROM, PROM, EPROM, EEPROM, and the like. Volatile memory can include, for example, RAM, synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), and direct RAM bus RAM (DRRAM).","A disk  may be operably connected to the computer  via, for example, an input\/output interface (e.g., card, device)  and an input\/output port . The disk  can include, but is not limited to, devices like a magnetic disk drive, a solid state disk drive, a floppy disk drive, a tape drive, a Zip drive, a flash memory card, and\/or a memory stick. Furthermore, the disk  can include optical drives like a CD-ROM, a CD recordable drive (CD-R drive), a CD rewriteable drive (CD-RW drive), and\/or a digital video ROM drive (DVD ROM). The memory  can store processes  and\/or data , for example. The disk  and\/or memory  can store an operating system that controls and allocates resources of the computer .","The bus  can be a single internal bus interconnect architecture and\/or other bus or mesh architectures. While a single bus is illustrated, it is to be appreciated that computer  may communicate with various devices, logics, and peripherals using other busses that are not illustrated (e.g., PCIE, SATA, Infiniband, 1394, USB, Ethernet). The bus  can be of a variety of types including, but not limited to, a memory bus or memory controller, a peripheral bus or external bus, a crossbar switch, and\/or a local bus. The local bus can be of varieties including, but not limited to, an industrial standard architecture (ISA) bus, a microchannel architecture (MSA) bus, an extended ISA (EISA) bus, a peripheral component interconnect (PCI) bus, a universal serial (USB) bus, and a small computer systems interface (SCSI) bus.","The computer  may interact with input\/output devices via i\/o interfaces  and input\/output ports . Input\/output devices can include, but are not limited to, a keyboard, a microphone, a pointing and selection device, cameras, video cards, displays, disk , network devices , and the like. The input\/output ports  can include but are not limited to, serial ports, parallel ports, and USB ports.","The computer  can operate in a network environment and thus may be connected to network devices  via the i\/o interfaces , and\/or the i\/o ports . Through the network devices , the computer  may interact with a network. Through the network, the computer  may be logically connected to remote computers. The networks with which the computer  may interact include, but are not limited to, a local area network (LAN), a wide area network (WAN), and other networks. The network devices  can connect to LAN technologies including, but not limited to, fiber distributed data interface (FDDI), copper distributed data interface (CDDI), Ethernet (IEEE 802.3), token ring (IEEE 802.5), wireless computer communication (IEEE 802.11), Bluetooth (IEEE 802.15.1), Zigbee (IEEE 802.15.4) and the like. Similarly, the network devices  can connect to WAN technologies including, but not limited to, point to point links, circuit switching networks like integrated services digital networks (ISDN), packet switching networks, and digital subscriber lines (DSL). While individual network types are described, it is to be appreciated that communications via, over, and\/or through a network may include combinations and mixtures of communications.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 11","b":["1100","1110","1110","1110","1100"]},"The image forming device  may receive print data to be rendered. Thus, image forming device  may also include a memory  configured to store print data or to be used more generally for image processing. The image forming device  may also include a rendering logic  configured to generate a printer-ready image from print data. Rendering varies based on the format of the data involved and the type of imaging device. In general, the rendering logic  converts high-level data into a graphical image for display or printing (e.g., the print-ready image). For example, one form is ray-tracing that takes a mathematical model of a three-dimensional object or scene and converts it into a bitmap image. Another example is the process of converting HTML into an image for display\/printing. It is to be appreciated that the image forming device  may receive printer-ready data that does not need to be rendered and thus the rendering logic  may not appear in some image forming devices.","The image forming device  may also include an image forming mechanism  configured to generate an image onto print media from the print-ready image. The image forming mechanism  may vary based on the type of the imaging device  and may include a laser imaging mechanism, other toner-based imaging mechanisms, an ink jet mechanism, digital imaging mechanism, or other imaging reproduction engine. A processor  may be included that is implemented with logic to control the operation of the image-forming device . In one example, the processor  includes logic that is capable of executing Java instructions. Other components of the image forming device  are not described herein but may include media handling and storage mechanisms, sensors, controllers, and other components involved in the imaging process.","Referring now to , an application programming interface (API)  is illustrated providing access to a system  for manipulating a persistent memory configured with a system firmware. The API  can be employed, for example, by a programmer  and\/or a process  to gain access to processing performed by the system . For example, a programmer  can write a program to access the system  (e.g., invoke its operation, monitor its operation, control its operation) where writing the program is facilitated by the presence of the API . Rather than programmer  having to understand the internals of the system , the programmer  merely has to learn the interface to the system . This facilitates encapsulating the functionality of the system  while exposing that functionality.","Similarly, the API  can be employed to provide data values to the system  and\/or retrieve data values from the system . For example, a process  that examines binaries can provide binary code to the system  via the API  by, for example, using a call provided in the API . Thus, in one example of the API , a set of application programming interfaces can be stored on a computer-readable medium. The interfaces can be employed by a programmer, computer component, logic, and so on, to gain access to a system  for manipulating a persistent memory configured with a system firmware. The interfaces can include, but are not limited to, a first interface  that communicates a binary code (e.g., replacement system firmware) and a second interface  that communicates a firmware data that may facilitate characterizing the binary code. For example, the firmware data may include size, version, date, and other identifying and\/or characterizing data.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 13","b":["1300","1300","1300","1300","1310","1300","1320","1330","1340","1300","1350","1330","1300"]},"While example systems, methods, and so on, have been illustrated by describing examples, and while the examples have been described in considerable detail, it is not the intention of the applicants to restrict or in any way limit the scope of the appended claims to such detail. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the systems, methods, and so on, described herein. Additional advantages and modifications will readily appear to those skilled in the art. Therefore, the invention is not limited to the specific details, the representative apparatus, and illustrative examples shown and described. Thus, this application is intended to embrace alterations, modifications, and variations that fall within the scope of the appended claims. Furthermore, the preceding description is not meant to limit the scope of the invention. Rather, the scope of the invention is to be determined by the appended claims and their equivalents.","To the extent that the term \u201cincludes\u201d or \u201cincluding\u201d is employed in the detailed description or the claims, it is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as that term is interpreted when employed as a transitional word in a claim. Furthermore, to the extent that the term \u201cor\u201d is employed in the detailed description or claims (e.g., A or B) it is intended to mean \u201cA or B or both\u201d. When the applicants intend to indicate \u201conly A or B but not both\u201d then the term \u201conly A or B but not both\u201d will be employed. Thus, use of the term \u201cor\u201d herein is the inclusive, and not the exclusive use. See, Bryan A. Garner, A Dictionary of Modern Legal Usage 624 (2d. Ed. 1995)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING","p":["The accompanying drawings, which are incorporated in and constitute a part of the specification, illustrate various example systems, methods, and so on, that illustrate various example embodiments of aspects of the invention. It will be appreciated that the illustrated element boundaries (e.g., boxes, groups of boxes, or other shapes) in the figures represent one example of the boundaries. One of ordinary skill in the art will appreciate that one element may be designed as multiple elements or that multiple elements may be designed as one element. An element shown as an internal component of another element may be implemented as an external component and vice versa. Furthermore, elements may not be drawn to scale.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
