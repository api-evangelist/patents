---
title: Distributed data model
abstract: Method and systems for transferring data from a sending device to a receiving device. The method starts with the preparation of a description of the structure of the data which is provided to the sending device and the receiving device. A reference model of the data structure is created on each of the sending and receiving devices, during run time, using the description of the data. As requested, instances of the reference model are created with the data on the sending device. The data in the instance is serialized by extracting the data and transferred from the sending device to the receiving device. The receiving device creates an instance of the data based on the reference model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08086660&OS=08086660&RS=08086660
owner: Ixia
number: 08086660
owner_city: Calabasas
owner_country: US
publication_date: 20040521
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION","Method for Transferring Data","Use of Parcels in a Protocol Emulator","Parcels","Working with Parcels","Miscellaneous"],"p":["Network devices, such as routers, are extensively tested to ensure that erroneous transmissions and fatal errors are minimized. A variety of test devices are available on the marketplace, including the ROUTER TESTER from AGILENT TECHNOLOGIES, assignee of the present application. Such test devices typically monitor the routers response to a variety of simulated input.","The process of routing can be quickly summarized as a node finding the path to every possible destination. Routing is present in everything from layer 1 (the physical layer) on up. The routing that most people are familiar with, however, occurs at layer 3 (the network layer) and as such, only layer 3 (and more specifically) Internet Protocol (IP) routing will be referenced herein. Routers use tables to determine where to forward packets. Updating these tables is a function performed by routing protocols. Each router is responsive to one or more protocols.","Protocols for exchanging routing information connect multiple routers around the world to provide them with a common view of the network through their heterogeneous, though generally consistent routing tables. Routing tables store all information necessary for the router to reach every destination on the network irrespective of size. There are a wide variety of routing protocols used to contribute to the routing tables across a network. Protocols such as BGP, OSPF, RIP and ISIS help to convey a correct and coherent picture of the network to all routers on the network.","Known router testers simulate network traffic using specifically created \u201ctest packets\u201d of data that are typical of the live data present on the network. These test packets are transmitted to the network device over a network under test. Parameters tested by traffic simulator systems (including ROUTER TESTER) include routing verification, achievement of Quality of Service (QoS) levels under load, and correct inter-working with other devices. Many of these so-called \u201cpacket blasters\u201d also test the ability of the network device to adhere to protocols by formulating and transmitting messages in accordance with the protocols.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["100","100","102","104","102","102","106","106","108"],"i":["n ","n ","n "]},"The test packets produced by the protocol emulation cards are built according to the rules and interpretations of communications protocols, such as those defined by the many standards bodies in the industry. There are many communications protocols in use and new protocols continue to be developed. Typically, new protocols are initially developed by equipment manufacturers and are proprietary in nature. Often, the protocols are subsequently adopted by standards bodies for widespread implementation in industry.","The current software architecture associated with traffic simulator test systems requires hard-coding all parts of the protocol emulation solution including the graphical user interface, scripting API, configuration and control components, and the protocol state machine itself. The hard coding required for each protocol has resulted in the use of an enormous amount of human talent to create the large body of code. Much of this code is dedicated to interfacing the computer  with each new protocol emulation card ","The traditional approach to interfacing the computer  with each new protocol emulation card requires methods and associated parameters to be known at the time the interface is written and hard coded in an interface description language (IDL). Under this paradigm, new methods and parameters are continually being created each time new protocol emulations are written or old protocols are extended. This has resulted in a vast API (application programming interface) containing many hundreds of methods and parameters, resulting in a body of code that is expensive to maintain. Further, the known approaches result in the API being replicated at several different layers, thereby compounding the problems. Thus, each change to the API (no matter how small) requires the updating of a significant amount of code and different levels within the system. One side effect of this approach is that a unique GUI must be generated for each protocol and each update thereof. As with the API, as the number of protocols grow, so do the required GUI implementations.","Efforts are now being made to design generic systems that alleviate some of the foregoing problems. One example is described in co-pending U.S. patent application Ser. No. 10\/266,507, Publication No.: U.S. 20040068681 A1, entitled: Building packets of data. U.S. 20040068681 A1, incorporated herein by reference, uses an external XML protocol description to drive a generic PDU encode\/decode engine. A next step is to build a generic interface to the protocol emulators that do not require new code or hard coded interfaces changes for each new emulator or change thereto.","One known approach to this problem is the use of an Interface Definition Language (IDL), such as DCOM or CORBA. However, IDLs have proven unsuitable, as they require all details of each interface to be known at compile time. Another option is the use of ASN.1\u2014a language for defining any data structure. Known ASN.1 compilers generate interface code for encoding and decoding such structures. However, like IDL's, ASN.1 is a compile time solution requiring specifically written code for each interface. Another option is using one of the available XML data models, such as DOM (Document Object Model). However, XML data is transmitted as text files which are an inefficient use of bandwidth. Further, XML data usually requires very processor intensive computations along with time consuming parsing. Further, navigation of a DOM structure is slow and does not naturally represent tabular data (which is prevalent in protocol emulator interfaces).","Accordingly, the present inventors have recognized a need for new interface mechanism capable of representing all commands, configuration data, and output from a protocol emulation. Further, such a mechanism should be equally adroit at hierarchical data as with tabular data.","In the description contained hereinafter, the use of a lowercase \u201cn\u201d adjacent to an element identifier denotes a non-specific instance of the element rather than a specific element as shown in the figures or discussed in the specification with a non-italicized letter adjacent to the element number.","Reference will now be made to embodiments of the present invention, examples of which are illustrated in the accompanying drawings, wherein like reference numerals refer to like elements throughout. The detailed description which follows presents methods that may be embodied by routines and symbolic representations of operations of data bits within a computer readable medium, associated processors, data generation and acquisition cards, and the like. A routine is here, and generally, conceived to be a sequence of steps or actions leading to a desired result, and as such, encompasses such terms of art as \u201cprogram,\u201d \u201cobjects,\u201d \u201cfunctions,\u201d \u201csubroutines,\u201d and \u201cprocedures.\u201d These descriptions and representations are the means used by those skilled in the art effectively convey the substance of their work to others skilled in the art. For the sake of convenience, the word \u201cnetwork\u201d will hereinafter in the description and claims be used to refer to any one or more of: a communication network, a network device, any other communication device, and any aspect or aspects of a communication system which can be tested using test packets of data.","Embodiments which comprise methods will be described with respect to implementation on a router tester having a configuration similar to the AGILENT ROUTER TESTER, but the methods recited herein may operate on any of a variety of router testers. More to the point, the methods presented herein are not inherently related to any particular device; rather, various devices may be used with routines in accordance with the teachings herein. In particular the methods described herein for transfer of data from one device to another, while being described with respect to router tester function, may be applicable to the data communication field in general. Machines that may perform the functions described herein include those manufactured by such companies as AGILENT TECHNOLOGIES, INC., HEWLETT PACKARD, and TEKTRONIX, INC. as well as other manufacturers of communication equipment.","With respect to the software described herein, those of ordinary skill in the art will recognize that there exist a variety of platforms and languages for creating software for performing the procedures outlined herein. Embodiments of the present invention can be implemented using any of a number of varieties of C, including C. However, those of ordinary skill in the art also recognize that the choice of the exact platform and language is often dictated by the specifics of the actual system constructed, such that what may work for one type of system may not be efficient on another system. It should also be understood that the routines and calculations described herein are not limited to being executed as software on a computer, but can also be implemented in a hardware processor. For example, the routines and calculations could be implemented with HDL (Hardware Design Language) in an ASICS or in an FGPA using a variety of design tools.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","200","106","102"],"i":["a ","b","a ","n "]},"For convenience, the data structures used by the described embodiments of the present invention will be referred to as \u201cparcels.\u201d A parcel can be thought of as a flexible, annotated data structure capable of representing commands, configuration data and output from any routine. Parcels created by the client would contain: commands; session data; and topology. Parcels created by the protocol emulation card would contain: statistics; topology; and message trace.","The transfer method, illustrated in , starts with a parcel definition (also referred to herein as a \u201cdefinition\u201d or \u201cdescription\u201d). A parcel definition provides a description of the elements of one or more parcels along with attributes thereof. The preferred data structure of a parcel is hierarchical, wherein each node can contain a value, sub nodes, a function, an array of values or a table of values. A parcel definition may be as simple as a text file that provides a list of parcels and specifies the elements (referred to herein as the \u201cnodes\u201d) that comprise each parcel, the type of each node and the interrelationship of the nodes. Each node may be annotated using descriptive attributes (examples of which are discussed herein after).","It may be preferable, but not necessary, to formulate the parcel definition in XML. More specifically, it is desirable to format the parcel description in an easily accessible format to facilitate creation and modification thereof. The nested tag structure provided by XML facilitates the documentation of hierarchal relationships and table structures. The parcel definition is generally stored on the first location and is retrieved at run time by applications running on the first location ","The parcel definition is parsed to create a parcel reference model (also referred to as a \u201creference model\u201d). In general, the parcel reference model is a data structure, such as in C++, from which instances of a parcel, e.g. the parcel object , can be created, or instantiated. Perhaps the closest analogous structure would be a generic type in C++. One difference is that while generic types must be defined at compile time, parcels can be introduced during run time. With parcels, the type is defined by the reference model from which the actual parcel is derived. In use, it may prove beneficial to parse all parcel definitions at system startup so as to generate a reference model of all potential parcels that may be required during operation. However, if time and storage are considerations, it may be advisable to generate only those reference models that are likely to be needed for the current session.","Parcel objects may be managed using a Parcel API, described hereinafter, that can provide a generic interface for working with parcel data. In the context of the present invention, one method for working with parcels is serializing them for communication to the second location . Parcel may be serialized into a variety of forms including XML suitable for save\/restore purposes and binary form suitable for communication with other locations. Conceptually, serialization can be thought of as stripping the data from the data structure, and forming a linear file or data stream for transmission. Enough data structure is provided to identify the reference model that should be used to decode the binary stream and recreate the parcel on the receiving side. During this reconstruction, the structural information contained in the reference model is used to parse the data in the binary stream.","Accordingly, the second location is provided with a copy of the parcel definition \u2014shown as the parcel definition . The second location parses the parcel definition to generate a reference model , which should be a copy of the reference model . Upon receipt of the binary data , the second location forms a parcel object by instantiating the parcel reference model and populating the resultant data structure with the binary data .","A similar process can be used to form parcel objects. The parcel definition may be used to generate a graphical user interface with the appropriate input mechanisms, e.g. text entry fields, radio buttons, etc. . . . for each of the defined elements. Once the user supplies the desired input data, the reference model is instantiated and the parcel is object is populated with the input data. Advantageously a generic API may be devised, examples of which are disclosed herein below, that can handle the creation and maintenance of any parcel object for which a parcel definition is provided.","In contrast to IDL based solutions, a parcel is defined externally to the compiled code and uses a generic API that does not need to be changed as new parcels are defined. This allows an application framework to be built that can cater for future protocol solutions without having to change or grow the framework. It also allows the creation of a stable interface for third parties or customers to build their own solutions on. In contrast to conventional XML solutions, parcel structure is defined once, up front\u2014not for every data packet received. Required parcel reference models may be built at application start up time, alleviating need to continually parse XML. Parcels may be designed for efficient navigation and searching is minimized, by contrast with the XML DOM. Parcels may be designed for efficient binary encoding and decoding requiring relatively small, as compared with XML text, binary data packets for communicated between software systems. Parcels may be designed to encompass tabular data providing a natural fit with many applications.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3","b":["300","300","302","304","302","304"]},"The host  runs an application , among other applications and the operating system, that provide routines for the control of the protocol emulator  and specifically for communication with the protocol emulator card . In accordance with at least one embodiment, the application is a generic protocol independent application. This means that the application  preferably lacks any protocol specific functionality. Such functionality is, in effect, created dynamically using the parcel definitions . The application  is responsible for the creation, maintenance use of the parcel reference models (see ), along with the serialization, transmittal, reception and de-serialization of the data contained in instances of the reference models, e.g. the parcel objects . As noted, it may be preferable to provide an API-like interface to these functions, thereby providing a single generic interface to each different protocol emulation.","A graphical user interface  is provided such that when a user requests that a protocol emulation be started, the application  will interact with a client , in the graphical user interface , to display forms for the entry of parameters needed to control the protocol emulator . This may be accomplished using the parcel definition or the parcel reference model (see ). Once the appropriate data has been entered, the application  creates an instance of the reference model to form a parcel object . The application  serializes the parcel object and transmits the serialized object to the protocol emulator .","The protocol emulator  runs an application , among others, which includes modules for the emulation of selected protocols . In accordance with at least one preferred embodiment, the application  includes routines for communication with the host  using parcels. In general, it may be preferable that the application  includes routines similar to those contained in the application . This may be accomplished by the creation of generic API-like routines that interface with parcels. Examples of such routines will be provided herein below.","The protocol emulator  should be periodically provided with updated copies of the parcel definitions . It may be beneficial for the host  to provide the definitions to the protocol emulator  upon each start up. The protocol emulator  upon receipt of the parcel definitions created a set of parcel reference models from which parcel objects can be instantiated. When a serialized parcel object is received from the host , a new parcel object is instantiated based on the associated parcel object . This object is then used to provide the data required by protocol emulation routines running on the protocol emulator . Thus, when new protocol emulations are added to the protocol emulator , only a new parcel definition need be defined to permit communication between the host  and the protocol emulator  (and the module ).","While the following discussion will focus on one embodiment of a parcel, those of ordinary skill in the art will recognize that departures from the described parcel structure are possible and will still fall within the scope of the invention. In the described embodiment, parcels generally comprise a header and a set of elements. Elements generally fall into two categories, container elements that provide structure and data elements that store a value or series of values. An example of a set of element (or \u201cnode\u201d) types for a parcel are shown in TABLE 1.",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Element",{},{}]},{"entry":["Type","Container","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["value","No","A single value. (Boolean, Numeric or string). A"]},{"entry":[{},{},"value may be any length."]},{"entry":["array","No","A set of homogeneous values (all the same type)"]},{"entry":["set","Yes","A parcel element containing other parcel elements,"]},{"entry":[{},{},"e.g. value, array, set, table or keyed table."]},{"entry":["table","Yes","A table. Each member of the table represents a"]},{"entry":[{},{},"column. Rows in the table are indexed."]},{"entry":["keyed","Yes","A table. Each member of the table represents a"]},{"entry":["table",{},"column. One column, which must be a value, is"]},{"entry":[{},{},"specified as the key column. Each row in the table"]},{"entry":[{},{},"must have a unique value in the key column."]},{"entry":[{},{},"Rows are accessed by key value."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Each element may be annotated using descriptive attributes. Such attributes document the parcel, allowing the parcel to be self-documenting. By storing the attributes with the parcel definition and perhaps the parcel reference model, the routines provided to manipulate and interface with parcel may be generic in nature, e.g. the data structure is not coded in the routines, rather the data structure is provided during run-time. For example, attributes can be used to provide all the information needed to present and edit any parcel using a generic graphical user interface. Some examples of possible attributes are shown in Table 2. Those of ordinary skill in the art will recognize that the list present in table 2 is not exhaustive, but that other attributes may prove beneficial depending on the implementation of the present invention.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Attribute","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["fullName","GUI presentation name for the parcel element"]},{"entry":["description","Description of purpose and usage"]},{"entry":["length","For value and array elements, the length attribute defines"]},{"entry":[{},"the number of bits required to hold the value."]},{"entry":["format","The presentation format. Defined formats include \u201cinteger\u201d,"]},{"entry":[{},"\u201chex\u201d, \u201cBoolean\u201d, \u201cipv4_address\u201d etc."]},{"entry":["minValue\/","Allowed value ranges, allowing the GUI or API to perform"]},{"entry":["maxValue","automated range checking"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 3 contains an example of a parcel definition in XML. In particular, Table 3 contains the definition of two parcels: bgpSessionData, and routePools, along with two commands: addIpv4RoutePool, and addIpv6RoutePool. The parcel bgp defines the startup data needed to create a bgp emulation session. The parcel routePools defines a set of reachable addresses to be advertised by a routing protocol. Two tables are defined within routePools: one for IPv4 addresses, and one for IPv6 addresses. The range of addresses are parametrically defined using a start address, prefix length and count. The commands references the routePools parcel to populate its contents. The commands use a selected row from a route pool table as parameters.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<!-- ============================================= -->"},{"entry":"<parcel name=\u201cbgpSessionData\u201d"},{"entry":"\u2003\u2003fullName=\u201cBGP4 Session Data\u201d"},{"entry":"\u2003\u2003class=\u201csessionData\u201d"},{"entry":"\u2003\u2003flow=\u201ctoServer\u201d"},{"entry":"\u2003\u2003buffer=\u201cnewest\u201d>"},{"entry":"\u2003\u2003<value name=\u201clocal_port\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cLocal port\u201d"},{"entry":"\u2003\u2003\u2003\u2003purpose=\u201clocalPort\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003\u2003defaultValue=\u201c179\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cremote_port\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cRemote port\u201d"},{"entry":"\u2003\u2003\u2003\u2003purpose=\u201cremotePort\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003\u2003defaultValue=\u201c179\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201csubinterface\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cSub-interface identifier\u201d"},{"entry":"\u2003\u2003\u2003\u2003purpose=\u201csubinterface\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cprefix_length\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cAddress prefix length\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003\u2003purpose=\u201cprefixLength\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003\u2003defaultValue=\u201c24\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201clocal_ip\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cSource IP Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cipv4_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003purpose=\u201clocalAddress\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c32\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cremote_ip\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cDestination IP Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cipv4_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003purpose=\u201cremoteAddress\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c32\u201d\/>"},{"entry":"<\/parcel>"},{"entry":"<!-- ============================================= -->"},{"entry":"<parcel name=\u201croutePools\u201d"},{"entry":"\u2003\u2003fullName=\u201cRoute Pools\u201d"},{"entry":"\u2003\u2003class=\u201cdestinationPools\u201d>"},{"entry":"\u2003\u2003<table name=\u201cipv4Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cIPv4 Route Pools\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv4StartAddr\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cStart Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cipv4_address\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv4PrefixLen\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cPrefix Length\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003minValue=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003maxValue=\u201c32\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv4Count\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cCount\u201d\/>"},{"entry":"\u2003\u2003<\/table>"},{"entry":"\u2003\u2003<table name=\u201cipv6Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cIPv6 Route Pools\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv6StartAddr\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cStart Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c128\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cipv6_address\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv6PrefixLen\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cPrefix Length\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003minValue=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003maxValue=\u201c128\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv6Count\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cCount\u201d\/>"},{"entry":"\u2003\u2003<\/table>"},{"entry":"<\/parcel>"},{"entry":"<!-- ============================================= -->"},{"entry":"<command name=\u201caddIPv4RoutePool\u201d"},{"entry":"\u2003\u2003fullName=\u201cAdd an IPv4 route pool\u201d"},{"entry":"\u2003\u2003instance=\u201csession\u201d"},{"entry":"\u2003\u2003purpose=\u201cdebug\u201d>"},{"entry":"\u2003\u2003<use rowRef=\u201croutePools:ipv4Pools\u201d\/>"},{"entry":"<\/command>"},{"entry":"<command name=\u201caddIPv6RoutePool\u201d"},{"entry":"\u2003\u2003fullName=\u201cAdd an IPv6 route pool\u201d"},{"entry":"\u2003\u2003instance=\u201csession\u201d"},{"entry":"\u2003\u2003purpose=\u201cdebug\u201d>"},{"entry":"\u2003\u2003<use rowRef=\u201croutePools:ipv6Pools\u201d\/>"},{"entry":"<\/command>"},{"entry":"<!-- ============================================= -->"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Often default values for elements need to be set which vary according to other values specified internally or externally of the definition. In such cases it may be beneficial to integrate Tool Command Language (TCL) procedures that can be invoked to perform such tasks. Such function can be specified in the XML parcel definition. Integration of TCL is within the capabilities of those of ordinary skill in the art and as such the specific details of such integration will not be discussed herein. An example of a portion of a parcel definition incorporating TCL functions is shown in Table 4:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<value name=\u201dholdTimer\u201d fullName=\u201dHold Timer\u201d length=\u201d16\u201d"},{"entry":"\u2003\u2003defaultValue=\u201d30\u201d\/>"},{"entry":"<value name=\u201dkeepalive\u201d fullName=\u201dKeepalive Value\u201d length=\u201d16\u201d"},{"entry":"\u2003\u2003valueFunction=\u201dmultiply :holdTimer 2\u201d \/>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example, the default value for keepalive is maintained at twice the holdTimer, no matter what value is set for holdTimer. The TCL functions can be executed when instantiating a parcel, e.g. creating an instance of a parcel. Further, routines can be created to review the parcel definition and\/or model and update the values affected by such functions during runtime.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4","b":["202","204","206","204","204"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5","b":["206","500","502","206"]},"In step , if a parcel object  is requested for which a parcel reference model  has not been formed, the method proceeds to step . Otherwise the method proceeds to step  discussed herein below. In step , the lookup table built in step  is scanned to identify the XML file corresponding to the parcel object  requested. Next in step , the identified XML file is parsed, for example using a public domain XML parser software such as expat. The XML parser generates a vector of C++ tag objects which are used to construct the associated reference model  in step .","Referring to the example shown in , the reference model  contains a top level node, set (), which contains a table node () and a value node (). The table node () contains three nodes: a value node (), an array node () and a value node (). In the example parcel object , twelve nodes are created by creating 3 rows of the table node ().","It may be beneficial to parse all XML files at startup time to ensure that all models are available for the entire session. However, this may prove to be unnecessary as a given test session may require only a subset of parcels. Therefore it may prove beneficial to parse on demand as is described with respect to .","In step , a map is created and associated with the reference model  that maintains a map of reference parcel objects, i.e. parcel objects described by the reference model , indexed by name. This is desirable as a single reference model  may contain the description of a plurality of reference parcel objects. The map may be used to retrieve an appropriate reference model  (or portion thereof) describing the desired parcel when a parcel object  is to be instantiated.","Next in step , the reference model  is passed to a routine that constructs the parcel object . In this way a new parcel object  is created, in effect instantiated, from the associated reference model . Generally, a parcel object  comprises a header indicating the associated reference model , and a data structure for holding the data related to the elements described in the reference model . When first created, where available the data structure can be populated with default values defined in the attributes. Where needed, values can be updated or entered by a user or another routine.","Each node in the parcel object  has a corresponding reference parcel node. However, the presence of tables means that the correspondence is not necessarily one to one. This is because a parcel object  may have multiple instances of a particular node\u2014one for each row in the table. The parcel object  does not need to (but may) include the attribute information contained in the reference model . Attribute information, when required, may be obtained from the reference parcel .","Assigning an index to each node in the parcel can facilitate efficient navigation between nodes of the parcel object . The number in parenthesis in each node in  shows an example of an indexing system. In the reference model, , each reference node is allocated an index. Each reference node that is a container, such as a set or table, can be configured to record the indices of its member nodes. Each node in a parcel object, , acquires the same index as its corresponding reference node, . A parcel index vector of active nodes in a parcel object  may be used for efficient navigation of nodes in the object. Each active node records its index in the vector. In the case of tables, the existence of multiple rows (and hence node instances) may be managed by designating a current (or selected) row in the table. When a row is selected, the nodes in the selected row register themselves with the parcel index vector. In this way, only the nodes in the current row may be navigated\u2014a row must be selected before nodes can be accessed.","To facilitate understanding of the process for converting a parcel definition in to a parcel model, the following tables are presented. Table 6 shows a partial parcel definition (encompassing three individual parcels) while Table 7 is a conceptual example of a reference model based on the parcel definition contained in Table 6.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<parcel name=\u201csessionSummary\u201d"]},{"entry":[{},"\u2003\u2003<table name=\u201csessions\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cName\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cTester\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cSUT\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/table>"]},{"entry":[{},"<\/parcel>"]},{"entry":[{},"<parcel name=\u201cbgpData\u201d>"]},{"entry":[{},"\u2003\u2003<value name=\u201clocalip\u201d\/>"]},{"entry":[{},"\u2003\u2003<value name=\u201cremoteip\u201d\/>"]},{"entry":[{},"<\/parcel>"]},{"entry":[{},"<parcel name=\u201cbgpRoutes\u201d>"]},{"entry":[{},"\u2003\u2003<value name=\u201cstart\u201d\/>"]},{"entry":[{},"\u2003\u2003<value name=\u201cincrement\u201d\/>"]},{"entry":[{},"\u2003\u2003<value name=\u201ccount\u201d\/>"]},{"entry":[{},"<\/parcel>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parcel sessionSummary","Parcel BGP4","Parcel bgpRoutes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Ref node \u201csessionSummary\u201d","Ref node \u201cbgpData\u201d","Ref node \u201cbgpRoutes\u201d"]},{"entry":["type=APF_NODE_TYPE_SET","type=APF_NODE_TYPE_SET","type=APF_NODE_TYPE_SET"]},{"entry":["index = 0","index = 0","index = 0"]},{"entry":["Ref node \u201csessions\u201d","Ref node \u201clocalip\u201d","Ref node \u201cstart\u201d"]},{"entry":["type=APF_NODE_TYPE_TABLE","type=APF_NODE_TYPE_VALUE","type=APF_NODE_TYPE_VALUE"]},{"entry":["index = 1","index = 1","index = 1"]},{"entry":["Ref node \u201cName\u201d","Ref node \u201cremoteip\u201d","Ref node \u201cincrement\u201d"]},{"entry":["type=APF_NODE_TYPE_VALUE","type=APF_NODE_TYPE_VALUE","type=APF_NODE_TYPE_VALUE"]},{"entry":["index = 2","index = 2","index = 2"]},{"entry":["Ref node \u201cTester\u201d",{},"Ref node \u201ccount\u201d"]},{"entry":["type=APF_NODE_TYPE_VALUE",{},"type=APF_NODE_TYPE_VALUE"]},{"entry":["index = 3",{},"index = 3"]},{"entry":"Ref node \u201cSUT\u201d"},{"entry":"type=APF_NODE_TYPE_VALUE"},{"entry":"index = 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"As a parcel is, in effect, a self documenting data model, a group of generic routines may be formulated to interface with the parcels. Such routines may be thought of as application program interfaces (APIs) in terms of their functions. It is desirable to provide routines for the creation, e.g. instantiation, of parcels, the reading of parcels and the writing of parcels. Table 8 provides examples of routines, using self-documenting code, that describe a generic interface to parcels, including read and write interfaces.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"350pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#ifndef APF_PARCEL_H"},{"entry":"#define APF_PARCEL_H"},{"entry":"\/\/ =========================================================================="},{"entry":"\/\/"},{"entry":"\/\/ = LIBRARY"},{"entry":"\/\/ \u2003\u2003APF Agilent Protocol Framework"},{"entry":"\/\/"},{"entry":"\/\/ = FILENAME"},{"entry":"\/\/ \u2003\u2003ApfParcel.h"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/"},{"entry":"\/\/ Parcel interface"},{"entry":"\/\/"},{"entry":"\/\/ = AUTHORS"},{"entry":"\/\/ \u2003\u2003Geoff Smith"},{"entry":"\/\/"},{"entry":"\/\/ = COPYRIGHT"},{"entry":"\/\/ \u2003\u2003(C) Copyright 2004 Agilent Technologies"},{"entry":"\/\/"},{"entry":"\/\/ =========================================================================="},{"entry":"#include \u201cemuframework\/include\/apfEmulationReference.h\u201d"},{"entry":"\/\/---------------------------------------------------------------------"},{"entry":"\/\/ = TITLE"},{"entry":"\/\/ \u2003\u2003Parcel Read Interface"},{"entry":"\/\/"},{"entry":"\/\/ = CLASS TYPE"},{"entry":"\/\/ \u2003\u2003Interface"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/ \u2003\u2003Read Interface to a parcel instance. This interface is used for"},{"entry":"\/\/ parcels retrieved from the destination parcel store."},{"entry":"class APB_EXPORT_CLASS IApfReadParcel"},{"entry":"{"},{"entry":"public:"},{"entry":"\u2003\u2003virtual ~IApfReadParcel( ) { }"},{"entry":"\u2003\u2003\/\/ = PROPERTIES"},{"entry":"\u2003\u2003virtual IApfRefParcel*"},{"entry":"\u2003\u2003refParcel( ) const = 0;"},{"entry":"\u2003\u2003virtual EApfParcelState"},{"entry":"\u2003\u2003parcelState( ) const = 0;"},{"entry":"\u2003\u2003\/\/ = PARCEL ITERATION"},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003currentIteration( ) const = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003iterateParcel(uint32_t aIteration = 0) = 0;"},{"entry":"\u2003\u2003\/\/ Note: the max iteration is a property of the emulation."},{"entry":"\u2003\u2003\/\/ It is not enforced by the parcel"},{"entry":"\u2003\u2003\/\/ = CURRENT NODE"},{"entry":"\u2003\u2003virtual IApfRefNode*"},{"entry":"\u2003\u2003refNode( ) const = 0;"},{"entry":"\u2003\u2003virtual EApfNodeType"},{"entry":"\u2003\u2003nodeType( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isActive( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Query whether or not the current node is active. An inactive node"},{"entry":"\u2003\u2003\/\/ has no value. It corresponds to a node that fails a selectRef,"},{"entry":"\u2003\u2003\/\/ or table columns nodes or decendents for a table with no rows."},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isCopyRowSource( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Query whether the current node is a set, or a table with a current row."},{"entry":"\u2003\u2003\/\/ Use this method to check whether this parcel is ready for"},{"entry":"\u2003\u2003\/\/ copying a row to another parcel using copyRow"},{"entry":"\u2003\u2003\/\/ = NAVIGATION"},{"entry":"\u2003\u2003\/\/ The parcel is a hierarchical collection of nodes, which may be values, arrays,"},{"entry":"\u2003\u2003\/\/ sets or tables (See nodeType( )). The root parcel node is similar to a set."},{"entry":"\u2003\u2003\/\/ The parcel maintains an internal cursor which is used to navigate the parcel"},{"entry":"\u2003\u2003\/\/ hierarchy."},{"entry":"\u2003\u2003\/\/ Most parcel operations are dependent on the current cursor location."},{"entry":"\u2003\u2003\/\/ For example, nodeType( ) returns the node type of the current node, and getValue( )"},{"entry":"\u2003\u2003\/\/ returns the value of the current node. So, to use the parcel API, the cursor"},{"entry":"\u2003\u2003\/\/ must be moved to the node of interest."},{"entry":"\u2003\u2003\/\/ Each level of the parcel hierarchy defines an cursor scope. Operations such as"},{"entry":"\u2003\u2003\/\/ resetFirst( ), next( ), prev( ) and goto*( ) work within the current cursor scope."},{"entry":"\u2003\u2003\/\/ Scope operations such as enter( ), leave( ), resetTop( ) and find*( ) move the"},{"entry":"\u2003\u2003\/\/ cursor between scopes."},{"entry":"\u2003\u2003\/\/ For example, after a resetTop( ), the cursor will be at the root parcel node. There"},{"entry":"\u2003\u2003\/\/ is only one node at this level, an enter( ) is needed to move down to the top level"},{"entry":"\u2003\u2003\/\/ members of the parcel. The next( ) and prev( ) operators may then be used to"},{"entry":"\u2003\u2003\/\/ will move the cursor among the members at this level."},{"entry":"\u2003\u2003\/\/ The members of a table represent the table columns. The parcel cursor is moved"},{"entry":"\u2003\u2003\/\/ from one column to the next. Separate table operations are provided to move between"},{"entry":"\u2003\u2003\/\/ table rows."},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003resetFirst( ) const = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003resetLast( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isStart( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isEnd( ) const = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003next( ) const = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003prev( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Cursor scope operations"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003resetTop( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Reset the cursor to the first member of the parcel"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003enter( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Enter a set or a table column. If the table has no rows, the cursor is positioned"},{"entry":"\u2003\u2003\/\/ off the end."},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003leave( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Leave a set or a table column"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003getCursor(int& theCursor) const = 0;"},{"entry":"\u2003\u2003\/\/ Save the cursor for the current element"},{"entry":"\u2003\u2003\/\/ Returns:"},{"entry":"\u2003\u2003\/\/ APB_RESULT_FLOATING_NODE: The cursor is positioned inside a table row and may not"},{"entry":"\u2003\u2003\/\/ \u2003return to the same node instance if the current table row is changed."},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_OPERATION: The cursor is not positioned on a node (theCursor == \u22121)"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003setCursor(int aCursor) const = 0;"},{"entry":"\u2003\u2003\/\/ Set the cursor to the node saved using getCursor( )."},{"entry":"\u2003\u2003\/\/ It is OK to reuse a cursor on another parcel of the same ref type, but the node instance"},{"entry":"\u2003\u2003\/\/ is dependent on the current row if getCursor returned APB_RESULT_FLOATING_NODE."},{"entry":"\u2003\u2003\/\/ Returns:"},{"entry":"\u2003\u2003\/\/ APB_RESULT_FLOATING_NODE: The cursor is positioned inside a table row and may not"},{"entry":"\u2003\u2003\/\/ \u2003be at the original node instance if the current table row was changed."},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_OPERATION: The cursor is not positioned on an existing node"},{"entry":"\u2003\u2003\/\/ = SEARCHING"},{"entry":"\u2003\u2003\/\/ goto methods move cursor to matching node in the current cursor scope"},{"entry":"\u2003\u2003\/\/ If found, return true. If not found, return false and leave cursor unchanged."},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003gotoName(const AtoString& aName) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003gotoPurpose(EApfValuePurpose aPurpose) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003gotoRefNode(const IApfRefNode* aRefNode) const = 0;"},{"entry":"\u2003\u2003\/\/ find methods search the entire parcel across all scopes."},{"entry":"\u2003\u2003\/\/ If found, return APB_RESULT_OK or APB_RESULT_FLOATING_NODE and move cursor to found node."},{"entry":"\u2003\u2003\/\/ If not found, return APB_RESULT_NO_DATA and leave cursor unchanged."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003findName(const AtoString& aName) const = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003findPurpose(EApfValuePurpose aPurpose) const = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003findRefNode(const IApfRefNode* aRefNode) const = 0;"},{"entry":"\u2003\u2003\/\/ ----------------------------------------------------------------"},{"entry":"\u2003\u2003\/\/ Parcel Node operations. Methods are provided for working with"},{"entry":"\u2003\u2003\/\/ values, arrays and tables. These methods must be used in the correct"},{"entry":"\u2003\u2003\/\/ context as follows:"},{"entry":"\u2003\u2003\/\/ value nodes: nodeType must be APF_NODE_TYPE_VALUE"},{"entry":"\u2003\u2003\/\/ array nodes: nodeType must be APF_NODE_TYPE_ARRAY"},{"entry":"\u2003\u2003\/\/ table nodes: parentNodeType must be APF_NODE_TYPE_TABLE"},{"entry":"\u2003\u2003\/\/ keyed table: parentNodeType must be APF_NODE_TYPE_KEYED_TABLE"},{"entry":"\u2003\u2003\/\/ General return codes:"},{"entry":"\u2003\u2003\/\/ APB_RESULT_INACTIVE_NODE - node is currently inactive, so operation is not available"},{"entry":"\u2003\u2003\/\/ APB_RESULT_RANGE_ERROR - operation exceeded count or value range specified in XML"},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_OPERATION - operation does not match the node type"},{"entry":"\u2003\u2003\/\/ = VALUE NODES"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003valueGet(CApbValue& aValue) const = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003valueGet(uint32_t& aIntValue) const = 0;"},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_VALUE_RANGE_ERROR if the value length is greater than 32 bits."},{"entry":"\u2003\u2003virtual const AtoByteString&"},{"entry":"\u2003\u2003valueByteString( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Asserts if cursor is not at a value node"},{"entry":"\u2003\u2003\/\/ An increment can be specified to automatically construct an incrementing"},{"entry":"\u2003\u2003\/\/ set of parcels. The parcel count is specified globally for the parcel,"},{"entry":"\u2003\u2003\/\/ using IApfWriteParcel::setIterationCount( )."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003valueGetIncrement(CApbValue& aIncrement) const = 0;"},{"entry":"\u2003\u2003\/\/ = ARRAY NODES"},{"entry":"\u2003\u2003\/\/ It is an error to call the array methods when the cursor is not"},{"entry":"\u2003\u2003\/\/ at an array"},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003arrayCount( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Get count of number of items in the array"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayGetValue(CApbValue& aValue, uint32_t aIndex) const = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayGet(AtoList<CApbValue>& aList) const = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayGet(AtoVector<CApbValue>& aVector) const = 0;"},{"entry":"\u2003\u2003\/\/ = TABLE & KEYED TABLE NODES"},{"entry":"\u2003\u2003\/\/ Table methods must only be used when the cursor is at a table node."},{"entry":"\u2003\u2003\/\/ Note that there are different methods for keyed and unkeyed tables."},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003tableRows( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Return the number of rows in the table."},{"entry":"\u2003\u2003\/\/ Row iterator methods work for both keyed and unkeyed tables.."},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003tableFirstRow( ) const = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003tableNextRow( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003tableIsEnd( ) const = 0;"},{"entry":"\u2003\u2003\/\/ = UNKEYED TABLE NODES"},{"entry":"\u2003\u2003virtual int"},{"entry":"\u2003\u2003tableRowIndex( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Return the current table row, or \u22121 if there are no rows in the table"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableSetRowIndex(uint32_t aRowIndex) const = 0;"},{"entry":"\u2003\u2003\/\/ Set the current row to the specified row."},{"entry":"\u2003\u2003\/\/ = KEYED TABLE NODES"},{"entry":"\u2003\u2003\/\/ A table is keyed when there is a key column specified in the XML."},{"entry":"\u2003\u2003\/\/ The library will assert if the current parent is not a keyed table."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableSetRowKey(const CApbValue& aKeyValue) const = 0;"},{"entry":"\u2003\u2003\/\/ Moves to the row containing the specified key value."},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_VALUE_UNSPECIFIED if aKeyValue not found"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableKey(CApbValue& aKeyValue) const = 0;"},{"entry":"\u2003\u2003\/\/ Returns the value of the key field for the current row."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableListKeys(AtoVector<CApbValue>& aKeyList) const = 0;"},{"entry":"\u2003\u2003\/\/ List the keys in the table"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003tableHasKey(const CApbValue& aKeyValue) const = 0;"},{"entry":"};"},{"entry":"\/\/---------------------------------------------------------------------"},{"entry":"\/\/ = TITLE"},{"entry":"\/\/ \u2003\u2003Parcel Write Interface"},{"entry":"\/\/"},{"entry":"\/\/ = CLASS TYPE"},{"entry":"\/\/ \u2003\u2003Interface"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/ \u2003\u2003Write Interface to a parcel instance. This interface is used for"},{"entry":"\/\/ parcels created at the local parcel store."},{"entry":"class APB_EXPORT_CLASS IApfWriteParcel : public IApfReadParcel"},{"entry":"{"},{"entry":"public:"},{"entry":"\u2003\u2003virtual ~IApfWriteParcel( ) { }"},{"entry":"\u2003\u2003\/\/ = INSTANCE"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003selectNode( ) = 0;"},{"entry":"\u2003\u2003\/\/ Select the current node. (so isActive( ) returns true)"},{"entry":"\u2003\u2003\/\/ Returns:"},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_OPERATION - node is not selectable, ie"},{"entry":"\u2003\u2003\/\/ \u2003\u2003has instance=\u201coptional\u201d or a selectRef"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003deselectNode( ) = 0;"},{"entry":"\u2003\u2003\/\/ Deselect the current node. (so isActive( ) returns false)"},{"entry":"\u2003\u2003\/\/ Returns:"},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_OPERATION - node is not selectable, ie"},{"entry":"\u2003\u2003\/\/ \u2003\u2003has instance=\u201coptional\u201d or a selectRef"},{"entry":"\u2003\u2003\/\/ = NODE COPY"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isCopyTarget(const IApfReadParcel& aSource) = 0;"},{"entry":"\u2003\u2003\/\/ Determine whether this parcel is a valid target for copying the current"},{"entry":"\u2003\u2003\/\/ node or table rows the source parcel."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003copyNode(const IApfReadParcel& aSource) = 0;"},{"entry":"\u2003\u2003\/\/ Copy aSource's current node tree into this parcel"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003copyRow(const IApfReadParcel& aSource) = 0;"},{"entry":"\u2003\u2003\/\/ Copy the current row from aSource's current table or keyed table node into"},{"entry":"\u2003\u2003\/\/ the equivalent table or set in this parcel."},{"entry":"\u2003\u2003\/\/ If copying a keyed table, the row will replace any existing row with the same key."},{"entry":"\u2003\u2003\/\/ If copying an unkeyed table into a table, the row will always be added"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003copyRows(const IApfReadParcel& aSource, AtoVector<CApbValue>& selectedRows) = 0;"},{"entry":"\u2003\u2003\/\/ Copy the specified rows from a aSource's current keyed table node into the"},{"entry":"\u2003\u2003\/\/ equivalent table in this parcel. The rows will replace any existing rows with"},{"entry":"\u2003\u2003\/\/ the same key."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003copyRows(const IApfReadParcel& aSource, AtoVector<uint32_t>& selectedRows) = 0;"},{"entry":"\u2003\u2003\/\/ Copy the specified rows from a aSource's current table node into the"},{"entry":"\u2003\u2003\/\/ equivalent table in this parcel. The rows will always be added."},{"entry":"\u2003\u2003\/\/ = VALUE NODES"},{"entry":"\u2003\u2003\/\/ It is an error to call the value methods when the cursor is not"},{"entry":"\u2003\u2003\/\/ at an value"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003valueSet(const CApbValue& aValue) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003valueSet(uint32_t aValue) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003valueSetIncrement(CApbValue& aIncrement) = 0;"},{"entry":"\u2003\u2003\/\/ Incrementing values are supported for values and increments less than 128 bits."},{"entry":"\u2003\u2003\/\/ If either the value or increment is longer, returns APB_RESULT_VALUE_RANGE_ERROR."},{"entry":"\u2003\u2003\/\/ = ARRAY NODES"},{"entry":"\u2003\u2003\/\/ It is an error to call the array methods when the cursor is not"},{"entry":"\u2003\u2003\/\/ at an array"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayRemove(uint32_t aStart, uint32_t aCount = 1) = 0;"},{"entry":"\u2003\u2003\/\/ Remove aCount array items from aStart (inclusive)"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayClear( ) = 0;"},{"entry":"\u2003\u2003\/\/ Remove all permitted items in array (to minCount)"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayResize(uint32_t aCount) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayAddFirst(const CApbValue& aValue) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayAddLast(const CApbValue& aValue) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayAddBefore(const CApbValue& aValue, uint32_t aIndex) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arrayAddAfter(const CApbValue& aValue, uint32_t aIndex) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arraySetValue(const CApbValue& aValue, uint32_t aIndex) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arraySet(const AtoList<CApbValue>& aList) = 0;"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003arraySet(const AtoVector<CApbValue>& aVector) = 0;"},{"entry":"\u2003\u2003\/\/ = TABLE OPERATIONS"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableRemoveRow( ) = 0;"},{"entry":"\u2003\u2003\/\/ Remove the current table row"},{"entry":"\u2003\u2003EApbResult"},{"entry":"\u2003\u2003tableClear( );"},{"entry":"\u2003\u2003\/\/ Clear all rows in the table"},{"entry":"\u2003\u2003\/\/ UNKEYED TABLE"},{"entry":"\u2003\u2003\/\/ A table is unkeyed when there is no key column specified in the XML."},{"entry":"\u2003\u2003\/\/ These methods will return APB_RESULT_INVALID_OPERATION if table has a key,"},{"entry":"\u2003\u2003\/\/ or are attempting to resize the table beyond its specified row limits."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableResize(uint32_t aNumRows) = 0;"},{"entry":"\u2003\u2003\/\/ tableResize will set the current row to the first row"},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_INVALID_OPERATION if node is not a keyed table"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableAddLast( ) = 0;"},{"entry":"\u2003\u2003\/\/ Add a new row to the end of table. The new row becomes the current row."},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_INVALID_OPERATION if node is not a keyed table"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableAddBefore( ) = 0;"},{"entry":"\u2003\u2003\/\/ Add a new row before the current row. The new row becomes the current row."},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_INVALID_OPERATION if node is not a keyed table"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableAddAfter( ) = 0;"},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_INVALID_OPERATION if node is not a keyed table"},{"entry":"\u2003\u2003\/\/ KEYED TABLE"},{"entry":"\u2003\u2003\/\/ A table is keyed when there is a key column specified in the XML."},{"entry":"\u2003\u2003\/\/ These methods will return APB_RESULT_INVALID_OPERATION if table has no key,"},{"entry":"\u2003\u2003\/\/ or is attempting to resize the table beyond its specified row limits."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableAddRow(const CApbValue& keyValue) = 0;"},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_INVALID_OPERATION if duplicate key value"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003tableRemoveRow(const CApbValue& keyValue) = 0;"},{"entry":"\u2003\u2003\/\/ Returns APB_RESULT_INVALID_OPERATION if keyValue not found"},{"entry":"\u2003\u2003\/\/ = MULTI-EDIT"},{"entry":"\u2003\u2003\/\/ Multi-edit features are only available on write parcels"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isMultiEditParcel( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Query whether the parcel is a multi-edit parcel."},{"entry":"\u2003\u2003\/\/ = NODE MARKING"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003parcelResetChangeMarks( ) = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isParcelChanged( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isNodeChanged( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isRowChanged( ) const = 0; \/\/ applies to table and keyed table nodes"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isIncrementChanged( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isNodeCommon( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isIncrementCommon( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isNodeOverridden( ) const = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isIncrementOverridden( ) const = 0;"},{"entry":"};"},{"entry":"#endif \/\/ APF_PARCEL_H"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"It may be preferable to provide a series of routines for the management of parcels. Such management can be provided by the client applications, e.g. the host  and the protocol emulator card  in the embodiment shown in . However, it may prove beneficial to provide a collection of management routines which may be linked to by the client applications, such routines are collectively referred to herein as a parcel store. Preferably, a parcel store is provided by each software component that communicates using parcels. By way of example a parcel store may be responsible for: creating parcels on behalf of clients; encoding and sending parcels to a destination parcel store (e.g. serialization); decoding and buffering incoming parcels from another parcel store; and notifying clients when new parcel data is available. Table 9 provides a sample of self-documented code for an interface to a parcel store.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#ifndef APF_PARCEL_STORE_H"},{"entry":"#define APF_PARCEL_STORE_H"},{"entry":"\/\/ =========================================================================="},{"entry":"\/\/"},{"entry":"\/\/ = LIBRARY"},{"entry":"\/\/ \u2003\u2003APF Agilent Protocol Framework"},{"entry":"\/\/"},{"entry":"\/\/ = FILENAME"},{"entry":"\/\/ \u2003\u2003ApfParcelStore.h"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/"},{"entry":"\/\/ Interface to the parcel store"},{"entry":"\/\/"},{"entry":"\/\/ = AUTHORS"},{"entry":"\/\/ \u2003\u2003Geoff Smith"},{"entry":"\/\/"},{"entry":"\/\/ = COPYRIGHT"},{"entry":"\/\/ \u2003\u2003(C) Copyright 2004 Agilent Technologies"},{"entry":"\/\/"},{"entry":"\/\/ =========================================================================="},{"entry":"#include \u201cemuframework\/include\/apfParcel.h\u201d"},{"entry":"class IApfParcelBuffer;"},{"entry":"\/\/---------------------------------------------------------------------"},{"entry":"\/\/ = TITLE"},{"entry":"\/\/ \u2003\u2003Parcel Store"},{"entry":"\/\/"},{"entry":"\/\/ = CLASS TYPE"},{"entry":"\/\/ \u2003\u2003Interface"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/ Client interface to the Parcel Store"},{"entry":"class APB_EXPORT_CLASS IApfParcelStore"},{"entry":"{"},{"entry":"public:"},{"entry":"\u2003\u2003\/\/ = FOUNDATION"},{"entry":"\u2003\u2003virtual ~IApfParcelStore( ) { }"},{"entry":"\u2003\u2003\/\/ = ACCESS"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003listSessions(AtoVector<uint32_t>& sessionList) const = 0;"},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003port(uint32_t aSession) const = 0;"},{"entry":"\u2003\u2003virtual IApfRefEmulation*"},{"entry":"\u2003\u2003refEmulation(uint32_t aSession) const = 0;"},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003maxIteration(uint32_t aSession) const = 0;"},{"entry":"\u2003\u2003\/\/ = OUTGOING PARCELS"},{"entry":"\u2003\u2003virtual IApfWriteParcel*"},{"entry":"\u2003\u2003createParcel(uint32_t aSession, const AtoString& aParcelName) = 0;"},{"entry":"\u2003\u2003\/\/ Specify aSession = 0 for a global parcel"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003deleteParcel(uint32_t aSession, IApfWriteParcel* pParcel) = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003sendParcel(uint32_t aSession, IApfWriteParcel* pParcel) = 0;"},{"entry":"\u2003\u2003\/\/ Specify aSession = 0 for global parcels."},{"entry":"\u2003\u2003\/\/ = PARCEL FUNCTIONS"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003refreshParcel(uint32_t aSession, IApfWriteParcel* pParcel) = 0;"},{"entry":"\u2003\u2003\/\/ For duplex parcels only. Copies the most recent read-only parcel into the write parcel"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003copyParcel(uint32_t aSession, const IApfReadParcel* pParcelIn, IApfWriteParcel* pParcelOut) = 0;"},{"entry":"\u2003\u2003\/\/ Copy parcel pParcelIn to new parcel pParcelOut"},{"entry":"\u2003\u2003\/\/ pParcelOut may or may not already exist"},{"entry":"\u2003\u2003\/\/ = Multi-Edit"},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003createMultiEditParcel(uint32_t aSession, AtoVector<IApfWriteParcel*>& aSelectedParcels,"},{"entry":"\u2003\u2003IApfWriteParcel** ppMultiEditParcel) = 0;"},{"entry":"\u2003\u2003\/\/ Create a multi-edit parcel from the selected parcels, which must all be share the same IApfRefParcel type."},{"entry":"\u2003\u2003\/\/ The multi-edit parcel may be modified as an ordinary parcel, and the changes subsequently"},{"entry":"\u2003\u2003\/\/ applied to all the selected parcels. However, a multi-edit parcel may not be sent to the destination."},{"entry":"\u2003\u2003\/\/ Returns:"},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_INTERFACE - at least of the selected Pdus does not exist"},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_OPERATION - unable to identify common element structure across selectedPdus."},{"entry":"\u2003\u2003virtual EApbResult"},{"entry":"\u2003\u2003applyMultiEditParcel(uint32_t aSession, IApfWriteParcel* pMultiEditParcel,"},{"entry":"\u2003\u2003AtoList<IApfWriteParcel*>& aChangedParcels) = 0;"},{"entry":"\u2003\u2003\/\/ Apply a multi-edit parcel to each of the parcels from which it was originally created, and which still"},{"entry":"\u2003\u2003\/\/ remain in the parcel store. A list of changed parcels is returned to the client."},{"entry":"\u2003\u2003\/\/ Only changes that have been specifically made to the multi-edit parcel will be applied to each changed parcel."},{"entry":"\u2003\u2003\/\/ Returns:"},{"entry":"\u2003\u2003\/\/ APB_RESULT_INVALID_INTERFACE - pMultiEditParcel is not a valid multi-edit parcel"},{"entry":"\u2003\u2003\/\/ = INCOMING COMMAND PARCELS"},{"entry":"\u2003\u2003\/\/ A client may subscribe to be notified on receipt of specific command parcels."},{"entry":"\u2003\u2003\/\/ Specify aSession = 0 for global commands"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003subscribeCommandParcel(uint32_t aSession, const AtoString& aParcelName,"},{"entry":"AtoObserverBC<IApfReadParcel>& aObserver) = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003unsubscribeCommandParcel(uint32_t aSession, const AtoString& aParcelName,"},{"entry":"AtoObserverBC<IApfReadParcel>& aObserver) = 0;"},{"entry":"\u2003\u2003\/\/ = INCOMING PARCEL BUFFERS"},{"entry":"\u2003\u2003\/\/ Incoming session parcels are buffered according to the parcel's buffer type."},{"entry":"\u2003\u2003\/\/ Access to the parcel is via the IApfParcelBuffer interface."},{"entry":"\u2003\u2003\/\/ Specify aSession = 0 for global parcels."},{"entry":"\u2003\u2003virtual IApfParcelBuffer*"},{"entry":"\u2003\u2003getBufferByName(uint32_t aSession, const AtoString& aParcelName) const = 0;"},{"entry":"\u2003\u2003virtual IApfparcelBuffer*"},{"entry":"\u2003\u2003getBufferByClass(uint32_t aSession, EApfParcelClass aClass) const = 0;"},{"entry":"};"},{"entry":"\/\/---------------------------------------------------------------------"},{"entry":"\/\/ = TITLE"},{"entry":"\/\/ \u2003\u2003Parcel Buffer"},{"entry":"\/\/"},{"entry":"\/\/ = CLASS TYPE"},{"entry":"\/\/ \u2003\u2003Interface"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/ Interface to a incoming parcel buffer. The buffer provides access to"},{"entry":"\/\/ a single parcel object, which exists for the lifetime of the buffer."},{"entry":"\/\/ Depending on the buffer type, incoming parcel updates may be queued, or"},{"entry":"\/\/ automatically applied to the parcel object as follows:"},{"entry":"\/\/ Buffer type Action"},{"entry":"\/\/ RETAIN & FIFO Queue incoming parcels and leave parcel object unchanged, unless"},{"entry":"\/\/ \u2003\u2003\u2003parcel object is currently CLOSED."},{"entry":"\/\/ NEWEST & FETCH Update the parcel object with the incoming parcel"},{"entry":"class APB_EXPORT_CLASS IApfParcelBuffer"},{"entry":"{"},{"entry":"public:"},{"entry":"\u2003\u2003\/\/ = FOUNDATION"},{"entry":"\u2003\u2003virtual ~IApfParcelBuffer( ) { }"},{"entry":"\u2003\u2003\/\/ = PARCEL EVENTS"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003subscribeBufferUpdates(AtoObserverBC<IApfParcelBuffer*>& anObserver) = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003unsubscribeBufferUpdates(AtoObserverBC<IApfparcelBuffer*>& anObserver) = 0;"},{"entry":"\u2003\u2003virtual bool"},{"entry":"\u2003\u2003isObsolete( ) const = 0;"},{"entry":"\u2003\u2003\/\/ An obsolete buffer is in the process of being deleted, because the session"},{"entry":"\u2003\u2003\/\/ is being removed. Any observers at that point are notified, so that they"},{"entry":"\u2003\u2003\/\/ may immediately unsubscribe and take any remedial action."},{"entry":"\u2003\u2003\/\/ For this reason, client observers should always check if the buffer is obsolete."},{"entry":"\u2003\u2003\/\/ = ACCESS"},{"entry":"\u2003\u2003virtual EApfBufferType"},{"entry":"\u2003\u2003bufferType( ) const = 0;"},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003sessionHandle( ) const = 0;"},{"entry":"\u2003\u2003virtual IApfReadParcel&"},{"entry":"\u2003\u2003parcel( ) = 0;"},{"entry":"\u2003\u2003virtual const IApfReadParcel&"},{"entry":"\u2003\u2003parcel( ) const = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003fetchUpdate( ) = 0;"},{"entry":"\u2003\u2003\/\/ Send a request to the parcel's server to send the parcel. Intended primarily"},{"entry":"\u2003\u2003\/\/ for buffer type == FETCH. This method must be used to update the parcel if the"},{"entry":"\u2003\u2003\/\/ current parcel state is CLOSED."},{"entry":"\u2003\u2003\/\/ = BUFFER MANAGEMENT (FIFO and RETAIN buffer types only)"},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003bufferCount( ) const = 0;"},{"entry":"\u2003\u2003\/\/ See setMaxParcelCount( ) below"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003popBuffer( ) = 0;"},{"entry":"\u2003\u2003\/\/ Refresh the parcel with the next parcel in the buffer. Client must ensure"},{"entry":"\u2003\u2003\/\/ that bufferCount( ) is > 0. popBuffer( ) reduces the buffer count by 1."},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003useBuffer(uint32_t aIndex) = 0;"},{"entry":"\u2003\u2003\/\/ Refresh the parcel with the specified buffer entry. Client must ensure"},{"entry":"\u2003\u2003\/\/ that aIndex < parcelCount( ). setParcel( ) does not affect the parcel count."},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003deleteBuffer(uint32_t aIndex) = 0;"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003clearBuffers( ) = 0;"},{"entry":"\u2003\u2003\/\/ Delete all buffers"},{"entry":"\u2003\u2003\/\/ The parcel buffer has a default max buffer count of 1. This avoids"},{"entry":"\u2003\u2003\/\/ the possiblity of a memory leak caused by multiple proxies receiving parcels into"},{"entry":"\u2003\u2003\/\/ FIFO or RETAIN buffers, when not all proxies have an active client to manage the"},{"entry":"\u2003\u2003\/\/ buffer."},{"entry":"\u2003\u2003\/\/ If a client wants a buffer to hold more than one parcel, it sets the max count"},{"entry":"\u2003\u2003\/\/ explicitly."},{"entry":"\u2003\u2003virtual uint32_t"},{"entry":"\u2003\u2003maxBufferCount( ) const = 0;"},{"entry":"\u2003\u2003\/\/ Default = 1. Adjust using setMaxBufferCount( )"},{"entry":"\u2003\u2003virtual void"},{"entry":"\u2003\u2003setMaxBufferCount(uint32_t aCount) = 0;"},{"entry":"\u2003\u2003\/\/ Effective only for RETAIN and FIFO buffers."},{"entry":"};"},{"entry":"#endif\/\/ APF_PARCEL_STORE_H"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"One basic function of the afore-described parcel store that may be desirable in any messaging system is buffering. In general, buffering means the temporary holding of parcels until the receiving (or transmitting) system is prepared to process the information contained in the parcel. For example, parcels can be pulled by a client from a buffer on the transmitting side when needed to minimize host load. Alternatively, parcels can be pushed by the transmitting side to a variety of types of buffers on the receiving side to optimize responsiveness. The type of buffer can be specified in the XML parcel definition and made known by the parcel reference model. Alternatively the type could be determined based on information in the serialized parcel. The application can be performance tuned by adjusting the parcel buffer types in the XML without impacting the client interface or requiring software to be re-written or re-compiled.","Some examples of suitable buffer types are disclosed in Table 10:",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Buffer",{}]},{"entry":["Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["retain","(Push) Each new parcel version received is retained in a circular"]},{"entry":[{},"buffer until deleted by the client"]},{"entry":["fifo","(Push) Parcels are placed in a FIFO buffer and deleted from the"]},{"entry":[{},"buffer when read by the client"]},{"entry":["newest","(Push) The buffered parcel is replaced by the most recent"]},{"entry":[{},"incoming version. Parcels with a root key specified may be"]},{"entry":[{},"consolidated according to the key value. This feature allows"]},{"entry":[{},"parcels from many sources to be automatically consolidated into"]},{"entry":[{},"a summary parcel at the destination."]},{"entry":["fetch","(Pull) Parcels are not sent to the destination store until requested"]},{"entry":[{},"by the destination"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"To conserve bandwidth, parcels may be serialized prior to sending. As used here the term serialization generally refers to a process whereby the data in a parcel is stripped out and arranged in a serial manner, typically based on the index of each of the elements. A minimal amount of identification material is provided in the header of the serialized parcel to enable the reconstruction of the parcel on the receiving end. Table 11 describes one possible process of serialization for the various elements of a parcel.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Parcel entity","How it is serialized"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Value (empty)","1 byte code = PCL_NODE_DATA_EMPTY"]},{"entry":["Value (<=8 bits long)","1 byte code = PCL_NODE_DATA_INT8 + 1 byte data"]},{"entry":["Value (8 < length <= 32 bits)","1 byte code = PCL_NODE_DATA_INT32 + 4 bytes data"]},{"entry":["Value (32 < length <= 255 bits)","1 byte code = PCL_NODE_DATA_BS255 + 1 byte length + length"]},{"entry":[{},"bytes data"]},{"entry":["Value length >= 255 bits","1 byte code = PCL_NODE_DATA_BSLONG + 4 bytes length +"]},{"entry":[{},"length bytes data"]},{"entry":["Array","Array count saved as a value + count values"]},{"entry":["Set","Each member saved in sequence"]},{"entry":["Table","Row count saved as a value + count sets"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Although certain embodiments of the present invention have been shown and described, it will be appreciated by those skilled in the art that changes may be made in these embodiments without departing from the principles and spirit of the invention, the scope of which is defined in the claims and their equivalents.","For example, one benefit of using a parcel structure, including definition and reference model is that the construction of graphical user interface (GUI) elements can be automated. In other words the contents of a parcel can be displayed using a format that is derived based upon the parcel itself. By parsing the parcel definition or reference model an interface can be built on the fly. Such an interface can be used for viewing the contents of a packet or packet creation and editing.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 13"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<parcel name=\u201csessionSummary\u201d"]},{"entry":[{},"\u2003\u2003<table name=\u201csessions\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cName\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cProtocol\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cState\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cTester\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cSUT\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/table>"]},{"entry":[{},"<\/parcel>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 7","FIG. 7"]},{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 14"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<parcel name=\u201cbgpSessionData\u201d"]},{"entry":[{},"\u2003\u2003<value name=\u201cType\u201d\/>"]},{"entry":[{},"\u2003\u2003<set name=\u201cPeers\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<set name=\u201cTester\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cIP address\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cAS number\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/set>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<set name=\u201cSUT\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cIP address\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cAS number\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/set>"]},{"entry":[{},"\u2003\u2003<\/set>"]},{"entry":[{},"\u2003\u2003<set name=\u201cTimers\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cHold time\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cKeep-alive time\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cConnection retry\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/set>"]},{"entry":[{},"\u2003\u2003<set name=\u201cNotification\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cError code\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<value name=\u201cError sub-code\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/set>"]},{"entry":[{},"<\/parcel>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Another example of changes may be made in these embodiments without departing from the principles and spirit of the invention is the provision of a facility to iteratively create parcel instances. For example, should a series of parcel be desirable wherein one or more values differ as between parcels, an iterative function can be provided defining those parcel values in relative terms, such as +1. In this way a single parcel can be used to parametrically generate many different parcels through use of parcel iteration. Using the example of a protocol emulation application, it may be desirable to create a session pool of many sessions, defined using just one session's parcels. This can be implemented by tagging certain values in the XML model with default increment attributes. The increment is used to adjust each value for each iteration of the parcel. For example, a value may specify a default increment of \u201c10\u201d. If in the first parcel, the value is 50, when the parcel is iterated once, the value will be 60. If the parcel is iterated twice, the value will be 70. The default increment can also be calculated by an increment function. This allows the default increment value to be intelligently assigned based on other values in the parcel."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["An understanding of the present invention can be gained from the following detailed description of certain embodiments of the present invention, taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
