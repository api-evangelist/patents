---
title: Block-partitioned technique for solving a system of linear equations represented by a matrix with static and dynamic entries
abstract: One embodiment of the present invention provides a system that uses a block-partitioned technique to efficiently solve a system of linear equations. The system first receives a matrix that specifies the system of linear equations to be used in performing a time-based simulation. This matrix includes a static portion containing entries that remain fixed over multiple time steps in the time-based simulation, as well as a dynamic portion containing entries that change between time steps in the time-based simulation. Next, the system performs the time-based simulation, wherein performing the time-based simulation involves solving the system of linear equations for each time step in the time-based simulation. In solving the system of linear equations, the system factorizes the static portion of the matrix only once, and reuses the factorization of the static portion in performing an overall factorization of the matrix for each time step of the time-based simulation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07089275&OS=07089275&RS=07089275
owner: SUN Microsystems, Inc.
number: 07089275
owner_city: Santa Clara
owner_country: US
publication_date: 20030129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates to computer systems for performing sparse matrix computations. More particularly, the present invention relates to a method and an apparatus that uses a block-partitioned technique to efficiently solve sparse systems of linear equations.","2. Related Art","The solution of large sparse symmetric linear systems of equations constitutes the primary computational cost in numerous applications, such as finite-element design, linear programming, circuit simulation and semiconductor device modeling. Efficient solution of such systems has long been the subject of research, and considerable progress has been made in developing efficient algorithms to this end. A direct solution technique known as \u201cCholesky Factorization\u201d is the most widely used approach to solve such a system. Under Cholesky factorization, the complete solution sequence requires many stages, including matrix reordering, symbolic factorization, numerical factorization and triangular solution. Of these stages, numerical factorization is typically the most computationally expensive.","One method of performing numerical factorization is based on a right-looking supernode-supernode method described in \u201cParallel Algorithms for Sparse Linear Systems\u201d by Michael T. Heath, Esmond Ng and Barry W. Peyton, in \u201cParallel Algorithms for Matrix Computations\u201d by Gallivan, et al. (Editors), SIAM (1994) (referred to as HNP). In a sparse matrix, a supernode is a set of contiguous columns that have essentially the same sparsity structure. Supernodes can be used to organize the numerical factorization stage around matrix-vector (supernode-column) and matrix-matrix (supernode-supernode) primitive operations leading to a substantial performance improvement arising from more efficient use of the processor caches and pipelining units.","In some applications, for example circuit simulation, existing numerical factorization techniques perform unnecessary work because the matrix system arising in such simulations is only partially modified from one time step to the next in a time-dependent simulation. For example, in a circuit simulation, linear circuit elements, such as resistors and capacitors, do not change from one time step to the next. In contrast, non-linear components, such as diodes, exhibit a nonlinear relationship between current and voltage and are typically time-dependent. Hence, the matrix system for simulating the circuit includes some static entries that remain fixed over many time steps, and some dynamic entries that change from one time step to the next. This means that the much of the work involved in factorizing the static entries every time step is largely wasted because the static entries do not change between time steps.","Hence, what is needed is a method and an apparatus for solving systems of linear equations without performing unnecessary work in factorizing static matrix entries.","One embodiment of the present invention provides a system that uses a block-partitioned technique to efficiently solve a system of linear equations. The system first receives a matrix that specifies the system of linear equations to be used in performing a time-based simulation. This matrix includes a static portion containing entries that remain fixed over multiple time steps in the time-based simulation, as well as a dynamic portion containing entries that change between time steps in the time-based simulation. Next, the system performs the time-based simulation, wherein performing the time-based simulation involves solving the system of linear equations for each time step in the time-based simulation. In solving the system of linear equations, the system factorizes the static portion of the matrix only once, and reuses the factorization of the static portion in performing an overall factorization of the matrix for each time step of the time-based simulation.","In a variation on this embodiment, prior to receiving the matrix, the system generates the matrix from the system of linear equations, and in doing so organizes the matrix into disjoint static and dynamic portions.","In a variation on this embodiment, wherein the static portion is located within an upper-diagonal block of the matrix, and the dynamic portion includes a lower-diagonal block of the matrix, as well as off-diagonal blocks located between the upper-diagonal block and the lower-diagonal block.","In a variation on this embodiment, the time-based simulation involves a simulation of a circuit. This circuit includes linear elements, which do not change between time steps in the time-based simulation, as well as non-linear elements, which change between time steps in the time-based simulation. In this variation, the upper-diagonal block of the matrix represents connections between static elements of the circuit, and the lower-diagonal block of the matrix represents connections between dynamic elements of the circuit. Similarly, the off-diagonal blocks of the matrix represent connections between dynamic and static elements of the circuit.","In a variation on this embodiment, the system of linear equations is a sparse system of linear equations and the matrix is a sparse matrix.","In a variation on this embodiment, solving the system of linear equations involves using sparse matrix techniques on the static portion of the matrix and using dense matrix techniques on the dynamic portion of the matrix.","In a variation on this embodiment, solving the system of linear equations involves using sparse matrix techniques on both the static and dynamic portions of the matrix.","In a further variation, the sparse matrix, and other data structures used in solving the sparse system of linear equations, are represented in Harwell-Boeing format.","In a variation on this embodiment, solving the system of linear equations involves using a technique based on Cholesky factorization to solve the system of linear equations.","The following description is presented to enable any person skilled in the art to make and use the invention, and is provided in the context of a particular application and its requirements. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present invention. Thus, the present invention is not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.","The data structures and code described in this detailed description are typically stored on a computer readable storage medium, which may be any device or medium that can store code and\/or data for use by a computer system. This includes, but is not limited to, magnetic and optical storage devices such as disk drives, magnetic tape, CDs (compact discs) and DVDs (digital versatile discs or digital video discs), and computer instruction signals embodied in a transmission medium (with or without a carrier wave upon which the signals are modulated). For example, the transmission medium may include a communications network, such as the Internet.","Computer System",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 1","FIG. 1"],"b":["102","104","106","108","114","110","112"]},"Core logic unit  couples CPU  with memory . CPU  may include any type of computational engine for executing programs within the computer system. This includes, but is not limited to, a microprocessor, a device controller and a computational device within an appliance. Memory  may include any type of random access memory for storing code and data for use by CPU . As illustrated in , memory  includes sparse matrix code  for solving systems of linear equations involving sparse matrices. Core logic unit  includes circuitry for interconnecting various computer system components, including CPU , memory  and bus .","Bus  couples core logic unit  with display , keyboard  and disk . Bus  may include any type of communication channel for coupling core logic unit  with peripheral devices, such as display , keyboard  and disk . Display  may include any type of device for displaying images from a computer system. Disk  may include any type of non-volatile storage device for storing code and data to for use by CPU . This includes, but is not limited to, magnetic storage devices, such as a disk drive, and electronic storage devices, such as flash memory or battery backed up RAM. Keyboard  may include any type of device for inputting data into the computing system. This includes input devices such as a keyboard and a mouse.","Note that although a specific computer system architecture is illustrated in , the present invention may be used with any computational device that can execute a computer program.","Cholesky Factorization",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},"One way to solve the linear system is to first compute the Cholesky factorization A=LL, where the Cholesky factor L is a lower triangular matrix with positive definite diagonal elements. Then the solution vector x can be computed by successive forward and back substitutions to solve the triangular systems Ly=b and Lx=y\u2033 (see page 84 of HNP above).","As mentioned above, the Cholesky factorization approach involves a number of operations, including prefactorzation operations, such as matrix reordering (step ), symbolic factorization (step ), as well as numerical factorization (step ) and triangular solution (step ). The matrix reordering step  involves shuffling around the rows and columns of the sparse matrix so that \u201cfill in\u201d gets reduced. During numerical factorization, \u201cfill in\u201d increases the number of non-zero elements in the sparse matrix and hence reduces computational performance.","The symbolic factorization step  determines which entries will become non-zero values and also identifies supernodes. As mentioned above, a supernode is a set of contiguous columns that have essentially the same sparsity structure. Supernodes can be used to organize the numerical factorization stage around matrix-vector (supernode-column) and matrix-matrix (supernode-supernode) primitive operations leading to a substantial performance improvement arising from more efficient use of the caches and pipelining units. The symbolic factorization step  also involves allocating memory needed to solve the sparse matrix.","Next, the numerical factorization step  is performed using Gaussian elimination (or some equivalent solution technique) on the sparse matrix. Note that this generally requires O(n) time for an n\u00d7n dense matrix.","Finally, the triangular solution step  solves the remaining triangular system of equations.","Of the four above-listed operations, the numerical factorization (step ) consumes most of the computational time.","Solver","The solver according to one embodiment of the present invention is based on a right-looking supernode-supernode method (see HNP). In a sparse matrix, \u201csupernodes\u201d are a set of contiguous columns that have essentially the same sparsity structure and are key to computational efficiency in the factorization step. The columns in a supernode can be treated as a unit for both computation and storage. These supernodes can be used to organize the whole factorization stage around matrix-vector (supernode-column) and matrix-matrix (supernode-supernode) like primitives leading to a substantial performance improvement (due to more efficient use of the processor caches and pipelining units).","In one embodiment of the present invention, we use this solver as an underlying tool and use a block-partitioned factorization framework on top of it to handle partially modified matrix systems.","The technique developed to solve the above-mentioned problem comprises several steps. In what follows, we will first outline the underlying mathematical treatment and then cover implementation-specific details.","The Problem","Recall the problem being solved is solution of a sparse linear system of equations Ax=b, where A is an n\u00d7n sparse symmetric positive-definite matrix. We can decompose A into a block representation as follows,",{"@attributes":{"id":"p-0040","num":"0039"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"A","mo":"=","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"A","mn":"11"}},{"msub":{"mi":"A","mn":"12"}}]},{"mtd":[{"msub":{"mi":"A","mn":"21"}},{"msub":{"mi":"A","mn":"22"}}]}]}}}}},"br":{},"sub":"11 "},"A, Aand Acollectively represent the dynamic portion of the matrix. The off-diagonal dynamic blocks, A, A, represent the connections between the time-dependent and static elements of the circuit. The diagonal-dynamic block, A, represents the inter-connections between the time-dependent elements in the circuit (also see ).","Note that the exact zero\/non-zero structure of A depends on the circuit topology and will be different for different circuits. Also note that since A is symmetric and positive definite, it can be shown that Aand Aare also symmetric and positive definite. Furthermore, note that since A is symmetric, A=Awhere the superscript \u201cT\u201d represents \u201ctranspose.\u201d Let","A: N\u00d7N","A: N\u00d7N","A: N\u00d7N","A: N\u00d7N","wherein N+N=N, and wherein bf=N\/N (0\u2266bf\u22661) is called the \u201cblock divider.\u201d","We now describe a block-partitioning technique that allows us to factorize Aonce and use the resulting factorization to update the factorization of the A, Aand Ablocks.","Let P be a permutation matrix (determined so as to minimize the fill-in during factorization of A). P is represented as,",{"@attributes":{"id":"p-0049","num":"0048"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"P","mo":"=","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"P","mn":"1"}},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mi":"I"}]}]}}}}},"br":{},"sub":["1 ","1","1 ","11","2","2 "],"sup":["\u22121","T "]},"The overall sequence in the Ax=b solution comprises (see HNP)","A\u2032=P*A*P(fill-reducing permutation of A);","A\u2032=L*D*L(factorization of A\u2032);","L*y=P*b (forward elimination);","(D*L)*x\u2032=y (back-substitution); and","x=(P)*x\u2032 (inverse permutation).","Now we will apply above steps to the block-partitioned representation. For the sake of brevity, in what follows we will refer to fill-reducing permutation and factorization step as factorization stage forward-elimination, back-substitution and inverse permutation steps as the \u201csolution stage.\u201d","Factorization Stage",{"@attributes":{"id":"p-0057","num":"0056"},"maths":[{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["A","\u2032"]},"mo":"=","mrow":{"mrow":[{"mi":["P","A"],"mo":["*","*"],"mrow":{"mrow":[{"msup":{"mi":["P","T"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"P","mn":"1"}},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mi":"I"}]}]}}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"A","mn":"11"}},{"msub":{"mi":"A","mn":"12"}}]},{"mtd":[{"msub":{"mi":"A","mn":"21"}},{"msub":{"mi":"A","mn":"22"}}]}]}}],"mo":"\u2061"}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"A","mn":"11"}],"mo":["*","*"],"msubsup":{"mi":["P","T"],"mn":"1"}}},{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"A","mn":"12"}],"mo":"*"}}]},{"mtd":[{"mrow":{"msub":{"mi":"A","mn":"21"},"mo":"*","msubsup":{"mi":["P","T"],"mn":"1"}}},{"msub":{"mi":"A","mn":"22"}}]}]}}],"mo":"="}}}},{"@attributes":{"id":"MATH-US-00003-2","num":"00003.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["A","\u2032"]},"mo":"=","mrow":{"mrow":[{"mi":["L","D"],"mo":["*","*"],"mrow":{"msup":{"mi":["L","T"]},"mo":["\u2062","[","]"],"mstyle":{"mtext":{}},"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"A","mn":"11"}],"mo":["*","*"],"msubsup":{"mi":["P","T"],"mn":"1"}}},{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"A","mn":"12"}],"mo":"*"}}]},{"mtd":[{"mrow":{"msub":{"mi":"A","mn":"21"},"mo":"*","msubsup":{"mi":["P","T"],"mn":"1"}}},{"msub":{"mi":"A","mn":"22"}}]}]}}},{"mrow":[{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"L","mn":"11"}},{"mn":"0"}]},{"mtd":[{"msub":{"mi":"Z","mn":"1"}},{"msub":{"mi":"L","mn":"22"}}]}]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"D","mn":"11"}},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"msub":{"mi":"D","mn":"22"}}]}]}}],"mo":"\u2061"},{"mo":["\u2003","\u2062"],"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msubsup":{"mi":["L","T"],"mn":"11"}},{"msubsup":{"mi":["Z","T"],"mn":"1"}}]},{"mtd":[{"mn":"0"},{"msubsup":{"mi":["L","T"],"mn":"22"}}]}]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":[{"mi":"L","mn":"11"},{"mi":"D","mn":"11"}],"mo":["*","*"],"msubsup":{"mi":["L","T"],"mn":"11"}}},{"mrow":{"msub":[{"mi":"L","mn":"11"},{"mi":"D","mn":"11"}],"mo":["*","*"],"msubsup":{"mi":["Z","T"],"mn":"1"}}}]},{"mtd":[{"mrow":{"msub":[{"mi":"Z","mn":"1"},{"mi":"D","mn":"11"}],"mo":["*","*"],"msubsup":{"mi":["L","T"],"mn":"11"}}},{"mrow":{"mrow":[{"msub":[{"mi":"L","mn":"22"},{"mi":"D","mn":"22"}],"mo":["*","*"],"msubsup":{"mi":["L","T"],"mn":"22"}},{"msub":[{"mi":"Z","mn":"1"},{"mi":"D","mn":"11"}],"mo":["*","*"],"msubsup":{"mi":["Z","T"],"mn":"1"}}],"mo":"+"}}]}]}}],"mo":["=","\u2062"],"mstyle":{"mtext":{}}},"mstyle":{"mspace":{"@attributes":{"width":"4.7em","height":"4.7ex"}}}}],"mo":"\u2062"}],"mo":"="}}}}]},"The factorization stage thus can be accomplished through the following steps:","(i) Compute P*A*P=L*D*L(LDLfactorization of A). Note that since Ais the static part of the matrix, this step needs to be done only once.","(ii) Compute L*D*Z=P*A. Note that Zis N\u00d7Nin size, this step just represents forward elimination on a collection of right-hand-sides. Also note that P*A(row permutation of A) is sparse and as we will see later, it is important to exploit this sparsity for performance.","(iii) Compute A\u2032=A\u2212Z*D*Z. Note that this step requires Z*D*Z(matrix-matrix multiplication).","(iv) Compute A\u2032=L*D*L(LDLfactorization of A\u2032). Note that in this step, we do the factorization on a permuted A\u2032 (i.e. A\u2033=P*A\u2032*P). This can be done without affecting other steps in the algorithm.","Solution Stage","Let",{"@attributes":{"id":"p-0064","num":"0063"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"y","mn":"1"}}},{"mtd":{"msub":{"mi":"y","mn":"2"}}}]}},{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"D","mn":"11"},"mo":"*","msubsup":{"mi":["L","T"],"mn":"1"}}},{"mrow":{"msub":{"mi":"D","mn":"11"},"mo":"*","msubsup":{"mi":["Z","T"],"mn":"1"}}}]},{"mtd":[{"mn":"0"},{"mrow":{"msub":{"mi":"D","mn":"22"},"mo":"*","msubsup":{"mi":["L","T"],"mn":"22"}}}]}]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"x","mn":"1"}],"mo":"*"}}},{"mtd":{"msub":{"mi":"x","mn":"2"}}}]}}],"mo":"\u2061"}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0065","num":"0064"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"L","mn":"11"}},{"mn":"0"}]},{"mtd":[{"msub":{"mi":"Z","mn":"1"}},{"msub":{"mi":"L","mn":"22"}}]}]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"y","mn":"1"}}},{"mtd":{"msub":{"mi":"y","mn":"2"}}}]}}],"mo":"\u2061"},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"b","mn":"1"}],"mo":"*"}}},{"mtd":{"msub":{"mi":"b","mn":"2"}}}]}}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0066","num":"0065"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"D","mn":"11"},"mo":"*","msubsup":{"mi":["L","T"],"mn":"11"}}},{"mrow":{"msub":{"mi":"D","mn":"11"},"mo":"*","msubsup":{"mi":["Z","T"],"mn":"1"}}}]},{"mtd":[{"mn":"0"},{"mrow":{"msub":{"mi":"D","mn":"22"},"mo":"*","msubsup":{"mi":["L","T"],"mn":"22"}}}]}]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msubsup":{"mi":["x","\u2032"],"mn":"1"}}},{"mtd":{"msubsup":{"mi":["x","\u2032"],"mn":"2"}}}]}}],"mo":"\u2061"},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"y","mn":"1"}}},{"mtd":{"msub":{"mi":"y","mn":"2"}}}]}}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0067","num":"0066"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"x","mn":"1"}}},{"mtd":{"msub":{"mi":"x","mn":"2"}}}]}},{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mrow":{"msubsup":[{"mi":["P","T"],"mn":"1"},{"mi":["x","\u2032"],"mn":"1"}],"mo":"*"}}},{"mtd":{"msubsup":{"mi":["x","\u2032"],"mn":"2"}}}]}},"mo":"."}],"mo":"="}}}},"It can thus be broken down into:","(i) solve L*y=P*b\u2014this is forward elimination (lower triangular solve);","(ii) solve L*y=b\u2212Z*y\u2014also, lower triangular solve;","(iii) solve D*L*x\u2032=y\u2014back-substitution stage;","(iv) D*L*xx\u2032=y\u2212D*Z*x\u2014also back-substitution stage; and","(v) x=P*x\u2032; x=x\u2032\u2014inverse permutation step to get the final solution vector.","Implementation","In this section we will describe implementation details of the above-described technique and present efficient optimizations developed as part of an implementation.","One characteristic of the circuit simulation problem (a feature actually shared by numerous other application areas and problems also) is that the structure of the matrix only depends on the topology of the circuit being simulated. Since, in most cases the circuit topology remains fixed during the duration of the simulation (i.e. circuit elements are neither added nor removed), the underlying linear systems have same structure (i.e. the zero non-zero pattern remains fixed). Thus, in a time-dependent simulation, at every time-step only the values of matrix entries change.","To take advantage of this feature, the algorithm is implemented in four primary stages:","(i) Prefactorization Stage\u2014This is a preprocessing step and is done only once in the beginning of the simulation. So as long as the matrix structure remains fixed, it is not repeated. In this step, symbolic processing is performed on the matrix system to minimize fill-in and the factorization operation count. During this stage, efficient data structures are derived for use during the numerical factorization stages and in keeping track of the static and dynamic portions of the matrix. Depending on the cache-characteristics of the underlying processor, the data-structures are cache-blocked to maximize data reuse.","(ii) Factorization Stage\u2014This is the step where the actual numerical calculations associated with performing factorization (as described above) are performed.","(iii) Solution Stage\u2014In this stage, the numerical calculations associated with solution stage (as described above) are performed.","(iv) Cleanup Stage\u2014This is called at the end of the simulation or when linear solver is no longer needed to be kept active in the program. This step just frees all the internal data-structures used by the linear solver and resets it.","One embodiment of the present invention uses four simple Application Programming Interfaces (APIs) implementing each of these stages:","scf_blkprefactor( . . .","scf_blkfactor( . . .","scf_blksolve( . . .","scf_blkfreesys( . . .","In this embodiment, the user only needs to use these APIs (and pass the parameters needed by them) to invoke the various features in the linear solver.","Implementation Approaches","Note that the block-partitioned algorithm can use two different approaches. (1) In a \u201cdense-dynamic\u201d approach, the static portion (Aand all associated computation steps) is treated as sparse but the dynamic portion (A, A, Aand all associated computation steps) are treated as dense blocks (i.e., their sparsity it ignored). (2) In a \u201csparse-dynamic\u201d approach, the entire matrix (both the static and dynamic parts) and all associated steps in the overall computation is treated as sparse. This approach is the superior of the two in both run-time performance and memory overhead, but is substantially more complex to implement.","In what follows, we will describe the sparse-dynamic method in more detail.","Sparse Dynamic Method","We start with some preliminary material to help in explaining the later sections. The sparse matrices (and blocks) arising in the algorithm are represented using the Harwell-Boeing (also called CSC) scheme (in which only the non-zeroes in the matrix are stored). In the C programming language, it can be implemented as",{"@attributes":{"id":"p-0089","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int nrows;","\/*number of rows in the matrix*\/"]},{"entry":[{},"int ncols;","\/*number of cols in the matrix*\/"]},{"entry":[{},"int *colptr;","\/*pointer to start of each column*\/"]},{"entry":[{},"int *rowind;","\/*non-zero row indices*\/"]},{"entry":[{},"double *anz;","\/*non-zero matrix entry values*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} ahb;","\/*Harwell-Boeing form matrix storage*\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"A supernode in the factor L of a sparse symmetric matrix (Land Lin above) are sets of contiguous columns having the structure illustrated in . A supernode thus has a dense triangle at its apex and the zero\/non-zero pattern below the triangle is identical for all the columns. Identification and exploitation of supernodal structures in sparse matrix systems are at the heart of computational efficiency since dense linear algebra techniques (cache-blocking, loop unrolling, loop tiling, software pipelining and others) can be applied on the dense blocks representing the supernodal entries. The identical patterns also substantially reduce the indirect addressing overhead needed in sparse elimination.","Supernodes can be represented with a single 1-d array of length N (# cols in matrix)","if supernode[i]>0\u2192it is width of supernode starting at i;","if supernode[i]<0\u2192i th col is in supernode starting at i+supernode[i]","For sparse rectangular matrices, we extend the concept of supernodes to entire columns with identical zero\/non-zero patterns. These are called \u201csupervariables.\u201d For an m\u00d7n rectangular matrix, the supervariables will be represented with a 1-d array of length n (# of cols in matrix)\u2014in an identical fashion as supernodes","if supervar[i]>0\u2192it is width of supervariable starting at i;","if supervar[i]<0\u2192i th col is in supervariable starting at i+supervar[i]","Sparse Dynamic Method","The section presents pseudo-code for the three primary implementation stages of the block partition algorithm, namely, prefactorization, factorization and solution, respectively, are presented for the sparse dynamic method. In later sections, we describe in detail the computational primitives that are the building blocks of the overall technique presented below.","Sparse Dynamic Prefactorization","The code for the function scf_blkprefactor( . . . ) can include the following operations:\n\n","The code for the function scf_blkfactor( . . . ) can include the following operations:\n\n","Note that one embodiment of the present invention has the ability to solve multiple right hand sides simultaneously, although in most cases there is usually only one right hand side (rhs).","The code for the function scfblksolve( . . . ) can include the following operations:\n\n",{"@attributes":{"id":"p-0102","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"loop over the number of rhs's"},{"entry":"for (ir=0; ir < nrhs; ir++) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"-permute bwith Pi.e compute P*b"]},{"entry":[{},"-solve L*y= P*bsystem to get y(this involves sparse"]},{"entry":[{},"forward elimination with dense right hand size vector)"]},{"entry":[{},"-compute b\u2032 = b\u2212 Z*y(Z*yis sparse matrix-dense vector"]},{"entry":[{},"product)"]},{"entry":[{},"-solve the system A\u2032*x= b\u2032"]},{"entry":[{},"-if (is Adense switch is set) then {"]},{"entry":[{},"\u2003--use LAPACK dsytrs routine to solve for x\u2032"]},{"entry":[{},"} else {"]},{"entry":[{},"\u2003-- use sparse triangular solver to obtain x\u2032"]},{"entry":[{},"}"]},{"entry":[{},"-compute y\u2032 = y\u2212 (D*L)*x((D*L)*xis sparse matrix-"]},{"entry":[{},"dense vector product)"]},{"entry":[{},"-solve (D*L) x\u2032 = y\u2032(this is sparse back-substitution stage"]},{"entry":[{},"with dense right hand side vector)"]},{"entry":[{},"-compute the final permutation and get the final solution vector"]},{"entry":[{},"x= P*x\u2032; x= x\u2032"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} \/*for (ir=0; ir<nrhs; ir++) loop*\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"We now describe an implementation of the computational kernels mentioned in the previous section where an overview of the overall sparse dynamic algorithm was presented. Only primitives where we have enhanced a previously known algorithm or developed a new approach are described.","Note that all the steps described above can be implemented independently (unless otherwise indicated) although the techniques for some cases have been borrowed from elsewhere.","Technique for P*ADetermination (Symbolic and Numeric)","Given sparse Aand P(permutation), determine B=P*A. Input Ais in Harwell-Boeing storage and output B is also in Harwell-Boeing storage.",{"@attributes":{"id":"p-0106","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Let nrows: #rows in A"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ncols: #cols in A"]},{"entry":[{},"nnz: #non-zeroes in A"]},{"entry":[{},"perm: permutation vector"]},{"entry":[{},"invp: inverse permutation vector (perm, invp have usual"]},{"entry":[{},"definition, See HNP)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Symbolic Step:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"begin get_symbolic_PA{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"number of nonzeroes in B are same as nnz, use this to"]},{"entry":[{},"allocate storage for HB vectors representing B;"]},{"entry":[{},"set bcolptr[i] = a12colptr[i] for all i=0..ncols\u22121;"]},{"entry":[{},"for (j=0; j<ncols; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for non-zero entries in each column of Ado {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compute invp[a12rowindices] and"]},{"entry":[{},"accumulate in"]},{"entry":[{},"a temp vector (tmp)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"sort entries of tmp in ascending order;"]},{"entry":[{},"copy tmp vector into browindices for column j;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/*find the location pointer array which maps the arowind indices"]},{"entry":[{},"to browind indices*\/"]},{"entry":[{},"for (j=0; j<ncols; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for non-zero entries in each column of Ado {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new = invp[a12rowind[i]];"]},{"entry":[{},"search for new in browind vector for"]},{"entry":[{},"column j and"]},{"entry":[{},"assign its location in blocptr array;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} end get_symbolic_PA"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Numerical Step:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Let nnz = #non-zeroes in B = PA"]},{"entry":[{},"begin get_numeric_PA{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for (i=0; i<nnz; i++);"]},{"entry":[{},"bval[blocptr[i]] = a12val[i]; \/*recall B = P*A*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} end get_numeric_PA"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}],"sub":["1","12 "]},"Given the zero\/non-zero pattern of P*Amatrix, this technique finds sets of columns with identical patterns (supervariables).",{"@attributes":{"id":"p-0108","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Let\u2003nrows: #rows in A"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ncols: #cols in A"]},{"entry":[{},"supervar PA: int array of length ncols"]},{"entry":[{},"for (j=0; j<ncols; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"determine non-zero length of each column of"]},{"entry":[{},"P*Aand"]},{"entry":[{},"store in temp vector mcollen;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"nsupers=1; size=1; current=0;"]},{"entry":[{},"for (j=1; j<ncols; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (mcollen[i] =\u2009= mcollen[i\u22121] && pattern_of_i_&"]},{"entry":[{},"(i\u22121)_match) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"record col i as member of supervar which"]},{"entry":[{},"i\u22121 is part of;"]},{"entry":[{},"increment width of current supervar;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"col i is the root column of a new supervar;"]},{"entry":[{},"set width of new supervar to 1;"]},{"entry":[{},"increment nsuper (# of supervars) counter;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"for (j=0; j<nsupers; j++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"split supervars into chunks that fit in the cache of"]},{"entry":[{},"the underlying cpu (determined in a separate step);"]},{"entry":[{},"\/*the cache-splitting creates a finer partition*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Note that supervars with a width of 1 are called singletons. Also note that the above algorithm determines a \u201csupervariable partition\u201d of P*A. There are \u201cmany\u201d partitions possible depending on the initial ordering of columns of P*A. There are factorial(ncols) orderings of P*Acolumns possible.","Also note that the above algorithm determines a \u201csupervariable partition\u201d of P*A. This partition is not guaranteed to be maximal but it is guaranteed to be larger or at least as large as the minimal supervariable partition. The maximal partition is nsupers=1 (all columns have identical pattern), and the minimal partition is nsupers=ncols (all columns have dissimilar patterns).","Relation between Supervariables of P*Aand Z","Note that supervariables in P*Aform a finer partition than the supervariables in Z. Consider Lx=y, where L is sparse lower triangular and y is a sparse vector. Then, we know Struct(x) is superset of Struct(y) (i.e., if yis symbolically non-zero then xis also symbolically non-zero). However, the reverse is not true, so x has more symbolic non-zeros than y.","The following holds with regards to zero\/non-zero patterns of P*Aand Z. Since L*(D*Z)=P*A, each corresponding column of Zand P*Asatisfies Lx=y relation. Hence, for each column of Zand P*A, Struct(Z) is superset of Struct([P*A]) for all i=0 . . . Ncols-1.","Given a certain ordering of columns of P*A, the following holds. (1) If 2 consecutive columns in P*Ahave same pattern, the corresponding 2 consecutive columns in Zmust have same pattern (the corresponding columns in Zcannot have dissimilar pattern). (2) If 2 consecutive columns in P*Ahave different pattern, the corresponding 2 consecutive columns in Zmay have same pattern.","Thus, the number of supervars in P*A>the number of supervars in Z. Hence, the supervariable partition of P*Ais finer than supervariable partition of Z. This observation has important performance consequences. It is sufficient to determine supervariables of P*A. Given a supervariable partition of P*A, one can unroll over the columns of supervariables during the numerical stage of L*(D*Z)=P*A. This can significantly increase data-reuse and lead to higher cache hit-rate.","Determining Structure of Zin L*(D*Z)=P*A","Given structure of Land P*A, we want to find the structure of Zsatisfying the relation L*(D*Z)=PA. The problem can be reduced to finding structure of x such that Lx=b where b is a sparse vector (this because columns of P*Acan be thought of as multiple right hand side vectors).","We take advantage of supernodal structure of L in the following way. For a supernode in L of size n, rooted at column i, S: i . . . i+n\u22121, the following is true. (a) If xis symbolically non-zero, then x, k=i+1 . . . (i+n\u22121) are symbolically non-zero. (b) Also, if xis non-zero (i\u2266j<i+n\u22121), then x(j\u2266k\u2266i+n\u22121) are also symbolically non-zero. The validity of (a) and (b) imply that the algorithm for determination of the structure of x can be made highly efficient given the supernodes of L.","We also take advantage of the supervariables in PA. Running the outermost loop only on the root column of each supervariable in PAgives rise to additional improvements in the computational efficiency.",{"@attributes":{"id":"p-0118","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Let"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Nrows: # of rows in Z, P*Aand L"]},{"entry":[{},"Ncols: # of cols in Zand P*A"]},{"entry":[{},"Ns: # of supervariables in P*A"]},{"entry":[{},"mb: array of int:1 of length n (bit-vector)"]},{"entry":[{},"mx: array of int:1 of length n (bit-vector)"]},{"entry":[{},"mt: array of int:1 of length n (bit-vector)"]},{"entry":[{},"supernode: supernode vector of L"]},{"entry":[{},"supervar PA: supervariable vector of PA"]},{"entry":[{},"jst = 0;"]},{"entry":[{},"\/*Loop over supervariables of P*A*\/"]},{"entry":[{},"while (jst < Ncols) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"jen = jst + supervar PA[jst]; \/*last col+1 of"]},{"entry":[{},"supervariable rooted"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"at column jst*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mb[i] = 0 for i=0...Nrows\u22121; \/*determine structure"]},{"entry":[{},"of column jst"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"of Z*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mx[i] = 0 for i=0...Nrows\u22121;"]},{"entry":[{},"mt[i] = 0 for i=0...Nrows\u22121;"]},{"entry":[{},"for (i=0....collen_P1A12[jst]) mb[rowind_P1A12[i]] = 1;"]},{"entry":[{},"\/*set"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mask of rhs*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*loop over supernodes of L*\/"]},{"entry":[{},"isup = icol = icnt = 0;"]},{"entry":[{},"while (isup < Nrows) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ien = isup + supernode[isup];"]},{"entry":[{},"if (supernode[isup] =\u2009= 1) { \/*singleton supernode*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mx[icol] = mb[icol]|mt[icol];"]},{"entry":[{},"\/*if mx is non-zero, determine updates from it*\/"]},{"entry":[{},"if(mx[icol] != 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"record icol in temp vector;"]},{"entry":[{},"increment icnt;"]},{"entry":[{},"for (i=0...collen_L[icol]) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mx[rowind_L[i]] = 1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else {"]},{"entry":[{},"\/*Lsupernode of size > 1; we want to find first column"]},{"entry":[{},"in the supernode for which x is not-zero; all cols"]},{"entry":[{},"from that col. to last col. of supernode do not"]},{"entry":[{},"need to be checked*\/"]},{"entry":[{},"while (icol < ie\u2032n) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mx[icol] = mb[icol]|mt[icol];"]},{"entry":[{},"if(mx[icol] != 0) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ifirst = icol;"]},{"entry":[{},"break;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"icol++;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} \/*while*\/"]},{"entry":[{},"if ((icol < ien) && (mx[icol] != 0)) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for (; icol < ien; icol++) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mx[icol] = 1;"]},{"entry":[{},"record icol in temp vector;"]},{"entry":[{},"increment icnt;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/*compute updates from dense portion"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"of ifirst super*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"theFirst = supernode[isup] \u2212 (ifirst \u2212 isup);"]},{"entry":[{},"for (j=theFirst.. lcollen_L[ifirst]) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"mt[rowind_L[j]] = 1;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}\u2003\/*of if (supernode[isup]=\u2009=1)*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/*At this point we have determined the structure of column jst of Z"},{"entry":"(stored in a temp vector). The structure of all columns of supervariable"},{"entry":"from jst...jen-1 will be identical. We allocate storage for these columns"},{"entry":"and copy the indices into the appropriate locations in the permanent data"},{"entry":"structure holding Zstructure. This data structure is dynamically grown"},{"entry":"using realloc function.*\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"len = icnt*(jen\u2212jst);"]},{"entry":[{},"realloc rowind_Z1T and grow it by len words;"]},{"entry":[{},"adjust column pointers: colptr_Z1T[jst+1....jen];"]},{"entry":[{},"copy rowindices in temp vector in locations;"]},{"entry":[{},"rowind_Z1T[colptr_Z1T[j]....colptr_Z1T[j+1]\u22121]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for j=jst..(jen\u22121);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"jst = jen; \/*start processing next supervariable of PA*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} \/*end of while (isup < Nrows) loop*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}\u2003\/*end of while (jst < Ncols) loop*\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}],"sub":["11 ","1","11","11","1","1","12 "],"sup":["T ","T"]},"Given structure of L, P*A, Zand numerical values in Land PA, we want to find Zsatisfying the relation L*(D*Z)=PA. Note that we actually compute (Z)\u2032=(D*Z), so division by Dis not explicitly done until computation of Z. This eliminates use of divide in the nested loops of forward elimination. Thus, in effect, we solve L*(Z)\u2032=PA.",{"@attributes":{"id":"p-0120","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Let\u2003Nrows: # of rows in Z, P*Aand L"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Ncols: # of cols in Zand P*A"]},{"entry":[{},"Ns: # of supervariables in P*A"]},{"entry":[{},"supernode: supernode vector of L"]},{"entry":[{},"supervar PA: supervariable vector of PA"]},{"entry":[{},"ist = 0;"]},{"entry":[{},"while (ist < Ncols) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ien = ist + supervar PA[ist];"]},{"entry":[{},"if (supervar PA[ist] =\u2009= 1) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"solve for column ist (using do_onerhscol function);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*process the PAsupervariable*\/"]},{"entry":[{},"ir = ist;"]},{"entry":[{},"for (; ir < ien\u22123; ir+=4) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"solve for (4) columns: ir...ir+3 at a time (using"]},{"entry":[{},"do_fourrhscol function);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"for (; ir < ien\u22121; ir+=2) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"solve for (2) columns ir...ir+1 at a time if 2 or 3 left-"]},{"entry":[{},"over cols (using do_tworhscol function);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"for (; ir < ien; ir++) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"solve for (1) column ir at a time if 1 left-over col"]},{"entry":[{},"(using do_onerhscol function);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"ist = ien;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} \/*end of while (lst < Ncols)*\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Note that the structure of do_onerhscol, do_tworhscol and do_onerhscol are very similar. We outline do_tworhscol as follows. Given ir and ir+1, this function computes solution vectors for these two column indices. So effectively, we are solving L {x, x}={y, y}, where lengths of x, xare same and lengths of y, yare same.",{"@attributes":{"id":"p-0122","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Let t, t: double array of length Nrows"},{"entry":"Let d, d: double array of length Nrows (temp vectors)"},{"entry":"leny = length of y& y;"},{"entry":"lenx = length of x& x;"},{"entry":"t0[i] = t1[i] = 0 for all i=0...Ncols\u22121;"},{"entry":"scatter y0 into t0; (sparse scatter)"},{"entry":"scatter y1 into t1; (sparse scatter)"},{"entry":"for (i=0....lenx) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ist = rowind_x[i] ;"]},{"entry":[{},"if (supernode[ist] =\u2009= 1) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compute x0[i], x1[i];"]},{"entry":[{},"compute updates from x0[i], x1[i] to t0 and t1;"]},{"entry":[{},"i = i + 1;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (supernode[ist] > 1) { \/*supernode rooted @ ist*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compute length of update (upwidth);"]},{"entry":[{},"set starting and ending columns for computing"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"update;"]},{"entry":[{},"}"]},{"entry":[{},"else if (supernode[ist] < 0) { \/*partial supernode*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compute length of update (upwidth);"]},{"entry":[{},"set starting and ending columns for computing"]},{"entry":[{},"update;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"process upper triangle of supernode;"]},{"entry":[{},"\/*Now that x0[i]...xsol[i+upwidth\u22121] and"]},{"entry":[{},"x1[i]...xsol[i+upwidth\u22121] are known, compute update from"]},{"entry":[{},"these and dense portion of supernode from cols ist..ien."]},{"entry":[{},"Updates are computed using dense matrix-vector like"]},{"entry":[{},"kernel using x, xas the two vectors. Updates are"]},{"entry":[{},"accumulated in dand d. Note that use of two vectors"]},{"entry":[{},"increases reuse of dense entries of supernode allows loop"]},{"entry":[{},"unrolling. Scatter updates accumulated in dand dinto t"]},{"entry":[{},"and tvectors using sparse scatter kernels.*\/"]},{"entry":[{},"i = i + up width;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} \/*end of if (supernode[ist] =\u2009= 1)*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} \/*end of for(i=0...lenx) loop*\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"sup":"T"},"Given structure of matrix A and its transpose A, we want to find the structure of the lower triangle of the product A*A. The enhancement reduces the algorithm from a 2-pass method to a 1-pass method.",{"@attributes":{"id":"p-0124","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Let\u2003m: #cols in A,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"n: #rows in A, and"]},{"entry":[{},"B = T*A where T=A(for brevity)"]},{"entry":[{},"marker: array n of ints"]},{"entry":[{},"tmp: array n of ints"]},{"entry":[{},"for (j=0; j<n; j++) { \/*run over columns of B*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"nnz = 0;"]},{"entry":[{},"for (i=0....collen_A[j]) { \/*run over non-zeroes of"]},{"entry":[{},"column j of A*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"k = rowind_A[i];"]},{"entry":[{},"for (ti= 0....collen_T[k]) { \/*column k of T*\/"]},{"entry":[{},"trow = rowind_T[ti];"]},{"entry":[{},"if ( (trow >= j) \/*lower triangle of B*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&& (marker[trow != j]) \/*to avoid duplication of"]},{"entry":[{},"marked nonzeroes*\/{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"marker[trow] = j;"]},{"entry":[{},"tmp[nnz++] = trow;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"set-up column pointer for column j of B;"]},{"entry":[{},"increase storage of rowind_B by nnz words;"]},{"entry":[{},"copy nnz from tmp into rowind_B[colptr_B[j]..."]},{"entry":[{},"colptr_B[j+1]\u22121];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} \/*end of for (j=0; j<n; j++) *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"sup":"T"},"Given structure of matrix A, A, B and their numerical values, we want to compute the product B=A*A. One point of novelty in this implementation is the use of supervariables of A to obtain: (1) a decrease in indirect addressing and decrease in load of non-zero index vector rowind_T; (2) an increase in data-reuse of Aentries and higher cache-hit rate; (3) unrolling of intermediate loops in the sparse loop nest; and (4) a decrease load of rowind_B","The basic approach is as follows. Partition A as: A=(A, . . . , A). Then B=T*A=(T*A, . . . , T*A), where T*A=(T, . . . , T)*A. So, clearly if structure of Aand Aare same, the structure of Band Bare same also. Thus, if supervariables of A are known, we can express the above as B=T*A=(T*A, . . . , T*A), where Ais supervariable Sof A and Ais supervariable S. Thus, if A=(A, A, . . . , A) (i.e. has s columns in it), T*A=(T*A, T*A, . . . , T*A), and so on. An additional implementation detail is that since we are computing only lower triangle of B, lesser and lesser portions of columns of T are used as one computes columns to right in B.",{"@attributes":{"id":"p-0127","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Let t0, t1, t2 and t3 be double temp vector of length n;"},{"entry":"jst = 0;"},{"entry":"while (jst < n) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"jen = jst + supervarA[jst];"]},{"entry":[{},"if (supervarA[jst] =\u2009= 1) { \/*singleton*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compute B_*jst = T*A_*j (column jst of B);"]},{"entry":[{},"\/*Note that only entries below diagonal are computed. The"]},{"entry":[{},"product accumulated in the temp vector and sparse gather"]},{"entry":[{},"operation are performed subsequently.*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else { \/* compute over supervar rooted at jst*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"j = jst;"]},{"entry":[{},"process four columns j, j+1, j+2, j+3 at a time, i.e. compute"]},{"entry":[{},"B_*j, B_*(j+1), B_*(j+2), B_*(j+3);"]},{"entry":[{},"-accumulate product in t0, t1, t2, t3"]},{"entry":[{},"-compute offsets for gathering into cols j...j+3 of B"]},{"entry":[{},"-perform sparse gather operation to put t0,t1,t2,t3 into"]},{"entry":[{},"columns j..j+3 of B"]},{"entry":[{},"process two columns j, j+1 at a time repeat above sub-steps;"]},{"entry":[{},"process one column j at a time repeat above sub-steps;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"jst = jen;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"sub":"22"},"Given structure of A\u2032s, decide whether A\u2032*x\u2032=b\u2032 should be solved assuming A\u2032s to be dense or using a sparse approach that takes advantage of its sparsity. The main reason to give consideration to A\u2032 being treated as dense is that in many problems, as the factorization proceeds more and more fill-in occurs towards the right of the matrix. As a result, often the apex supernode (or the lower right triangle in the matrix) fills-up naturally. In those cases, treating A\u2032s as dense can be efficient and has the advantage of allowing calls to LAPCK dsytrf routine to be made. This routine in turn calls a routine, which is highly optimized. Thus, for these cases, the sparse kernels turn out to be substantially inferior to the dense case.","On the other hand, in general, we want A\u2032 to be treated as sparse to preserve memory and to avoid performing any redundant operations. For systems where A\u2032s is sparse, treating it as dense leads to a high runtime and memory overhead.","The heuristic involves: (1) determining the structure of A\u2032=A\u2212Z*D*Z; (2) performing reordering and symbolic factorization of A\u2032; (3) counting the number of non-zeroes in sparse factor of A\u2032s (as determined in symbolic factorization stage) mem_sparse; (4) estimating sparse flop count (flop_sparse); (5) computing rat_flop=flop_sparse\/flop_dense; and (6) computing rat_mem=mem_sparse\/mem_dense.","In particular,",{"@attributes":{"id":"p-0132","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (rat_mem < MEMCUT && rat_flop < FLOPCUT)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"isA22dense = 0; \/*treat A\u2032 as sparse*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"isA22dense = 1; \/*treat A\u2032 as dense *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"MEMCUT=0.4;","FLOPCUT=0.7;","Time-Based Simulation",{"@attributes":{"id":"p-0135","num":"0162"},"figref":"FIG. 5","b":["502","504"]},"The system then performs the simulation, which involves solving the system of linear equations for each time step in the simulation. In doing so, the system factorizes the static portion of the matrix A once and the reusing the factorized static portion to perform an overall factorization of the matrix A for each time step of the simulation as is described in preceding sections of this disclosure (step ).","The foregoing descriptions of embodiments of the present invention have been presented for purposes of illustration and description only. They are not intended to be exhaustive or to limit the present invention to the forms disclosed. Accordingly, many modifications and variations will be apparent to practitioners skilled in the art. Additionally, the above disclosure is not intended to limit the present invention. The scope of the present invention is defined by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
