---
title: Hybrid tree/mesh overlay for data delivery
abstract: Hybrid tree/mesh overlays for data delivery involve using a tree overlay network and a mesh overlay network to delivery a data stream via a push mechanism and a pull mechanism, respectively. In an example embodiment, a network node enters a mesh overlay network and attaches to a tree overlay network. In operation, the network node receives data blocks of a data stream over the tree overlay network via a push mechanism. The network node ascertains if a data block is not received over the tree overlay network. If a data block is missing, the network node retrieves the missing data block over the mesh overlay network via a pull mechanism. In another example embodiment, the tree overlay network includes a subset of nodes forming a tree-based backbone. Network nodes that are identified as being stable may join the backbone and provide the data stream to other nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08504734&OS=08504734&RS=08504734
owner: Microsoft Corporation
number: 08504734
owner_city: Redmond
owner_country: US
publication_date: 20091218
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Introduction to Hybrid Tree\/Mesh Overlay for Data Delivery","Example Embodiments for Hybrid Tree\/Mesh Overlays for Data Delivery","1: Introduction\u2014Example Environments and General Embodiments","2: Example Specific Embodiments","Example Device Implementations for a Hybrid Tree\/Mesh Overlay for Data Delivery"],"p":["This application is a continuation of and claims priority to U.S. patent application Ser. No. 11\/766,665, filed on Jun. 21, 2007, the disclosure of which is incorporated by reference herein.","Data streams, such as live media data, are being communicated over point-to-point networks with increasing frequency. The sizes of the data streams, in terms of both the temporal length and the instantaneous bandwidth demands, are increasing as well. Data streams can be communicated from a single source to multiple destinations using a unicast approach. With unicasting, the source usually sends a separate and complete data stream to each individual destination.","Alternatively, data streams can be communicated from a single source to multiple destinations using a multicast approach. With multicasting, the source usually sends the entire data stream to a limited number of initial nodes, such as one or more routers. These initial nodes then forward the data stream to multiple other nodes. The data stream may be copied and split at a given intermediate node when required to eventually reach an intended destination. These multiple other nodes likewise forward the data stream to still other nodes. Ultimately, the intended multiple destinations are reached. Hence, multicasting can generally facilitate the communication of a data stream from a source to many destinations even when the source has (or other intermediate nodes have) finite processing capabilities and\/or bandwidth constraints.","Traditional multicasting has been implemented at the network layer. However, the limited deployment of network-layer multicasting has motivated researchers to try to implement multicasting at the application layer. More recently, some multicasting efforts have been directed to the application-layer. At the application layer, end-hosts can not only receive the data stream, but they may also be recruited to forward the data stream to other end-hosts. Application-layer multicasting creates a new set of challenges that have heretofore not been remedied by existing approaches or technologies.","Hybrid tree\/mesh overlays for data delivery involve using a tree overlay network and a mesh overlay network to deliver a data stream via a push mechanism and a pull mechanism, respectively. In an example embodiment, a network node enters a mesh overlay network and attaches to a tree overlay network. In operation, the network node receives data blocks of a data stream over the tree overlay network via a push mechanism. The network node ascertains if a data block is not received over the tree overlay network. If a data block is missing, the network node retrieves the missing data block over the mesh overlay network via a pull mechanism. In another example embodiment, the tree overlay network includes a subset of nodes forming a tree-based backbone. Network nodes that are identified as being stable may join the backbone and provide the data stream to other nodes. Node stability may be determined responsive to an age of a node and a temporal stability threshold.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover, other method, system, scheme, apparatus, device, media, procedure, API, arrangement, etc. implementations are described herein.","Application layer multicasting can be used for delivering a data stream, such as a live media streaming, over one or more networks, such as the Internet. A tree is one potential structure for a multicast network overlay, but it is vulnerable in the presence of autonomous end-hosts. A data-driven approach can employ a mesh out of overlay nodes so that they can exchange data; this mesh structure greatly enhances communication resilience. However, it suffers from an efficiency-latency tradeoff, given that the data has to be pulled from mesh neighbors with periodic notifications.","More specifically, one example approach to application-layer multicasting is that the end-hosts may be organized into a tree for data delivery. A tree structure, however, is vulnerable to node dynamics, such as the departure or failure of a node. This vulnerability is particularly acute for node dynamics that are close to the source because they may cause data outage in a number of descendants. Tree structures thus have to be frequently repaired. Another example approach is data-driven randomized overlays that can be relatively resilient. Such systems can construct a mesh network out of the overlay nodes such that each node independently selects some other nodes as neighbors and exchanges data with them.","A difference between the tree and the mesh overlay networks lays in their data delivery strategies. In a tree structure, a data stream is pushed along defined routes. On the other hand, given multiple and dynamic neighbors, a node in a mesh structure pulls data to avoid significant redundancies. Consequently, a mesh-based system can be more robust, but it typically experiences longer delays and has higher control overhead. More explicitly, there is an efficiency-latency tradeoff: if the mesh nodes choose to send notifications for every data block arrival, then the overhead is excessive; alternatively, although sending periodic notifications can reduce the overhead, it also increases the latencies.","In contrast to these separate overlay network approaches, an example hybrid tree\/mesh overlay approach that leverages both network overlay types for delivering data streams is described herein. In an example embodiment, the tree overlay can facilitate delivering much of the data stream in normal steady-state circumstances. The mesh overlay facilitates handling node dynamics in the tree-based backbone. Implementing a mesh overlay can also better utilize the available bandwidth between overlay nodes.","When a hybrid tree\/mesh overlay network is to be employed, seamless data delivery using both push and pull mechanisms can be implemented. In an example embodiment, a set of stable nodes is identified to construct a tree-based backbone, with much of the data usually being pushed over this backbone. These stable nodes, together with other unstable nodes, are further organized through an auxiliary mesh overlay. When a tree-based backbone is to be formed from stable nodes, these stable nodes may be identified responsive to the age of each node.","Other example, more-specific embodiments include the following. In one, stable nodes are identified in a tree overlay, and a tree-based backbone is gradually built up. A temporal stability threshold, which may vary between nodes, is used in conjunction with node ages to identify which nodes are likely to have higher expected service times and can thus be deemed sufficiently stable to join the tree-based backbone. In another example embodiment, the respective push and pull data delivery mechanisms of the two respective tree and mesh overlays are reconciled. They can work complementally for joint efficiency in the presence of autonomous nodes. Also, a buffer partitioning and scheduling scheme coordinates push\/pull delivery mechanisms and can avoid data redundancy. Other general and specific example embodiments are described herein below.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","102","102","100"]},"These unidirectional arrows also represent data delivered via a push mechanism. Bidirectional arrows represent data delivered via a pull mechanism. The pull data is delivered over links of the mesh overlay. Mesh overlay links also indicate neighbor nodes for individual network nodes in the mesh overlay network.","Each network node  may be comprised of all or any part of a device that is capable of forming a node in a wireless and\/or a wired network. Examples of network nodes  include, but are not limited to, a general personal computer (e.g., notebook, desktop, portable, etc.); a client, server, or workstation computer; a television-based device; an entertainment appliance (including portable ones); a mobile phone; a gaming device; a personal digital assistant (PDA); any device or part thereof that is operating at an application layer within the network; a device otherwise described herein; some combination thereof; and so forth. An example embodiment for a device that is capable of realizing a network node  is described herein below with particular reference to .","In an example embodiment, there are \u201cn\u201d network nodes , with \u201cn\u201d representing some integer. As indicated by the ellipses, other network nodes that are not explicitly illustrated in diagram  may be included in the overall network. Network node () is the source node that originates a data stream. By way of example but not limitation, the following characteristics may be evidenced: First, the network may comprise a structured or unstructured peer-to-peer (P2P) network. Second, the data stream may be a live media data stream that is being multicasted. Third, network nodes  may be end-hosts that are operating at an application layer. Fourth, the data stream may be divided into data blocks, which may be of equal or approximately equal length.","Generally, the tree overlay accepts a primary role for delivering the data stream via a push mechanism as indicated by the unidirectional arrows. However, when data (e.g., a data block) of the data stream is not received over the tree overlay network via the push mechanism, the data may be retrieved over the mesh overlay network via a pull mechanism. The data may be requested and received from a neighbor node in the mesh overlay network, which accepts a secondary role for delivering the data stream.","An example failure scenario is described: Push data from network node () experiences a failure as indicated by the \u201cX\u201d at . This failure may be a bandwidth rate reduction, a temporary communication delay, a complete transmission cessation, and so forth. To reduce, if not prevent, a disruption in the ability to utilize (e.g., play) the data stream in a timely manner at network node (), network node () can retrieve any missing data from neighbor nodes over the mesh overlay network at pull data () and\/or at pull data (). If network node () is still functioning from a mesh overlay perspective, network node () can also attempt to retrieve any missing data at pull data ().","In the drawings, , , and  are flow diagrams , , and , respectively Implementations of flow diagrams , , and  may be realized, for example, as processor-executable instructions. Processor-executable instructions may be embodied as software, firmware, hardware, fixed logic circuitry, some combination thereof, and so forth. The acts of these flow diagrams may be performed in many different environments, with a number of different devices, and\/or in a variety of different network configurations. The order in which the methods are described is not intended to be construed as a limitation, and any number of the described blocks can be combined, augmented, rearranged, and\/or omitted to implement a respective method, or an alternative method that is equivalent thereto.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2","b":["200","200","202","214","202","102","204","206"]},"At block , it is ascertained if a data block is not received via the push mechanism in accordance with the primary delivery role. If each data block is received, then the method of flow diagram  continues at block , which is described below. If a data block is not received, then at block  the data block is retrieved over the mesh overlay network via a pull mechanism that is operating in a secondary delivery role. For example, a network node may request and receive the data block from one or more mesh overlay network neighbor nodes.","At block , the data flow deficiency as evidenced by a missing data block is investigated. If possible, the deficiency may be remedied as well. For example, the network node may attach to a different parent node in the tree overlay network. This is described further herein below with particular reference to .","At block , if a temporal stability threshold is satisfied, a tree-based backbone of the tree overlay network is joined. For example, if an age of the network node satisfies (e.g., meets, equals, surpasses, etc.) a temporal stability threshold, the network node may be considered stable, and it may join the tree-based backbone, including by becoming a parent node that provides the data stream to one or more children nodes. Examples for a tree-based backbone are described further herein below with particular reference to . Examples implementations for a temporal stability threshold are also described herein below.","In an example embodiment, a data stream is delivered using a tree overlay network and a mesh overlay network. The tree overlay network includes a tree-based backbone. The tree-based backbone comprises a subset of the nodes of the tree overlay network. This subset includes the stable nodes of the tree overlay network. Other non-stable nodes are attached to the backbone at the outskirts of the tree overlay network. Under normal circumstances, most of the data stream is pushed through the tree-based backbone to eventually reach the outskirts.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3","b":"300"},"In an example embodiment, the stable nodes form the tree-based backbone. Each node that attaches to the tree overlay network, and the tree-based backbone thereof, is capable of receiving the data stream via a push mechanism. Each node that joins the tree-based backbone, such as node B, is also capable of providing the data stream to one or more children nodes, such as node C, via the push mechanism. Node D is a parent node for node B, and node B is a parent node for node C.","The unstable nodes are located in the outskirts of the tree overlay network outside of the tree-based backbone. The unstable nodes do not act as a parent node within the tree overlay network. However, both stable and unstable nodes can retrieve (and provide in response to a request) data blocks via a pull mechanism of the mesh overlay network. This is further described herein below with particular reference to  in which node B experiences a failure.","Usually, a relatively small tree-based backbone can be sufficient to support a larger tree overlay network. As evidence, and by way of example only, consider a simple K-ary tree of height H. The fraction of its internal nodes (e.g., those belonging to the backbone) is no more than 1\/K if the tree is complete and balanced",{"@attributes":{"id":"p-0043","num":"0042"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"0"},{"mi":"L","mo":"-","mn":"2"}]},"mo":"\u2062","mrow":{"msup":{"mi":["K","i"]},"mo":"\/","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"0"},{"mi":"H","mo":"-","mn":"1"}]},"mo":"\u2062","msup":{"mi":["K","i"]}}}},"mo":"<","mfrac":{"mn":"1","mi":"K"}}},"mo":"."}}},"br":{}},"Thus, the stability of nodes is to be identified using a scheme or schemes. Generally, in overlay multicast systems, nodes with a higher age tend to stay longer with the multicast session. Thus, node stability may be inferred by examining nodal ages. We describe herein below a temporal-stability-threshold-based scheme for identifying stable nodes.","A tree-based backbone, however, cannot completely eliminate repairing operations because even relatively stable nodes are not absolutely persistent. Moreover, the potential bandwidth between the unstable nodes is largely ignored by the tree-based backbone. Hence, to increase the resilience and efficiency of the tree-based backbone approach, the network nodes are also organized into a mesh overlay network.","For an example embodiment of the mesh overlay network, each network node keeps (at least) a partial list of the active overlay nodes and their status. This local list facilitates the node's locating a set of mesh neighbors as well as its dedicated backbone parent. To keep the list updated, a light-weighted, scalable, random gossip algorithm, for example, may be used for the nodes to periodically exchange their status information. The mesh neighbor nodes also periodically exchange their buffer maps. However, a node need not actively schedule the automatic fetching of data blocks from neighbors using such data availability information. Instead, data block retrieval can be invoked when there is a data delivery outage in the backbone.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 4","FIG. 3"],"b":["400","400","300"]},"Nodes promoted to the tree-based backbone, on the other hand, are stable and are expected to seldom depart. Even if a stable node does depart, the impact can be mitigated with help from the mesh overlay network. For example, consider the departure (or other failure) of node B. While node C is affected, it can retrieve missing data blocks from its mesh neighbors over the mesh overlay network via the pull mechanism until it re-attaches to the tree-base backbone.","For instance, node C can retrieve data block(s) via the pull mechanism at pull data () and (). These data retrievals over the mesh overlay network can be from stable or unstable nodes. Node C also reattaches to the tree-based backbone to re-establish data reception over the tree overlay network as indicated by the push data  from node D. Because node C is also a stable node (and responsible for forwarding the data stream to at least one downstream child node), node C may also rejoin the tree-based backbone network as a parent therein. Node C can also reestablish an additional mesh overlay network connection to another node, such as node E, as indicated by the mesh overlay link .","To realize such a hybrid tree\/mesh overlay for data streaming, one or more of a number of example embodiments may be implemented. First, stable nodes in the overlay can be identified in accordance with some scheme. Second, the stable nodes can be positioned so as to form the tree-based backbone. This backbone can also be evolved so as to enhance data block delivery. Third, the tree and mesh overlays can be reconciled so as to enable seamless data delivery. Examples for the establishment, evolution, and enhancement of the tree-based backbone are described next. Example interactions between the tree overlay network and the mesh overlay network are described further below.","In an example embodiment, the stability of a node is considered to be proportional to its duration in the overlay. Unfortunately, this cannot be known with complete certainty before the node actually departs the network. However, this duration can be predicted using the node age in the session, which is the time elapsed since its arrival. As noted above, network nodes that already have relatively higher ages tend to stay relatively longer. Consequently, the node age can be used, at least partially, to infer its stability. If the age is above a certain threshold (e.g., a temporal stability threshold), for example, the node can be considered stable and can be joined to the tree-based backbone. Once a stable node is moved into the tree-based backbone, it can remain there until it departs the session or the session concludes.","The effectiveness of the tree-based backbone can be impacted by the temporal stability threshold. If the threshold is set too low, unstable nodes can be promoted to the tree-based backbone. On the other hand, if the threshold is set too high, too few nodes might be considered stable and moved into the backbone. In an example embodiment, an Expected Service Time (EST) of a network node is determined by selecting an appropriate temporal stability threshold. The EST and other variables are described in Table 1 below.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing of Notation Descriptions."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Notation","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"L","Session length"]},{"entry":[{},"t","Node arrival time"]},{"entry":[{},"L-t","Residual session length at time t"]},{"entry":[{},"s","Node age"]},{"entry":[{},"EST(t)","Expected service time in backbone for a node"]},{"entry":[{},{},"arriving at t"]},{"entry":[{},"T(t)","Temporal stability threshold for a node arriving at t"]},{"entry":[{},"f(x)","Probability distribution function of node duration"]},{"entry":[{},"k, x","Shape and location parameters of Pareto distribution"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"For an example embodiment, a temporal stability threshold can be determined as follows: Let L be the length of the session, and let \u0192(x) be the probability distribution function (PDF) of the node duration in the session. Because a node starts serving in the tree-based backbone when its age exceeds its corresponding temporal stability threshold, for a backbone node arriving at time t, its EST(t) can be calculated as the expected duration minus the corresponding threshold, T(t), that is,",{"@attributes":{"id":"p-0055","num":"0054"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"EST","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mfrac":{"mrow":[{"msubsup":{"mo":"\u222b","mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":["L","t"],"mo":"-"}]},"mo":"\u2062","mrow":{"mi":"x","mo":["\u00b7","\u00b7","\u2062"],"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"mo":"\u2146","mi":"x"}],"mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}}}},{"msubsup":{"mo":"\u222b","mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":["L","t"],"mo":"-"}]},"mo":"\u2062","mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"mo":"\u2146","mi":"x"}],"mo":["\u00b7","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}}}}]},"mo":"-","mrow":{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"."}}],"mo":"="}}}},"By way of example only, for some data streams, such as video data streams, the durations of participating clients generally follow a Pareto distribution. The Pareto distribution has parameters k and x, (here, k is a shape parameter that determines how skewed the distribution is, and x, is a location parameter that determines where the distribution starts). We then have the following result,",{"@attributes":{"id":"p-0057","num":"0056"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"EST","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mfrac":{"mrow":[{"msubsup":{"mo":"\u222b","mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":["L","t"],"mo":"-"}]},"mo":"\u2062","mrow":{"mfrac":{"msubsup":{"mi":["kx","m","k"]},"mrow":{"msup":{"mi":"x","mrow":{"mi":"k","mo":"+","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mrow":[{"msubsup":{"mi":["x","m","k"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}}},{"mo":"-","mi":"k"}]}}}}},"mo":["\u00b7","\u00b7","\u2062"],"mi":"x","mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}},"mrow":{"mo":"\u2146","mi":"x"}}},{"msubsup":{"mo":"\u222b","mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":["L","t"],"mo":"-"}]},"mo":"\u2062","mrow":{"mfrac":{"msubsup":{"mi":["kx","m","k"]},"mrow":{"msup":{"mi":"x","mrow":{"mi":"k","mo":"+","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mrow":[{"msubsup":{"mi":["x","m","k"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}}},{"mo":"-","mi":"k"}]}}}}},"mo":["\u00b7","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}},"mrow":{"mo":"\u2146","mi":"x"}}}]},"mo":"-","mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mfrac":{"mrow":[{"mfrac":{"msubsup":{"mi":["kx","m","k"]},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}},{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mrow":[{"msubsup":{"mi":["x","m","k"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}}},{"mo":"-","mi":"k"}]}}}],"mo":"\u2062"}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mfrac":[{"mn":"1","mrow":{"msup":{"mi":"T","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mn":"1","msup":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},{"mi":"k","mo":"-","mn":"1"}]}}],"mo":"-"}}},{"mfrac":{"msubsup":{"mi":["x","m","k"]},"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mrow":[{"msubsup":{"mi":["x","m","k"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}}},{"mo":"-","mi":"k"}]}}}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mfrac":[{"mn":"1","mrow":{"msup":{"mi":["T","k"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mn":"1","msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},"mi":"k"}}],"mo":"-"}}}]},"mo":"-","mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mfrac":{"mrow":[{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mfrac":[{"mn":"1","mrow":{"msup":{"mi":"T","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mn":"1","msup":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},{"mi":"k","mo":"-","mn":"1"}]}}],"mo":"-"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}},{"mo":["(",")"],"mrow":{"mfrac":[{"mn":"1","mrow":{"msup":{"mi":["T","k"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},{"mn":"1","msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},"mi":"k"}}],"mo":"-"}}],"mo":"\u2062"}]},"mo":"-","mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}}}}}]}}},"br":{}},{"@attributes":{"id":"p-0058","num":"0057"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":["x","t"]},"mo":"=","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mi":["L","t"],"mo":"-"}]}},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0059","num":"0058"},"maths":[{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"EST","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},{"mfrac":{"mrow":[{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mfrac":[{"mn":"1","msup":{"mrow":[{"msubsup":{"mi":["x","t"],"mrow":{"mi":"k","mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}}},{"mi":"k","mo":"-","mn":"1"}]}},{"mn":"1","msup":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},{"mi":"k","mo":"-","mn":"1"}]}}],"mo":"-"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}},{"mo":["(",")"],"mrow":{"mfrac":[{"mn":"1","msup":{"mrow":{"msubsup":{"mi":["x","t","k"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}}},"mi":"k"}},{"mn":"1","msup":{"mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},"mi":"k"}}],"mo":"-"}}],"mo":"\u2062"}]},"mo":"-","mrow":{"msub":{"mi":["x","t"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},{"mo":["(",")"],"mfrac":{"mrow":[{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","msubsup":{"mi":["x","t"],"mrow":{"mi":"k","mo":"-","mn":"1"}}},"mo":"-","mn":"1"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}},{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","msubsup":{"mi":["x","t","k"]}},"mo":"-","mn":"1"}}],"mo":"\u2062"}]}}],"mo":"\u2062"},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["L","t"],"mo":"-"}},{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","t"]}}}],"mo":"\u2062"}],"mo":"="}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"1.7em","height":"1.7ex"}}}}}}]}}},{"@attributes":{"id":"MATH-US-00005-2","num":"00005.2"},"math":{"@attributes":{"overflow":"scroll"},"mi":"for"}},{"@attributes":{"id":"MATH-US-00005-3","num":"00005.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","t"]}}},{"mfrac":{"mrow":[{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","msubsup":{"mi":["x","t"],"mrow":{"mi":"k","mo":"-","mn":"1"}}},"mo":"-","mn":"1"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}},{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","msubsup":{"mi":["x","t","k"]}},"mo":"-","mn":"1"}}],"mo":"\u2062"}]},"mo":"."}],"mo":["=","\u2062"],"mi":{}}}}]},"Hence, to likely maximize EST(t), we attempt to maximize g(x) with respect to x. For a typical Pareto distribution, curves of g(x) with different k values can be graphed. For a typical value close to 1, g(x) is maximized when xis about 0.3. In other words, the temporal stability threshold for a node arriving at time t can be set to be 30% of the residual session length L\u2212t. The parameter k can instead be estimated online, and the temporal stability threshold can then be adjusted accordingly. Alternatively, other distributions can be used to compute a temporal stability threshold. Furthermore, temporal stability thresholds for promoting a node to stable status can be determined in other manners.","In an example embodiment, and given a temporal stability threshold, network nodes can establish and evolve into a stable tree-based backbone as follows. It is assumed, without loss of generality, that the source node alone is in the tree-based backbone initially. Each network node that is newly-attached to the tree overlay network obtains L and t from the source node, as well as (at least) a partial list of the existing overlay nodes. (Alternatively, the source node can compute the temporal stability threshold and send it to the newly-attached node.) At least one node in the listing is to already be in the tree-based backbone. The new node then attaches itself to one of the tree-based backbone nodes, and it also locates mesh neighbor node(s) using the list.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 5","b":"500"},"If a network node is not in the tree-based backbone, it periodically checks its own age in the overlay network. Once the age of the node satisfies (e.g., meets, exceeds, equals, etc.) the temporal stability threshold T(t), the node promotes itself as a stable backbone node. In hybrid tree\/mesh overlay , the numeric label within each network node indicates the arrival time of the node. Example illustrated arrival times include zero (0), 2, 5, 10, 14, and 17 time units.","In this example promotion scheme, before time T(), no node but the source can be included in the tree-based backbone, which reduces the efficiency of data delivery in the early periods. To alleviate this lack of efficiency, a randomized, probabilistic promotion operation may be employed for some initial period of the data stream delivery session. In an example embodiment, the algorithmic operation strives to achieve a probability s\/T(t) for a network node to be in the tree-based backbone when its age is s. To realize a, e.g., linearly increasing probability s\/T(t), each non-backbone node independently checks its status per unit time. For the s-th check (e.g., at time t+s), the network node is promoted to the tree-based backbone with a probability of 1\/(T(t)\u2212s+1) (and 0 for s=0). Alternatively, the source node (or another network node) may be responsible for determining when a given node is to be promoted to the tree-based backbone using a probabilistic or a non-probabilistic criterion.","Theorem 4.1: In the above example promotion scheme, at (discrete) time s(<T(t)), the probability that a network node of age s resides in the tree-based backbone is s\/T(t). Proof: The probability that the node is in the tree-based backbone is given by:",{"@attributes":{"id":"p-0066","num":"0065"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mn":"1","mo":"-","mrow":{"munderover":{"mo":"\u220f","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"s"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mn":"1","mrow":{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":["-","+"],"mi":"k","mn":"1"}}}}}},{"mn":"1","mo":"\u2062","mrow":{"munderover":{"mo":"\u220f","mrow":{"mi":"k","mo":"=","mn":"1"},"mi":"s"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mrow":[{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"-","mi":"k"},{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":["-","+"],"mi":"k","mn":"1"}]}}}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mn":"1","mo":"-","mrow":{"mrow":{"mfrac":[{"mrow":[{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"-","mn":"1"},{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}]},{"mrow":[{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"-","mn":"2"},{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"-","mn":"1"}]}],"mo":"\u00b7"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"\u2026","mfrac":{"mrow":[{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"-","mi":"s"},{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":["-","+"],"mi":"s","mn":"1"}]}}}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mn":"1","mo":"-","mfrac":{"mrow":[{"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}},"mo":"-","mi":"s"},{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}]}},{"mfrac":{"mi":"s","mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"t"}}},"mo":"."}],"mo":"="}}}}]}}}},"Promotions that occur prior to when a nodal age satisfies the temporal stability threshold can accelerate the establishment of the tree-based backbone. Theses early probabilistic promotions can also potentially reduce the churn of the tree-based backbone with a built-in randomness. When each individual node performs its own promotion computations and\/or promotion determinations\/checks, the promotion operation can be implemented in a distributed manner with no extra message exchanges among the overlay nodes.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 6","b":["600","600","602","620","602","604"]},"At block , the network node obtains a session length and a node arrival time (for the node) from a source node. At block , a temporal stability threshold is computed responsive to the session length and node arrival time. As noted above, the source node may alternatively provide a computed temporal stability threshold.","At block , the network node determines if a probabilistic promotion criterion is satisfied based on the current age of the node. For example, a likelihood of nodal promotion to the tree-based backbone can increase as time elapses. If the probabilistic promotion criterion is satisfied, then the method of flow diagram  continues at block , which is described below.","If, on the other hand, the probabilistic promotion criterion is not satisfied, then at block  the node checks if its current age satisfies the temporal stability threshold. If its current age does not satisfies the temporal stability threshold, then as time elapses as indicated at block  and the node's age thus increases, the probabilistic promotion criterion may be considered again at block  (e.g., repeatedly, at regular intervals, randomly, etc.). If, on the other hand, the current age of the node does satisfy the temporal stability threshold (as checked at block ), the method continues at block .","At block , the network node joins the tree-based backbone to provide the data stream via a push mechanism. For example, the network node can promote itself to a stable status and offer to become a parent by providing the data stream to one or more downstream children nodes via the push mechanism of the tree overlay network.","At block , the network node forwards the data stream via a push mechanism to one or more children nodes. At block , the network node, possibly in conjunction with other network nodes, can attempt to enhance the tree-based backbone with one or more nodal rearrangement procedure(s). Examples of nodal rearrangement procedures include, by way of example but not limitation, high-degree-preemption, low-delay-jump, and so forth. These are described further herein below in the context of evolving the tree-based backbone with particular reference to . The acts of blocks  and  can be repeated while the data stream session continues.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 7","b":["700","700","700"]},"As illustrated, hybrid mesh\/tree data delivery implementer  includes the following components: a mesh overlay network interface , a tree overlay network interface , a mesh network handler , a tree network handler , a tree-based backbone handler , a push\/pull switch buffer , and a node listing . Tree-based backbone handler  includes a tree-based backbone joiner J and a tree-based backbone enhancer E. Tree-based backbone handler , wholly or partly, may be coupled to and\/or integrated with tree network handler .","In an example general embodiment, mesh overlay network interface  empowers a node to enter a mesh overlay network that enables data retrieval via a pull mechanism. Tree overlay network interface  empowers a node to attach to a tree overlay network. The tree overlay network may include a subset of nodes forming a tree-based backbone that provides a data stream via a push mechanism. Tree network handler  empowers a node to receive data blocks of the data stream over the tree-based backbone of the tree overlay network via the push mechanism.","Mesh network handler  empowers a node to retrieve missed data blocks over the mesh overlay network via the pull mechanism. Missed data blocks are those data blocks that are not received over the tree-based backbone of the tree overlay network. Tree-based backbone joiner J checks if an age of the node satisfies a temporal stability threshold. If so, tree-based backbone joiner J empowers the node to join the tree-based backbone to provide the data stream via the push mechanism.","Example embodiments for tree-based backbone enhancer E are described herein below with particular reference to . Example embodiments for push\/pull switch buffer  are described herein below with particular reference to . Node listing  is a data structure listing local neighbor nodes for the mesh overlay network and\/or at least one parent node of the tree-based backbone of the tree overlay network. Example embodiments for node listing  are described herein above and additionally below with particular reference to nodal rearrangement procedures as well as to locating mesh neighbor nodes and\/or potential new parent backbone nodes when a failure occurs in the tree-based backbone.","The illustrated components of hybrid mesh\/tree data delivery implementer  may alternatively perform different functions and\/or implement different schemes. Moreover, they may additionally perform other functions and\/or implement other schemes that are described herein, including the various more specific embodiments described with reference to flow diagrams, network organizations, and so forth.","A tree-based backbone constructed by the establishment and evolution operations described above does not necessarily minimize the latency for data stream delivery. In particular, two example non-optimal substructures can exist. They are illustrated in . Nodal rearrangement procedures may be performed to combat these non-optimal substructures.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 8","FIG. 9"],"b":["800","900","800","900"]},"High-degree-preemption is described with reference to . Each tree-based backbone node x periodically checks whether it has more children than a node that is closer to the source in the tree-based backbone. Such a node, referred to as y, can be the parent of x in the tree-based backbone, a node known from x's local node list, and so forth. If such a node is found, node x preempts y's position in the tree-based backbone, and node y re-joins the tree-based backbone. In practice, it can attach itself to node x, as illustrated in the upper portion of .","Low-delay-jump is described with reference to . Each tree-based backbone node x periodically checks if there is at least one node that (i) is closer to the source than its parent node and (ii) has spare bandwidth capacity. If so and if one such node, say node y, has sufficient available bandwidth to support a new child, node x leaves its original parent and attaches itself to node y as a child.","The above two procedures may be executed by the overlay nodes iteratively until no node can further locate candidates for swapping. The average depth of the tree-based backbone nodes is monotonically decreased in the iterations, which can lead to a minimal average depth. More explicitly, the resultant tree-based backbone can have the following properties: 1) it is balanced, if each tree-based backbone node can support at least one child; and 2) the node degree is non-increasing with the node depth.","Theorem 4.2: The average depth of the tree-based backbone is minimized when high-degree-preemption and low-delay-jump terminate at each of the tree-based backbone nodes. Proof: We prove this in two steps: first, we prove that the two properties mentioned above hold for any tree with minimum average depth; second, based on this observation, we prove that both our tree and a tree with minimum depth have the same average depth.","We prove the first step by contradiction. Assume there exists a tree A that does not have the two properties but is of minimum average depth. Apparently, tree A is a balanced tree; otherwise, we can use low-delay-jump to reduce its average depth. Now consider that tree A violates the second property, i.e., there is at least one node x whose out-degree is smaller than another node y but is closer to the root. We first consider the case that y is a descendant of x (as shown in the lower general portion of ). In this case, we can swap nodes x and y, with node y still taking its other children (e.g., node z). This operational procedure reduces the depth, which contradicts the original assumption that tree A has minimized average depth. For the case that node y is not node x's descendant, we can first swap node y with one of node x's descendants at the same level. This operation does not change the average depth, but node y now becomes a descendant of node x; so we can then apply the swapping as in the previous case to reduce tree A's average depth.","Next, we define a normalization operation that swaps only nodes at the same level if the left one has lower out-degree than the right one. This normalization does not change the average depth. We apply this operation iteratively to a tree until no swap can be applied. Such a normalized tree has the following new property: at each level, the out-degrees of the nodes are non-increasing from left to right. Given our tree-based backbone and any tree with minimum average depth, the two normalized trees are isomorphic, and thus of the same average depth. In other words, a tree-based backbone can achieve a minimum average depth after high-degree-preemption and low-delay-jump nodal rearrangement procedures are iteratively completed.","In an example embodiment, there is a level of collaboration between the tree-based backbone of the tree overlay network and the mesh overlay network within the hybrid tree\/mesh overlay framework. Such collaboration may be apparent in two example respects: delivering data blocks and handling node dynamics.","With the hybrid tree\/mesh overlay framework, data blocks of a data stream are delivered via two mechanisms. In general, they are pushed over the tree-based backbone. If a gap appears in the data stream received by a network node, due to temporal capacity fluctuations in the tree-based backbone and\/or due to node dynamics (which are further discussed below), the network node may pull the missing data blocks over the mesh overlay network. An example embodiment for a relatively seamless push\/push switching buffer implementation that coordinates the tree-based backbone and the mesh overlay to make data delivery efficient while also resilient against failure is described below.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 10","b":["1000","1000","1002","1002","1000","1004"]},"In operation of an example embodiment, data blocks that are newly-received via a push mechanism over the tree-based backbone of the tree overlay network are inserted into push\/pull switch buffer  at the tree-push pointer. In other words, the tree-push pointer can indicate the latest data block delivered via the push mechanism (unless perhaps one is delivered out-of-order). Data stream  is utilized (e.g., played) at the playback pointer. When a data block is still missing (e.g., missing data block ) as data stream  reaches the mesh-pull window, the node retrieves the missing data block from a mesh neighbor node. More specifically, the node may request and then receive the missing data block over the mesh overlay network via a pull mechanism.","In this manner, most blocks can typically be received via the push mechanism over the tree-based backbone of the tree overlay network. To avoid user-detectable delays resulting from missing data blocks, such missing data blocks can be retrieved via the pull mechanism of the mesh overlay network when they are ascertained to be missing within the mesh-pull window. Consequently, missing data blocks can usually be retrieved prior to their location progressing to the playback pointer.","When a network node is temporarily disconnected from the tree-based backbone, its tree-push pointer can be disabled. The mesh-pull window is then used to pull data from its mesh neighbor nodes. When the network node connects to the tree-based backbone again, the tree-push pointer can be reactivated. In a described implementation, the location of the mesh-pull window is maintained behind the tree-push pointer; hence, it does not request data blocks that are currently being delivered by the tree-based backbone. Consequently, few (if any) duplicated data blocks may be received at the network node from both the tree-based backbone and the mesh overlay network.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 11","b":["1100","1100","1102","1112","1102","1104"]},"At block , the network node ascertains if one or more data blocks are missing in the mesh-pull window of the push\/pull switch buffer. If not, the method of flow diagram  continues at block . If, on the other hand, at least one data block is ascertained to be missing within the mesh-pull window, then at block , the network nodes requests the missing data block from at least one neighbor node of a mesh overlay network via a pull mechanism.","At block , the missing data block is received from the neighbor node(s) over the mesh overlay network via the pull mechanism. At block , the network node inserts the data block received via the pull mechanism into the push\/pull switch buffer at the position of the missing data block, which may still be located within the mesh-pull window.","A network node may gracefully depart the network overlay, or it may abruptly fail without any notification. For an example embodiment, in the former situation, the network node proactively informs its mesh neighbors of the mesh overlay network and at least its tree-based backbone children if it resides in the tree-based backbone as a stable node. In the latter situation, the abrupt departure can be detected by the mesh neighbors after a silent period with no control message exchange; it may also be detected by the children nodes in the tree-based backbone after observing persistent losses. In either case, the mesh neighbors reestablish neighbor relationships, or neighborships, with other known nodes from their local node lists; additionally, the children of the departing\/failing node relocate to different parents in the tree-based backbone.","If the affected child is an unstable node in the outskirts of the tree-based backbone, it can consult\/access its local node list and directly attach to a different parent node that is nearest to the source node and has sufficient available bandwidth. On the other hand, if the affected child is a stable node, it rejoins the tree-based backbone. To this end, the node first locates a tree-based backbone node having sufficient available bandwidth, and then second it attaches itself thereto. If no such stable backbone node is known, the node can preempt the position of an unstable node that is currently a child of a stable backbone node. In these dynamic-node-handling processes, the mesh overlay temporarily takes over data delivery until the tree-based backbone is repaired.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 12","FIG. 1"],"b":["1200","1202","102","1202","1202","1","1202","1214","1202","1202","1214","1202"],"i":"d"},"Generally, a device  may represent any computer or processing-capable device, such as a server device; a workstation or other general computer device; a data storage repository apparatus; a personal digital assistant (PDA); a mobile phone; a gaming platform; an entertainment device; a router computing node; a mesh or other network node; a wireless access point; some combination thereof; and so forth. As illustrated, device  includes one or more input\/output (I\/O) interfaces , at least one processor , and one or more media . Media  include processor-executable instructions .","In an example embodiment of device , I\/O interfaces  may include (i) a network interface for communicating across network , (ii) a display device interface for displaying information on a display screen, (iii) one or more human-device interfaces, and so forth. Examples of (i) network interfaces include a network card, a modem, one or more ports, a network communications stack, a radio, and so forth. Examples of (ii) display device interfaces include a graphics driver, a graphics card, a hardware or software driver for a screen or monitor, and so forth. Examples of (iii) human-device interfaces include those that communicate by wire or wirelessly to human-device interface equipment  (e.g., a keyboard, a remote, a mouse or other graphical pointing device, etc.).","Generally, processor  is capable of executing, performing, and\/or otherwise effectuating processor-executable instructions, such as processor-executable instructions . Media  is comprised of one or more processor-accessible media. In other words, media  may include processor-executable instructions  that are executable by processor  to effectuate the performance of functions by device . Processor-executable instructions may be embodied as software, firmware, hardware, fixed logic circuitry, some combination thereof, and so forth.","Thus, realizations for hybrid tree\/mesh overlays for data delivery may be described in the general context of processor-executable instructions. Generally, processor-executable instructions include routines, programs, applications, coding, modules, protocols, objects, components, metadata and definitions thereof, data structures, application programming interfaces (APIs), etc. that perform and\/or enable particular tasks and\/or implement particular abstract data types. Processor-executable instructions may be located in separate storage media, executed by different processors, and\/or propagated over or extant on various transmission media.","Processor(s)  may be implemented using any applicable processing-capable technology, and one may be realized as a general purpose processor (e.g., a central processing unit (CPU), a microprocessor, a controller, etc.), a graphics processing unit (GPU), a special-purpose processor, a derivative or combination thereof, and so forth. Media  may be any available media that is included as part of and\/or accessible by device . It includes volatile and non-volatile media, removable and non-removable media, storage and transmission media (e.g., wireless or wired communication channels), hard-coded logic media, combinations thereof, and so forth. Media  is tangible media when it is embodied as a manufacture and\/or as a composition of matter. For example, media  may include an array of disks or flash memory for longer-term mass storage of processor-executable instructions , random access memory (RAM) for shorter-term storing of instructions that are currently being executed and\/or otherwise processed, link(s) on network  for transmitting communications, and so forth.","As specifically illustrated, media  comprises at least processor-executable instructions . Generally, processor-executable instructions , when executed by processor , enable device  to perform the various functions described herein. Such functions include, but are not limited to: (i) those acts that are illustrated in the flow diagrams (of , , and ); (ii) those actions implementable by the illustrated components for hybrid tree\/mesh data delivery (of ); (iii) those actions undertaken to establish, evolve, enhance, or otherwise organize an overlay network (e.g., of , , , , , and ); (iv) the push\/pull coordination between a tree overlay network and a mesh overlay network (e.g., of ); combinations thereof; and so forth.","The devices, acts, aspects, features, functions, procedures, nodes, data structures, techniques, components, etc. of  are illustrated in diagrams that are divided into multiple blocks and other elements. However, the order, interconnections, interrelationships, layout, etc. in which  are described and\/or shown are not intended to be construed as a limitation, and any number of the blocks and\/or other elements can be modified, combined, rearranged, augmented, omitted, etc. in any manner to implement one or more systems, methods, devices, procedures, media, apparatuses, arrangements, etc. for hybrid tree\/mesh overlays for data delivery.","Although systems, media, devices, methods, procedures, apparatuses, mechanisms, schemes, approaches, processes, arrangements, and other example embodiments have been described in language specific to structural, logical, algorithmic, and functional features and\/or diagrams, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like and\/or corresponding aspects, features, and components.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
