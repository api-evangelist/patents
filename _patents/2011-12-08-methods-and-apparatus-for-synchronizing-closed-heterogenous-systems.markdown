---
title: Methods and apparatus for synchronizing closed heterogenous systems
abstract: Methods, systems, and computer program products for synchronizing a first closed system with a second closed system are disclosed. A first transaction synchronization function on a first computing device receives a first plurality of user transactions and stores corresponding transaction records in a first synchronization file in a common format. The first transaction synchronization function submits the first plurality of user transactions to the first closed system via a first vendor interface for application to a first database. A second computing device accesses the first synchronization file, translates the transaction records in accordance with a second vendor interface, and submits the translated transaction records to a second closed system via a second vendor interface for application to a second closed system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08880464&OS=08880464&RS=08880464
owner: Lockheed Martin Corporation
number: 08880464
owner_city: Bethesda
owner_country: US
publication_date: 20111208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE DISCLOSURE","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present disclosure relates to synchronization of systems, and in particular to synchronization of a first closed system with a second closed system.","Organizations, such as private companies or governmental agencies, commonly purchase relatively complex third-party products that help them achieve their primary goals. For example, a company that manufactures and markets electronic products may need a third-party human resources product to help the company manage its employees, a third-party supply chain product to help the company manufacture its products, a third-party customer relationship product to help maintain relationships with customers, and the like. Generally, such third-party products provide the desired functionality, and manage large amounts of data that are relevant to such desired functionality. Management of data is in itself a highly complex function, and third-party products frequently incorporate a database management system (DBMS) that is manufactured by yet another party that specializes in the management of data. A DBMS is commonly a combination of complex database access routines that manipulate data structures, and the actual data structures (i.e., the \u201cdatabase\u201d) manipulated by the database access routines.","Typically, a third-party product interfaces with a DBMS through a programmatic interface that is native, or unique, to that DBMS vendor. Such native database interface allows the third-party product to store, retrieve, and modify data necessary to the functionality of the third-party product, in a manner dictated by the DBMS vendor.","Third-party products typically provide user interface functions that allow employees of the company to enter, retrieve, and modify data maintained by the third-party product. Often a third-party product will also provide a programmatic interface, such as an application programming interface (API), that allows a company that has purchased the third-party product to develop software that can interface with the third-party product programmatically to enter, retrieve and modify data. Consequently, the company may have no ability to directly access the underlying DBMS used by the third-party product, and thus, with respect to the underlying DBMS system, may be limited to the functionality implemented by the third-party vendor. If the company would like additional access to the underlying DBMS, the company must request the third-party vendor to implement such functionality, which may or may not be feasible, and even if feasible, may not be implemented in a timely manner by the third party. Such a third-party product will be referred to herein as a \u201cclosed system,\u201d since the company using the third-party product has no, or only limited, ability to modify the third-party product, and does not have direct access to the underlying DBMS.","Such closed systems can make data synchronization with other systems difficult, or impracticable. It is not uncommon for a company, over time, to develop multiple systems that rely on the same data, requiring propagation of data from one system to another system. This can happen, for example, as a company grows and purchases other companies, which have in place their own third-party products, e.g., a customer relationship management (CRM) product, that differ from the systems of the purchasing company. It may be highly desirable to keep the two different CRM systems in synchronization with one another, but this may not be possible because the systems may be provided by two different vendors, even where such vendors utilize the same underlying DBMS system.","In some situations, an organization may implement multiple instances of the same third-party product throughout the organization, but desire synchronization among such instances, or desire synchronization of modifications made by client instances with a master instance. Again, such synchronization functionality, if not expressly provided by the third-party vendor, may not be possible. Accordingly, there is a need for a mechanism that allows synchronization among closed systems, and that does not require modification of a closed system, or direct access to an underlying DBMS used by the closed system.","Embodiments disclosed herein relate to synchronization of closed systems. In one embodiment, a first closed system includes a first vendor interface, a first native database interface, and a first database. A second closed system includes a second vendor interface, a second native database interface, and a second database. Both closed systems are configured to submit transactions received via the respective vendor interfaces to the respective native database interfaces for application to the respective databases.","A first transaction synchronization function executing on a first computing device receives a first plurality of user transactions. Each of the user transactions identifies a user action and data that identifies a desired modification to the first database. The first transaction synchronization function stores the first plurality of user transactions in a first synchronization file in a common format. The first transaction synchronization function also submits the first plurality of user transactions to the first closed system via the first vendor interface for application to the first database.","A second transaction synchronization function accesses the first synchronization file, translates the user transactions from the common format to a vendor format suitable for submission to the second vendor interface, and submits the translated user transactions to the second closed system via the second vendor interface for application to the second database. In one embodiment, the first vendor interface differs from the second vendor interface. In this manner, embodiments disclosed herein synchronize data among closed systems without modification of the closed systems.","In one embodiment, a plurality of closed system instances is provided on a plurality of client computing devices. Each of the closed system instances includes a vendor interface, a native database interface, and a database. Each of the client computing devices includes a transaction synchronization function that stores in a respective synchronization file user transactions that identify a user action and data that identifies an intended modification to the respective database. The transaction synchronization functions also submit the user transactions to the respective closed systems for application to the respective databases via the respective vendor interfaces. The client computing devices may be isolated and not communicatively coupled to a master computing device. The respective synchronization files may be stored on portable media, such as flash drives, and transported to the master computing device for synchronization with a master closed system. The master closed system includes a master vendor interface, a master native database interface, and a master database. Each of the user transactions in the synchronization files are in the common format, irrespective of the particular vendor interface associated with the closed system to which the user transactions were initially submitted. A transaction synchronization function on the master computing device accesses the synchronization files, translates the user transactions from the common format into a format suitable for the master vendor interface, and submits the user transactions to the master vendor interface for application to the master database.","Those skilled in the art will appreciate the scope of the present disclosure and realize additional aspects thereof after reading the following detailed description of the preferred embodiments in association with the accompanying drawing figures.","The embodiments set forth below represent the necessary information to enable those skilled in the art to practice the embodiments and illustrate the best mode of practicing the embodiments. Upon reading the following description in light of the accompanying drawing figures, those skilled in the art will understand the concepts of the disclosure and will recognize applications of these concepts not particularly addressed herein. It should be understood that these concepts and applications fall within the scope of the disclosure and the accompanying claims.","Embodiments disclosed herein relate to synchronization of closed systems without modification to the closed systems. Closed systems comprise systems that provide a primary functionality and utilize a database management system (DBMS) to store, maintain, and otherwise manage data. A closed system includes a vendor interface, a native database interface, and a database. A closed system is configured to submit a transaction received via the vendor interface to the native database interface for application to the database. The native database interface and the database may be components that are included in the closed system but that are manufactured by an entity that differs from the entity that provides the closed system. Access to the closed system, other than via the vendor interface, may be precluded.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 2","FIG. 1","FIGS. 1 and 2"],"b":["10","12","14","16","12","16","16","18","16","16","18","16"]},"The first closed system  may be provided to the user  in a manner that precludes any entity other than the vendor that manufactures the first closed system  from modifying the first closed system , or otherwise accessing the first database . For example, the first closed system  may be sold or otherwise licensed in object code only (OCO) form. The first closed system  offers a first vendor interface, however, that enables automated, such as programmatic, interaction with the first closed system , including the submission of user transactions for application to the first database . The first vendor interface may comprise any conventional interface that permits programmatic interaction with a software module, such as an application programming interface (API).","The first computing device  includes a first transaction synchronization function  that interacts with the first closed system  via the first vendor interface. The first transaction synchronization function  also interacts with, or includes, a user interface (not illustrated) that allows the user  to interact with the first transaction synchronization function , and through the first transaction synchronization function , with the first closed system . Such interactions may include the retrieval of data from the first database , modification of existing data in the first database , or addition of new data in the first database . Note that throughout the Figures, the term \u201ctransaction\u201d may be shortened to \u201cxaction,\u201d and the term \u201csynchronization\u201d to \u201csync.\u201d","Assume that over a period of time the first computing device  receives a plurality of user transactions  from the user  (, step ). Each of the user transactions  contains an intended, or desired, modification to the first database . For each user transaction , the first transaction synchronization function  generates a transaction record in a common format (, step ). The transaction record contains information associated with the submission of the user , such as the data that is to be updated; the desired action, such as create, modify, or delete; or the like. The common format is independent of a vendor interface of the first closed system  and a native database interface of the first database . The common format may be any suitable format that enables another translation synchronization function to recreate the user transaction, as discussed in greater detail herein, for submission to another closed system. In one embodiment, the common format utilizes Extensible Markup Language (XML).","The first transaction synchronization function  stores each transaction record into a synchronization file  (, step ). The first transaction synchronization function  also formats each user transaction  for submission to the first closed system  in accordance with the first vendor interface (, step ). The first transaction synchronization function  then submits the user transaction  to the first closed system  for application to the first database . It should be apparent that certain steps discussed herein could be done in a different sequence without altering the outcome of the process. For example, the first transaction synchronization function  could first submit the user transaction  to the first closed system , and then generate and store the transaction record in the synchronization file .","At a point in time, it may be desirable to synchronize the first closed system  with a second closed system . The second closed system  may execute on, or be coupled to, a second computing device . The second closed system  contains a second database , and offers a second vendor interface that permits automated communications with other modules, such as a second transaction synchronization function . The second closed system  may be a copy of, i.e., an instance of, the first closed system , or may be a completely different closed system from the first closed system . Consequently, the second vendor interface may be identical to the first vendor interface, or may be a completely different vendor interface. Assume for purposes of illustration that the second closed system  is a different closed system from the first closed system , and thus, that the second vendor interface differs from the first vendor interface. Such a situation may arise, for example, when two different closed systems that provide different primary functionality to an organization rely on certain common data, such that the two different closed systems contain copies of the same data, and a modification of the data in one closed system requires synchronization of the data with the other closed system.","In one embodiment, the first computing device  may not be communicatively coupled to the second computing device , in which case the synchronization file  may be copied onto a portable storage medium, such as a flash drive or the like, and copied to a location accessible to the second computing device  (, step ). The second computing device  accesses the synchronization file  (, step ). The second transaction synchronization function  translates each transaction record in the synchronization file  into a vendor format suitable for submission to the second vendor interface associated with the second closed system  (, step ). The second transaction synchronization function  submits the translated transactions to the second closed system  (, step ).","It should be apparent that the mirror image of the process described above may also be performed to synchronize updates made to the second closed system  with the first closed system . In particular, as one or more users enter transactions to the second transaction synchronization function , the second transaction synchronization function  generates transaction records, and stores such transaction records into a second synchronization file (not illustrated). The second transaction synchronization function  also formats such transactions in a vendor format that is suitable for submission to the second vendor interface, and submits the transactions to the second closed system . The second synchronization file may then be made accessible to the first computing device . The first transaction synchronization function  accesses the second synchronization file and translates each transaction record in the second synchronization file into a vendor format suitable for submission to the first vendor interface associated with the first closed system . The first transaction synchronization function  then submits the translated transactions to the first closed system , thereby synchronizing the first closed system  with the second closed system .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 3","FIG. 1"],"b":["14","14","20","16","20","34","36","38","40","20","34","12","16","18","34","20","16","20","48","16","44"]},"The file interface  is a module that accesses synchronization files generated by other computing devices, such as the second computing device  (), and extracts transaction records from such synchronization files ultimately for submission to the first closed system . In one embodiment, the file interface  may be initiated as one or more separate processes that process corresponding synchronization files as users, such as the user , continue to access the first closed system  via the user interface . This may be desirable in the context of an embodiment wherein a plurality of client computer devices, each of which has its own closed system, provides synchronization files to a master computing device that contains or is coupled to a master closed system. In such embodiment, the master computing device may initiate multiple file interfaces  as computing resources permit, to allow parallel submission of the transactions contained in the synchronization files of each of the plurality of client computing devices.","The transaction processing function  receives user transactions entered by the user  from the user interface . The user transactions contain an intended, or desired, modification to the first database . For each user transaction, the transaction processing function  generates a transaction record  that is in a common format. The phrase \u201ccommon format\u201d indicates a format that is independent of the underlying closed system, such as the first closed system . Each transaction record  contains information associated with the information submitted by the user , such as the data that is to be updated; the desired action, such as create, modify, or delete; a timestamp; or the like. Exemplary common formats of a transaction record  will be discussed below in greater detail. The transaction processing function  stores each transaction record  into the synchronization file .","The vendor interface translation function  translates or otherwise formats the user transaction into a format suitable for the first closed system . In particular, the first closed system  includes a vendor interface  that permits automated, such as programmatic, interaction with the first closed system . Such vendor interface  may be the only practical, or possible, mechanism for programmatic interaction with the first closed system , because as discussed above, the first closed system  may be provided to an organization in a form that is not modifiable or that enables an organization to determine mechanisms for interacting with the first closed system . In particular, the first closed system  may be provided in an OCO format.","The vendor interface  may use any known mechanism for inter-process communications, such as, for example, an API. The vendor that manufactures the first closed system  may document the API to enable an organization to develop the vendor interface translation function  to appropriately call the API. In essence, the vendor interface translation function  is developed to invoke the appropriate methods, or functions, suitable for providing the user transaction to the first closed system  to effect updating of the first closed system . Thus, upon receipt of a user transaction or a transaction record , the vendor interface translation function  generates the appropriate interactions, such as function calls, method calls, or the like, suitable for submitting the transaction to the first closed system . Note that the vendor interface translation function  is likely different for each closed system for which synchronization is desired.","The first closed system  may use a DBMS provided by another party that specializes in the management of data. Such DBMSs typically include data structures, such as the first database , as well as database access routines  that manipulate data in the first database . Typically, the only mechanism permitted by a DBMS manufacturer for manipulation of data in a database is via the provided database access routines, to ensure consistency, recoverability, and the like. Thus, the DBMS manufacturer also provides the native database interface  that allows a third party, such as the vendor of the first closed system , to manipulate the first database . Accordingly, the vendor interface  in turn interacts with the native database interface  to submit the received user transaction to the first database . Thus, with respect to the first database , the first transaction synchronization function  may be twice removed from the ability to directly update or otherwise modify the first database .","A similar process is followed when the first transaction synchronization function  is synchronizing transactions from a synchronization file rather than receiving user transactions from the user . In particular, the file interface  reads transaction records from a synchronization file and provides the transaction records to the transaction processing function , which in turn provides the transaction records to the vendor interface translation function  for translation and submission of the data contained therein to the first closed system  via the vendor interface .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4","b":["42","42","50","42","52","42","54","42","42","56","42","42","56"]},"A timestamp field  may be used to identify the time the data was submitted by the user . The timestamp field  may be used, as discussed in greater detail herein, to determine the order in which transactions from different synchronization files have occurred. For example, if a transaction synchronization function is applying multiple user transactions from multiple synchronization files to a closed system, it may be desirable to submit them in the order that such updates were chronologically made in accordance with the timestamp contained in the respective timestamp fields . An action field  is used to identify the particular user action associated with the user transaction, such as delete, modify, or create. A version field  identifies the common format version of the common format of the transaction record . In one embodiment, the transaction synchronization function includes a transaction record translation function that detects the common format version identified in the version field , and if the identified common format version is less than a current common format version, translates the transaction record  from the identified common format version to the current common format version. This feature allows transaction records  to be synchronized even if such transaction records  were generated in a common format version that is not current.","A variable plurality of name\/value pair fields ---N (generally, name\/value pair field ) may follow the version field . Each name\/value pair field  contains a name of a data item in the first database , and a value to which the data item is to be set. Preferably, each transaction record  only contains name\/value pair fields  for those data fields that the user  has indicated are to be altered. Thus, even though the user interface  () may display a large number of data fields and data values from the first database  to the user , if the user  indicates that only three of such data values are to be changed, the corresponding transaction record  would only contain three name\/value pair fields . The name contained in each name\/value pair field  has a mapping to a particular field in each closed system. In one embodiment, each transaction record  may also comprise a unique signature, such as a hash value, for each name\/value pair , to ensure that the data contained in the name\/value pair fields  has not been tampered with.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 5","FIG. 5"],"b":["70","72","74","76","78","80","82","84","86","88","90","92","94","96","70","74","76","80","70","74"]},"Assume that over a period of time, the user  submits a plurality of user transactions to a transaction synchronization function  that executes on the computing device . As discussed above, for each such user transaction, the transaction synchronization function  generates a transaction record in the common format and stores the transaction record into a synchronization file . The transaction synchronization function  also translates or otherwise formats the user transaction into a format suitable for submission to the closed system , in accordance with the vendor interface of the closed system . The transaction synchronization function  then submits the user transaction to the closed system  via the vendor interface for application to the database .","Similarly, assume that users  and  also submit a plurality of transactions to the respective closed systems ,  for application to the databases , . As discussed with respect to the transaction synchronization function , transaction synchronization functions , , generate synchronization files ,  containing such transaction records in the common format.","At a second point in time, designated T2 in , the synchronization files , , and  are provided to a master computing device  for application to the master closed system  to synchronize the master closed system  with the closed systems -.  is a flowchart of an exemplary process that may be performed by the master computing device  to effect such synchronization, and will be discussed in conjunction with . Initially, a transaction synchronization function  executing on the master computing device  accesses the synchronization files , ,  (, step ). The transaction synchronization function  obtains the transaction records from the synchronization files , , . As the transaction synchronization function  processes each transaction record, the transaction synchronization function  determines whether the common format version of the transaction record is the current format version, and if not, updates the transaction record to the current format version (, steps -).","In one embodiment, the master database  maintains a data element timestamp for each data element in the master database  that identifies the time of the last update to such data element. The data elements correspond to name\/value pairs. The transaction synchronization function  examines each name\/value pair in the transaction record (, step ), and examines the timestamp of the transaction record. The transaction synchronization function  compares the timestamp of the transaction record to the timestamps of the data elements from the master database  that correspond to the name\/value pairs in the transaction record (, step ). If the timestamp of the transaction record is earlier than any such data element timestamp, then this may be an indication that a transaction record contained in a different synchronization file had already been applied to the master closed system , in essence out of order. In such event, the transaction synchronization function  may generate an exception event that identifies the transaction record so that the transaction record can subsequently be examined and a determination can be made about whether or not to apply the transaction record to the master closed system  (, step ). If the timestamp of the transaction record is later than the timestamps of the affected data elements of the master database , then the transaction synchronization function  translates data stored in the transaction record into a format suitable for submission to the master closed system  in accordance with the vendor interface of the master closed system  (, step ). The transaction synchronization function  then submits the translated transaction to the master closed system  for application to the master database  (, step ). During the processing of user transactions, the transaction synchronization function  may make a number of determinations to ensure that consistency of the closed system  is maintained. For example, in one embodiment, the transaction synchronization function  examines the CURR XACTION ID field  and PREV XACTION ID field  of each transaction record to ensure that transaction records are not missing. If a transaction record is missing, the transaction synchronization function  may generate an exception event.","Note that the use of data element timestamps allows for \u201cout of order\u201d transactions to be applied to the master closed system , so long as such transactions do not cause an out-of-order update to any particular data element in the master database . For example, assume that a first transaction record in a first synchronization file is created at time T3, and contains a single update to a first name\/value pair. Assume that a second transaction record in a second synchronization file is created at time T4, and contains a single update to a second name\/value pair. Assume that time T4 is later than time T3. Assume next that the second transaction record is submitted to the master closed system  before the first transaction record is submitted to the master closed system , and the data element that corresponds to the second name\/value pair is updated. Such a scenario may occur simply because the second synchronization file was provided to the master computing device  before the first synchronization file was provided to the master computing device . Assume that the first transaction record is then processed. Although the timestamp of the data element that corresponds to the second name\/value pair is later than the timestamp associated with the first transaction record, so long as the timestamp associated with the data element that corresponds to the first name\/value pair is earlier than the time T3, the first transaction record may be submitted to the master closed system  without causing concern about an out-of-order update to the data. The first transaction record will only update the data element associated with the first name\/value pair, and will not affect the data element associated with the second name\/value pair.","Synchronization at the public access layer provides many advantages over synchronization at the data access layer. First, synchronization at the data access layer requires access to source code of the closed system, as well as extensive knowledge of the closed system, to ensure that modifications to the closed system to implement synchronization do not disrupt other functionality of the closed system. In contrast, synchronization at the public access layer eliminates the need for access to source code of the closed system, or knowledge of the underlying closed system. Moreover, synchronization at the public access layer eliminates the need to directly interact with the native database interfaces associated with closed systems. Moreover, complex closed systems typically include workflow processing wherein a single update to the closed system may result in multiple different database structure updates, as well as the generation of events, such as a work process order, a supply chain order, and the like. Synchronization at the public access layer eliminates the need to understand the way in which the closed system implements such workflow processing, and eliminates the likelihood that a modification to the closed system may accidentally disrupt such workflow processing.","Synchronization at the public access layer also eliminates or substantially reduces difficulties that may otherwise arise when closed system vendors release updates to products. If synchronization is performed at the data access layer, each such product update may potentially impact the synchronization process. Synchronizing at the public access layer eliminates this problem, because the underlying processing of the closed system is relatively independent of the synchronization process.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7","b":["14","14","14","120","122","124","124","122","120","120","120"]},"The system bus  may be any of several types of bus structures that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and\/or a local bus using any of a variety of commercially available bus architectures. The system memory  may include non-volatile memory  (e.g., read only memory (ROM), erasable programmable read only memory (EPROM), electrically erasable programmable read only memory (EEPROM), etc.) and\/or volatile memory  (e.g., random access memory (RAM)). A basic input\/output system (BIOS)  may be stored in the non-volatile memory , and can include the basic routines that help to transfer information between elements within the computing device . The volatile memory  may also include a high-speed RAM such as static RAM for caching data.","The computing device  may further include a computer-readable storage , which may comprise, for example, an internal hard disk drive (HDD) (e.g., enhanced integrated drive electronics (EIDE) or serial advanced technology attachment (SATA)) HDD (e.g., EIDE or SATA) for storage, flash memory, or the like. The storage  may store, for example, the first database  and synchronization file . The drives and associated computer-readable and computer-usable media provide non-volatile storage of data, data structures, computer-executable instructions, and so forth. Although the description of computer-readable media above refers to an HDD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as Zip disks, magnetic cassettes, flash memory cards, cartridges, and the like, may also be used in the exemplary operating environment, and further, that any such media may contain computer-executable instructions for performing novel methods of the disclosed architecture.","A number of program modules can be stored in the computer-readable storage  and in the volatile memory , including an operating system  and one or more program modules , which may implement the functionality described herein in whole or in part, including, for example, functionality described with respect to the first transaction synchronization function , first closed system , and other processing and functionality described herein. It is to be appreciated that the embodiments can be implemented with various commercially available operating systems  or combinations of operating systems .","All or a portion of the embodiments may be implemented as a computer program product stored on a non-transitory computer-usable or computer-readable medium, such as the storage , and including instructions configured to cause the central processing unit  to carry out the steps described herein. Thus, the computer-readable program code can comprise software instructions for implementing the functionality of the embodiments described herein when executed on the central processing unit . The central processing unit , in conjunction with the program modules  in the volatile memory , may serve as a control system for the computing device  that is configured to, or adapted to, implement the functionality described herein.","The user  may be able to enter commands and information into the computing device  through one or more input devices, such as, for example, a keyboard (not illustrated); a pointing device, such as a mouse (not illustrated); or a touch-sensitive surface. Other input devices may include a microphone, an infrared (IR) remote control, a joystick, a game pad, a stylus pen, or the like. These and other input devices may be connected to the central processing unit  through an input device interface  that is coupled to the system bus , but can be connected by other interfaces such as a parallel port, an IEEE 1394 serial port, a Universal Serial Bus (USB) port, an IR interface, etc.","The computing device  may also include a communication interface  for communicating with a network, which may comprise, for example, a wired or wireless network interface. The computing device  also preferably includes a video adapter  that interfaces with a display  that provides information to the user .","Those skilled in the art will recognize improvements and modifications to the preferred embodiments of the present disclosure. All such improvements and modifications are considered within the scope of the concepts disclosed herein and the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING FIGURES","p":["The accompanying drawing figures incorporated in and forming a part of this specification illustrate several aspects of the disclosure, and together with the description serve to explain the principles of the disclosure.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
