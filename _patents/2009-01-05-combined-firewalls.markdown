---
title: Combined firewalls
abstract: A method of providing a firewall to protect a set of virtual machines on a host node that is one of multiple host nodes that host virtual machines. The method stores a table of allowed connections for each virtual machine on the host node. Upon a particular virtual machine moving from the host node to another host node, the method deletes records of a first set of allowed connections that each identify the particular virtual machine and do not identify any other virtual machine in the set of virtual machines. Also upon the virtual machine moving, the method edits records of a second set of allowed connections, each identifying the particular machine and one other virtual machine in the set of virtual machines on the first host node, to remove an identifier of the particular virtual machine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08146147&OS=08146147&RS=08146147
owner: Juniper Networks, Inc.
number: 08146147
owner_city: Sunnyvale
owner_country: US
publication_date: 20090105
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF BENEFIT TO PRIOR APPLICATIONS","CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims the benefit of U.S. Provisional Application 61\/040,133 entitled \u201cNETWORK FIREWALLS\u201d filed Mar. 27, 2008, U.S. Provisional Application 61\/101,111 entitled \u201cNETWORK FIREWALLS\u201d filed Sep. 29, 2008, U.S. Provisional Application 61\/109,915 entitled \u201cNETWORK FIREWALLS\u201d filed Oct. 30, 2008, and U.S. Provisional Application 61\/120,376 entitled \u201cMOVING SECURITY FOR VIRTUAL MACHINES\u201d filed Dec. 5, 2008, all of which U.S. Provisional Applications are hereby incorporated by reference.","This Application is related to the following applications: U.S. patent application Ser. No. 12\/348,896, filed Jan. 5, 2009; U.S. patent application Ser. No. 12\/348,897, filed Jan. 5, 2009; and U.S. patent application Ser. No. 12\/348,898, filed Jan. 5, 2009.","This application concerns computer security. In particular firewalls for hosting systems with virtual machines.","In recent years it has become increasingly common for corporations and individuals to run computer programs on virtual machines on servers. Virtual machines are simulated computers that are simulated by other computers. The physical computers on which the virtual machines run are also referred to as \u201chosts\u201d or \u201chost computers\u201d. To the programs running on the virtual machines, there is little or no discernable difference between running on a virtual machine and running on a whole computer.","Virtual machines have several advantages. When a user wants to run multiple applications that each work best on a different operating system (e.g., Windows 95\u00ae or Windows XP\u00ae), then the user can implement two virtual machines on a single computer. That is, one virtual machine running the Windows 95 operating system and one virtual machine running the Windows XP\u00ae operating system.","Another advantage of using a virtual machine is that the operating system and application or applications running on the virtual machine may require only a fraction of the full resources of the physical computer on which the virtual machine is running. Thus, multiple virtual machines can run on the same physical computer, saving hardware costs.","Still another advantage is that virtual machines can be instantiated as needed, then shut down when no longer needed, freeing the resources of the physical computer to run other virtual machines. Therefore, a system with multiple virtual machines that are needed at different times saves more resources by running each virtual machine only when that virtual machine is needed.","One popular application of virtual machines is running them on a hosting system. A hosting system runs multiple physical computers (also referred to as \u201cservers\u201d or \u201chost nodes\u201d) that each run multiple virtual machines (also referred to as \u201chosting\u201d the virtual machines). Some hosting systems can move virtual machines among the host nodes. For example, a hosting system may host four virtual machines on one host node while the four virtual machines have low resource requirements. Later, if the resource requirements of one of the virtual machines increase, the hosting system can move one of the virtual machines to another host node.","As virtual machines are intended to accurately simulate individual computers, they often have the same security vulnerabilities as individual computers. For example, virtual machines can be infected with computer worms and can suffer from other unauthorized accesses. The problems of infected machines are magnified as some prior art hosting systems do not protect virtual machines from unauthorized access by other virtual machines on the same host node. In such a hosting system, worm-infected virtual machines can infect other virtual machines on the same host node. When any of the infected virtual machines are moved to other host nodes, they may carry the infection with them. In time, the infection of one virtual machine in such a hosting system can result in an infection spreading to all the virtual machines on the hosting system.","In order to protect virtual machines from unauthorized access and to protect the hosting system itself and individual host nodes from unauthorized access and infection, firewalls are implemented. A firewall is computer software running on a particular machine or stored on a computer readable medium, hardware, or a combination of hardware and software that checks incoming and\/or outgoing packets of data against an existing list of characteristics that determine whether the packets should be allowed to continue to their destination or should be blocked.","In systems hosting virtual machines, firewalls can be run on the hosting system itself and on individual virtual machines. The firewalls of prior-art hosting systems were not efficiently coordinated; accordingly there is a need in the art for a coordinated firewall for a hosting system.","Some embodiments provide security for virtual machines that run on a plurality of host nodes of a hosting system. The security includes firewalls for the virtual machines on the hosting system. Some embodiments implement one firewall on each host node. A firewall is computer software running on a particular machine or stored on a computer readable medium, hardware, or a combination of hardware and software that checks incoming and outgoing packets of data against an existing list of characteristics that determine whether the packets should be allowed to continue to their destination or should be blocked. Users of the hosting system, including the system administrators, and in some embodiments other users, set security policies for the firewalls. The policies of some embodiments are conditional statements that indicate conditions under which packets of data should be allowed to pass through the firewall of a host node or should be blocked. Some embodiments store connection data with information about packets previously allowed to pass according to the policies enforced by the firewall.","Some embodiments provide a system for moving firewall policies and connection data that pertain to individual virtual machines from one host node to another. When a virtual machine is moved to a new host node, the firewall policies and connection data pertaining to that virtual machine are moved to the firewall of the new host node. In some embodiments, the connection data relating to virtual machines on a host node is grouped together as a single connection table in the firewall of the host node. In some such embodiments, the connection table is split when a virtual machine moves and connection data relating to the moved virtual machine is moved to the firewall of that virtual machines new host node. The moved connection data is then merged with the existing connection table of the firewall of the new node. Some embodiments provide different policies for an initial packet than for a reply packet. Some embodiments provide firewalls that enforce multi-layered policies. In some such embodiments, policies of different layers may be set by users with different levels of authority over the firewall system. The environment in which some embodiments operate, and further details of the various embodiments are described below.","In some embodiments, firewalls intercept packets of data on their way to and from virtual machines on host nodes of the hosting system. In some embodiments, each virtual machine has a set of policies associated with that virtual machine. The firewall policies and connection tables for all virtual machines on a given host node are implemented by a firewall for that host node (the firewall of a host node is sometimes referred to herein as a \u201cvirtual network firewall\u201d). The virtual network firewall allows packets of data to pass to or from a particular virtual machine only if those packets are permissible according to the policies applicable to that particular virtual machine. For example, a virtual network firewall might allow all packets from one particular computer address (i.e., an IP address) and deny all packets from another particular IP address.","The information about the source address, destination address, source port, destination port, and the protocol of a packet is sometimes referred to as \u201cconnection data\u201d or \u201ca connection\u201d. The firewalls of some embodiments store connection data for allowed packets. That is, when a firewall allows a packet to pass, the connection data for that packet is stored in a connection table of the firewall. The connection tables of some embodiments include identifiers of the virtual machine that is the source or destination of that connection. In some embodiments, a single connection table on each host node includes the connection data for all virtual machines on that host node.","The firewall policies and connection data relating to a given virtual machine are needed on the host node that is hosting that virtual machine. In some embodiments, the policies and connection data relating to a virtual machine are not needed on any other host node in the system. In order to make sure that the firewall policies and connection data for a particular virtual machine are available to the host node of that virtual machine and are not using up resources on other host nodes, some embodiments provide a firewall coordinator (also referred to as a \u201ccentral controller\u201d or a \u201cmanagement console\u201d) to coordinate firewall policies and track the locations of the virtual machines on the hosting system. In some embodiments, the firewall coordinator is implemented as a dedicated hardware device. In some embodiments, the firewall coordinator is entirely implemented as software running on a particular machine, such as a computer (or stored in a computer readable medium). In some embodiments, the firewall coordinator is a piece of software, running on a particular machine, such as a computer, that receives new firewall policies and updates the policies of individual software firewalls running on virtual machines on the particular machines of the host nodes. In some embodiments, the firewall coordinator coordinates the transfer of firewall policies and connection data (e.g., the firewall policies and connection tables for the firewalls) to the host nodes on which the virtual machines are running.","When a virtual machine is moved to a new host node, the virtual network firewall of the new host node detects the arrival of a virtual machine that had not been running on that host node. When the virtual network firewall detects a new virtual machine, the virtual network firewall contacts the firewall coordinator to determine on which host node, if any, the new virtual machine had previously been running. When the virtual machine had previously been running on another host node, the virtual network firewall contacts the virtual network firewall of that other host node to retrieve the firewall policies and connection table data for the new virtual machine. When the virtual machine was not previously running on another host node, the virtual network firewall receives the firewall policies for the virtual machine from the firewall coordinator.","As mentioned above, some embodiments store tables of connection data that include source and destination address information of allowed packets and identifiers of the virtual machines that are the sources or destinations of the allowed packets. In some embodiments, both the source and the destination of allowed packets are virtual machines on the same node. That is, in some embodiments, virtual network firewalls apply policies to packets going between two virtual machines on a host node. Such a firewall may be referred to as an \u201cintra-node firewall\u201d. When a virtual machine on a host node sends a packet addressed to another virtual machine on the same host node, the intra-node firewall determines both whether the source virtual machine is allowed to send the packet to the destination virtual machine and also whether the destination virtual machine is allowed to receive the packet from the source virtual machine. When the source virtual machine is allowed to send the packet and the destination virtual machine is allowed to receive the packet, the virtual network firewall stores connection data for the packet as a combined entry in the connection table. Like a regular entry in a connection table, a combined entry includes the address information for a connection. However, where a non-combined entry only identifies the source virtual machine or the destination virtual machine, a combined entry identifies both the source virtual machine and the destination virtual machine.","A combined entry in a connection table indicates that both the source virtual machine and the destination virtual machine of an allowed packet are running on the same host node as each other and the firewall with the connection table. When a virtual machine referred to in a combined connection is moved to another node, the combined entry no longer accurately reflects the situation. That is, the combined entry incorrectly indicates that the moved virtual machine is on the same node as the other virtual machine in the entry.","As mentioned above, in some embodiments, connection data for all the virtual machines on a host node are stored in a single table. When a virtual machine moves from one host node to another host node, the connection table data is sent to the new host node, entries relating to the moved virtual machine are added to the connection table of the new host node, and then deleted from the connection table of the old host node.","In some embodiments with combined entries, the virtual network firewall of the original host node splits a connection table by 1) sending copies of the entries relating to the moved virtual machine to the virtual network firewall of the new host node, 2) deleting the entries solely relating to the moved virtual machine, and 3) editing combined entries that relate to both the moved virtual machine and to virtual machines that are remaining on the original host node. In some embodiments, editing the entries removes the portion of the entries that relate to the moving virtual machine and keeps the portion relating to virtual machines that remain on the host node. In some embodiments, the old host node edits the copied connection data that it is sending to remove references to the other virtual machines on the old host node. In other embodiments, the new host node edits the copied connection data to remove references to the other virtual machines on the old host node.","In some embodiments, when a virtual machine is moved to a new node, that node may be hosting another virtual machine that the moved virtual machine had previously contacted. The connection table of the new host node would include an entry for that contact, indicating that the firewall of the new node had allowed the other virtual machine to receive packets from the moved virtual machine (before the moved virtual machine was moved). Similarly, the connection data for the moved virtual machine would include an entry indicating that the firewall of the previous host node had allowed the moved virtual machine to send packets to the other virtual machine (on the new host node). The two entries would have identical address information. To store the information in the entries in the same connection table, the firewall of the new host node merges the entries into a single entry indicating that the firewall policies had allowed both the moved virtual machine to send the packets and the other virtual machine to receive the packets.","In some embodiments that split and merge connection tables, as described above, the connection table entries relating to the various virtual machines do not reflect whether the allowed connections happened while the virtual machines were on the same node, or on different nodes. Instead the connection table entries for connections between two virtual machines indicate whether the allowed connections are between virtual machines currently on the same node or currently on different nodes.","Some embodiments use connection table entries to determine which of two different sets of policies should be applied to a packet. For example, in some embodiments, the firewall checks the connection table to determine whether a packet is a reply to a previously allowed packet. The firewalls of such embodiments apply a different set of policies when a packet is a reply packet than when a packet is an original packet. When an original packet passes through the virtual network firewall (i.e. is allowed to pass by the firewall policies), addresses of the source and destination of the packet are stored in the connection table. When the virtual network firewall subsequently receives a \u201creply packet\u201d (e.g., a packet with source and destination addresses that are the reverse of an original packet whose connection data is stored in the connection table), then the virtual network firewall uses a set of policies (also referred to as \u201creverse policies\u201d) that apply only to reply packets to determine whether the reply packet is to be allowed to pass. The reverse policies are a set of policies that are different from the policies that would be applied if a packet with the source and destination addresses of the reply packet had arrived at the virtual network firewall when an the original connection is not stored in the connection table.","As discussed above, the firewalls of the host nodes apply various policies to determine whether to allow a packet to pass. In some embodiments, such policies are set using the firewall coordinator. Because many entities (e.g., companies, administrators, users, user accounts of a single user, etc.) may have valid interests in what packets a particular virtual machine can send or receive, the firewall coordinators of some embodiments allow users of various levels of authority to provide different layers of firewall policies for a virtual machine. These various layers allow the higher level users (e.g., systems administrators and office supervisors) to determine whether access will be granted or denied for a particular packet or whether the decision to grant access or deny access will be delegated to a lower level set of firewall policies. The firewall coordinator then provides the layers of policies pertaining to each virtual machine to the virtual network firewall of the host node that hosts that virtual machine. The virtual network firewall determines whether packets will be allowed based on those policies. In embodiments where policies move from host node to host node, the layered policies move as well.","In some embodiments, the virtual network firewall, the firewall coordinator, and other parts of the system described above include multiple modules that perform the various different functions disclosed herein. Further details of the modules of some embodiments are provided below. The modules described are provided as examples. One of ordinary skill in the art will realize that some embodiments can be implemented with details that differ from those described below while remaining within the scope of the invention. Accordingly, the scope of the claimed inventions will be provided in the claims.","In the following description, numerous details are set forth for purpose of explanation. However, one of ordinary skill in the art will realize that the invention may be practiced without the use of these specific details.","I. Overview","Virtual machines are simulated computers that are simulated by other computers (e.g., particular, physical machines). Virtual machines are often run on large systems of physical computers (e.g., servers) that are networked together. Such a networked system is sometimes referred to as a \u201cserver farm\u201d or a \u201chosting system\u201d. In a hosting system, multiple physical computers each simulate one or more virtual computers. The physical servers that virtual machines run on are sometimes referred to as \u201chost nodes\u201d or \u201cnodes\u201d.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 1","b":["100","100","105","110","115","120","105","125","130","135","140","140","110","110","145","110","145","150","120","165"]},"The controller program  of some embodiments tracks the resource usage of the virtual machines - on the host nodes. When the controller program  determines that a virtual machine should be moved, the controller program  commands the host node on which the virtual machine is running to send the virtual machine to a designated host node. For example, host node  is hosting four virtual machines while host node  is only hosting one. Therefore, as indicated by arrow , the controller program  has commanded host node  to send virtual machine  to host node  as indicated by arrow . In some embodiments, a system administrator  can also command the controller program  to move virtual machines from one host node to another.","In some embodiments, each virtual machine has an IP address. When a packet is sent from a computer (or other device) on the Internet to one of those IP addresses, the packet will arrive at a router  of the hosting system (e.g., a physical router). The router  of some embodiments forwards the packet to the host node on which the virtual machine with that IP address is running. In some embodiments, the controller program  directly notifies the router  which host node each virtual machine is on. In other embodiments, a host node that receives a virtual machine sends a packet that reveals the new location of the virtual machine on the hosting system to the router . In some embodiments, the packet that the host node sends to the router  includes a Media Access Control (MAC) address of the virtual machine.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 2","b":["200","210","212","214","212","214","220","222","224","226","210","230"]},"The firewalls are implemented to protect virtual machines of a hosting system from unauthorized access. The firewalls of some embodiments are computer applications that check the characteristics of incoming and\/or outgoing packets of data against a list of pre-set security policies (sometimes simply called \u201cpolicies\u201d) that determine whether the packets should be allowed to pass or blocked from passing. The data packets that come in are stored on computer readable media before the firewalls determine whether they should be allowed to pass. The firewalls transform sets of data packets, stored on computer readable media, into other sets of data packets, stored on computer readable media, with the blocked packets removed from the transformed set. In some embodiments, the data packets comprise computer code. In some embodiments, the data packets comprise images or other representations of real world items (e.g., digitized x-rays of bones, photographs, video camera footage etc.). Firewalls of some embodiments record various characteristics of allowed packets on computer readable media. In some embodiments, the recorded characteristics include an IP address and port number of the source and destination of the packet and a protocol of the packet.","In some embodiments, multiple virtual machines are part of a virtual local area network (VLAN). Virtual machines that are part of a VLAN add tags to the packets that they send that identify the packets as coming from a virtual machine in the VLAN. Some embodiments use policies that evaluate the presence of a VLAN tag in determining whether or not to allow a packet.","As mentioned above, in a hosting system, virtual machines can be moved from one host node to another. In prior art hosting systems, each host node had to be prepared at all times to provide a firewall for each and every virtual machine that could potentially be started on the host node or moved to the host node.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 3","FIG. 3"],"b":["310","312","1","407","314","316","318","312"]},"The use of a firewall with all the policies of every virtual machine that might run on the host node allows virtual machines to move to new host nodes, but uses a large amount of memory and computer resources of each host node. For example, the firewall policies for a virtual machine may include thousands of policies. In the prior art system, the firewall of each host node might have to keep hundreds of thousands of policies available just in case one of the virtual machines arrived on the node. Similarly, some prior art firewalls would have to evaluate each packet against all of those hundreds of thousands of policies.","Some embodiments provide firewalls, with various novel features, for securing virtual machines on host nodes. In some embodiments, multiple elements described below can be implemented in the same system. However, some embodiments may separately employ various elements described below. For example, some embodiments enforce firewall policies and store connection data for all the virtual machines on a host node, and can move those firewall policies and connection data between firewalls on different host nodes. These elements can be used with or without the later described \u201cintra-node firewalls\u201d that in some embodiments provide additional refinements for providing security between two virtual machines on the same host node.","However, elements of embodiments described for moving firewall policies can also be implemented in systems that do not provide firewall protection between two virtual machines on the same host node. Similarly, elements of the below described combined firewalls and hierarchical firewalls may be implemented in systems that use some or none of the other elements described in various embodiments.","II. Moving Firewall Policies and Connection Table Data","A. Introduction","In some embodiments, each host node implements a separate firewall. A firewall coordinator coordinates the firewalls on the various host nodes.  illustrates a firewall system of such embodiments. In the figure, each of the host nodes , , and  of hosting system  has its own virtual network firewall, firewalls , , and  respectively. The firewalls , , and  are controlled by firewall coordinator . The virtual machines are controlled by control program  on control server . In some embodiments, the firewalls or firewall coordinator are dedicated pieces of hardware, or are software running on dedicated pieces of hardware (e.g., particular machines).","However, in other embodiments, the firewalls, the firewall coordinators, and the virtual machines are all implemented entirely as software on particular machines. In some embodiments, these particular machines are general purpose computers that implement the specific functions of the firewalls when the firewall software is run on the machines. In some embodiments, some or all of the software runs on computers with one processor per computer and in some other embodiments, some or all of the software runs on computers with more than one processor per computer. In some embodiments, the firewall coordinator has no dedicated hardware. In some embodiments, the firewalls coordinated by the firewall coordinator have no dedicated hardware. In some embodiments, the virtual machines protected by the firewalls and the firewall system coordinated by the firewall coordinator have no dedicated hardware. The firewalls and firewall coordinators of some embodiments are described below.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 5","b":["500","505","507","510","500","314","318","510"]},"Virtual network firewall  protects all three virtual machines -. The firewall  includes security data , , and  for each virtual machine , , and  currently on the host node . The security data for each virtual machine includes lists of policies that allow the firewall  to determine whether to allow access to that virtual machine. In some embodiments, the security data for each virtual machine also includes data about previously accepted packets sent to or from that virtual machine. Unlike the prior art system illustrated in , the security data in firewall  does not include security data for all virtual machines of the hosting system, just the virtual machines currently running on host node . Similarly, firewall  includes security data only for the virtual machines on host node .","When a virtual machine is moved to a new host node by the hosting system , the security data for that virtual machine is moved from the virtual network firewall of the previous host node to the virtual network firewall of the new host node. In some embodiments, the firewall system does not need to be informed by the hosting system that a virtual machine is moving. Such embodiments automatically determine that a virtual machine has moved to a new host node and move the security data for that virtual machine to the new host node automatically.","In order to protect the virtual machines and the host node, the virtual network firewalls of some embodiments are \u201cpositioned\u201d to intercept any packets passing to or from virtual machines. That is, the hosting system  is programmed to send any incoming or outgoing packets through the virtual network firewall.  illustrates a host node  with a virtual network firewall  of some embodiments. The host node  includes several virtual machines, for example virtual machines , , and , virtual switches  and , and virtual network firewall . Virtual switches route packets among virtual machines. In some embodiments, virtual switches route packets based on MAC addresses in the packets. In some embodiments, the virtual switches route packets based on other characteristics of the packets. In some embodiments, there are three reasons for a packet to be on a host node. First, the packet could be an incoming packet from outside the host node to a virtual machine on the host node. Second, the packet could be an outgoing packet from a virtual machine on the host node to an address outside the host node. Third, the packet could be an internal packet from one virtual machine on the host node to another.","Incoming packets from outside the host node  and addressed to one of the virtual machines - enter the host node through virtual switch . Virtual switch  is sometimes referred to herein as the \u201couter switch\u201d. Virtual switch  passes the packets on to the virtual network firewall . The virtual network firewall  applies a set of policies to the packet. For example, the virtual network firewall could apply policies based on the source and destination addresses of the packet and the protocol of the packet (e.g., TCP, HTTP, etc.). Packets permitted by the firewall policies are sent through to virtual switch  for distribution to the appropriate virtual machine. Virtual switch  is sometimes referred to herein as the \u201cinner switch\u201d.","Similarly, outgoing packets from one of the virtual machines - to addresses outside of the host node  pass through virtual switch , then through virtual network firewall  (if allowed by the policies of the virtual firewall), then through the virtual switch .","In some embodiments, packets from one of the virtual machines - to another virtual machine on the same host node pass through the virtual switch  to the virtual network firewall . Packets that are allowed are sent back to virtual switch  to be sent to the destination virtual machine , , or , as addressed. Packets that are not allowed by the policies applicable to a source or destination virtual machine are dropped by the virtual network firewall.","In some other embodiments, packets sent from one virtual machine on a host node to another virtual machine on the host node pass from the source virtual machine (e.g., virtual machine ), through virtual switch  to the destination virtual machine (e.g., virtual machine ) without passing through the virtual network firewall . In some such embodiments, copies of any packets sent from one virtual machine to another on the same host node are sent to the virtual network firewall  for evaluation. In some embodiments, if the virtual network firewall  determines that packets should not be allowed to pass from the source virtual machine to the destination virtual machines, the virtual network firewall sends a reset packet (e.g., a TCP reset packet) to the virtual switch .","In still other embodiments, packets from one virtual machine to another virtual machine on the same host node are not evaluated by the virtual network firewall. In some such embodiments, the virtual network firewall does not receive copies of intra-node packets. The virtual network firewalls of some such embodiments do not block any packets sent from one virtual machine to another virtual machine on the same host node and do not send reset packets in response to a packet sent from one virtual machine to another on the same host node.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 7","b":["790","760","762","764","770","750","750","760","762","764","770","770","750","750","770","750","750"]},"B. Virtual Network Firewall",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 8","b":["630","630","630","810","820","825","830","840","810","850","820","825","830","840","860","820","825"]},"Packets enter the virtual network firewall  through the network interface cards  and . The packets are either from a virtual machine on the host node to the outside, to a virtual machine on the host node from outside the host node, or from a virtual machine on the host node to another virtual machine on the host node.","From the network interface cards  and , the packets are sent to the network stack . The network stack  implements different layers of the network protocol (e.g., transport, network, and data link layers of a TCP protocol). To determine whether the packets are allowed to proceed farther, they pass through the packet filter . The packet filter  evaluates the packets in view of the policies of the firewall. Each virtual machine on the host node is associated with a set of policies that apply to that virtual machine. The policies that the packet filter uses to determine whether a given packet is allowed to proceed are the policies relevant to the virtual machine, on that packet filter's host node, that is the source or destination of the packet. The policies that a packet filter on a host node uses are provided by the daemon , which receives those policies from a firewall coordinator or from a daemon of another virtual network firewall on another node of the hosting system. The firewall coordinator and the daemon are described further below. When a packet is allowed under the policies of the firewall, the packet filter sends the packet though one of the network interface cards  and  to the inner or outer virtual switch (depending on the destination address of the packet). The virtual switch sends the packet on toward its destination address.","Many of the figures are described herein with reference to actions performed by certain software modules. In some embodiments, the described modules perform the described functions. However, in other embodiments within the scope of the invention, individual modules may perform some or all of the functions of several of the described modules. Likewise in other embodiments, multiple modules may perform functions described herein with respect to single modules.","1. Packet Filter",{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 9","b":["840","910","920","930","940","810","840","940","810","920","940"]},"The packet filter  receives packets from the network interface card driver  at the packet processor . The packet processor checks characteristics of the packets (e.g., the addresses, ports, and protocols of the packets) against the policies in the policy table  to determine whether the packets should be allowed or rejected. When a packet is allowed, the connection information about the packet is saved in the connection table . In some embodiments, when the packet processor does not find any policies for the virtual machine to (or from) which the packet is addressed, the packet processor sends data to the daemon through the daemon interface module  to inform the daemon that a new virtual machine is on the host node. In some embodiments, the packet filter does not have a separate daemon interface module . In some such embodiments, the daemon interacts directly with the policy table  and connection table  of the packet filter. In other such embodiments, the daemon manipulates the connection table and policy table through the packet processor.","In some embodiments, the daemon determines when a new virtual machine is on the node. In some embodiments, a new virtual machine on a node is also referred to as a \u201cpreviously undetected virtual machine\u201d. In some embodiments, a \u201cpreviously undetected\u201d virtual machine on a host node is a virtual machine that does not have policies on that host node. For example, a virtual machine that has previously been detected on another host node is a \u201cpreviously undetected virtual machine\u201d to the host node to which it is moved. Similarly, a virtual machine that once ran on a particular host node, but had been moved off that host node or otherwise identified as no longer running on that host node, would be a \u201cpreviously undetected virtual machine\u201d for that host node the next time a packet to or from that virtual machine was detected on that host node.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 10","b":["1000","1000","1010","1000","1020","1000","920","1000","1000","1025","1000"]},"On the other hand, when the process  determines (at ) that the packet is allowed according to the policy table, the process  allows (at ) the packet to pass. Next, the process  determines (at ) whether the packet represents a known connection. When the process  determines that the packet represents a known connection, the process  ends. On the other hand, when the process  determines that the packet represents a previously unknown connection, the process  adds (at ) the connection to the connection table. The process  then ends.","In the embodiments described with respect to , each packet that arrives at the packet filter is evaluated according to the policies of the firewall. However, in some embodiments, packets are allowed to pass through the firewall without being evaluated against the firewall policies if those packets represent connections that have previously been allowed under the firewall policies. That is, if the connection table indicates that a connection is allowed, then future packets from that connection are also allowed. Some embodiments also provide a middle ground, for example allowing packets from a previously allowed connection for some length of time before the packets from that connection need to be re-evaluated.","In some embodiments, packets representing previously allowed connections are allowed to pass until the virtual machine policies that allowed the connection are updated. In some embodiments, when a policy is updated, connections that were allowed by the previous policy are marked in the connection table as being old connections. In some embodiments that use previously allowed connections to bypass the policies, packets representing connections that are marked as being old are evaluated under the new policies. Some embodiments mark all connections related to a virtual machine as old when any of its policies are updated. In other embodiments, when policies for a virtual machine are updated, connections that relate to new or changed policies are marked old while connections not related to a new or changed policy are not marked as old.","In some embodiments, a packet that represents a previously allowed connection can be blocked by the policies. For instance when a policy has been updated, or when circumstances change a variable that the policy uses to determine whether a packet is allowed. When a packet from a previously allowed connection is blocked, the firewalls of some embodiments remove the connection data for that connection from the connection table.","2. Daemon",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 11","b":["810","810","810","1110","1120","1130","1140","1110","840"]},"When a host system moves a virtual machine to a new host node, the host system starts sending packets that are addressed to that virtual machine to the new host node. Similarly, the virtual machine starts sending out packets from its new location (the new host node). When the packet filter  on the new host node starts receiving such packets, the packet filter  does not yet have policies relating to the new virtual machine. Therefore the packet filter  notifies the virtual machine migration and update coordinator  of the daemon  that a new virtual machine is on the host node.","The daemon  then retrieves the policies and connection data (if any) from the previous node or from the firewall coordinator (described below). In some embodiments, the migration and update coordinator  contacts the firewall coordinator to determine whether the new virtual machine had been running on another host node. When the virtual machine had not been running on another host node, the firewall coordinator itself provides the policies pertaining to that virtual machine.","When the virtual machine had been running on another host node, the firewall coordinator identifies the host node on which the virtual machine had been running and sends that identification to the virtual machine migration and update coordinator . The virtual machine migration and update coordinator  then contacts the daemon on the host node on which the virtual machine had previously been running to retrieve the policies and connection data for the virtual machine from the other host node.","The virtual machine migration and update coordinator  then passes the retrieved policies to the policy editor , and the connection data to the connection table editor . The policy editor  updates the policy table  and the connection table editor  updates the connection table . Once the policy table  has been updated, the packet filter  has the information it needs to evaluate packets to and from the new virtual machine. In some embodiments, the policy editor  translates the policies from one computer protocol to another computer protocol or from one computer language to another computer language, before sending the translated policies to the policy table of the packet filter. That is, the policy editor  translates the policies from a form that the daemon and the firewall coordinator use, to a form that the packet filter uses. In some embodiments, the policy editor  stores a copy of the policies that it receives in a policy table . In some embodiments, the copy of the policies stored in the policy table  are not translated from the language and protocol that the daemon and the firewall coordinator use for the policies. Some embodiments provide two policy tables  and  with different languages and\/or protocols so that the packet filter can use protocols and\/or languages native to the packet filter and the daemons can send policies to other daemons in the languages and\/or protocols used by the daemons and the firewall coordinator.","When a policy for a virtual machine on the host node is updated, or when a virtual machine arrives on the host node or leaves the host node, the policy editor  sends policy information to the policy table  through the packet filter control module . In some embodiments, when a virtual machine leaves a host node, the policy editor removes the policies relating to that virtual machine from the policy table . Likewise, when a virtual machine arrives on or leaves the host node or when logs of the connections need to be sent to the firewall coordinator, the connection table editor  sends and retrieves connection data to and from the connection table  through the packet filter control module .","When a virtual machine has been moved to a new host node from a previous host node and the daemon of the new host node has retrieved the policies and connections for the virtual machine, the daemon acknowledges to the firewall coordinator that the policies and connections (if any) for that virtual machine have been received. The firewall coordinator then sends a command to the virtual machine migration and update coordinator  of the daemon of the previous node of the virtual machine. The command prompts the policy editor  and the connection table editor  to delete the policies and connections, respectively, pertaining to the moved virtual machine. In some embodiments, the command to delete the policies and connection table is sent to the daemon of the previous node by the daemon of the new node rather than by the firewall coordinator.","When a virtual machine has shut down, it does not send or receive packets. Accordingly, in some embodiments, when a virtual machine on a node has not sent or received a packet for some length of time, the daemon  of that node identifies that virtual machine as shut down. In some embodiments, the packet filter control module  determines that the virtual machine has not sent or received packets for that length of time and classifies the virtual machine as shut down. In some embodiments, the policy editor  and the connection table editor , respectively, cause the packet filter to delete policies and connections pertaining to a virtual machine that has been classified as shut down.","C. Firewall Coordinator","As previously indicated, the firewalls of the firewall system are controlled and coordinated by a firewall coordinator, the firewall coordinator.  illustrates a firewall coordinator  of some embodiments. As shown, the firewall coordinator  includes a policy receiving module  (also referred to as a \u201cpolicy manager\u201d), a policy database , a virtual machine tracker  (also referred to as a \u201cvirtual machine location coordinator\u201d), a virtual machine tracker database , a daemon coordination module  (also referred to as a \u201ccoordination manager\u201d), and a database of collected logs . The firewall coordinator  receives policies from various levels of users ,  and  at the policy receiving module . The firewall coordinator communicates with daemons on the host nodes through the daemon coordination module .","1. Updating Policies","In some embodiments, the policies pertaining to a virtual machine can be changed by authorized people. For example, when a policy, which blocks a certain type of packet, blocks packets that a user wants to allow, an authorized user can add or change a policy to allow the desired packets. In some embodiments, updates to policies are implemented by the firewall coordinator . In some embodiments, a policy receiving module  of the console receives policy changes for a virtual machine from a user - (e.g., receives an identification of the virtual machine and the policy for that machine). The policy receiving module  updates the policies for that virtual machine in policy database . In some embodiments, a policy update can include adding a new policy, deleting an existing policy, and\/or changing an existing policy.","In cases where the virtual machine is not running on any host node when a policy update is received, updating the policy database  is sufficient to ensure that the next time the virtual machine is activated, it will be protected using the updated policies. As described above, when a new virtual machine on a node was not previously running on another node, the daemon retrieves the policies for that virtual machine from the firewall coordinator.","However, in some embodiments, if the virtual machine is running when the policy is updated, the updated policies are sent to the firewall of the host node on which the virtual machine is running. Sending the updated policies both allows the firewall of the host node to implement the updated policies, and ensures that when the virtual machine moves, the daemon of the host node will be retrieving the updated policies, rather than the previous policies.","Accordingly, when a policy update for a virtual machine is received by the policy receiving module , it sets off a chain of exchanges of data. The policy receiving module  sends an identifier (e.g., a MAC address or other identifier) of the virtual machine for which the policies have been updated to the virtual machine tracker .","When the virtual machine tracker  receives the virtual machine identifier from the policy receiving module , the virtual machine tracker  checks the virtual machine tracker database  to determine whether and where (i.e., on what host node) the virtual machine is running. When the virtual machine is running on a host node, the virtual machine tracker  sends the virtual machine identifier and the location (host node) of the virtual machine to the daemon coordination module . The daemon coordination module  then retrieves the policies for that virtual machine from the policy database  and sends the updated policies to the daemon of the host node on which the virtual machine is running.","2. Coordinating Movement of Security Data","In addition to updating policies when a user changes policies, the firewall coordinator also coordinates the movement of firewall policies and connection tables from the firewalls of previous host nodes of the virtual machines to the firewall of the new host nodes of the virtual machines.","As previously described, when a new virtual machine appears on a host node, the daemon of that host node sends a query including an identifier of the new virtual machine to the firewall coordinator . The query seeks the source of the virtual machine (i.e., another host node or a new instantiation of the virtual machine). The daemon coordination module  receives such queries and passes them on to the virtual machine tracker . The virtual machine tracker  then checks the virtual machine tracker database  to determine whether the virtual machine is a new instantiation of the virtual machine or has been moved from another host node. When the virtual machine is a new instantiation, the virtual machine tracker  informs the daemon coordination module  and the daemon coordination module  retrieves the policies for that virtual machine from the policy database  and sends them to the daemon where the new virtual machine has been instantiated.","However, when the virtual machine has been moved from a previous host node, the virtual machine tracker  sends the identifier of the virtual machine and the location of that previous host node to the daemon coordination module . The daemon coordination module  sends the identifier and the location to the daemon of the new host node. Sending this information tells the daemon of the host node which daemon to contact in order to retrieve the policies and connection table entries relating to the virtual machine.","Once the daemon of the new host node has retrieved the security data from the daemon of the old host node, the daemon of the new host node sends an identifier of the virtual machine to the virtual machine tracker  through the daemon coordination module . The virtual machine tracker  then stores the virtual machine identifier and the host node location in the virtual machine tracker database . In some embodiments, daemons send periodic updates to the virtual machine tracker  that include a list of virtual machines running on the respective host nodes of the daemons.","Periodic updates allow the firewall coordinators of some embodiments keep track of the movements of the virtual machines. Similarly, the firewall coordinators of some embodiments maintain logs of connections to the virtual machines. In some such embodiments, when daemons send logs of their connections to the firewall coordinator , the daemon coordination module  stores the logs in collected log database .","3. Daemon Coordination Module","In some embodiments, the various types of data being passed through the daemon coordination module  are handled by various modules in the daemon coordination module .  illustrates the daemon coordination module  of some embodiments. The daemon coordination module  includes daemon communication control , new virtual machine reporter , virtual machine policy updater , virtual machine policy retriever , virtual machine log recorder , and virtual machine data received reporter .","Communications from and to daemons of various host nodes are controlled by the daemon communication control . The daemon communication control  receives identifiers of new virtual machines from daemons on host nodes and passes those identifiers to the virtual machine tracker  through the new virtual machine reporter . When a virtual machine was not previously running on another host node, the virtual machine policy updater  receives notification from the virtual machine tracker  that the virtual machine is a new instance of the virtual machine. The virtual machine policy updater  passes this information to the daemon communication control , which retrieves the policies of the virtual machine through the virtual machine policy retriever , which in turn retrieves the policies from the policy database . The daemon communication control  then sends the policies to the daemon of the host node on which the virtual machine resides.","When a virtual machine has been moved from one host node to another host node, the virtual machine policy updater  sends an identifier of the virtual machine and the location of the host node (from which the virtual machine has moved) to the daemon communication control . The daemon communication control sends this data to the daemon of the virtual machine's new host node so that the daemon can contact the daemon of the previous host node to retrieve the policies and connection tables. Once a daemon has received the security data for a virtual machine, the packet filter control module  sends an identifier of the virtual machine and an acknowledgment that the security data has been received to the firewall coordinator. The daemon communication control  passes that information to the virtual machine data received reporter , which passes the information to the virtual machine tracker .","The virtual machine policy updater  also receives notice (e.g., identifiers of virtual machines and the host nodes on which they are running) from the virtual machine tracker  when policies for a running virtual machine are updated. The virtual machine policy updater  informs the daemon communication control , which retrieves the policies of the virtual machine through the virtual machine policy retriever , which in turn retrieves the policies from the policy database  and sends them to the daemon of the host node on which the virtual machine, for which policies have been updated, resides. When the daemons send logs of their connection tables to the firewall coordinator , the daemon communication control  receives the communication data and passes them on to the virtual machine log recorder , which stores the logs in the collected logs database .","4. Virtual Machine Tracker","The firewall coordinator  of some embodiments keeps track of the locations where the virtual machines are running in order to let daemons know where virtual machines were previously running. Some embodiments use a virtual machine tracker  to keep track of the locations of the virtual machines.  illustrates the virtual machine tracker  of some embodiments. The virtual machine tracker  includes a daemon communication module , a virtual machine tracking module , and an update module  (also referred to as a policy update controller).","The daemon communication module  receives and sends data from and to the daemon coordination module . When the daemon communication module  receives a query with an identifier of a new virtual machine from the daemon coordination module , the daemon communication module  passes the query to the virtual machine tracking module .","The virtual machine tracking module  checks the virtual machine tracking database  to determine on what host node, if any, the virtual machine is running. When the virtual machine was running on another host node, the virtual machine tracking module  identifies the previous host node. The virtual machine tracking module sends this identification through the daemon communication module  to the virtual machine policy updater  of the daemon coordination module . When the virtual machine was not previously running, then the virtual machine tracking module  sends that information to the daemon coordination module .","When a policy of a firewall for a virtual machine is updated, the policy receiving module  sends an identifier of that virtual machine to the update module . The update module passes this information on to the virtual machine tracking module . When the virtual machine is not active at the time, then there is no firewall using the policies for that virtual machine, so the virtual machine tracker  does not need to send an order to update a firewall. In some embodiments, when the virtual machine is active, then the virtual machine tracking module  supplies data to the virtual machine policy updater  of the daemon coordination module  through the daemon communication module  about which host node the virtual machine is on and which virtual machine needs updating. In other embodiments, when the virtual machine is active, then the virtual machine tracking module  identifies the host node of the virtual machine to the update module , which in turn commands the daemon coordination module  to send a policy update to the firewall of the identified host node.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 13","b":["1300","1300","1310","1300","1320","1206","1300","1330","1208","1210","1300","1300","1340","1300"]},"D. Examples of Security Data Structures","As described above, virtual machines on a hosting system can be moved from one host node to another by the hosting system with the firewall coordinator and the virtual network firewalls moving the security data along with them. The security data of some embodiments include both policies that a firewall uses to determine whether or not a given packet is allowed and connection tables that store a list of the previously allowed connections. , B, and  illustrate the policies and connections that the virtual network firewalls and the firewall coordinator move in some embodiments.","1. Policy Data","Policies are evaluated by firewalls to determine whether a packet is allowed or blocked. In some embodiments, the policies for all virtual machines are stored in a policy database  of the firewall coordinator .  illustrate examples of policies stored in the policy database  of some embodiments. In , the policy database  includes policy sets , , and , one set for each of the virtual machines that the system hosts.  illustrates some examples of a set of policies , , , , and  for a virtual machine. In some embodiments, policies can be conceptually represented as conditional statements. That is, \u201cif A then B.\u201d More specifically, a policy includes a set of conditions for a firewall to recognize, and instructions to the firewall about what to do when those conditions are recognized. For example, a policy may specify \u201cif the packet is from IP address 123.45.6.7 then allow the packet\u201d. In some embodiments, policies such as policy  can depend on a destination port address and destination virtual machine. Similarly, in some embodiments, policies such as policy  can also depend on when the packet is received.","2. Connection Data","Some embodiments keep track of various data about the packets that have previously been allowed. Some embodiments store this data as connection tables.  illustrates the data structure of data in connection tables of some embodiments. Connection data includes both a set of information that uniquely identifies a connection, a memory location for storing the identity of the virtual machine on the host node (if any) that is the source of the packet, and a memory location for storing the identity of the virtual machine on the host node (if any) that is the destination of the packet.","The identifiers and the virtual machine identities are stored as a data tuple  including the IP of the source address , the IP of the destination address , the source port , the destination port  and the protocol of the connection . Those five pieces of data uniquely identify the connection. In some embodiments, the fields - comprise the key to a hash table storing the connection data.","The data tuple  also includes the source ID  (e.g., the virtual machine on the host node, if any, that is the source of the connection), and the destination ID  (e.g., the virtual machine on the host node, if any, that is the destination of the connection). In some embodiments, the values of the source ID  and destination ID  are index values for an index of MAC addresses of the virtual machines on the hosting system. In some embodiments, such an index is stored in the firewall coordinator. In some embodiments, the fields  and  are the values of a hash table, the keys of which are fields -. In some embodiments, the source ID field of a connection, in a connection table on a particular host node is blank (e.g., no entry, a null entry, etc.) when the source is not a virtual machine on that particular host node. Similarly, in such embodiments, the destination ID field is blank when the destination is not a virtual machine on that particular host node.","In some embodiments, the connection data stored in the tuples allow the packet filter to determine whether a packet with the same source and destination addresses, ports, and protocol has been received for or from a virtual machine before. In some embodiments, the firewalls allow packets that match connection data tuples in the connection table (e.g., packets of previously allowed connections) to pass. In other embodiments, the connection tables are not used to bypass the policies.","As described above, when a virtual machine is moved to a new node, the firewall of the new node retrieves a copy of the connection table data relating to that virtual machine from the firewall of the previous node. Once the connection data has been copied successfully, the firewall coordinator commands the old firewall to delete the connection data, completing the movement of the connection data tuples to the new host node.  illustrates the movement of data tuples from one host node to another in some embodiments. In this example, the connection table  of host node  originally includes four tuples (, , , and ) that describe connections for the two virtual machines VM and VM that are currently running on host node . When VM is moved from host node  to host node , the connections that include VM information (tuples  and ) are deleted from the connection table  of host node  and are added to the connection table  of host node .","E. Moving Security Data to a Host Node","As previously described, when a virtual machine is moved to a new host node, the firewall system moves the policies and connection data relating to that virtual machine to the new host node.  conceptually illustrate several processes of some embodiments for moving security data (e.g., policies and connection data) to a host node when a previously unknown virtual machine begins to run on that host node.  conceptually illustrates a process undertaken by the host node where the virtual machine starts running.  conceptually illustrates a process undertaken by a host node where the virtual machine was previously running.  conceptually illustrates a process performed by a firewall coordinator.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":"FIG. 17A","b":["1700","2","1700","1705","2","2","2"]},"In various embodiments, there are multiple circumstances in which a virtual machine would be identified as new to the host node. In some embodiments, a new virtual machine on the node could be detected (at ) by a host node without coming from another host node if the virtual machine is initially activated on the host node that detects it. In some embodiments, a virtual machine that had been moved from one node to another, but had not sent or received packets on a previous node would not be identified as coming from another node. The virtual network firewalls of some embodiments identify virtual machines on their nodes as shut down when the virtual machines have not sent or received a packet for some length of time. In such embodiments, a virtual machine that had not sent or received a packet would be reported to the firewall coordinator as having been shut down. In some such embodiments, the daemon would delete the policies and connection table data relating to such a virtual machine. Accordingly, if a virtual machine had not sent or received a packet for an extended period, the next time that virtual machine sent or received a packet, the virtual network firewall of the host node would identify the virtual machine as a new virtual machine on the node.","Next, the process  requests (at ) information about the new virtual machine from a firewall coordinator . In some embodiments, the daemon of host node  contacts the firewall coordinator  about the new virtual machine. The process  determines (at ) whether the virtual machine was previously running on another host node. In some embodiments, the daemon of host node  receives data from a virtual machine tracker  of the firewall coordinator  that informs the daemon whether the virtual machine is from another host node (and if so which host node).","When the virtual machine is not from another host node, the process  receives (at ) the policies relating to that virtual machine from the firewall coordinator . In some embodiments, the daemon communication control  of the daemon coordination module  of firewall coordinator  sends the policies to the daemon of the host node. When the virtual machine has been moved from another host node (which will be referred to here as host node ), the process  contacts (at ) the daemon of host node  to retrieve the policies and connection data for the virtual machine from host node . Whether the virtual machine was a new instantiation or was moved from host node , the process  sends (at ) a confirmation message to the firewall coordinator  to confirm that the virtual machine security data has been received. In some embodiments, the confirmation message includes a list of all virtual machines operating on the host node of that firewall at the time.",{"@attributes":{"id":"p-0156","num":"0155"},"figref":"FIG. 17B","b":["1730","1","2","1730","1735","2","1","2","1720","1700","1730","1740","2","1135","1120","810","1","810","2","1140","810","1"]},"When the process  receives (at ) a command from the firewall coordinator to delete the security data (e.g., policies and connection table data) relating to the moved virtual machine from the firewall of host node , the process  deletes (at ) the copies of the policies and connection table data from the firewall of host node . In some embodiments, the firewall coordinator sends such a command after the daemon of host node  notifies the firewall coordinator that the policies and connection table data have been received by the firewall of host node .","As long as a command to delete the security data is not received (at ), the process  keeps (at ) the copy of the security data on the firewall of host node  until the process  does receive such a command. In some embodiments, the loop shown in  is not a loop in the programming, but an indication that the daemon of host node  does not delete its copy of the policies unless and until the firewall coordinator indicates that it should. Once the firewall coordinator indicates that the daemon should delete the policies and connections, the process  deletes (at ) the security data pertaining to the moved virtual machine.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 17C","b":["1755","1200","1755","1760","1212","1200","2"]},"The process  determines (at ) whether the virtual machine that the daemon identified was previously running on another host node of the hosting system. In some embodiments, the virtual machine tracker  of the firewall coordinator  checks the virtual machine tracker database  to determine whether the virtual machine had been running on another host node.","When the process determines (at ) that the virtual machine was not already running on another host node, the process  retrieves (at ) the policies for the virtual machine from the policy database and sends them to the daemon of host node  and receives notice that the policies have been received. In some embodiments, the daemon coordination module  of the firewall coordinator  gets the policies for that virtual machine from the policy database  and sends the policies to the daemon of host node . When the virtual machine (at ) was already running on another host node, the process  informs (at ) the daemon of host node  on which host node the virtual machine was previously running. In some embodiments, the daemon coordination module  of the firewall coordinator  tells the daemon of host node  on which host node the virtual machine had been running.","The process  is informed (at ) that the daemon of host node  has retrieved the security data from the other host node. Upon receiving the notice, the process  sends (also at ) a command to the previous host node of the virtual machine to delete the security data pertaining to that virtual machine. The process  updates (at ) the records of the locations of the virtual machines to indicate that the virtual machine is now on host node . In some embodiments, the virtual machine tracker  of the firewall coordinator  updates the virtual machine tracker database  to indicate the presence of the virtual machine on host node .","The processes described above result in the movement of policies and security data from the old host node of a virtual machine to the new host node of a virtual machine. The effects of the processes described above are conceptually illustrated in .  illustrates the movement of a virtual machine from one host node to another. In stage , host node  includes virtual machine , firewall policies  and connection table data , in a virtual network firewall (not shown) for virtual machine . Host node  also includes virtual machine , firewall policies  and connection table data , in the same virtual network firewall as the firewall policies  and connection table data  for virtual machine . In stage , host node  does not contain any firewall policies, connection table data, or virtual machines.","In stage , the hosting system has moved virtual machine  to host node . As described with respect to , the firewall of host node  (not shown) would begin to detect packets to or from virtual machine . The daemon of node  (not shown) would find out that virtual machine  came from node  and would ask for and receive a copy of the firewall policies  and connection table data  for virtual machine  from the daemon (not shown) of host node . This is shown in stage . The daemon of host node  has a copy of the policies  and connection table data  for virtual machine  from host node .","As described above with respect to , the daemon of host node  would inform the firewall coordinator  that the daemon of host node  had received the firewall policies  and connection table data . The firewall coordinator  would then send a command to the daemon of host node  to delete the firewall policies  and connection table data . The results of such a command are shown in stage . The daemon of host node  has received the delete command from the firewall coordinator  and has deleted its copy of the security data of host node .","While  illustrates the sequence of events for moving security data in some embodiments, it shows the connection tables and policies only as monolithic blocks. In contrast,  illustrates the movement of individual policies and connection table tuples from one host node to another. Though for reasons of space,  illustrates the starting and ending stages of the move, without the intermediate stages.","In stage , host node  includes virtual machines , , and . Virtual machine  is associated with firewall policies  and connection table data tuples . Virtual machine  is associated with firewall policies  and connection table data tuples . Host node  includes virtual machine , which is associated with firewall policies  and connection table data tuples . Arrow  indicates that virtual machine  is being moved to host node . Arrow  indicates that the policies  relating to virtual machine  are being moved to the policy table for host node . Arrow  indicates that data tuples  that refer to virtual machine  are being moved to the connection table for host node .","In stage , the virtual machine  has been moved to host node , the policies  have been moved the policy table for host node , and the data tuples  have been moved to the connection table for host node .","F. Identification of a New Virtual Machine","As described in relation to , the firewall of some embodiments determines when a new virtual machine has been added to the host node that the firewall protects.  conceptually illustrates a process  of some embodiments for determining when a new firewall has been added to a host node.","The process  receives (at ) a packet at a firewall. The process  determines (at ) whether the packet has come into the host node from outside the host node. In some embodiments, the firewall  determines that a packet has come from outside when it receives the packet from virtual switch  that leads outside of the host node.","When the packet is from outside, the process  recognizes (at ) that the destination MAC address is to a virtual machine on the node. That is, the process assumes that the destination MAC address is to a virtual machine on the node. This assumption is based on the fact that the packet has been sent to that host node, which implies that the virtual machine to which that packet is addressed is on that host node. The process  determines (at ) whether it has policies for a virtual machine with that destination MAC address. When the packet is for a virtual machine with an unknown destination MAC address, the process  gets (at ) the policies for that destination MAC address (e.g., by the processes described above for retrieving policies).","As mentioned in above, the fact that a packet has been sent to a host node implies that the virtual machine to which the packet has been sent is on the host node. However, in some embodiments, rather than assuming that the virtual machine is on the host node based on the packet, the firewall  verifies whether the virtual machine to which the packet is addressed packet is actually on the host node. In some embodiments, the firewall  verifies the presence of the virtual machine on the host node by sending a probe packet with that destination address into the node (e.g., to virtual switch ). If the destination MAC address is to a virtual machine on the node then the virtual machine will reply to the probe packet. Such a reply indicates to the firewall  that the destination address is to a virtual machine on the node. Once the firewall has the policies, whether it just retrieved the policies or not, the process  applies the policies (at ).","When the process  determines (at ) that a packet comes to a packet filter from inside the host node. The fact that the packet is from inside the host node implies that the packet is from a virtual machine on that host node. The process  recognizes (at ) that the source of the packet is a virtual machine on the node. In some embodiments, the firewall  determines that a packet has come from inside when it receives a packet, or a copy of a packet, from virtual switch  that leads into the host node.","The process  determines (at ) whether it has policies for a virtual machine with that source MAC address. When the packet is for a virtual machine with an unknown source MAC address, the process  gets (at ) the policies for that destination MAC address (e.g., by the processes described above for retrieving policies).","Whether the packet is from a known MAC address or not, the process  determines (at ) whether the packet was being sent outside. In some embodiments, when packets are sent from one virtual machine to another virtual machine on the same node, the virtual switch  sends a copy of the packet to the firewall  rather than passing the packet through the firewall (as described below). When the packets are being sent out of the node, then the process  recognizes (at ) that the destination MAC is not a virtual machine on the host node. The process  then applies (at ) the policies (for the source virtual machine).","When the process  determines (at ) that the packets are not going out of the node, the process  recognizes (at ) that the destination MAC address is also to a virtual machine on the node. The process  determines (at ) whether it has policies for a virtual machine with that destination MAC address. When the packet is for a virtual machine with an unknown destination MAC address, the process  gets (at ) the policies for that destination MAC address (e.g., by the processes described above for retrieving policies). Once the firewall has the policies, whether it just retrieved the policies or not, the process  applies (at ) the policies for both the source and destination virtual machines.","III. Combined Connection Tables","A. Intra-Node Firewalls","The virtual network firewall of some embodiments acts as an intra-node firewall. The term \u201cintra-node firewall\u201d refers to the fact that the virtual network firewall of such embodiments is a firewall that checks whether a packet is allowed to be sent by a virtual machine on a node and whether it is allowed to be received by a virtual machine on the same node. Some firewalls described below are referred to as \u201cintra-node firewalls\u201d to indicate that they check packets sent to and from virtual machines on the same node, however this does not indicate that the firewalls only check packets sent to and from virtual machines on the same node.","One of ordinary skill in the art will realize that the question of whether computer A is allowed to send a packet to computer B is a separate question from the question of whether computer B is allowed to receive a packet from computer B. One question is \u201ccan A send to B\u201d the other is \u201ccan B receive from A\u201d. For a packet to be sent from A and received by B requires that both of these questions be answered \u201cyes\u201d. If computer A is not allowed to send the packet to computer B then the packet will not reach computer B (i.e., A cannot send to B). If computer A is allowed to send to computer B but computer B is not allowed to receive from computer A (i.e., A can send, but B can't receive), then the packet will not reach computer B.","When two virtual machines on the same host node are the source and destination addresses of a packet, the intra-node firewall of some embodiments determines the answer to both of these questions. That is, the intra-node firewall checks whether the policies for the source virtual machine allow the source virtual machine to send the packet to the destination machine and whether the policies for the destination virtual machine allow the destination virtual machine to receive the packet from the source machine.","As described above with respect to , the firewalls of some embodiments store connection data that includes an identifier of whether the source or the destination of a packet is a virtual machine on the host node of the firewall. In some embodiments, any packet received by the intra-node firewall will either be: 1) from a virtual machine on its host node to an address outside the host node, 2) to a virtual machine on its host node from an address outside the host node, or 3) from one virtual machine on the host node to another virtual machine on the host node.","In the third case, where a packet both comes from a virtual machine on a node and is also addressed to a virtual machine on the same node, a connection table that included all the connections for all the virtual machines on that host node would require two entries with identical address data, one entry indicating that the source virtual machine was allowed to send the packet and one entry indicating that the destination virtual machine was allowed to receive the packet. Having two entries with identical address information would cause errors in a system that relied on the connection table having no redundant entries. Accordingly, some embodiments use combined connection tables that indicate that the firewall of the host node both allowed the source virtual machine to send the packet and allowed the destination virtual machine to receive the packet.",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIG. 21","b":["2100","2100","2100","2100","2105","2100","2110","2100","2115","2120"]},"When the source virtual machine is not allowed to send the packet, the process  discards the packet (at ). The process  then ends. When the source virtual machine is allowed to send a packet with those characteristics, the process  adds (at ) that connection to the connection table with the source virtual machine indicated in the source ID field of the connection data tuple. In some embodiments, the connection is only added to the connection table if connection representing a packet with those characteristics has not previously been added to the connection table. In other embodiments, the previous connection in the table is updated when a new packet representing that connection is allowed.","The process  then determines (at ) whether the destination of the packet is on the host node of the intra-node firewall. When the destination of the packet is not a virtual machine on the host node, the process  allows (at ) the packet to pass the firewall to continue toward its destination (outside the host node). At this point, the firewall has already determined that the source virtual machine is allowed to send the packet to the destination. Because the destination of the packet is not a virtual machine on the host node, the firewall of the host node does not determine whether the destination computer or virtual machine is allowed to receive the packet. Whether or not the destination computer or virtual machine is allowed to receive the packet is determined by the firewall (if any) protecting that computer or virtual machine. The process  then ends.","When the destination is a virtual machine on the process  host node, the process  applies (at ) the policies relating to the destination virtual machine to determine (at ) whether the virtual machine is allowed to receive a packet with those characteristics. When not, the packet is discarded (at ). The process  the ends. On the other hand, when the virtual machine is allowed to receive a packet with those characteristics, the connection that the packet represents is added (at ) to the connection table. In some embodiments, the connection is only added to the connection table if connection representing a packet with those characteristics has not previously been added to the connection table. In other embodiments, the previous connection in the table is updated when a new packet representing that connection is allowed.","In some embodiments, when the connection that the packet represents was also from a virtual machine on the same host node, there will already be a connection table entry for that connection (added at ). When there is already a connection table entry for that connection, the process  adds (at ) the ID of the destination virtual machine to the existing connection table entry in the destination ID field. In some embodiments, the operations at  and  are combined so that the connection is not added to the connection table until the full determination of whether to allow the packet to pass the firewall is complete. In such embodiments, once the determination is made, the source (if any) and destination (if any) IDs are recorded in the connection table entry at the same time.","The process  then allows (at ) the packet to proceed and the process  ends. In some embodiments, the determinations at  and  represent determinations of which virtual machines (if any) are the source and\/or destination of the packet. The illustration has been simplified for clarity to show determinations  and  as merely \u201cyes\/no\u201d determinations.","Some advantages in some embodiments of having an intra-node firewall for a host node and the multiple virtual machines of the host node are illustrated in .  illustrates the intra-node firewalls of some embodiments. Packets , , and  each have to pass through only one firewall, firewall , to reach virtual machines  and . In contrast, in the prior art system illustrated in , there is no intra-node firewall. Therefore, in order to be protected from other virtual machines on the same host node, each virtual machine has its own internal firewall  and  running on that virtual machine. The hosting system has its own firewall  to protect it from security risks from the virtual machines on that host node, and to protect the virtual machines on the host node from unwanted external packets. In order for a packet such as , , or  to reach a virtual machine it passes through two separate firewalls. For example, packet  passes through both the internal firewalls of the virtual machines, firewall  and firewall . Packet  passes through the host node's firewall  and internal firewall  of the virtual machine.","B. Combined Connection Tables","In some embodiments, connections of packets that have been allowed to leave the virtual machines on a host node and connections of packets that have been allowed to enter the virtual machines on that host node are both stored in the same connection table. As described previously, when the source of an allowed packet is outside the host node and the destination is on the host node, the connection table has an entry to indicate that a virtual machine on the host node was allowed to receive the packet. The destination ID of that entry is the virtual machine that received the packet, the source ID would be blank. Although, if the source is on another host node, the firewall of that other host node may have an entry identifying the same connection, with the source ID indicating a virtual machine on that other host node and a blank destination ID. Therefore, when only one virtual machine is on a particular host node, a single connection table entry with that virtual machine's ID accurately reflects that the firewall allowed that packet to pass the firewall.","In some cases both the source and destination of the packet are on the same host node. In such cases, rather than have a connection table that includes redundant entries for the same connection (one with the source ID blank and one with the destination ID blank), or separate connection tables for each virtual machine, some embodiments provide combined entries for both the source and destination of the packet. In some embodiments, having a single connection table on each node improves performance and resource utilization. For example, in embodiments that use fields - as keys of a hash table, redundant entries are not possible. Accordingly, merging the connection table entries with identical values - allows one entry in the table to represent both previous tuples.","C. Splitting Combined Connection Tables","When a virtual machine leaves a host node, a combined tuple, which represents a connection between two virtual machines on the same host node, is no longer accurate. As one of the virtual machines identified in that connection tuple is no longer on that host node, the tuple will be automatically edited to reflect the change. Similarly, when two virtual machines on different host nodes send packets to each other, the connection table on each host node records a separate entry for the connection. When one of those virtual machines is moved to the same host node as the other, the entries become redundant, and a combined tuple is a more accurate reflection of the connection than two redundant tuples (one in each direction). Thus, the movement of virtual machines in such embodiments leads to a requirement for new methods and systems to split and merge connection tables when a virtual machine moves.",{"@attributes":{"id":"p-0196","num":"0195"},"figref":["FIG. 24","FIG. 24"],"b":["2400","2410","2420","2400","1","1","1","2","2400","2402","2404","2408","2412","2414","2402","2402","2","2402","2","2402","2404","2406","2408"]},"In contrast, the connection tuples  and  each represent a connection from a virtual machine on the host node of the connection table and to a virtual machine on the same host node. As described in relation to , in some embodiments such a tuple is the result of an intra-node firewall determining that the firewall policies for the source virtual machine allow the source virtual machine to send the packet and that the firewall policies for the destination virtual machine allow the destination virtual machine to receive the packet.","Like connection table  in , connection table  is automatically edited when a virtual machine listed in the connection table is moved to another host node. Connection table  is automatically edited to have the entries shown in connection table . Connection  is the connection table of host node  after the hosting system has moved virtual machine  to host node . The tuples  and  that identify connections from or to VM are in connection table . The tuples  has been automatically edited to remove virtual machine  from the source ID field, becoming tuple . The removal of virtual machine  from the source ID removes the indication that the firewall policies of that host node allowed virtual machine  to send the packet identified by the connection table entry. The removal of that indicator accurately reflects that the firewall policies relating to virtual machine  have been removed from the firewall of host node .","However, even though the firewall policies of host node  no longer determine whether virtual machine  should be allowed to send a packet to virtual machine , the firewall policies of host node  still determine whether virtual machine  should be allowed to receive a packet sent from virtual machine . Therefore, the full description of the connection (source IP address, destination IP address, source port, destination port, and protocol) is still relevant to virtual machine . Accordingly, splitting the connection table does not remove the IP address of virtual machine  from the source IP address field of tuple .","Similarly, a copy of tuple  has been sent to the connection table  of host node  as tuple . The tuple  includes the same source IP address, destination IP address, source port, destination port, and protocol as tuples  and , but in tuple , the destination ID (i.e., VM) has been removed. As the firewall policies relating to virtual machine  have been moved to host node , the source ID field of tuple  accurately reflects that the firewall policies that have been moved to host node  allowed the connection from VM, as indicated in tuple .","Similarly, in some embodiments, packets sent between a virtual machine on one node and a virtual machine on another node would result in connection tables on those nodes with entries similar to tuples  and . That is, tuples with the same source IP address, destination IP address, source port, destination port, and protocol, but with different entries in the source and destination ID fields. The connection table of the host node of the source virtual machine would indicate that the firewall policies of that host node had allowed the source virtual machine to send the packet, while the connection table of the host node of the destination virtual machine would indicate that the firewall policies of that host node had allowed the destination virtual machine to send the packet. Since the connection tables on each host node are separate from each other, the separate entries would not be redundant entries in the same connection table.","However, if the virtual machines were subsequently moved to the same node, simple combination of the connection data for the moved virtual machine and the connection table of the new host node would contain redundant entries. Therefore, when two virtual machines on separate nodes that have been in contact are moved to the same node, some embodiments edit the connection table entries for the merged connection table so that a combined tuple such as , with entries for both source and destination IDs is made for the merged connection table. In some embodiments, splitting and merging connection tables results in connection tables with the same data in them whether the virtual machines had always been on the host nodes of the connection tables or had been moved to the host nodes later. 1",{"@attributes":{"id":"p-0203","num":"0202"},"figref":"FIG. 25A","b":["2500","2500","2502","2","1","1","2"]},"Next, the process  copies (at ) all the entries of the connection table of node  that relate to virtual machine  (e.g., that have virtual machine  as the source or destination ID). In some embodiments, the daemon of host node  copies the entries from the connection table of host node  that relate to virtual machine . As illustrated in , there may be tuples that have virtual machine  as the source or destination ID, that also have other virtual machines in the other ID field.","Accordingly, the process  deletes the source and destination IDs of other virtual machines from the copies of the data tuple entries relating to virtual machine . In some embodiments, the daemon of host node  deletes the extraneous source and destination IDs. The process  sends (at ) the connection table message to the daemon of host node . In some embodiments, the daemon of host node  sends the edited connection table data to the daemon of host node .","The process  receives (at ) a command from a firewall coordinator  to delete the connection table data for virtual machine  from the connection table of host node . In some embodiments, the firewall coordinator  sends the command after it receives notice from the daemon of host node  that the connection table data and the firewall policies relating to virtual machine  have been received.","The process  then deletes (at ) virtual machine  from all source and destination ID fields of the connection table and deletes any tuples with no other source or destination IDs (i.e. tuples that don't refer to any other virtual machine on host node ). In some embodiments, the daemon of host node  deletes the source and destination ID fields and tuples of virtual machine .","D. Merging Combined Connection Tables","As described above, in some embodiments, splitting up two virtual machines that have been in contact results in editing the combined tuples of each so that each connection table has the data relevant to the remaining virtual machines. Similarly, in some embodiments, two virtual machines of different host nodes can be in contact. When the virtual machines are moved to the same host node, a combined connection table would have redundant entries. To prevent this, some embodiments provide a process for merging connection table entries.",{"@attributes":{"id":"p-0210","num":"0209"},"figref":"FIG. 25B","b":["2520","2520","2522","1","2","2520","2524","1","1"]},"Next, the process  determines whether the address data of the new tuple is the same as the address data of a connection tuple already in the connection table. In some embodiments, having the same address data means having the same source IP address, destination IP address, source port, destination port, and protocol. In some embodiments, the new tuple has the same address as an existing tuple in the connection table of the host node if the virtual machines to which the tuples refer have previously had one or more packets sent from one virtual machine to the other.","When the new tuple does not have the same address data as an existing tuple, the process  moves (at ) the new tuple to the connection table of the host node. When the new data tuple does have the same address data as a tuple in the connection table of host node , the process  edits (at ) the tuple of the connection table of host node  to add the virtual machine referred to in the source or destination ID field of the new tuple to the source or destination ID of the tuple in the connection table. The process  then deletes the new tuple.","For example, referring to , if VM were moved to host node , the connection data for VM would also be moved to host node . In that case, tuple  would be a tuple in the connection table of host node  and tuple  would be a tuple in the connection table data sent to host node  from host node . Tuples  and  have the same IP addresses and port addresses, so the source ID of tuple  (e.g., the MAC address of VM, an index value or hash value of that MAC address, etc.) would be added to the source ID field of tuple  to produce tuple . In some embodiments, tuple  would be created even if the virtual machines had not previously been in contact while they were on the same host node. That is, if VM and VM had been in contact while on different host nodes, then moved to the same host node as each other, the result would be the generation of tuple .","Next, the process  determines (at ) whether there are any other new tuples. When there are more new tuples, the process  evaluates (at ) the next tuple. When there are no more new tuples (i.e. all new tuples have either been moved to the connection table, or deleted after their source or destination ID was added to an existing tuple in the connection table) the process  informs the firewall coordinator  that the connection data for the virtual machine referenced in the tuples has been received.","IV. Reversible Policies","Communication between computers, including virtual machines, is often two-way. One machine sends a packet, and the other machine replies. In some cases, a user may want to have different policies for replies than for original packets. For example, in prior art firewalls, if a firewall is set to block all external packets from reaching a virtual machine, then replies to packets sent from that machine would also be blocked. In some embodiments of the present invention, different sets of policies apply to packets that come from sources that were the destinations of previous packets. The question of whether a computer can receive (or send) a reply is distinct from the earlier questions of whether one computer can send and another computer can receive. Colloquially, the questions here are \u201cif A was already allowed to listen to B, can A talk to B?\u201d, or \u201cif A was already allowed to talk to B, can A listen to B?\u201d","For example, in some embodiments, when computer A sends an original packet from IP address 122.123.1.5 to virtual machine B and virtual machine B has a policy to block all packets that come in from IP addresses starting with \u201c122\u201d, the packet will be blocked under policies for an original packet. In this context, \u201coriginal\u201d means that there is no record in the connection table of the firewall protecting computer B that computer B sent an allowed packet to computer A. In some embodiments, because the packet is blocked, it will not be recorded in the connection table.","When virtual machine B sends an original packet to computer A, the connection table of the host node of virtual machine B will keep a record that the sent packet was allowed to be sent from virtual machine B to computer A. After an allowed packet from virtual machine B to computer A, when a packet comes in from computer A with the reverse address information from the packet sent from virtual machine B, the presence in the connection table of the record of the original connection (from virtual machine B to computer A) triggers the firewall of some embodiments to apply a separate set of policies from the policies for incoming packets that do not have the reverse address of an allowed packet. The separate set of policies may simply say \u201callow all packets\u201d. In which case, the reply packets from computer A will be allowed under the set of policies for reply packets.","As a concrete example, a virtual machine on a host node might have a general policy to reject incoming packets, but allow web browsing by using a reverse policy that allows packets with the HTML protocol that come from computers that the virtual machine has contacted (e.g., to request a web page). Another example would be a virtual machine that is only allowed to send outgoing packets in response to an outside query in order to prevent someone who gains unauthorized access to the virtual machine (e.g. by infecting it with a worm) from exporting data. Policies for original packets for such a virtual machine might be to block all outgoing packets, while the reverse policies might be to allow outgoing packets that are a reply to incoming packets.","One of ordinary skill in the art will realize that while the reversed address packets may be referred to as \u201creply\u201d packets, the separate set of policies applies whether the reversed packets are actually replies to the initial packets, or are simply packets sent later that are not in direct response to the original connection. In order to reduce confusion, rather than referring to original packets and reverse packets, the description below sometimes refers to initial connections and reverse connections.",{"@attributes":{"id":"p-0220","num":"0219"},"figref":"FIG. 26","b":["2600","2600","2610","2600","2620","2600","2640","2600","2645"]},"When the process determines (at ) that the connection is in the connection table, the process  determines (at ) whether the connection in the table is in the same direction as the packet. When the connection is in the same direction as the packet, the process  evaluates (at ) the connection using policies for original connections. The process then ends.","When the packet is in the reverse direction from the connection in the table, then the process  evaluates (at ) the connection according to a set of policies for reply packets. The process then ends. The illustrated process  does not save connections of reply packets, however in some embodiments, when a packet is allowed under the policies for reply packets, the connection for that packet is saved in the connection table. In some embodiments, the connection is saved in the connection table with an indicator that it is a connection of a reply packet. In some embodiments, a connection for an allowed reply packet is saved in a separate connection table for reverse policies. In some embodiments, a connection for an allowed reply packet is stored as a different lookup in the normal connection table.",{"@attributes":{"id":"p-0223","num":"0222"},"figref":"FIG. 27","b":["2710","2","2600","2710","2600","2720"]},"In , the destination of tuple  and the source of tuple  are the same (as indicated by the IP addresses and port addresses of the tuples). However, the destination of tuple  and source of tuple  is not a virtual machine on the same host node as virtual machine , therefore the destination ID of tuple  and the source ID of tuple  are blank.",{"@attributes":{"id":"p-0225","num":"0224"},"figref":"FIG. 28","b":["2800","2800","2810","2811","2812","2814","2820"]},"In some embodiments, packets arrive at the initial packet evaluator  that determines from the connection table  whether the packet is an original packet or a reply packet. When the packet is an original packet, then the initial packet evaluator  sends the packet to a forward packet evaluator . When the packet is a reply packet, then the initial packet evaluator  sends the packet to a reverse packet evaluator . The forward packet evaluator  applies the policies from policy table  to determine whether to allow the packet or reject the packet. When the policies indicate that the packet is allowed, then the forward packet evaluator  sends the packet on to the virtual switch and adds the connection in the connection table . The reverse packet evaluator  applies the reply policies from policy table  to determine whether to allow the packet or reject the packet. In some embodiments, the reverse packet evaluator  stores a list of allowed reverse connections in the connection table, while in other embodiments, the allowed reverse connections are not stored.","In some embodiments, the packet filter does not have separate modules for evaluating forward and reverse policies, but instead use a single packet processor module for evaluating all policies. In some such embodiments, the policies for reply packets include conditions that determine whether a packet is a reverse packet as part of a conditional statement for allowing a packet. The following pseudo-code provides an example of what a policy for reply packets might state:\n\n",{"@attributes":{"id":"p-0228","num":"0228"},"figref":"FIG. 29","b":["2900","2900","2800","2900","2910","2920","2900","2930","2940","2900","2920","2910","2900","2910","2920","2900"]},"V. Hierarchical Firewalls","Policy Layers","In some circumstances, multiple people all have authority over a single virtual machine. In the prior art, multiple firewalls could be set up with the output of one firewall feeding to the input of the next firewall. Each individual firewall could block a packet, or allow the packet to pass through that individual firewall. Such an arrangement of firewalls (e.g., multiple hardware firewalls) allowed multiple people to have veto authority over whether a packet was allowed to pass through the group of firewalls. When any one of those prior art firewalls said to block a packet, the packet would be blocked. Only when all of the firewalls allowed a packet would it pass through the group of firewalls.","The prior art group of firewalls grants equal power to each person who controls one of the firewalls. However, in some cases, not all the people with authority over a virtual machine have the same level of authority. For example, a virtual machine for employee use may be used by an employee who is allowed to run various applications on the virtual machine. The employee may have sufficient authority within his company to be allowed to block connections from coming in, but lack the authority to block connections from the technicians at the company that need access to the virtual machine.","Similarly, the technicians from the employee's company may have sufficient authority within the company to access any virtual machine owned by that company, whether the employees who user of those virtual machines want them to have access or not. The virtual machines of the first company may be on a hosting system run by a second company, so all the virtual machines of the first company are merely a subset of the virtual machines on the hosting system. The technicians of the first company are not authorized to access virtual machines owned by other companies.","The system administrators of the hosting system want to protect the hosting system from unauthorized access by the virtual machines running on that same system. The system administrators may also need access to the virtual machines on the system that are owned by their customers in order to keep the system running smoothly. Accordingly, the firewall policies of some embodiments allow multiple layers of firewalls, with each layer having different amounts of authority, to reflect the multiple layers of authority that various people or companies may have over a single virtual machine.","Some embodiments provide firewall policies with hierarchical layers. The policies of someone with higher authority override the policies of anyone with lower authority if their respective policies conflict. For example, some embodiments allow a system administrator of the hosting site to set policies for a virtual machine that can allow a connection, block a connection, or delegate the decision of whether to allow or block the connection to the next highest authority over the firewall of that virtual machine.","Similarly, the next highest authority over the firewall can set policies that allow, deny or delegate the decision of whether to allow access to another layer of the hierarchy and so on until the lowest layer, which can allow or deny a connection, but has no further policy layers to which it can delegate the decision. In some embodiments, all the policy layers for a virtual machine are implemented by a packet processor of the host node on which the virtual machine is running.",{"@attributes":{"id":"p-0236","num":"0236"},"figref":"FIG. 30","b":["3000","3000","3000","3000"]},"As shown, the process  receives (at ) a packet. Next, the process  applies (at ) the policies of the top layer of the hierarchy to determine whether to reject (at ) the packet, accept (at ) the packet, or delegate the decision to the next layer. When the policies of the top layer call for rejecting (at ) the packet, the packet is dropped (at ). When the policies of the top layer call for accepting (at ) the packet, the packet is allowed (at ). In either case, the process  for allowing or blocking then ends. However, as described in relation to , the process  of some embodiments stores the connection data for allowed connections in a connection table.","When the packet is neither rejected (at ) nor allowed (at ) then the process  applies (at ) the policies of the next layer of the firewall. Again, the process  determines whether to reject (at ) the packet. When the packet has to be rejected, the process  proceeds to  which was described above. Otherwise, the process  determines (at ) whether to accept the packet. When the packet is accepted, the process  proceeds to  which was described above. Otherwise, the process  proceeds to  to delegate the decision to the next firewall layer. The process  continues until the packet is either: 1) rejected, in which case the process  drops (at ) the packet; or 2) accepted, in which case the process  allows (at ) the packet to pass. The lowest layer of policies has no lower layer to which it can delegate the decision. Therefore, if no higher layer decides, the lowest layer determines whether to accepted or rejected the packet, but does not delegate.","In some embodiments, there may be users of a virtual machine who do not have the authority to set any firewall policies. For example, a virtual machine that contains a web site for a professor in a department of a university may have firewall policies set by (in order of authority) a system administrator, a department administrator, and the professor. Such a web site can be accessible to students, or other people with no authority to set any firewall policies for the virtual machine on which the web site is running.",{"@attributes":{"id":"p-0240","num":"0240"},"figref":"FIG. 31","b":["3100","3105","3110","3110","3112","3114","3105","3112","3100","3114","3112","3114","3110"]},"When the policy of the highest layer delegates the decision to the next layer, then the policies represented by wall  are checked by the packet processor . Again, the policies can deny the packet, allow the packet (represented by gate ), or delegate the decision (represented by gate ). When the policies of both higher levels (walls  and ) delegate the decision (gates  and ), then the policies represented by wall  (with gate ) determine whether to allow or block the packet.",{"@attributes":{"id":"p-0242","num":"0242"},"figref":"FIG. 32","b":["3200","3205","3210","3220","3230","3240","3200","3210","3200","3250","3260","3205","3270","3210"]},"The policies of the highest layer  are illustrated in chart  as policies -. Policies  and  result in an immediate decision to allow a packet to pass the firewall or block the packet. Policies  and  delegate the decision of whether to allow those packets to the next layer of policies , as illustrated in chart  as policies -. For easy identification, the charts  and  are illustrated in  as separate from each other. However in some embodiments, the policies shown in the charts are part of the same policy table. The charts  and  show that the system administrator has the highest authority over policy while the virtual machine administrator has the lowest. In different embodiments, different entities represent the highest and lowest levels of authority over the policies. For example, in some embodiments there may be default policies with higher authority than any user of the firewall system or with lower authority than any user of the firewall system.","Policies  and  are moot because the decision of whether to pass any packets that would be allowed or blocked based on policies  and  will be made under policies  and  rather than being delegated to policy layer .","Whether policy layer  would allow or block a packet (and even whether policy layer  has a policy about the packet) does not determine whether the packet will be allowed or blocked unless the decision is delegated to policy layer  by a policy of policy layer . Policies  and  determine whether to allow or block packets because the decision of whether to allow or block the packets that they refer to is delegated to their policy layer  by policies  and .","One of ordinary skill in the art will understand that in some embodiments in which all layers of the firewall are implemented by a packet processor, a packet would not get part way to the destination, as the conceptual illustration of  suggests. In such embodiments, the packet would be evaluated in view of the highest layer of policies first and because it would be rejected by the packet processor at the higher policy level, the packet processor would never have to determine whether the lower policy level of firewall  would allow or reject the packet .","Packet  is allowed by the highest layer . Therefore the policies of the lowest layer  are ignored. Packet  is delegated by the highest layer , and blocked by the lowest layer ; therefore the packet processor blocks the packet. Packet  is delegated by the highest layer , and allowed by the lowest layer , therefore the packet processor allows the packet to pass.","VI. Computer System","Computer programs for implementing some embodiments are executed on particular machines, such as computer systems.  illustrates a computer system with which some embodiments of the invention are implemented, such a computer system includes various types of computer readable media and interfaces for various other types of computer readable media. Computer system  includes a bus , a processor , a graphics processing unit (GPU) , a system memory , a read-only memory , a permanent storage device , input devices , and output devices .","The bus  collectively represents all system, peripheral, and chipset buses that communicatively connect the numerous internal devices of the computer system . For instance, the bus  communicatively connects the processor  with the read-only memory , the GPU , the system memory , and the permanent storage device .","From these various memory units, the processor  retrieves instructions to execute and data to process in order to execute the processes of the invention. Some instructions are passed to and executed by the GPU . The GPU  can offload various computations or complement the image processing provided by the processor .","The read-only-memory (ROM)  stores static data and instructions that are needed by the processor  and other modules of the computer system. The permanent storage device , on the other hand, is a read-and-write memory device. This device is a non-volatile memory unit that stores instructions and data even when the computer system  is off. Some embodiments of the invention use a mass-storage device (such as a magnetic or optical disk and its corresponding disk drive) as the permanent storage device .","Other embodiments use a removable storage device (such as a floppy disk, flash drive, or ZIP\u00ae disk, and its corresponding disk drive) as the permanent storage device. Like the permanent storage device , the system memory  is a read-and-write memory device. However, unlike storage device , the system memory is a volatile read-and-write memory, such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments, the invention's processes are stored in the system memory , the permanent storage device , and\/or the read-only memory .","The bus  also connects to the input and output devices  and . The input devices enable the user to communicate information and select commands to the computer system. The input devices  include alphanumeric keyboards and pointing devices (also called \u201ccursor control devices\u201d). The output devices  display images generated by the computer system. For instance, these devices display a GUI. The output devices include printers and display devices, such as cathode ray tubes (CRT) or liquid crystal displays (LCD).","Finally, as shown in , bus  also couples computer  to a network  through a network adapter (not shown). In this manner, the computer can be a part of a network of computers (such as a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), or an intranet, or a network of networks, such as the Internet. For example, the computer  may be coupled to a web server (network ) so that a web browser executing on the computer  can interact with the web server as a user interacts with a GUI that operates in the web browser.","Any or all components of computer system  may be used in conjunction with some embodiments. As mentioned above, the computer system  may include any one or more of a variety of different machine-readable or computer-readable media. Some examples of such computer-readable media include RAM, ROM, read-only compact discs (CD-ROM), recordable compact discs (CD-R), rewritable compact discs (CD-RW), read-only digital versatile discs (DVD-ROM), a variety of recordable\/rewritable DVDs (e.g., DVD-RAM, DVD-RW, DVD+RW, etc.), flash memory (e.g., SD cards, mini-SD cards, micro-SD cards, etc.), magnetic and\/or solid state hard drives, ZIP\u00ae disks, and floppy disks.","Machine-readable or computer-readable media are capable of storing computer programs or computer code that can be run on particular machines. Examples of computer programs or computer code include machine code, such as produced by a compiler, and files including higher-level code that are executed by a computer, an electronic component, or a microprocessor using an interpreter. In some embodiments, the firewall coordinator is a software program or a set of software programs stored on computer readable media. In some embodiments, firewalls (sometimes referred to herein as \u201cvirtual network firewalls\u201d) are software programs or sets of software programs stored on computer readable media. In some embodiments, other components are software programs or sets of software programs stored on computer readable media. When executed on one or more processors, such software programs implement the previously described features of some embodiments.","While the invention has been described with reference to numerous specific details, one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. For example, while the elements of the various embodiments can be used in conjunction, many of the features described herein can be used as independent, novel inventions."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 12A"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 12B"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 12C"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 14A and 14B"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 17A"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 17B"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 17C"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 25A"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 25B"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 33"}]},"DETDESC":[{},{}]}
