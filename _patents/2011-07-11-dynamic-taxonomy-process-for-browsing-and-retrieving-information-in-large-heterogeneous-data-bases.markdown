---
title: Dynamic taxonomy process for browsing and retrieving information in large heterogeneous data bases
abstract: A process is disclosed for retrieving information in large heterogeneous data bases, wherein information retrieval through visual querying/browsing is supported by dynamic taxonomies; the process comprises the steps of: initially showing (F) a complete taxonomy for the retrieval; refining (F) the retrieval through a selection of subsets of interest, where the refining is performed by selecting concepts in the taxonomy and combining them through boolean operations; showing (F) a reduced taxonomy for the selected set; and further refining (F) the retrieval through an iterative execution of the refining and showing steps.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08650171&OS=08650171&RS=08650171
owner: 21 Srl
number: 08650171
owner_city: Milan
owner_country: IT
publication_date: 20110711
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS","Example"],"p":["This application is a continuation application of and claims the benefit of priority from Ser. No. 10\/819,946, filed Apr. 8, 2004, which claims the benefit of application Ser. No. 09\/868,339, filed Jun. 18, 2001, which claims the benefit of PCT application PCT\/IT99\/00401\/, filed Dec. 3, 1999, and prior Italian Patent Application No. TO98A 001049, filed Dec. 16, 1998. The contents of each of the above applications are incorporated herein by reference.","The present invention refers to a dynamic taxonomy process for browsing and retrieving information in large heterogeneous data bases.","Information retrieval on this type of database (for example those available on the Internet) is nowadays a slow task, sometimes impossible to realize due to the enormous amount of data to be analyzed, and that can be implemented with difficulty with the currently available tools. The following documents deal with the prior art in this field: Hearst M. et al: \u201cCat-a-cone: an interactive interface for specifying searched and viewing retrieval results using a large category hierarchy,\u201d Annual International ACM-SIGIR Conference on Research and Development in Information Retrieval, US, New York, N.Y.: ACM, 1997, pages 246-255; EP-A-0 694 829 (XEROX Corp.); U.S. Pat. No. 5,644,740 (Kiuchi Itsuko); Gert Schmeltz Pedersen: \u201cA browser for bibliographic information retrieval, based on an application of lattice theory,\u201d Proceedings of the Annual International ACM SIGIR Conference on Research and Development in Information Retrieval, US, New York, ACM, vol. CONF., 16, 1993, pages 270-279; and Story G. et al: \u201cThe Rightpages image-based electronic library for alerting and browsing,\u201d Computer, US, IEEE Computer Society, Long Beach, Calif., US, vol. 25, no. 9, 1 Sep. 1992, pages 17-25.","The present Applicants developed for such purpose a process solving the above problems by an innovative use of taxonomies as a structuring and information access tool.","Dynamic taxonomies are a model to conceptually describe and access large heterogeneous information bases composed of texts, data, images and other multimedia documents.","A dynamic taxonomy is basically a IS-A hierarchy of concepts, going from the most general (topmost) to the most specific. A concept may have several fathers. This is a conceptual schema of the information base, i.e. the \u201cintension\u201d. Documents can be freely classified under different concepts at different level of abstraction (this is the \u201cextension\u201d). A specific document is generally classified under several concepts.","Dynamic taxonomies enforce the IS-A relationship by containment, i.e. the documents classified under a concept C are the deep extension of C, i.e. the recursive union of all the documents classified under C and under each descendant C\u2032 of C.","In a dynamic taxonomy, concepts can be composed through classical boolean operations. In addition, any set S of documents in the universe of discourse U (defined as the set of all documents classified in the taxonomy) can be represented by a reduced taxonomy. S may be synthesized either by boolean expressions on concepts or by any other retrieval method (e.g. \u201cinformation retrieval\u201d). The reduced taxonomy is derived from the original taxonomy by pruning the concepts (nodes) under which no document d in S is classified.","A new visual query\/browsing approach is supported by dynamic taxonomies. The user is initially presented with the complete taxonomy. He\/she can then refine the result by selecting a subset of interest. Refinement is done by selecting concepts in the taxonomy and combining them through boolean operations. She\/he will then be presented with a reduced taxonomy for the selected set of documents, which can be iteratively further refined.","The invention described here covers the following aspects of dynamic taxonomies:","1. additional operations;","2. abstract storage structures and operations on such structures for the intension and the extension;","3. physical storage structures, architecture and implementation of operations;","4. definition, use and implementation of virtual concepts;","5. definition, use and implementation of time-varying concepts;","6. binding a dynamic taxonomy to a database system;","7. using dynamic taxonomies to represent user profiles of interest and implementation of user alert for new interesting documents based on such profiles of interest.","The above and other objects and advantages of the invention, as will appear from the following description, are obtained by a dynamic taxonomy process as claimed in Claim . Preferred embodiments and non-trivial variations of the present invention are claimed in the dependent Claims.","Before proceeding with a detailed description of the invention, suitable terminology remarks will be made. The set of documents classified under the taxonomy (corpus) is denoted by U, the universe of discourse. Each document d in U is uniquely identified by an abstract label called document ID of d (DID(d)). Each concept c in the taxonomy is uniquely identified by an abstract label called concept ID of c (CID(c)). Concepts are partitioned into terminal concepts (concepts with no concept son in the taxonomy) and non-terminal concepts. T denotes the set of concepts used in the taxonomy.","The taxonomy is usually a tree, but lattices (deriving from a concept having more than one father) are allowed. Documents can be classified under any (terminal or non-terminal) concept in the taxonomy. A specific document d in U may be classified under one or more concepts. The single, most general concept in the taxonomy is called the root of the taxonomy. This concept need not be usually stored in the extension, since it represents the entire corpus.","The term \u201cdeep extension\u201d of a concept c denotes all the documents classified under c or under any descendant of c. The term \u201cshallow extension\u201d of a concept c denotes all the documents directly classified under c.","If c is a concept, C(c) denotes the set {c union {c\u2032: c\u2032 is an ancestor of c in the taxonomy, and c\u2032 is not the root of the taxonomy}}. C(c) is computed by the recursive application of operation AIO3 (described hereinbelow). If c is a concept, C(c) denotes the set {c union {c\u2032: c\u2032 is a descendant of c in the taxonomy}}. C(c) is computed by the recursive application of operation AIO2 (described hereinbelow).","With reference to , a block diagram is shown of the main steps of the process of the present invention, from which all further developments of the process itself originate, such developments being described hereinbelow.","According to the diagram in , the process for retrieving information on large heterogeneous data bases of the present invention comprises the steps of:","(F) initially showing a complete taxonomy for retrieval;","(F) refining the retrieval through a selection of subsets of interest, where the refining step is performed by selecting concepts in the taxonomy and combining them through boolean operations;","(F) showing a reduced taxonomy for the selected set; and","(F) further refining the retrieval through an iterative execution of the refining and showing steps.","In addition to the previously-described operations, the following operations can be supported:\n\n","The prior art has never specified storage structures nor the implementation of operations, that are both presented in this context. Abstract storage structures are defined with the following notation. Given domains A1, . . . , AN and B1, . . . , BM:\n\n","When brackets are omitted in the right part, square brackets are assumed.","Abstract relations can be trivially mapped (for the purpose of illustration, and with no intent to restrict their representation) to relations in a relational schema, in the following way:","R: R: [A1, . . . , AN]\u2192[B1, . . . , BM] maps into R(A1, . . . , AN, B1, . . . , BM)","R: R: [A1, . . . , AN]\u2192{B1, . . . , BM} maps into a set of 4NF relations Ri(A1, . . . , AN, Bi)","where underlined domains are key attributes of R. Abstract SQL queries on these relations will be used to express operations. When expedient, the notation A.B applied to an abstract relation [A]\u2192[B] or [A]\u2192{B} will be used to denote the value or the set of values of B corresponding to a given value of A. Domain CID holds the abstract labels of concepts, i.e. stands for the set of values {CID(c), for all c in the taxonomy}. Domain DID holds the abstract labels of documents, i.e. denotes the set of values {DID(d), for all d in U}.","Abstract structures to store the intension will now be described.","The intension is the taxonomy itself; it can be seen as a conceptual schema for a set of corpora. The intension is stored as:","AIS1. One or more \u201cdictionary\u201d relations in the form","Di: [CID]\u2192[textualLabel]","storing the user-visible definition of each concept; the domain \u201ctextualLabel\u201d holds natural language descriptions of concepts. Each dictionary can be in a different \u201clanguage\u201d, thereby allowing multilingual corpora and\/or different descriptions of concepts.\n\nAIS2. A language directory, identifying the appropriate dictionary relation for a specific \u201clanguage\u201d (required only if more than one \u201clanguage\u201d for concept description is used) in the form:\n\nLD: [LANGUAGE_ID]\u2192D\n\nwhere LANGUAGE_ID holds the abstract identification of languages and D holds the existing dictionaries.\n","An alternate representation of AIS1, AIS2 is by a single relation","AIS1\u2032: [CID, LANGUAGE_ID]\u2192textualLabel.","AIS3. A father to son relation in the form","FS: [CID]\u2192{SON_CID}","or","FS\u2032: [CID, SEQ]\u2192[SON_CID]","storing, for each concept c, its sons in the taxonomy. The domain SON_CID is the same as CID. The domain of SEQ is the set of natural numbers.","The second form, which is generally used, allows to supply a meaningful display order among the sons of a concept c.","AIS4. A son to father relation, in the form","SF: [CID]\u2192{FATHER_CID}","storing, for each concept c, its fathers in the taxonomy. The domain FATHER_CID is the same as CID.",{"@attributes":{"id":"p-0041","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"If the taxonomy is not a lattice (i.e. any concept c can have no more than one father), this relation becomes:\n\nSF: [CID]\u2192[FATHER_CID].\n"}},"In this latter case, information on the father of a specific concept c may alternatively be stored in the dictionaries as:","Di:[CID]\u2192FATHER_CID, textualLabel","although this results in redundancy if more than one dictionary is maintained.","Abstract storage structures for the extension will now be described.","The extension represents the classification of documents. As such, it depends on the specific corpus. The extension is abstractly represented by the following three relations:","AES1. Deep extension, in the form","DE:[CID]\u2192{DID}","storing, for each concept c, all the documents in its deep extension (that is, all the documents classified under c or under any descendant c\u2032 of c).","AES2. Shallow extension, in the form","SE: [CID]\u2192{DID} equivalent to [CID, DID]","storing, for each concept c, all the documents in its shallow extension (that is, all the documents directly classified under c). The shallow extension and the deep extension are the same for terminal concepts, so that for such terminal concepts only one of DE and SE needs to be kept (typically, DE will be kept).\n\nAES3. Classification, in the form\n\nCL:[DID]\u2192{CID}\n\nstoring, for each document, the most specific concepts under which it is classified. All the ancestors of these concepts can be easily recovered through the son-to-father (SF) relation in the intension. This structure is required only if the display of the classification for stored documents is supported at the user level. This storage structure is optional, since the set K of concepts under which a specific DID is stored can be synthesized by operation AE05 applied to each concept c in T on the singleton set {DID}. A concept c is then in K if and only if operation AE05 returns TRUE.\n\nAES4. Document directory\n\nNot specified, since it depends on the host system. It maps a document id into information required to retrieve the specific document (for example, the file name).\n","The abstract implementation of operations on the intension will now be described.","AIO1. Given a concept c identified by K=CID(c), find its label in a specific language L.","1. Access the appropriate language directory","SELECT D","FROM LD","WHERE LANGUAGE_ID=L","2. Use K as a key to access the textual label","SELECT textualLabel","FROM D","WHERE CID=K","AIO2. Given K=CID(c) find all its sons.","Access the father-to-son relation FS, using K as a partial key","SELECT SON_CID","FROM FS","WHERE CID=K","Or","Access the father-to-son relation FS\u2032, using K as a partial key","SELECT SEQ, SON_CID","FROM FS\u2032","WHERE CID=K","ORDER BY SEQ, SON_CID","AIO3. Given a K=CID(c), find all its fathers.","Access the son-to-father relation SF, using K as a partial key","SELECT FATHER_CID","FROM SF","WHERE CID=K","AIO4. Insert, delete, change operations.","Insert operations are performed by inserting the new concept C:",{"@attributes":{"id":"p-0047","num":"0000"},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["in the dictionaries (AIS1)","in the father to son relation (AIS3)","in the son to father relation (AIS4)"]}}}},"If C is a son of another concept C\u2032, it may be useful to allow the user to reclassify under C some of the documents presently classified in the shallow extension of C\u2032.","In the case in which each concept has a single father in the taxonomy, the deletion of a concept C is performed by deleting from the intension (AIS1, AIS3, AIS4) all concepts c\u03b5C(C). In addition (in order to avoid losing documents), the documents in the deep extension of C should be added to the shallow extension of C\u2032, where C\u2032 is the father of C in the taxonomy, unless C\u2032 is the root of the taxonomy. The shallow (AES2) and deep (AES1) extensions for all concepts c\u03b5C(C) must be removed. The concepts in C(C) must be removed from the classification (AES3) of all the documents in the deep extension of C.","Alternatively, and in the general case in which concepts can have multiple fathers, we proceed as follows.","Define LinkDelete(f, s) as:",{"@attributes":{"id":"p-0051","num":"0000"},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":["1. remove from AIS3 the instance where CID=CID(f) and SON_CID=CID(s)","2. remove from AIS4 the instance where CID=CID(s) and FATHER_CID=CID(f)\n\nDefine BasicDelete(c) as:\n","1. for each f in {f: f is a father of c} call LinkDelete(f, c)","2. remove the deep (AES1) and shallow (AES2) extension for c, its classification (AES3), and any dictionary entries associated with c.\n\nDefine RecursiveDelete(f, s) as:\n","1. if f is the only father of s then\n    \n    ","2. else call LinkDelete(f, s)\n\nDefine RecomputeDeepExtension(c) as:\n","1. for each s in {s: s is a son of c}\n    \n    ","2. return(DeepExtension(c))\n\nDefine UpdateDeepExtension(c) as:\n","1. for each f in {f: f is a father of c}\n    \n    ","1. Compute the set F(C), which represents all the fathers of the concept to be deleted (accessible through relation AIS4). All and only the concepts in F(C) and their ancestors will have their deep extension affected by the deletion of C.","2. For each s in {s: s is a son of C}, call RecursiveDelete(C, s)","3. Call BasicDelete(C).","4. Recompute the deep extension of all the fathers of C: for each f in F(C) call RecomputeDeepExtension(f)","5. Update the deep extension of all the ancestors of the set F(C):\n    \n    ","1. changing the labeling of a concept C: this only requires the modification of the textualLabel in AIS1","2. changing the place of a concept C in the taxonomy","3. adding an additional father C\u2032 to C in the taxonomy"]}},"In case 2, let C\u2032 be the current father of C and C\u2033 the new father of C. First, C must be deleted from the taxonomy, and reinserted with C\u2033 as a father. The deep extension of C must be deleted from the deep extension of all concepts c e CP(C\u2032) (by set subtraction, or by applying the above algorithm for deletion with steps 2 and 3 replaced by C reparenting). The deep extension of C must be added to the deep extension of all concepts c\u03b5C(C\u2033) (by set union). No changes in shallow extensions are required.","In case 3, the deep extension of C must be added to the deep extension of all concepts c\u03b5C(C\u2032) (by set union).","The abstract implementation of operations on the extension will now be described.","AEO1. Given a concept c such that CID(c)=K, find its deep extension.","Access the deep-extension relation DE, using K as a partial key","SELECT DID","FROM DE","WHERE CID=K","AEO2. Given a concept c such that CID(c)=K, find its shallow extension.","Access the shallow extension relation SE, using K as a partial key","SELECT DID","FROM SE","WHERE CID=K","AEO3. Test the membership of a set of DIDs {DID} in the deep extension of a concept CID.",{"@attributes":{"id":"p-0055","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["1. Retrieve the deep extension of CID","2. For each d in {DID}, test whether d belongs to the deep-extension; if it does, return TRUE; if no d in {DID} does, return FALSE\n\nAEO4. Given a set of DIDs {DID}, count the number of documents in {DID} which are also in the deep extension of CID.\n","1. Retrieve the deep extension of CID","2. Initialize CNT to 0","3. For each d in {DID}, test whether d belongs to the deep-extension; if it does, CNT=CNT+1","4. Return CNT\n\nAEO5. Test the membership of a set of DIDs {DID} in the shallow extension of a concept CID.\n\nAs in AEO3, by substituting the deep extension with the shallow extension.\n\nAEO6. Given a set of DIDs {DID}, produce the projection under a concept CID.\n","1. Retrieve the set {SON} of all the sons of CID","2. Initialize set R to empty","3. For each concept s in SON, use operation AEO3, or operation AEO4 if counters are desired, to test the membership of {DID} in s. If the operation returns TRUE (>0 if AEO4 is used) add s to list R","4. Return R\n\nAEO7. Given a set of DIDs {DID}, produce the reduced taxonomy for {DID}.\n"]}},"As a clarification, the set of DIDs for which the reduced taxonomy has to be produced can be generated by operations on the taxonomy and also by any other means, including, without loss of generality, database queries and information retrieval queries. Also, the current combination of concepts can be used as a pre-filter for other retrieval methods.","For performance reason, the reduced taxonomy is usually produced on demand: the request only displays the highest levels in the tree. The set {DID} is kept in memory, so that when the explosion of a specific concept in the reduced taxonomy is requested, appropriate filtering is performed.\n\n","Produce the projection of {DID} for c","The reduced tree can also be totally computed in a single step. Let RT be the set of concepts in the reduced tree. RT can be computed by testing, for each concept c in T, the membership of {DID} in c through operation AEO3 or AEO4 (if counters are required). Concept c is in RT if and only if operation AEO3 returns TRUE or operation AEO4 returns a counter larger than 0.","The computation can be speeded up in the following way:\n\n","Boolean combinations of concepts are performed through the corresponding set operations on the deep extension of concepts. Let c and c\u2032 be two concepts, and DE(c) and DE(c\u2032) their deep extension (represented by AES1):","c AND c\u2032 corresponds to DE(C)\u2229DE(c\u2032)","c OR c\u2032 corresponds to DE(c)\u222aDE(c\u2032)","c MINUS c\u2032 corresponds to DE(c)-DE(c\u2032)","NOT c corresponds to U-DE(c), where U is the universe","AEO9. Insertion of a new document.","The insertion of a new document d (represented by DID(d)) classified under a set of concepts {C} requires the following steps:","for each c\u03b5{C}",{"@attributes":{"id":"p-0062","num":"0000"},"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["1. insert DID(d) in the shallow extension of c (AES2), if c is not a terminal concept and the shallow extension must be stored","2. insert DID(d) in the deep extension (AES1) of C(c).","3. insert an item [DID(d)]\u2192{C} in the classification structure AES3\n\nAEO10. Deletion of an existing document.\n\nThe deletion of a document d (represented by DID(d)) requires the following steps:\n","1. retrieve the set of concepts {C} under which d is shallowly classified, by accessing AES3 with DID(d) as the key (operation AEO2)","2. for each c\u03b5{C}\n    \n    ","3. delete the entry corresponding to DID(d) from AES3."]}},"If AES3 is not stored, deletion is performed in the following way. For each concept c in T, if d belongs to the shallow extension of c:\n\n","Changes in the classification of a document d (represented by DID(d)) are implemented in the following way. Let d be initially classified under a concept c (possibly null) and let the new concept under which d must be classified be c\u2032 (possibly null). If both c and c\u2032 are non-null, the operation means that d was previously classified under c and must now be classified under c\u2032; if c is null, the operation means that d is additionally classified under c\u2032; if c\u2032 is null, the operation means that the original classification under c must be removed. At least one of c and c\u2032 must be non-null.","If c is not null:",{"@attributes":{"id":"p-0065","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":["1. eliminate DID(d) from the shallow extension (AES2) of c","2. eliminate DID(d) from the deep extension (AES1) of all c\u2033\u03b5C(c)","3. eliminate c from the classification of d (AES3)\n\nIf c\u2032 is not null:\n","1. insert DID(d) in the shallow extension (AES2) of c\u2032 (if the shallow extension of c exists)","2. insert DID(d) in the deep extension (AES1) of all c\u2033\u03b5 C(c\u2032)","3. insert c\u2032 in the classification of d (AES3)\n\nAEO12. Find the concepts under which a document d is immediately classified.\n\nRetrieve {C} from AES3, using DID(d) as a key.\n"]}},"Physical storage structures, architecture and implementation of operations will now be described.","As regards the intension, storage structures usually contribute with a negligible overhead to the overall storage cost, since a few thousand of concepts are usually adequate even for semantically rich corpora. Storage for these structures may be provided by any database management system or any keyed access method. The second form of AIS3 (FS\u2032) requires an ordered access, since SEQ is used to order the sons of a specific concept. Because of the low overhead, all the intensional storage structures (with the possible exception of AIS1, the dictionaries) may be usually kept in central memory.","As regards the extension, the most critical component is AES1 (the deep extension), for several reasons. First, deep-extension semantics are the natural semantics for boolean combinations of concepts (see AEO8). Second, the production of reduced taxonomies requires a possibly large number of projections (which are performed on the deep extension), whose performance is critical for visual operations.","It is critical that the deep extension of concept c is explicitly stored, and not computed as the union of the shallow extensions of all the descendants of c.","Although any dbms or keyed access method can be used to provide storage for the deep extension, the set of documents in the deep extension can be more efficiently represented than by straightforwardly mapping the abstract relation.","The use of fixed size bit vectors in the present context will now be described. Information data bases with a small-to-moderate number of documents can effectively represent the deep extension of a concept c by bit vectors, each of size equal to |U\u2032|, the maximum number of documents in the universe. In the bit vector, bit i is set if and only if the document d with DID(d)=i is in the deep extension of c.","Set operations on the deep extension only involve logical operations on bit vectors (AND, OR, NOT, etc.). These operations take one or more bit vectors and produce a result bit vector of the same size.","Let document id's be numbered 0 to |U\u2032|\u22121, and n be the number of bits in the word of the host CPU. For performance reasons, it is better to set the fixed size of bit vectors at \u250c|U\u2032|\/n\u2510, in order to be able to perform bit operations at the word level. Unused bit positions are left unset.","Counting the number of documents in the result of any operation can be efficiently performed by table lookup, in the following way.","Let the unit of access UA (not necessarily the CPU word) be n bits. Build once a vector V of 2elements, stored in memory, which stores in V[i], the number of bits set in the binary number 2, 0<=i<=2\u22121.","Counting:","Initialize counter C at 0;","Access the bit vector in chunks of n bits at a time:","for each chunk",{"@attributes":{"id":"p-0076","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["store the chunk in i","set C=C+V[i]"]}}}},"For access at the octet level (n=8), the translation table requires no more than 256 octets. For access at the double octet level (n=16), no more than 64K octets. Larger units of access are not recommended.","Insertion, deletion and reclassification are also efficiently performed, by simply locating the appropriate deep and\/or shallow extension and setting\/resetting the appropriate bit.","This same representation can be trivially used for storing structures AS2 and AS3. In AS3 the size of the bit vector is equal to the cardinality of the set of concepts in the taxonomy.","As regards compressed bit vectors, by construction, the deep extension is very sparse at terminal level, and very dense at the top levels in the taxonomy. The use of any type of bit vector compression (such as, without prejudice to generality, Run Length Encoding (see Capon J., \u201cA probabilistic model for run-length coding of pictures\u201d, IEEE Trans. on Inf. Theory, 1959) and\/or variable-length bit vectors) is therefore beneficial in reducing the overall storage overhead, although it introduces a compression\/decompression overhead.","If a controlled error-rate in operations is acceptable, Bloom filters (see Bloom, B. H., Space\/time tradeoffs in hash coding with allowable errors, Comm. of the ACM, 1970) can be used to represent the deep extension in a compact form, suitable for larger information bases. With Bloom filters, counting and set negation are usually not supported.","For large to very large information bases, a bit vector representation (albeit compressed) may produce an excessive storage overhead. The deep and shallow extensions as well as structure AES3 may be stored as inverted lists (see Wiederhold, G., Files structures, McGraw-Hill, 1987). Because of performance in the computation of set operations, such lists (and the result of set operations) are kept ordered by document id's. For the above-cited statements, it is generally advantageous to use any form of inverted list compression.","As regards the general architectural strategies, the implementation of dynamic taxonomies should try to keep all the relevant data structures in main memory, shared by the processes accessing them.","As noted before, the intension overhead is generally negligible so that intensional structures (with the possible exception of dictionaries) may be usually kept in memory without problems.","Extension overhead for extensional structures is considerably larger. If the storage overhead prevents the complete storage of deep-extension structures, buffering strategies should be used, such as LRU or the ones described in documents Johnson, T., Shasha D.: 2Q: A Low Overhead High Performance Buffer Management Replacement Algorithm, Int. Conf. on Very Large Databases, 1994; and O'Neill, et al.: The LRU-K Page Replacement Algorithm For Database Disk Buffering, SIGMOD Conf. 1993. Shallow extensions and classification structures are less critical and may be kept on disk (again with the buffering strategies described in the two above-mentioned documents).","As indicated in operation AEO3, the membership test without counting can return TRUE when the first DID common to both lists is found, thereby speeding up the computation.","The use and implementation of virtual concepts will now be described.","Some data domains (such as price, dates, quantities, etc.) correspond usually to a concept (e.g. PRICE) which can be expanded into a large number of terminal concepts, each representing a specific value (e.g. 100$). Such a representation causes a high number of son concepts, and increases the complexity of the taxonomy. Alternatively, values can be grouped by defining meaningful intervals of values and representing only the intervals as specific concepts. This representation loses the actual data, and presents the user with a fixed classification. Grouping may also be combined with exhaustive representation, but inherits most of the problems of both schemes.","The invention of \u201cvirtual concepts\u201d provides a third, more flexible alternative. We define a \u201cSimple virtual concept\u201d as a concept for which neither the actual sons (actual values of the domain to be represented) nor the actual extension are stored, but are computed (usually from additional, possibly external data).","A virtual concept is completely described by 4 abstract operations:","V1: Given a virtual concept v, retrieve all its sons.","V2: Given a virtual concept v, retrieve its deep extension.","V3: Given the son s of a virtual concept v, retrieve its deep extension.","V4: Given a document d, find all the terminal concepts (descendants of v) under which it is stored.","One way of implementing these abstract operations is by keeping, for each virtual concept v, two abstract relations:","S: [value]\u2192{DID}","which stores the set of documents with a given value in the domain of values of the virtual concept.","C: [DID]\u2192{value}","which stores the set of values for a specific document; if each document has a single value C: [DID]\u2192[value]. A single Crelation may store multiple domains and be shared by many virtual concepts: in this case C: [DID]\u2192{valueA, . . . , valueN}, where valueI denotes the set of values for domain I. It is important to note that neither Snor Cneed to be explicitly stored, but they can be also synthesized by queries on external data.","These two abstract relations can be represented by a single relation in a relational schema (without loss of generality and simply to provide a clear description of operations)","C(DID, value)","with underscored attributes representing the primary keys. Sactually stores the inversion of Cand will usually be represented by a secondary index on C, rather than by a base relation.","With this representation, the abstract operations defined before can be easily implemented by SQL queries:","V1: Given a virtual concept v, retrieve all its sons:","SELECT DISTINCT value","FROM C","V2: Given a virtual concept v, retrieve its deep extension:","SELECT DISTINCT DID","FROM C","V3: Given the son s of a virtual concept v, retrieve its extension (s is a terminal concept, so that its deep and shallow extension are the same)","SELECT DISTINCT DID","FROM C","WHERE value=s","Counting is trivially added.","V4: Given a document d, find all the terminal concepts (descendants of v) under which it is stored","RETRIEVE DISTINCT value","FROM C","WHERE DID=d","In general, a virtual concept v can be organized into a sub-taxonomy, i.e. each non-terminal son of v represents a set of actual domain values. Each son may be further specialized, and so on. For instance SALARY can be organized into the following taxonomy:","SALARY",{"@attributes":{"id":"p-0096","num":"0000"},"ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":{"@attributes":{"id":"ul0023-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0024","list-style":"none"},"li":["Low (e.g. <1000)","Medium (e.g. >=1000 and <10000)","High (e.g. >10000)"]}}}},"In this case, the non-terminal descendants of v can be stored as derived virtual concepts, i.e. virtual concepts referencing the same abstract relations defined for v, but providing additional restrictions. In the example, \u201cLow\u201d can be characterized by the additional restriction value<1000, so that operation V3 for Low becomes:","SELECT DISTINCT DID","FROM C","WHERE value<1000","Virtual and derived virtual concepts are peculiar in that their terminal descendants and their extensions are not directly stored but computed. In order to represent them in our framework, the following abstract relations are added to the intension:","AIS5: [CID]\u2192[conceptType]","where conceptType designated real, simple virtual and derived virtual concepts.","AIS6: [CID]\u2192[S]","for simple virtual concepts, stores the abstract relation Sv (which can synthesized be a query) for the virtual concept CID","AIS7: [CID]\u2192[C]","for simple virtual concepts, stores the abstract relation Cv (which can synthesized be a query) for the virtual concept CID","AIS8: [CID]\u2192[CID\u2032, restriction]","for derived virtual concepts only, identifies the virtual concept to refer to and the additional restriction.","The use and implementation of time-varying concepts will now be described.","Time-varying concepts, such as age, can be represented by a simple variant of virtual concepts. A time instant t is represented as an abstract \u201ctimestamp\u201d. The timestamp contains the number of clock ticks starting from a fixed time origin; the clock resolution depends on the application. All timestamps use the same time coordinates. The difference between two timestamps t and t\u2032 defines the time interval amplitude between the two times. Let the values of the virtual concept v be the set of timestamps of all documents in the extension of v, and let T be the timestamp of the current time, and the sons of v be represented as time intervals with respect to the current timestamp T:","Given a virtual concept v, retrieve all its sons:","SELECT DISTINCT T-value","FROM C","Given a virtual concept v, retrieve its deep extension:","SELECT DISTINCT DID","FROM C","Given the son s of a virtual concept v, retrieve its extension","SELECT DISTINCT DID","FROM C","WHERE value=T\u2212s","Alternatively, and more efficiently, the values of the time-varying concept can be split into N intervals (from more recent to older), which are stored as real concepts. In addition, for each interval I, we keep:\n\n","Since the classification of documents varies with time, we need to re-compute the classification of documents every time tick (arbitrary time interval selected by the system administrator, typically a multiple of clock resolution), according to the following algorithm:",{"@attributes":{"id":"p-0103","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"At each time tick:"]},{"entry":[{},"For each interval I"]},{"entry":[{},"while IR(I) needs reclassification (i.e. it fails"]},{"entry":[{},"the classification criterion for I) do"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003Reclassify(IR(I));"]},{"entry":[{},"\u2003\u2003set as IR(I) the last DID in the ordered list"]},{"entry":[{},"a)"]},{"entry":[{},"}"]},{"entry":[{},"where Reclassify(IR(I)) is"]},{"entry":[{},"Delete IR(I).DID from I"]},{"entry":[{},"For(i=i+1 to N)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003if IR(I).timestamp meets\u2002the\u2002classification"]},{"entry":[{},"criterion for interval i"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003insert IR(I) in interval i"]},{"entry":[{},"\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Binding a dynamic taxonomy to a database system will now be described.","The present invention allows to use a dynamic taxonomy to browse and retrieve data stored in a conventional dbms (relational, object-relational, object-oriented, etc.). The invention covers data stored as a single relation (or object) or, more generally, represented by a single view on the database (see Elmasri, Navathe, Fundamentals of database systems, The Benjamin\/Cummings Publ. Co., 1994).","In this case documents correspond to tuples (or rows, records, objects) in the view V. In order to identify a document we can either use the primary key of the view as a document identifier (DID) or keep two abstract relations mapping system-generated DID's to and from the primary key PK of the view:","DK: [DID]\u2192[PK]","IDK: [PK]\u2192[DID]","where PK represents the primary key of the relation. DK is used to access a tuple of V, given a document id DID, and IDK is used to retrieve the document id corresponding to a specific value in the primary key of V. This latter representation is beneficial when primary keys PK's are large (e.g. when they are defined on alphanumeric attributes).","Given a view V we can construct a taxonomy T for V in the following way. For each attribute A in V, we place a corresponding concept C(A) (either a real or a virtual one) as an immediate son of the root. Virtual concepts use V itself for the synthesis of sons and extensions (as previously seen). Real concepts can be further specialized as required by the semantics of A.","Given a tuple t in V, for each attribute A in V, let t.A denote the value of attribute A in t. For each real concept C in T (either C(A) or a descendant of C(A)), the designer must provide a boolean clause B(C, t) such that t (represented by DID(t)) is to be classified under C if and only if B(C, t)=TRUE.","The boolean clause B(C, t) may reference any attribute of t, and consequently, new virtual concepts (called \u201cextended concepts\u201d) may be defined on combinations of attributes by operations on the database (including but not restricted to sums, averages, etc. of database values).","A special case occurs when the boolean clause B(C, t) is true when t.A\u03b5S, where Sis a set of values of attribute A and S\u2229S\u2032=\u00d8, for \u2200C\u2260C\u2032. In this case, it is more efficient to keep a table T:[v]\u2192[c], listing for each value v in domain(A), the corresponding concept c. If S\u2229S\u2260\u00d8, for \u2203C\u2260C\u2032, multiple concepts can be associated with the same value, so that T:[v]\u2192{c}.","In addition to this mapping among attributes and concepts, the designer may define new concepts either as taxonomic generalizations of attributes or extended concepts.\n\n","Binding is then performed in the following way. Virtual concepts do not require any special processing, since they are realized by operations on the database. Real concepts require a classification for any new tuple, a deletion if t is deleted or a reclassification if t is changed. In order to classify t, the system locates the set C of concepts for which B(c, t), c\u03b5C is satisfied and classifies t under \u2200c\u03b5C (and, consequently under all of c's ancestors). Deletion and reclassification are performed as previously stated.","Given the relation R:(TOWNID, NAME, COUNTRY, POPULATION), we can identify the documents in the database by the values of TOWNID. We need to decide which attributes will be represented in T and how they will be represented. Let COUNTRY be represented by a real concept, and NAME be represented by a virtual concept. In addition we define the real concept CONTINENT as the continent the COUNTRY is in. CONTINENT can be represented in two ways: as a taxonomic generalization concept or as an extended concept.","If we represent CONTINENT as an extended concept, the taxonomy T will be:",{"@attributes":{"id":"p-0116","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NAME"]},{"entry":[{},"\u2003\u2003Sv:Select TOWNID FROM R WHERE NAME = x"]},{"entry":[{},"\u2003\u2003Cv:Select DISTINCT NAME FROM R"]},{"entry":[{},"CONTINENT"]},{"entry":[{},"EUROPE t.COUNTRY=\u201cItaly\u201d or t.COUNTRY=\u201cFrance\u201d or ..."]},{"entry":[{},"AMERICA t.COUNTRY=\u201cUSA\u201d or ..."]},{"entry":[{},"ASIA t.COUNTRY=..."]},{"entry":[{},"COUNTRY"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Italy","t.COUNTRY=\u201cItaly\u201d"]},{"entry":[{},"\u2003\u2003France","t.COUNTRY=\u201cFrance\u201d"]},{"entry":[{},"\u2003\u2003Usa","t.COUNTRY=\u201cUSA\u201d"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"If we represent CONTINENT as a taxonomic generalization of COUNTRY, the taxonomy T\u2032 will be:",{"@attributes":{"id":"p-0118","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NAME"]},{"entry":[{},"\u2003\u2003Sv:Select TOWNID FROM R WHERE NAME = x"]},{"entry":[{},"\u2003\u2003Cv:Select DISTINCT NAME FROM R"]},{"entry":[{},"CONTINENT"]},{"entry":[{},"\u2003\u2003EUROPE"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003Italy","t.COUNTRY=\u201cItaly\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003France","t.COUNTRY=\u201cFrance\u201d"]},{"entry":[{},"\u2003\u2003AMERICA"]},{"entry":[{},"\u2003\u2003\u2003\u2003Usa","..."]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003ASIA"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"COUNTRY"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Italy","t.COUNTRY=\u201cItaly\u201d"]},{"entry":[{},"\u2003\u2003France","t.COUNTRY=\u201cFrance\u201d"]},{"entry":[{},"\u2003\u2003Usa","t.COUNTRY=\u201cUSA\u201d"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In both cases, NAME is represented in the same way. For NAME, we have two abstract relations","Sv:[COUNTRY]\u2192{TOWNID}","Cv:[TOWNID]\u2192[COUNTRY]","POPULATION is represented in an analogous way.","Finally, the use of dynamic taxonomies to represent user profiles of interest and implementation of a user alert for new interesting documents based on dynamic taxonomy profiles, will be described.","The invention consists in using set-theoretic expressions on concepts (plus optional, additional expressions, such as information retrieval queries) to describe user interest in specific topics. Such expressions may be directly entered by the user or transparently and automatically captured by the system, by monitoring user query\/browsing. The specification of user profiles is especially important in electronic commerce and information brokering and in monitoring dynamic data sources in order to advise users of new or changed relevant information. The information base is assumed to be classified through dynamic taxonomies.","The scenario is as follows. Several users express their interests through possible multiple conceptual expressions, called \u201cinterest specifications\u201d. A monitoring system accepts these requests (with an abstract user \u201caddress\u201d to send alerts to). The monitoring system also monitors an information base for changes (insertion, deletion, change). The information base is described by the same taxonomy used by users to express their interests.","When a change occurs in the information base (the type of change to be alerted for may be specified by users), the system must find the users to alert on the basis of their interests.","A brute force approach will check all user interest specifications exhaustively, and compute whether each changed document d satisfies any given specification S. We can test whether a document d satisfies a specification S by applying the query specified in S to the singleton set {d} and test if d is retrieved. However, this strategy requires to perform, for each information base change, as many queries as there are user specifications and may be quite expensive in practice. For this reason, we define alternate strategies which reduce the number of evaluations required.","We are primarily interested into the efficient solution of dynamic taxonomy specifications. Additional expressions, such as information retrieval queries, will usually be composed by AND with taxonomic expressions, and can therefore be solved, if required, after the corresponding taxonomic expression is satisfied.","We will start from the simplest case, in which:\n\n","When a specification is created, its abstract identifier is created, its directory entry is created in SD and the set of concepts referenced in the specification are stored in the inversion SI.","When a document d is inserted, deleted or changed, let C be the set of concepts (terminal concepts by assumption) under which d is classified. The set of specifications that apply to d are then found in the following way.","Let K be the set of concepts used to classify document d. For each concept k in K, let SID(k) be the list of specifications for k (accessible through relation SI) ordered by increasing specification id's. We define MergeCount(K) as the set composed of pairs (SID, N) such that SID is in MergeCount(K) if SID belongs to a SID(k), k in K. If the pair (SID, N) is in MergeCount(K), N counts the number of SID(k) referencing SID. MergeCount(K) can be produced at a linear cost, by merging the SID(k) lists.","Let S be a set initially empty, which represents the set of specifications satisfied by d.","For each pair (SID, N)",{"@attributes":{"id":"p-0131","num":"0000"},"ul":{"@attributes":{"id":"ul0029","list-style":"none"},"li":{"@attributes":{"id":"ul0029-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":["retrieve SID.N from SD;","if SID.N=N: S=S union SID"]}}}},"As regards specifications using unrestricted set operations, let S (represented by SID(S)) be a specification. Transform S into a disjunctive normal form (i.e. as a disjunction of conjunctions). Let each conjunctive clause in S be called a component of S. We denote by SIDi(S) the i-th component of S.","Store the directory of specifications as two abstract relations:","SD (as before, with N omitted)","SCD: [COMPONENT]\u2192[SDI, N], where COMPONENT stores components of specifications, COMPONENT.SDI represents the specification id of the specification S of which COMPONENT is a component, and COMPONENT.N is the number of concepts referenced in the component.","The specification inversion is stored as:","SI: [CID]\u2192{COMPONENT}, where CID is a concept identifier and CID.COMPONENT is the set of components referencing the concept identified by CID.","Let K be the set of concepts used to classify document d, for each concept k in K, let COMPONENT(k) be the list of components for k (accessible through relation SI) ordered by increasing component id's. Define ComponentMergeCount(K) as the set composed of pairs (COMPONENT, N) such that COMPONENT is in ComponentMergeCount(K) if COMPONENT belongs to a COMPONENT(k), k in K. If the pair (COMPONENT, N) is in ComponentMergeCount(K), N counts the number of COMPONENT(k) referencing COMPONENT. ComponentMergeCount(K) can be produced at a linear cost, by merging the COMPONENT(k) lists.","Let S be a set initially empty.","For each pair (COMPONENT, N),","retrieve COMPONENT.N through relation SCD;","if COMPONENT.N=N: S=S union COMPONENT.SID (COMPONENT.SID is accessed through relation SCD).","S represents the set of specifications satisfied by d.","As regards specifications and document classification under non-terminal concepts to which they refer, the specification inversion SI needs to be modified in the following way.","If a specification or component Z references concept C, represented by CID(C) then:","C is a terminal concept:\n\n","Z, if Z is a component","C is a non-terminal concept:","for each k in C(C)\n\n","The set S of satisfied specifications is computed as per the previous cases.","The above-disclosed techniques allow computing the specifications satisfied by a document d. In case it is desired to determine the specifications satisfied by a set of documents D (whose cardinality is greater than 1), the above-disclosed techniques can be applied in two ways. In the first way, the techniques are applied without modifications to every document d in D, then removing possible duplicate specifications. In the second way, K is defined as the set of concepts used to classify D, the adequate technique is chosen among the described ones and the set S of \u201ccandidate\u201d specifications is determined. Every specification s in S is then checked, performing it on D."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":"The present invention will be better described by some preferred embodiments thereof, given as a non-limiting example, with reference to the enclosed drawing, whose  shows a block diagram of the process of the present invention."},"DETDESC":[{},{}]}
