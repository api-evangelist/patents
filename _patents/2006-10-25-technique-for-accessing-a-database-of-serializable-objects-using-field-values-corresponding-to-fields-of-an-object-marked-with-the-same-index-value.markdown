---
title: Technique for accessing a database of serializable objects using field values corresponding to fields of an object marked with the same index value
abstract: A converter may be used to convert a serializable object to other file formats. A serializable objects database can be used to store these serializable objects. The serializable object database may be accessed by passing a field value, corresponding to a selected field of the serializable object, to the database. The selected field of the serializable object is marked with an index value. The database is queried using the field value to determine whether any record stored in the database includes the field value in a matching field indicated by the index value. If the query determines that the serializable objects database includes at least one record with the field value in the matching field indicated by the index value, then a plurality of field values are returned to populate a plurality of fields of the serializable object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07620526&OS=07620526&RS=07620526
owner: Zeugma Systems Inc.
number: 07620526
owner_city: Richmond
owner_country: CA
publication_date: 20061025
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to software, and in particular but not exclusively, relates to databases.",{"@attributes":{"id":"p-0003","num":"0002"},"figref":"FIG. 1","b":["100","105","110","105","110","115","105","105","120","115","105","110","125","105","125","110","105"]},"Since database  merely indexes data buffers or records to internal keys, the knowledge and complexity required to run higher level queries on database  is pushed onto application developers of database client . Furthermore, since the internal keys themselves are not part of the useful data stored by database client , but rather independently generated values used simply for retrieving records or data buffers, the internal keys consume additional memory resources within database .","In an alternative conventional database system, database  itself may contain knowledge of the internal representation of the data buffers or records it stores to perform it own complex queries and indexing. This alternative embodiment pushes the complexities of indexing and queries onto the database developer; however, does so at the expense of performance by adding a layer of abstraction between the records stored and the database clients accessing the records.","Embodiments of a system and method for serializable objects and a serializable objects database are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize, however, that the techniques described herein can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring certain aspects.","Reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrases \u201cin one embodiment\u201d or \u201cin an embodiment\u201d in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":["200","200","205","210","215","210","215","200"]},"In the illustrated embodiment, network service element  is implemented using an Advanced Telecommunication and Computing Architecture (\u201cATCA\u201d) chassis. Mesh interconnect  may provide cross-connectivity between traffic and compute modules  and  with the ATCA backplane. In the exemplary configuration shown in , the ATCA chassis is fully populated with 14 ATCA blades (i.e., traffic and compute modules  and ), with each blade installed in a respective chassis slot\u2014in an actual implementation, the chassis may be populated with less blades or may include other types of blades in addition to compute and traffic blades. The illustrated configuration includes four compute modules , and  traffic modules , with one of the compute modules being provisioned to provide operations, administration, maintenance and provisioning functionality (\u201cOAMP\u201d) functions. As depicted by interconnection mesh , each module is communicatively-coupled with every other module under the control of fabric switching operations performed by each module's fabric switch. In one embodiment, mesh interconnect  provides a 10 Gbps connection between each pair of modules, with an aggregate bandwidth of 280 Gbps.","In the illustrated embodiments, network service element  is implemented using a distributed architecture, wherein various processor and memory resources are distributed across multiple modules. To scale a system, one simply adds another module (e.g., blade). The system is further enabled to dynamically allocate processor tasks, and to automatically perform fail-over operations in response to a module failure or the like. Furthermore, under an ATCA implementation, modules may be hot-swapped without taking the system down, thus supporting dynamic scaling.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3A","b":["300","200","300","305","310","315","320"]},"HAL  abstracts the underlying hardware resources to the software layers above and may include various device drivers, a kernel, software buffers, or the like. Runtime layer  is used to maintain dynamic state information for the modules of network service node , which may be in a state of flux during operation. For example, routing demons may execute in runtime layer  to setup and tear down route changes, to receive and process open shortest path first (\u201cOSPF\u201d) protocol packets, or service other dynamic change requests coming up from HAL .","Management layer  services application programming interface (\u201cAPI\u201d) calls from interface layer  and translates the calls into data, typically to be stored into a provisioning database  or occasionally into a runtime database . The APIs are published into interface layer  via a management layer API (\u201cMLAPI\u201d), which may provide a variety of APIs for accessing the databases. For example, the MLAPI may publish five APIs into interface layer  including a set API, a get API, a get multiple API, a create API, and a remove API. Management layer  typically facilities the provisioning of static attributes assigned to the modules of network service node . For example, static attributes may include port assignments, the existence (or lack thereof) of a module in a slot, power settings, a registry of applications executing on each module, and the like.","Finally, interface layer  proves an access layer to enable a user (e.g., network administrator or other Information Technology (\u201cIT\u201d) technician) to interface with network service element  and the lower layers of layered software stack . For example, the user may invoke any of the APIs published by the MLAPI using a command line interface (\u201cCLI\u201d) to get (e.g., retrieve) one or more records stored in provisioning database  or runtime database , create a new record, remove (e.g., delete) an existing record therefrom, or set an attribute of an object existing in lower layers of layered software stack . In other cases, the interface layer  may enable the user to push user\/data files (e.g., extensible markup language (\u201cXML\u201d) files, etc.) down to the lower layers through one or more converters.","As mentioned, interface layer  enables a user to push in data files  from external sources. Data files  may be XML files, C objects, C++ objects, C# objects, Java objects, or otherwise. As a data file  is pushed down to management layer , layered software stack  may convert data file  into a serializable object . A serializable object (\u201cSO\u201d) is a software object that lends itself well to serialization and which is typically a complex of linked memory structures. As SO  is pushed further down to runtime layer , SO  may be converted into a flat structure . Flat structure  typically is a fixed length contiguous memory structure which may be quickly and easy manipulated in memory and therefore well suited for the high speed, dynamic environment of runtime layer .","Provisioning database  may be used to store provisioning data for setting static or semi-static attributes of network service element , while runtime database  may be used to store runtime data arriving on datapaths rising up from HAL . In one embodiment, provisioning database  may convert SO  into variable length, compressed, flat memory structures, prior to storing SO , while runtime database  may simply store flat structure  as a fixed length, uncompressed, flat structure. Since runtime layer  manages high speed, dynamically changing events, it is reasonable to tradeoff memory consumption (e.g., fixed length, uncompress structures) in exchange for low latency, high speed access to runtime database . In contrast, management layer  typically manages static or semi-static attributes, therefore compressed, variable length structures are advantages, even at the expense of incurring some processing overhead related to accessing variable length structures.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3B","b":["300","200","215","310","315","320","215","210","310"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4A","b":["400","405","410","415","420","425","430","435","440","445","450","455","460","465","470","475","480"]},"SO  may operate as a sort of intermediary between the various file formats and provides a sort of common currency within a processing system between various entities, which otherwise communicate in a different language or format. SO  is amenable to serialization and conversion between some or all of the various file formats listed above, as well as others. Generic file CV  is included in  to illustrate that converters may be provided to convert SO  to a number of different file types beyond those illustrated in . For example, file  may represent a Java file or any other file type or format. In one embodiment, the converters are software modules that are generated and linked to endpoints (e.g., DB , CLI , network , file , C++ code , C# code , XML file , display , etc.) and may be invoked by SO  to read from or write to the selected endpoint.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4B","FIG. 4B"],"b":["490","492","494","496","490","492","496","494","496","490","496","494","490","490","492","496","496","494","490","492","496","494","492","490","490","492"]},"In one embodiment, converters may be used to perform software upgrades of serializable objects. The converters could be inserted in the execution runtime to perform \u201cin service software upgrades\u201d to translate the serializable objects between version v to version v. Updating an SO may include removing a field with the SO, rearranging the order of one or more fields, adding new fields, or changing the type of a field (i.e., translating the field from one basic type to another). As illustrated in , upgrades from version v to a version v may be implemented by linking or daisy chaining converters in series. In this manner, each software release need only create a converter for converting from the previous release.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5A","FIGS. 4A and 4B"],"b":["500","500","400","494","500","505","1","2","3","4","505","510","515","515","510"]},"One or more fields  may be marked with an index . Indexes  are substitute identifiers that may be used to reference the corresponding marked field . Indexes  enable SO  to write out subsets of its fields , through a converter, into any other form. In one embodiment, indexes  may either represent a primary index or a secondary index. A primary index  is an index  which may be used to uniquely identify SO  from all other SO's. Accordingly, the primary index marks a field  having a unique field value . In one embodiment, an index value of \u20181\u2019 is reserved for the primary index. The same index value may be used to mark multiple fields , as illustrated by index value \u20182\u2019 marking fields  and . By invoking index value \u20182\u2019, the field values  (e.g., VALUE_A and VALUE_B) corresponding to the fields  marked with an index  having an index value of \u20182\u2019 are referenced.","The to_struct method and the from_struct method may be invoked by SO  to convert itself into a fixed length, flat, contiguous memory structure or generate itself from a fixed length, flat, contiguous memory structure, respectively. These methods may be useful for manipulating flat contiguous memory structures in runtime layer  (see ), and particularly, for converting an SO in interface layer  or management layer  into flat structure  in runtime layer . The to_struct method enables a user to quickly push an SO down into runtime database . The to_struct method pre-allocates memory and defines how to map the complex linked memory structures of SO  into fixed length, flat, contiguous memory structures, which are amenable to high speed manipulation. The from_struct method may be invoked by a blank or empty SO to populate its fields  with data from a flat structure.","In one embodiment, fields  may include flags (not illustrated) for identifying each field  as \u201cset\u201d, \u201cunset\u201d, or \u201cmodified.\u201d When an object reads in an unset field  from source object, the reader will simply read in a default value for the unset field, as opposed to reading the unset field  from the source object. In contrast, the reader will actually read in field values  from a source object for fields  marked as \u201cset\u201d. The modified flag may be used to indicate whether or not a particular field  has been changed, whether or not it is set or unset. For example, a field  marked as \u201cunset\u201d and \u201cmodified\u201d indicates that a user has explicitly unset a field , as opposed to a field  that was initialized as \u201cunset\u201d with a default value.","In one embodiment, SO  may include a merger function to merger its field values  with the field values  from another SO. In this case, if a field  is flagged as \u201cmodified\u201d, then it field value  is retained, while fields  flagged as unmodified will retain existing values. In one embodiment, SO  may include a comparison function (e.g., diff_struct), which may be invoked to compare SO  against another SO. The output of the comparison function may be a bit field for each field , where a \u20181\u2019 represents \u201cis different\u201d and a \u20180\u2019 represents \u201cis same.\u201d",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 5B","b":["530","500","505","510","510","530","530","530","530"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 5C","FIGS. 4A and 4B"],"b":["540","540","405","420","430","460","455","465","480","470","540","550","530","1","2","555","530","1","2","540","515","510","500","540","505","505"]},"Operation of converter  to write from or read into SO  is now described with reference to , B, and C.  is a flow chart illustrating a process  for writing from SO , in accordance with an embodiment of the invention. In a process block , one or more fields within SO  are \u201cset\u201d or assigned specific field values . In a process block , the write method within SO  is invoked, which in turn will invoke converter  (process block ).","Once invoked, converter  will execute a corresponding one of its write methods on each set field  in SO . For example, if VAR_A was declared as basic type INT64 (i.e., 64 bit integer), then converter  will invoke WRITE BT(), corresponding to INT64 in table . Similarly, if VAR_B was declared as basic type BOOLEAN, then converter  will invoke WRITE BT(), corresponding to basic type BOOLEAN in table . Each write method  invoked by converter  will access the corresponding field , convert the contents of the field based on the converter type, and write out the converted field to the destination object\/file (process block ).","In one embodiment, specific fields  of SO  may be referenced to be written out by specifying corresponding indexes . For example, by invoking a write method, identifying a particular converter, and passing one or more index values to the write method, specified fields  may be written out from SO , while skipping others. In one embodiment, the default setting is writing out all fields  when a write method is invoked, without specifying index values. In one embodiment, all fields  may be written out by passing a default index number, such as \u20180\u2019.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 6B","b":["505","500","555","540","540","405","505","630","540","460","505","635","540","470","505","640"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6C","b":["650","500","515","500","500","655","660","540","500","655","500","550","540","515","550","540","500","505","520","500"]},"As discussed above, to translate SO  from interface layer  or management layer  to runtime layer , SO  may be converted into a flat structure using the to_struct method ( ). There may some scenarios where it may be desirable to store more than one type of SO into runtime database . This may be achieved using a concept referred as \u201cunion\u201d. From interface layer  or management layer  records may be passed down to runtime layer  that contain multiple types. For example,",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Foo",{}]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003Key","*key;"]},{"entry":[{},"\u2003\u2003\u2003Record","*data;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["MyRecord: public Record","{\n        \n        ","};","MyKey: public Key","{\n        \n        ","};\n\nSo, there could be MyKey, YourKey, HisKey, MyRecord, YourRecord, HisRecord, or the like. Therefore, the class Foo could be made up of any mixture of these types, since they inherit from Key and Record. This is referred to as \u201cpolymorphism.\u201d In order to translate Foo into runtime database , Foo is converted into a flat structure, which then gets stored into runtime database . This may be achieved by marking the class Foo with a special attribute, such as,\n"]}}}},{"@attributes":{"id":"p-0056","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Foo"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003[SOField(union=MyKey, YourKey, HisKey)]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003\u2003Key","*key;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003\u2003[SOField(union=MyRecord, YourRecord, HisRecord)]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003\u2003Record","*data;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0057","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class Foo"},{"entry":"{"},{"entry":"\u2003\u2003struct_type"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003enum which_t { MYKEY, YOURKEY, HISKEY };"},{"entry":"\u2003\u2003which_key_t isset;"},{"entry":"\u2003\u2003union _ul"},{"entry":"\u2003\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003MyKey::_type","mykey;"]},{"entry":["\u2003\u2003YourKey::_type","yourkey;"]},{"entry":["\u2003\u2003HisKey::_type","hiskey;"]},{"entry":"\u2003\u2003}"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003enum which_t { MYRECORD, YOURRECORD, HISRECORD };"},{"entry":"\u2003\u2003which_record_t isset1;"},{"entry":"\u2003\u2003union _u2"},{"entry":"\u2003\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003MyRecord::_type","myrecord;"]},{"entry":["\u2003\u2003YourRecord::_type","yourrecord;"]},{"entry":["\u2003\u2003HisRecord::_type","hisrecord;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003}"},{"entry":"\u2003};"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003Key","*key;"]},{"entry":["\u2003Record","*data;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"330"},{"@attributes":{"id":"p-0058","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Switch (which)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Key","*whichkey;"]},{"entry":[{},"\u2003\u2003case","MYKEY:"]},{"entry":[{},{},"Whichkey = new MyKey;"]},{"entry":[{},{},"Whichkey \u2212> fromstruct (_type::_ul::mykey);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003case YOURKEY:"]},{"entry":[{},"\u2003\u2003case HISKEY:"]},{"entry":[{},"}"]},{"entry":[{},"key = whichkey;."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["500","320","315","310","330"]},{"@attributes":{"id":"p-0059","num":"0066"},"figref":["FIGS. 7 and 8","FIG. 7","FIG. 8"],"b":["705","800"]},"In a process block , an empty SO  is created (illustrated in  by arrow ). An empty SO is a serializable object where none of the fields have been set or assigned field values. Empty SO  may be created by instantiating a new SO based on a class definition file . In a process block , one or more fields of empty SO  (e.g., fields ) are set or assigned field values (illustrated in  by arrow ) to create set SO . In the embodiment illustrated in , field  is set with a field value \u201cVALUE_A.\u201d In a process block , a GET command is issued on database  (illustrated in  by arrow ) to retrieve data from database . In one embodiment, the GET command may be invoked from interface layer  via the MLAPI.","In one embodiment, the GET command is passed set SO , a destination address or pointer  to a destination object to which database  should return the data, and one or more index values . The destination object may be set SO  itself, or some other object or file. Index value(s)  passed into the GET command indicates to database  which fields  of all the objects stored in database  it should inspect and attempt to match against the set fields of set SO . The set field value (e.g., VALUE_A) operates as the key for searching database  to find any SO stored therein having a field marked with an index value matching index value  (e.g., index 1) and having a corresponding field value matching field value VALUE_A. Accordingly, a user of database  can query database  using the data, itself, rather than using an extraneous or separate key. Furthermore, even though multiple fields of set SO  may be set with field values, by selecting different index values corresponding to different fields, a particular record (e.g., serializable object) stored in database  can be searched for using a variety of different data as the key. Fields  marked with the primary or secondary indexes provide search flexibility to the end user to query database  based on a variety of different subsets of the data\/fields within set SO .","For example, database  may store phone records that include the following three fields: a name field, a phone number field, and an address field. If the name fields are marked with index value 1, the phone number fields are marked with index value 2, and the address fields are marked with index value 3, then a user who wishes to determine the phone number associated with a particular name would set the first field with the name and pass the set SO to the GET command. Since the name field is marked with an index value 1, index value  would be passed as a \u20181\u2019 into the GET command. Of course, the user could also set the address field and\/or phone number field, pass the set SO to the GET command, and retrieve the corresponding name.","Returning to , in a process block , the one or more set fields marked with index value(s)  is\/are converted to flat contiguous memory structure(s)  by database CV . As illustrated, serializable objects that exist outside of database  may exist as link memory structures , which are serialized into flat contiguous memory structures  prior to passing into database . Although DB CV  is illustrated as external to database , it should be appreciated that DB CV  may in fact be an internal component to database . Once passed into database  by the GET command, a query is executed to determine whether a matching record index value\/field value pair exists (decision block ). If such a record is not found, then an empty set, null, or void response is returned to the destination object in a process block . If such a record is found, then process  continues to a process block .","In process block , the matching record (or records) is converted from a flat contiguous memory structure  into a more complex linked memory structure  by DB CV  and returned to the destination object (illustrated as set SO  in ). Finally, in a process block , the data from the matching record is written into the destination object to populate the empty fields of set SO  with field values from the matching record stored in database .",{"@attributes":{"id":"p-0065","num":"0072"},"figref":["FIGS. 9 and 10","FIG. 9","FIG. 10"],"b":["500","705","1000","1005","505","500","505","500","1010","405","1015","405","905","500","910","1020","910","705","1025","405","705","910","910","705"]},"In one embodiment, SO  may be written into database  by invoking the CREATE command published by the MLAPI into interface layer . In this embodiment, the CREATE command may be passed SO  and one or more index values to identify which fields  are to be written into database . In this manner, a subset of the data or fields  within SO  may be written into database .","In accordance with architecture aspects of some embodiments, the aforementioned functions may be facilitated by various processing and storage resources hosted by associated line cards and the like, which are mounted in a common chassis. As shown in , from a datapath perspective, the hardware architecture of one embodiment of network service node  can be decomposed into three entities, Traffic Blades (TB) , Compute Blades (CB)  and the chassis . A TB  can be further reduced to its physical and link layer portions  and , network layer components , and infrastructure components . Similarly, a CB  provides Service Layer termination  and infrastructure components . In one embodiment, a CB can be further re-defined to be an OAMP Blade based on its slot index (within chassis ). OAMP blades are a functional superset of CBs, adding operations, administration, maintenance, and provisioning functionality (collectively referred to as OAMP card function or OAMP CF).","As illustrated in the embodiments herein, chassis  comprises an Advanced Telecommunication and Computing Architecture (ATCA or AdvancedTCA\u00ae) chassis. The ATCA Chassis provides physical connectivity between the blades via a passive backplane  including a full-mesh interconnect . It is noted that the ATCA environment depicted herein is merely illustrative of one modular board environment in which the principles and teachings of the embodiments of the invention described herein may be applied. In general, similar configurations may be deployed for other standardized and proprietary board environments, including but not limited to blade server environments.","The ATCA 3.0 base specification (approved Dec. 30, 2002), which is being carried out by the PCI Industrial Computer Manufacturers Group (\u201cPICMG\u201d), defines the physical and electrical characteristics of an off-the-shelf, modular chassis based on switch fabric connections between hot-swappable blades. (As used herein, the terms \u201cboard,\u201d \u201cblade,\u201d and \u201ccard,\u201d are interchangeable.) This specification defines the frame (rack) and shelf (chassis) form factors, core backplane fabric connectivity, power, cooling, management interfaces, and the electromechanical specification of the ATCA-compliant boards. The electromechanical specification is based on the existing IEC60297 EuroCard form factor, and enables equipment from different vendors to be incorporated in a modular fashion with guaranteed interoperability. The ATCA 3.0 base specification also defines a power budget of 200 Watts (W) per board, enabling high performance servers with multi-processor architectures and multi gigabytes of on-board memory.","In addition to power input to ATCA boards, mating connectors on the boards and backplane are employed for coupling input\/output (I\/O) signals. Many of the ATCA boards, as well as other modular boards used for telecommunications and computer, such as but not limited to CompactPCI, employ very-high speed I\/O channels. For example, Advanced Switching (\u201cAS\u201d) employs a serial communication channel operating at Gigahertz+ frequencies. ATCA boards may also provide one or more I\/O ports on their front panels, enabling an ATCA board to be coupled to other network resources.","An exemplary architecture  for a compute blade  is shown in . In one embodiment, a single compute blade (physical) architecture is employed for both Compute Blades and OAMP CF's. More particularly, under architecture , a corresponding blade may be deployed to support both Compute Blade and OAMP functionality.","Compute Blade  employs four multiple processor compute nodes . In general, each of compute nodes functions as multiple processor resources, with each processor resource being associated with a logical processor. Accordingly, such processor resources may be implemented using separate processors, or processor chips employing multiple processor cores. For example, in the illustrated embodiment of , each of compute nodes is implemented via an associated symmetric multi-core processor. Exemplary multi-core processors that may be implemented include, but are not limited to Broadcom  and  devices. Each of the compute nodes is enabled to communicate with other compute nodes via an appropriate interface (e.g., bus or serial-based interfaces). For the Broadcom  and  devices, this interface comprises a \u201cHyper Transport\u201d (HT) interface. Other native (standard or proprietary) interfaces between processors may also be employed.","As further depicted in architecture , each compute nodes is allocated various memory resources, including respective RAM . Under various implementations, each of compute nodes may also be allocated an external cache , or may provide one or more levels of cache on-chip. In one embodiment, the RAM comprises ECC (Error Correction Code) RAM. In one embodiment, each compute node employs a NUMA (Non-Uniform Memory Access) cache coherency scheme. Other cache coherency schemes, such as MESI (Modified, Exclusive, Shared, Invalidated), may also be implemented for other embodiments.","Each Compute Blade  includes a means for interfacing with ATCA mesh interconnect . In the illustrated embodiment of , this is facilitated by a Backplane Fabric Switch . Meanwhile, a field programmable gate array (\u201cFPGA\u201d)  containing appropriate programmed logic is used as an intermediary component to enable each of compute nodes to access backplane fabric switch  using native interfaces for each of the compute nodes and the fabric switch. In the illustrated embodiment, the interface between each of compute nodes and the FPGA  comprises an SPI (System Packet Interface) 4.2 interface, while the interface between the FPGA and backplane fabric switch  comprises a Broadcom HiGig\u2122 interface. It is noted that these interfaces are merely exemplary, and that other interface may be employed depending on the native interfaces of the various blade components.","In addition to local RAM (e.g., RAM ), the compute node associated with the OAMP function (depicted in  as Compute Node #) is provided with local SRAM  and a non-volatile store (depicted as Compact flash ). The non-volatile store is used to store persistent data used for the OAMP function, such as provisioning information and logs. In Compute Blades that do not support the OAMP function, each compute node is provided with local RAM and a local cache.","In the embodiment illustrated in , compute blade  is provisioned as an OAMP blade. In one configuration (as shown), one of the compute nodes is employed for performing OAMP functions (e.g., compute node ), while the other three compute nodes (e.g., compute nodes ) perform normal compute functions associated with compute blades, as described in further detail below. When a compute blade  is provisioned as a compute blade, each of compute nodes is available for performing the compute functions described herein.",{"@attributes":{"id":"p-0077","num":"0084"},"figref":"FIG. 13","b":["1300","210","1300","1302","1304","1306","1308","1310","1312","1314","1316","1318","1319","1320","1320"]},"PHY block  and Ethernet MAC block  respectively perform layer  (Physical) and layer  (Data Link) functions, which are well-known in the art. In general, the PHY and Ethernet MAC functions may be implemented in hardware via separate components or a single component, or may be implemented in a combination of hardware and software via an embedded processor or the like.","One of the operations performed by a traffic blade is packet identification\/classification. As discussed above, a multi-level classification hierarchy scheme is implemented for this purpose. Typically, a first level of classification, such as a 5-Tuple signature classification scheme, is performed by the traffic blade's NPU . Additional classification operations in the classification hierarchy may be required to fully classify a packet (e.g., identify an application flow type). In general, these higher-level classification operations may be performed by the traffic blade's host processor  and\/or a processor on a compute blade, depending on the particular classification.","NPU  includes various interfaces for communicating with other board components. These include an Ethernet MAC interface, a memory controller (not shown) to access RAM , Ethernet and PCI interfaces to communicate with host processor , and an XGMII interface. SERDES interface  provides the interface between XGMII interface signals and HiGig signals, thus enabling NPU  to communicate with backplane fabric switch . NPU  may also provide additional interfaces to interface with other components, such as an SRAM (Static Random Access Memory) interface unit to interface with off-chip SRAM (both not shown).","Similarly, host processor  includes various interfaces for communicating with other board components. These include the aforementioned Ethernet and PCI interfaces to communicate with NPU , a memory controller (on-chip or off-chip\u2014not shown) to access RAM , and a pair of SPI 4.2 interfaces. FPGA  is employed to as an interface between the SPI 4.2 interface signals and the HiGig interface signals.","Typically, NPUs are designed for performing particular tasks in a very efficient manner. These tasks include packet forwarding and packet classification, among other tasks related to packet processing. To support such functionality, NPU  executes corresponding NPU software . This software is shown in dashed outline to indicate that the software may be stored (persist) on a given traffic blade (e.g., in a flash device or the like), or may be downloaded from an external (to the traffic blade) store during initialization operations, as described below. During run-time execution, NPU software  is loaded into internal SRAM  provided by NPU .","Host processor  is employed for various purposes, including lower-level (in the hierarchy) packet classification, gathering and correlation of flow statistics, and application of traffic profiles. Host processor  may also be employed for other purposes. In general, host processor  will comprise a general-purpose processor or the like, and may include one or more compute cores (as illustrated, in one embodiment a two-core processor is used). As with NPU , the functionality performed by host processor is effected via execution of corresponding software (e.g., machine code and or virtual machine byte code), which is depicted as host software . As before, this software may already reside on a traffic blade, or be loaded during blade initialization.","In one embodiment, host processor  is responsible for initializing and configuring NPU . Under one initialization scheme, host processor  performs network booting via the DHCP (or BOOTP) protocol. During the network boot process, an operating system is loaded into RAM  and is booted. The host processor then configures and initializes NPU  via the PCI interface. Once initialized, NPU  may execute NPU software  on a run-time basis, without the need or use of an operating system.","The processes explained above are described in terms of computer software and hardware. The techniques described may constitute machine-executable instructions embodied within a machine (e.g., computer) readable medium, that when executed by a machine will cause the machine to perform the operations described. Additionally, the processes may be embodied within hardware, such as an application specific integrated circuit (\u201cASIC\u201d) or the like.","A machine-accessible medium includes any mechanism that provides (i.e., stores) information in a form accessible by a machine (e.g., a computer, network device, personal digital assistant, manufacturing tool, any device with a set of one or more processors, etc.). For example, a machine-accessible medium includes recordable\/non-recordable media (e.g., read only memory (ROM), random access memory (RAM), magnetic disk storage media, optical storage media, flash memory devices, etc.).","The above description of illustrated embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize.","These modifications can be made to the invention in light of the above detailed description. The terms used in the following claims should not be construed to limit the invention to the specific embodiments disclosed in the specification. Rather, the scope of the invention is to be determined entirely by the following claims, which are to be construed in accordance with established doctrines of claim interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments of the invention are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
