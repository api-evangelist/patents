---
title: Methods and systems for navigating deterministically through a graphical user interface
abstract: Disclosed is a mechanism for systematically invoking executable features of a software application via its graphical user interface. Also disclosed is a mechanism for generating a map that characterizes operational states of an application as it executes. An application driver selects an action to be performed by the application according to a deterministic mode such as depth-first mode or breadth-first mode. In the depth-first mode of deterministic operation, an action associated with a particular element is explored as deeply as possible, while breadth-first mode explores the application as widely as possible. For each executable feature invoked within the software application, the states encountered during execution are stored within the application map for subsequent retrieval and analysis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07290245&OS=07290245&RS=07290245
owner: Microsoft Corporation
number: 07290245
owner_city: Redmond
owner_country: US
publication_date: 20011018
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates generally to automated software test systems, and particularly, to an automated software test system that systematically invokes executable features presented to a user via a graphical user interface.","Today's software products are increasingly complex, often capable of performing numerous tasks simultaneously and operating upon multiple platforms and operating systems. In addition, many software products in use today are graphics intensive and employ graphical user interfaces (GUIs) that correlate graphics elements (e.g., buttons, dialog boxes, menus) to the executable features of the products. This allows a user to easily navigate through an application to perform a desired task. Invariably, to ensure the reliability of software products, comprehensive testing and debugging are key components to the software development process. In general, software testing and debugging are the processes of identifying and correcting programmatic or operational defects within a software product.","Many defects that occur within a software product are not fully exposed until the application is actually in execution, referred to as being \u201cin a runtime state.\u201d For example, a newly developed application may stall or produce an error message when its user selects a certain button or menu from a GUI during runtime. Other common errors that occur within GUI-based applications are visual defects, such as text truncation and spelling errors. Such errors occur even more frequently in software products that have been \u201clocalized.\u201d Software is localized when it has been translated or adapted from its original language to a new language to accommodate new users. Oftentimes, in adapting the software to the new language, one or more text strings are left untranslated. To identify these errors prior to deployment into the intended market, the functions and features of the product should be tested exhaustibly during runtime.","One method of testing the features of an application is to employ an automated test application, commonly referred to as a \u201cmonkey\u201d. Monkeys are executable applications that contain instructions for automatically exercising, or invoking, the features of an application under test. Monkeys allow executable states, or actions, of the application to be exposed during runtime and subsequently verified for proper operation by the tester. For example, a monkey can be used to automatically activate menus, buttons, dialog boxes, and other graphics elements that represent the features of a typical GUI-based application as it executes. In operation, the monkey randomly selects an action or graphics element from within the GUI\u2014perhaps the \u201cFile\u201d button\u2014resulting in a drop down menu of other user options (e.g., New, Open, Exit) being displayed to the screen. This random selection of actions or graphics elements is continued until the software tester terminates the process manually or until the monkey encounters an un-recoverable system or programming error (e.g., invalid command, system crash).","The monkey is a \u201cdumb\u201d test, meaning it has no model or understanding of the software under test. It simply activates any executable action or graphics element within the software package without regard to the operation underlying the action or graphics element. This characteristic makes monkeys cheap to design and easy to program, as they need not be customized to fit the application under test. Also, the relative ease of designing test monkeys makes them particularly useful during the early stages of testing, where most defects or errors are found. Furthermore, by automating the GUI-testing process, the software tester does not have to manually invoke each of the actions and graphics elements that make up the application. This reduces the time required for testing user interface features and eliminates any human error that could result from manual execution. All of these features are particularly useful in the testing of graphics-oriented software packages having several executable features and options.","Monkeys, however, are not without some inherent limitations. Because conventional monkeys and other automated testing techniques perform random acts upon the software, unnecessary test repetition can occur. This results in significant time being consumed in order to fully exercise an application under test. Even further, repetition compounds the cost of testing a product, especially those products having several features and associated graphics elements that are accessible from a GUI. Typically, monkey tests must run for several days at a time in order to fully explore the GUI of a software product. Obviously, this hinders the timeliness of product development and deployment processes.","As another drawback, random execution of the GUI of a software application does not promote a structured, sequential approach to testing, an approach often required to identify the source of bugs. For example, a dialog box displayed by the user interface may consist of various graphics elements including text, a button, and a list box. Activation of the button can result in the display of an entirely new dialog box by the user interface, representing an entirely new state of the application. In order to identify errors that occur as a result of transitioning between states, or to identify the graphics element or actions that correspond to a particular error, the software tester must know the relationship between various states. Unfortunately, this relationship cannot be easily established when executing test monkeys, as actions can be executed in a non-sequential (random) order. Monkey testing, while automatic, is not systematic in its approach to exercising the features of an application.","To overcome the limitations described above, a way is needed to exercise a GUI of an application quickly and systematically, such that the time and cost associated with debugging and testing are minimized. Furthermore, a way is needed to record, or map, the various states of the software as it executes so that relationships between graphics elements and actions of the application can be easily determined.","The present invention presents a mechanism for systematically exploring a graphical user interface (GUI). Moreover, the invention presents a method for generating a map that characterizes the operational states of an application as it executes. The invention can be applied to any software application that employs a graphical user interface to expose executable features of the application to a user.","In accordance with the present invention, a computer-executable application driver scans a GUI of an application to be explored for information related to its graphics elements. This results in the acquisition of information related to top-level graphics elements of the GUI. These elements characterize the initial state of the application. From this information, the application driver chooses one of the top-level elements and then chooses an action to perform on that element. The application driver records each state it encounters and each action it performs. For example, the application driver records its encounter with a particular state, such as the presentation of a particular dialog box, and records that it activated a button within the dialog box. The next time the same dialog box is encountered, the application driver may choose the same button but may select a different action to be performed. In a preferred embodiment, it will continue to select this button each time it encounters the dialog box until all actions associated with the button have been performed. Whenever an action is performed, the record of elements and associated actions is updated.","To ensure that the application driver invokes all of the actions associated with the GUI, the driver may explore the application in depth-first mode or breadth-first mode. In depth-first mode, an action associated with a particular element is explored as deeply as possible before moving on to another action. In breadth-first mode, the application driver explores all actions before probing the depth of any one action. To illustrate the difference, an application's interface can be thought of as a tree of UI elements and actions. At the top of the tree is the main window, and it has a set of children that are the top-level elements, for example menu items File, Edit, and Help. In turn, the File menu has children New, Open, and Exit. In depth-first mode, the application driver first chooses File, then New, and then fully explores New's subsequent dialog. Next, the driver explores File\/Open, then File\/Exit before returning to the Edit Menu. In breadth-first mode, the application driver first chooses File, then Edit, etc.","Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments that proceeds with reference to the accompanying figures.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer. Generally, program modules include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","The invention is described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains them at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data are maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in such a context, it is not meant to be limiting as those of skill in the art will appreciate that the various acts and operations described hereinafter may also be implemented in hardware.","Before describing the invention in detail, the computing environment in which the invention operates is described in connection with . Although the invention may be incorporated into many types of computing environments as suggested above, the following detailed description of the invention is set forth in the context of an exemplary general-purpose computing device in the form of a conventional PC.","Exemplary Computing Environment",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","100","100","100"]},"The computing system environment  includes a general-purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus, also known as Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by computer  and include both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media include, but are not limited to, random-access memory (RAM), read-only memory (ROM), EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVDs) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium that can be used to store desired information that can be accessed by computer . Communication media typically embody computer-readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information-delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired media such as a wired network or direct-wired connection and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile or nonvolatile memory such as read-only memory  and random-access memory . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and program modules that are immediately accessible to or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system (OS) , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer-readable instructions, data structures, program modules, and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball, or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user-input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device, or other common network node and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN-networking environment, the personal computer  is connected to the LAN  through a network interface or adapter . When used in a WAN-networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Navigating Deterministically Through a GUI","The present invention provides a systematic approach to exploring features of a GUI of a software application. By exploring the GUI systematically rather than randomly, test repetition is eliminated. Furthermore, the invention provides a mechanism for mapping information related to states of the software application as they are explored. A software tester can retrieve this information for subsequent use or analysis. This is advantageous to software testers, as hand-drawn process charts and flow diagrams, often prone to human error, need not be relied upon for testing the accuracy of the software application. The features of the invention will be described in greater detail in later sections of the detailed description. For now, an example of a software application employing a GUI is provided in .","As illustrated in the figure, the GUI  for a \u201ctarget application\u201d comprises several graphics elements, e.g.,  and  that represent executable features of the application. A graphics element is any object that can be rendered to a user interface screen (monitor)  by a software application executing upon a computer . Graphics elements include computer-implemented objects that display lines, text, images, and other graphics primitives to the GUI. These include, but are not limited to, control and dialogue boxes, functional buttons, menu screens, combo boxes, and any graphics windows that are capable of being executed or invoked by an application run by the operating system .","A \u201ctarget application\u201d is a process, executable procedure, or application that operates according to methods and functions defined by the operating system . By working in conjunction with the operating system , a user of the computer  is able to access features of the application via the application's GUI. A target application can be stored in system memory  as an application program  or can be retrieved and executed from external memory devices such as the system hard drive , floppy disk , or CD-ROM . The target application is responsible for generating its GUI .","As shown in the GUI  of the target application in , a dialog box  is spawned as a result of an invoked action, such as clicking one of the menu items  with the mouse . The mouse pointer  indicates the location of the mouse in relation to the GUI . The dialogue box  consists of three user-option buttons , which can be activated with the mouse pointer  to provide a logical response to the action of the dialogue box . All of the buttons  and the associated text field  are child controls of the dialogue box . A child control, or child object, is a graphics element initiated by a parent object. Each object has its own handle, which is a unique identification number assigned by the operating system  to distinguish one object from another. The handles of display objects are stored in a resource file (*.res) associated with an executable application. The handle of each of the children is inherited directly from the parent object.","In , the action of the dialogue box  is to assess a user's desire to become debt free and financially independent. Based on the user's selection of one of the buttons , another action (e.g., a new dialog box or execution of code) is invoked within the target application. For practically every action performed or invoked within the target application, a state transition occurs. The term \u201cstate\u201d refers to a distinct mode of operation, or the current status, of a program in execution by the computer . More specifically, the state of an application refers to a unique set of graphics elements, content, and associated actions. For example, the current state of a dialog box displayed to the GUI is defined by the buttons it consists of, the positions and appearance of the buttons, and the text that is displayed. If an action is invoked within the dialog (e.g., by clicking a button with the mouse ), then a state transition within the dialog may occur. This is manifested as a change in the appearance of the dialog, such as by a color change or a text modification. From a broader perspective, a state transition can also relate to a change in the particular mode of operation of the software application. For instance, a word processing application may be capable of operating in a text-editing mode and a Web-publishing mode. Each of these modes represents a different state of the application. The current state of the software as illustrated in  is defined by the composition of graphics elements , , and associated actions (\u201cYes,\u201d \u201cNo,\u201d \u201cCancel\u201d) that are exposed by the dialogue box .","Turning now to , an example of a state transition within the dialogue box  is shown. In this example, a state transition occurs as a result of placing the mouse pointer  over the user button . This type of action, where the mouse pointer affects a graphics element without actually clicking the element, is referred to as a \u201cmouse over.\u201d As a result, the appearance of the button changes (\u201cYes\u201d is embellished with an oval outline). While this is only a subtle change in the appearance of the GUI, it nonetheless represents a change in the state of operation of the target application. In accordance with the methods of the operating system, this state is defined by its own unique identifier number and other properties that distinguish it from the state shown in .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4","b":["300","308","300","308","300","300","300","306","300","308","300","306","300","308"]},"In order to interpret the contents (graphics elements) of a GUI and to invoke the actions associated with each of the graphics elements, the application driver  relies upon a capture agent  and a command agent , respectively. As illustrated in , the application driver  communicates with, or polls, the capture agent  to retrieve information descriptive of the current state of the target application . The information retrieved by the capture agent  includes the types of the graphics elements currently displayed by the UI, any captions contained within a particular graphics element and their order of appearance, the element identifier number assigned by the OS  or target application , the type of action (e.g., a button click) that resulted in the current state of the target application , and any other properties of the GUI and target application. Those skilled in the art will appreciate that the invention is not limited to any particular information, as any data exposed by the graphical user interface are retrievable.","There are various methods for retrieving information descriptive of the properties and underlying actions of the GUI that can be employed by the capture agent . One such method is to access the resource (*.res) files related to the GUI of the target application . In MICROSOFT \u201cWINDOWS\u201d-based applications, for example, graphics primitives are stored in a resource file associated with the target application 's executable (*.exe). Resource files are text-based computer files that indicate the resources required for the application to run successfully and can be viewed with a standard resource editor\/viewer tool. Resource files are converted into a binary representation at compile time and then merged into the executable image of the application. The resources indicated by the resource file are extracted from the executable at runtime to be presented to the user as menus, dialog boxes, cursors, icons, toolbars, bitmaps, and other graphics elements composed of one or more graphics primitives. The resources specified in the resource file can be accessed by the capture agent  to obtain information about the properties of the graphics elements that make up the GUI of the target application.","The capture agent  can retrieve information pertaining to the state of the target application  by using standard hook functions and system patches to spy on the target application as it executes. For example, the capture agent  can inject a spy DLL (Dynamic Link Library) into the executable code of the target application . A DLL is a module of executable code that is activated upon the request of a specific application or of the operating system. Once the spy DLL is injected, it installs patches and hook functions into the operating system APIs (Application Programming Interfaces) that have routines for rendering graphics elements of the target application's GUI. The hook functions monitor the operating system messages generated during the execution of the target application, while the patches allow for the capture of graphics elements and associated actions that are drawn to the user interface. Because the graphics elements are captured in connection with the operating system messages passed during runtime, the capture agent  obtains complete information about the current state of the target application . Developers of software applications frequently use mechanisms such as spy DLLs, patches, and hook functions to observe the internal state of an application as it executes. Other techniques for retrieving information pertaining to the state of the target application  as exposed by the GUI may also be employed.","Another component relied upon by the application driver , specifically for invoking the underlying action associated with a graphics element in the GUI of the target application , is the command agent . The command agent is an executable component that is capable of calling the necessary API routines, OS mechanisms, and target application processes that result in the execution of particular actions. For example, the primary API for WINDOWS, known as Win32, provides a complete set of functions to format and draw text primitives to a target application 's GUI. These functions, such as CreateWindow, MoveWindow, andSetWindowText, affect the display and appearance of popup windows and corresponding text. Within the WINDOWS environment, the command agent  calls these functions to render the appropriate output to the display. Further, the command agent  invokes specific executable code and processes that allow for the importation and exportation of data, start and stop of specific tasks, storage of information, and all other features of the application that are correlated with the GUI.","The application driver , capture agent , and command agent  all interact with one another to provide the necessary functions required to carry out the methods of the invention. Functionally, these components may be implemented as hardware or firmware components capable of processing machine language instructions for performing the actions described in the foregoing paragraphs. Likewise, each of the components can be implemented as software in the form of DLLs, executable program modules, command scripts, or any computer-executable routines or instructions that are developed according to a specific command language such as C\/C++, Java, etc.","The flowchart of  further describes the interactions that take place between the components for performing the methods of the invention. In order to direct the execution of the target application , the application driver  sends a request for the capture agent  (event ) to retrieve information pertaining to the current state of the application. In response to this request, the capture agent  interprets the contents of the graphical user interface rendered by the target application  and extracts specific information such as the element types presented and their associated actions, specific text strings displayed, unique element identifier numbers (e.g., software handles), and other properties that define the GUI. The capture agent  then returns this information to the application driver . The application driver  arranges and records this information in a logical format as an application map  (event ). The application map is a file wherein the information retrieved by the capture agent  can be formatted, stored, and retrieved for subsequent analysis.  and the accompanying text discuss one possible data storage scheme for the application map.","Once the information is retrieved and stored in the application map  by the application driver , the application driver  selects an element and corresponding action from the map to be invoked (event ). Upon selecting an action to execute, the application driver communicates with the command agent  to fulfill the request by invoking the particular action. The sequence in which the application driver invokes actions within the target application  is determined according to one of several possible \u201cdeterministic\u201d modes. Deterministic operation ensures a systematic approach to driving the execution of the target application . This is in contrast to conventional mechanisms for executing the features of a software application where random execution of events is the norm.","Described here are the breadth-first or depth-first deterministic modes of operation. In the breadth-first mode of operation, actions at higher levels of the target application's hierarchy of execution are invoked first, while subsequent levels of the hierarchy are performed last. This means that actions are invoked across similar levels of the application first. In the depth-first mode of operation, actions at successively lower levels of the target application's hierarchy of execution are invoked first until no lower-order levels are available. This means that actions are invoked at deep levels of the application first.  illustrates the difference between these two modes of operation. A target application  can be depicted as a hierarchical tree  of graphics elements and actions. At the top of the tree  is the main window of the target application . At the next level are the children of the main window, here the top-level menus File , Edit , and soon on to Help . In turn, the File menu has children at the next level of the hierarchy, namely New , Open , and Exit . In the breadth-first mode of operation, the application driver  first executes File , then Edit , and fully across Level 1 of the hierarchy through Help . In depth-first mode, the application driver  first chooses File  at Level 1, then New  at Level 2, and then fully explores the subsequent dialog. The execution of the application is driven until the deepest hierarchy level for New , Level N, is reached. Then File\/Open  is fully explored, and then the other children of File. Only then does the application driver  return to execute the Edit menu  at Level 1.","Returning now to , the command agent  executes the actions in the deterministic order set by the application driver  (events  or ). The resultant action potentially leads the target application  to enter a new state, in which case more actions are available for execution, and the steps are repeated. For each new state exposed within the target application  as a consequence of the directed execution by the application driver , the resulting graphics elements are recorded into the application map  (events  and ). This process is repeated until no more actions are available for execution.","In addition to storing GUI- and operating state-specific information within the application map , the application driver  maintains an indicator (e.g., counter) for each state encountered during execution of the target application . These indicators are stored in the application map for every state and state edge encountered, providing an indication of the number of times each state and edge has been visited. A state edge is a state and an associated path to another operational state. As the map is built, the indicator is updated accordingly. Using the indicator in conjunction with the elements and actions contained within the map, the application driver is able to determine systematically the next action to invoke. For instance, in  a dialog box  consisting of three user buttons  and a text field  is shown. The composition, arrangements, and associated actions of these graphics elements define the current state of the dialog box . Until one of the buttons is invoked, the indicator related to each button specifies that no associated actions have been activated (note here that each button represents a state edge\u2014the action of the button may be a path to another state, such as a different dialog box). If the \u201cCancel\u201d button is invoked, the indicator for this button is updated, and the dialog box is closed. Because the indicators for the other buttons of the dialog box  are not yet set (e.g., incrementing a counter, activating a flag), the application driver knows that these buttons have yet to be executed. Thus, the application driver can execute these features the next time this dialog box is encountered.","The process of continually updating the application map  allows the sequential execution of the software program  to be recorded dynamically. Furthermore, by updating the state and edge indicators, the various state transitions, edges, and subsequent actions related to each state can be tracked throughout execution. This is significant particularly in software testing where access to such information is not often readily available, short of hand-drawn software trees or process diagrams. Bugs and code defects occurring at specific locations, or levels, of the target application can be easily identified and even re-invoked by the application driver  by simply returning to the applicable point of execution within the application map , and recalling the subsequent action using the command agent .","To provide further details of the construction and format of the application map , an example data structure is presented in . In lines -, an element (e.g., a graphics element) is defined as having various properties, including a resource identifier value  and an order of appearance within the interface . Events are defined with relation to the execution of the application. For instance, the application map stores information pertaining to the appearance of the GUI and its associated graphics elements prior to and after a state transition occurs. Categorizing events in this way allows a client, such as a software tester, to refer to the state of the target application at a specific period of execution. The application map also defines element types  and action types  related to the software application. Access to such information is necessary for the application driver  so that it may direct the execution of the target application . Please note that in this example, the contents of the application map are arranged in XML (Extensible Markup Language) format. However, this is only one example of a suitable content model for representing the application map . In particular, the information can be formatted according to data representations such as XML, SGML, HTML, or XHTML. Indeed, any language wherein data are logically formatted for later interpretation by a user or machine-executable program is suitable for the present invention. As such, the model provided in  is not to be misconstrued as limiting the scope or nature of the invention, as there exist numerous formats for storing and arranging data. The invention contemplates the usage of all such data storage, data modeling, and representation schemes.","The invention as described herein can be incorporated into the source code of an existing application such as a software-testing program or executed as a stand-alone mechanism for driving the execution of a target application. For instance, the application driver  and application map  can be implemented as separable modules of varying functionality or incorporated in their entirety into the executable code of another application. Also, the application driver  can be used in conjunction with any data retrieval and modeling mechanisms, as well as code-execution mechanisms, to carry out the methods of the invention. No code modifications need to be made to the application under test in order to employ the methods of the invention.","All of the references cited herein, including patents, patent applications, and publications, are hereby incorporated in their entireties by reference. In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example, those having skill in the art will recognize that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa or that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
