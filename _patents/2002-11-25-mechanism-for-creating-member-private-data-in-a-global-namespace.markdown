---
title: Mechanism for creating member private data in a global namespace
abstract: A system and techniques are described for creating member private data in a global namespace. According to one aspect, first data that is associated with a key is stored in a repository shared by multiple members. After the first data has been stored, second data that is associated with the key is stored without overwriting the first data. Mapping data is stored. The mapping data maps the key, relative to a first member, to a first data structure that stores the first data. The mapping data also maps the key, relative to a second member, to a second data structure that stores the second data. Based on the mapping data, the first member is allowed to access the first data and not the said second data. Based on the mapping data, the second member is allowed to access the second data and not the first data. The first data and the second data may include key values and subtrees of child keys.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07672945&OS=07672945&RS=07672945
owner: Oracle International Corporation
number: 07672945
owner_city: Redwood Shores
owner_country: US
publication_date: 20021125
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","Hierarchical Data Model","Example System that Uses Hierarchical Data","DETAILED DESCRIPTION OF THE INVENTION","Functional Overview","The Registry Pages","Example Tree Structure","The T-Nodes","Using Indirection to Store Values and Key Component Entries","Using a Slotted Page Structure to Store Key Component Entries","Member-Dependent Keys","The Member-Dependent Key Map","Creating a Key","Finding a Key Component Entry in a T-Node","Creating a New Key Component Entry in a T-Node","Deleting a Key Component Entry from a T-Node","Finding a T-Node in which a Key Component Entry for a Key Exists","Setting a Value of an Empty T-Node","Modifying the Value of a T-Node","Opening a Key","Reading the Value of a Key","Creating a Key and Setting the Value of the Key","Creating a Link","Creating a Member-Dependent Key","Setting a Security Attribute of a Key","Setting a Value of a Key","Deleting a Value of a Key","Deleting a Key","Converting a Normal Key to a Member-Dependent Key","Converting a Member Dependent Key to a Normal Key","Creating Member Private Data in a Global Namespace","Hardware Overview"],"p":["The present application claims priority to the following provisional U.S. Patent Applications:","U.S. Provisional Patent Application No. 60\/370,963 entitled \u201cPersonalized Content Within a Global Namespace\u201d, filed Apr. 8, 2002, which application is incorporated by reference herein; and","U.S. Provisional Patent Application No. 60\/372,186 entitled \u201cApproach for Personalized Content Within a Global Namespace\u201d, filed Apr. 12, 2002.","The present application is also related to the following non-provisional U.S. Patent Applications, the entire contents of which are incorporated herein for all purposes:","U.S. patent application Ser. No. 10\/232,907 entitled \u201cUse of Dynamic Hash Tree for Managing Hierarchically Structured Information\u201d filed on Aug. 30, 2002 by Surojit Chatterjee and Sameer Joshi;","U.S. patent application Ser. No. 10\/253,088 entitled \u201cPersistent Key-Value Repository with a Pluggable Architecture to Abstract Physical Storage\u201d filed on Sep. 23, 2002 by Surojit Chatterjee, Raj Kumar, Jonathan Creighton, Alok K. Srivastava, and Sameer Joshi.","The present invention relates to data storage and, more specifically, to storing hierarchical data on a persistent storage device.","A data model provides the general structure of a database. A data model can be viewed as a collection of conceptual tools for describing data, data relationships, data semantics, and consistency constraints.","It is often useful to model data in a hierarchical structure. In a hierarchical model, data and relationships among data are represented by records and links, respectively. Hierarchically modeled data is logically structured as a \u201ctree\u201d, which includes a conglomeration of parent-child relationships between data within the hierarchical structure. LDAP (Lightweight Directory Access Protocol), Microsoft\u00ae Windows\u00ae registry hierarchical structure, and Oracle\u00ae Cluster Registry hierarchical structure are examples of uses of hierarchically modeled or structured information.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},"Hierarchically organized data is generally represented by a key name-value (or name-value) pair. More specifically, each item of information is identified within the hierarchy by a key name consisting of key components. The term \u201ckey name\u201d is generally used herein to refer to a specific value within the key domain associated with the hierarchy. For example, a key domain may be network IP addresses and an associated key name may be 255.255.000.000. For another example, a domain may be the collection of URLs associated with the public Internet, and an associated key of the domain may be a specific URL associated with a specific web page.","For example, a file's location in a hierarchical directory may be identified as: C:\\My Documents\\example.doc, wherein each backslash separates levels of the associated hierarchy. More generally, information may be identified by a key name represented as a character string, such as a.b.d.e, where key component e is a child (i.e., a descendant) of key component d, key component d is a child of key component b, and so on, to the hierarchy root. In some contexts, hierarchically organized information contains name-value pairs. A value is information associated with a name. For example, in the foregoing hierarchical directory path, \u201cMy Documents\\example.doc\u201d is a name of a name-value pair. The content of this file is the value of the name-value pair.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":["1","3"]},"A distributed system may include multiple logical computational units. Each logical computational unit may be referred to as a \u201cmember\u201d of the distributed system. Thus, a member may be a network-connected personal computer, workstation, central processing unit (CPU), or other logical computational unit such as an instance of a program. Members of a distributed system can communicate with each other.","Multiple members of a distributed system may share a common entity. One such shared entity is a shared file system. All of the members in the distributed system may directly access the shared file system (e.g., through a network). All of the members in the distributed system can see a given file within the shared file system. All of the members within the distributed system may access the contents of the given file. In other words, the data that is contained in the file is \u201cpublic\u201d or \u201cglobal\u201d to all members and not \u201cprivate\u201d to any particular member.","It is common for one member of a distributed system to be one instance of a particular computer program, and for another member of the distributed system to be another instance of the same computer program. Each member of a distributed system may be a different instance of the computer program. Each instance may be able to communicate with each other instance. The particular computer program may be, for example, a database server. The particular computer program may execute, for example, in the form of multiple concurrent processes.","All instances of the particular computer program may attempt to read or write to a same particular file (such as a configuration file) in the shared file system. The particular computer program might not have been designed to operate in a shared file system. Therefore, by overwriting a value in the particular file, one instance of the particular program may cause the other instance of the computer program to subsequently read an incorrect value. Such data conflicts constitute a problem.","This problem particularly impacts registries. A registry is a data repository that stores configuration information. A single registry may store configuration information for multiple databases that are stored on a single shared storage subsystem. A registry may organize data according to the hierarchical data model described above. Configuration information for multiple databases may be hierarchically organized beneath a single root.","One example of a multi-instance database server is RAC, which can have multiple instances of the same program running as multiple members of a distributed system. To communicate with each other, each of these instances listen to specific ports for communicating with each other. For example, a key like \u201cRAC.instancename\u201d could be created in a shared (between all the instances of RAC) configuration repository such as a registry. Each instance of RAC stores its name as a value of the key \u201cRAC.instancename\u201d. Consequently, every time, after the first time, that an instance of RAC stores its name as a value of this key, the previous value of this key will be overwritten. This results in a data conflict.","Many applications require that the multiple members of a distributed system (such as instances of the same computer program) refer to a piece of data in the global repository by the same name but read or write a value that is specific for each instance.","Computer programs, such as database servers, may be modified to access separate instances of files (or registry entries) in a shared file system (or registry). However, such modification is impossible when source code is unavailable. Even when source code is available, source code modification is time-consuming and expensive. Often times it is not desirable.","A method and system for creating member private data in a global namespace is described. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","Techniques are disclosed for creating member private data in a global namespace. First data that is associated with a key is stored in a repository that is shared by multiple members of a distributed system. After the first data has been stored, second data that is associated with the key is stored without overwriting the first data. Mapping data is stored. The mapping data maps the key, relative to a first member of the distributed system, to a first data structure that stores the first data. The mapping data also maps the key, relative to a second member of the distributed system, to a second data structure that stores the second data. Based on the mapping data, the first member is allowed to access the first data and not the second data. Based on the mapping data, the second member is allowed to access the second data and not the first data. The first data and the second data may include key values and subtrees of child keys. While reference is made above to first and second members, the techniques disclosed herein may be applied to a greater number of members.","Multiple members may access a particular key that is contained in the mapping. Through the mapping, data (which may include, for example, a single value or an entire subtree of name-value pairs) that is obtained by a member as a result of accessing the key is dependent upon which member accessed the particular key. In other words, multiple members may share a global namespace while maintaining their member private data.","As a result, two different instances of a same computer program, which are running as two different members of a distributed system, and which are designed to read and update values associated with a same key, need not be modified to avoid data conflicts. One instance may refer to the key and obtain a first value that is associated with that instance, and another instance may refer to the same key and obtain a second value that is associated with that other instance. Similarly, one instance may update a first value that is associated with the key, while a second value, that is associated with the same key and with another instance, remains unaffected. Similarly, given multiple instances where each instance is running as a different member of a distributed system, each instance may update a value that is associated with a key, while other values, that are associated with the same key and with other instances, remain unaffected.","While reference is made herein to a single key referencing different single values, the techniques described herein may also be applied to a single key referencing different structures that each include multiple values. For example, the techniques described herein may be applied to produce a single key that references two different hierarchies, or subtrees, of key-value pairs. Thus, according to one embodiment, a whole subtree of key-value pairs may be made private to a given member.","Additionally, structures are disclosed for efficiently storing and accessing key-value pairs that implement public keys and private data as described above. Such efficient structures may be established on a persistent storage device. These structures are described below, first generally, and then with reference to the specific manner in which these structures implement private member data in a global namespace. The structures described below are described for the sake of context, and are not intended to represent an exclusive means of implementing the mapping described above.","According to one embodiment, a storage device may have stored thereon several \u201cregistry pages.\u201d A registry page is a defined data storage space on a data storage device. Each registry page is of some specified size. For example, each registry page may be 4 kilobytes long.","Taken together, multiple registry pages form a tree structure comprised of nodes. Nodes in the tree structure are data structures that are referred to herein as \u201ctree nodes\u201d or \u201ct-nodes.\u201d Each of the registry pages stores a t-node. However, t-nodes need not be stored contiguously. Each t-node corresponds to a key in a hierarchy of keys (which has the same organization as the tree structure). A first of the registry pages is a root t-node of the tree structure.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2A","b":["204","206","206","204"]},"Each key may be associated with a value. For example, key \u201cA\u201d  may be associated with a value \u201c1\u201d. Key \u201cB\u201d  may be associated with a value \u201c2\u201d. Key \u201cC\u201d  may be associated with a value \u201c3\u201d. Key \u201cD\u201d  may be associated with a value \u201c4\u201d. Key \u201cE\u201d  may be associated with a value \u201c5\u201d.","The tree includes a root key . Root key  may be invisible to the users of the distributed system. In other words, root key  is hidden and is not made visible to the users of the distributed system. In this example, root key  is a parent key of key \u201cA\u201d , key \u201cF\u201d , and key \u201cK\u201d . When a particular key is created without an explicit designation of a parent key of the particular key, the parent key of the particular key is implicitly designated to be the root key.","Each key is associated with a t-node. Each t-node is located at a particular location (i.e., offset) on a storage device. The location of a t-node that is associated with a particular key is stored in a t-node that is associated with a parent key of the particular key.","In this example, root key  is associated with a t-node . T-node  includes information for each t-node that is associated with a child key of root key . Because root key  is the parent key of key \u201cA\u201d , key \u201cF\u201d , and key \u201cK\u201d , t-node  includes information for t-nodes associated with each of key \u201cA\u201d , key \u201cF\u201d , and key \u201cK\u201d . Information for a t-node associated with a particular key is called a \u201ckey component entry\u201d for the particular key.","According to one embodiment, each dot-separated name inside a full key path name is called a key component. For each key component there is a corresponding key component entry. Key component entries are variable in size to take into account widely different size of key names. In one embodiment, up to 255 characters are allowed for each key component, and up to 255 bytes are reserved for each key component name. In one embodiment, a key component name is one or more characters. A key component entry includes a name of the key component and, in one embodiment, a 5 byte logical address of a registry page that stores a t-node that is associated with the key. Of these 5 bytes, the first byte may be used to indicate whether the key is a member-dependent key. Member-dependent keys are described below in the section entitled, \u201cMEMBER-DEPENDENT KEYS\u201d. If the key is a member-dependent key, then a logical-to-physical address mapping may be obtained from a \u201cmember-dependent key map\u201d, which is described in greater detail below in the section entitled, \u201cTHE MEMBER-DEPENDENT KEY MAP\u201d. The logical address obtained may be a number that is used as an index in the member-dependent key map.","A key component entry for key \u201cA\u201d  includes a key component name (\u201cA\u201d) , an offset , and other fields. These other fields include a field is_member_dependent . Similarly, a key component entry for key \u201cF\u201d  includes a key component name (\u201cF\u201d) , an offset , and other fields, including a field is_member_dependent . Likewise, a key component entry for key \u201cK\u201d  includes a key component name (\u201cK\u201d) , an offset , and other fields, including a field is_member_dependent . The purpose of the is_member_dependent field is described in greater detail in the section below entitled \u201cMEMBER-DEPENDENT KEYS.\u201d","Offset  provides the location, on a storage device, of a t-node that is associated with key \u201cA\u201d . Similarly, offset  provides the location, on the storage device, of a t-node that is associated with key \u201cF\u201d . Likewise, offset  provides the location, on the storage device, of a t-node that is associated with key \u201cK\u201d .","Therefore, offset  provides the location of a t-node  that is associated with key \u201cA\u201d . Each t-node includes the value of the key that corresponds to that t-node. Thus, both data (e.g., value) and metadata (e.g., key name) are encapsulated within the same t-node data structure. T-node  includes a value  that is the value of key \u201cA\u201d . In this example, value  is \u201c1\u201d. In one embodiment, 256 bytes of a t-node are reserved for the value. In one embodiment, values larger than 256 bytes are not stored within the t-node; instead, such larger values are stored at a location to which the t-node points. A technique for storing larger values using indirection is described in greater detail in the section below entitled \u201cUSING INDIRECTION TO STORE VALUES AND KEY COMPONENT ENTRIES.\u201d","Like each t-node, t-node  includes key component entries for each child key of the key with which t-node  is associated. Therefore, t-node  includes a key component entry for key \u201cB\u201d . This key component entry includes a key component name (\u201cB\u201d) , an offset , and other fields, including a field is_member_dependent . Offset  provides the location, on the storage device, of a t-node (not shown) that is associated with key \u201cB\u201d .","Each t-node may also include version information, an owner identifier, a group identifier, access control information (e.g., for users, groups, and others), a number of links to the t-node (e.g., from other t-nodes), a data type of the value of the key that corresponds to the t-node, a size of the value, a number of child keys of the key, a member number, a time that the t-node was created, a time that the t-node was last modified. The key name of the key does not need to be included in the t-node because the key name may be included in the parent t-node of the t-node. This reduces redundancy and preserves storage resources.","In one embodiment, a t-node layout is organized as follows. The first 4 bytes have registry version information. The next 4 bytes are reserved for an owner identifier. The next 4 bytes are reserved for a group identifier. The next 3 bytes are used for access control information for users, groups, and others. The next 1 byte is used to hold the count of the number of links on the current t-node. Therefore, in one embodiment, the maximum number of links is 255. One byte is reserved to indicate whether the t-node is a member-dependent key. One byte is reserved for a data type of the value of the key that is associated with the t-node. The next 4 bytes are reserved for the size of the value data. The next 4 bytes are reserved for creation time information. The next 4 bytes are reserved for last modification time information. The next 4 bytes are used to hold the number of child keys, or key component entries, of the key that is associated with the t-node. In one embodiment approximately 64,000 child keys may be under each key. The next 256 bytes are used to store the value of the key that is associated with the t-node. As described below, larger values may be stored through indirection. The next 80 (4*20) bytes contain logical addresses of 20 pages (described below) that accommodate up to 80 kilobytes of data through single indirection (described below). The next 4 bytes contain an address of a page that contains double indirect pages (described below) for value data, thus accommodating an additional gigabyte of data. The next 12 bytes, starting at byte offset , contain addresses of three pages that contain double indirect addresses (described below) of pages that contain key component entries. The next 100 bytes, beginning at byte offset , contain addresses of 25 pages that contain key component entries. The next 110 bytes are reserved for other uses. The rest of the space in the t-node is taken up by key component entries. Each key component entry represents one child key.","In one embodiment, a t-node is allocated to contain within itself, at most, a 256 byte value. It may sometimes be desirable to associate, with a key, a value that is larger than 256 bytes (or whatever limited amount of data storage space has been specified).","Therefore, in one embodiment, a t-node may include one or more addresses. For example, t-node  includes addresses . Each address may provide the location, on the storage device, of a different page. In one embodiment, each page is a different 4 kilobyte data storage space. Such pages are different than the registry pages discussed above.","The first 256 bytes of a value are stored in the t-node itself. The remainder of the value may be divided into 4 kilobyte portions. Each portion may be stored in a different page. The addresses included in the t-node provide the locations of the pages, which need not be contiguous. So, for example, the first 4 kilobytes after the first 256 bytes of a value may be stored in a first page that is referenced by a first address, the next 4 kilobytes after that may be stored in a second page that is referenced by a second address, and the remainder of the value (which may be less than 4 kilobytes) may be stored in a third page that is referenced by a third address. Because each address refers directly to the location of a page, this technique is called \u201csingle indirection.\u201d","Because each t-node is limited to some size, a finite number of addresses may be stored in a t-node. In one embodiment, each address is 32 bytes long. Therefore, to store even larger values, each 4 kilobyte page referred to by one of addresses  may include one or more other addresses (a 4 kilobyte page may include up to 128 32-byte addresses). Each of these other addresses may, in turn, refer to a different 4 kilobyte page. Each of these different pages may store a different portion of the value. Because each address in the t-node refers to a page that includes addresses that refer to yet other pages, this technique is called \u201cdouble indirection.\u201d","In other embodiments, additional levels of indirection may be used. Consequently, the specified size of a t-node imposes no limit on the size of a value that may be associated with a key.","Indirection may also be used to allow a parent key to have a greater number of child keys. As described above, a t-node contains key component entries for each child key of the key that is associated with the t-node. Because the size of a t-node is limited, a finite number of key component entries may be contained within a given t-node. In one embodiment, addresses contained in the t-node may refer to different pages that store key component entries in addition to those that are stored in the t-node itself. Any level of indirection is possible. Consequently, the specified size of a t-node imposes no limit on the number of keys that may be children of a particular key.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 2B"},"Slotted page structure  includes a header , free space , and key component entries A-N. Header  includes a number of entries . Number of entries  contains the number of key component entries that are stored in slotted page structure .","Header  also includes an \u201cend of free space\u201d address . \u201cEnd of free space\u201d address  contains the address at the end of free space . It is at this address that new key component entries are added to slotted page structure . In one embodiment, \u201cend of free space\u201d address  is a two-byte address. In one embodiment, header  is located starting at byte offset  of a t-node.","Header  also includes an array A-N that stores locations and sizes of each of the key component entries A-N that are stored in slotted page structure . In array A-N, the location and size of key component entry \u201cA\u201d  is indicated by location and size of entry \u201cA\u201d A. Likewise, the location and size of key component entry \u201cN\u201d N is indicated by location and size entry \u201cN\u201d N. Other locations and sizes of other key component entries may similarly by indicated in array A-N.","Located between header  and key component entries A-N is free space . Free space  is a contiguous space that shrinks as key component entries are added to the t-node and grows as key component entries are removed from the t-node.","Key component entries A-N are the key component entries for the child keys of the key that is associated with the t-node. Key component entries are added starting at the end of the slotted page structure, and then towards the start of free space  with each new addition.","In one embodiment, when a key component entry is removed from slotted page structure , the key component entries closest to free space  are relocated so that the space formerly occupied by the removed key component entry is occupied. This relocation essentially \u201cde-fragments\u201d the key component entries, thus ensuring the contiguity of both free space  and key component entries A-N.","Data may be made private to a particular member of a distributed system through the creation of a member-dependent key. A member-dependent key is expressly designated as being member-dependent when it is created. A member-dependent key may be created from any member of a distributed system; even a member other than the particular member for whom the data associated with the member-dependent key will be private.","Member-dependent keys are different from keys that are not member-dependent, in that member-dependent keys are expressly designated to be member-dependent keys when they are created. Invoking a special function of an Application Programming Interface (API) causes a member-dependent key to be created. Child keys of a member-dependent key do not need to be expressly designated as member-dependent keys in order to be private to a particular member. When a child key (or grandchild key, great-grandchild key, etc.) of a member-dependent key is created, that child key is automatically made private to the member that created it. This is so even though the member does not expressly designate that child key as a member-dependent key.","In one embodiment, a key component entry for a key includes information that designates that key as being a \u201cmember-dependent key.\u201d For example, if key \u201cB\u201d  was created as a member-dependent key, then the field is_member_dependent  would be set to \u201ctrue\u201d (e.g., \u201c1\u201d). Otherwise, is_member_dependent  would be set to \u201cfalse\u201d (e.g., \u201c0\u201d).","A key that is designated as being a member-dependent key may reference different values for different members of the distributed system. In other words, the value of a member-dependent key depends on the member from which the key is accessed. In one embodiment, a key component entry for a member-dependent key includes, instead of an offset that provides a location of a t-node, an index value for an entry in a data structure. The data structure that contains the entry is called the \u201cmember-dependent key map.\u201d The member-dependent key map is described in greater detail below.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 3","b":["328","328","330","332","334","336","336","338","340"]},"To illustrate the function of table , an example hierarchy of keys is also shown. In the example hierarchy, root key  is the parent key of key \u201cA\u201d . Key \u201cA\u201d is the parent key of key \u201cB\u201d . In this example, key \u201cB\u201d  has been created as a member-dependent key. As a member dependent-key, key \u201cB\u201d  may reference one value relative to one member, and another different value relative to another member.","Also, as a member-dependent key, key \u201cB\u201d  is the parent key of both key \u201cX\u201d  and key \u201cX\u201d . While key \u201cX\u201d  and key \u201cX\u201d  share a global name space (by virtue of the shared key component name \u201cX\u201d), the value and child keys of key \u201cX\u201d  are private to one member, while the value and child keys of key \u201cX\u201d  are private to another member.","Key \u201cX\u201d  is the parent key of key \u201cY\u201d . Key \u201cY\u201d is the parent key of key \u201cZ\u201d . Key \u201cY\u201d  and key \u201cZ\u201d  are private to the same member to which key \u201cX\u201d  is private by virtue of being descendant keys of a member-dependent key.","Key \u201cX\u201d  is the parent key of key \u201cY\u201d . Key \u201cY\u201d  is the parent key of key \u201cZ\u201d . Key \u201cY\u201d  and key \u201cZ\u201d  are private to the same member to which key \u201cX\u201d  is private by virtue of being descendant keys of a member-dependent key.","Each member-dependent key is associated with a unique index value. The index value of a member-dependent key is included in the member-dependent key's key component entry that is contained in the parent key of the member-dependent key. For example, t-node  is associated with key \u201cA\u201d , which is the parent key of key \u201cB\u201d . Because key \u201cA\u201d  is the parent key of key \u201cB\u201d , t-node  includes a key component entry for key \u201cB\u201d .","The key component entry for key \u201cB\u201d  includes a key component name (\u201cB\u201d) . The key component entry for key \u201cB\u201d  also includes a field is_member_dependent . Because key \u201cB\u201d  has been created as a member-dependent key, is_member_dependent  is set to \u201c1\u201d (e.g., \u201ctrue\u201d). By is_member_dependent  being set to \u201c1\u201d, it is signified that the value in offset  is not actually an offset to a t-node, but that the value in offset  is actually an index value used to locate an entry in table . In this example, offset (or index value)  is set to \u201c1\u201d. Thus, in this example, the unique index value associated with key \u201cB\u201d , as a member-dependent key, is \u201c1\u201d.","In this example, table  includes two entries whose index is set to \u201c1\u201d; index value  is set to \u201c1\u201d and index value  is set to \u201c1\u201d. Both of these index values correspond to offset (or index value) , which is also set to \u201c1\u201d. Associated (i.e., in the same row) with index value  is member identifier . Associated with index value  is member identifier . Each member of the distributed system is associated with a unique member identifier. In this example, a member identifier of a first member is \u201c1\u201d and a member identifier of a second member is \u201c2\u201d. In one embodiment, when a member-dependent key is created, a different entry for that member-dependent key is created in the member-dependent key map for each member of the distributed system.","The entry that includes member identifier  also includes an offset . The entry that includes member identifier  also includes an offset . In this example, offset  is shown as \u201cO(1)\u201d and offset  is shown as \u201cO(2)\u201d. Each of these offsets provides a location to a different t-node that is associated with key \u201cB\u201d . Because member identifier  (\u201c1\u201d) corresponds to offset , a member having a member identifier of \u201c1\u201d uses offset  to locate a t-node when that member accesses key \u201cB\u201d  (which corresponds to index value \u201c1\u201d). Because member identifier  (\u201c2\u201d) corresponds to offset , a member having a member identifier of \u201c2\u201d uses offset  to locate a t-node when that member accesses key \u201cB\u201d .","T-nodes  and  are both associated with key \u201cB\u201d . T-node  is located at the location indicated by offset . T-node  is located at the location indicated by offset . T-node  may include a different value and different key component entries than t-node . For example, the value entry for T-node  is labeled with - to indicate that the value associated with key \u201cB\u201d  for T-node  is associated with member , and the value entry for T-node  is labeled with - to indicate that the value associated with key \u201cB\u201d  for T-node  is associated with member . A value may be written to Value - independently of writing to Value -, and thus, at any point in time Value - may have a value different from the value of Value -.","Thus, a t-node associated a key relative to one member is different than a t-node associated with the same key relative to another member. Because each t-node that is associated with a single member-dependent key includes its own independent key component entries, once a parent key is created as a member-dependent key, all of that parent key's child keys will be member-private even if not explicitly made member-dependent. The key component entries for one t-node may have the same key component names as the key component entries for another t-node.","For example, t-node  includes a key component entry that includes a key component name  that is set to \u201cX\u201d. Similarly, t-node  includes a key component entry that includes a key component name  that is also set to \u201cX\u201d. However, an offset  in the key component entry that is included in t-node  is different than an offset  that is included in t-node Therefore, offset  may provide the location (\u201cO(3)\u201d) of a t-node that is associated with key \u201cX\u201d , while offset  may provide the location (\u201cO(4)\u201d) of a t-node that is associated with key \u201cX\u201d .","The values for key \u201cX\u201d  and key \u201cX\u201d  may differ. This is so even though key \u201cX\u201d  and key \u201cX\u201d  were not specially created as member-dependent keys (as demonstrated by is_member_dependent  and is_member_dependent  both being set to \u201c0\u201d). For example, key \u201cX\u201d  could be created as a child key of key \u201cB\u201d  from a member whose member identifier is \u201c1\u201d, while key \u201cX\u201d  could be created as a child key of key \u201cB\u201d  from a member whose member identifier is \u201c2\u201d. The different members need not even be aware that key \u201cB\u201d  is a member-dependent key.","Thus, data may be member-private even though a key name associated with that data is global. As a result, a program does not need to be modified in order for an instance of that program to create and access data that is private and protected from all other instances of that program. Other programs, such as installation programs, may create member-dependent keys for which child keys may be created at a later time.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIGS. 4A","FIG. 4A","FIG. 4B","FIG. 4C"],"b":["4","4"]},"Each of the hierarchies illustrated in , B, and C include a key \u201cCLUSTER_\u201d . In each of these hierarchies, a key \u201cA\u201d  is a child key of key \u201cCLUSTER_\u201d . In each of these hierarchies, a key \u201cB\u201d  is a child key of key \u201cA\u201d . In each of these hierarchies, a key \u201cC\u201d  and a key \u201cD\u201d  are child keys of key \u201cB\u201d . All of the first, second, and third members of the distributed system can see and access these keys.","In each of the hierarchies illustrated in , B, and C, key \u201cC\u201d  is a member-dependent key. That is, key \u201cC\u201d  was expressly created as a member-dependent key. In this example, no other key in the hierarchies was expressly created as a member-dependent key.","In , a key \u201cE\u201d  is a child key of key \u201cC\u201d . Only the first member of the distributed system can see and access key \u201cE\u201d  and its corresponding value and child keys (if any). In contrast, in , a key \u201cF\u201d  is a child key of key \u201cC\u201d . Only the second member of the distributed system can see and access key \u201cF\u201d  and is corresponding value and child keys (if any). In further contrast, in , key \u201cC\u201d  has no apparent child keys. Thus, the third member of the distributed system does not see any child keys of key \u201cC\u201d . A given member of a distributed system may be access an entire sub-hierarchy that is private to that member.","When a new child key is created under a key, a new t-node may be allocated for the child key. A key component entry may be created for the child key. The key component entry may be entered into the t-node of the parent key. If intermediate child keys do not exist, then the intermediate child keys may be created as a side-effect of the creation of the new child key. For example, if a child key named \u201ca.b.c.d\u201d is to be created, and only \u201ca.b\u201d currently exists, then \u201ca.b.c\u201d and \u201ca.b.c.d\u201d are both created. Any of the intermediate child keys could be a member-dependent key.","If an intermediate child key is a member-dependent key, then all of that intermediate child key's descendant keys are member-private. If an intermediate child key is a link to another key, then the t-node address field may point to a t-node for the other key. Thus, in one embodiment, multiple key component entries may share a single t-node.","In one embodiment, to create a new key, user access control information, a key handle of a parent key of the new key, a key name of the new key, and security attributes of the new key are provided to a function. The function finds a part of the provided key name that is not common with the name of the key that is stored in the provided key handle. The function stores that part in the new key. For example, if the key name of the key handle contains \u201ca.b.c\u201d, and the provided key name is \u201ca.b.c.d.e\u201d, then the part stored in the new key is \u201cd.e\u201d.","The function assigns the key handle to a temporary key handle. For each component in the new key, the function does the following. The function finds a t-node that corresponds to the parent key using the temporary key handle. The function finds a t-node that corresponds to the key component. If the t-node that corresponds to the key component already exists, then the function assigns the t-node that corresponds to the key component to the temporary key handle.","If the t-node that corresponds to the key component does not already exist, then the function creates a key component entry in memory for the key component.","The function allocates a new t-node for the key component and inserts the address of the new t-node into the address field of the key component entry. The function may call another function to enter the key component entry into a t-node. The function assigns the handle of the newly created key to the temporary key handle.","After the function has done the above for each component in the new key, the function may call another function to finish \u201cshadow updating\u201d of a list of free registry pages. The function marks the log space as being invalid. The function returns the key handle that is currently stored in the temporary key handle.","In one embodiment, to find a key component entry in a t-node, a key name and a t-node address are provided to a function. The function searches through the slotted page structure of the t-node at the address provided to the function. Using the array in the header of the slotted page structure, the function locates and reads key component entries. If the key name stored in a key component entry matches the key name provided to the function, then the function returns the address of the t-node and the offset of the key component entry that stores the matching key name. The function may also return a size of the key component entry that stores the matching key name.","If the key component entry that stores the key name is a key component entry for a member dependent key, then the address of the t-node may be obtained from the member dependent key map, as described above in the section titled \u201cTHE MEMBER-DEPENDENT KEY MAP\u201d.","If the function does not find the key name provided to the function in any of the key component entries in the slotted page structure, then the function searches directly addressed registry pages for the key name. If the function finds the key name, then the function returns the address of the t-node and the offset of the key component entry that stores the matching key name. The function may also return a size of the key component entry that stores the matching key name.","If the function does not find the key name provided to the function in any of the directly addressed registry pages, then the function searches indirectly addressed registry pages for the key name. If the key name is found, then the function returns the address of the t-node and the offset of the key component entry that stores the matching key name. The function may also return a size of the key component entry that stores the matching key name.","If the function does not find the key name in the slotted page structure or in the directly or indirectly addressed pages, then the function may return an error message.","In one embodiment, to create a new key component entry in a t-node, a key component entry and a t-node address are provided to a function. Based on the t-node address, the function finds the registry page in which the key component entry is to be created. If there is not enough space to create the key component entry in the registry page, then another function is called to find a free page.","If there is enough space to create the key component entry in the registry page, then the function does the following. The function writes the t-node (at the address provided) into a log space. The function updates a count of key component entries that are in that t-node. The function sequentially scans through the header of the slotted page structure of the t-node to find the first empty entry. If there are no empty entries in the header, then the function creates a new entry at the end of the array that is in the header.","Once the function has found or created an empty entry, the function writes the key component entry provided to the function at the end of the free space in the slotted page structure. The function inserts size and location information of the new key component entry in a corresponding entry in the array in the header of the slotted page structure. Another function may be called to finish \u201cshadow updating\u201d of a list of free registry pages.","If there is not enough space to create the key component entry in the registry page, then the function does the following. The function initializes a new registry page with the slotted page structure. The function then performs the techniques described above, but in relation to the new registry page.","Whether or not there is enough free space to create the key component entry in the registry page, the log space mentioned above is marked as being invalid. The function returns an indication of success or failure based on whether the new key component entry was created.","In one embodiment, to delete a key component entry from a t-node, a key name is provided to a function. The function finds a t-node that stores the key component entry that stores the provided key name by calling the function described below to find a t-node in which a key component entry for a key exists. The function decrements a count of key component entries in the t-node found. The function finds the key component entry that stores the provided key name by calling the function described above for finding a key component entry in a t-node. The function makes an entry in a registry page log and writes the t-node's registry page into the registry page log space. The function deletes the key component entry that stores the provided key name from the slotted page structure. Another function may be called to finish \u201cshadow updating\u201d of a list of free registry pages. The function marks the log space as being invalid. The function returns an indication of success or failure based on whether the key component entry was deleted.","In one embodiment, to find a t-node in which a key component entry for a key exists, a key name is provided to a function. The function parses the key name to separate the key components of the provided key name. The function reads the root registry page. For each of the key components of the provided key name, the function does the following.","The function finds the key component entry for the key component by calling the function described above in the section titled \u201cFINDING A KEY COMPONENT ENTRY IN A T-NODE\u201d to find a key component entry in a t-node. If the function cannot find the t-node, then the function may return an error. Otherwise, the function reads the t-node that was found.","After doing the above for each of the key components of the provided key name, the function returns the t-node that was most recently read (i.e., the current t-node).","In one embodiment, to set a value of an empty t-node, a value and a t-node are provided to a function. The function may return an error if the size of the value is greater than a maximum permitted value size. Otherwise, the function scans through a list of free registry pages to find the total size of the available free space. The function may return an error if the size of the free space is less than the size of the value.","Otherwise, the function makes an entry for the operation in the registry page log space. The function writes the t-node into the registry page log space. The function writes the size of the value in a field of the t-node that is reserved for the size of the value. In one embodiment, the function writes the first 256 bytes of the value in the field of the t-node that is reserved for the value. If the size of the value is 256 bytes or less, then the function returns an indication that the operation was successful.","Otherwise, based on the size of the value, the function allocates direct and possibly indirect pages (if the value is sufficiently large) for the value by updating the t-node and the list of free registry pages. The function writes the value in the allocated pages. If any error occurs while writing, then the function may return an error. Otherwise, another function may be called to finish \u201cshadow updating\u201d of the list of free registry pages. The function marks the log space as being invalid. The function returns an indication of success or failure based on whether the value was stored.","In one embodiment, to modify a value of a t-node, a new value and a t-node are provided to a function. If the size of the new value exceeds a maximum permitted size, then the function may return an error. Otherwise, the function scans through a list of free registry pages to find a total size of free space available. The function reads the t-node to find the current size of the existing (old) value. If the sum of the total available free space and the current size of the existing value is not greater than the size of the new value, then the function may return an error.","Otherwise, the function makes an entry for the operation in the registry page log space. The function writes the t-node into the registry page log space. The function writes the size of the new value in the field of the t-node that is reserved for the value of the t-node. If the size of the new value is small enough so that one or more registry pages can be freed, then the function writes those one or more registry pages into the registry page log space and modifies the list of free registry pages.","Regardless of whether the function modifies the list of free registry pages, in one embodiment, the function writes the first 256 bytes of the new value in the field reserved for the value in the t-node. If the size of the new value is 256 bytes or less, then the function returns an indication of success. Otherwise, if the size of the new value is greater than the size of the existing value and new registry pages should be acquired to store the new value, then the function calls another function to find a free page. The function writes the new value in the pages allocated.","If any error occurs while writing, then the function may return an error. Otherwise, the function may call another function to finish \u201cshadow updating\u201d of the list of free registry pages. The function marks the log space as being invalid. The function returns an indication of success or failure based on whether the value was stored.","In one embodiment, to open a key, user access control information and a key name are provided to a function. The function searches for a t-node that stores the key name, possibly by calling another function that is designed to find a t-node. If the key does not exist, or if access to the key is not permitted based on the user access control information, then the function may return an error.","Otherwise, the function inserts a key component entry for the key into a key handle. The function inserts security attributes for the key into the key handle. The function then returns the key handle.","In one embodiment, to read the value a key, user access control information, a key handle (such as may be returned by the function for opening a key, as described above), an address of a buffer in which a read value is to be stored, and an address at which a size of the buffer is stored are provided to a function. The function obtains an address of a t-node based on the provided key handle. If the provided size of the buffer is zero, then the function may return an error.","Otherwise, the function reads user security attributes from the provided user access control information. The function reads key security attributes from the provided key handle. The function checks if the user indicated in the user access control information has sufficient privileges to access the key by calling another function. If the check is not successful, then the function may return an error.","Otherwise, the function reads the t-node from a disk into memory. The function reads the size of the value that is stored in the t-node. If the size of the value is greater than the provided size of the buffer, then the function may insert the size of the data at the address where the size of the buffer was stored, and return an error.","Otherwise, in one embodiment, the function reads the first 256 bytes of the value from the field in the t-node that stores the value. The function stores this at the address of the buffer provided. If the size of the value is more than 256 bytes, then the function reads directly addressed pages. The function appends the information read from the directly addressed pages to the data that is stored in the provided buffer. The function does not stop reading the directly addressed pages until the entire value has been read. The function inserts the total number of bytes read at the address where the size of the buffer was stored. The function may return an indication of success.","In one embodiment, to create a new key and set the value of the new key, user access control information, a function may call another function to create a key, such as is described above. However, shadow updating is not finished, and the registry page log is not marked as being invalid. After the key is created, the function may set the value of the new key by calling another function to set the value of a key, such as is described below in the section \u201cSETTING THE VALUE OF A KEY\u201d.","In one embodiment, to create a link, user access control information, a key handle of an open destination key, a key name of a source key, and security attributes of the source key are provided to a function. The function reads a t-node of the destination key using an address that is located in the provided key handle of the destination key. This t-node may be referred to as the destination t-node.","If the number of existing links on the key exceeds some specified threshold, then the function may return an error. If the destination key is a member-dependent key and the source key is not a member-dependent key, or vice-versa, then the function may return an error.","Otherwise, the function creates an image of the destination t-node in the registry page log. The function updates a link count of the destination t-node. The function finds a t-node that corresponds to a parent key of the source key (whose key name was provided). This t-node may be referred to as the source t-node. The function creates, in memory, a key component entry for the provided key name. The function inserts the address of the destination t-node into a t-node address field of the key component entry. The function enters the key component entry into the source t-node. The function deletes log records that were involved in the operation. The function may call another function to finish \u201cshadow updating\u201d if needed. The function returns a key handle.","In one embodiment, to create a new member-dependent key, user access control information, a key handle of a parent key of the new key, a key name of the new key, and security attributes of the new key are provided to a function. The function performs the same operations as those described above in the section \u201cCREATING A KEY\u201d, except that, by setting a bit in the key component entry for the key stored in the parent t-node, the function creates a new entry for the member-dependent key to be created in the member-dependent key map. The function enters the address of the newly created entry in the member-dependent key map inside the key component entry of the key. The function allocates a t-node for the key for each of the members (one t-node for each member) and writes the addresses of these t-nodes in the entry corresponding to the key in the member-dependent key map.","In one embodiment, to set a security attribute of a key, user access control information, a key handle of an opened key, and new security attributes for the opened key are provided to a function. If the user identified by the user access control information does not have sufficient privileges to access the key, then the function may return an error.","Otherwise, the function reads a t-node that corresponds to the provided key handle. The function creates a record of the t-node in the registry page log. The function updates the t-node in memory and then writes the t-node to the disk. The function marks the registry page log as being invalid.","In one embodiment, to set a value of a key, user access control information, a key handle of an opened key, a pointer to a buffer that contains the new value, a type of the new value, and the size of the new value are provided to a function. If the user identified by the user access control information does not have sufficient privileges to access the key, then the function may return an error. If the provided size of the new value is equal to zero, then the function may return an error.","Otherwise, the function retrieves the t-node that corresponds to the provided key handle. The t-node may be a member-dependent key or not; the address of the t-node may be obtained by a previously called function, such as the function described above with reference to opening a key. The function may use another function, such as the function described above in the section \u201cMODIFYING A VALUE OF A T-NODE\u201d to modify the value of the retrieved t-node. If this other function returns an error, then the error is passed along.","Otherwise, the function may mark the registry page log as being invalid and return an indication of success.","In one embodiment, to delete a value of a key, user access control information and a key handle of an opened key are provided to a function. If the key component entry for the key is already empty (e.g., signified by the t-node's address being equal to 0x0000), then the function may return an error.","Otherwise, the function reads the t-node for the key. The function writes, in the registry page log space, the value of each registry page that contains the value of the key. The function creates a shadow of a list of free registry pages, possibly by calling another function designed to create such a shadow. The function updates the shadow by marking every registry page that contains the value of the key as being a free registry page. The function writes t-node for the key into the registry page log space. The function updates the t-node by making the value field of the t-node empty, making the value size of the t-node zero, and marking direct and indirect addresses in the t-node as being empty.","If the key is a member-dependent key, then the function does the following. The function creates a shadow of the member-dependent key map, possibly by calling another function designed to create a shadow of the member-dependent key map. The function deletes an entry, in the shadow of the member-dependent key map, which corresponds to the t-node.","Regardless of whether the key is a member-dependent key, the function may call another function to finish \u201cshadow updating\u201d of data structures. The function marks the log space as being invalid.","In one embodiment, to delete a key, user access control information and a key handle of an opened key are provided to a function. If the key component entry for the key is already empty (e.g., signified by the t-node's address being equal to 0x0000), or if the key has child keys, then the function may return an error.","Otherwise, the function reads a t-node from a disk by using the address of the t-node that is stored in the key component entry that is stored in the provided key handle. If the value size for the key is not equal to zero, then the function may return an error. If the count of the total number of key component entries is not equal to zero, then the function may return an error.","If the function does not return an error, then the function does the following. The function locates, on the disk, a registry page that contains the key component entry for the key. The function reads the located registry page into memory. The function writes the registry page into the registry log space, possibly by calling another function that writes to the registry log space. The function deletes the key component entry in the registry page that is stored in memory by calling another function, such as the function described above in the section titled \u201cDELETING A KEY COMPONENT ENTRY FROM A T-NODE\u201d. The function may call another function to finish \u201cshadow updating\u201d of data structures. The function marks the log space as being invalid. The function may return an indication of success.","A key handle of an opened key is provided to a function. If the opened key is already a member-dependent key, then an error may be thrown. Otherwise, the function locates the t-node for the key and the key component entry (KCE) corresponding to the key (The KCE is located in the parent t-node of the key). The function sets a bit in the KCE to indicate that it is a member-dependent key. The function then makes as many replicas of the t-node for the key as there are members in the distributed system. The function creates a new entry for the key in the member-dependent key map and inserts the index of this entry in the key component entry corresponding to the key. The function inserts the addresses of the t-nodes into the entry for the key in the member-dependent key map. The member number indexes each t-node address.","A key handle of an opened member-dependent key is passed to a function. If any of the ancestors of the key is also a member-dependent key, then an error may be thrown. The function locates the key component entry for the key. The function then locates the member-dependent key map entry for the key (the index of the member-dependent key map entry for the key is read from the key component entry for the key). The function then locates the t-nodes for the key corresponding to the members of the distributed system (there are as many t-nodes for a member-dependent key as there are members of the distributed system). The function deletes the t-nodes and all the descendants of each corresponding to all the members of the distributed system except the current member. The function then marks the bit in the key component entry for the key to indicate that the key is a normal key. The function inserts the address of the t-node for the key corresponding to the current member of the distributed system in the key component entry for the key.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 5","b":"502"},"In block , in response to the first request, the first data is stored in a repository that is shared by a plurality of members of the distributed system. The repository may store configuration information that is used by both a first instance of a computer program that runs as a first member of the distributed system and a second instance of the computer program that runs as a second member of the distributed system. The repository may store configuration information that is used by multiple instances of a computer program that run on a same hardware element of a distributed system.","In block , mapping data is stored. The mapping data maps the key, relative to the first member, to a first t-node that stores the first data. The mapping data may be stored in a member-dependent key map. The mapping data may include a first association between the key, the first member, and first location information. The first location information provides a location of the first t-node. In block , location data for locating the first association within the member-dependent key map is stored in a parent t-node of the first t-node.","In block , a second request is received from a second member of a distributed system to store second data in association with the key. The second data may differ from the first data. In block , in response to the second request, the second data is stored in the repository without overwriting the first data.","In block , mapping data is stored. The mapping data maps the key, relative to the second member, to a second t-node that stores the second data. The mapping data may include a second association between the key, the second member, and second location information that differs from the first location information. The second location information provides a location of the second t-node. In block , location data for locating the second association within the member-dependent key map is stored in a parent t-node of the second t-node.","In block , based on the mapping data, the first member is allowed to access the first data and not the second data. In block , based on the mapping data, the second member is allowed to access the second data and not the first data. Thus, the first data is member private data that is private to the first member, and the second data is member private data that is private to the second member. Member private data may be a single value. Member private data may be a complete subtree of key-value pairs.",{"@attributes":{"id":"p-0145","num":"0144"},"figref":"FIG. 6","b":["600","600","602","604","602","600","606","602","604","606","604","600","608","602","604","610","602"]},"Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","The invention is related to the use of computer system  for implementing the techniques described herein. According to one embodiment of the invention, those techniques are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus .","Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, or any other memory chip or cartridge.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line. Appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. In any such implementation, communication interface  sends and receives digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both carry digital data streams.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface .","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 4A","b":["4","4"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6","b":"600"}]},"DETDESC":[{},{}]}
