---
title: System and method for processing map images
abstract: A system of processing map images includes a Web Mapping Service (WMS) for storing map images. A WMS proxy is operative with the WMS and receives from a client a request for a map image for display at the client. A WMS proxy includes a tile broker module that converts the request for the map image into a series of requests for obtaining map tiles. A cache system that stores the map tiles. The tile broker module is operative for returning cached map tiles if they already exist within the cache and retrieving map tiles from the WMS if map tiles are not returned from the cache. A tile building module is operative for building a map image at the WMS proxy from the map tiles in a requested format and resolution and displaying the map image at the client without resampling at the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08130245&OS=08130245&RS=08130245
owner: Harris Corporation
number: 08130245
owner_city: Melbourne
owner_country: US
publication_date: 20070118
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["GOVERNMENT LICENSE RIGHTS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This invention was made with government support under Government Contract No. HM1571-04-A-0006 awarded by the National Geospatial-Intelligence Agency (NGA). The U.S. Government may have certain rights in the invention.","The present invention relates to the field of image processing, and more particularly, to systems and related methods of processing map images formed from map tiles used in mapping systems.","Classical large image databases, such as those used by Google Earth and Microsoft Virtual Earth, require map data to be preprocessed. As a result, only one set of map data is served up with only one view into the map data. This limits the ability to rapidly make new map data available or to view map data from different perspectives, for example, viewing changing map data over time.","Current systems use a Web Mapping Service (WMS) with a WMS data layer that could include some cache system. In most systems, scalability and performance are enhanced by adding additional image services and using various load balancing techniques. For example, any users as clients could be connected by the internet to the WMS as one or more servers that could be load balanced with other WMS servers and a shared database such as a retrieval and information database. Performance can be enhanced by preprocessing imagery, trading currency of data for response time. Some systems have many tiles assembled at the client in which tiles are already predefined such that a client will fetch a tile, thus placing much work on the client with excessive map data processing occurring at the client.","A system of processing map images includes a Web Mapping Service (WMS) for storing map images. A WMS proxy is operative with the WMS and receives from a client a request for a map image for display at the client. A WMS proxy includes a tile broker module that converts the request for the map image into a series of requests for obtaining map tiles. A cache stores the map tiles. The tile broker module is operative for returning cached map tiles if they already exist within the cache and retrieving map tiles from the WMS if map tiles are not returned from the cache. A tile building module is operative for building a map image at the WMS proxy from the map tiles in a requested format and resolution and displaying the map image at the client without resampling at the client.","The WMS could be formed by a plurality of servers that store map images. A load balancing module could be operative with the WMS proxy and WMS for load balancing among the plurality of servers.","In yet another aspect, the WMS proxy is operative for storing map tiles within the cache that are retrieved from the WMS. The map building module is also operative for rebuilding a map image by mosaicking and cropping tiles. The map building module can be operative for building a tile specification that details an adjusted x, y position on overall mosaic and cropping parameters. The map building module can also be formed as hardware performance primitives, open GL\/GPU or JAVA processes.","In yet another aspect, a distributed two-tier cache stores map tiles based on the Java Caching System (JCS), and other distributable caching mechanisms. A method aspect is also set forth.","Different embodiments will now be described more fully hereinafter with reference to the accompanying drawings, in which preferred embodiments are shown. Many different forms can be set forth and described embodiments should not be construed as limited to the embodiments set forth herein. Rather, these embodiments are provided so that this disclosure will be thorough and complete, and will fully convey the scope to those skilled in the art.","The system and method of processing map images formed from a plurality of tiles, in accordance with non-limiting examples of the present invention, overcomes disadvantages in prior art map imaging processes that use classical large image databases, such as Google Earth and Microsoft Virtual Earth, which require data to be preprocessed. In these systems, only one set of data is \u201cserved-up\u201d with only one view into the data, limiting the ability of the system to make new data rapidly available or view data from different perspectives, for example, changing data over time. Some of the prior art mapping engines operative with a classic Web Map Service (WMS) were only marginally beneficial to solve analytical problems because of the inherent one state view of the world. Some improved map systems could process different spatial map tiles at the server that are fairly small. For example, a client would retrieve or \u201cfetch\u201d those map tiles that are necessary for the desired map screen, for example, tile number . These systems could operate under Open GIS Consortium, which operates with an OGC WMS standard. This is the first interoperability standard in map serving space, but does not allow for rapid tiling. It is possible to request different scales of data at a different resolution and number of pixels, and the map server corresponding to the WMS would have responsibility for assembling that picture. This type of system takes some of the load off the clients. This type of system, however, can be slow if many users request a map, tying-up those processing resources used for making custom images. A positive benefit of such system, however, is the OGC specification, which allows querying over data ranges.","In accordance with non-limiting examples of the system and method of the present invention, clients now have the speed and open standard for use with a WMS interface, such that clients can remain lightweight with minimum processing, and do not require the extensive data processing on the map tiles. The system and method has the flexibility to continue querying through time and also maintain dynamic lightweight clients that can connect to the system.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1A","b":["10","12","14","16","18","20","18","16","14","14","14","18","14","18"]},"In operation, the client  requests a map such as an Image Mosaic . Load balancing  as an optional processing step can occur. At the WMS proxy , which acts as a separate logic module and typically a separate server, a tile broker  converts the map request to a series of tiled requests. A cache  returns the cached tile if it already exists, for example, by using an internet cache program such as SQUID or similar cache program.","The cache , for example, SQUID as a non-limiting example, typically will be a high performance proxy caching server for web clients that supports HTTP data objects and requests in single, non-blocking, input\/output driven processes. Metadata and objects can be cached in RAM, including DNS look-ups and negative caching secure socket layer (SSL) extensive access controls and full requests logging are supported.","It should be understood that any internet object caching program and related cache can be used to store requested internet objects as data available via HTTP, FTP and gopher protocols as non-limiting examples. Web browsers can use the cache as a proxy HTTP server.","At the WMS server  as a typical separate server, the WMS fields the GetMap request  and the appropriate pyramid level is determined . A database access program identifies the appropriate images for request  into the WMS Data Layer  that could include several databases , . At this time, the WMS resamples and mosaics input images  with tiles returned to the cache  for caching. At the network module , an optional load balancing module  can occur. The WMS  can be formed by several servers \/as illustrated by the two large boxes depicting the servers, corresponding to a plurality of servers that could be load balanced.","The WMS proxy  is operative as a front-end proxy to the WMS . After the tiles are returned to the cache for caching, tiles are mosaicked and scaled at the map building module  as part of the WMS proxy , using software or hardware via the Intel Performance Perimatives or Open GL\/GPU. No resampling is required of the client . It is possible and desirable in some embodiments to use a Java Caching System (JCS). The cache and map building module are operative together and can provide memory management, disk overflow and defragmentation, thread pool controls and element grouping. It is a composite cache for memory, disk, lateral and remote regions. It can have a memory cache with the Least Recently Used (LRU) algorithm for management. Cached data can be cached to multiple servers.","The Intel Performance Primatives provide multi-core power for multimedia and data processing as an appropriate software library of performance-optimized functions. In the alternative, the Open Graphics Library (Open GL) defines the cross-language, cross-platform application programming interface (API) for three-dimensional and two-dimensional computer graphics. Different functions can call and draw complex three-dimensional scenes from simple primatives.","After the tiles are cropped, mosaicked, and scaled, the map is displayed on the client . In this preferred embodiment, the WMS proxy , network  and WMS  are limited in management of the tile preparation on the server or servers. Temporary file clean up can be administered. Additionally, when fresh content is added, the cache for that area is flushed. This type of system provides for the potential of significant scalability. For example, if a particular image of a field is desired, such as 1,000 pixels wide and 1,000 pixels high, e.g., the size of a football field, the WMS proxy  could break that into predetermined tiles.","In this non-limiting example, perhaps four tiles are required in the original tiling. The system would break-up the data into four independent requests and determine if they exist already in cache. For example, images may have been pooled for some other reason in the past. The cache  is operative at this point. Perhaps the picture as a tile of the field was held at one-meter pixel resolution in the cache, and another tile was held at five meters pixel resolution, and yet another tile was held at 20 meters pixel resolution. In this example, perhaps the client  may desire a three-meter pixel resolution of the field. The four tiles would be processed and fetched out of the one-meter pixel resolution tile in cache. The map building module  would resample that down to three meters pixel resolution at a fast processing speed. Thus, in the system and method, different sizes can be fetched, and the resolution is highly changing for every user request. This tiling scheme, in accordance with non-limiting examples of the present invention, could hold in fixed resolution tiles of different scales, and resample them (down-sample) at lower scales quickly. For example, different libraries in the Intel Performance Perimitives could be used for the resampling.","In accordance with non-limiting examples of the present invention, the tile broker , combined with the cache  and the functional ability to resample those tiles and ship them back together at the right resolution, enhances the speed of operation in map imaging. The load balancing ,  is operative if the WMS  includes a plurality of map servers , . For example, the WMS  shown in  illustrates two servers , , each as separate processors. As a result, the request for four tiles in the example above could be spread over the different processors. Load balancing helps populate the cache.","There now follows a more detailed description of the WMS proxy  that can be used in accordance with non-limiting examples of the present invention. The WMS proxy  is operatively similar to a reserve proxy for imagery. The WMS proxy  breaks an image request into common tiles, stores the common tiles in the fast-cache system , and builds the image from tiles in the format requested using the map building module  as a scaling module.","It is possible for the architecture to use two servlets, i.e., a front-end and a back-end, and include a cache connection and a concurrent threading system to control the number of requests to\/from different proxy components.","Another embodiment splits the WMS proxy into a more patterned design such as shown in . The major components of this embodiment could include a Front-End Servlet (FES) , the Tile Query Factory (TQF) , the Tile Query Manager (TQM) , and an ImageManipulator Component (IMC) . The configuration handling in this design is centralized. Java functionality  could include JAI and AWT Java objects, and the utilization of the JCS as an integrated and distributable cache.","The programming could allow configuration classes to be one instance across the system, allowing an accurate resolution level configuration. A resolution level adjustment, in one non-limiting example, could reduce memory overhead by as much as tenfold. In one embodiment, up to 48 individual 1000 by 1000 pixel tiles could be called to create an image that most efficiently could be handled by calling just four tiles. In dealing with AWT Java Objects, such as a buffered image, 48 individual 1000 by 1000 pixel tiles could cause a system failure due to a heap stack memory overload.","In another embodiment, the WMS proxy  calls a http-get command and runs as a servlet on the server, for example, an Apache-Tomcat server. Image tiles are added asynchronously to the tile mosaic and the TQM  retrieves the image tile when the thread has finished. The TQF  can build a tile specification detailing the adjusted X\/Y position on the overall mosaic and crop parameters. It can return a reference list of any concurrent threads that may or may not have executed. The TQF  can submit a concurrent asynchronous thread. Another module, the Tile Retrieval Thread (TRT), can return the image tile result and will take the tile specification and use the IMC  to crop the tile using Java Advanced Imaging (JAI). It is also possible to operate with a SQUID (remote cache) thread pool and a WMS thread pool that are operative with a database. A Java Caching System (JCS) thread pool could be operative with the database.","The Front-End Servlet (FES)  as a WMS Proxy Servlet can be the starting point of the WMS Proxy. It can be coded as a Java Servlet (J2EE) and deployed through Apache Tomcat version 5.5.17, in one non-limiting example. The structure of this servlet can be described as \u201crequest in, process, response out.\u201d Though the FES  is one center point of the WMS Proxy, and holds the outline of the system, most of the true processing work is subjugated to other components. Below is an algorithm written in pseudo-code, detailing the FES request handling as a non-limiting example:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"FrontEnd Begin"},{"entry":"\u2003\u2003WMSProxyParameters params <- parseWebVars( )"},{"entry":"\u2003\u2003Load RequestThreadPool pool"},{"entry":"\u2003\u2003Use TileQueryFactory to create TileQuery objects based on params"},{"entry":"\u2003\u2003Use TileQueryManager to load Tiles from TileQuery objects"},{"entry":"\u2003\u2003Get TileMosaic from TileQueryManager"},{"entry":"\u2003\u2003Use ImageManipulator to scale image based on params"},{"entry":"\u2003\u2003Open OutputStream to user"},{"entry":"\u2003\u2003Use Image Formatting I\/O to send image in format based on params"},{"entry":"\u2003\u2003Close OutputStream"},{"entry":"End FrontEnd"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Tile Query Factory (TQF)  produces Tile Query objects based on parameters loaded from the requested web environment variables. The TQF  is responsible for breaking down the overall query into its respective common tiles, and build a Tile Specification detailing the crop and mosaic positioning.","A Tile Specification calculation enforces a divide-and-conquer approach, which is taken in respect to the mosaicking process. Of course, different image integration operations could be processed, including overlay and mosaic as juxtaposing images as tiles in a presentation window, which could require scaling, cropping, color conversion and position registration. In cropping processes, the graphics processing function trims the necessary portions of the image. This approach also alleviates memory costs by monitoring only the needed portions of each tile active in processing. Below is an example of a representative algorithm, written in pseudo-code, detailing the TQF processes within the method Tile Query Factory::create Queries( );",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"TileQueryFactory::createQueries Begin"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Initialize List of Future Submissions (TileQuery) returnList"]},{"entry":[{},"\/\/ Assume the user\/client parameters are loaded into the TQF"]},{"entry":[{},"WMSProxyParameters params"]},{"entry":[{},"\/\/ Get configuration from the system (e.g., Resolution Levels)"]},{"entry":[{},"WMSProxyConfig cfg <- get singleton proxy configuration"]},{"entry":[{},"\/\/ Determine DPP setting. Assuming DD Coordinates."]},{"entry":[{},"RealNumber xDistance <- params.SEPoint.x \u2212 params.NWPoint.x"]},{"entry":[{},"RealNumber yDistance <- params.NWPoint.y \u2212 params.SEPoint.y"]},{"entry":[{},"RealNumber xDPP <- xDistance (DD) \/ params.requestWidth (Px)"]},{"entry":[{},"RealNumber yDPP <- yDistance (DD) \/ params.requestHeight (Px)"]},{"entry":[{},"\/\/ Get the resolution level for a given layer and dpp value."]},{"entry":[{},"ResolutionLevel rlvl <- cfg.getResLvl (param.layer,"]},{"entry":[{},"min(XDPP,yDPP))"]},{"entry":[{},"RealNumber dpp <- rlvl.dpp"]},{"entry":[{},"\/\/ Adjust the start and end point for precision, this is used to"]},{"entry":[{},"\/\/ get the common tiles. Precision is currently 6 decimal points,"]},{"entry":[{},"\/\/ or IE6."]},{"entry":[{},"Integer sx <- params.NWPoint.x * params.precision"]},{"entry":[{},"Integer sy <- params.NWPoint.y * params.precision"]},{"entry":[{},"Integer ex <- params.SEPoint.x * params.precision"]},{"entry":[{},"Integer ey <- params.SEPoint.y * params.precision"]},{"entry":[{},"Integer adjDPP <- dpp * params.precision"]},{"entry":[{},"\/\/ Calculate degrees covered per tile at this resolution level"]},{"entry":[{},"\/\/ Incorporate padding for tile overlay and mosaic \u2018stitching\u2019."]},{"entry":[{},"Integer ddPerTile <- cfg.tileSize * adjDPP"]},{"entry":[{},"Integer ddjDDPerPadding <- cfg.padding * adjDPP"]},{"entry":[{},"Integer ddPerFullTile <- ddPertile + 2 * adjDDPerPadding"]},{"entry":[{},"\/\/ Calculate the step increments (assumes tiles are square)"]},{"entry":[{},"Integer stepX <- ddPrerTile + adjDDPerPadding"]},{"entry":[{},"Integer stepY <- stepX"]},{"entry":[{},"\/\/ Determine the minimum and maximum points x and y that the"]},{"entry":[{},"\/\/ tiles will have to cover. The floor and ceiling of the points"]},{"entry":[{},"\/\/ divided by ddPerTile ensure a common tile."]},{"entry":[{},"Integer minX <- floor(sx \/ ddPerTile) * ddPerTile;"]},{"entry":[{},"Integer maxX <- ceiling(ex \/ ddPerTile) * ddPerTile;"]},{"entry":[{},"Integer minY <- floor(sy \/ ddPerTile) * ddPerTile;"]},{"entry":[{},"Integer maxY <- ceiling(ey \/ ddPerTile) * ddPerTile;"]},{"entry":[{},"\/\/ Adjust the values for the padding on one side only."]},{"entry":[{},"minX <- minX \u2212 adjDDPerPadding"]},{"entry":[{},"minY <- minY \u2212 adjDDPerPadding"]},{"entry":[{},"maxX <- maxX \u2212 adjDDPerPadding"]},{"entry":[{},"maxY <- maxY \u2212 adjDDPerPadding"]},{"entry":[{},"\/\/ Calculate the raw image (tile mosaic) width and height"]},{"entry":[{},"\/\/ before cropping would be done."]},{"entry":[{},"Integer width <- round(maxX \u2212 minX) \/ ddPerTile"]},{"entry":[{},"Integer height <- round(maxY \u2212 minY) \/ ddPerTile"]},{"entry":[{},"\/\/ Determine the crop values."]},{"entry":[{},"LongInteger ddLeftCrop <- (sx \u2212 minx) * cfg.tileSize"]},{"entry":[{},"LongInteger ddTopCrop <- (maxY \u2212 ey) * cfg.tileSize"]},{"entry":[{},"LongInteger ddRightCrop <- (maxX \u2212 ex) * cfg.tilesize"]},{"entry":[{},"LongInteger ddBottomCrop <- (ey \u2212 winY) * cfg.tileSize"]},{"entry":[{},"\/\/ Convert crop values to pixels"]},{"entry":[{},"Integer leftTrim <- max(0, (ddLeftCrop \/ ddPerTile))"]},{"entry":[{},"Integer topTrim <- max(0, (ddTopcrop \/ ddPerTile))"]},{"entry":[{},"Integer rightTrim <- max(0, (ddRightCrop \/ ddPerTile))"]},{"entry":[{},"Integer bottomTrim <- max(0, (ddBottowCrop \/ ddPerTile))"]},{"entry":[{},"\/\/ Determine the cropped image size."]},{"entry":[{},"Integer croppedWidth <- width \u2212 leftTrim \u2212 rightTrim"]},{"entry":[{},"Integer croppedHeight <- height \u2212 topTrim \u2212 bottomTrim"]},{"entry":[{},"\/\/ Store these values in params for TQM, et al."]},{"entry":[{},"param.rawWidth <- croppedWidth"]},{"entry":[{},"params.rawHeight <- croppedHeight"]},{"entry":[{},"\/\/ declare the destination X position"]},{"entry":[{},"Integer destX <- 0"]},{"entry":[{},"\/\/ build and submit tile queries, determine the origin"]},{"entry":[{},"Loop x <- minX to maxX by step stepX"]},{"entry":[{},"\u2003\u2003Integer originX <- cfg.padding"]},{"entry":[{},"\u2003\u2003Integer cropWidth <- cfg.tileSize"]},{"entry":[{},"\u2003\u2003If Tile is left and right tile (single tile case)"]},{"entry":[{},"\u2003\u2003\u2003\u2003originX <- leftTrim"]},{"entry":[{},"\u2003\u2003\u2003\u2003cropWidth <- cfg.tileSize \u2212 rightTrim \u2212 leftTrim \u2212 2 *"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003cfg.padding"]},{"entry":[{},"\u2003\u2003Else if Tile is left tile"]},{"entry":[{},"\u2003\u2003\u2003\u2003originX <- leftTrim"]},{"entry":[{},"\u2003\u2003\u2003\u2003cropWidth <- cfg.tilesize \u2212 leftTrim + cfg.padding"]},{"entry":[{},"\u2003\u2003Else if Tile is right tile"]},{"entry":[{},"\u2003\u2003\u2003\u2003originX <- cfg.padding"]},{"entry":[{},"\u2003\u2003\u2003\u2003cropWidth <- cfg.tileSize \u2212 rightTrim + cfg.padding"]},{"entry":[{},"\u2003\u2003End if"]},{"entry":[{},"\u2003\u2003\/\/ Declare the destination Y position"]},{"entry":[{},"\u2003\u2003Integer destY <- croppedHeight"]},{"entry":[{},"\u2003\u2003Loop y <- minY to maxY by step stepY"]},{"entry":[{},"\u2003\u2003\u2003\u2003Integer originY <- cfg.padding"]},{"entry":[{},"\u2003\u2003\u2003\u2003Intgeer cropHeight <- cfg.tilesize"]},{"entry":[{},"\u2003\u2003\u2003\u2003If Tile is top and bottom tile (single tile case)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003originY <- topTrim"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003cropHeight <- cfg.tileSize \u2212 bottomTrim \u2212"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003topTrim + 2 * cfg.padding"]},{"entry":[{},"\u2003\u2003\u2003\u2003Else if Tile is top tile"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003originY <- topTrim"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003cropHeight <- cfg.tileSize \u2212 topTrim + cfg.padding"]},{"entry":[{},"\u2003\u2003\u2003\u2003Else if Tile is bottom tile"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003cropHeight <- tileSize \u2212 bottomTrim + cfg.padding"]},{"entry":[{},"\u2003\u2003\u2003\u2003End if"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Adjust the location on the Y axis"]},{"entry":[{},"\u2003\u2003\u2003\u2003destY <- destY \u2212 cropHeight"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Initialize a new tile specification"]},{"entry":[{},"\u2003\u2003\u2003\u2003Initialize TileSpec spec"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.cropHeight <- cropHeight"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.cropWidth <- cropWidth"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.originX <- originX"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.originY <- originY"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.destX <- destX"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.destY <- destY"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.tileSize <- cfg.tileSize"]},{"entry":[{},"\u2003\u2003\u2003\u2003spec.padding <- cfg.padding"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Create a bounding box based on the x\/y settings of loop"]},{"entry":[{},"\u2003\u2003\u2003\u2003RealNumber north <- x \/ cfg.precision"]},{"entry":[{},"\u2003\u2003\u2003\u2003RealNumber west <- y \/ cfg.precision"]},{"entry":[{},"\u2003\u2003\u2003\u2003RealNumber south <- x + ddPerFullTile \/ cfg.precision"]},{"entry":[{},"\u2003\u2003\u2003\u2003RealNumber east <- y + ddPerFullTile \/ cfg.precision"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ Append bounding box numbers in correct format to url"]},{"entry":[{},"\u2003\u2003\u2003\u2003String url <- params.url + bbox(north,west,south,east)"]},{"entry":[{},"\u2003\u2003\u2003\u2003Build new Tile Query thread with above parameters"]},{"entry":[{},"\u2003\u2003\u2003\u2003returnList.add(reference to new thread submission)"]},{"entry":[{},"\u2003\u2003End loop y"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003End Loop x"},{"entry":"Return the returnList"},{"entry":"End TQF TileQueryFactory::createQueries"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 2"},"In this map image, the dashed rectangular block in the middle represents the requested query area. \u03c4represents the common tile at a given resolution level. \u03a9w represents the raw composite (mosaic) width. \u03a9h represents the raw composite (mosaic) height.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 3","b":"1"},"In this map image, the implicit variables are Tile X position=0, Tile Y Position=0. The constants are Tile Size (W and H) and Padding (\u03b8). The Tile Specification for Tile  (\u03c4) is:","o.x\u03c4: Crop Origin X for Tile =P.x","o.y\u03c4: Crop Origin Y for Tile =P.y","\u03b4.x\u03c4: Destination X for Tile =0","\u03b4.y\u03c4: Destination Y for Tile =0","\u03c7.w\u03c4: Crop Width for Tile =w+2\u03b8\u2212P. x","\u03c7.h\u03c4: Crop Height for Tile =h+2\u03b8\u2212P.y",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 4","b":"2"},"In this map array, the implicit variables are Tile X Position=1 and Tile Y Position=0. The constants are Tile Size (W and H) and Padding (\u03b8). The Tile Specification for Tile  (\u03c4) is:","o.x\u03c4: Crop Origin X for Tile =P.x","o.y\u03c4: Crop Origin Y for Tile =P.y","\u03b4.x\u03c4: Destination X for Tile =\u03c7.w\u03c4","\u03b4.y\u03c4: Destination Y for Tile =\u03c7.h\u03c4","\u03c7.w\u03c4: Crop Width for Tile =w+2\u03b8\u2212P. x","\u03c7.h\u03c4: Crop Height for Tile =h+2\u03b8\u2212P.y",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 5","b":"6"},"In this map image, the implicit variables are Tile X Position=2 and Tile Y Position=1. The constants are Tile Size (W and H) and Padding (\u03b8). The Tile Specification for Tile  (\u03c4) is:","o.x\u03c4: Crop Origin X for Tile =P.x","o.y\u03c4: Crop Origin Y for Tile =P.y","\u03b4.x\u03c4: Destination X for Tile =\u03a9\u2212RIGHT TRIM","\u03b4.y\u03c4: Destination Y for Tile =\u03a9h\u2212BOTTOM TRIM","\u03c7.w\u03c4: Crop Width for Tile =w+2\u03b8\u2212RIGHT TRIM","\u03c7.h\u03c4: Crop Height for Tile =w+2\u03b8\u2212BOTTOM TRIM","The Tile Query Manager (TQM)  of the WMS Proxy is responsible for putting the tile query results together into a single Tile Mosaic. The TQM  is initialized with a list of references to currently executing queries. It will monitor the queries through grouped asynchronous threads, and will wait until the Tile Mosaic has been built before returning it to the caller. The diagram shown in  shows how the TQM spawns and waits for the tiles to be retrieved.","As shown in , the system includes various map tiles  and is initialized at step  with the Tile Retrieval Thread Group . For each thread in the list as shown at step , the TileRetrievalThread  operates. The process waits until the TileQuery is done as a step  in the process. The TileMosaic is built through TQM if it is not ready (i.e., not initialized) using the first available query information from a finished Tile Retrieval Thread (step ), and is operative with the TQM  and the TileMosaic . The Tile Result is added to the TileMosaic (step ) and the count in the group monitor is reduced by one to signal that the thread has completed in step . The TQM  is notified when the count reaches zero as a step .","The Image Manipulator Component (IMC)  () is, typically, a utility class. The IMC  is used to perform image processing functions. The IMC can use the Intel\u00ae Integrated Performance Primatives (IPP) library for image processing. The IPP, though efficient image processing, may have a relatively high overhead due to Java Native Invocation (JNI), as a Java-to-C++ (et al.) bridge, designed to allow Java applications to access non-Java libraries and code.","The removal of a JNI bridge occurs when IPP is no longer used.","The WMS Proxy  uses the IMC  for scaling and cropping functions. Image conversion and analysis are all available within the extensible framework of JAI. For scaling and cropping, as well as image holding, the architecture backs away from Java's Abstract Window Toolkit (AWT) objects, such as BufferedImage, which follow the \u201cpush\u201d model of image processing. Images are always loaded completely to memory before any processing commands are available. Instead of AWT, the baseline can use the RenderedImage interface of Java's Graphics2D\u2122\/JAI framework.","The RenderedImage interface (and related objects RenderedOp\/RenderableOp) follows the \u201cpull\u201d model of image processing. In this model, image processing commands are available at any time. Ideally, any processing commands for an image are added to a directed acyclic graph (DAG) before the image is loaded to memory. This approach permits efficient use of memory space, without the gluttony of many image objects needlessly remaining in scope.","Below is an example of the code used by the IMC  to crop images, as a non-limiting example. The ParameterBlock is a holder object, much like a list. The correct usage of this class is solely dependant on the JAI operation on which the block will be called:",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public static RenderedOp cropImage (RenderedOp img, TileSpec spec)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ Create the parameter block used to crop."},{"entry":"\u2003\u2003ParameterBlock pb = new ParameterBlock( );"},{"entry":"\u2003\u2003pb.addSource (img);"},{"entry":"\u2003\u2003pb.add((float)spec.theCropOriginX);"},{"entry":"\u2003\u2003pb.add((float)spec.theCropOriginY);"},{"entry":"\u2003\u2003pb.add((float)spec.theCropWidth);"},{"entry":"\u2003\u2003pb.add((float)spec.theCropHeight);"},{"entry":"\u2003\u2003\/\/ Create a rendered operation from the crop parameters."},{"entry":"\u2003\u2003return JAI.create (\u201ccrop\u201d, pb, null);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Below is an example of the code used by the IMC  to scale images. There is some similarity between the way the crop operation is called, and the way the scale operation is called. The ParameterBlock of the scale operation contains different settings (in count, and object class) than that of the crop operation:",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Note that TileMosaic is an extension of the RenderedOp class."},{"entry":"public static TiledImage scaleImage(TileMosaic rawImage,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003WMSProxyParameters parameters)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ Determine the scale"},{"entry":"\u2003\u2003float scaleX = (float)parameters.getRequestedWidth( ) \/"},{"entry":"\u2003\u2003\u2003\u2003(float) rawImage.getWidth( );"},{"entry":"\u2003\u2003float scaleY = (float)parameters.getRequestedHeight( ) \/"},{"entry":"\u2003\u2003\u2003\u2003(float) rawImage.getHeight ( );"},{"entry":"\u2003\u2003\/\/ Create the parameter block for scaling."},{"entry":"\u2003\u2003ParameterBlock pb = new ParameterBlock( );"},{"entry":"\u2003\u2003pb.addSource (rawImage);"},{"entry":"\u2003\u2003pb.add(scaleX);"},{"entry":"\u2003\u2003pb.add(scaleY);"},{"entry":"\u2003\u2003pb.add(0F);"},{"entry":"\u2003\u2003pb.add(0F);"},{"entry":"pb.add(Interpolation.getInstance(Interpolation.INTERP_BICUBIC_2));"},{"entry":"\u2003\u2003return new TiledImage(JAI.create(\u201cscale\u201d, pb), true);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Two-tier caching as part of the WMS proxy  is available as shown in the system block diagram of . One embodiment of the WMS Proxy architecture has the caching of image tiles located near the WMS Proxy. Active recent \u201chot\u201d image tiles could be available through the cache at a speed much faster than going directly to the related WMS system. However, in the best case, an http network call could be involved in the overall cost of image tile retrieval. It is desirable to control and delete individual image tiles that reside in the cache. The entire cache could be deleted, yet this broad approach is not sufficient control of \u201chot\u201d imagery.","The Java Caching System (JCS) is a distributed caching system written in Java by the Apache Jakarta project. Because it is written in Java, and because it is not a true stand-alone cache web application, the JCS could be implemented within the WMS Proxy , removing the http network call altogether.","The JCS could be implemented as an integrated cache providing near-zero access overhead to image tiles. JCS also provides complete control over every image tile that resides within it. The WMS Proxy cache could be between 1 GB and 100 GB in size, or even larger, and implemented in a Disk-Caching mode. With a very large cache disk allocation, and a large amount of users accessing cached data (e.g., the N-scale scenario, or high user-load case), it is very likely that the disk would be overloaded with access requests to disk objects. This not only would strain the JCS cache, but sub-sequentially, the WMS Proxy would suffer as well.","The http network call to a distributable cache application can actually be a benefit. Thus, a two-tier caching architecture is implemented into the WMS Proxy in one non-limiting example shown in .","A local integrated cache (JCS) is added to the WMS Proxy. The JCS would be tuned to best performance, in terms of disk space allocation to overall system cost. A failover cache would be distributed, as per the original design, to a separate caching application. This separate caching application would be the larger of the two tiers of caching. Also, because the utilized caching software, e.g., JCS, SQUID, et al., is laterally distributable (able to have sub-caches on other machines), the second-tier becomes plausibly scalable to fit any N-scale requirement.","Therefore, the integrated JCS becomes the \u201chot\u201d image tile repository, the second-tier cache (currently SQUID, but could be JCS) becomes the \u201cwarm\u201d image tile repository, and the backend will continue to exist in case of dual failover, as intented design for new image tile retrieval and cache storage.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 7","b":["90","92","94","90","96","98","92","99","99"]},"Referring now to , there is illustrated another embodiment in which the system is limited in management of the tile preparation on the server. Numbers begin in the 100 series. Those components and modules that are similar in function to the components and modules in the system shown in  are given common reference numerals beginning in the 100 series.","The system is illustrated at  and includes many of the basic components as set forth in the system shown in . Temporary file clean-up is administered and when fresh content is added to the WMS , the cache is flushed. This WMS implementation provides for the potential of significant scalability. The five basic components of the client , WMS proxy , network , classic WMS  and data  are illustrated. What differs from the preferred system of  is that a determination is made if the client can \u201ccatch\u201d the tiles . If not, the tiles are mosaicked and cropped with no resampling  and the map generated on the client . If yes, the tiles are assembled at the client  and a map generated on the client . The network option with the optional load balancer  remains the same with the classic WMS  and data  the same. Of course, tiles are returned to the cache  for caching.","Many modifications and other embodiments of the invention will come to the mind of one skilled in the art having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore, it is understood that the invention is not to be limited to the specific embodiments disclosed, and that modifications and embodiments are intended to be included within the scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects, features and advantages of the present invention will become apparent from the detailed description of the invention which follows, when considered in light of the accompanying drawings in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 8","FIG. 1A"]}]},"DETDESC":[{},{}]}
