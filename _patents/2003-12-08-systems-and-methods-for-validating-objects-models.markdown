---
title: Systems and methods for validating objects models
abstract: A metadata validation process that allows for deferring object model validation until after the objects are created. The process also allows for multi-threaded processing of the validation rules, thus increasing overall performance. Validation is performed by enforcing a series of validation rules on an appropriate subject. Rules are specified according to the subject that they are validating (i.e., attribute level, association level, object level or collection level). The metadata driven validation process implements several validation types on different validation units. Correctness validation rule types ensure that a validation unit satisfies all semantic rules defined for it. Completeness validation rule types ensure that a validation unit contains all the necessary data and is ready for further use. At design time, only correctness type validation is performed. Thus, the present invention advantageously allows for incomplete objects to be created at design time. The developer, however, in this case may opt to perform completeness validation at any time. In general, a developer may opt to perform completeness and/or correctness validation at any time independent of deployment processing. In another aspect, full validation (e.g., completeness and correctness) is automatically performed on the objects during the process of creating a configuration prior to deployment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865480&OS=07865480&RS=07865480
owner: Oracle International Corporation
number: 07865480
owner_city: Redwood Shores
owner_country: US
publication_date: 20031208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates generally to object-oriented programming and object models, and more particularly to validation of object models.","Object-oriented software is typically built on top of an object model. The object model provides a definition of entities in the system and their associations to each other. Unified Modeling Language (UML) is a modeling system that provides a means to specify, construct, document and visualize an object model. For example, UML diagrams are typically used to represent and document object models. The diagrams rendered in the display provide the user with a visual feedback that allows the user to simply and easily understand the model paradigm being created or implemented. However, UML is not powerful enough to define complex validation rules and constraints that fully describe a consistent object model.","Traditionally validation of objects is achieved by incorporating the validation logic into the programming logic responsible for maintaining the data in the system. Validation rules in this case are \u201chard-coded\u201d into the APIs (Application Programming Interfaces) and it is usually not possible to alter the behavior of such logic once the APIs have been developed.","Another approach is to formalize the definition of constraints on the object model by using Object Constraint Language (OCL). With this approach, the defined constraints are meant to be always satisfied, thus not allowing incorrect and incomplete data to be created. While satisfying the goal of having consistent data in the system, this approach is very inflexible for the developers of application logic because the specific methodology must be followed to create objects that do not violate system constraints.","Thus, there is a need for new systems and methods for describing and enforcing validation rules for an object model. Such systems and methods should also allow for flexibility in designing objects and in determining when validation processes are invoked.","The present invention provides systems and methods for describing and enforcing validation rules for an object model. Such systems and methods provide for much flexibility in the design of objects and in the invocation of validation processes.","According to the present invention, a validation process is provided that is applicable to any object model. The process is metadata driven, thus allowing for existing unit definitions and validation rules to be edited, and for new rules to be defined. The process allows for deferring object model validation until after the objects are created. The process also advantageously allows for the user to create incomplete objects in a design environment. For example, when the user is ready to define an agreement, he\/she may not have all the information which is required for the participants in the agreement. The present invention advantageously allows the user to define the agreement with incomplete but correct information. In order for the agreement to be effective and for the partners to do business, however, the agreement has to be completely defined. Since it is not desirable to have runtime errors due to incomplete information, the present invention also advantageously provides for automatic validation upon deployment (and for the user to select validation at any time) to determine whether the objects that are to be deployed form a complete set and whether the semantics of objects in the set is indeed correct.","The process also allows for multi-threaded processing of the validation rules, thus increasing overall performance. According to one aspect, validation is performed by enforcing a series of validation rules on an appropriate subject. Rules are specified according to the subject that they are validating (i.e., attribute level, association level, object level or collection level). A metadata validation engine is used to execute these rules during the validation process.","According to one aspect of the present invention, a metadata driven validation process implements several validation types on different validation units. In one aspect, two validation rule types are provided\u2014correctness and completeness types. The correctness validation rule type ensures that a validation unit satisfies all semantic rules defined for it. The completeness validation rule type ensures that a validation unit contains all the necessary data and is ready for further use. In one aspect, at design time, only correctness type validation is performed. Thus, the present invention advantageously allows for incomplete objects to be created at design time. The developer, however, in this case may opt to perform completeness validation at any time. In general, a developer may opt to perform completeness and\/or correctness validation at any time independent of deployment processing. In another aspect, full validation (e.g., completeness and correctness) is automatically performed on the objects prior to deployment processing.","In one aspect, the validation process for an object model is based on \u201cdivide-and-conquer\u201d principle; the model is divided into several levels of validation units. Each unit is validated independently by the validation process. The complete object model is valid if all of the validation units defined for it are valid individually. In one aspect, the highest level of validation unit is a collection of objects. The set of objects which compose a collection is computed, in one aspect, by a separate metadata driven process. This \u2018separate process\u2019 in one aspect is a combination of the execution of queries described later as well as an independent algorithm that traverses an object model from a given root object to produce what is referred to as a \u201ctransitive closure\u201d. A collection forms a complete and well formed set of objects. A collection may also be composed of other collections. The next level of validation unit is a single, individual object. Further levels are defined for the attributes and associations of an individual object.","The validation process defines a sequence of operations necessary to establish the validity of a given validation unit. The process uses metadata created by a model developer to inquire on the different validation units in the model and the rules to be applied to them. Composite units are validated for a specified type. All members of composite units are also validated for the same type.","According to an aspect of the present invention, a computer-implemented method is provided for validating metadata in an object model stored in a database. The method typically includes identifying a first subject of validation, wherein the first subject is one of an object, an attribute, an association and a collection of objects, and determining a context of metadata validation based on the first subject, the context including one of a) the first subject, and b) the first subject and one or more additional subjects. The method also typically includes determining one or more validation rules for each subject in the context, and applying the determined validation rules to each subject in the context.","According to another aspect of the present invention, a metadata validation system is provided for validating an object model. The system typically includes a database that stores the objects and metadata of the object model, a means for identifying a first subject of validation, wherein the first subject type is one of an object, an attribute, an association and a collection of objects, and a means for determining a context of metadata validation based on the first subject, the context including one of a) the first subject, and b) the first subject and one or more additional subjects. The system also typically includes a means for determining one or more validation rules for each subject in the context, and a means for applying the determined validation rules to each subject in the context.","According to yet another aspect of the present invention, a method is provided for validating metadata in an object model in a database. The method typically includes receiving user defined rules, each rule defining a validation rule on a meta metadata object, each rule being one of a completeness type rule and a correctness type rule, storing the validation rules to the database, and identifying a first subject of metadata validation, wherein the first subject has a subject type selected from the group consisting of an attribute, an association, an object and a collection of objects. The method also typically includes determining a context of validation based on the first subject, wherein the context includes the first subject and none, one or more additional subjects, determining one or more validation rules for each subject in the context based on the subject type of each subject, and applying the validation rules to each of the determined subjects.","In certain aspects, each subject is a meta metadata object selected from the group consisting of a MetaAttribute, a MetaAssociation, a MetaAssociationEnd, a MetaClass and a MetaCollection.","Reference to the remaining portions of the specification, including the drawings and claims, will realize other features and advantages of the present invention. Further features and advantages of the present invention, as well as the structure and operation of various embodiments of the present invention, are described in detail below with respect to the accompanying drawings. In the drawings, like reference numbers indicate identical or functionally similar elements.","According to the present invention, systems and methods are provided for implementing metadata validation. Metadata validation is the validation of metadata in a data repository, such as a database. A metadata validation framework provides a means for performing metadata validation on a given subject within a specified context.","General Definitions and Concepts","The subject of metadata validation is the meta metadata object on which a validation rule is defined. In general, the following terms are used herein to describe meta metadata objects: MetaClass, MetaCollection, MetaAttribute, MetaAssociation, MetaAssociationEnd. A MetaClass is an object used to represent a model class. A MetaCollection is a concept used to represent a collection of MetaClass objects. A MetaAttribute is an object used to represent a single attribute of a MetaClass object. A MetaAssociation is an object used to represent an association between two MetaClass objects. A MetaAssociationEnd is an object used to represent one end of a MetaAssociation object. A Subject Type class object is used to represent a MetaAttribute, a MetaAssociation, a MetaAssociationEnd, a MetaClass, and a MetaCollection.","For example, if a validation rule enforces that all business process names start with \u2018BP\u2019, then the rule is on the MetaAttribute for attribute \u2018name\u2019 in class BusinessProcess. The following are the various types of subjects for whom validation rules are applied in one aspect:\n\n","The Collection subject type is further subdivided into two different categories:\n\n","The context of metadata validation represents the instances of object(s) which are provided to the validation framework at the time of metadata validation for whom validation rules are to be applied.","Table 1 describes the semantics of the different levels of validations according to one embodiment. The classification of these levels is based on the subject of validation and its context.",{"@attributes":{"id":"p-0028","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Level of","Subject of",{}]},{"entry":["Validation","Validation","Context of Validation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attribute","MetaAttribute","Instance of the Object"]},{"entry":[{},{},"containing the Attribute"]},{"entry":["Association","MetaAssociation","Instance(s) of the Object(s) on one"]},{"entry":[{},{},"or both ends of the Association"]},{"entry":["Object","MetaClass","Instance of the Object"]},{"entry":["Collection","MetaCollection","Root object instance and instances"]},{"entry":[{},{},"of all objects in the collection"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Association level validations are performed in one aspect by having the subject of validation be MetaAssociationEnd. The validation context is the object instances at both MetaAssociationEnds of the corresponding MetaAssociation. Implementing association level rules in this manner advantageously avoids impacting the data repository to support pure association level rules. A single rule on an association is implemented by applying two rules, one to each object at both ends of the association. Such rules are invoked when the objects are first associated or when they are modified.","According to one embodiment, two types of validation rules are provided: correctness and completeness rule types. Correctness type rules determine whether the subject of metadata validation is correct (e.g., the first character in a string is an alphanumeric character, or a special string field has only a specified number of characters). Completeness type rules determine whether the subject of metadata validation is complete (i.e., the subject is ready to be deployed). In one aspect, completeness is determined only for an object or for a collection of objects. Thus, in this aspect, validation rules for attributes and associations are correctness rules whereas validation rules for objects or collections might be either classified as correctness or completeness or both. Tables 2 and 3 show examples of validation performed for various levels of validation for correctness and completeness rules according to one embodiment. In another aspect, completeness rules are defined at the attribute and association levels. An example of an attribute level completeness rule is whether an attribute of an object is defined (i.e., has a non-null value). An example of an association level completeness rule would be that an association between two objects must exist.",{"@attributes":{"id":"p-0031","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Correctness Validation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Level of",{}]},{"entry":[{},"Validation","Validation Performed"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Attribute","Type validation."]},{"entry":[{},"Association","Type validation."]},{"entry":[{},"Object","Semantic validity of the object. All attribute"]},{"entry":[{},{},"values form a consistent set."]},{"entry":[{},"Collection","Semantic validity of root object."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0032","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Completeness Validation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Level of",{}]},{"entry":[{},"Validation","Validation Performed"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Object","Deployment readiness of the object and all objects"]},{"entry":[{},{},"strongly aggregated to it recursively."]},{"entry":[{},"Collection","Deployment readiness of the transitive closure of"]},{"entry":[{},{},"the root object."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"According to one embodiment, invocation of validation rules is based on the type of validation rule. Correctness validation is performed implicitly by the UT when objects are first created or are updated at design time. This ensures that the design time metadata is correct. Correctness and completeness validation are performed implicitly during the process of creating a configuration to determine if objects at design time are ready to be deployed. Correctness and completeness validation may also be performed explicitly by the user using the UI. Tables 4 and 5 illustrate invocation of validation rules from a user point of view.",{"@attributes":{"id":"p-0034","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Correctness"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Level of",{}]},{"entry":[{},"Validation","Performed When and By Whom"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Attribute","Implicitly by the UI when the attribute is set"]},{"entry":[{},"Association","Implicitly by the UI when the association is set"]},{"entry":[{},"Object","Implicitly by the UI when the object is either"]},{"entry":[{},{},"created or updated"]},{"entry":[{},"Collection","Explicitly by the user"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0035","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Completeness"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Level of",{}]},{"entry":[{},"Validation","Performed When and By Whom"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Object","Explicitly by the user or implicitly by the UI"]},{"entry":[{},"Collection","Implicitly during the creation of a configuration"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In one embodiment, Metadata is classified into two categories: modeling metadata and profile metadata. Modeling metadata include type definitions for process modeling, e.g., business process modeling. Profile metadata includes the metadata related to entities such as, for example, Agreements, Applications and TradingPartners.","A configuration is a collection of modeling and profile metadata that is consistent and complete (as determined by metadata validation) and which can be deployed. A configuration represents all of the objects (e.g., a business process) that are required to be deployed for that configuration to run. Hereafter, this shall also be referred to as a deployment unit. That is, a configuration is a verified and complete deployable unit (e.g., business process) that contains all of the metadata necessary for that configuration to execute at runtime. Configurations are typically created at design time, when a user decides to model a process (e.g., business process) that needs to be deployed, and can be validated by the metadata validation process prior to deployment.","Deployment is a process that takes a validated configuration from a design time context to a runtime context, e.g., by transferring the design time configuration metadata to a runtime context for execution, in one embodiment.","System Framework Architecture",{"@attributes":{"id":"p-0040","num":"0046"},"figref":["FIG. 1","FIG. 1"],"b":["12","14","16","12","12","12","16","16"]},"Network  can be a LAN (local area network), WAN (wide area network), wireless network, point-to-point network, star network, token ring network, hub network, or other configuration. One of the most common type of network in current use is a TCP\/IP (Transfer Control Protocol and Internet Protocol) network such as the global internetwork of networks often referred to as the \u201cInternet\u201d with a capital \u201cI\u201d. For example, user systems  might communicate with system  using TCP\/IP and, at a higher network level, use other common Internet protocols to communicate, such as HTTP, FTP, AFS, WAP, etc.","Several elements in the system shown in  include conventional, well-known elements that need not be explained in detail here. For example, each user system  could include a desktop personal computer, workstation, laptop, PDA, cell phone, or any WAP-enabled device or any other computing device capable of interfacing directly or indirectly to the Internet or other network connection. User system  typically runs a client interface module, such as an HTTP client, e.g., a browsing program, such as Microsoft's Internet Explorer\u2122 browser, Netscape's Navigator\u2122 browser, Opera's browser, or a WAP-enabled browser in the case of a cell phone, PDA or other wireless device, or the like, allowing a user (e.g., object model developer) of user system  to access, process and view information and pages available to it from system  over network . Each user system  also typically includes one or more user interface devices, such as a keyboard, a mouse, touch screen, pen or the like, for interacting with a graphical user interface (GUI) provided on a display (e.g., monitor screen, LCD display, etc.) in conjunction with pages, forms and other information provided by system  or other systems or servers. The client interface module of system  typically implements or interfaces with a presentation layer  (). As discussed above, the present invention is suitable for use with any type of network such as the Internet, an intranet, an extranet, a virtual private network (VPN), a non-TCP\/IP based network, any LAN or WAN or the like.","According to one embodiment, each user system  and all of its components are operator configurable using applications, including computer code run using a central processing unit such as an Intel Pentium processor or the like. Similarly, system  and all of their components might be operator configurable using application(s) including computer code run using a central processing unit such as an Intel Pentium processor or the like, or multiple processor units. Computer code for operating and configuring system  to intercommunicate and to process tables, pages and other data and media content as described herein is preferably downloaded and stored on a hard disk, but the entire program code, or portions thereof, may also be stored in any other volatile or non-volatile memory medium or device as is well known, such as a ROM or RAM, or provided on any media capable of storing program code, such as a compact disk (CD) medium, digital versatile disk (DVD) medium, a floppy disk, and the like. Additionally, the entire program code, or portions thereof, may be transmitted and downloaded from a software source, e.g., over the Internet, or from another server, as is well known, or transmitted over any other conventional network connection as is well known (e.g., extranet, VPN, LAN, etc.) using any communication medium and protocols (e.g., TCP\/IP, HTTP, HTTPS, Ethernet, etc.) as are well known. It will also be appreciated that computer code for implementing aspects of the present invention can be implemented in any programming language that can be executed on a server or server system such as, for example, in C, C++, HTML, Java, JavaScript, or any other scripting language, such as VBScript. It is appreciated that the code for implementing the metadata validation processes of the present invention may also be stored and executed on a standalone system, with no network connection.","According to one embodiment, metadata validation system  includes a database system  for storing objects and data according to various object schema. If more than one database system is used, they may be located in close proximity to one another (e.g., in a server farm located in a single building or campus), or they may be distributed at locations remote from one another (e.g., one or more servers located in city A and one or more servers located in city B). The metadata validation system , in one aspect, could be implemented in a standalone system with an associated data storage repository or database, or it could include one or more logically and\/or physically connected servers distributed locally or across one or more geographic locations. Additionally, the term \u201cserver\u201d is meant to include a computer system, including processing hardware and process space(s), and an associated database storage system and database application as is well known in the art. It should also be understood that \u201cserver system\u201d and \u201cserver\u201d may be used interchangeably herein. Similarly, the databases described herein can be implemented as single databases, a distributed database, a collection of distributed databases, a database with redundant online or offline backups or other redundancies, etc., and might include a distributed database or storage network and associated processing intelligence.",{"@attributes":{"id":"p-0045","num":"0051"},"figref":"FIG. 2","b":["16","16","40","40","40","20","12","25","40","30","35"]},"Thus, in one aspect, a user, using a browser, interacts with a GUI (referred to as the presentation layer  in ) to create design time metadata in a data repository (i.e., a database ). The GUI interacts with the metadata validation system either implicitly or explicitly from a user's point of view. Implicitly, the GUI invokes metadata validation when objects are either first created or updated by a user. Explicitly, a user may use the GUI to invoke the metadata validation system in at least two ways. One way is by selecting, e.g., a \u2018Validate\u2019 button on a GUI screen. Another way is through the process of creating a configuration. The configuration manager  invokes the metadata validation system prior to creating a configuration. Again, this is done explicitly through the GUI. Once a valid configuration is created, the deployment manager is invoked to deploy the metadata into a runtime context.","Validation rules module  includes rules that define certain validation criteria that are to be applied to a validation subject. Validation queries module  includes logic which, when executed by validation engine , retrieves lists of objects, some being subjects for which validation rules may need to be evaluated. These queries are also used to retrieve sets of objects that, when combined, form transitive closures based on a given root object. A \u2018separate process\u2019 or algorithm is used in conjunction with these queries to compute the transitive closure (referred to as the deployment unit). The computation of the deployment unit is required not only by the validation engine , but also by the configuration manager .","The validation engine  is invoked by calling one of its APIs to validate either an individual object (e.g., the aggregated collection whose root object is the object specified) or to validate a deployable collection. Other APIs can be used to obtain sets of objects that form transitive closures based on a supplied root object (e.g., a deployable business process).","During validation, when validation engine  invokes a rule from rules module , the rule invokes use case APIs supplied by the business logic layer (BLL)  to access information about the subject of the rule and also to traverse associations starting from that subject to other related objects that are relevant to the evaluation of the rule. In some cases, a rule will use the query\/predicate manager (QPM) module  to execute a query against the database  when evaluating a rule. The BLL  and QPM  extract the information from the database  through the repository\/persistency services module .","In one aspect, validation queries, given a specified object, are used to produce a list of target objects associated with that specified object. All queries traverse the model's relevant associations starting from the specified object to a target object. In one aspect, validation rules and queries are implemented in Java according to a specific template. In this aspect, all Java rules and queries preferably have the same signature and pre and post processing. The actual implementation of the rule itself is written by a developer after the pre-processing and before the post-processing phases of the rule in the body of the rule function. In another aspect, queries are written using a simple meta-language (METALANG) that captures the specified target object itself and in some cases a single association to a target object.","The Validation Seed Task  is executed by a system seed driver during installation of the system and is a seeding task that stores all non-generated validation metadata in the data repository . This metadata defines subjects, rules, etc., and their associations. Some of the validation seed data are created and pre-seeded as part of the normal model generation process. In one aspect, only the MetaClasses, MetaAttributes, MetaAssociations, MetaAssociationEnds and their names, etc. are pre-seeded. In this aspect, none of the validation metadata that is required by the validation system is pre-seeded. This is done by the Validation Seed Task . The remaining seed data are created during the validation seeding task using use cases generated during a prior seed task. In general, the Validation Seed Task  uses the BLL  to create subjects and rules, etc. and to make the necessary associations between them so as to provide the necessary metadata for use by the validation engine . For example, in one aspect, the Validation Seed Task  creates SubjectTypes, ValidationRules and SubjectTypeMembers using the metadata that is pre-seeded during model generation and sets the various associations between these objects. This populates the repository  described by the schema shown in . During the validation process, validation engine  queries the validation and design time metadata to determine which queries need to be executed and which rules need to be evaluated for a given subject. The appropriate Java query and rule functions are executed by supplying that function's requisite parameters.","Validation Schema",{"@attributes":{"id":"p-0053","num":"0059"},"figref":"FIG. 3"},"As shown in , the SubjectType class  is used to represent a subject of validation. The SubjectType class  aggregates the ValidationRule class . For each subject there can exist multiple rules associated with that subject. Table 6 illustrates an example of a SubjectType class definition.",{"@attributes":{"id":"p-0055","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SubjectType"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attribute",{},"Not",{},{}]},{"entry":["Name","Type","Null","Unique","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["name","String(255)","Y","Y","The name of the"]},{"entry":[{},{},{},{},"subject"]},{"entry":["description","LargeString",{},{},"User readable des-"]},{"entry":[{},{},{},{},"cription of the"]},{"entry":[{},{},{},{},"subject"]},{"entry":["type","SubjectTypeDomain","Y","Y","The type of the"]},{"entry":[{},{},{},{},"subject"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The SubjectTypeDomain class  is a domain object whose valid values are used to determine the type of the subject. Table 7 illustrates an example of a SubjectTypeDomain class definition.",{"@attributes":{"id":"p-0057","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SubjectTypeDomain"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Valid Value","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"ATTRIBUTE","The subject is an individual"]},{"entry":[{},{},"attribute of an instance of"]},{"entry":[{},{},"a MetaClass"]},{"entry":[{},"ASSOCIATIONEND","The subject is one end of an"]},{"entry":[{},{},"association between two"]},{"entry":[{},{},"instances of MetaClass"]},{"entry":[{},{},"objects"]},{"entry":[{},"OBJECT","The subject is an instance"]},{"entry":[{},{},"of a MetaClass"]},{"entry":[{},"AGGREGATEDCOLLECTION","The subject is a root object"]},{"entry":[{},{},"instance and all object"]},{"entry":[{},{},"instances strongly aggregated"]},{"entry":[{},{},"to it"]},{"entry":[{},"DEPLOYABLECOLLECTION","The subject is a root object"]},{"entry":[{},{},"instance and all objects"]},{"entry":[{},{},"associated with it transitively"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Note that the name of a subject depends on and is, in many cases, derived from the SubjectTypeDomain of that subject. Table 8 describes how to interpret the name of a subject according to one aspect.",{"@attributes":{"id":"p-0059","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Interpreting the Name of a Subject Type"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SubjectTypeDomain","Name of the Subject Type"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","<Name of the Subject's"]},{"entry":[{},"MetaClass>.<Name of the"]},{"entry":[{},"Attribute>"]},{"entry":["ASSOCIATIONEND","<Name of the Subject's"]},{"entry":[{},"MetaClass>.<Name of the"]},{"entry":[{},"AssociationEnd>"]},{"entry":["OBJECT","<Name of the Subject's"]},{"entry":[{},"MetaClass>"]},{"entry":["AGGREGATEDCOLLECTION","<Name of the First Class"]},{"entry":[{},"object's MetaClass>"]},{"entry":["DEPLOYABLECOLLECTION","MetaCollectionConstants.<Deployable"]},{"entry":[{},"MetaCollection Constant>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"So, for example, the name of the subject for a rule applied to the \u201cname\u201d attribute of a business process might read, \u201cTIP_BusinessProcess.name\u201d. For DEPLOYABLECOLLECTION, the description mentions \u2018MetaCollectionConstants\u2019 which is a file that contains the names of all Deployable Collections. For example, in this file there is a constant called DEPLOYABLEBUSINESSPROCESS that has the String value of \u201cDeployableBusinessProcess\u201d.","The ValidationRule class  is used to represent a validation rule in the system. The ValidationRule class  is aggregated by the SubjectType class  and only exists in the context of a validation subject. For a given validation rule, there can be only one subject. Table 9 illustrates an example of a ValidationRule class definition.",{"@attributes":{"id":"p-0062","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ValidationRule"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Not",{},{}]},{"entry":["Attribute Name","Type","Null","Unique","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["validationNumber","String(100)","Y","Y","The number of the validation rule"]},{"entry":["name","String(255)","Y",{},"The name of the validation rule"]},{"entry":["description","LargeString",{},{},"User readable description of the"]},{"entry":[{},{},{},{},"validation rule"]},{"entry":["errorKey","String(255)","Y",{},"The key of the entry in the"]},{"entry":[{},{},{},{},"resource bundle that contains the"]},{"entry":[{},{},{},{},"error message shown when the"]},{"entry":[{},{},{},{},"rule fails"]},{"entry":["functionName","String(255)","Y",{},"The name of the Java method that"]},{"entry":[{},{},{},{},"implements the rule's logic"]},{"entry":[{},{},{},{},"(PL\/SQL may also be used)"]},{"entry":["enforcementType","EnforcementType","Y",{},"The type of enforcement (i.e."]},{"entry":[{},{},{},{},"CORRECTNESS or"]},{"entry":[{},{},{},{},"COMPLETENESS)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The SubjectTypeMember class  is used to represent membership in different ways, such as, for example, membership of a MetaClass in a MetaCollection and membership of a MetaCollection in another MetaCollection. For example, since a role can be composed of multiple steps, a \u201cStep\u201d MetaClass might be a member in a \u201cRole\u201d MetaCollection. As another example, since a business process can involve multiple roles, a \u201cRole\u201d MetaCollection might be a member in a \u201cBusinessProcess\u201d MetaCollection. Table 10 illustrates an example of a SubjectTypeMember class definition.",{"@attributes":{"id":"p-0064","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SubjectTypeMember"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attribute",{},"Not",{},{}]},{"entry":["Name","Type","Null","Unique","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["name","String(255)","Y","Y","The name of the subject type member"]},{"entry":["description","LargeString",{},{},"User readable description of the subject type"]},{"entry":[{},{},{},{},"member"]},{"entry":["functionType","FunctionType","Y",{},"The type of the function that implements the"]},{"entry":[{},{},{},{},"query. The values are limited to those"]},{"entry":[{},{},{},{},"specified in the FunctionType domain object,"]},{"entry":[{},{},{},{},"e.g., JAVA and METALANG."]},{"entry":["functionName","String(255)",{},{},"For JAVA function types, the name of the Java"]},{"entry":[{},{},{},{},"method that implements the rule's logic"]},{"entry":["instanceQuery","LargeString",{},{},"For METALANG function types, the query to"]},{"entry":[{},{},{},{},"obtain object instances of the appropriate"]},{"entry":[{},{},{},{},"subject type (i.e, MetaClasses and\/or"]},{"entry":[{},{},{},{},"MetaCollections)."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"One of either the \u2018functionName\u2019 or the \u2018instanceQuery\u2019 attributes should be defined depending on the value of the \u2018functionType\u2019 attribute (i.e., \u2018functionName\u2019 for JAVA function types and \u2018instanceQuery\u2019 for METALANG function types).","Validation Rule Design","An example of a design pattern used to implement validation rules according to one embodiment is as follows:",{"@attributes":{"id":"p-0068","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"public static boolean < Rule Name > ("}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BusinessObject obj, SubjectType type, String ruleID, List errors)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"< Prologue >"]},{"entry":[{},"int status = < Succeeded >;"]},{"entry":[{},"try {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"< Implementation of the Validation Rule >"]},{"entry":[{},"if (status =\u2009= < Failure >)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"errors.add( new ValidationError(obj, type, ruleID,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"< Message Substitutions >) );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"catch (Exception e) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"throw new IPRuntimeException(< Error Key >, e);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"< Epilogue >"]},{"entry":[{},"return ( status =\u2009= < Succeeded > );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In one aspect, the actual implementation of a rule is performed using a client, e.g., client .","A validation rule enforces a single criteria on its subject. Executing a validation rule, in effect, enforces the criteria on that subject. Validation rules are preferably grouped according to their associated subject (i.e., all collection rules applied to a specific subject are grouped in a file (e.g., Java file) strictly devoted to containing collection rules that are to be applied on that subject).","Each validation rule preferably has a single error message associated with it that is to be displayed in the event that the rule fails. This message may or may not have substitution parameters associated with it. In one aspect, each error message is identified using a unique key (e.g., as shown by the \u2018<Error Key>\u2019 above).","In one aspect, each validation rule takes, as input parameters from the validation engine , the following objects:\n\n","The BusinessObject is used by a client when implementing the body of the validation rule. The SubjectType is used to determine the type of the subject as well as what kind of validation rule is being executed (e.g., an Attribute rule when the type of the subject is a MetaAttribute). The List is supplied so that the validation engine  is able to accumulate all validation errors that occur during the validation process. For each error, a new ValidationError object is added to this list. The Id of the ValidationRule, in addition to the other parameters, is used when creating a new instance of a ValidationError should the rule fail. When needed, a BLL API is called to retrieve the actual ValidationRule associated with the ruleId.","The \u2018Prologue\u2019 portion of each validation rule logs information about the subject and the rule using the Diagnostic Service for tracing\/debugging purposes. Parameters are checked for null and any local parameters common to all rules are also declared and initialized during this prologue (e.g., the error message substitutions array).","The \u2018Implementation\u2019 of the rule is written by a client. Each rule is different so the execution of each rule will vary based on the criteria that the rule is trying to enforce. The implementation uses the BLL to access data stored in the database  about the subject and any associated objects that are needed in order to execute the rule. Part of the job of the client when writing the rule is to set the status of the rule and also provide the necessary message substitutions (if any) in the event that the rule fails.","The \u2018Epilogue\u2019 portion of each validation rule logs information about the rule and the status of that rule after it has executed using the Diagnostic Service (e.g., whether or not the rule succeeded or failed for the given subject) for tracing\/debugging purposes.","The output of each validation rule is preferably a boolean flag that indicates whether or not the rule succeeded (i.e., \u2018true\u2019) or failed (i.e., \u2018false\u2019). In the event that the rule fails, a new ValidationError object describing that failure is added to the running list of ValidationError objects. If an unexpected exception occurs during the execution of a rule, an exception is thrown.","Validation Query Design","An example of a design pattern for validation queries (implemented in Java) according to one embodiment is as follows:",{"@attributes":{"id":"p-0080","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public static List < From Object >TO< To Object > (BusinessObject bo)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (bo =\u2009= null)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"throw new IPRuntimeException"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"( < Error Key >, new IllegalArgumentException(\u2009) );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"List list = new ArrayList(\u2009);"]},{"entry":[{},"< Add all \u2018To Object\u2019 instances reachable from the \u2018From Object\u2019 >"]},{"entry":[{},"return list;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Queries are implemented based on the underlying model and are typically written by developers. Queries are used by the validation engine  to help produce a transitive closure (i.e., a complete set of deployable objects) based on the \u2018From Object\u2019 acting as the \u2018root\u2019 object. As described herein, the queries are used in conjunction with a separate process (algorithm) that, with the combined results, produce the transitive closure (or \u2018deployable unit\u2019).","The input to the (Java) query is a BusinessObject instance (e.g., the \u2018root\u2019 object of the deployment unit). A query traverses all associations from the \u2018From Object\u2019 to the \u2018To Object\u2019 and proceeding through any and all intermediate objects (e.g., intersection objects). The implementation of each query varies and depends on the starting \u2018From Object\u2019 and to which \u2018To Object\u2019 the query must traverse. Some queries may be more straightforward than others, and can be much more complicated depending on the underlying model and the relationship between the \u2018From Object\u2019 and the \u2018To Object.\u2019 The set of objects produced by each query is a subset of the overall deployment unit. These subsets are combined (with the results of a separate algorithm) to form a complete deployment unit.","Each query returns a List of all \u2018To Object\u2019 instances that are reachable from the \u2018From Object\u2019 by traversing all associations through the model starting from that \u2018From Object\u2019. If the \u2018From Object\u2019 is null upon entering a query, an exception is thrown.","Validation Seed Task Design","The Validation Seed Task module  is responsible for seeding all of the validation metadata that is not already pre-seeded during the model generation process. During model generations some of the validation metadata is pre-seeded. The Validation Seed Task module  seeds all ValidationRules , SubjectTypes , SubjectTypeMembers  and the various associations between these objects.","The Validation Seed Task  is incorporated into a standard System Seed Driver, and has no inputs. During validation seed task processing, an API, e.g., ValidationSeedTask.doWork( ) API, is invoked by the SystemSeedDriver. Using the BLL , all validation metadata not already pre-seeded by the model generation process is seeded. SubjectTypes, including all Aggregated and non-Aggregated MetaCollections are seeded. All Attribute, AssociationEnd, Object and MetaCollection rules are also created and associated with their respective SubjectType. Each SubjectTypeMember  is also created and associated with a SubjectType  accordingly.","According to one aspect, an example of a pattern for creating all Deployable MetaCollections is as follows:",{"@attributes":{"id":"p-0088","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"SubjectType st = (SubjectType)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"getObject(SubjectType.class, < Name of MetaCollection's"]},{"entry":[{},"MetaClass >);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"e.g. getObject(SubjectType.class, \u201cTIP_BusinessProcess\u201d)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"SubjectType metaCollection ="}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"createMetaCollection(<MetaCollection Name>, <Description>, st);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"e.g. DeployableBusinessProcessMC ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"createMetaCollection"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(\u201cDeployableBusinessProcess\u201d,"]},{"entry":[{},"\u201cA complete Business Process deployable"]},{"entry":[{},"unit\u201d, st)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"putObject(SubjectType.class,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<MetaCollection Name>, <MetaCollection SubjectType>);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"e.g. putObject(SubjectType.class,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cDeployableBusinessProcess\u201d,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"DeployableBusinessProcessMC)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The \u2018createMetaCollection\u2019 API creates the MetaCollection SubjectType of type \u2018DEPLOYABLECOLLECTION\u2019 and associates the SubjectType representing the MetaClass of that MetaCollection (i.e., the SubjectType instance, \u2018st\u2019 which has already been seeded). A Deployable MetaCollection SubjectType must first be created before any rules can be associated with it. Note that the name of Deployable MetaCollections must match the String in the MetaCollectionContants.java file which contains the names of all Deployable Collections (e.g., MetaCollectionConstants.DeployableBusinessProcess in this case). For Aggregated MetaCollections, the name must be the same as the pre-seeded SubjectType name for that Aggregated MetaCollection. In one aspect, aggregated MetaCollection SubjectTypes are created for each First Class object in the object model, and the name of each Aggregated MetaCollection is the name of the MetaClass representing that First Class object.","According to one aspect, an example of a pattern for creating a validation rule on a SubjectType is as follows",{"@attributes":{"id":"p-0091","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"SubjectType st = (SubjectType)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"getObject(SubjectType.class, < Name of the SubjectType >);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"e.g. getObject(SubjectType.class,"]},{"entry":[{},"\u201cTIP_BusinessProcess.name\u201d)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"createRule"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(st, <Rule Number>, <Error Key>, <Function Name>,"]},{"entry":[{},"<Enforcement Type>);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"e.g. createRule"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(st, \u201cruleATTR1_1\u201d, \u201cDVR_ATTR1_1\u201d,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u201coracle.tip.buslogic.validation.rules.AttributeRules::ruleATTR1_1\u201d,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EnforcementType.CORRECTNESS);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The input parameters include Rule Number, Error Key, Function Name and Enforcement Type. The rule's name is the name of the rule that is derived from a combination of the SubjectType name and the rule number, e.g., \u201cTIP_BusinessProcess.name::ruleATTR11\u201d. Rule Number is the unique number of the rule. Error Key is the key of the entry in the resource bundle that contains the error message associated with this rule. Note that the prefix for the validation error message bundle is \u201cDVR\u201d in this example. Function Name is the fully qualified name of the (Java) function that implements this rule, e.g., \u201coracle.tip.buslogic.validation.rules.AttributeRules::ruleATTR11\u201d. AttributeRules.java is the Java file that contains the method \u201cruleATTR11\u201d. Enforcement Type is the type of the rule (i.e. CORRECTNESS or COMPLETENESS).","In the example above, a rule called \u201cTIP_BusinessProcess.name::ruleATTR11\u201d is applied to the \u201cname\u201d attribute of a BusinessProcess (i.e., the SubjectType instance, \u2018st\u2019 which has already been seeded). The method called \u201cruleATTR11\u201d implements this rule and is located in a file called \u201cAttributeRules.java\u201d in a \u201coracle.tip.buslogic.validation.rules\u201d package.","The \u2018createRule\u2019 API logs information about the rule being created using the Diagnostic Service.","Creating SubjectTypeMembers makes the association between two SubjectTypes and defines the necessary query function that will be executed starting from a \u2018From Object\u2019 and proceeding to a \u2018To Object\u2019. According to one aspect, an example of a pattern for creating SubjectTypeMembers and making the necessary SubjectType association is as follows (where \u2018Type\u2019 is either \u2018MetaCollection\u2019 or \u2018MetaClass\u2019.):",{"@attributes":{"id":"p-0096","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"create< Type >Member"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(<From Object>, <To Object>,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Name of the SubjectTypeMember>, <FunctionType>,"]},{"entry":[{},"<Function Name>);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The input parameters include From Object, To Object, Name, FunctionType and Function Name. From Object is the SubjectType of the \u2018From Object\u2019 in the query, To Object is the SubjectType of the \u2018To Object\u2019 in the query, Name is the name of the SubjectTypeMember, FunctionType is the type of the query that will be executed (i.e., either JAVA or METALANG), and Function Name is the name of the query that will be executed.","For MetaCollection SubjectTypeMembers, the \u2018From Object\u2019 is the \u2018parent\u2019 SubjectType in the UML diagram () while the \u2018ToObject\u2019 is the \u2018child\u2019 SubjectType. For MetaClass SubjectTypeMembers, the \u2018To Object\u2019 is the \u2018metaClass\u2019 SubjectType.","According to one aspect, an example of creating a MetaCollection SubjectTypeMember is as follows:",{"@attributes":{"id":"p-0100","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"createMetaCollectionMember"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(DeployableBusinessProcessMC, IPAgreementMC,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201coracle.tip.buslogic.validation.rules.MemberQueries::DeployableBusinessProc"]},{"entry":[{},"essTOIPAgreement\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"FunctionType.JAVA,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201coracle.tip.buslogic.validation.rules.MemberQueries::DeployableBusinessProc"]},{"entry":[{},"essTOIPAgreement\u201d)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As shown in this example, a new SubjectTypeMember, creating the association between a DeployableBusinessProcess MetaCollection and an IPAgreement MetaCollection, is created. It is assumed that both MetaCollections have already been created as per the above description. The query that will be executed is a Java function located in the \u201cMemberQueries.java\u201d file found in the \u201coracle.tip.buslogic.validation.rules\u201d package. The name of the function is \u201cDeployableBusinessProcessTOIPAgreement\u201d. This query produces a List of all IPAgreements reachable from a BusinessProcess. The name of the SubjectTypeMember should follow the same pattern (i.e., in this case its simply the same as the function name).","The \u2018From Object\u2019 should always be a MetaCollection. The \u2018To Object\u2019 could be either a MetaCollection or it could be an object represented by a MetaClass. An example of a pattern for creating SubjectTypeMembers is slightly different in this case:",{"@attributes":{"id":"p-0103","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"SubjectType st = (SubjectType)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"getObject(SubjectType.class, <Name of the object's MetaClass>);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"e.g. getObject(SubjectType.class, \u201cTIP_Actor\u201d)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The \u2018To Object\u2019 SubjectType must first be retrieved before creating the new SubjectTypeMember. The SubjectTypeMember can now be created, making the association between the two SubjectTypes. For example:",{"@attributes":{"id":"p-0105","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"createMetaClassMember"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(SupportedActorMC, st,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201coracle.tip.buslogic.validation.rules.MemberQueries::SupportedActorTOActor\u201d"]},{"entry":[{},","]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FunctionType.METALANG,"]},{"entry":[{},"\u201cself.Actor\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Here, the \u2018From Object\u2019 is the \u2018SupportedActor\u2019 MetaCollection. The \u2018To Object\u2019 is \u2018Actor\u2019 (represented by the SubjectType whose MetaClass name is the name of the MetaClass for Actor, \u201cTIP_Actor\u201d). The name of the query follows the same pattern as above. In this example, however, the query is expressed using METALANG. The association from SupportedActor to Actor is traversed by executing the getActor( ) API on the SupportedActor object instance. In the query example shown, \u201cself\u201d refers to an instance of SupportedActor. The \u201c.Actor\u201d part refers to the name of the association between SupportedActor and the object to which it is connected, which, in this case is an instance of Actor. The \u201c.Actor\u201d translates to a call to the BLL  getActor( ) API of SupportedActor.","Both \u2018create<Type>Member\u2019 APIs used for creating SubjectTypeMembers will log information about the new SubjectTypeMember using the Diagnostic Service.","The Validation Seed Task  populates the SubjectType table (in database ) with all SubjectTypes. It also populates the ValidationRule table (in database ) with all validation rules in addition to making the appropriate association to their respective SubjectType. The SubjectTypeMember table (in database ) is also populated with both MetaCollection and MetaClass members. For MetaCollection SubjectTypeMembers, the parent\/child associations are made. Compare that with MetaClass SubjectTypeMembers whose metaClass association is made instead.","Design Time","To compute a set of objects to be validated during design time, various APIs are provided. Examples of such APIs include the following:\n\n","In one aspect, only those objects with an appropriate lifecycle state are included in the resulting Set. The lifecycle state should be taken into account to ensure that only those applicable objects that are in an approved state are included for profile metadata. U.S. patent application Ser. No. 10\/734,860, now U.S. Pat. No. 7,457,817 entitled \u201cVersioning in an Integration Platform\u201d, and U.S. patent application Ser. No. 10\/735,217, now U.S. Pat. No. 7,209,933 entitled \u201cObject Versioning\u201d, all filed on even date herewith, the contents of which are each hereby incorporated by reference in its entirety, teach aspects of lifecycle management lifecycle state, and versioning.","In one aspect, the following API is provided to allow the UI to determine a default MetaCollection in cases where there may be more than one collection associated with that object:\n\n","The above API never returns null. If no such default MetaCollection exists, the ObjectNotFoundException is thrown instead.","Two types of validation are provided in the presentation layer (UI) , object and collection. In one aspect, object validation occurs either implicitly by the BLL  whenever an object is first created or updated (correctness only), or explicitly by the UI when an object is loaded and viewed on a details page (correctness and completeness). When performing object validation, the scope of that validation is the object being validated and all of its strongly aggregated objects recursively. In one aspect, collection validation occurs when a user explicitly clicks on a special \u2018Validate\u2019 button. The scope of this type of validation is the true transitive closure of all objects starting from the given root object.","A root object and all of its strong aggregated objects recursively is referred to as an Aggregated Collection. This advantageously improves performance (e.g., the performance of (deployable) collection validation may be unacceptable for UI purposes because the size of the transitive closure can often times be prohibitively large).","The \u2018Validate\u2019 functionality for a specified object may have a problem which can occur when an object has more than one MetaCollection (or Deployable Collection) associated with it. In one aspect, the object's Default Collection is chosen in cases like these to make it easier for the UI to know which to use when performing the \u2018Validate\u2019.","In the above APIs, a set is used to capture all of the objects as opposed to a list. This guarantees uniqueness of all objects within the set (i.e., no object will be included in the set more than once). It is possible that more than one MetaCollection could contain a given object. By using a set, the same object will not be included multiple times. The order of the objects returned is irrelevant and need not be preserved.","To allow the UI to perform object validation the following API is provided:\n\n","In this API, validation of a (root) object will also include validation of all objects that are strongly aggregated with that object recursively. Enforcement type refers to an indication to the validation engine  that determines which type of validation is to be performed as shown in Table 11. Validation level refers to an indication to the validation engine regarding which validations are to be performed (i.e., attribute, association, object, etc., or some combination of these) as shown in Table 12",{"@attributes":{"id":"p-0120","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Enforcement Type"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CORRECTNESS_ENFORCEMENT","Execute correctness validation"]},{"entry":[{},"rules only"]},{"entry":["COMPLETENESS_ENFORCEMENT","Execute completeness validation"]},{"entry":[{},"rules only"]},{"entry":["FULL_ENFORCEMENT","Execute both correctness"]},{"entry":[{},"and completeness validation"]},{"entry":[{},"rules"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0121","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Validation Level"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ATTRIBUTE_LEVEL","Execute all validation rules associated"]},{"entry":[{},"at the attribute level"]},{"entry":["ASSOCIATION_LEVEL","Execute all validation rules associated"]},{"entry":[{},"at the association level"]},{"entry":["OBJECT_LEVEL","Execute all validation rules associated"]},{"entry":[{},"at the object level"]},{"entry":["ALL_OBJECT_LEVEL","Execute all validation rules associated"]},{"entry":[{},"at the attribute, association and object"]},{"entry":[{},"levels of the aggregated collection"]},{"entry":["COLLECTION_LEVEL","Execute all validation rules associated"]},{"entry":[{},"at the collection level"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Generally, COLLECTION_LEVEL is preferably only used when validating MetaCollections. In one aspect, object validation occurs in BLL  when an object is first created or updated. In this aspect, the UI  and the BLL  use ALL_OBJECT_LEVEL which includes aggregation. In the UI , this also occurs when an object is loaded for display on a details page.","The return type, in one aspect, is a Java class that contains information regarding the success or failure of the validation, a list of errors that were encountered (if any) and a set of all objects traversed during the validation process.","Prior to deployment, the configuration manager  creates a new configuration when a user selects a business process for which a configuration is to be created and deployed. In one aspect, the configuration manager  invokes the following API:\n\n","The configuration manager  uses this API to retrieve the set of objects in the deployment unit. It then invokes the following API to validate the objects in that set:\n\n","The UI layer , in one aspect, calls one of the following APIs to validate a collection (for example, when a user explicitly requests validation, e.g., by selecting a \u2018Validate\u2019 button):\n\n","The APIs which accept a String (e.g., name) instead of an actual object represented by that String are included as wrappers for simplicity in cases where only the name of the corresponding object is known. This avoids having the user determine and retrieve the object. In the above APIs, the ObjectNotFoundException will generally occur when a corresponding object is not found given the specified name for that object.","While the invention has been described by way of example and in terms of the specific embodiments, it is to be understood that the invention is not limited to the disclosed embodiments. To the contrary, it is intended to cover various modifications and similar arrangements as would be apparent to those skilled in the art. Therefore, the scope of the appended claims should be accorded the broadest interpretation so as to encompass all such modifications and similar arrangements."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
