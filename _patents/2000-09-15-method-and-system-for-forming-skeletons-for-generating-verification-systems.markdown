---
title: Method and system for forming skeletons for generating verification systems
abstract: A verification system for a procedure interface is generated by using formal specifications of the procedure interface and generating test suites. The test suites are generated from the formal specifications and templates or skeletons which are used to generate an element of a verification system. The skeletons are generated based on decomposition of test suits.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06898784&OS=06898784&RS=06898784
owner: Nortel Networks Limited
number: 06898784
owner_city: St. Laurent
owner_country: CA
publication_date: 20000915
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This invention relates to a system and method for forming skeletons for generating a verification system for verifying procedure interfaces.","A software system contains a functionally closed set of procedures. In order to ensure correct implementation of the software system, it is desirable to determine a software contract, i.e., elements and functional specifications of external interfaces of the software system, and carry out conformance testing of the software contract implementation. Since the elements of the software contract are procedures, it is in fact Application Programming Interface (API) testing.","A kernel of an Operating System (OS) comprises API. For example, a Support Operating System (SOS) is a real-time OS for a Digital Multiplexing Switch (DMS) for a communication system. SOS comprises a plurality of processes for supporting the operation of DMS. The lowest layer of SOS is SOS kernel. The SOS kernel allocates resources to the processes running under SOS. The SOS kernel also provides communication among these processes. The SOS kernel also creates, controls and removes these processes.","SOS supports more than 25 million lines of code for applications and utilities. Thus, it is critical that user procedure interfaces of the SOS kernel be stable and reliable for correct performances of the DMS switch. The SOS kernel consists of over 17,000 procedures or over 230,000 lines of source code. Thus, it is very complicated and time consuming processes to generate a system for verifying such complex procedure interfaces. There existed no automatic or semi-automatic mechanisms to aid such generation of a verification system.","At the same time, SOS continuously evolves. Also, SOS is often ported to new hardware and software platforms. While more than 75% of the kernel procedures are machine-independent, the remainder of the kernel procedures are very machine dependent. The remainder describes particularity of memory, inter-processor communication and communication with peripheral devices. Accordingly, when SOS evolves or SOS is ported to a new platform, the SOS kernel and its procedure interfaces are also modified. Thus, the verification system for the procedure interfaces of the SOS kernel also needs to be modified. However, there existed no automatic or semi-automatic modifying mechanisms to aid such modifications.","There are some systems proposed for building a verification process. One of such systems is Interactive Tree and Tabular Combined Notation (TTCN) Editor and eXecutor (ITEX). ITEX is a test environment for communicating systems. It includes a TTCN and Abstract Syntax Notation.1 (ASN.1) analysis and design tool, a test simulator and support for generation of complete Executable Test Suites (ETS). In accordance with ITEX, a Test Suite is made up of Test Cases in form of tables. ITEX provides a set of highly integrated tools for development and maintenance of Abstract Test Suites (ATS) written in TTCN. ITEX supports phases of the test suite development including Test Case Generation, Editing, Verification, Validation and Execution. This toolset is integrated with the Specification Description Language (SDL) Design Tool (SDT), which is an environment for design of SDL specifications. Test suites described with TTCN can be transformed to the form that allows testing both implementation in some programming language and specification in SDL. However, this approach is unsuitable for API testing. TTCN does not permit declaration of pointers and other software entities that do not have textural (literal) representation. A major limitation of SDL-like specifications is their explicit form. This means that it is easy to build models and prototypes based on them but it is very difficult to develop a system of constraints that define the union of all possible implementations.","Another example is the Algebraic Design Language (ADL)\/ADL2. From formal specifications, ADL generates test oracles and skeletons for building test drivers and documentation. ADL uses not one of the popular specification languages but extensions of C and C++ languages. There are ideas on extensions of Java and other object-oriented languages aimed at developing software in \u201cDesign-by-Contract\u201d fashion. However, despite the obvious advantages of better acceptance of such languages in the software engineering community, the concept, not to mention the common notation, is still far in the future. ADL has a limited range of API classes for which it can provides means for specifications and automatic test generation. ADL provides adequate tools for test generation automation only for procedures whose parameters allow independent enumeration and allows testing procedures one by one. This means that ADL omits procedures with dependent parameters, procedures that require testing in a group, e.g., \u201copen-close\u201d, or those that require testing in parallel mode, e.g., \u201clock-unlock\u201d, or \u201csend-receive\u201d.","Another example is formal derivation of Finite State Machines (FSM) for class testing proposed by L. Murray, D. Carrington, I. MacColl, J. McDonald and P. Strooper in \u201cFormal Derivation of Finite State Machines for Class Testing\u201d, in Jonatthan P. Bowen, Andreas Fett, Michael G. Hinchey (eds.) ZUM'98: The Z Formal Specification Notation. 11-th International Conference of Z Users, Berlin, Germany, September 1998, Proceeding, Lecture Notes in Computer Science, v. 1493, pp. 42-59. This work is at the research stage. The authors propose a scheme for organization of procedure group testing using Object-Z as specification language and C++ as programming language. The task of this work is stated to build test suites to verify conformance of the implementation to the specification using formal specifications of the methods for a class. As a test coverage criterion, the union of two criteria is used: to cover all equivalency classes that represent the areas obtained as a result of partition analysis, and then, to check results on or near the boundaries. However, the authors of this work do not try to solve the problem of complete automation of test generation. Nor do they attempt to support any elements of the preparation phase with tools. Partition and boundary analysis is done manually according to the methodology proposed by the authors. In a similar way, they build the specification of oracles. Oracles, once compiled into C++, call target procedures and verify the conformance of the results to the specifications. This testing scheme is a framework that dynamically generates test sequences of procedure calls. The framework is controlled by the FSM description which represents an abstraction of a state transition graph of the test class. The authors describe the methodology of building specifications for the classes of states and transitions between them while considering the problem of exclusion of inaccessible states.","This approach needs the full description of the FSM that models the states of the system under test. The theoretical weakness of this approach is that it does not try to come up with a formal methodology to build transformation specifications. It is obvious that serious problems will be encountered when attempting to apply this approach to specifications of real-life complexity. In practical sense, it is clear that the process of test derivation from the specifications is mostly manual activity which limits its applicability to industrial software.","The development of verification system is a labour-intensive process. The total size of a verification system is often similar to the size of the software under test.","Currently, the most commonly used approach to the verification system development is the manual development. There are some tools that can generate some elements of a verification system for the most simple cases of the test parameter set generation, namely, for the case of the manually written list of the test parameter sets in literal form. However, this approach can not be used if some parameter could not be written in literal form. For example, a UNIX file descriptor is returned by operating system as a result of the system call \u201copen file\u201d, and can not be written in literal form. This approach also can not be used for testing of the procedure sequence when the out-parameter of some procedure is used as the in-parameter of the another procedure.","It is therefore desirable to provide means to decrease the efforts of the verification system development and to increase its reliability.","The present invention provides a method and system for forming templates or skeletons which are used to generate an element of a verification system.","In accordance with an aspect of the present invention, there is provided a method for forming a skeleton tool usable for generating a test suite for a verification system for verifying a Procedure Interface Under Test (PIUT). The method comprises decomposing existing test suites, the test suites having automatically generated components and manually developed components and being written in its test suite implementation language; defining one or more standard schemes of procedure testing based on the decomposition of the test suites; providing skeleton description for each scheme in skeleton definition language; and transforming the skeleton description for each scheme into a skeleton tool for generating the test suite of the scheme.","In accordance with another aspect of the present invention, there is provided a system for forming a skeleton tool usable for generating a test suite for a verification system for verifying a Procedure Interface under Test (PIUT). The system comprises a decomposer, a skeleton describer and a skeleton transformer. The decomposer is provided for decomposing test suites. The test suites have automatically generated components and manually developed components. They are written in its test suite implementation language. The decomposed test suites are used to define one or more standard schemes of procedure testing. The skeleton describer is used for providing skeleton description for each scheme in skeleton definition language. The skeleton transformer is provided for transforming the skeleton description for each scheme into a skeleton tool for generating the test suite of the scheme.","Other aspects and features of the present invention will be readily apparent to those skilled in the art from a review of the following detailed description of preferred embodiments in conjunction with the accompanying drawings.","There are different kinds of API entities, such as procedures, operations, functions, methods in C++ and subroutines in Fortran. In this specification, these terms are considered synonyms and all are called \u201cprocedure\u201d.","Referring to , an example of a verification system generator  and a method for generating a verification system  to which the present invention may be suitably applied are described. The verification system  is generated for verifying a procedure interface  of a System Under Test (SUT) .","The verification system generator  comprises means  for generating formal specifications, a test source generator  and a repository . As shown in , the means  for generating formal specifications generates formal specifications of the procedure interface  (S). Based on the formal specifications, the test source generator  generates test sources (S). The generated formal specifications and the test sources are stored in the repository  (S).","The test sources are used to generate a test suite . The test suite  is a set of programs and test data intended for the use in verifying the target procedure interface .","The formal specifications are generated in a form independent form implementation of the SUT . That is, the formal specifications do not depend on the implementation language, software or hardware of SUT , as further described later. The test sources that are generated based on the implementation independent formal specifications are also implementation independent. Accordingly, the test sources may be used on any implementation of the SUT or modified versions of the SUT.","The SUT  uses specific implementation language. The test sources are written in specification language that is independent from the implementation language. Accordingly, in order to execute the test sources on the SUT  to verify the procedure interface  of the SUT , the test sources are translated in language executable on the SUT  (S). The translation is carried out by an implementation language compiler . The compiler  compiles some executable subsets of test sources in the specification language into programs in the implementation language of the SUT . The compiled programs are specifications in implementation language that can be interpreted as description of some algorithms.","Thus, the generator of the verification system  is carried out in two stages. First, generation of implementation independent programs is performed. Then, implementation independent programs are compiled into those in implementation language of the SUT . Such a two step generation method allows the means  for generating specifications and the test source generator  of the verification system generator  to be implementation-independent tools and, in particular, implementation-language-independent tools.","The complier  may be a part of the verification system generator  or may be provided separately from the verification system generator .","The compiled test sources form the test suite . As the test sources are implementation independent, the test suite  is also independent from the implementation of the target SUT , other than the language used. That is, the test suite  does not depend on the implementation software or hardware of SUT . By using the test suite , a test harness  including the test suite  and a test bed  is formed for verifying the procedure interface  of the SUT , as further described below.","The test suite  executes tests on the SUT  (S) and analyses results of the tests to verify the procedure interface  (S).","The verification system generator  \u201cautomates\u201d test generation of real software for verifying a procedure interface  of an SUT . The expression \u201cautomation\u201d used herein does not necessarily mean fully automated manipulation that creates ready for use test data, test sequences and other infrastructure for test execution and test result analysis. An \u201cautomated\u201d process may include steps of manually writing some components in implementation language. When the total size of such manually developed components is small as a whole, the process may be considered \u201cautomated\u201d.","It is preferable that the test source generator  comprises a test driver generator  and a test case parameter generator .","The test case parameter generator  generates test case parameter sources for generating test case parameters. That is, the test case parameter generator  generates constant arrays and programs that generate and select needed test case parameters. The test case parameters are represented by these constant arrays and programs.","Based on the formal specifications, the test driver generator  generates test driver sources for generating test drivers. The test drivers execute tests on the SUT  using the test case parameters in implementation environments and analysing results of tests.","The test drivers comprise programs to execute and control testing of the procedure interface . The test case parameters are parameters of a test case. A test case is an instance of a tested procedure. A test case is defined by a procedure name and its parameters, i.e., test case parameters. Also, state of environment may be a factor of defining a test case. The test drivers use the test case parameters and execute test cases on the SUT  to verify the procedure interface .","The test driver generator  generates the test driver sources which, once compiled into the test drivers by the implementation language compiler , fulfil functions to initialize the procedure interface , prepare input values, call tested procedures with test case parameters, and receive test procedure results and analysis of the test results. In general case, the test driver sources are complex programs.","It is preferable that the test driver generator  generates the test driver sources that, once compiled into the test drivers, do not only pass some previously generated test case parameters to the SUT , but also control the state of the SUT . If the SUT  state violates some conditions of the test, the test drivers do not supply test parameters to the procedure interface .","As the formal specifications are implementation independent, the generated test driver sources and test case parameter sources are also implementation independent.","The test driver generator  preferably comprises a basic driver generator  and a script driver generator . The basic driver generator  analyses the formal specifications, and generates the basic driver sources comprising programs in implementation-independent language. The basic driver sources are used for generating a basic driver in implementation language. The basic driver is a test driver for a target procedure . The basic driver checks whether pre-conditions for the target procedure  hold for a given tuple of input parameters, calls the target procedure  with the given tuple of input parameter, records corresponding output parameters, and assigns a verdict on the correctness of the target procedure execution results. The basic driver preferably also collects information necessary to estimate test coverage or investigate reasons for a fault, as described below.","The script driver generator  generates script driver sources which describe sequences of calls to the basic driver with different test case parameters. The script driver sources are used for generating script drivers in implementation language. A script driver is a test driver for a target procedure or a set of target procedures. A script driver reads test options, generates sets of input parameters based on test options, and calls a basic driver with some set of input parameters. A script driver may also perform extra checking of the correctness of the target procedure execution results and assigns a verdict. A script driver may also check whether the test coverage is complete, and if not, it may continue to generate sets of input parameters and call the basic driver with this tuple.","The present invention may be suitably applied to generation of a verification system for arbitrary procedure interface of arbitrary systems. For example, the present invention is suitably applied to generate a verification system for procedure interfaces of a kernel of a Support Operating System (SOS) for a Digital Multiplexing Switch (DMS). The invention is hereinafter described mainly for verification of SOS kernel interfaces, but it is not limited to this application.","Generating formal specifications","The generation of the formal specifications of the procedure interfaces is further described referring to .","The means  for generating specifications first provides a function (F) for defining procedure interface of the SOS kernel (S).","As shown in , SOS  has SOS kernel  and SOS utilities . SOS  supports applications . SOS  is written using Nortel Networks Corporation's proprietary programming language called Protel, which is an example of the implementation, or target, language.","The SOS Kernel  comprises a plurality of procedures. The procedure interface defining function (F) categories the procedures of the SOS Kernel  into two groups: one group for those depending on implementation of SOS , and the other group for those independent from implementation of SOS . The procedure interface defining function (F) then defines procedure interfaces to consist of procedures that are implementation independent. The defined procedure interfaces form a Kernel Interface Layer (KIL). KIL  does not depend on implementation and, in particular, on hardware special features of SOS . The procedure interfaces of KIL  are defined such that each procedure in KIL  performs one and only one service. No two procedures provide the same service. Thus, KIL  comprises minimal and orthogonal procedures needed by upper layers of SOS  and applications . KIL  hides internal data structures and implementation details of the SOS kernel .","Based on the defined procedure interfaces of KIL , the means  for generating specifications provides a function (F) for developing implementation independent description of the procedure interfaces of KIL  (S).","The description developing function (F) rigorously describes functionality of the procedure interfaces of KIL .","The implementation independent description may be developed using reverse engineering. The basic idea of the reverse engineering approach is a gradual \u201cupwarding\u201d of data representation in defined implementations. \u201cUpwarding\u201d is increasing the level of abstraction.","For example, as shown in , it may be developed using source code  of the SOS kernel . The source code  is in the implementation language of SOS . The source code  is compiled into implementation independent language to generate a prime specification, i.e., implementation independent description . It is preferable to use an implementation independent language compiler  to carry out this compiling process automatically.","The implementation independent description may also be developed from documents or other information of the SOS Kernel .","As shown in , the means  then provides a function (F) for deriving formal specifications of KIL  from the implementation independent description (S). In the example shown in , the level of abstraction of the prime specification  is increased to generate a formal specification . This abstraction process  may be carried out manually.","It is preferable to use Rigorous Approach to Industrial Software Engineering (RAISE) to generate formal specifications. RAISE Specification Language (RSL) is suitable to write formal specifications. RSL is supported by commercial tools for syntax and semantics checking, such as an EDEN-sintaxicaly oriented editor, a RAISE to ADA compiler, and a RAISE to C++ compiler.","Other RAISE features, e.g., axiom, algebraic specifications and channels may be used in semiformal considerations and explanations.","Also, it is preferable to use model-oriented specification in implicit form as the main form of specification. The implicit form describes a target procedure using pre-conditions and post-conditions of the target procedure.","The means  for generating specification may comprise a tool or a set of tools for providing above described functions for aiding a specifier to manually or semi-automatically generates the specifications. An example of such tools is the implementation independent language complier  as described above.","It is preferable to classify procedure interfaces of the target SUT by using the specifications. The following classification of procedures of a procedure interface is suitably used for generating a verification system for the procedure interface. The procedure interface classes include five main classes of procedures and some extensions of classes including procedures tested in parallel and expected exceptions. The classes are organized hierarchically. The first class establishes the strongest requirements. Each following class weakens the requirements. The requirements for the five classes are as follows:","KIND1: The input is data that could be represented in literal (textual) form and can be produced without accounting for any interdependencies between the values of different test case parameters. Such procedures can be tested separately because no other target procedure is needed to generate input test case parameters and analyse the outcome of the tests.","KIND2: No interdependencies exist between the input items, i.e., values of input test case parameters. The input does not have to be in literal form. Such procedures can be tested separately. Examples of this class include procedures with pointer type input parameters.","KIND3: Some interdependencies exist, however, separate testing is possible. Examples of this class include a procedure with two parameters in which the first one is array and the second one is a value in the array.","KIND4: The procedures cannot be tested separately, because some input test case parameters can be produced only by calling another procedure from the group and\/or some outcome of tests can be analysed only be calling other procedures. Examples of this class include a procedure that provides stack operations and that receives the stack as a parameter.","KIND5: The procedures cannot be tested separately. Part of the input and output data is hidden and the user does not have direct access to data. Examples of this class include instances of Object-Oriented classes with internal states; and a group of procedures that share a variable not visible to the procedure user.","Exception raising extension of API classes: The specific kind of procedures raise exceptions as a correct reaction to certain input test case parameters. Examples of this class include a procedure that is supposed to raise an exception after dividing by zero. If zero received as an input parameter, then this procedure must not return any return code.","Generating test sources","The generation of the test sources is further described referring to FIG. .  shows an example of the test generation for a KIL  using RAISE as implementation independent language.","The test source generator  comprises a basic driver generator , script driver generator  and test case parameter generator . In this example, the test source generator  uses UNIX, and the target SOS kernel  uses target language. The formal specifications  are generated in RSL. Accordingly, the test source generator  uses an RSL-target language complier  as an implementation language compiler.","The main source of the test source generation is the RAISE specifications . The RAISE specifications  are written in RSL. The RAISE specifications  may be those generated by the means  for generating specifications shown in  or those stored in the repository .","The basic driver generator  receives the specifications . The basic driver generator  is a tool for generating basic driver sources, i.e., RSL basic drivers . The RSL basic drivers  are testing procedures in RSL. The basic driver generator  executes analysis of the RAISE specifications . Based on the analysis results, the basic driver generator  generates testing procedure programs comprising the RSL basic drivers . That is, the basic driver generator  generates, as the RSL basic drivers , programs for checking input test case parameters, calling tested procedures, tracing and analysing the test results, assigning a verdict of the outcome, and outputting trace information.","The basic driver generator  preferably also generates source for test case parameter generation . The source  for test case parameter generation preferably includes source for partition analysis, as described below.","The results ,  of the basic driver generator  are fully completed in RSL sources. RSL generated sources do not require any customization as they are implementation independent.","The RSL basic drivers  generated by the basic driver generator  are compiled by the RSL-target language compiler  into basic drivers  in the target language. The basic drivers  comprise target language procedures. Other than the language used, the RSL basic drivers  and the basic driver  in the target language are the same.","For each procedure in KIL , one basic driver  is generated. Each basic driver  provides direct call of a target procedure in KIL , and provides common facilities to test the target procedure. That is, each basic driver  takes input test case parameters for KIL , and checks pre-conditions of the target procedure. If the pre-conditions are correct, the basic driver  makes the call of the target procedure, and checks post-conditions of the target procedure.","The basic drivers  may carry out test result analysis by recording execution outcomes and comparing them with required outcomes. The basic drivers  may provide the result of the analysis as a verdict. The verdict may be either \u201cpassed\u201d or \u201cfailed\u201d. The \u201cpassed\u201d verdict means that no error is detected. The \u201cfailed\u201d verdict means that an error is detected.","The basic drivers  may have a test oracle to automatically perform the analysis of the test outcome. The test oracle is a program that assigns a verdict on the correctness of outcome for the target procedure. The test oracle is similar to post-conditions. Both the test oracle and the post-conditions have Boolean functions. They have the same parameters, and return \u201cTrue\u201d if the target procedures produces a correct result and \u201cFalse\u201d otherwise. Accordingly, the test oracles can be generated once the post-conditions are generated.","The test result may depend on the SOS state and the history of SOS functioning. In order to fulfil its function, each basic driver  preferably also generates programs to support a model of SOS state. The model is used to check acceptability of test case parameters in different contexts and to analyse correctness of test results.","The test case parameter generator  receives the source for test case parameter generation  from the basic driver generator . Then, the test case parameter generator  generates test case parameter sources, i.e., RSL test case parameters . The RSL test case parameters  may be constant arrays or programs. The test case parameter programs are also fully completed RSL sources.","The test case parameter generator  may also generate test case parameter sources from the specifications.","The RSL test case parameters  are compiled into test case parameters  by the RSL-target language compiler . The test case parameters  are input parameters for procedures under testing. Therefore, they are used for basic driver procedures. The test case parameters  may include only numeric and\/or boolean input parameters. For example, a KIL of SOS includes about 140 procedures which need only such input parameters. These procedures are called KIND1 procedures, as described above.","The script driver generator  receives the RAISE specifications , and generates script driver sources, i.e., RSL script drivers . The RSL script drivers  are compiled by the RSL-target language compiler  into script drivers  in the target language. Other than the language used, and the RSL script drivers  and the script drivers  in the target language are the same. The script drivers  are the upper level of the basic drivers .","Each RSL script driver  is a program for testing of a procedure or a group of procedures. It is a sequence of target procedures calls. The sequence may have serial or parallel composition. The sequence may have iterations. The RSL script drivers , once complied into the script drivers  by the complier , realize a scenario or script of testing.","The script driver generator  generates, as the RSL script drivers , programs to realize the sequences of procedure execution with different test case parameters. The script driver generator  generates the RSL script drivers  to have no direct interaction with target procedures. That is, the RSL script drivers , once complied into the script drivers , call the basic driver . One or more RSL script drivers  may be written to be called by procedures which function as suppliers of test case parameters , or procedures that allow a system operator to control a procedure group testing.","The script driver generator  may also generate programs to check the verdicts of the basic drivers . The script driver generator  may also generate programs to assign script driver own verdicts based on the basic driver verdicts.","It is preferable that the script driver generator  uses script driver skeletons  in addition to the specifications . The script driver skeletons  describe general scheme of script drivers. That is, each script driver skeleton contains an algorithm of a script driver. The script driver skeletons  are specific to each kind of procedure interface.","Each script driver consists of declarations and a body. The declarations include import of the procedure under test and its data structure definitions and\/or import of all data and types used in the specifications. The declarations are generated automatically based on the list of procedures under test and their specifications . The body of a script driver begins with the script driver option parsing. The options, as parameters of the script driver as a whole, determine the depth of testing, e.g., the level of test coverage criteria, and some specific data like interval of values, duration of testing.","In the example shown in , in order to generate an RSL script driver , the script driver generator  uses one of the skeletons  and the RAISE specifications . Union of the specifications  and skeletons  forms formal description of test suite sources. This formal description may be considered as a test suite specification. The test suite specification allows the generator  to define test coverage requirements, schemes of script drivers, and algorithm for checking target procedure behaviours.","The script driver skeletons  for a new target SUT may be manually developed or received from the repository . Before testing starts, the verification system carries out some initialization. For example, before testing write\/read procedures, the verification system opens a file. Such initializations are written manually. After initialization is finished, the main part of the script driver begins.","In addition to specifications  and skeletons , the script driver generator  may also use some supplement sources, such as some instances of test case parameters values.","The script driver generator  may also use procedures that convert values derived from the RAISE specifications  into value formats used by the current version of SOS kernel . Because the specifications  are implementation independent, correspondence between the specifications  and implementation data structures is separately described. Thus, it is preferable to use some means for associating abstract objects with implementation objects. Some target language procedures convert data from their representation in implementation to and from their representation in the test suite . Such target language procedures may be used as the associating means. The target language procedures use post-conditions of the procedure under test. The target language procedures may be manually developed.","These additional sources including manually written skeletons may be called \u201cmanually developed components\u201d. The size of manually developed components is not large compared to the automatically generated components in the verification system generator .","For KIND1 procedures, full automation of test generation is possible. All other kinds generally need some additional effort for writing manually developed components. The effort gradually grows from KIND2 to KIND5. The extensions require more effort than the corresponding kinds themselves. Complexity and effort for the development of manually developed components is usually caused by the complexity of the script driver generation and debugging. All script drivers for different classes of procedures have similar structure. The main distinction is the distribution between automatically generated components and manually developed documents. The KIND1 script driver is generated fully automatically, KIND2 script driver is generated almost automatically and so on.","The scheme of a script driver is further described in more detail using an example of a KIND5 script driver.","The KIND5 script driver realizes a general algorithm for traversing an abstract Finite State Machine (FSM). This algorithm passes all states and all possible transitions between the states. Each transition corresponds to an execution of a procedure under test.","The algorithm of a script driver is related to the specification and does not depend on the implementation details outside the specification. The script driver algorithm does not have direct descriptions of the abstract FSM. The verification system generator  avoids use of direct descriptions because direct specification of the FSM requires extra efforts to generate.","Instead of a direct specification of FSM, the verification system generator  uses indirect, virtual representation of FSM. Such representation includes a function-observer and a function-iterator. The function-observer calculates on the fly the current state in the abstract FSM. The function-iterator selects a next procedure from the target procedure group, and generates a tuple of the input parameter values for this procedure.","The KIND5 script driver algorithm is described in more detail. For example, a case of testing a procedure group is considered. After passing several FSM states, i.e., some target procedures have been called, the next transition is being made. This elementary cycle of testing starts by calling a function-iterator that selects the next procedure from the target procedure group, and prepares a tuple of input test case parameter values for this target procedure. If the function-iterators have managed to generate a new and correct tuple without violation of pre-conditions, then the script driver calls a corresponding basic driver with the tuple as actual test case parameters.","When the basic driver returns a verdict, the control script driver checks the verdict assigned by the basic driver. If the verdict is \u201cFalse\u201d, i.e., an error has been detected, the script driver produces corresponding trace data and finishes. If the verdict is \u201cTrue\u201d, i.e., the elementary test case passed, the script driver calls the function-observer. The function-observer then calculates a current state, logs the state and transition, and continues to traverse FSM.","Thus, all possible states and test the procedures with all needed sets of input parameters may be obtained. FSM is used here as a guideline to pass through all states the needed number of times.","As described above, the script drivers are preferably composed following the requirements of the corresponding skeletons. In this embodiment, overall, the verification system generator  uses five skeletons needed for serial testing of API KIND1 through KIND5 and one skeleton for parallel testing. Based on a corresponding skeleton and the list of target procedures and specifications, the verification system generator  generates a script driver template for each class. A KIND1 template is a ready-to-use program. The templates for the other kinds include several nests with default initiators and iterators. If a test designer does not need to add or improve anything in the nests, the template can be compiled by the RSL-target language compiler  and executed as a script driver . This situation is typical for a KIND2 procedure interface. For other kinds, a test designer usually adds some specific initiators and iterators as RSL supplement . The test designer defines FSM state observer for the script drivers of KIND4 and KIND5.","Formulation of skeletons","The development or formation of skeletons  is now described referring to FIG. .","According to the present invention, skeletons  are developed by decomposition of test suites (). Every large system consists of subsystems. A structure that exposes the hierarchical construction of the subsystem is called its decomposition. Test suites have generated and manually-developed components, and these components are exposed by the decomposition.","Standard schemes of the procedure testing are then determined based on the decomposition (). As described above, the standard schemes include the five kinds, Kind1 to Kind5. Each scheme is defined by a skeleton of the test suite.","For each separate scheme of procedure testing, skeleton description is developed in the skeleton definition language (). The skeleton definition language is analogous to the macro language of an advanced programming language. The main difference between the skeleton language and the macro language is that the skeleton language does not use the macro definitions and macro calls. In this sense, the skeleton language functions as a directive for control of translation.","The skeleton definition language consists of the following parts:\n\n","Parameters of the skeleton may be text strings, integers, arrays of text strings or arrays of integers. Arrays of text strings or integers may be one dimensional arrays or multi dimensional arrays. Skeleton parameter identifiers identify the type of parameters.","Repetitors and variants descriptors are written in the macro-language of the skeleton definition language. This macro-language may be a subset of the C language. For example, a repetitor may be the following construct:\n\n","Slot descriptors provides slots in skeletons. Some slots are filled in automatically, and another slots are filled in manually. Each manually filled in slot has the rigorously defined semantics. The slot descriptor supports the rigorously defined semantic. Each slot descriptor consists from two slot boundaries, slot identifier having an arbitrary length string and a default slot filler. The semantic of the clot filler is defined by its identifier. No formal semantic description is provided.","Finally, the skeleton description written in the skeleton definition language is then transformed into a skeleton tool () The skeleton tool, or the skeleton, facilitates generation of the test suite of the selected scheme. The translation of the skeleton description may be carried out by transforming the skeleton description into the source code of the skeleton tool for generating the template of test suite. The source code may be C-code. During transformation, each part of the skeleton definition is transformed into the corresponding part of the skeleton tool. That is, the invariant test suite parts of the skeleton description are transformed into constant text strings. The skeleton parameter identifiers are transformed into the definition of the variable. The repetitors and the variant descriptors become the part of the source code of the skeleton tool as they are written in the macro-language of the skeleton description. The slot descriptors also transformed into the constant text strings.","Formal requirements may be written in the skeleton for each slot for manually-developed components.",{"@attributes":{"id":"p-0115","num":"0120"},"figref":"FIG. 9","b":["700","700","702","704","706"]},"The decomposer  decomposes test suites (). It has functions - for identifying specific parts of test suites. The skeleton describer  develops skeleton description (). It has functions - for creating parts of skeleton description based on the identified parts of the test suites.","As shown in , the decomposer  has an invariant test suite parts identifier  that identifies invariant test suite parts (). Based on the identified invariant parts, the invariant test suite description creator  of the skeleton describer  creates invariant test suite description ().","A skeleton parameter identifier  of the decomposer  identifies skeleton parameters (). Based on the identified parameters, an identifier creator  of the skeleton describer  creates skeleton parameter identifiers ().","Similarly, identifiers - of the decomposer  identify from the decomposed test suites, repetitive parts, variants, manually developed components and automatically generated components, respectively (-). Based on the identified repetitive parts, variants, manually developed components and automatically generated components, creators - of the skeleton describer  creates repetitors, variant descriptors, first slot descriptors and second slot descriptors, respectively (-).","The order of identifying those features do not need to follow the above order.","The transformer  transforms the skeleton description into a skeleton tool (). The skeleton tool uses a file containing the skeleton parameter actual values and the components for the slot filling.","Completed test suite sources will be obtained as a result of the execution of the skeleton tool. For example, as shown in , the skeleton generated by the skeleton transformer  is used as an input for generation of a tool, template generator . The procedure specification generated by the means for generating specification  () is also used as an input for generation of the template generator . The template of the test suite is obtained as the result of execution of the template generator . The template contains the slots for manually written parts. A tool, template filler , receives the test suite template and a file with manually written parts of the test suite as its input, and generates the completed test suite sources, which will then be compiled into the test suite  as described below.","In an example, during test suite development in accordance with the present invention, the size of the manually-developed components can be less than 20% of the total test suite size.","The invention decreases efforts required for the test suite development, and increases reliability of the resultant test suites because of simplifications and formalizations of the requirements to the manually-developed components.","Compilation of test sources","Returning back to , in the generator , all kinds of generation by generators , ,  produce results , , ,  in RSL. This means that \u201cfront end\u201d of specification and verification technology is implemented in implementation language independent form. All generators , ,  can produce the components , ,  of the test suites  for systems implemented in arbitrary programming languages.","Compilation of generated sources , ,  by the RSL-target language compiler  may be carried out when generation of all sources , ,  is completed. The RSL-target language compiler  translates executable subsets of RSL language into programs in the target language. Thus, the RSL-target language compiler  restricts RSL. These restrictions are typical for all RSL language compilers. For example, the RSL-target language compiler  does not treat explicit definitions of constants if the user does not define the concrete constant value but only defines limitations that restrict constant field of values.","The RSL-target language compiler  is implementation-language dependent.","The result of the RSL-target language compiler  is generally a group of complete target-language sections. This is a part of the target language module that consists of a few sections. For obtaining a target language program which is ready to execute, some target language sections with interface descriptions may be produced. Interfaces or behaviour of some procedures from SOS are written once and do not need to be rewritten repeatedly. The target language sections with interface descriptions may be produced manually. These target language sections may be called target language supplement .","In order to correctly use different generation\/compiling tools, it is preferable to know interdependencies between modules of specifications and between results of generation\/compiling, i.e., the target language sections, and other target language modules\/sections that were manually developed or had been produced by other tools. These interdependencies may be represented by a graph. The complexity of such a graph of interdependencies depends on the size of the procedure interface under test.","For example, currently KIL consists of over 560 procedures divided into over 30 subsystems. For each subsystem, there exists, at least, a basic driver module, and as a whole there exist about 200 script driver modules. For each RSL driver, at least one target language module is generated and stored. Besides, the target language modules consist of a few sections and each section is stored in a separate file. As a whole, KIL requires over 10,000 files. In order to facilitate use of test generation\/compiling tools, it is preferable to provide a work \u201cmanage\u201d utility, as described later.","The basic drivers  invoked by the script drivers  are generated fully automatically. The only manually developed components called from basic drivers  are data converters of the RSL-target language compiler . As mentioned above, the converters transform the model data representation into the implementation representation and vice versa. A model representation is distinguished from the implementation one by the level of abstraction. For example, models may use \u201cinfinite\u201d representation of integers, maps, relations, and other data structures suitable for specification. Sometimes model representation is very similar to the implementation one. In this case, such transformation is done by a standard translation algorithm of the specification language into the implementation language.","The verification system generator  is suitably used for generating a verification system for a continual evolving SUT. SOS may be evolved in accordance with its life cycle. During evolution cycle, requirements, interfaces or behaviour of some procedures from the SOS kernel, and implementation of SOS are repeatedly modified. For each new version of SOS, it is necessary to develop a new version of verification system. Therefore, it is beneficial to automate process of regeneration of the verification system.","Life cycle of test suites  generated by the verification system generator  replicates life cycle of the SOS Kernel . Usually, only a few interfaces or behaviour of some procedures from the SOS kernel are modified. The verification system generator  provides a possibility to re-specify modified interfaces or behaviour of some procedures from the SOS kernel and then re-generate test suites , and in doing so to provide re-use of old manually developed components. Thus, the verification system generator  can automate test suites regeneration. Therefore, existence of manually developed components does not decrease actual level of automation of the verification system generation.","To support automatic regeneration of test suites , the verification system generator  preferably stores in the repository  all manually developed components developed for generating the test suites  separately from automatically generated components. The manually developed components supplement automatically generated components. Therefore, process of the test suites components manually development may be called \u201csupplement\u201d. Thus, the verification system generator  may use two kind of sources for generating test sources: formal specifications and some supplement sources. As automatically generated and manually developed components of the verification system generator  are stored separately, no manual changes in automatically generated components are needed. Therefore, the verification system generator  can eliminate need of customizing automatically generated files for each regeneration of the test suites .","To estimate effort for generating verification system, a volume of modified interfaces or behaviour of some procedures from the SOS kernel is first estimated. When no interface is modified during SOS evolution, then no test (re)generation is needed. In that case, only realization, i.e., implementation, of SOS is modified Therefore, previous specifications  and previous test suites  can be used for validation of the new KIL.","When some interfaces or behaviour of some procedures from the SOS kernel are modified or added during SOS evolution, then corresponding specifications  need to be modified. When interface data structures are modified, in addition to specifications , some conversion procedures in the target language also need to be (re)developed. Those target language conversion procedures may be manually developed. In any case, some reasons for test plan modification may arise. For example, these modifications may be caused by wishes to increase amount of tests, decrease time of testing, to check correlation of some features for parallel execution and so on. In those cases, some manual modification to manually developed components may be needed. When manual modifications are completed, a test designed can automatically generate new test suites  for validation of the new SOS kernel by using the verification system generator .","In a simple case, it may suffice to modify the specifications  of types of pre-condition or post-condition of a target procedure. When new modification of procedure behaviour does not imply on behaviour of other procedure, the generator  needs only to regenerate a basic driver for verification of the modified procedure. In a complicated case, the generator  may need to regenerate totally new test suites including new basic drivers and script drivers. What volume of test suite modification is required depends on dependencies inside of the specifications  and between separate parts of the specifications  and test suites components - generated from these parts. Existing \u201cmanage\u201d utility may be used which automates regeneration and recompiling of new test suites, as described later.","In order to port a test suite  generated by the verification system generator  from one implementation language platform to another, the data converters need to be rewritten and a new RSL to implementation language compiler needs to be provided. Also, a new run-time support system for the test suites with new test bed functions needs to be provided.","It is preferable that the verification system generator  also generates data for test coverage estimation and test plan design. The data is preferably kept in the repository .","Test coverage measures the completeness of testing. Sometimes, test coverage is presented as percentage of checked test situations. Sometimes, it is a list of test situations that have been or should be checked by the test suites. Test coverage requirements present all possible test situations that must be covered by test suites execution. If test suites  meet the requirements, then \u201cexhaustive\u201d or \u201c100%\u201d test coverage is gained.","There is a difference between test coverage estimation for source code and for specifications. In the case of source code, a test situation is associated with a statement, branch of path in control flow graph of a program. In the case of specifications, the specifications are represented as logical expressions, i.e., boolean expressions. Thus, test situations are associated with branches and disjuncts of boolean expressions. Therefore, by using test situations for specifications, it is possible to define test coverage requirements for arbitrary specifications. This allows uniform notation for description and accounting of the test situations, coverage requirements and obtained coverage.","The test suites are generated based on the specifications. The specifications are implementation independent. Thus, the test coverage is preferably measured by means of an implementation independent way. For this purpose, the verification system preferably uses test coverage criteria which are based on the specifications.","In complex SUTs, \u201call test situations\u201d may not be covered. Accordingly, it is preferable to group similar test situations in classes. In this case, exhaustive coverage may represent coverage of all classes of test situations. Test situations and their classes may be identified and classified based on implementation source code or some external descriptions of the procedures under test. When a so-called \u201cblack box\u201d approach is taken to test SUTs, test situations and their classes are identified and classified based on knowledge of descriptions of the procedures under test.","The test coverage criterion is a metric defined in terms of implementation or specification. The most well known test coverage criteria in terms of implementation are:\n\n","In the case of using the specifications for test coverage criteria definition, the so-called domain testing approach is preferably used. The whole input space is partitioned into areas by the basic driver generator. Each area corresponds to a class of equivalence.","The source for test case parameter generation  generated by the basic driver generator  preferably includes source for the partition analysis. The partition determines the choice of one of the test generation techniques applicable to a procedure interface or an interface of a procedure group. The source for partition analysis includes a list of test situation classes that represent test coverage requirements, and initial data for partition analysis. The source for partition analysis is used to generate test case parameters .","The partition may be derived from the specifications that describe requirements on input and properties of outcome for target procedures. Both the requirements and properties are represented in pre-conditions and post-conditions of formal specifications in implicit form. Accordingly, the test coverage estimation can be carried out based on the implicit specifications. In this example, the average percentage of the test coverage of the verification system generated by the generator  for SOS KIL is 70% to 100% of statements in the implementation.","Furthermore, there are two levels of the test coverage criteria. The first one is the coverage of all branches in post-conditions. The second one is the coverage of all disjuncts, i.e., elementary conjunctions, in the Full Disjunctive Normal Form (FDNF) representation of the post-condition while taking into account the pre-condition terms. The verification system generator  allows automatic partitioning in terms of specification branches and FDNF. It is preferable to calculate accessible FDNF disjuncts and remove the inaccessible FDNF disjuncts using pre-condition design.","Monitoring of obtained test coverage is preferably conducted on the fly by script drivers . Based on this data, the script drivers  may tune testing parameters and\/or testing duration.","As described above, the verification system generation consists of a sequence of steps. For a step, needed tools are used where possible. Some tools generate auxiliary data, others convert and union their output and generate resulting target language code. To facilitate usage of these tools, it is preferable to use \u201cmanage\u201d utility. The \u201cmanage\u201d utility is a tool which works on a standard structure of UNIX directory where the tools and sources for verification system generations and generated test suites are stored.","The \u201cmanage\u201d utility works like UNIX \u201cmake\u201d. It analyses an interdependencies graph which represents interdependencies of the test suite components, and searches \u201cinconsistencies\u201d in the graph. Each \u201cinconsistency\u201d requires to make some kind of generation and compiling. After the \u201cmanage\u201d utility removes all \u201cinconsistencies\u201d, all needed test suites components become ready to use. The \u201cmanage\u201d utility uses a set of UNIX scripts and UNIX \u201cmake\u201d files. The \u201cmanage\u201d utility uses description of paths for all files used. It is preferable to define a \u201cstandard\u201d directory structure to store sources and generated files for generating verification systems, and directories of the verification system generator.","While particular embodiments of the present invention have been shown and described, changes and modifications may be made to such embodiments without departing from the true scope of the invention. For example, the present invention is described mainly using the verification system generator for verifying the SOS kernel. However, the present invention is suitably used for verifying a different system, such as a base level of call processing system, and a management system of tree-like store for queues with different disciplines. The present invention is mainly disclosed using RSL specifications. However, natural language documentation may also be used. Also, the present invention is mainly disclosed using UNIX. However, other operating systems may also be used."],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be further understood from the following description with reference to the drawings in which:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
