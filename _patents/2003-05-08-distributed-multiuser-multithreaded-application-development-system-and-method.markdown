---
title: Distributed, multi-user, multi-threaded application development system and method
abstract: An object-oriented multi-threaded application development system and method for developing resource information software is provided, wherein the application development framework is made up of three tiers. The first tier comprises at least one computer running a web browser, where the web browser is capable of running an object-orientated applet. The second tier similarly comprises at least one computer, wherein the computer runs a web server, a report server, and an application server. The first and second tiers are connected through a network. The third tier comprises at least a third computer, wherein the third computer runs an object-orientated database management system. The third computer is connected to the second tier through a second network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07124134&OS=07124134&RS=07124134
owner: 
number: 07124134
owner_city: 
owner_country: 
publication_date: 20030508
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","GetService (Admissions)","The Connector Object, Event Client Object, and Event Listener Objects","Servant Object","Component Pool Object","Balance Object","Monitor Object"],"p":["This application is related as a continuation of U.S. application Ser. No. 09\/670,988, filed on Sep. 26, 2000, now abandoned which is a continuation of U.S. application Ser. No. 09\/050,545, filed on Mar. 30, 1998, issued as U.S. Pat. No. 6,125,363.","As network technology becomes progressively more advanced, the demand for software capable of taking full advantage of these network advances correspondingly rises. However, many organizations dependent on information technology are struggling to manage complex heterogeneous environments that incorporate disparate hardware, software, applications, networks, and database systems. Thus, there has been an increasing demand and need for information resource software that is flexible, robust, and easily upgraded and customized. Moreover, it is desirable for these systems to be hardware independent, support multiple users, and based on a distributed architecture. Accordingly, the present invention provides an object-oriented, distributed, multi-user, multi-threaded application development framework for such applications.","There have been many attempts in the prior art to provide such an adequate information system. These systems, however, have been based on proprietary code that is hardware dependent, inflexible, difficult to upgrade, and difficult to maintain. An example of one such prior art system is disclosed in U.S. Pat. No. 4,839,822 which discloses an expert system for use in treating various types of trauma. This prior art expert system is a diagnostic system which is used to recommend a course of treatment based on information input from the user. The system achieves this result primarily through the use of a knowledge base and an inference engine. The software uses the well known Personal Consultant Plus inference engine, along with the Structured Query Language (SQL) database engine and the Essential Graphics software package. Based on the information input from the user, the inference engine receives information from the knowledge base which includes a collection of rules and parameter descriptions, upon which the treatment is suggested.","This prior art system, however, suffers from several shortcomings. Since the software is written in Microsoft C, upgrading or rewriting the code is significantly difficult and time consuming. For example, a rewrite of the code in order to use a different inference engine or a different database server would consume considerable time and effort. Moreover, the portability of the software is very limited. Due to inherent limitations of the C programming language, different versions of the software must be compiled for each different type of client computer used. An additional drawback to this type of software is how the data is stored. The data in a SQL relational database, for example, is stored in tables made up of rows and columns of records. In order to access this data, the methods for accessing it must be coded separately from the data.","Other prior art information systems known to applicants suffer similar drawbacks in that they generally accomplish their goals at the expense of cross platform capability, software maintainability, and cumbersome data retrieval and storage. This is so even though more flexible programming languages, such as Java, by Sun Microsystems, have been developed and even though the use of inference engines has increased. Therefore, it would be desirable to create a more flexible development system and method for use in expert type data processing systems that is more robust, flexible, maintainable, upgradable, and cross-platform capable than currently available in the prior art. Accordingly, applicants have developed an object-oriented, distributed, multi-user, multi-threaded development system and method which overcomes the disadvantages of the prior art.","A distributed, multi-user, multi-threaded application development system and method is provided in which the system architecture is made up of three tiers. The first tier comprises at least one computer running a conventional web browser, where the web browser is capable of running an object-oriented applet. The second tier similarly comprises at least one computer, wherein the computer runs a conventional web server, a conventional report server, and a conventional application server. The first and second tiers are connected through a network such as in intranet or Internet network. The third tier comprises at least a third computer, wherein the third computer runs an object-oriented database management system, with the third computer being connected to the second tier through a second network such as also an intranet or Internet network. The second tier applications may be abstracted by incorporating an application programming interface. The system and method of the present invention may support a multitude of users, be distributed over a multitude of computers, and be multi-threaded. The web browser running on the user or client computer may be any conventional web browser capable of supporting running a Java applet. The underlying application framework is written in an object-oriented language, such as Java, and is based on a set of hierarchical classes, wherein the classes comprise server components, client components, and an object model.","In employing the system and method of the present invention, the user or client instantiates a session by downloading an HTML page. The applet in the HTML page creates a ZeoConnector, which creates a ZeoEventClient. The ZeoConnector contacts the ORB through the Internet or intranet. The ORB hands the ZeoConnector to the ZeoServer. The ZeoServer creates a ZeoServant to handle all the traffic from the client. The ZeoServant instantiates a ZeoEventServer to handle all the client's requests for services. The client then chooses a service it invokes such as, for example, \u2018ADMIT A STUDENT\u201d, assuming the invention is used by an educational institution for management of its student database. The ZeoConnector contacts the ZeoServant. The ZeoServant requests an idle ComponentPool from ZeoBalance, which balances the workload among several servers. ZeoBalance reports where the idle Component Pool is to ZeoServant. The ZeoServant requests that a specific component be instantiated from Component Pool. The Component Pool then instantiates an instance of the ZeoComponent (e.g., ADMIT STUDENT). The ZeoComponent then obtains a reference to its ZeoEventServer. The ZeoComponent registers with ZeoMonitor through ZeoEventServer's EventQ. The ZeoEventClient tells the ZeoComponent what it wants to do. The ZeoComponent then instantiates the appropriate ZeoObjects to do the requested transaction. The ZeoComponent requests the appropriate GUI screen, which is sent to the ZeoEventClient., The client then inputs the information. The ZeoObjects perform appropriate functions based on the input, such as calling for Rules logic in the inference engine to help accomplish its task. The ZeoComponent then instantiates a ZeoRulesSession and pulls the appropriate rules and the ZeoObject executes the Rules according to its encapsulated functions. The ZeoObject may pull information from the OODBMS through DatabaseService or may store information in the OODBMS through the same DatabaseService class. When the ZeoComponent finishes its transaction, it is time stamped by ZeoEventServer, The ZeoEvent Client on Tier I continues to poll the ZeoEventServer to see if there are any active ZeoComponents in the EventQ. If none, ZeoMonitor is notified and shuts down the components that were activated. Java then cleans up the remaining dead ZeoServant, which is now empty.","Referring now to the drawings in detail, the present invention uses an object-oriented language, such as Java, with distributed network resources using Common Object Request Broker Architecture (CORBA), and the integration of an Object-Oriented Database Management System (OODMS).","As is well known, object-oriented programming, such as Java, employs a programming language that is based on the concept of an object. In order to understand the present invention, a brief review of conventional object-oriented programming may be helpful. In this regard, an object is a data structure that comprises a set of data fields and methods that operate on the data. Objects are structured by class. A class is a group of objects that inherit the same set of attributes. The code underlying the object is essentially invisible to the rest of the program; thus, so long as the interface to an object remains the same, the underlying code of an object may be changed without effecting the rest of the program. For example, a program may use an object called \u201cdoor\u201d, which receives a variable \u201cpush\u201d, and returns a variable \u201cdoor open\u201d. The code underlying the object \u201cdoor\u201d may be completely changed without effecting any other portion of the code that uses the object \u201cdoor\u201d, so long as the object still receives and returns the same types of data.","In particular, the well known programming language Java, available from Sun Microsystems, is uniquely suited for an enterprise wide information resource program. Since Java is an object-oriented programming language, it is very easily maintained and upgraded. Moreover, programs written in Java are not complied; rather, they are interpreted by a Java Virtual Machine (JVM). Any computer running a JVM is capable of running a Java Program. Currently, JVMs are part of many popular conventional web browsers, including Netscape Navigator, Microsoft Internet Explorer, and Sun's HotJava. Therefore, virtually any type of computer can run a program written in Java.","As noted above, the development system and method of the present invention preferably employs Common Object Request Broker Architecture (CORBA) which is a conventional open, distributed, object computing infrastructure that is currently being standardized. CORBA allows heterogeneous network clients to communicate with distributed network components. The CORBA specification accomplishes this by defining a software bus called the Object Request Broker (ORB). The ORB provides the infrastructure necessary to enable cross-platform communication among distributed objects and client programs. A CORBA compliant ORB automates many common network programming tasks such as object registration, location, and activation, request demultiplexing, framing and error handling, parameter marshaling and demarshalling, and operation dispatching. One example of such a CORBA compliant ORB is commercially available under the name Visibroker, from Visigenic.","Many conventional information resource software products, such as the prior art system disclosed in U.S. Pat. No. 4,839,822, use relational databases such as the SQL database from Microsoft. Although these databases may be robust and reliable, they are ill-suited for an object-oriented environment such as contemplated by the present invention. A relational database conventionally stores data in a row and column format. Accordingly, when an object sends data to a relational database, the data must be stripped from the object and reassembled in the row and column format so that it may be stored. Similarly, when requesting data from a relational database, the row and column data must be transformed into an object that the requesting program can understand.","This problem is not present in the present invention which employs an object-oriented database and an object-oriented database management system (OODMS). Unlike the relational database employed in the prior art, the object-oriented database or OODMS stores data as objects. Therefore, the database in the present invention can receive and store data as an object in exactly the same form that the object-oriented program uses them. Similarly, data can be retrieved from the database of the present invention in exactly the same object that the program requests it in.","Referring now to , the object-oriented, distributed, multi-user, multi-threaded application development system in accordance with the present invention is shown. As shown and preferred, the present invention system architecture consists of a set of classes, which are hierarchical in nature and consist of server components, client components, and an object model. The present invention allows information systems, or daughter applications, that are similarly distributed, object-oriented, multi-user and multi-threaded to be built on top of the framework of the system architecture. In the preferred embodiment of the invention, the system development architecture is organized into three Tiers, Tiers I, II and III. Generally, Tier  () comprises user or client CPU's running conventional web browsers with compliant conventional JVM's. Tier II () comprises at least one computer system with a conventional web server, application server, and report server. Tier III () comprises a computer system in which a conventional Object-Oriented Database Management System (OODBMS) has been installed. In the presently preferred embodiment of the present invention, the system development architecture is written entirely in the well known Java programming language and is run on any conventional computers capable of running Java. While other computer programming languages could be used for Tiers II and III if desired, Java allows for the best integration between all three tiers. The present invention preferably uses conventional pluggable computer components that can be switched easily without substantially rewriting the system's code. This is accomplished by using conventional, commercially available program components for the underlying infrastructure, and subsequently building abstraction layers on top of them. The abstraction layer of the present invention may be, for example, an application programming interface (API). Accordingly, since daughter applications are preferably written on top of the API, so long as the calls to the API remain the sane, the underlying third party products may be changed with minimal changes to the code of the system architecture. These pluggable components preferably consist of a report writer and server, an Object Request Broker (ORB), an inference engine, and the OODBMS. Although the present invention is flexible enough to employ any type of third party software, an illustrative example of a report server which provides preferred results is Actuate Report Server 3.0 commercially available from Actuate. Similarly, an example of a presently preferred ORB is Visibroker, commercially available from Visigenic. An example of a presently preferred conventional inference engine employed in the present invention is Advisor\/J2.0 commercially available from Neuron Data. The OODBMS may preferably be, for example, the object database commercially available from Versant Object Technology.","The tiers employed in the present invention shall now be described separately in greater detail, starting with Tier I illustrated in which shows the structural components of Tier I. Tier I generally comprises a conventional client computer , client objects , HTML page  and applet . The client computer  runs a conventional web browser . The client computer  may be virtually any type of conventional computer, so long as it is connected to the Internet\/intranet in some way. For example, as shown in , the client computer may be a conventional IBM PC, a workstation, a Macintosh, a laptop, or any combination of different computer types. The conventional web browser  is preferably capable of running a conventional Java Virtual Machine (JVM) . Examples of such conventional web browsers are Microsoft's Internet Explorer, Netscape's Navigator, or Sun's HotJava.","As shown and preferred in , the client workstation  contacts a conventional web server  which is part of Tier II to be discussed below. The web server  preferably sends the conventional web browser  an HTML page 220, which preferably has a Java applet embedded within it. As shown and preferred in , the applet  spawns a Connector Object , which is defined by a Connector class contained within the applet . The Connector Object then creates a Event Client Object . The Event Client Object  preferably handles service requests, and allows the client  to access any services or data. Moreover, when the Event Client Object  is created, it preferably creates an Event Listener Object . The Event Object  connects to the ORB  independently of the Connector Object .","Referring now to Tier II of the present invention, Tier II preferably comprises at least one conventional computer system with a conventional web server, application server, and a report server. As shown in , Tier II may be distributed; that is, there may be many servers in Tier II. However, if desired, Tier II may also be implemented with only one server. The use of multiple servers maximizes computing power, speed, and efficiency. Moreover, in a distributed environment, the servers may be load balanced so that the workload may be automatically balanced by spreading requests to idle machines. Additionally, Tier II preferably provides multi-user and multi-threaded support in accordance with the present invention. Any number of users or clients from Tier I can exist simultaneously, so long as the hardware can support it. Similarly, each client can be using Tier II resources at the same time, as each client has its own thread, from which there are sub-threads for each transaction conducted.","Referring now to , as shown and preferred, Tier II generally comprises a plurality of applications servers , , a web server , a report server , and an Object Request Broker (ORB) . The applications servers , further comprise a plurality of server classes , and a component pool . Each server preferably comprises all of these aforementioned elements; however, server  is shown, by way of example, with only a component pool  for clarity.","The application servers , , web server , and report server  may or may not be distributed among computer systems connected by an intra\/Internet, as desired, in accordance with the present invention. For example, the web server  and application servers ,  may reside on one machine, while the report server  resides on another machine in a different location. Similarly, although two application servers   are shown, this is for illustrative purposes only. The application server may actually reside on one machine, or be distributed among several depending on the needs and desires of the users of the system of the present invention.","The ORB  may be any conventional ORB that is CORBA compliant. For example, as previously mentioned, Visibroker from Visigenic may be employed. The ORB  is the gateway through which communication takes place between the user and the system. Tier I contacts the ORB  through an intranet or over the Internet . The ORB  directs traffic for all clients to the appropriate place to find what each client is requesting. For example, the ORB  allows the Connector Object  to connect to the Server Object  on the application server . Although the application server may be one or a multiple of machines in various locations, the client software need not know where an object resides, so long as the ORB  is running. The Connector Object  merely requests an object from the ORB , and the ORB  allows the Connector Object  to connect to the requested object. For example, assuming an education based student database management system, the Event Client Object  may execute the following request:","This request would subsequently be sent to the ORB , which would then allow the Event Client Object  to connect to the Event Servant Object , where the class \u201cAdmissions\u201d resides. This would then allow an object \u201cadmissions\u201d to be created.","Moreover, server objects may be classified as either distributed or non-distributed. Distributed components are capable of being remotely invoked. Thus, a distributed component in an application may communicate with other distributed components, collaborating on the results of operations, transactions, and performing services. Additionally, distributed components proceed a component execution system, allowing communication, load-balancing, monitoring, security, transaction, and persistence services. These services are analyzed in greater detail below.","Referring to , asynchronous communication between objects preferably is implemented using the Servant Object , Connector Object , Event Client Object , Event Server Object , and Event Listener Objects . In general, when a client  requests a service, a Servant Object  is issued to process its requests, and an Event Server Object  thread is started. In the Connector Object , an Event Client Object  thread is preferably started and connects with the Event Server Object . The Event Client Object  polls the Event Server Object  for waiting events and processes them using the Event Listener Object . Additionally, the Default Event Listener class provides basic processing of events such as system messages and requests for data from application components. The following details the various objects used in asynchronous communication between objects in accordance with the present invention.","As discussed above, once spawned, the Connector Object  creates the Event Client Object . The Event Client Object  handles service requests, and allows the client  to access any services or data. Moreover, when the Event Client Object  is created, it creates a Event Listener Object . The Event Listener Object  connects to the ORB  independently of the Connector Object .","The Servant Object  manages and controls the interaction between the client and the system. Once created, the Servant Object  manages and works with the Connector Object  to handle all transactions between the two tiers, I and II. All transactions go through the ORB  which continues to direct the Connector Object  requests to the Servant Object  for handling.","The Servant Object  is preferably created when the ORB  receives a request for a Servant Object. In response to this request, the Server Object  creates a Servant Object  from its Servant Object class. Once the Servant Object  is created, it handles all requests from the client  through the Connector Object  and the ORB . Further, once the Servant Object  is created, it creates a Event Server Object  for all asynchronous service communication between the Event Client Object  and Component Objects .","Referring now to , load balancing is preferably implemented and managed by the server classes Monitor object  and Balance Object . Preferably, Monitor Object  keeps track of the number of clients connected and the amount of server side resource each client is using, as well the amount of RAM each client consumes. Monitor Object  also preferably keeps track of the client connections, so that if a client loses a connection, Monitor Object  may reclaim the resources used by the client. Balance Object  preferably keeps track of Component Pool Objects ,  and provides for distribution of application processing across the Component Pools. The following analyzes these objects in detail.","The Component Pool object ,  manages resources and reclaims them when the various services from the various Component Objects are finished and no longer active. The various services can be distributed among various servers on the intranet, or across the Internet, maximizing performance and CPU resources.","The Component Pool Objects ,  preferably comprise a table of component objects with references for all of the attributes for each component object. Further, the Component Pool Object ,  is the base class object for all components in the invention. Moreover, the Component Pool object ,  preferably exists on each server in the network on which the application software is installed. Once a Component Pool object is created, it preferably registers with the Balance Object , described below.","The purpose of the Balance Object  in the present invention is to balance the workload among multiple servers , . Moreover, the Balance Object  preferably allows multiple users to access the system at once. Upon a service request from a client, Balance Object  preferably returns the location of an idle machine. Balance Object  is aware of each Component Pool Object  on each Server , in the system as compared to conventional load balancing, which essentially issues a query to each idle CPU upon a request from a client.","The interaction of Balance Object  with Component Pool Object  allows the software to efficiently manage the load balancing across network machines. For example, the Servant Object  may issue a request such as \u201cGetAvailPool(x)\u201d to Balance Object . Balance Object  would then return the most idle Component Pool, for example, Component Pool , which would reside on the most idle CPU of a server  in the network. Servant Object  then calls the referred Component Pool for an instance of the requested service. The Component Pool  then creates an instance of a Component Object  for use by Servant Object . Further, once it is created, the Component Object registers with the Monitor Object  (discussed below), and obtains a reference to its Event Server Object . The Event Server Object  then creates an Event Queue  to track the queue of Events for the client, while the Component Object reference is returned to the Event Client Object  through the Servant Object . Subsequently, the Component Object is connected to the ORB , and the client may invoke operations through the Event Client Object  on the Component Object  directly.","The purpose of the aforementioned Monitor Object  in the present invention is to monitor the processes of each Servant Object  and of all of the Servant Object's threads in order to conserve resources and maximize efficiency. In order to accomplish this, preferably the Monitor Object  has a vector  with every activated and live Servant Object  listed. Moreover, every Servant Object on the vector has every component Object  existing on the Servant Object  referenced in the vector . Once a Component Object  is finished, the Monitor Object  preferably releases resources claimed by the Component Object in order to conserve system resources.","The Monitor Object  preferably works in the following way. When a client  evokes an operation or transaction, it necessarily changes something in at least one Component Object . When a change in a Component Object  occurs, the Event Server Object  time stamps the Component Object  with the time of the last transaction. The Event Client Object  polls the Event Server Object for a message indicating that a component is still active. The amount of time between each poll is selectable. The Server Object's Event Queue  will report to its Event Server Object a message indicating that a component is still active. If a servant Object  is still connected to its originating client and processes are still ongoing, Monitor Object  does nothing to the component. However, if a Servant Object  reports no action back from its Event Server Object , the Monitor Object preferably kills any remaining Component Objects , and reclaims any resources that they were using.","Referring now to , the Security Object  preferably provides encryption and role-based security interfaces used by the Servant Object to limit access to specific application components and functions. This is based upon entries in OODBMS  of  for users, roles, and services. The system includes the ability to define access for specific users or groups of users for specific date ranges. Additionally, Security Object  preferably provides for encryption of data between tiers of the system architecture including client to server data exchange.","Transaction tracking is preferably provided in the system of the present invention by a service called Transaction Object . Transaction Object  provides an interface to application components, called Component Objects , for the validation and coordination of events. This includes updates, deletions, and creations of database data in the OODBMS.","Persistence of data in the system of the present invention is preferably provided via the Database Service Object . The Database Service Object  abstracts query, commit, rollback, and delete operations on the OODBMS. Application components operate on business objects, referred to as Objects , which are stored in the OODBMS. The Database Service Object interface is written in terms of these objects.","Non-Distributed components of the preferred system architecture include the inference engine instance, component connections to the OODBMS via the Database Service, business objects described by the object model and implemented as descendants of Object, and Event listeners. These components are not invoked remotely by other objects outside their individual threads of execution.","As shown and preferred in , Tier III preferably comprises the Object-Oriented Database Management System . (OODBMS). The OODBMS  comprises administrative databases, as well as any other databases used by daughter applications residing on top of the application database system architecture framework of the present invention. As shown and preferred in , communication between Tier II and Tier III is accomplished through a network. For example; communication may take place through an Ethernet network. Moreover, the OODBMS  may be connected to Tier II through an intranet or through the Internet.","For the sake of clarity, the following example will trace through the starting, requesting, and ending of a process with reference to \u2013","As shown in , a client  running a Java compliant web browser  issues a request  to a web server  for an HTML page. In response, the web server  sends an HTML page  to the client . As shown in , the Java Applet  contained in the HTML pace creates a Connector Object . In turn, the Connector Object  creates an Event Client Object . Next, as shown in , the Connector Object  contacts  the ORB  through the intra\/Internet . The ORB  connects  the Connector Object  to the Server Object . The Server Object  then creates a Servant Object  to handle all traffic from the client  as shown in . Subsequently, the Servant Object  creates a Event Server Object  to handle all the client's  request for services. The client  then chooses a service it wishes to invoke. For illustrative purposes, let us assume the client  chooses to invoke the service \u201cADMIT A STUDENT\u201d. The Connector Object  then contacts  the Servant Object  through the intra\/Internet  and the ORB  as shown in . Subsequently, the Servant Object  contacts  the Balance Object , requesting an idle Component Pool. Next, as shown in , the Balance Object  reports  where an idle Component Pool  is located to the Servant Object . The Servant Object  then requests  that a specific component (in this example, \u201cADMIT A STUDENT\u201d) be created from the Component Pool . As shown in , the Component Pool  then creates  a Component Object . Moreover, the Component Object  receives a reference to its Event Server Object . Next, as shown in , the Component Object  registers  with the Monitor  through the Monitor's Event Server Object . The Event Client Object  then tells  the Component Object  what it wants to do (in this case, \u201cAdmit Student\u201d) as shown in . Subsequently, the Component Object  creates the appropriate Object  to complete the transaction. The Component Object  then preferably requests the appropriate GUI screen, which is sent to the Event Client Object . Based on this GUI, the user inputs information. The Component Object  then performs the appropriate functions, such as calling for Rules logic to help it accomplish its task if needed.","As shown and preferred in , if required, the Component Object  creates  a Rules Session  and pulls the appropriate rules. The Object  executes the Rules according to its encapsulated functions. Moreover, the Object  may pull  or store  information from the OODBMS through a Database Service .","When the Component Object  finishes its transaction as shown in , it is time stamped  by the Event Server Object . Moreover, the Event Client Object Continues to Poll  the Event Server Object  to see if there are any active Component Objects  in the Event Queue . If there are none, the Monitor  is notified, and shuts down the components there were activated. The remaining Servant Object  is then cleaned up by Java.","Summarizing the operation of the system of the present invention, with reference to , the Client launches browser with JVM and contacts the web server for appropriate HTML page. The HTML page has an applet embedded in the page. The HTML applet instantiates a ZeoConnector object from the ZeoConnector class contained in the applet. The ZeoConnector object knows how to contact the ORB. The ZeoConnector instantiates a ZeoEventClient to handle service requests. The ZeoConnector object contacts the ORB through an intranet or over the Internet. The Internet\/intranet represents the beginning of Tier II. The ORB is the third party component that directs traffic for all clients to the appropriate place to find what each client wants. The ORB tells the ZeoConnector where the ZeoServer class is, on the Application Server. The ORB allows the ZeoConnector to connect to the ZeoServer class. The ZeoServer class instantiates a ZeoServant from its ZeoServant class. The ZeoServant will now handle all requests from the client through the ZeoConnector and the ORB. ZeoServer is no longer invoked. When instantiated, the ZeoServant instantiates a ZeoEventServer for all asynchronous service communication between the ZeoEventClient and ZeoComponents. In order for the client to access any services or business objects (data), a ZeoEventClient must be created. The ZeoConnector instantiates a ZeoEventClient object to handle all transactions between the system and the client. ZeoConnector instantiates the ZeoEventClient upon its own creation. When ZeoServant is created for a client by ZeoServer, ZeoServer creates a ZeoEventServer. When ZeoConnector is instantiated, it instantiates a ZeoEvent object, which connects to the ORB independently of the ZeoConnector. The ZeoEventClient object then executes a request for a service on the ZeoServant.","As noted above, there can be many servers in a installation of the invention so that load balancing takes place across all the servers. This maximizes computing power, speed and efficiency. The system also runs on just one server. Any number of clients on Tier I can exist simultaneously, so long as the hardware can handle the connections for each client. Each client can be using the system of the present invention at the same time. Each client has its own thread, from which there are sub-threads for each transaction conducted. The invention automatically load-balances the workload to spread the requests to idle machines. Each server in the network, which is intended to be used by the invention, has to have the system of the present system software installed on it to work. Each server has to run \u201cstartPool\u201d to instantiate its Component Pool, which is then available for use. Thus, after the client has contacted the system and a ZeoServant has been created on the Tier II, a ZeoEventClient has been created on Tier I and both communicate with each other through the ORB.","ZeoBalance balances the workload among several servers and allows multi-users to access the system at once. The present invention uses an improved process that allows for more information to be processed than in conventional load-balancing in object-oriented systems. For each new service request from any client, ZeoBalance returns the idle machine, spreading out each instantiation over the available CPUs. This is better than conventional systems because it works on the larger chunks of data. Load-balancing conventionally is done on the query-level each query sent to an idle CPU. This is a holdover from relational databases. Here it is load-balanced on the entire service. This takes greater advantage of the inherent nature of objects as encapsulated packets of data and functions. ZeoBalance knows about each ComponentPool on each server in the system. ZeoBalance is essentially a foreman, making sure all transactions are being completed in the most efficient way. ZeoBalance exists as a permanent object in the system and is not instantiated by anything else.","ComponentPool has a table of component objects with references for all of the attributes for each component object. ComponentPool is the base class object of all components in the present invention. Part of the installed software on each server in the network is a class for creation of an instance of Component Pool. There can be multiple instances of the same ComponentPool on as many servers in the network. The number will equal the number of servers with the invention software installed on it. ComponentPool registers with ZeoBalance when it is instantiated.","ZeoBalance and ComponentPool work together as follows. ZeoServant executes \u201cgetAvailPool(x)\u201d on ZeoBalance. ZeoBalance returns the most idle ComponentPool (on the most idle CPU of a server on the network). ZeoServant calls the referred ComponentPool and obtains a component client. ZeoServant asks the ComponentPool for an instance of the requested service. ComponentPool instantiates a component object (\u201cZeoComponent\u201d) for use by the ZeoServant. The ZeoComponent registers with ZeoMonitor when it is instantiated. (Upon instantiation, ComponentPool registers with ZeoBalance; the ZeoComponent registers with ZeoMonitor). The ZeoComponent also obtains a reference to its ZeoEventServer at instantiation. The ZeoEventServer creates an EventQueue to track the queue of ZeoEvents for the client. The ZeoComponent reference is returned to the ZeoEventClient through ZeoServant. ZeoComponent is connected to the ORB. Client invokes operations through the ZeoEventClient on the ZeoComponent directly.","As noted above, ZeoMonitor monitors the processes of each ZeoServant and all of that ZeoServant's threads to conserve resources and maximize efficiency. ZeoMonitor has a vector with every activated and alive ZeoServant listed. Every ZeoServant on the vector has every ZeoComponent existing on the ZeoServant referenced in the vector. Each ZeoComponent is registered with ZeoMonitor upon instantiation. ZeoMonitor essentially tracks client\/server heartbeat signals to make sure ZeoServants are still alive and that all the ZeoComponents within the ZeoServant are active. ZeoMonitor cleans up finished ZeoComponents to conserve system resources. This is a new and efficient way to keep the invention from eating up resources and eventually requiring server reboots. Dead (inactive) ZeoServants are automatically culled by Java's garbage collector function.","ZeoMonitor works as follows. When the client evokes an operation or transaction, it necessarily changes something in at least one ZeoComponent. When that happens, the ZeoEventServer time stamps the ZeoComponent with the time of the last transaction. ZeoEventClient polls the ZeoEventServer every X seconds (or whatever period of time is assigned) for NextEvent (from the ZeoEvent class). ZeoEventServer's EventQueue will tell the ZeoEventServer one of three messages: RULERESULT; RULEQUERY; or HEARTBEAT. These three messages are constants in the ZeoEvent class. If there is another event, the EventQueue will notify the ZeoEventServer, who will report the message back to the ZeoMonitor when polled. Even if it is only a heartbeat to tell it that the EventQueue is still working on something, the ZeoMonitor will wait. ZeoMonitor polls each ZeoServant to see when its last timestamp was. If a ZeoServant is still connected to its originating client and processes are ongoing, ZeoMonitor does nothing. If a ZeoServant reports nothing back from its ZeoEventServer, then the ZeoMonitor kills any remaining ZeoComponents. Eventually, the dead ZeoServant is culled by the garbage collection of the Java language.","Components also communicate directly with the ORB regarding any direct communication between it and the ZeoEventClient. ZeoComponent uses the ZeoEventServer to handle asynchronous communications between it and the ZeoEventClient. For example, if the ZeoComponent has a method built in and the ZeoEventClient calls on it to perform directly, the ZeoComponent will perform and report the result to the Client Directly. If, however, ZeoComponent needs more information, it works through ZeoEventServer to handle the communication to the ZeoEventClient. When ZeoEventClient responds with the new data, ZeoEventServer reports it to the ZeoComponent to finish the transaction.","ZeoObjects is the base class for all business objects in the architecture of the present invention.","It should be noted that preferably the knowledge bases are not written in Java but rather in a declarative programming language which is accepted by the particular inference engine used. With respect to the present preferred use of Advisor\/J 2.01 from Neuron Data, an example excerpt of a knowledge base in a student database management system is given below:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CourseTaughtByInstructor is any CourseSection such"]},{"entry":[{},"that (it.teacher <>Null)."]},{"entry":[{},"AnInstructor is any Instructor."]},{"entry":[{},"CourseNeedsInstructor is any CourseSection such"]},{"entry":[{},"that (it.teacher = null)."]},{"entry":[{},"CoursesTaughtByAnInstructor is any CourseSection"]},{"entry":[{},"such that (it.teacher = AnInstructor)."]},{"entry":[{},"rule FacultyLoad English is if"]},{"entry":[{},"(CourseTaughtByInstructor.teacher.dept ="]},{"entry":[{},"\u201cEnglish\u201d) then"]},{"entry":[{},"{"]},{"entry":[{},"CourseTaughtByInstructor.teacher.teachingLoad ="]},{"entry":[{},"CourseTaughtByInstructor.teacher.teachingLoad +"]},{"entry":[{},"CourseTaughtByInstructor.hours * 0.0333, print"]},{"entry":[{},"(\u201cNew load calculation:"]},{"entry":[{},"\u201cCourseTaughtByInstructor.teacher\u201d load is"]},{"entry":[{},"\u201dCourseTaughtByInstructor.teacher.teachingLoad)"]},{"entry":[{},"}"]},{"entry":[{},"rule FacultyLoad_Math is if"]},{"entry":[{},"(CourseTaughtByInstructor.teacher.dept = \u201cMath\u201d)"]},{"entry":[{},"then"]},{"entry":[{},"{"]},{"entry":[{},"CourseTaughtByInstructor.teacher.teachingLoad ="]},{"entry":[{},"CourseTaughtByInstructor.teacher.teachingLoad +"]},{"entry":[{},"CourseTaughtByInstructor.hours * 0.0250, print"]},{"entry":[{},"(\u201cNew load calculation:"]},{"entry":[{},"\u201cCourseTaughtByInstructor.teacher\u201d load is"]},{"entry":[{},"\u201dCourseTaughtByInstructor.teacher.teachingLoad)"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As noted above, the present invention is preferably a three-tiered architecture with clients, on Tier I, accessing the system by starting a web browser with a complaint JVM; accessing the system's homepage via the Www (World Wide Web); the web browser starts an applet embedded in the HTML document downloaded from the web server running on Tier II; and the applet instantiates a ZeoConnector which then connects the ZeoServer running on Tier II. Once a client instantiates a ZeoConnector, he or she must log into the system by presenting a userid, password, and the particular application suite needed. The ZeoServer instantiates a ZeoServant which will process requests from the user for services. Each client who logs into the system successfully, based upon a database of user definitions administered through the system Administrators, receives its own ZeoServant. The ZeoServant is for all intents and purposes a dedicated \u201cserver object\u201d responsible for answering the needs of this particular client. The interface for a ZeoServant is published via CORBA's IDL definition language and the underlying communications protocols established by the ORB implementation. The ORB serves as a \u201cmiddleman\u201d in all communications between client and server, routing requests for service to the appropriate ZeoServant. The list of services available to a particular client correspond the ZeoComponents which are the basic functional unit of the architecture. ZeoComponent is a base-class from which all components in applications are derived. All share a common parent interface which is implemented at the ZeoComponent level and described in IDL.","The ZeoRemote is a GUI widget which provides for the selection of application services from a list of services validated by the ZeoServant on the basis of the client's userid, password, and \u201crole\u201d as defined via ZeoSecurity. Once a user selects a service, the client accesses the thin-client GUI classes for that particular service by downloading them from the web server. This means that if interfaces have changed, perhaps a new version of the GUI is available, the client always uses the most up-to-date version without the costly MIS overheads associated with managing an install-base of thick-client administrative software. The user interacts with the system via the user interface. Behind each component GUI frame, on the applications server, there exists an instance of a class derived from ZeoComponent.","As discussed above, ComponentPools provide for distributed computing by allowing the ZeoBalance to spread application processing over multiple processes or even servers forming an applications server cluster. Using this strategy, the system architecture can leverage the most of computing power by combining the resources of application server hardware to support more concurrent client connections. ZeoComponents have associated ZeoRulesSessions and manage zero or more business objects which derive from the ZeoObject base class. ZeoObjects are persistent, rules-aware objects over which business rules enforce the policies and practices of an institution using applications based upon the system of the present invention. Business rules are evaluated whenever an operation is invoked upon a ZeoComponent from the client interface. Rules enforce business policy and procedure and are represented in an ASCII format rulebase processed by the inference engine embedded in the ZeoRulesSession. As noted above, the presently preferred embodiment of the present invention uses Neuron Data's Advisor\/J 2.0 inference engine and rulebase language. Rules are developed using the Advisor\/J Builder IDE and are organized into projects and reside on the application server's secondary storage device. In a student database management system using the present invention, ZeoObject subclasses represent business objects such as \u201cstudents\u201d, \u201cinstructors\u201d, \u201cpayroll transactions\u201d, \u201cbenefit plans\u201d, etc. ZeoObjects are persistent and are stored in the ODBMS using the system DatabaseService class which is part of ZeoPersistence. An example of a business rule assuming a payroll system, which illustrates the rulebase syntax and purpose of the rule is:",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"APayroll is any PayrollObject."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule","CalculateDollarAdjustment R1 is"]},{"entry":[{},"if","InvalidPayroll.Value = false and"]},{"entry":[{},{},"Apayroll.earningTrans = \u201cRegular\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"then",{},{}]},{"entry":[{},"{","Apayroll.dollarAdj =","Apayroll.hours *"]},{"entry":[{},{},{},"FedConstants.minWage,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"print","(\u201cYour dollar adjustment has been"]},{"entry":[{},{},"calculated based upon minimum wage"]},{"entry":[{},{},"as \u201cApayroll.dollarAdj)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Rules are triggered through user initiation of a component transaction. Rules are enforced by the ZeoRulesSession's inference engine and operate over native Java objects. The inference engine includes both forward-chaining and backward-chaining support through its inference algorithm. Rules are stated atomically in terms of the business rule they represent and are evaluated based upon the data provided to the engine and the conditions of the rule(s). This approach separates the business logic of an application from the process logic. It enables changes to the rulebase reflecting changes in business policy or procedure without forcing the system to be taken offline and are centrally managed.","As opposed to making changes to SQL queries in an RDBMS-driven system or modifying and then recompiling code written in COBOL, this strategy isolates changes in policy or procedure from the source-code level implementation of services such as distributed communication, persistence, GUI interaction, etc.","Business rules allow customization by resting on a solid Core Object Model and isolating the details of \u201chow\u201d from the business-oriented concerns of \u201cwhat\u201d, \u201cwhen\u201d, \u201cwhy,\u201d and \u201chow much?\u201d Instead of forcing a client institution to adapt its policies and procedures to match a new system, the system of the present invention allows the system to adapt to the client institution. Rules are partitioned based upon functional area and allow customization for individual institutions without re-implementation of the entire system. In order to provide maximum flexibility for the development of software in accordance with the present invention intended for educational institutions ranging from small to large with varying requirements, practices, etc. code generators may be employed to provide much of the implementation for applications making maximum use of the system framework. Code generators provide for great savings in application development time and allow a small team of developers to create large and complex distributed systems quickly, consistently, and coherently. The code generation process may make use of metadata descriptions of application data, GUI, and functionality. From this metadata, code generation can produce the base files necessary for the implementation of the entire 3-tiered application. Customization and implementation can then proceed extremely quickly. Regeneration preserves customized code and implementation work and allows the redesign of GUI screens, and the addition\/deletion of data elements to continue without redesigning or reimplementing the entire system."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2","i":"a "},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2","i":"b "},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4","i":"b "},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5","i":"a "},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5","i":"b "},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5","i":"c "},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5","i":"d "},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5","i":"e "},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5","i":"f "},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5","i":"g "},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5","i":"h "},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5","i":"i "},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5","i":"j "},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5","i":"k "},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 6","FIG. 1"]}]},"DETDESC":[{},{}]}
