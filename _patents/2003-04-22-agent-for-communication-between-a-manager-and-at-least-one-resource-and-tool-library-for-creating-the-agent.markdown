---
title: Agent for communication between a manager and at least one resource, and tool library for creating the agent
abstract: The agent for communication between a manager () and at least one resource () comprises a protocol core () created automatically from a formalized description of the resource (), this core (), once created, comprising in compiled form an interface () for communication with the manager () and a model () of the resource () comprising the values of the instances of the resource (), these values being accessible by the administrator () through the communication interface ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07562126&OS=07562126&RS=07562126
owner: Thomson Licensing S.A.
number: 07562126
owner_city: Boulogne-Billancourt Cedex
owner_country: FR
publication_date: 20030422
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","DESCRIPTION OF RELATED ART","SUMMARY OF THE INVENTION ","DESCRIPTION OF THE PREFERRED EMBODIMENT(S)"],"p":["This application is a divisional application of application Ser. No. 09\/335,773, filed Jun. 18, 1999 now U.S. Pat. No. 6,615,250.","The present invention relates to an agent for communication between a manager and at least one resource of a data processing system. The manager is also known as an administrative platform. The invention also relates to a library of tools for creating an agent. An agent of this type enables a manager of a data processing system to control, monitor and evaluate computing resources remotely. The invention also relates to a process for communicating between a manager and a resource using an agent that enables a manager of a data processing system to remotely control, monitor and evaluate computer resources.","It is known in the prior art that a distributed system is constituted by computing resources, which may be mainframes, workstations, bridges, routers, printers, operating systems, applications, etc. In short, any entity of the data processing system is considered to be a resource.","To administrate or manage a distributed system is to manage all of its resources. An administrative platform (or manager), which must have as complete, accurate and detailed a view as possible of the resources it has to manage, is used for this purpose.","This view of a resource is made possible by a model of the resource in question. The modeling of a resource is based, in particular, on an approach and a structuring of objects organized into a tree of management information. The model of a resource is managed by an agent capable of instantiating these objects with the help of information from the resource or from the administrative platform.","Because of the specificity of each resource, each agent must be created individually for each of its resources, and must contain the expertise for communicating with the manager, also called known as the protocol core, and the expertise of the system to be managed.","The known methods for developing an agent of the prior art consist of a programmer's designing, in their entirety, the expertise for communicating with the manager and the expertise for communicating with the resource to be managed. In its development, the programmer is confronted with two types of problems, those linked to the protocol for communicating with the manager and those linked to the development of the expertise of the resource to be managed. Furthermore, these two types of expertise are not separated in the agent, resulting in problems in terms of performance, robustness, code quality, reliability, and development time for the agent, since the programmer is confronted with two problems at once and therefore, for each agent developed, the programmer must systematically develop the protocol core without being able to reuse it.","Hence, the first object of the present invention is to eliminate the drawbacks of the prior art by offering a simpler, faster agent, designed so as to be adaptable to different contexts and having great reliability.","This object is achieved by the fact that the agent for communication between a manager and at least one resource of a data processing system comprises a protocol core created automatically from a formalized description of the resource, this core, once created, comprising in compiled form a first interface for communicating with the manager and a model of the resource comprising the values of the instances of the resource, these values being accessible by the manager through the first communication interface.","According to another characteristic, the agent comprises, in a second interface, at least one method for accessing the resource for communicating with the protocol core and updating and\/or reading at least one value of an instance of the model of the resource specific to the method, and for responding to requests from the core related to the updating of at least one instance value of the model of the resource.","According to another characteristic, the resource being modeled in the form of attributes, access to each attribute managed by the agent can be obtained in either a \u201cdirect\u201d mode or a \u201csignal\u201d mode, defined in a configuration file <agt>.confget.","According to another characteristic, when the access method uses sockets interface primitives, the configuration file includes an identifier of the method that is associated with the instance.","According to another characteristic, the formalized description of the resource is in the form of an MIB (management information base).","According to another characteristic, the model of the resource comprises a sorted database constructed from the formalized description of the resource.","According to another characteristic, the protocol core includes a compiled file containing sorted data for the management of objects specific to its operation.","According to another characteristic, the communication between the manager and the protocol core takes place in accordance with the Simple Network Management Protocol (SNMP) ASN1 (Abstract Syntax Notation One), by means of verbs that allow the operations for reading an instance (get), for reading the next instance (get-next) and for modifying an instance (set).","According to another characteristic, when the manager sends, in the same request, an operation for a modification (SET) on a list of instances, the core transmits instance modification messages (SET) one by one to the methods corresponding to each instance, the last message for modifying the last instance being transmitted by a modification message (SETLAST) indicating that it is the last instance in the list; as long as the method has not received the last message from the core, the modifications of the instances are stored, and as soon as the last message is received by the method, if all the modifications of the instances are possible, they are all validated, whereas if not, they are all cancelled.","According to another characteristic, the communication between each access method and the core takes place through online TCP\/IP (Transmission Control Protocol\/Internet Protocol) communication software.","According to another characteristic, the communication between the protocol core and at least one method for accessing the resources in the \u201csockets\u201d mode takes place through two TCP\/IP connection processes that communicate through sockets executable primitives, making it possible to perform the operations for reading the value of an instance (readInstSock), for modifying an instance (writeInstSock), for reading the next instance (readNextSock), for writing a new instance, and for deleting an instance.","According to another characteristic, the communication between two methods () of access to the resource () in the \u201csockets\u201d mode is established by calling a function (notifyMeth).","According to another characteristic, the communication between the protocol core and at least one method for accessing the resources in the \u201cdirect\u201d mode takes place through named pipes and executable primitives, making it possible to perform the operations for reading the value of an instance (readInstDirect), for modifying an instance (writeInstDirect), for reading the next instance (readNextDirect), for writing a new instance, and for deleting an instance.","According to another characteristic, the structure of each message related to an operation on an instance of the resource, and constructed by the protocol core of the agent to be sent to at least one method, comprises a field for identifying the instance, a field corresponding to the value of the instance, a code identifying the operation to be executed and a return code indicating whether the operation has been performed.","According to another characteristic, the manager and\/or the method can create an instance in the model of the resource managed by the core, by means of a request sent to the core containing the verb (SET) for an instance modification on an instance that is non-existent in the model, the reception of this request by the core resulting in the creation of the instance.","According to another characteristic, the manager and\/or the method can delete an instance in the model of the resource managed by the core by means of a request comprising the verb (SET) for modifying an instance, which assigns the name of the instance to be deleted to a predetermined, preexisting instance (gamDeleteObject) of the model of the resource, the reception of this request by the core resulting in the deletion of the instance.","According to another characteristic, the model of the resource included in the core is a database sorted in the lexicographical order of the protocol SNMP.","According to another characteristic, the model of the resource managed by the core is initialized by an instance file created by the user before the initialization of the core.","According to another characteristic, the successive modifications of at least one instance value of the model of the resource are stored in a backup file of predetermined maximum size.","According to another characteristic, a merge between the instance file and the backup file is performed before the initialization of the core, or when the backup file has reached the predetermined size, or when the user so desires, in order to create a new instance file containing the last values of the instances saved in the backup file and to create an empty backup file.","According to another characteristic, the values of the instances recorded in the backup file are accessible by a user before the merge with the instance file.","According to another characteristic, each line of the backup file corresponds to a modification, a deletion, a creation or a writing of an instance, and comprises a field containing the name of the instance, a field containing the value of this instance, and a field containing the identification of the type of operation performed on this instance.","According to another characteristic, prior to the merging of the instance file with the backup file, both of these files are copied onto the hard disk of the resource.","A second object of the invention is to provide a tool library that makes it possible to create a communication agent in a generic, simple and fast way.","This second object is achieved by the fact that the tool library for creating an agent for communication between a manager and at least one resource of a data processing system comprises a command which, from a formalized description of the resource, creates in the form of an executable program the protocol core of the communication agent that manages the resource.","According to another characteristic, the library comprises at least one development support function, which allows the user to develop methods of the resource capable of communicating with the protocol core and\/or of updating at least one instance of the model of the resource and\/or of reading at least one instance of the model of the resource.","A third object of the invention is to offer a process for communication between a manager and a resource using an agent according to the invention.","This object is achieved by the fact that the process for communication between a manager and a resource using the agent according to the invention comprises:","a first step for sending a request from the manager to the resource in order to read information of the resource, and","a second step for the decoding of the request by the core of the agent in order to determine the instance corresponding to the desired information and the mode for obtaining this instance.","According to another characteristic, if the mode for obtaining the instance is the \u201cdirect\u201d mode, the core of the agent constructs, then sends a request for a response to the manager, giving it the value of the instance existing in the model of the resource it manages.","According to another characteristic, if the mode for obtaining the instance is the \u201csignal\u201d mode, the core of the agent constructs, then sends a message to the method corresponding to the instance, in order to obtain the value of the instance.","The corollary subjects of the invention are a data processing system which includes at least one agent according to the invention and a medium for recording data such as a magnetic disk or a CD-ROM, and which incorporates a computer program for using an agent according to the invention and\/or a tool library as defined above, and\/or the process defined above for creating an agent according to the invention.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 1","b":["10","20","30","20","30","11"]},"The importance of the agent's role in this case is clear, since it is the agent that is responsible for maintaining and animating the model of the resource.","The agent in question in the present invention is an agent of the simple network management protocol (SNMP agent). The protocol SNMP, which is the dialogue between a manager and a resource, takes place in accordance with the most widely used protocol in the administrative platforms of the system. In a very schematic view, it is possible to divide an SNMP agent into standard communication layers and into layers that provide facilities for encoding and decoding syntaxes and manipulating objects.","The objects (or information quanta) are available through what is called a management information base (MIB), which is a sort of virtual database that models the resource to be managed. In deprecated language, it is often said that an agent manages an MIB.","An agent also contains, above all:","code for managing the management model of the resource to be managed, called the protocol core;","expertise on the resource in the form of controllers (based on the detail of the model managed by the agent).","Thus, in an agent, both code and specific expertise are associated with each resource to be managed.","The operations available through the management protocol SNMP, which enable the agent to manipulate the objects of the MIB it manages, are the following:","reading of an object (get)","reading of the next object (get-next)","writing of an object (set).","Let us also note that rather than the objects, which are actually templates or forms, it is the instances of these objects that are manipulated by the protocol SNMP and the agent.","In order to instantiate the objects of the MIB that it manages, an agent must search for the information directly in the physical resource by means of methods, which are procedures associated with a particular object and initiated each time it is necessary to perform an operation on the object in question. It is by means of these methods that the instances of the MIB assume a semantic value: depending on the way in which the value of an instance is searched for in the physical resource, this instance will have one meaning or another, or one function or another.","The agent according to the invention has the characteristic of comprising a protocol core developed automatically, by means of tools described below, from data specific to the resource to be managed. This specific data is provided in the form of an MIB. The core created handles the sending and the reception of SNMP frames from and to the manager, the encoding\/decoding of these frames in accordance with the ASN.1 standard, as well as the access to the objects of the MIB. Thus, it is no longer necessary for the developer of an agent according to the invention to design what corresponds to the protocol core; he need only develop the MIB corresponding to the resource he wishes to manage by means of the agent. Advantageously, the syntax used to develop the MIB is an ASN.1-SNMP V1 syntax.","The core, and hence the agent, thus created is specific to the resource, but the creation process is generic. Thus, by modifying the data provided as input to the process for creating the protocol core, a new agent is obtained.","The MIB contains only the lexical and syntactic information of the resource describing the objects of the resource, and does not contain any semantic information. The model of the resource derived from the MIB is constructed in the core in the form of a database sorted in lexicographical order. This sorted data base contains the values of the objects of the resource managed by the agent. To develop this sorted database, the user must also provide as input to the creation process an instance file that will make it possible to initialize this sorted database. Since, as has been indicated, the MIB does not actually contain any semantic information, it is therefore necessary, in order to give a meaning to the information of the MIB, to provide the creation process with the initial instances for the sorted data base.","The protocol core of the agent according to the invention thus created allows the execution, by the manager in complete conformity with the SNMP standard, of the following primitives:","GET reading of an instance of an attribute;","GET-NEXT reading of the next attribute instance in lexicographical order;","SET modification of an attribute instance.","These primitives are supported by the following protocol data units (PDU):\n\n","In addition, the agent according to the invention allows the emulation of verbs which do not originally belong to the SNMP standard but which, as a result of their frequent use in the management of distributed systems, have been inserted into other protocols, such as for example the Common Management Information Protocol (CMIP). It includes the following primitives:","CREATE creation of an instance in a table;","DELETE deletion of an instance in a table;","These two new primitives are supported by the PDUs:\n\n","In order to perform the function for deleting an instance from the table corresponding to the sorted database, a specific attribute (gamDeleteObject) is added during the agent creation process. In order to delete an instance, it is sufficient to assign this attribute (gamDeleteObject), by means of the command SET, the name of the instance to be deleted.","For this purpose, the agent according to the invention comprises a second sorted data base (, ) for the management of objects specific to its operation. This second sorted data base pools attributes that are used, in particular, to delete an instance from the first sorted database (, ), but also attributes used in the agent initialization process, in the incremental backup process, and in the process for communication between methods, which are described below. The list below provides examples of attributes contained in the second sorted data base and their utilization.","A first attribute \u201cgamInit-<name_agent>.0\u201d is used during the synchronization between the core and the method of the agent <nameAgent>, during the phases for initialization and for initiating a merge, It can have the following values: COREBEGIN, COREEND, METHBEGIN, METHEND, MERGE.","A second attribute \u201cgamDeleteObject-<name_agent>.0\u201d is used to delete an instance in a table of the agent <nameAgent>. Its value corresponds to the attribute of the instance to be deleted.","A third attribute \u201c<gamHostName-<name_agent>.0\u201d is automatically set by the core of the agent OAT during its initialization and assumes the value of the name of the machine in which the agent <nameAgent> is installed.","A fourth attribute gamNotify-<name_agent>.0 is set for the communications between methods in the sockets interface mode; the identifier of the destination method is indicated in the field \u201cresult\u201d and the attribute assumes the value of the information to be transmitted to another method.","Advantageously, at this stage of the agent's development, it is already capable of responding to inquiries from the manager. In fact, the core comprises a description of a resource to be managed through the sorted database, initialized by an instance file, even though the resource is not necessarily present, as well as the protocol for communicating with the manager. Of course, the virtual resource is frozen, since the information in the sorted data base is not updated by a method or methods. But the agent thus created can be used for simulation purposes. One of the advantages of this simulation is being able to develop, in the administrative platform, management functions involving a virtual resource. These functions communicate with an agent in exactly the same way they would if they actually had access to the resource. This makes it possible to modularize the connection chain between a manager and a managed resource, or to accelerate the obtainment of a complete management solution by parallelling the developments, or to perform load or performance tests by multiplying the number of agents simulated.","Of course, the object of the agent according to the invention also involves managing real resources. For this reason, the agent also comprises the expertise of the resource to be managed, in the form of methods which allow the instantiation of the model of the resource constituted by the sorted database of the core. The methods can be of any nature: for example, they can be, in addition to executables, functions of the operating system, interpreter lists (shell scripts), interpreted or compiled procedures, etc. They run continuously or are initiated periodically by querying the physical resource in order to load the sorted databases of the core. The function of the methods is simply to update the sorted database of the core by performing write or read operations in this base. These methods are designed individually by the developer of the agent according to the invention. In order to assist in this design, a tool library OAT is made available to the developer. This tool library comprises functions or primitives, for example in the form of executables, which allow the method to perform, in the sorted database of the core, the operations for reading the value of an instance (readInstSock or readInstDirect), for writing a new instance (writeInstSock or writeInstDirect), for deleting an instance (writeInstSock or writeInstDirect), for reading the next instance (readNextSock or readNextDirect), but also functions for initializing the method (connectSock or methInit), functions for exchanging information between methods (notifyMeth) and functions for communicating with the protocol core (receiveSock or readPipe, writeRespSock or writeResp).","In order to allow the operations for writing and reading the methods in the sorted database of the core, as well as the requests to the methods for the protocol core, a communication interface exists between the core and the methods. Two types of communication interfaces are possible: an interface that establishes a communication process of the sockets type, called a sockets interface, or an interface using named pipes, called a direct interface.",{"@attributes":{"id":"p-0083","num":"0088"},"figref":"FIG. 3","b":["111","10","12","12","12","112","112","10","11","111","12","12","12","11","11"],"i":["a","b","c"]},"The choice of one policy or another is made through an initialization file (<agt>.confget) in which, for each attribute managed by the agent, the mode for obtaining its value\u2014\u201cdirect\u201d or \u201csignal\u201d\u2014is indicated. As a function of this choice, the tool OAT for constructing the agent defines, in addition to the protocol core, two application programming interfaces, ordinarily called API (Application Programming Interface), i.e., one interface API () for communicating to the methods and one interface API () for communicating with the manager. If the user has not indicated the policy to be applied for an attribute, by default it is searched for directly in the sorted databases of the core of the agent according to the invention. The same is true if the initialization file is empty or nonexistent. The chief advantages offered by the sockets mode of communication are the capability to link, through a dialog, a plurality of distinct methods with the same core and the capability to reroute one or more methods to a different machine or machines from the one in which the core is running.","Moreover, the sockets interface is based on the use of TCP\/IP communication elements. This mode guarantees a better synchronization of the exchanges between the core () and the method or methods (). Furthermore, it facilitates the task of the method developer by simplifying the initialization and monitoring mechanisms.","In the communications carried out between the core () and the methods () of an agent () according to the invention, two types of exchanges may be distinguished: protocol exchanges, which are the exchanges used on the initiative of the core () following an SNMP request from the manager (), and the method exchanges, which are the exchanges used at the request of a method (), when the resource () managed by the agent according to the invention modifies an indicator that characterizes it, and when a method () needs to read the value of an instance managed by the core (). There are therefore two sockets (, ) for each method, i.e., a socket () for the SNMP messages and a socket () for the method messages. The core itself creates two listening sockets, each in a separate TCP port. The connection of a method () entails, for the core (), the opening of two service sockets (, ) (each associated with a listening socket), through which flow the SNMP messages sent to this method and the method messages sent by the latter, respectively. All of the protocol exchanges between the core () of the agent () and the methods () are carried out via network sockets that are online, i.e., supported at the transport level by the TCP layer. Primitives for reading and writing in the sockets are made available to the developer of the method.","The protocol exchanges are invoked by a request (, ) from the manager (), which wants, first of all, to read a piece of information of the resource (). The frame sent by the manager () is decoded by the protocol core (), which identifies the desired instance and the \u201cdirect\u201d or \u201csignal\u201d mode for obtaining this instance. If the \u201cdirect\u201d mode is detected (), the core constructs and sends the response (), searching for the instance in the sorted database (). If the \u201csignal\u201d mode is detected () the core () identifies the method () corresponding to the desired instance, constructs a message understandable by the method () and sends it to the latter through a socket (). This message is understood by the method () by means of a specific reception function (receiveSock). The method () queried will search for the desired instance in the resource () and respond to the core () using the write function (writeRespSock) containing the value of the instance. The response () from the method () results in the updating by the agent of the sorted database () as well as the construction and the sending by the core () of a message () containing the instance requested by the manager (). The protocol exchanges are invoked when the manager wants, secondly, to modify an instance of the resource (). The frame () sent by the manager () is then decoded by the core (), which identifies the method () in question and constructs a message () to be sent to this method () in order to modify the value of the instance of the resource. The method () receives the message using the reception function (receiveSock), executes the modification and responds () to the core (). The response from the method results in the updating of the sorted database (), as well as the construction and the sending of a response message () to the manager (), indicating that the modification has been performed. The structure of all the messages constructed by the core () to be sent to the method () comprises:\n\n","In the case of a request to read an instance or a request to read the next instance, the operation code is GET. The field corresponding to the value of the instance is empty for the message from the core to the method, and is equal to the value captured by the method in the message from the method to the core. The return code is either OK, if the method is capable of finding the value, or NOK, if it is not. If the core receives from the method a message with a return code NOK, it constructs an error message to the manager and cancels the request. The management of the function GET-NEXT coming from the manager is left up to the core, which means that the method receives only GET commands from the core (), and that it is the core that determines the next instance for constructing its GET message to be sent to the method.","In the case of a request to modify an instance, the operation code is SET, and the field corresponding to the value of the instance is equal to the desired value. The return code is either OK, if the method is capable of finding the instance and modifying it, or NOK, if it is not. If the core receives from the method a message with a return code NOK, it constructs an error message to the manager and cancels the request.","When a modification request (SET) or a creation request (CREATE) involves several attributes, the core submits these attributes one by one to the method. As soon as the method returns a code NOK, a response with a generic SNMP error is returned to the manager. Thus, it is strongly recommended that the developer of a method requiring the setting of several attributes of an instance, before performing the creation or the modification of this instance, respond with a return code OK for all the attributes except the last one, then judge the possibility for creation or modification with the complete knowledge provided by this last instance, before sending an acceptance (OK) or a denial (NOK) to the core of the agent OAT.","In addition, full compliance with the SNMP protocol has been improved, while maintaining full atomicity during an SNMP request involving a set of attributes. Atomicity consists of processing all of the attributes if all of the modifications are possible, or of not processing any of the attributes if any of the modifications is impossible. For this purpose, the core of the agent always transmits the instances contained in the same frame SNMP-SET to the method one by one, differentiating the last instance by means of the operation code transmitted to the method, which in the latter case is SETLAST.","Thus, the agent according to the invention makes it possible to ensure the complete atomicity of the SNMP-SET requests from the manager (). This atomicity throughout the connection chain is explained in the following example:\n\n","While all of the other instances are normally transmitted with an operation code equal to SET, the last one is sent to the method with an operation code equal to SETLAST. The method () is therefore built to react differently as a function of the operation code that the core () transmits to it. When the core transmits an operation code for modifying an attribute, the method reads the operation code of the message. If the operation code corresponds to a SET, the method verifies the possibility for modifying this attribute, stores the result of the modification in a file or a register, and responds to the core with a return code OK. If the operation code corresponds to a SETLAST, the method verifies the possibility for modifying the last attribute and checks to see whether all the modifications stored are possible. If any of the modifications is impossible, or if the modification of the last attribute is impossible, the method transmits a return code NOK; if not, the method responds with a return code OK. The return code NOK to the operation code SETLAST results in the cancellation of the entire request. The return code OK results in the validation, in the model () of the resource of the core (), of all the modifications stored by the method.","The method exchanges take place in accordance with the same mechanism as the protocol exchanges: through the sending of messages in a TCP\/IP \u201csocket.\u201d The sending of the message is managed in the functions and primitives made available to the developer and written later. Thus, the method can write (writeInstSock) new values into the sorted databases of the core (, ), which allows it to create, modify or delete instances. Likewise, it can of course read (readInstSock) the value of a particular instance in these bases. It is also possible for the method to read, in the internal databases (, ) of the core, the next instance in lexicographical order (readNextSock). This allows the method, for example, to read all of the instances of a table.","The core, when it is initialized, listens to a list of sockets. When no method has yet been connected, the sockets that are part of this listening list are the method listening socket and the protocol data unit (PDU) socket. When a method is connected, an event occurs in the method listening socket, upon which the core opens a method service socket and waits for the connection of the method to the SNMP listening socket. Once this connection has been established, the core opens an SNMP service socket. Then, it resumes its listening, adding the new method service socket to the listening list. The disconnection of a method results in the closing of both service sockets that are associated with it and the deletion of the method service socket from the listening list. When a message (writeInstSock, readInstSock, readNextSock, or notifyMeth) arrives in a method service socket, the core processes the request before resuming its wait in the listening list.","The sockets interface mode makes it possible to have several methods coexist with the core of the agent. The agent can therefore know the method to which it must transmit a request coming from the manager. The concept of a method identifier was introduced for this purpose. This identifier is an integer that makes it possible to uniquely distinguish a method. The choice of this integer and its uniqueness for the same core is left up to the developer of the agent. For each attribute in the file <agt>.confget, the identifier of the method that manages this attribute is indicated. Thus, the distribution of an SNMP request to one method or another takes place as a function of the attribute involved in the request. When a method is initialized, it declares its identifier to the core so that the latter knows which method corresponds to a given SNMP service socket corresponds. This declaration takes place directly in the function for initializing the method (connectSock).","The following description relates more precisely to the direct interface mode of communication between the protocol core and the method. In the direct interface mode, the communication between the core and the method takes place through named pipes. The sending of a message in a pipe is coupled with the emission of a signal in order to warn the interlocutor (core or method) that a message has been sent to it. This mode requires the core to communicate with only one method. The principle of the direct interface mode differs only slightly from the sockets mode, though not, of course, in the inter-process communication resources used. In the direct mode, all the protocol exchanges between the core of the agent and the method take place through named pipes and through the sending of a signal SIGUSR. The named pipes used for these protocol exchanges in the requests GET, NEXT, SET, CREATE or DELETE are <pipesDir>\/<agtName>.pRespSnmp and <pipesDir>\/agtName>.pReqSnmp. The first pipe is created by the core of the agent according to the invention and is open for writing by the method for transmitting the responses to the SNMP requests (the function writeResp). The second pipe is created and is open for reading by the method for receiving the SNMP requests coming from the core of the agent.","The utilization of the signal SIGUSR allows both the core of the agent and the method to be dedicated to other tasks. Each write operation in a pipe is followed by a sending of the signal SIGUSR which warns the addressee that a message has just been transmitted to it. The method and the core of the agent can, of course, function without each other. This is achieved as a result of the opening of the pipes in a non-inhibiting mode.","During exchanges with a method in the direct interface mode, the core does not send a signal to the method when there is a response to a readInstDirect or readNextDirect, which allows the method process to use the signal SIGUSR for possible interceptions independent of the agent.","The named pipes used for these method exchanges, in the instance requests READINST, READNEXT, or WRITEINST, are <pipesDir>\/<agtName>.pReqMeth and <pipesDir>\/<agtName>.pRespMeth. The first pipe is created by the core of the agent and is open for writing by the method for transmitting instance requests (the functions readInstDirect, readNextDirect and writInstDirect) to the core. The second pipe is created and is open for reading by the method for receiving the responses to the requests readInstDirect and readNextDirect from the core of the agent.",{"@attributes":{"id":"p-0101","num":"0122"},"figref":["FIGS. 4A through 4E","FIG. 4A"],"b":["20","20","100","10","111","200","300"]},{"@attributes":{"id":"p-0102","num":"0123"},"figref":"FIG. 4B","b":["20","101","201","111","301","20","111","202","12","203","12","203","111","301","202","12","30","400","401","12","402","111","111","204","11","302"]},{"@attributes":{"id":"p-0103","num":"0124"},"figref":"FIG. 4C","b":["20","110","111","201","20","205","111","212","12","203","12","203","111","310","12","30","400","401","12","403","12","11","402","111","111","204","11","320","20","11","310"]},{"@attributes":{"id":"p-0104","num":"0125"},"figref":["FIGS. 4D and 4E","FIG. 4C","FIG. 4D","FIG. 4E"]},"Advantageously, the agent according to the invention makes it possible to maintain a trace of all the modifications that have occurred in the sorted database () of the protocol core. Accumulating management information is not usually the role of an SNMP agent. However, the agent according to the invention implements this additional functionality in order to best prevent any loss of information whatsoever. The incremental backup is, of course, installed in both the direct interface and sockets interface modes. Rather than archiving, the term incremental backup is preferred. In effect, the information is stored on the hard disk of the system as it is modified, and no longer at predetermined intervals. Thus, the requests resulting in a modification of the sorted databases () of the core () of the agent according to the invention are logged in a file known as an incremental file. The table below summarizes the various requests that can be transmitted to the core of the agent according to the invention and the operation applied to each of them:",{"@attributes":{"id":"p-0106","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Source of the request","Nature of the request","Backup on disk"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Manager","GET, independent of the method","NO"]},{"entry":["Manager","GET, subject to the method","NO"]},{"entry":["Manager","SET","YES"]},{"entry":["Manager","CREATE","YES"]},{"entry":["Manager","DELETE","YES"]},{"entry":["Method","readInstDirect","NO"]},{"entry":["Method","readNextDirect","NO"]},{"entry":["Method","writeInstDirect","YES"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The requests are backed up as soon as the method indicates its acceptance of the modification, even before the actual processing of this modification in the sorted databases of the core of the agent. Thus, the agent guarantees the retention of the information in case of a recovery after a failure. The incremental file thus constitutes a memory for the various modifications of the data managed by the SNMP agent according to the invention. Its structure makes it possible to save all of the information contained in a modification request. This incremental file is stored on a disk, for example under than name \u201c<agent>.incr\u201d in the same directory as the instance file <DIR>\/agts\/inst. Furthermore, the incremental file is structured so as to optimize the processing speed linked to the incremental backup mechanism. Thus, each line of the incremental file represents a modification request wherein the various fields are separated by blanks. Each line, and hence each request, is recorded sequentially in the incremental file. These fields are the name of the modified instance (with its suffix), the value of this instance, and the type of the operation. These various fields are, of course, constructed automatically by the core () of the SNMP agent according to the invention. The following table provides the structure of an incremental file as well as an example:",{"@attributes":{"id":"p-0108","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Request","Instance","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CREATE","attribute. 1","1"]},{"entry":["SET","attribute. 1","2"]},{"entry":["DELETE","attribute. 1","Deleted Jun. 21, 1998 at 18:12"]},{"entry":["WRITEINST","attribute. 1","6"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"This example illustrates all the operations that it is possible to save in an incremental file. In the example, all of the requests involve the same instance. The requests are in chronological order. Thus, it may be seen that the instance was deleted after having been created, modified by the manager, then re-valuated during a WRITEINST by the method. The sequential nature of the incremental file guarantees that the chronological order of the requests is maintained.",{"@attributes":{"id":"p-0110","num":"0131"},"figref":"FIG. 2","b":["111","40","50","40","50","111","111","42","41","40","41","51","50","51","40","50","42","42","111","52"]},"In case of an absence of either of the files at the beginning of the initialization phase of the core of the SNMP agent, the behavior of the agent corresponds to that indicated in the table below:",{"@attributes":{"id":"p-0112","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Instance","Incremental",{},{}]},{"entry":["file","file","Behavior","Situation"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Present","Present","Merge of","Normal"]},{"entry":[{},{},"the 2 files","situation"]},{"entry":["Present","Absent or","The instance","No modifications"]},{"entry":[{},"empty","file is saved","since the last merge"]},{"entry":["Absent","Present","Merge of the","A failure occurred"]},{"entry":["OLD file",{},"incremental file","during the last"]},{"entry":["present",{},"with the OLD","merge"]},{"entry":[{},{},"instance file"]},{"entry":["Absent","Present","The incremental","A serious failure"]},{"entry":["OLD file",{},"file becomes the","occurred during"]},{"entry":["present",{},"instance file","the last merge"]},{"entry":["Absent","Absent","The OLD instance","A failure occurred"]},{"entry":["OLD file",{},"file becomes the","during the last merge;"]},{"entry":["present",{},"instance file","there have been no"]},{"entry":[{},{},{},"modifications since;"]},{"entry":[{},{},{},"a highly improbable"]},{"entry":[{},{},{},"situation"]},{"entry":["Absent","Absent","A minimal instance","First initialization"]},{"entry":["OLD file",{},"file is generated","or very serious failure"]},{"entry":"present"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"These behaviors of the core () of the SNMP agent, when the backup files are in a nonstandard configuration (i.e., the files are not both present), make it possible to easily process the failure recovery phases. During its initialization, the method can decide to load the management information it needs from the instance file, if the core of the SNMP agent is not capable of providing it (such a case generally occurs if the core is absent). It will then activate the same merging mechanism using a call to a function initMerge of the tool library OAT of the agent. The method could also use an updated instance file. The concurrent access to this merge is completely managed by the core () and the tool library \u201cOAT\u201d.","With the incremental backup mechanism, periodic archiving is no longer absolutely necessary. On the other hand, a reintegration of the modifications that have occurred since the startup of the agent is still essential. As has been seen, these modifications are fully logged in the incremental file (). Thus, during the normal operation of the agent, the information contained in the incremental file () is processed in order to integrate it into the sorted databases () of the core () of the SNMP agent. This integration during operation is initiated, not after the expiration of a given time period, but when the incremental file () has reached a size limit. This size limit can be indicated in the starting parameters of the SNMP agent. Furthermore, the method can decide to initiate this integration of the incremental file itself, while the core of the agent is in operation, by sending it a request for a write operation (writeInstSock or writeInstDirect) on a particular instance of the sorted database, specific to the agent (gamInit-<name_agent>.0) valuated with the constant MERGE. A call to a primitive for initiating the merge (runMerge) performs the same operation. In an integration of this type, the same process as in the initialization phase is used. There is a copy of the instance () and incremental () files, then a merge into the new instance file (). As soon as this integration starts, a new empty incremental file () is made available to the core of the agent. Thus, the process for integrating the incremental backup is absolutely non-inhibiting for the core of the SNMP agent, which can therefore continue with its normal tasks during this process.","It is imperative, when a failure occurs and an agent must be stopped, to be able to restart the agent, while losing as little as possible, if not none, of the information managed by the agent since its last startup. The main objective of the incremental backup mechanism of the agent according to the invention, as well as the installation, implied by this mechanism, of a memory in the SNMP agent, is fully in keeping with this imperative. Because of the very existence of the incremental file, the agent according to the invention guarantees a minimal, if not nonexistent, loss of the modifications that have occurred in the sorted data base () of the core () since the previous initialization of the latter. The execution of the incremental backup during the operation and initialization of the SNMP agent also guarantees better retention of the management information during a failure recovery. The failure recovery phases are facilitated and optimized by the behavior adopted by the core of the SNMP agent during the initialization or the integration of the incremental backup, summarized in the core behavior table described above. In fact, no matter what the configuration of the instance () and incremental () files, the SNMP agent according to the invention is capable of recovering, in the best possible condition, the management information managed by the agent in the state in which it was before the failure occurred.","The present invention also relates to a tool for creating the agent described above. The process for creating the core of the agent has been mentioned previously in the description; this process is implemented by a tool whose description follows. The tool OAT for creating an agent according to the invention comprises a specific command (buildagt) which, from a formalized description of a resource, automatically creates the protocol core of the SNMP agent specific to the resource that is the subject of the formalized description. As explained above, the formalized description is a management information base (MIB), advantageously written in the ASN.1 MIB SNMP V1 format. From this MIB, the command (buildagt) automatically creates the executable program corresponding to the protocol core of the agent according to the invention, compiling with the latter the model of the resource managed by the core. The result of the command (buildagt) is therefore a compiled program that is able to dialogue with the manager of the resource via an SNMP communication protocol, and to construct messages requesting at least one method to respond to requests from the manager and update a model of the resource, also constructed by the command for creating the agent (buildagt). The model of the resource is advantageously in the form of a sorted database, as described above. Thus, the command for creating the agent according to the invention advantageously makes it possible to automatically create, using a generic process, an agent core specific to a resource, thus freeing the developer of the agent from having to design the protocol core of said agent.","In order to develop the sorted database () of the core (), the command for creating the agent (buildagt) needs an instance file and a configuration file (agt.confget) which determine, for each instance of the model, the mode for obtaining instance values (\u201cdirect\u201d or \u201csignal\u201d), and in the case of the utilization of the sockets interface mode, the identifier of the method that is associated with it. On output, the command for creating the agent also produces files for the operation of the core of the agent according to the invention, including a configuration file of the communities of the agent and their rights, and a file that makes it possible to match the identifier of an object (OID: Object Identifier) in the SNMP protocol with its full name. This last file subsequently makes it possible to use, for example in the instance file, the full name of the instance rather than its OID, which considerably simplifies the writing of the instance file. Advantageously, the language in which the program corresponding to the core is written is a compiled language, in order not to interrupt the resource in which the agent is installed.","We have just seen that the protocol core manages the instances of the resource through a database sorted in lexicographical order. This lexicographical order is linked to the way the instances managed by the agent are identified. These instances are identified by the model represented by the MIB, described in the form of a tree, a node of the tree corresponding to an instance. These trees are modeled in the MIB in the form of a table in which each column corresponds to the indicators and each line corresponds to the particular instances. In order to mark each line of the table in a unique way, an index of the protocol SNMP V1 is used. An index is an indicator of the base corresponding to an attribute. When the manager sends a request to read or modify a particular instance, the instance is located by means of the index. The user's request is entered in \u201cEnglish\u201d, then retranscribed using the OID (Object Identifier) of the protocol SNMP of the manager. This OID is a sequence of positive integers in accordance with the SNMP standard. The value of the instance is marked by the name of a column (indicator) that includes the index (instance) corresponding to the line of the instance. The indexing of the instances allows them to be stored in lexicographical order. This order is determined by the path through the trees of the model in the increasing order of the various nodes. The name of an instance corresponds to the path it is necessary to follow from the root of the tree in order to reach the instance.","As described above, the developer of the agent according to the invention has the use of a tool library OAT comprising various functions for designing the various methods specific to the resource to be managed. When the methods and the core are constructed, the agent thus created must be initialized in order to be integrated with the resource. Because of the different modes of communication between the core and the method or methods (sockets interface mode or direct interface mode), the initialization is different according to each of the modes chosen. In the sockets interface mode, the initialization of the agent is much simpler than in the direct interface mode. In fact, each method can call the function for initializing the method (connectSock) simply by indicating its identifier. On the other hand, in this mode it is necessary to make sure that the core of the agent starts first, before each method. Moreover, as seen above, the architecture of an agent in the sockets interface mode uses two TCP ports in which the core creates two listening sockets. These TCP ports must be declared in a file by indicating the service name. In the direct interface mode, the communication via named pipes and signals between agent core and method entails a sharing of system resources between these components. Each entity, core and method, must, when it is initialized, create and open the various named pipes they both use for reading, open the ones they use for writing, and make the identifier of its process known so that the other entity can send it signals. Thus, the method must, as soon as it is initialized, execute a call to the method initialization function (methInit) made available to the developer of the agent, this function communicates the identifier of the method's process to the core, by writing it in a file. The initialization function \u201cmethInit\u201d takes care of creating and opening the named pipe in which the method will be able to read the SNMP requests (pipeReqSnmp). If the core has already been initialized, an opening of the named pipe in which the method will write the responses to the SNMP requests (pipeRespSnmp) is also performed. Furthermore, the function methInit performs the creation and the opening of the pipe in which the method will read the responses to the method requests transmitted by the core (pipeRespMeth). Likewise, if the core has been initialized, the function opens the pipe in which the method will write the method requests (pipeReqMeth) and finally, sends a request for writing an instance (WRITEINST) to the core. When the method is initialized, the core of the agent does not interrupt this initialization by transmitting SNMP protocol requests to the agent. The core is then in a so-called MUTE mode. This mode is initiated when the instance gamInit-<nameAgent>.0 is assigned a particular value (METHBEGIN). This is done by the method by means of a call to the function methInit. When the core of the core of the agent according to the invention is in the MUTE mode, it no longer transmits messages to the method, except of course for the responses to the direct read requests readInstDirect and readNextDirect that the method is capable of sending it during the initialization of the latter. If the method has been initialized first, it will not be able to open the pipe or pipes it uses for writing by calling the function methInit. It must do so when the core has been initialized. Also, if the core is initialized after the method, it notifies the method that it is starting, by sending a request for an instance modification (SET) on an instance of an attribute that belongs to it (gamInit-<agent Name>.0) assigned a particular value (COREBEGIN).","As described above, the developer of the agent according to the invention has the use of tool library OAT for constructing the specific method or methods of access to the resource that will search in the resources for the values of the various instances and update the model managed by the core, as well as respond to requests from the core. The tool library essentially comprises primitives and various functions in accordance with the mode of communication (sockets interface mode or direct interface mode) between the core and the method or methods, which make it possible to define a communication API (application programming interface). In the sockets interface mode, the following primitives are accessible to the developer: readInstSock, writeInstSock, readNextSock.","readInstSock","Syntax","readInstSock <serverName><agtName><timeOut><inst>","Function","The primitive \u201creadInstSock\u201d reads the value of the instance <inst> in the sorted databases of the core of the agent. The agent is identified by the parameter <agtName>. The user must provide the full name of the instance with its suffix. The primitive displays the value of the instance through the standard output. The user must also indicate in the parameter <serverName> the machine in which the core of the agent is located. If there is no response after a given time <timeOut>, the function returns an error.","writeInstSock","Syntax","writeInstSock <serverName><agtName><inst><val>","Function","The primitive \u201cwriteInstSock\u201d writes an instance <inst> and its value <val> in the sorted databases of the core of the agent. The agent is identified by the parameter <agtName>. The user must provide the fall name of the instance with its suffix. If the instance exists, its value is modified; if not, it is created. The user must also indicate in the parameter <serverName> the machine in which the core of the agent is located. Only new tabular instances (whose suffix is not \u201c.0\u201d) can be created.","readNextSock","Syntax","readNextSock <serverName><agtName><timeOut><inst>","Function","The primitive \u201creadNextSock\u201d reads the value of the next instance in lexicographical order of <inst> in the sorted databases of the core of the agent. The agent is identified by the parameter <agtName>. The user must provide the full name of the instance with its suffix. The primitive displays the value of the instance through the standard output. The user must also indicate in the parameter <serverName> the machine in which the core of the agent is located. If there is no response after a given time <timeOut>, the function returns an error. The user can search for the first instance managed by the core of the agent by indicating root.0 in the parameter <inst>.","In the sockets interface mode, the following functions are accessible to the developer: readInstSock, writeInstSock, readNextSock, receiveSock, writeRespSock:","readInstSock","Type returned","GAMResultType","Parameters","GAMMessType *messSock","const int sock_meth","const long timeOut","Description","The function \u201creadInstSock\u201d that reads the value of an instance in the \u201csockets\u201d mode comprises the above parameters. The name of the instance with its suffix must be placed in \u201cmessSock.inst\u201d. The operation \u201cmessSock.operation\u201d is automatically set to READINST by the function. The value of the instance is returned in \u201cmessSock.val\u201d. The descriptor \u201csock_meth\u201d of the socket must be indicated.","If there is no response after a period \u201ctimeOut\u201d of seconds, the function returns an error. The error code returned is also reported in \u201cmessSock.result\u201d. The first parameter of the function \u201creadInstSock\u201d is a pointer to a type structure \u201cGAMMessType\u201d, since various fields of this structure (operation, inst, val and result) are set during the execution of the function.","readNextSock","Type returned","GAMResultType","Parameters","GAMMessType *messSock","const int sock_meth","const long timeOut","Description","The function \u201creadNextSock\u201d that reads the value of the next instance in lexicographical order in the sockets mode comprises the above parameters. The name of the preceding instance with its suffix must be placed in \u201cmessSock.inst\u201d. It is possible to search for the first instance managed by the core of the agent by indicating \u201croot.0\u201d in the parameter \u201cmessSock.inst\u201d. The operation \u201cmessSock.operation\u201d is set to READNEXT by the function. The name of the next instance is returned in \u201cmessSock.inst\u201d. The value of the next instance is returned in \u201cmessSock.val\u201d. The descriptor \u201csock_meth\u201d of the socket must be indicated.","If there is no response after a period \u201ctimeOut\u201d of seconds, the function returns an error. The error code returned is also reported in \u201cmessSock.result\u201d. The first parameter of the function \u201creadNextSock\u201d is a pointer to a type structure \u201cGAMMessType\u201d, since various fields of this structure (operation, inst, val and result) are set during the execution of the function.","writeInstSock","Type returned","GAMResultType","Parameters","GAMMessType messSock","const int sock_meth","Description","The function \u201cwriteInstSock\u201d that writes an instance into the sorted data bases of the core of the agent in the sockets mode comprises the above parameters. The name of the instance with its suffix must be placed into \u201cmessSock.inst\u201d and its value into \u201cmessSock.val\u201d. The operation \u201cmessSock.operation\u201d is set to WRITEINST by the function. The descriptor sock_meth of the socket must be indicated. No acknowledgement message from the core is expected. Thus, only the return code of the function reports the sending of the message to the core of the agent. In particular, if there is an attempt to create a non-tabular instance, the core of the agent will have actually prevented this illegal creation, but the function \u201cwriteInstSock\u201d will not have returned an error.","receiveSock","Type returned","GAMResultType","Parameters","GAMMessType *messSock","const int sock_snmp","Function","The function \u201creceiveSock\u201d that reads a message \u201cmessSock\u201d in the TCP socket \u201csock_snmp\u201d comprises the above parameters. This function can be used by the method to read the SNMP requests that the core of the agent transmits to it in the socket mode. It performs an integrity check on the message received. In other words, with the return of this function, the structure messSock is properly completed.","writeRespSock","Type returned","GAMResultType","Parameters","GAMMessType *messSock","const int sock_snmp","Function","The function \u201cwriteRespSock\u201d that responds to an SNMP request from the core of the agent in the sockets mode comprises the above parameters. The fields operation and inst must be identical to those transmitted by the core in the SNMP request. This SNMP request message will have been able to be read by the method by means of the function \u201creceiveSock\u201d. The value of the instance must be placed in \u201cmessSock.val\u201d. The descriptor \u201csock_snmp\u201d of the TCP socket must be indicated. This socket will have been able to be opened in the method by means of the function \u201cconnectSock\u201d.","In the direct interface mode, the following primitives are accessible to the developer: readInstDirect, WriteInstDirect, readNextDirect.","readInstDirect","Syntax","readInstDirect <serverName><agtName><timeOut><inst>","Function","The primitive \u201creadInstDirect\u201d reads the value of the instance <inst> in the sorted databases of the core of the agent. The agent is identified by the parameter <agtName>. The user must provide the full name of the instance with its suffix. The primitive displays the value of the instance through the standard output. The user must also indicate in the parameter <serverName> the machine in which the core of the agent is located. If there is no response after a given time <time Out>, the function returns an error.","writeDirectSock","Syntax","writeInstDirect <serverName><agtName><inst><val>","Function","The primitive \u201cwriteInstDirect\u201d writes an instance <inst> and its value <val> into the sorted databases of the core of the agent. The agent is identified by the parameter <agtName>. The user must provide the full name of the instance with its suffix. If the instance exists, its value is modified; if not, it is created. The user must also indicate in the parameter <serverName> the machine in which the core of the agent is located. Only new tabular instances (whose suffix is not \u201c.0\u201d) can be created.","readNextDirect","Syntax","readNextDirect <serverName><agtName><timeOut><inst>","Function","The primitive \u201creadNextDirect\u201d reads the value of the next instance in lexicographical order of <inst> in the sorted databases of the core of the agent. The agent is identified by the parameter <agtName>. The user must provide the full name of the instance with its suffix. The primitive displays the value of the instance through the standard output. The user must also indicate in the parameter <serverName> the machine in which the core of the agent is located. If there is no response after a given time <timeOut,> the function returns an error. The user can search for the first instance managed by the core of the agent by indicating root.0 in the parameter <inst>.","In the direct interface mode, the following functions are accessible to the developer: readInstDirect, WriteInstDirect, readNextDirect, readPipe, readResp.","readInstDirect","Type returned","GAMResultType","Parameters","GAMMessType *messPipe","const char *gamAgtDir","const char *agtName","const long pipeReqMeth","const long pipeRespMeth","const long timeOut","Function","The function \u201creadInstDirect\u201d that reads the value of an instance in the direct mode comprises the above parameters. The name of the instance with its suffix must be placed into \u201cmessPipe.inst\u201d. The operation \u201cmessPipe.operation\u201d is automatically set to READINST by the function. The value of the instance is returned in \u201cmessPipe.val\u201d. The directory \u201cgamAgtDir\u201d of the core of the agent and the name \u201cagtName\u201d of the agent must be indicated. It is also necessary to indicate the descriptors \u201cpipeReqMeth\u201d and \u201cpipeRespMeth\u201d of the named pipes. These pipes will have been able to be opened in the method by means of the function \u201cmethInit\u201d described below. The message of the request is written by the function in the named pipe \u201cpipeReqMeth\u201d. The response message is read by the function in the named pipe. The exchanges between the method and the core of the agent are synchronized by the function by means of the reserved signal SIGUSR. If there is no response after a time limit \u201ctimeOut\u201d of seconds, the function returns an error. The error code returned is also reported in \u201cmessPipe.result\u201d. The first parameter of the function \u201creadInstDirect\u201d is a pointer to a type structure \u201cGAMMessType\u201d, since various fields of this structure (operation, inst, val and result) are set during the execution of the function.","readNextDirect","Type returned","GAMResultType","Parameters","GAMMessType *messPipe","const char *gamAgtDir","const char *agtName","const long pipeReqMeth","const long pipe RespMethod","const long timeOut","Description","The function \u201creadNextDirect\u201d that reads the value of the next instance in lexicographical order in the direct mode comprises the above parameters. The name of the preceding instance with its suffix must be placed in \u201cmessPipe.inst\u201d. It is possible to search for the first instance managed by the core of the agent by indicating \u201croot.0\u201d in the parameter \u201cmessPipe.inst\u201d. The operation \u201cmessPipe.operation\u201d is set to READNEXT by the function. The name of the next instance is returned in \u201cmessPipe.inst\u201d. The value of the next instance is returned in \u201cmessPipe.val\u201d. The directory \u201cgamAgtDir\u201d of the core of the agent and the name \u201cagtName\u201d of the agent must be indicated. It is also necessary to indicate the descriptors \u201cpipeReqMeth\u201d and \u201cpipeRespMeth\u201d of the named pipes. These pipes will have been able to be opened in the method by means of the function \u201cmethInit\u201d described below. The message of the request is written by the function in the named pipe \u201cpipeReqMeth\u201d. The response message is read by the function in the named pipe \u201cpipeRespMeth\u201d. The exchanges between the method and the core of the agent are synchronized by the function by means of the reserved signal SIGUSR. If there is no response after a time limit \u201ctimeOut\u201d of seconds, the function returns an error. The error code returned is also reported in \u201cmessPipe.result\u201d. The first parameter of the function \u201creadNextDirect\u201d is a pointer to a type structure \u201cGAMMessType\u201d, since various fields of this structure (operation, inst, val and result) are set during the execution of the function.","writeInstDirect","Type returned","GamResultType","Parameters","GAMMessType messPipe","const char *gamAgtDir","const char *agtName","const long pipeReqMeth","Function","The function \u201cwriteInstDirect\u201d that writes an instance into the sorted databases of the core of the agent in the direct mode comprises the above parameters. The name of the instance with its suffix must be placed into \u201cmessPipe.inst\u201d and its value into \u201cmessPipe.val\u201d. The operation \u201cmessPipe.operation\u201d is set to WRITEINST by the function. The directory \u201cgamAgtDir\u201d of the core of the agent and the name \u201cagtName\u201d of the agent must be indicated. It is also necessary to indicate the descriptor of the named pipe \u201cpipeReqMeth\u201d. This pipe will have been able to be opened in the method by means of the function \u201cmethInit\u201d described below. The request message is written by the function in the named pipe pipeReqMeth. The sending of the message from the method to the core of the agent is synchronized by the function by means of the reserved signal SIGUSR. No acknowledgement message from the core is expected. Thus, only the return code of the function reports the sending of the message to the core of the agent. In particular, if there is an attempt to create a non-tabular instance, the core of the agent will have actually prevented this illegal creation, but the function writeInstDirect will not have returned an error.","readPipe","Type returned","GAMResultType","Parameters","const long dpipe","GAMMessType *messPipe","Function","The function \u201creadPipe\u201d that reads a message \u201cmessPipe\u201d in the named pipe \u201cdpipe\u201d comprises the above parameters. This function can be used by the method to read the SNMP requests that the core of the agent transmits to it in the direct mode.","writeResp","Type returned","GAMResultType","Parameters","GAMMessType messPipe","const char *gamAgtDir","const char *agtName","const long pipeRespSnmp","Function","The function \u201cwriteResp\u201d that responds to an SNMP request from the core of the agent in the direct mode comprises the above parameters. The fields operation and inst must be identical to those transmitted by the core in the SNMP request. This SNMP request message will have been able to be read by the method by means of the function \u201creadPipe\u201d. The value of the instance must be placed in \u201cmessPipe.val\u201d. The directory \u201cgamAgtDir\u201d of the core of the agent and the name \u201cagtName\u201d of the agent must be indicated. It is also necessary to indicate the descriptor of the named pipe \u201cpipeRespSnmp\u201d. This pipe will have been able to be opened in the method by means of the function methInit described below. The response message is written by the function in the named pipe \u201cpipeRespSnmp\u201d. The sending of the message from the method to the core of the agent is synchronized by the function by means of the reserved signal SIGUSR.","The developer also has access to initialization functions in each mode:\n\n","The function \u201cconnectSock\u201d that establishes the connection of a method to the core comprises the above functions. The name of the agent is sent in \u201cagtName\u201d, the name of the machine in which the core is running is sent in \u201cserverName\u201d, and the identifier of the method arbitrarily chosen by the developer so as to be unique for the same core is sent in \u201cmethId\u201d. The descriptor of the socket through which the method will transmit its requests (writeInst, readInst, etc.) to the core is returned in \u201csock_meth\u201d. The descriptor of the socket through which the core will submit to the method the requests from the manager is returned in \u201csock_snmp\u201d. The function \u201cconnectSock\u201d establishes the connections of the two TCP sockets and sends the core a message that lets it know the identifier of the method.","MethInit (direct interface mode)","Name","methInit","Parameters","const char *gamAgtDir","const char*pipesDir","const char *agtName","long *pipeRespSnmp","long *pipeReqSnmp","long *pipeReqMeth","long *pipeRespMeth","Description","The function \u201cmethInit\u201d that initializes the method comprises the above parameters. The developer must indicate the directory \u201cgamAgtDir\u201d of the core of the agent, the directory \u201cpipesDir\u201d of the pipes used by the agent, and the name \u201cagtName\u201d of the agent. The function \u201cmethInit\u201d opens the named pipes used to communicate with the core of the agent and returns pointers to the descriptors of these pipes. The parameters of the function \u201cmethInit\u201d corresponding to the descriptors of these pipes are pointers, since they are assigned values during the execution of the function. The function \u201cmethInit\u201d sends the core of the agent a message of the type for writing an instance (WRITEINST), which assigns a particular instance of the sorted database () of the core () (gamInit-<agtName>) a determined value (METHBEGIN). If the core has not yet been initialized, only the reading pipes (pipeReqSnmp and pipeRespMeth) are created and opened in the function \u201cmethInit\u201d. In this case, an error is returned and the descriptors of the writing pipes (pipeRespSnmp and pipeReqMeth) are valuated at 0 (zero). When the core is initialized, the method is informed of this by the reception of an instance modification request (SET) that assigns the particular instance (gamInit-<agtName>.0) a given value (COREBEGIN). The method must then open the pipes \u201cpipeRespSnmp\u201d for writing in a non-inhibiting way. If the core has already been initialized, the sending of the message WRITEINST that sets the instance \u201cgamInit-<agtName>.0 to METHBEGIN will initiate the MUTE mode. It is imperative that the function \u201cmethInit\u201d be called by the method as soon as it is initiated.","MethEndInit (direct interface mode)","Name","methEndInit","Parameters","const char *gamAgtDir","const char *pipesDir","const char *agtName","const long pipeReqMeth","Description","The function \u201cmethEndInit\u201d that determines the end of the initialization of the method, as well as the end of the initialization of the core of the agent when the latter is initialized by the method, comprises the above parameters. The developer must indicate the directory \u201cgamAgtDir\u201d of the core of the agent, the directory \u201cpipesDir\u201d of the pipes used by the agent, and the name of the agent \u201cagtName\u201d. If the core () has not yet been initialized, an error GAM is returned to the manager. If the core has already been initialized, the initialization function \u201cmethEndInit\u201d sends the core of the agent a message of the instance writing type (WRITEINST) that assigns the particular instance of the sorted data base (gamInit-<agtName>.0) a given value (METHEND), which initiates the MUTE mode. The initialization function \u201cmethEndInit\u201d must be called by the method at the end of its initiation and, in the case where the core of the agent is initialized by the method, at the end of the \u201cwriteInstDirect\u201d sequence.","The function \u201cinitMerge\u201d performs a merge between instance files.","InitMerge (for both modes)","Name","initMerge","Parameters","const char *gamAgtDir","const char *instDir","const char *tmpDir","const char *agtName","Description","The developer must indicate the directory \u201cgamAgtDir\u201d of the core of the agent, the directory \u201cinstDir\u201d in which the instance and incremental files are located, the name of the agent \u201cagtName\u201d and a temporary job directory \u201ctmpDir\u201d. The function \u201cinitMerge\u201d is inhibiting until a merged instance file is available. It is imperative that the function \u201cinitMerge\u201d be called by the method, if the latter must be initialized in connection with the instance file.","To illustrate the various operations possible by means of a method, two examples of methods in the sockets interface mode are provided in appendices. In the first example in Appendix 1, the user enters as a parameter of this first method the name of the agent to which it must connect. After this connection, the method waits for messages from the core. Then, after twenty seconds, it modifies and reads the instances contained in the sorted databases of the core. The second example in Appendix 2 makes it possible to illustrate the communication between two methods. It also illustrates the utilization of readNext to scan a table. This clearly shows the advantage of the cache memory constituted by the sorted databases of the core.","While this invention has been described in conjunction with specific embodiments thereof, it is evident that many alternatives, modifications and variations will be apparent to those skilled in the art. Accordingly, the preferred embodiments of the invention as set forth herein, are intended to be illustrative, not limiting. Various changes may be made without departing from the spirit and scope of the invention as forth herein and defined in the claims.",{"@attributes":{"id":"p-0288","num":"0319"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"APPENDIX 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/*"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Product Name","\u2003\u2003\u2003OAT Agent - Method"]},{"entry":[{},"File Name","method1_sock.c"]},{"entry":[{},"Type","C source code file"]},{"entry":[{},"Function","Sample for a method item of an OAT Agent"]},{"entry":[{},"Author","\u2003\u2003\u2003Gerald SEDRATI"]},{"entry":[{},"Copyright","BULL 1996"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*\/"]},{"entry":[{},"#include \u2003\u2003<gamApi\/GAMAPI.h>"]},{"entry":[{},"\/* -------------------------------------- *\/"]},{"entry":[{},"\/* Modify Section : Modify these 2 constants *\/"]},{"entry":[{},"\/* -------------------------------------- *\/"]},{"entry":[{},"\/* Server name where the agent core is running *\/"]},{"entry":[{},"#define SERVERNAME \u201cange\u201d"]},{"entry":[{},"\/* Sockets TCP *\/"]},{"entry":[{},"int sock_meth, sock_snmp;"]},{"entry":[{},"\/* Method identifier: WARNING the \u201cconfget\u201d file HAS TO be"]},{"entry":[{},"\u2002\u2009 configured *\/"]},{"entry":[{},"#define METHID 1"]},{"entry":[{},"\/* ----------------------- *\/"]},{"entry":[{},"\/* End of Modify Section *\/"]},{"entry":[{},"\/* ----------------------- *\/"]},{"entry":[{},"\/* Name of the agent *\/"]},{"entry":[{},"char agtName[MAXLENFILENAME];"]},{"entry":[{},"\/* Receive snmp messages from core agent *\/"]},{"entry":[{},"static CVoidType snmpReceive(CIntfType sock)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003GAMMessType mess;"]},{"entry":[{},"\u2003GAMERROR(\u201cMessage received from core\\n\u201d);"]},{"entry":[{},"\u2003receiveSock(&mess, sock);"]},{"entry":[{},"\u2003if (mess.result != GAM_ERR_CORE_NOT_READY) {"]},{"entry":[{},"\u2003\u2003switch (mess.operation) {"]},{"entry":[{},"\u2003\u2003\u2003case GET:"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR1(\u201cGET on %s\\n\u201d, mess.inst);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* Special instance => value =< beep\/ascii>*\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (!(strcmp(mess.inst, \u201cpannelDescription.0\u201d))) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003GAMERROR1(\u201cSpecial instance <%s>\\n\u201d,"]},{"entry":[{},"mess.inst);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003sprintf(mess.val, \u201ccharacter7:%c:fin\u201d, 0x7);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003GAMERROR1(\u201cValue=%s\\n\u201d, mess.val);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003mess.result = OK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* For any other instance => value=1 *\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003strcpy(mess.val, \u201c1\u201d);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003GAMERROR1(\u201cValue=%s\\n\u201d, mess.val):"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003mess.result=OK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003\u2003case SET:"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR2(\u201cSET on %s=%s\\n\u201d, mess.inst,"]},{"entry":[{},"mess.val);"]},{"entry":[{},"\u2003\u2003\u2003\u2003mess.result=OK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* Special instance => set unable*\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (!(strcmp(mess.inst, \u201cpannelVendor.0\u201d))) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003mess.result=NOK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003GAMERROR1(\u201cSpecial instance <%s> NO"]},{"entry":[{},"SET\\n\u201d,mess.inst);"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003\u2003case CREATE:"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR2(\u201cCREATE on %s=%s"]},{"entry":[{},"REFUSED\\n\u201d, mess.inst, mess.val);"]},{"entry":[{},"\u2003\u2003\u2003\u2003mess.result=NOK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003\u2003case DELETE:"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR1(\u201cDELETE on %s REFUSED\\n\u201d,"]},{"entry":[{},"mess.val);"]},{"entry":[{},"\u2003\u2003\u2003\u2003mess.result=NOK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003\u2003case SETLAST:"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR2(\u201cLAST instance of a SET on"]},{"entry":[{},"%s=%s\\n\u201d, mess.inst, mess.val);"]},{"entry":[{},"\u2003\u2003\u2003\u2003mess.result=OK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* Special instance => set unable*\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (!(strcmp(mess.inst, \u201cpannelVendor.0\u201d))) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003mess.result=NOK;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003GAMERROR1(\u201cSpecial instance <%s> NO"]},{"entry":[{},"SET\\n\u201d, mess.inst);"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003\u2003case NOTIFY:"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR1(\u201cNotify received from method"]},{"entry":[{},"id=%d . . . \\n\u201d, mess.result);"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR1(\u201cMessage notified=%s\\n\u201d, mess.val);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/* Maybe your agent has something more to"]},{"entry":[{},"perform on notify . . ."]},{"entry":[{},"\u2003\u2003\u2003Write the code here *\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003if (mess.operation!=NOTIFY) {"]},{"entry":[{},"\u2003\u2003\u2003writeRespSock(mess, sock);"]},{"entry":[{},"\u2003\u2003\u2003if (mess.result == OK) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR1(\u201cResponse sent <%s>\\n\u201d, mess.val);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003GAMERROR(\u201cResponse sent NOK \\n\u201d);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003else"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\u2003GAMERROR(\u201cCore is down, exiting !. . . \\n\u201d);"]},{"entry":[{},"\u2003\u2003exit(1);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"\/* Main function : argv[1]=agent name (example : method1_sock"]},{"entry":[{},"\u2002\u2009 miscagt)*\/"]},{"entry":[{},"void main(int argc,char argv)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003GAMMessType mess;"]},{"entry":[{},"\u2003fd_set read_mask;"]},{"entry":[{},"\u2003struct timeval timeWait;"]},{"entry":[{},"\u2003GAMResultType result;"]},{"entry":[{},"\u2003CIntfType rc;"]},{"entry":[{},"\u2003\/* Parsing arguments *\/"]},{"entry":[{},"\u2003if (argc!=2) {"]},{"entry":[{},"\u2003\u2003printGamError(GAM_ERR_ARG);"]},{"entry":[{},"\u2003\u2003printf(\u201cUsage : %s <agent_name>\\n\u201d);"]},{"entry":[{},"\u2003\u2003printf(\u201c . . . Exiting !\\n\u201d);"]},{"entry":[{},"\u2003\u2003exit(1);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003strcpy(agtName, argv[1]);"]},{"entry":[{},"\u2003printf(\u201cRunning GAM agent method item for %s\\n\u201d, agtName);"]},{"entry":[{},"\u2003\/* Initialization *\/"]},{"entry":[{},"\u2003result=connectSock(agtName, SERVERNAME, METHID,"]},{"entry":[{},"\u2003&sock_meth,"]},{"entry":[{},"&sock_snmp);"]},{"entry":[{},"\u2003if (result) {"]},{"entry":[{},"\u2003\u2003printGamError(result);"]},{"entry":[{},"\u2003\u2003exit(result);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003GAMERROR1(\u201cMethod is connected to core of %s agent\\n\u201d,"]},{"entry":[{},"\u2003agtName);"]},{"entry":[{},"\u2003\/* Infinite loop : waiting 20 seconds for snmp message"]},{"entry":[{},"\u2003from core agent then sending writeInst, readInst and readNext *\/"]},{"entry":[{},"\u2003timeWait.tv_sec=20L:"]},{"entry":[{},"\u2003timeWait.tv_usec=0L;"]},{"entry":[{},"\u2003for (;;) {"]},{"entry":[{},"\u2003\u2003FD_ZERO(&read_mask);"]},{"entry":[{},"\u2003\u2003FD_SET(sock_snmp, &read_mask);"]},{"entry":[{},"\u2003\u2003rc=select(sock_snmp+1, &read_mask, (fd_set *)NULL,"]},{"entry":[{},"(fd_set *)NULL,&timeWait);"]},{"entry":[{},"\u2003\u2003if(rc==0) {"]},{"entry":[{},"\u2003\u2003\u2003printf(\u201cTimeout of 20 seconds reached !\\n\u201d);"]},{"entry":[{},"strcpy(mess.inst, \u201cpannelVendor.0\u201d);"]},{"entry":[{},"\u2003\u2003\u2003sprintf(mess.val, \u201cRandom Manufacturer no %d\u201d, rand( ));"]},{"entry":[{},"\u2003\u2003\u2003result=writeInstSock(mess, sock_meth);"]},{"entry":[{},"\u2003\u2003\u2003printf(\u201cWrite done\\n\u201d);"]},{"entry":[{},"\u2003\u2003\u2003strcpy(mess.inst, \u201cpannelId.0\u201d);"]},{"entry":[{},"\u2003\u2003\u2003result=readInstSock(&mess, sock_meth,2);"]},{"entry":[{},"\u2003\u2003\u2003if (result)"]},{"entry":[{},"\u2003\u2003\u2003\u2003printGamError(result);"]},{"entry":[{},"\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003printf(\u201cReadInst :"]},{"entry":[{},"inst=%s\\tval=%s\\n\u201d, mess.inst, mess.val);"]},{"entry":[{},"\u2003\u2003\u2003strcpy(mess.inst, \u201cpannelVendor.\u22121\u201d);"]},{"entry":[{},"\u2003\u2003\u2003result=readNextSock(&mess, sock_meth,2);"]},{"entry":[{},"\u2003\u2003\u2003if (result)"]},{"entry":[{},"\u2003\u2003\u2003\u2003printGamError(result);"]},{"entry":[{},"\u2003\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003\u2003printf(\u201cReadNext :"]},{"entry":[{},"inst=%s\\tval=%s\\n\u201d, mess.inst, mess.val);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003if (FD_ISSET(sock_snmp, &read_mask)) {"]},{"entry":[{},"\u2003\u2003\u2003snmpReceive(sock_snmp);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0289","num":"0320"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"APPENDIX 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/*"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Product Name","\u2003\u2003\u2003OAT Agent - Method"]},{"entry":["File Name","method2_sock.c"]},{"entry":["Type","C source code file"]},{"entry":["Function","Sample for a method item of an OAT Agent"]},{"entry":["Author","\u2003\u2003\u2003G\u00e9rald SEDRATI"]},{"entry":["Copyright","BULL 1996"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"*\/"},{"entry":"#include \u2003\u2003<gamApi\/GAMAPI.h>"},{"entry":"\/* -------------------------------------- *\/"},{"entry":"\/* Modify Section : Modify these 2 constants *\/"},{"entry":"\/* -------------------------------------- *\/"},{"entry":"\/* Server name where the agent core is running *\/"},{"entry":"#define SERVERNAME \u201cange\u201d"},{"entry":"\/* Method identifier: WARNING the \u201cconfget\u201d file HAS TO be"},{"entry":"\u2002\u2009 configured *\/"},{"entry":"#define METHID 2"},{"entry":"\/* ----------------------- *\/"},{"entry":"\/* End of Modify Section *\/"},{"entry":"\/* ----------------------- *\/"},{"entry":"\/* Name of the agent *\/"},{"entry":"char agtName[MAXLENFILENAME];"},{"entry":"\/* Sockets TCP \/*"},{"entry":"int sock_meth, sock_snmp;"},{"entry":"\/* Global variable to take modifications into account *\/"},{"entry":"int modif=0;"},{"entry":"\/* When a get is received on the special instance, response is computed"},{"entry":"depending on other attributes *\/"},{"entry":"static CBoolType verifyGet(GAMMessType* messRequest)"},{"entry":"{"},{"entry":"\u2003GAMMessType messEvent;"},{"entry":"\u2003CIntfType i;"},{"entry":"\u2003sprintf(messEvent.inst, \u201clightId.\u22121\u201d);"},{"entry":"\u2003for (i=0; !strncmp(messEvent.inst, \u201clightId.\u201d, 8);i++) {"},{"entry":"\u2003\u2003readNextSock( &messEvent, sock_meth, 10);"},{"entry":"\u2003\u2003if (messEvent.result != OK)"},{"entry":"\u2003\u2003\u2003\u2003\/* Special instance => set unable *\/"},{"entry":"\u2003\u2003\u2003\u2003if (!(strcmp(mess.inst, \u201clightsNum.0\u201d))) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003mess.result=NOK;"},{"entry":"\u2003\u2003\u2003\u2003\u2003GAMERROR1(\u201cSpecial instance <%s> NO"},{"entry":"SET\\n\u201d, mess.inst);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003modif++;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case CREATE:"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR2(\u201cCREATE on %s=%s"},{"entry":"ACCEPTED\\n\u201d, mess.inst, mess.val);"},{"entry":"\u2003\u2003\u2003\u2003mess.result=OK;"},{"entry":"\u2003\u2003\u2003\u2003modif++;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case DELETE :"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR1(\u201cDELETE on %s ACCEPTED\\n\u201d,"},{"entry":"mess.val);"},{"entry":"\u2003\u2003\u2003\u2003mess.result=OK;"},{"entry":"\u2003\u2003\u2003\u2003modif++;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case SETLAST:"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR2(\u201cLAST instance of a SET on"},{"entry":"%s=%s\\n\u201d, mess.inst, mess.val);"},{"entry":"\u2003\u2003\u2003\u2003mess.result=OK;"},{"entry":"\u2003\u2003\u2003\u2003\/* Special instance => set unable*\/"},{"entry":"\u2003\u2003\u2003\u2003if (!(strcmp(mess.inst,\u201clightsNum.0\u201d))) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003mess.result=NOK;"},{"entry":"\u2003\u2003\u2003\u2003\u2003GAMERROR1(\u201cSpecial instance <%s> NO"},{"entry":"SET\\n\u201d, mess.inst);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003modif++;"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003case NOTIFY:"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR1(\u201cNotify received from method"},{"entry":"id=%d . . . \\n\u201d, mess.result);"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR1(\u201cMessage notified=%s\\n\u201d,mess.val);"},{"entry":"\u2003\u2003\u2003\u2003\/* Maybe your agent has something more to perform"},{"entry":"on"},{"entry":"notify . . ."},{"entry":"\u2003\u2003\u2003\u2003Write the code here *\/"},{"entry":"\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003}"},{"entry":"\u2003if (mess.operation!=NOTIFY) {"},{"entry":"\u2003\u2003writeRespSock(mess, sock);"},{"entry":"\u2003\u2003if (mess.result == OK) {"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR1(\u201cResponse sent <%s>\\n\u201d, mess.val);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else {"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR(\u201cResponse sent NOK\\n\u201d);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003else"},{"entry":"\u2003{"},{"entry":"\u2003\u2003GAMERROR(\u201cCore is down, exiting ! . . . \\n\u201d);"},{"entry":"\u2003\u2003exit(1);"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"\/* Main function : argv[1]=agent name (example : method1_sock"},{"entry":"miscagt) *\/ void main(int argc.char **argv)"},{"entry":"{"},{"entry":"\u2003fd_set read_mask;"},{"entry":"\u2003struct timeval timeWait;"},{"entry":"\u2003GAMResultType result;"},{"entry":"\u2003CIntfType rc;"},{"entry":"\u2003\/* Parsing arguments *\/"},{"entry":"\u2003if(argc!2) {"},{"entry":"\u2003\u2003printGamError(GAM_ERR_ARG);"},{"entry":"\u2003\u2003printf(\u201cUsage : %s <agent_name>\\n\u201d);"},{"entry":"\u2003\u2003printf(\u201c . . . Exiting !\\n\u201d);"},{"entry":"\u2003\u2003exit(1);"},{"entry":"\u2003}"},{"entry":"\u2003strcpy(agtName, argv[1]);"},{"entry":"\u2003printf(\u201cRunning GAM agent method item for %s\\n\u201d, agtName);"},{"entry":"\u2003\/* Initialization *\/"},{"entry":"\u2003result=connectSock(agtName, SERVERNAME, METHID,"},{"entry":"&sock_meth &sock_snmp);"},{"entry":"\u2003if (result) {"},{"entry":"\u2003\u2003printGamError(result);"},{"entry":"\u2003\u2003exit(result);"},{"entry":"\u2003}"},{"entry":"\u2003GAMERROR1(\u201cMethod is connected to core of %s agent\\n\u201d,"},{"entry":"\u2003agtName);"},{"entry":"\u2003\/* Infinite loop : waiting 20 seconds for snmp message"},{"entry":"\u2003from core agent then notify method 1 if there is a change *\/"},{"entry":"\u2003timeWait.tv_sec=20L;"},{"entry":"\u2003timeWait.tv_usec=0L;"},{"entry":"\u2003for (;;) {"},{"entry":"\u2003\u2003FD_ZERO(&read_mask);"},{"entry":"\u2003\u2003FD_SET(sock_snmp, &read_mask);"},{"entry":"\u2003\u2003rc=select(sock_snmp+1, &read_mask, (fd_set *)NULL,"},{"entry":"(fd_set *)NULL, &timeWait);"},{"entry":"\u2003\u2003if (rc==0) {"},{"entry":"\u2003\u2003\u2003printf(\u201cTimeout of 20 seconds reached !\\n\u201d);"},{"entry":"\u2003\u2003\u2003if (modif) {"},{"entry":"\u2003\u2003\u2003\u2003result=notifyMeth(\u201cThere are some changes in"},{"entry":"lightTable\u201d,sock_meth,agtName,4,5);"},{"entry":"\u2003\u2003\u2003\u2003GAMERROR1(\u201cNotify transmitting result=%d\\n\u201d,"},{"entry":"result);"},{"entry":"\u2003\u2003\u2003\u2003modif=0:"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (FD_ISSET(sock_snmp, &read_mask)) {"},{"entry":"\u2003\u2003\u2003snmpReceive(sock_snmp);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS ","p":["Other characteristics and advantages of the present invention will emerge more clearly from the reading of the following description, with reference to the appended drawings, in which:",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIGS. 4A through 4E"}]},"DETDESC":[{},{}]}
