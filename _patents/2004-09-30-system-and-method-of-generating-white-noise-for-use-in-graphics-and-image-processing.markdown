---
title: System and method of generating white noise for use in graphics and image processing
abstract: A method of generating white noise for use in graphic and image processing, in accordance with one embodiment of the present invention, includes receiving one or more hash inputs. The hash inputs may be one or more primitive coordinates, one or more texel addresses, a base image, a device identifier, or a user password. The one or more hash inputs are evaluated utilizing a cryptographic hash function. The output of the cryptographic hash function generates one or more white noise samples. The white noise samples may be utilized as texel data. The white noise samples may also be utilized for encrypting images.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09264265&OS=09264265&RS=09264265
owner: NVIDIA CORPORATION
number: 09264265
owner_city: Santa Clara
owner_country: US
publication_date: 20040930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["Three-dimensional graphics processing is utilized in a number of applications, from electronic games, and movies to computer aided design (CAD). Conventionally, three-dimensional graphics processing includes a multi-step rendering process of transitioning from a database representation of three-dimensional objects to a two-dimensional projection of the object into a display space. The process generally includes setting up a polygon model (e.g., a plurality of primitives) of objects, applying linear transformation to each primitive, culling back facing primitives, clipping the primitives against a view volume, rasterizing the primitives to a pixel coordinate set, shading\/lighting the individual pixels using interpolated or incremental shading techniques, and the like. Typically, graphics processors are organized in a pipeline architecture, where each stage is dedicated to performing specific functions. A benefit of the pipeline architecture is that it permits fast, high quality rendering of even complex scenes.","A random number generator may be utilized for graphics and image processing applications. For example, the random number generator may be utilized to generate noise samples for use in texturing processes. The random number generator may be implemented by a thermal noise generator (e.g., thermal resistor) or a software implemented sequential random number generator. A thermal resistor provides a hardware implementable random number generator having a high degree of entropy. However, the thermal resistor does not provide a repeatable random number sequence, which is important for both hardware\/software debugging and maintaining rendering consistency in animations.","Software implemented sequential random number generators (e.g., X=aX+b) are implemented by the central processor unit (e.g., CPU) and provide a random number after a relatively long sequence. The sequential number generation processes is repeatable, but is not readily implementable in hardware. It is appreciated that the input may be determined from the output (e.g., solve for Xgiven X). It is also appreciated that random number generators implemented in software are sequential and present a performance bottleneck for parallel computations in pipeline architectures. In addition, typical sequential random number generators (e.g., linear congruential regression equation) are pseudo-random and can significantly bias the resultant statistics.","Accordingly, embodiments of the present invention are directed toward a system and method of generating white noise for use in graphic and image processing. In one embodiment, a graphics processor includes a shader module, a texture module and a parallel hashing module. The texture module and the parallel hashing module are coupled to the shader module. The texture module provides a texture mapping function to the shader module. The parallel hashing module generates white noise as a function of a key. The white noise may be utilized as texel data for use in the graphics processor. The white noise may also be utilized for encrypting images generated by the graphics processor.","In another embodiment, a method of generating white noise for use in graphic and image processing includes receiving one or more hashing inputs. The hashing inputs may be, for instance, one or more primitive coordinates, one or more texel addresses, a base image, or a device identifier. The one or more hashing inputs may be evaluated utilizing a cryptographic hash function. The output of the cryptographic hash function generates one or more white noise samples. The white noise samples may be utilized as texel data. The white noise samples may also be utilized for encrypting images.","Embodiments of the present invention advantageously generate white noise for use in graphics and image processing. The system and method for generating white noise advantageously generates a random number having a high degree of entropy in a single step. Accordingly, the embodiments of the present invention advantageously reduce processing latency in graphics and image processing without consuming memory.","Reference will now be made in detail to the embodiments of the invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with these embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it is understood that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the present invention.","Referring to , a block diagram of a graphics processor , in accordance with one embodiment of the present invention, is shown. As depicted in , the graphics processor  may include geometry setup and raster modules , a shader module , a texture module , a parallel hashing module  and a pixel write module . The shader module  may be coupled to the geometry setup and modules . The texture module  and the parallel hashing module  may be coupled in parallel with each other to the shader module . The pixel write module  may be coupled to the shader module. It is appreciated that the graphics processor  may also include one or more other modules well-known in the art, such as a fog module, alpha test module, depth test module, alpha blend module, etc., coupled to the geometry setup and raster modules , shader module , texture module , parallel hashing module  and\/or pixel write module .","The geometry setup and raster modules  receives one or more graphics commands and data from a host interface . The shader module  may receive one or more transformed primitive parameters from the geometry setup and raster modules . The shader  may implement one or more position, color, texture, reflectivity, filter, blend and the like functions on the primitive parameters. The pixel write module  may output pixel data produced by the shader module . In one implementation, the pixel write module  stores the pixel data as a rendered image in a memory (e.g., computer-readable medium), such as a frame buffer.","The shader module  utilizes the texture module  to provide texture mapping (e.g., level of detail, texel address, etc.). The texture module  receives one or more texture coordinates from the shader module  and returns the corresponding texel data from one or more appropriate textures stored in memory (e.g., mipmap). Alternatively, the shader  may utilize the parallel hashing module  for texturing functions.","The parallel hashing module  may receive one or more hash inputs. A hash input may be a plurality of primitive parameters, one or more texel addresses, a base image, a device identifier, a graphics processor device identifier, a user password or the like. The parallel hashing module  evaluates the one or more hash inputs utilizing a cryptographic hash function. The cryptographic hash function converts an arbitrary bit stream, into a unique fixed-length bit stream of random numbers (e.g., white noise) having a high degree of entropy. In one embodiment, a plurality of texture coordinates are hashed to produce corresponding white noise samples that are returned as procedural texel data to the shader module . In another embodiment, the texture coordinates are hashed to produce corresponding white noise samples. The white noise samples may then be utilized to produce other types of noise (e.g., pink noise, brown noise, fractal noise, etc.). The other types of noise may then be utilized as texel data by the shader module .","Alternatively or in addition, the parallel hashing module  may be utilized to generate white noise for encrypting images. In one embodiment, a hash input is hashed to produce white noise. The samples of white noise may be combined with pixel data (e.g., rendered image) to generate encrypted pixel data (e.g., encrypted image). In one embodiment, the graphics processor  further includes a first XOR gate . The parallel hashing module  receives one or more hash inputs at an input and outputs a white noise. The first XOR gate  receives an image (e.g., rendered image) at a first input and the white noise at a second input. The first XOR gate  outputs an encrypted image at an output. In one implementation, the encrypted image may be stored in a computer-readable medium, such as a frame buffer, a graphics memory, a unified memory or the like. It is appreciated that the XOR\u2032ing function may alternatively be implemented by a shader instruction.","It is appreciated that the image may be decoded from the encrypted image by combining the encrypted image with the same white noise. In one embodiment, the graphics processor  further includes a second XOR gate . The second XOR gate  receives the encrypted image at a first input and the same white noise at a second input. The second XOR gate  outputs a decrypted image at an output.","In one implementation, the hash input to the parallel hashing module  may be a device identifier (e.g., graphics processor device identifier), user password or the like. Accordingly, by combining a rendered image with white noise generated by hashing a device identifier it may then be possible to uniquely determine the specific device (e.g., computer) or the individual that generated the image.","It is also appreciated that the white noise generated by the parallel hashing module  may also be utilized by other functions performed by the shader module , raster module, fog module, alpha test module, depth test module, alpha blend module and\/or the like.","The cryptographic hash function is a one-way function. It is generally infeasible to reverse the process to determine the original input. It is also infeasible to find two different inputs that produce the same output. Accordingly, given an arbitrary input, any particular bit of the output should be zero substantially half the time. In addition, any two output samples should be substantially uncorrelated no matter how similar the inputs are.","The cryptographic hashing function may be a message digest algorithm (e.g., MD1, MD2, MD3, MD4, MD5), a security hash standard (e.g., SHA, SHS) or the like. In one implementation, an MD5 algorithm receives an arbitrary message as an input and produces a 128-bit message digest as an output. At initialization, the MD5 algorithm pads the input to the nearest multiple of 512 bits. The algorithm computes a 128-bit digest from each 512-bit chunk of the input through 64 stages of bit scrambling operations, including AND, OR, XOR, negation, addition, and circular shifting Boolean functions. The individual digests may then be summed as a final message digest. It is appreciated that the MD5 algorithm may thus be utilized to generate 32-bit white noise samples. More specifically, four 32-bit texel coordinates may be packed as a single message and the resulting message digest may be split into four 32-bit white-noise samples.","The MD5 algorithm is performed utilizing integer and bit-wise operations. The MD5 algorithm is designed to be quite fast for 32-bit processors. For example, 0.73 million 512-bit messages may be hashed per second on a PC having a 1.5 MHz Intel Pentium CPU. The pipeline nature of the MD5 algorithm also makes it suitable for implementing in hardware on a graphics processor, such as that in .","It is appreciated that the parallel hashing module  does not suffer from the memory latency or cache coherency issues that the conventional texture module  incurs. For example, the parallel hashing module  utilizing the MD5 algorithm may achieve a maximum throughput of one 128-bit sample per clock, provided sufficient requests are grouped together. This translates to 350 million 128-bit samples per second for a 350 MHz graphics processor. A texture module , having similar length and data dependency, generates approximately 17.4 million 32-bit samples per second on a 350 MHz graphics processor, such as the GeForce FX 5600 from NVIDIA of Santa Clara, Calif.","It is appreciated that the parallel hashing module  may be implemented in hardware or software utilizing a plurality of Boolean operators. In one implementation, a MD5 based parallel hashing module  may typically be implemented by 64 stages comprising AND, OR, XOR, negation, addition and circular shifting circuits. The MD5 based parallel hashing module  may also typically be implemented utilizing a 64\u00d732 bit table constructed from the sine function. The hardware costs of the parallel hashing module  may be reduced by simplifying the MD5 algorithm. In one implementation, latency of the parallel hashing module  may be reduced by reducing the stage of circuits to 16 stages by executing 4 adjacent stages in parallel. Alternatively or in addition, the computer-readable medium for storing sine table entries may be reduced by keeping only the 8 most significant bits of each sine table entry, and replicating each 8 bit entry into 32 bits at run time. Accordingly, simplifying the hardware implementation of the cryptographic hashing function may advantageously reduce processing latency and consumption of system memory.","Referring now to , a flow diagram of a method of generating white noise for use in graphics and image processing, in accordance with one embodiment of the present invention, is shown. As depicted in , the method begins with receipt of one or more hash inputs, at step . Each hash input may be one or more primitive coordinates, one or more texel addresses, base image, a device identifier, a user password and\/or the like.","At step , the hash input(s) are evaluated utilizing a cryptographic hash function. Each sample of the hash inputs may be evaluated independently and in parallel. The cryptographic hash function may be a message digest algorithm (e.g., MD2, MD3, MD4, MD5), a security hash standard (SHS, SHA, SHS-1, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512) or the like. Such cryptographic hash functions generate random numbers having a high degree of entropy in a very short sequence.","At step , the white noise samples generated by the cryptographic hashing function are then output. Referring now to , an exemplary hash input and white noise generated according to the method shown in , is shown. As depicted in , the exemplary hash input may be a 256\u00d7256\u00d73 image. The exemplary white noise generated by hashing each input pixel independently is depicted in . The total computation time is approximately 60 milliseconds on a PC having a 1.5 GHz Intel Pentium processor.","The white noise samples, generated according to the method shown in , may be output as procedural texturing (e.g., mathematically generated texel values) for use by the shader module, raster module, fog module, alpha test module, depth test module, alpha blend module and\/or the like. The white noise samples may also be output for further processing by the hashing module , shader module , raster module, fog module, alpha test module, depth test module, alpha blend module and\/or the like. In one implementation, the white noise may be further processed to generate pink noise, brown noise, fractal noise or the like, in accordance with any well-known prior art functions. Such other noise may be used to generate patterns, such as wood, marble, etc., without the use of a texture stored in memory (e.g., mipmap).","Referring now to , B, C and D, exemplary noises and textures generated from such noises, in accordance with one embodiment of the present invention, are shown. The textures may be generated as a function of white noise from the parallel hashing module of  of  in accordance with the process described with reference to . For example, fractal noises, generated from white noise, with different levels L and persistence p are depicted in .  depict corresponding textures generated from the fractal noise samples shown in . Assuming the fractal noises of  are normalized in the range [0 1], the wood grain texture in  is generated by fractions(8\u00d7N) and the marble vein in  is generated by |cos(4\u03c0\u00d7x+N)|.","Referring now to , a flow diagram of a method of image encryption, in accordance with one embodiment of the present invention, is shown. As depicted in , the method of image encryption begins with receiving one or more hash inputs, at step . Each hash input may be a device identifier, a user password, a base image (e.g., simple ramp image), one or more primitive coordinates, one or more texel addresses and\/or the like.","At step , the one or more hash inputs are evaluated utilizing a cryptographic hash function to generate a plurality of white noise samples. Each sample of the hash input may be evaluated independently and in parallel. The cryptographic hash function may be a message digest algorithm (e.g., MD2, MD3, MD4, MD5), a security hash standard (SHS, SHA, SHS-1, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512) or the like. Such cryptographic hash functions generate random numbers having a high degree of entropy. Furthermore, an arbitrary large number of white noise samples may be produced from a small hash input (e.g., graphics processor device identifier).","At step , a rendered image is received. In one implementation, the rendered image may be a plurality of pixel values destined for storage in a frame buffer or similar computer-readable medium. The generated white noise is bit-wise combined with the received rendered image to effectively encrypt the rendered image, at step . In one embodiment, the pixel values are combined with the white noise samples utilizing a bit-wise Boolean XOR function. At , the encrypted image generated by XOR\u2032ing the rendered image and the white noise is output.","It is appreciated that the encrypted image may be decrypted by combining the encrypted image with the same white noise. More specifically, the pixel values of the encrypted image are combined with the same white noise samples utilizing the bit-wise Boolean XOR function to generate the decrypted image.","Referring now to , an exemplary input image and encrypted image, in accordance with one embodiment of the present invention, is shown. The encrypted image depicted in  is generated by bit-wise XOR'ing the input image depicted in  with white noise generated utilizing a cryptographic hashing function. It is appreciated that the encrypted image may be decrypted by XOR'ing the encrypted image with the same white noise.","Referring now to , block diagrams of exemplary computing devices for implementing embodiments of the present invention, are shown. The computing devices may be a cellular telephone, PDA or other portable wireless appliance, navigation system (e.g., map enabled GPS), palm-sized computer, tablet computer, game console, personal entertainment center, media center PC, computer based simulator, desktop computer, laptop computer, or the like. The computing device architectures provide the execution platform for implementing certain functionality of embodiments of the present invention. As depicted in , a first computing device may include a processor , a system memory controller , a system memory , a host interface , a graphics processor , a graphics memory controller , a graphics memory , a display controller  and a display . The processor  may be communicatively coupled to the system memory  through the system memory controller . The processor  may also be communicatively coupled to the graphics processor  through the host interface . The graphics processor  may be communicatively coupled to the graphics memory  through the graphics memory controller . The graphics memory controller  may also communicatively couple the display controller  to the graphics memory . The display  may be communicatively coupled to the display controller .","As depicted in , a second computing device may include a processor , a host interface , a graphics processor , a unified memory controller , a unified memory , a display controller  and a display . The processor  may be communicatively coupled to the unified memory  through the unified memory controller . The processor  may also be communicatively coupled to the graphics processor  through the host interface . The graphic processor  may be communicatively coupled to the unified memory  through the unified memory controller . The unified memory controller  may also communicatively couple the display controller  to the unified memory . The display  may be communicatively coupled to the display controller .","The processor ,  provides one or more applications by operating on instructions (e.g., computer executable code) and information (e.g., data) stored in memory ,  (e.g., computer-readable medium). The memory controller ,  controls the flow of such information and instructions between the processor ,  and memory , . Images to be output on the display ,  may be off-loaded to the graphics processor ,  by the processor , . The images are off-loaded by transferring geometric primitive parameters, draw commands and instructions for controlling the operation of the graphics processor , . The primitive parameters, draw commands and instructions are transferred from the processor ,  to the graphics processor ,  under control of the host interface , . In one implementation, a widely implemented graphics application programming interface, such as the OpenGL-ES\u2122 graphics language, Direct3D\u2122, or the like, is utilized for the software interface between the graphics processor ,  and the applications provided by the processor , .","The graphics processor ,  generates a color value for each pixel of the display ,  in response to the received primitives, draw commands and instructions. The graphics processor ,  includes a parallel hashing module coupled to a shader module, as more fully described above with reference to . The parallel hashing module generates white noise as a function of one or more hash inputs, in accordance with the method more fully described above with reference to . The one or more hash inputs may be primitive coordinates, texel addresses, a device identifier, user password, base image and\/or the like. The white noise may be utilized as texel values by the shader module of the graphics processor , . The white noise may also be further processed by the graphics processor ,  to generate other types of noise, such as pink noise, brown noise, fractal noise and\/or the like. The white noise may also be combined with pixel data to generate encrypted images and decrypt them, as more fully described above with reference to .","Accordingly, embodiments of the present invention advantageously generate white noise for use in graphics and imaging processes. The white noise may advantageously be utilized for generating texel data by a graphics processor without consuming texture memory. The white noise may also advantageously be utilized to provide image encryption and image decryption. Embodiments of the present invention advantageously implement a parallel hashing module in hardware for generating the white noise. The parallel hashing module advantageously generates a random number having a high degree of entropy in a single step. Accordingly, the parallel hashing module advantageously reduces processing latency in the graphics processor.","The foregoing descriptions of specific embodiments of the present invention have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the Claims appended hereto and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention are illustrated by way of example and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIGS. 2B and 2C","FIG. 2A"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 3A","b":["3","3","3"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 6A and 6B"}]},"DETDESC":[{},{}]}
