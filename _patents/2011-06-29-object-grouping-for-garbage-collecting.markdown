---
title: Object grouping for garbage collecting
abstract: Methods, systems, and computer program products for memory garbage collection via object grouping are disclosed. Normative objects are allocated in a non-native memory referencing respective one or more native objects in a native memory. The non-native objects are grouped into non-native object groups based upon information regarding object references associated with respective ones of the native objects. Objects in respective ones of the one or more non-native object groups are provided one or more references to other said objects of the non-native object groups to create connected object groups. Unused ones of the connected object groups are detected. And objects of the detected unused ones of the connected object groups are de-allocated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856186&OS=08856186&RS=08856186
owner: Google Inc.
number: 08856186
owner_city: Mountain View
owner_country: US
publication_date: 20110629
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE EMBODIMENTS","DETAILED DESCRIPTION"],"p":["1. Field","This disclosure generally relates to garbage collecting of objects from memory.","2. Background Art","Garbage collection, as used herein, is a form of memory management. A garbage collector will seek to collect and remove objects or other data structures that are stored in memory but are no longer being used. Garbage collection can occur at any time during system processing, but may also be configured to activate when the memory consumption has reached or is nearing capacity or another configured threshold. In many processing environments, many of the objects, variables and other data that are created or used during the execution of a program are stored in an area of memory known as the heap. As the heap fills up or reaches capacity, a garbage collector may be configured to clear the unused objects from the heap, so that the system can use the available memory for further allocations.","Conventional garbage collection schemes work by maintaining a root set of objects from which all objects that are currently in use are reachable. Whether or not an object is reachable from a node in the root set is determined by keeping track of the references among active objects. At the time of garbage collection, any objects that are not reachable from the root set are considered unused and may be de-allocated. The conventional garbage collection schemes may work adequately when all of the objects are from the same processing environment, because then the interdependencies between objects can be accurately determined. However, conventional garbage collection schemes cannot effectively determine which objects are to be cleared from a heap (e.g., are unused), when one or more of those objects correspond to or references one or more objects in another processing environment. As such, when objects in a first processing environment reference objects in a second processing environment, conventional garbage collection schemes may result in unused objects remaining in the heap or other memory portion even after garbage collection.","Leaving unused objects or other data structures within a heap, as may be done by conventional schemes, is referred to as a memory leak. These memory leaks may, over time, cause more and more of the memory accessible to an operating program to be consumed by unused objects, which may eventually cause the system to run out of memory for new objects necessary for continued execution of the system.","Methods, systems, and computer program products for memory garbage collection via object grouping are disclosed. Non-native objects are allocated in a non-native memory referencing respective one or more native objects in a native memory. The non-native objects are grouped into non-native object groups based upon information regarding object references associated with respective ones of the native objects. Objects in respective ones of the one or more non-native object groups are provided one or more references to other said objects of the non-native object groups to create connected object groups. Unused ones of the connected object groups are detected. And objects of the detected unused ones of the connected object groups are de-allocated.","Further features and advantages of the embodiments, as well as the structure and operation of various embodiments thereof, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","While the present invention is described herein with reference to illustrative embodiments for particular applications, it should be understood that the invention is not limited thereto. Those skilled in the art with access to the teachings herein will recognize additional modifications, applications, and embodiments within the scope thereof and additional fields in which the invention would be of significant utility.","Embodiments disclosed herein can be used to perform garbage collection of memory using object grouping, particularly where objects in a first execution environment are referenced by objects in a second execution environment. Garbage collection of objects in a non-native memory is performed where the objects in the non-native memory reference objects in a native memory. The term \u201cnon-native memory\u201d is used herein to refer to the memory available to a processing environment that is not the native processing environments of the system. For example, the non-native memory may be the memory area used by an embedded execution environment. Processes or threads executing in the embedded processing environment allocate memory objects in the non-native memory. The term \u201cnative memory\u201d is used herein to refer to the memory that is not available to the embedded processing environment, but which is available to the native processing environment. The non-native memory may be a portion of a native memory.","According to one or more exemplary embodiments, garbage collection of objects in a non-native execution environment such as a Java Virtual Machine (JVM) is performed, where JAVA objects are allocated in a heap in the non-native memory in these exemplary embodiments, the non-native memory is allocated from a native memory which includes an area to allocate objects and other data structures, such as C\/C++ data structures, for the native execution environment. Objects may be garbage collected from memory when both non-native and native objects are stored in one or more memory portions (e.g., heaps) and one or more non-native objects are created as proxies or wrappers to correspond or point to the one or more native objects. A program may instantiate, create or otherwise use both non-native and native objects during its execution. These objects may be allocated in heap portions of memory.","When executing the program, non-native objects may be created and allocated in portions of a non-native heap. Similarly, native objects may be created and allocated in portions of a native heap. However, often when native objects are created or otherwise used or referenced by the program, a corresponding non-native object that refers to or otherwise represents the native object within the non-native environment may be created within the non-native heap, herein referred to as a wrapper object. The wrapper object may operate as proxy, whereby when the program is executing and uses a native object, the wrapper object may point to the native object required by the program. For example, in JAVA, a wrapper object may be created that points to, refers to, or otherwise references a native object that is created or otherwise used by an executing program","As the program executes, more and more non-native objects and non-native wrapper objects (that correspond to one or more native objects) may be created and allocated in the non-native heap. Then, for example, as the available space remaining in the heap is allocated in more and more non-native objects, a non-native garbage collector may be executed to clear the unused objects (including wrapper objects) from the non-native heap. A non-native memory manager may effectively track relationships and usage of non-native objects stored in the non-native heap, which can be provided to (or in other embodiments collected by) a non-native memory garbage collector which may then clear the unused (non-wrapper) non-native objects from the non-native heap. However, conventional non-native memory managers may be unable to correctly garbage collect the non-native wrapper objects that may exist in the non-native heap.","Conventional non-native memory managers may fail in correctly garbage collecting the non-native wrapper objects because they may be unable to track the relationships or usage among the native objects, which are allocated in the native memory heap and cannot therefore be accessed directly by the non-native memory managers. Conventional non-native memory managers may be unable to determine the relationships amongst the non-native wrapper objects because such non-native wrapper objects may or may not be related via their corresponding native objects in the native heap. Therefore, the non-native garbage collector cannot effectively garbage collect all the unused non-native (wrapper) objects of the non-native heap.","While there have been proposed solutions to address this memory leak issue in conventional memory management schemes, these proposed solutions result in less-than-ideal scenarios. One such proposed solution is to use weak references which may allow non-native objects to keep native objects alive (to the garbage collector) but not the other way around. However, as just noted, the weak references do not allow a garbage collector to trace through a native heap which prevents effective garbage collection of native objects. Another proposed solution is to create new objects at garbage collection time which attempt to track the relationship between non-native and native objects. This solution however requires allocation of new memory for new objects at or around garbage collection time, which can create problems such as memory allocation problems because it is being performed at a time when a heap is full and\/or is nearing capacity.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","100","100"]},"The system  may allocate a field, or other data-holding portion of memory to be associated with each wrapper object, that may be created or otherwise used to point to or otherwise reference one or more native objects. The field, herein referred to as a tracking field, may be used to define relationships amongst the non-native wrapper objects that represent the relationships that may exist amongst the corresponding native objects (to which the non-native wrapper objects refer). For example prior to garbage collection of the non-native heap (where non-native objects and non-native wrapper objects may be stored), and preferably immediately prior to the garbage collection of the non-native heap, the native objects of the native heap may be traversed. The system  may determine, based on the traversal of the native heap (and\/or objects stored thereon), the interconnectivity, relationships and\/or usage of the native objects. The system  may then provide values into the previously allocated tracking fields (of the non-native wrapper objects) that represent or otherwise correspond to the relationships amongst the corresponding native objects, creating one or more object groupings. Then, a non-native garbage collector, upon determining which objects of the non-native heap are being unused, may effectively garbage collect the unused non-native wrapper objects based on the object groupings, whereby all of the wrapper objects of an object grouping that are being unused will be garbage collected.","An unused object, as referred to herein, may include an object in a heap which is not referenced by, does not reference another and\/or is not accessible by any other object. For example, a program may create objects A, B, C, and D, whereby only A calls B, only B calls C and only A calls D. Then for example, if it is found that object A has been garbage collected or is no longer being used, then objects B, C and D may be considered unused objects as well and should be garbage collected when A is garbage collected. If however, one or more of these objects are non-native wrapper objects that correspond to native objects that exist in a native heap, then in conventional schemes, as discussed above, a conventional non-native garbage collector may have no way of determining which of the objects are unused and\/or should be garbage collected.","The system  however, prior to garbage collection time, may group or otherwise provide the relationships that exist amongst the (wrapper) objects A, B, C and D, as they correspond to native objects, by providing values into the tracking fields associated with the wrapper object. Then, for example, when A is determined to be unused and is garbage collected, a non-native garbage collector, based on the tracking field or other reference to the object groupings, may garbage collect all the objects of the group (e.g., B, C and D). The system , without requiring the allocation of any additional memory at or around garbage collection time when available memory is running low, may effectively garbage collect (e.g., free up memory allocated to unused objects as they exist in) the heaps, without modifying a legacy or conventional non-native garbage collector.","The system  of  may include a processor  which may include any computer or electronic processor for executing and\/or processing information. The processor  may include or be part of any device capable of processing any sequence of instructions. The processor  may include, for example, a computer processor, a processor in a mobile device or other electronic and\/or digital processor. Processor  may, for example, be included in a computer, a mobile computing device, a set-top box, an entertainment platform, a server, a server farm, a cloud computer and the like. The processor  may be connected to a memory  via a bus .","The memory  may include volatile memory, virtual and\/or other memory, configured to store information for use by and\/or output by the system . The memory  may include, for example, random access memory (RAM) and\/or dynamic RAM (DRAM). The memory  may be used to store any information, such as state and\/or other program information of the system .","According to an example embodiment, the memory  may be used or otherwise logically and\/or physically divided into one or more memories, memory segments or memory portions referred to as heaps (A, B). The heaps A, B may include portions of memory available to a program  for dynamic memory allocation during the program's execution. For example, the non-native heap A and the native heap B may be used by a program to store non-native and native objects and data, respectively. The memory partition as shown in  is exemplary only and in other embodiments the memory  may be partitioned into more or fewer heaps (A, B) or not partitioned at all. In other example embodiments, there may multiple memories . The memory , including the heaps A, B may be garbage collected by one or more garbage collectors.","The bus  may include a communication infrastructure that allows interaction between the various components of the system . The bus  may, for example, carry data between the components of the system , such as between the processor  and the memory . The bus  may include a wireless and\/or wired communications medium between the components of system , and may include parallel, serial or other topological arrangements.","A persistent storage  may include non-volatile main memory as used by processor  in the system . Persistent storage  may include, for example, computer readable media such as flash memory, a hard disk or optical disk. Persistent storage  may be used, for example, to store instructions of program .","The system  may include a program . The program  may be executed by the one or more processors () (the code and\/or instructions of the program  as executed by the processor  may reside on one or more memories  and\/or persistent storage , and\/or may be distributed over one or more networks and reside on one or more devices). The program  may be written in or otherwise comprise code and\/or instructions associated with two or more program environments, including, for example, a non-native processing environment (non-native PE)  and a native processing environment (native PE) . The program  may use one or more application programming interfaces (APIs) to interact with one or more of the processing environments , .","The processing environments ,  may include any set of processes, tools and\/or other resources used to create and\/or otherwise used by the program . The processing environments ,  may include one or more virtual machines. For example, the non-native PE  may include a Java development, programming, or processing environment, and then by contrast, the native PE  may include any other environment that is not Java, including, but not limited to a C or C++ environment. In other embodiments, this may be reversed, where C\/C++ may be considered non-native, and Java considered native. In another example embodiment, the native PE  may be a different version of the programming language associated with the non-native PE . The system  may include at least one non-native PE  and at least one native PE , though other embodiments may include more than one non-native and\/or native PE , .","As the program  executes, a non-native memory manager (non-native MM)  and a native memory manager (native MM)  may manage the objects as created and\/or instantiated by the program  in the non-native and native heaps A and B, respectively. For example, if the program  calls for the instantiation of a Java (non-native) object, this non-native object may be managed by the non-native MM  and stored in the non-native heap A. Whereby any non-Java (e.g., native) object may be handled by the native MM  and stored in the native heap B. As referenced above however, the creation and\/or other use of one or more of these native objects may cause the non-native MM  to populate the non-native heap A with a non-native wrapper object corresponding to one or more native objects in the native heap B.","The non-native MM  may be configured to manage the non-native heap A. The non-native MM  may include any number of functional blocks associated with compiling, executing and\/or otherwise supporting the execution of at least a portion of the program , including managing the memory heap A. The non-native MM  may include, for example, a virtual machine, such as a java virtual machine (JVM). The JVM () may then manage or track objects that are created and\/or being used in one or more corresponding Java heaps A.","The native MM  may include functionality similar to that of the non-native MM  as just described, except as applied to the native PE . Whereby, the native MM  may support the program  execution and manage native objects stored and\/or need to be created in the native heap B. For example, if the non-native MM  manages Java objects, then the native MM  may manage any non-Java objects, including but not limited to C and\/or C++ objects.","The non-native MM  may include an object allocator . The object allocator  may allocate portions of the memory  (e.g., non-native heap A) as required or to be used by the program . For example, as just referenced, if the program  calls for the instantiation of a non-native object, then the object allocator  may reserve that portion of the non-native heap A to be used to store the non-native object. If the program  calls for a native object, then the object allocator  may allocate a corresponding non-native-wrapper object to the non-native heap A. The term \u201cobject\u201d, is used herein to reference an exemplary usage of the system  in managing the memory . Though the term \u201cobject\u201d is commonly associated with object-oriented programming, one skilled in the art will recognize that the system  may manage the memory  with other forms of memory usage in other kinds of programming, operating and\/or execution environments (including, but not limited to, objects in an object-oriented processing environment). For example, the system  may be used to manage memory allocation (e.g., perform garbage collection) to store any data or variables.","The program  may execute for some period of time, whereby non-native objects (including wrapper objects) that are instantiated or otherwise created reside on the non-native heap A and native objects reside on the native heap B (for which one or more corresponding non-native wrapper objects may reside on the non-native heap A). Then for example, once the memory  (e.g., one or more of the heaps A, B) exceeds a storage threshold, and\/or one or more of the MMs ,  determine that it is time to garbage collect the memory , an object interconnectivity determiner (OID)  may execute.","The OID  may determine interconnectivity between the native objects of the native heap B. The OID  may, for example, track the usage of native objects called by the program . In another example embodiment, the OID  may traverse the native objects as stored in the native heap B, prior to garbage collection of the memory  (e.g., heaps A and\/or B), and determine dependencies, calls and\/or other relationships amongst the native objects. According to an example embodiment, the OID  may group or otherwise determine the existing groupings of the native objects of the native heap B based on their relationships with each other.","A relationship grouper  may translate or otherwise represent the relationships amongst the native objects (as determined by the OID ) amongst the corresponding non-native wrapper objects on the non-native heap A. The non-native heap A, as referenced above, may include one or more non-native wrapper objects that point or otherwise refer to one or more corresponding native objects on the native heap B. Tze object allocator  may include with each non-native wrapper object, on the heap A, a tracking field or other portion of memory by which to represent the relationships amongst the non-native wrapper objects. Each wrapper object may include in its object class (definition), one or more tracking fields, for which memory is allocated from the heap A, at the time of instantiation or creation of the wrapper object(s) (which may or may not substantially correspond to the instantiation of corresponding native objects). In other embodiments, the tracking field(s) may be later added to and\/or associated with the wrapper object(s), prior to garbage collection and\/or prior to the heap A and\/or memory  reaching a threshold or other capacity.","The relationship grouper  may then use the tracking field of the wrapper objects to define relationships amongst the wrapper objects that mimic or are otherwise consistent with the relationships\/interconnectivity amongst the corresponding native objects (as determined by the OID ). For example, when the program  creates (or otherwise references the creation of) native objects, the native MM  may receive an instruction to create a native object in the native heap B, and the non-native MM  may receive an instruction to create a corresponding non-native wrapper object in the non-native heap A (the sequence and\/or simultaneity of the creation of the native object and the corresponding non-native wrapper object does not matter).","Then, for example, as the program  continues to execute, relationships may develop and\/or otherwise be defined between and\/or amongst the native objects in the native heap B. The native MM  may receive these instructions and represent or otherwise track this interconnectivity amongst the native objects (e.g., in the native heap B). The non-native MM  however may not receive these instructions regarding the interconnectivity of the native objects in the native heap B. As a result, though the non-native wrapper objects that correspond to the native objects may exist in the heap A, without the functionality provided by the relationship grouper  (as in conventional schemes) there may be no matching interconnectivity amongst the non-native wrapper objects matching the interconnectivity of the native objects to which the non-native wrapper objects correspond.","As a result, without this interconnectivity between and\/or amongst the wrapper objects on the non-native heap A being defined, as in conventional (e.g., without relationships defined by the relationship grouper ) schemes, garbage collectors, when clearing unused objects from the heap A, may remove or de-allocate some of the unused wrapper objects but may not clear all of the wrapper objects that may be unused. The relationship grouper  addresses this issue by defining the relationships amongst the non-native wrapper objects of the non-native heap A as they correspond to the native objects of the native heap B","The relationship grouper  may use the tracking fields of the wrapper objects to define or otherwise identify relationships amongst the wrapper objects of the heap A as they correspond to the (relationships amongst) native objects of the heap B. As referenced above, tracking fields may include a field of the wrapper objects (which have already been allocated) used to identify relationships and\/or object groupings amongst the wrapper objects. For example, if native object A has a relationship with native objects B and C, the relationship grouper  may use the tracking field of wrapper object A to point to wrapper object B, use the tracking field of wrapper object B to point to wrapper object C, and use the tracking field of wrapper object C to point to wrapper object A. As such, the relationship grouper  may create one or more circular linked lists amongst the non-native wrapper objects of the heap A using the pre-allocated and\/or otherwise pre-defined tracking fields. Each linked list, circular or not, as defined by the relationship grouper , may be an object grouping. The relationship grouper  may provide or define a value in the tracking field that references or otherwise groups a wrapper object with other non-native (wrapper and\/or non-wrapper) objects. This value(s) may, in an example embodiment, not take up any more memory space than was originally allocated to the tracking field.","Though a tracking field may be defined with the instantiation or creation of the wrapper objects in the system , in other example embodiments, the tracking field may be created at other times as well. Tracking fields may be added or otherwise associated with the wrapper objects at any point before garbage collection and\/or the available or remaining memory (from memory ) crosses below a threshold. For example, the heap A may have a first threshold at which (tracking) fields or other data-objects are created to represent the interconnectivity\/relationships of the native objects amongst the wrapper objects at any point during garbage collection. Then for example, the heap A may have a second threshold at which garbage collection is performed. Though a tracking field is referred to herein as being used to represent the relationships amongst the wrapper objects, as just referenced, other example embodiments may include other data-objects, other than a field to represent the interconnectivity and\/or relationships of the native objects.","After the relationship grouper  has grouped the non-native wrapper objects into one or more groupings (based on the relationships\/interconnectivity amongst the corresponding native objects), a usage detector  may determine object usage amongst the non-native (including wrapper and non-wrapper) objects of the heap A. The usage detector  may determine which objects of the non-native heap A are being used and\/or are unused. For example, the usage detector  may determine which object(s) of the heap A are no longer and\/or can no longer be referenced by and\/or make reference to other objects of the heap A. These objects that may be determined to have no reference to and\/or from other objects may be deemed unused objects.","For example, if heap A includes wrapper objects A-E that have relationships as provided by the relationship grouper , whereby only object A calls object B which is the only object that calls objects C, D and E, and if there is no other object in heap A that calls, references and\/or otherwise uses object A, then object A may be considered unused by the usage detector . And then, based on the relationships between the objects, all the other objects (B-E) belonging to the same grouping as object A may be considered unused objects as well.","A non-native garbage collector  may de-allocate the unused objects from heap A. Non-native garbage collector  may de-allocate or otherwise free up that portion of memory  (e.g., specifically in non-native heap A) that was being used or otherwise reserved for the unused objects. Non-native garbage collector  may determine whether or not to remove all the non-native objects belonging to a grouping, such that if one of the objects of the grouping is determined to be unused, then all the objects of the grouping are unused, and likewise, if one member of a grouping is being used, then none of the members of the grouping may be de-allocated by the non-native garbage collector  because the usage detector  may determine that all of the objects of the grouping are being used.","The system  may allow a non-native garbage collector to efficiently collect all the garbage (e.g., unused objects) stored in a non-native heap, including those objects that are references, wrappers, pointers and\/or other proxies to objects stored in one or more native heaps. By pre-allocating space in a tracking field of the wrapper objects, the system  traverses the native heaps and provides the interconnectivity\/relationships amongst the native objects to the non-native heap using the tracking field, which results in one or more object groupings. Because the tracking fields are pre-allocated in the respective non-native objects, there is no additional consumption of memory for tracking purposes or object groupings at the time of garbage collection. Then the non-native garbage collector, using the object groupings, can efficiently determine which object groupings are being unused, de-allocate all of the objects of the unused groupings and free up memory space in the heap for continued program execution.","The system  may be implemented using conventional or legacy non-native garbage collectors in existing schemes. The system  does not require any modification to the conventional garbage collectors. As part of their existing process, the conventional garbage collectors will recognize the groupings as defined in the system  and described above. As such, implementing the system  into conventional schemes with legacy garbage collectors will allow the legacy garbage collectors to account for and free memory that may be otherwise allocated to unused wrapper objects and that may create memory leaks and system crashes.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 1"],"b":["100","200","120","140","120","140","200"]},"The non-native PE  may include an application programming interface (API) module  that may be used by the non-native memory manager (MM)  to communicate with native memory manager , for example, to be informed about the used and\/or unused status of native objects. As shown, the non-native wrapper object  may include a tracking field . The API module  may include a particular set of rules and\/or specifications that a program () can follow for make use of another program () that implements the API. The API module  may serve as an interface between the non-native PE  and the native PE . The non-native MM  may use the API module  to generate the wrapper object(s) , or, for example, the API module  may be used to define or may otherwise define the wrapper object , which may then be instantiated by the non-native MM .","Prior to garbage collecting non-native heap A, as discussed above, OID  may determine relationships amongst one or more native objects  that exist on native heap B. After the relationship information for the native objects  has been determined, the information and control may be passed back to the non-native PE  via a callback function . The non-native memory manager  may then provide values to the tracking field(s)  to group the wrapper objects  of the non-native heap A based on the relationships among the corresponding native object(s) . The garbage collector  may then garbage collect the non-native heap A and remove unused objects.","Though not specifically shown, it may be understood that the native PE  may include its own object grouping and garbage collection system (e.g., 100) as described above. In the native PE's  system, the native PE  may be considered non-native and the non-native PE  may be considered native. Then, the garbage collection system may effectively clear all the unused objects from the native heap B. In other embodiments, the native PE  may be embedded within a third PE (e.g., another non-native or native PE, not shown) and one or more object grouping garbage collection systems may operate on two or more of the PEs.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 3A","FIG. 3B","FIG. 3A"],"b":["104","104","104"]},"As shown in , the non-native heap A may include a number of non-native wrapper objects, A, A, A, A, A, A, A, A and A that correspond to one or more native wrapper objects in the native heap B, whereby like numbered objects between the heaps may correspond. For example, the wrapper object A may correspond, reference or otherwise point to the native object . Though the example of  shows a one-to-one correspondence between the objects of the heaps A, B, other embodiments may include other correspondences such as one-to-many and\/or many-to-one. Also, though only wrapper and native objects are shown, the heaps A, B other objects and\/or data as well (not shown).","The native heap may include the native objects organized into two interconnected or logical trees , . The trees  and  are exemplary only. As shown the tree  may include a parent node  connected to children nodes  and , by which child node  is the parent of nodes  and . Even though, for example, the nodes  and  may exist on different branches of the tree , the OID  and\/or the relationship grouper  may recognize that the nodes may still communicate with one another through parent-child relationships in the tree  and thus may be grouped together as shown in the corresponding object grouping  in .","The non-native heap A of  may include a representation of the non-native heap A of  after object grouping. The trees  and  may be represented by the object groupings  and , respectively. The object groupings may be defined by the values provided by the tracking fields  that did not exist in the pre-grouping heap . The tracking fields in the example groupings ,  may correspond to circular linked lists. Then, for example, when a garbage collector () parses the non-native heap A after grouping, the garbage collector will know that either all of the nodes of an object grouping  or  are to be garbage collected or none of them. Because if even a single node of the groupings ,  is being used, then it is possible that any of the nodes or objects of the grouping may be used and should not be garbage collected. But by garbage collecting all the nodes of a grouping that are unused, the garbage collector may prevent memory leaks from occurring in the non-native heap B due to unused objects remaining in memory ().","The non-native heap A may include a root set . The root set  may include the object(s) of the heap A that are considered reachable or in use by a program (). As may be seen in the example of A, the object grouping  may include a connection or reference from the root set , which may indicate that the object grouping  is being used or is reachable and should not be garbage collected. The object group , by contrast, does not include a reference to\/from any other root set or reachable object. As such, all the objects of the group  may be considered unused and should be garbage collected on the next iteration of the a non-native garbage collector ().",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 4","FIGS. 1-3B"],"b":["400","402","208","104","150"]},"At step , objects may be allocated in a non-native memory. For example, a wrapper object  may be allocated in the non-native memory A. The wrapper object  may include a tracking field  that may be allocated at the same time that the wrapper object  is created. The tracking field  may or may not have a valid value or reference at this time, and may be initialized to a default value.","At step , references may be set from objects on the non-native memory to objects on the native memory. For example, a wrapper object A may correspond and\/or otherwise be created as a response to the creation of a native object . The wrapper object A may include a reference, pointer or other correspondence information that indicates that the wrapper object A references the native object .","At step , connected objects may be identified in the native memory. For example, the OID  may determine the interconnectivity of the native objects  . . .  of the native heap B. The interconnectivity may include any connectivity, calls, references or other relationships between and\/or amongst the native objects  . . .  and\/or one or more other objects.","At step , non-native objects may be grouped into non-native object groups based on connected objects in the native memory. For example, as shown in , the non-native heap B, after object grouping, may include the object groupings  and . The object groupings, at this point, as determined by the relationship grouper , may not include the values of the tracking field  may be filled in later. Or for example, the tracking fields  may be provided a preliminary or grouping value to indicate which of the non-native objects belong to the same group. The non-native wrapper objects A, A, A and A may be grouped based on the connected objects of the tree . In other embodiments, the tracking field  values may be provided prior to and\/or simultaneously with object grouping.","At step , non-native object groups may be linked to generate non-native connected object groupings. For example, as shown in the heap B of , the values of the tracking fields  may be provided (e.g., by the relationship grouper ) to create or represent the connections between the non-native wrapper objects of the groupings  and . The connections as shown by tracking field  in , may not actually exist within the non-native heap A, but rather may be inferred from the values provided to the tracking fields .","At step , the object groupings to be de-allocated may be determined. For example, the usage detector  may determine which non-native objects of the non-native heap A may be used and\/or unused. An unused object may include an object to which there are no known and\/or otherwise detected references to and\/or from that object to one or more objects of the same and\/or different heaps A, B or other memory  portions. The usage detector  may determine whether all or none of the non-native objects of the object groupings ,  are being unused and as such may be de-allocated. If, however, even a single object of one of the object groupings ,  may be accessed and\/or called by an object outside the grouping (e.g., being used) then all of the objects of the grouping ,  may be used and are not ready for de-allocation.","At step , the unused connected object groupings of the non-native memory may be de-allocated. For example, the garbage collector  may de-allocate or otherwise free up any of the memory  being used or otherwise allocated in the unused objects of the non-native heap A. The garbage collector  may, for example, remove the unused (wrapper and non-wrapper) objects including all the objects of whatever object grouping ,  to which they belong. At an end step, the process  may complete.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 5","FIGS. 1-3B"],"b":["500","502","121","104","104","144","140"]},"At step , a callback function may be invoked to the native processing environment. For example, the OID  of the native PE  may determine the relationships amongst the native objects of the heap B. Then upon this completion, the callback function  may be invoked that may return the object grouping for garbage collection process back to the non-native processing environment .","At step , object information may be received from the native processing environment. For example, the non-native MM  may receive the relationship information (as determined by the OID ) from the native PE . The non-native MM  may provide this information to the relationship grouper .","At step , the connected object groups may be identified in the non-native memory. For example, the relationship grouper  may group the objects of the non-native memory A into the object groupings  and  based on the relationships between the native objects as shown in trees  and .","At step , a linked list may be created for each connected object group in the non-native memory. For example, the relationship grouper  may provide values that create relationships between the objects of the non-native heap A. As shown, particularly in , the tracking fields  may be inserted and\/or created or otherwise defined between the non-native wrapper objects to create the connected object groupings ,  as shown. The linked list may include a circular linked list where the last element of the list points back to the first element of the list.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 6","FIG. 3A"],"b":["600","602","104","321"]},"At step , a second object may be selected and a tracking value may be provided in the first object to the second object. For example, the object A may be selected from the heap A. Then, for example, the relationship grouper  may provide a tracking value in tracking field  to create a reference or relationship between the objects A and A.","At step , it may be determined whether there are more objects in the connected group. For example, the relationship grouper  may determine that the objects A A, and A of the group  still remain and have not been connected. Then, for example, the process  may move down the \u2018Yes\u2019 branch to step .","At step , a next object may be selected and a tracking value may be provided in the previously selected object to the selected next object. For example, the relationship grouper  may select the object A, and provide a tracking value linking or associating the object A to object A. Then the process  may continue to step  to repeat the process for the remaining objects of the group (e.g., A and A).","When all the objects of the group have been interconnected to at least one other object of the group, the process  may proceed from step  to step . At step , another tracking value may be provided that links the last object of the group (e.g., object A) to the first object of the group (e.g., object A). Step , is optional, but may be used to create a circular linked list of the connected object groupings , . The circular linked list may include a reference from the last item(s) of the list to the first item(s) of the list or object grouping, as shown in groupings  and . The process  ends.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 7","FIGS. 1-3B"],"b":["700","702","132","104","121","141","141","144"]},"At step , object hierarchies of the native memory may be traversed. For example, the OID  may traverse the hierarchies of the trees  and  in the native heap B. Though the trees ,  are shown as having a top-down hierarchical nature, in other embodiments the trees ,  may be flat, singular, circular and\/or may embody other hierarchies as well, including but not limited to top-down.","At step , connected and\/or unconnected objects may be identified. For example, the OID  may determine which objects of the trees ,  are connected to other objects and\/or how they are connected.","At step , object information may be returned to a non-native processing environment. For example, the callback function  may be executed or called and the object information (as collected\/determined by the OID ) may be provided to the non-native PE . The process  ends.","The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.","The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can, by applying knowledge within the skill of the art, readily modify and\/or adapt for various applications such specific embodiments, without undue experimentation, without departing from the general concept of the present invention. Therefore, such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments, based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation, such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.","The breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["Reference will be made to the embodiments of the invention, examples of which may be illustrated in the accompanying figures. These figures are intended to be illustrative, not limiting. Although the invention is generally described in the context of these embodiments, it should be understood that it is not intended to limit the scope of the invention to these particular embodiments.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3B","FIG. 3A"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
