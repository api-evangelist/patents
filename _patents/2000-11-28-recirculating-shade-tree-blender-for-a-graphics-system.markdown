---
title: Recirculating shade tree blender for a graphics system
abstract: A hardware-accelerated recirculating programmable texture blender/shader arrangement circulates computed color and alpha data over multiple texture blending/shading cycles (stages) to provide multi-texturing and other effects. Up to sixteen independently programmable consecutive stages, forming a chain of blending operations, are supported for applying multiple textures to a single object in a single rendering pass.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07034828&OS=07034828&RS=07034828
owner: Nintendo Co., Ltd.
number: 07034828
owner_city: Kyoto
owner_country: JP
publication_date: 20001128
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Provisional Application serial No. 60\/226,888, filed Aug. 23, 2000, the entire content of which is hereby incorporated by reference in this application. This application is related to concurrently-filed application Ser. No. 09\/726,212 of Law et al entitled \u201cMethod And Apparatus For Providing Logical Combination Of N Alpha Operations Within A Graphics System\u201d.","The present invention relates to computer graphics, and more particularly to interactive graphics systems such as home video game platforms. Still more particularly this invention relates to recirculating shader hardware for implementing shade trees for multitexturing and other effects.","Many of us have seen films containing remarkably realistic dinosaurs, aliens, animated toys and other fanciful creatures. Such animations are made possible by computer graphics. Using such techniques, a computer graphics artist can specify how each object should look and how it should change in appearance over time, and a computer then models the objects and displays them on a display such as your television or a computer screen. The computer takes care of performing the many tasks required to make sure that each part of the displayed image is colored and shaped just right based on the position and orientation of each object in a scene, the direction in which light seems to strike each object, the surface texture of each object, and other factors.","Because computer graphics generation is complex, computer-generated three-dimensional graphics just a few years ago were mostly limited to expensive specialized flight simulators, high-end graphics workstations and supercomputers. The public saw some of the images generated by these computer systems in movies and expensive television advertisements, but most of us couldn't actually interact with the computers doing the graphics generation. All this has changed with the availability of relatively inexpensive 3D graphics platforms such as, for example, the Nintendo 64\u00ae and various 3D graphics cards now available for personal computers. It is now possible to interact with exciting 3D animations and simulations on relatively inexpensive computer graphics systems in your home or office.","A problem graphics system designers confronted in the past was how to efficiently implement shaders in a graphics system. Generally, shading is the process performing lighting computations and determining pixel colors\/opacities from them. Generally, there are three main types of shading in common use: flat, Gouraud, and Phong. These correspond to computing the light per polygon, per vertex and per pixel. A wide variety of shading models have been created. There is no one shading model that pleases all users and is suitable for all applications. Therefore, several design approaches have been suggested to provide flexibility in terms of programmer selection and specification of shading models.","In the paper by R. L. Cook called \u201cShade Trees\u201d (84, pages 223-231, the author described a special purpose language in which a shader is built as a tree expression called a shade tree. Generally speaking, a shade tree is a tree of nodes each of which takes parameters from its children and produces parameters for its parent. For example, the parameters may be the terms of the illumination equation (e.g., specular coefficient or surface Normal). Other parameters might comprise atmospheric effects (e.g., haze) or projections. The RenderMan Interface uses shade trees to provide user-defined and system-defined shaders for a variety of purposes.","While shade trees have been used extensively in non-real-time rendering graphics systems, problems arise when trying to accommodate the flexibility that shade trees provide within the context of real-time rendering. It would be highly desirable to be able to provide the flexibility of shade trees within low cost real-time rendering systems such as, for example, home video game platforms and personal computer graphics cards.","Another problem confronting graphics systems designers has been how to efficiently provide a feature called single-pass multitexturing. Basically, texturing is a technique for efficiently modeling the properties of a surface. For example, instead of modeling the geometry of each individual brick and mortar line within a brick wall, it is possible to electronically \u201cglue\u201d an image of a brick wall onto a surface. Such texturing capabilities can be used to significantly increase image complexity without a corresponding increase in modeling and processing costs.","The extension to texturing known as multitexturing allows two or more textures to be applied to the same surface. For example, suppose you want to create an image of the earth as it might be seen from outer space. You could model the earth as a sphere and apply two different textures to it. The first texture could be an image of the continents and oceans. The second texture could be an image of cloud cover. By moving the cloud cover texture image relative to the continent\/ocean texture image, you could create a very realistic dynamic texture-mapped image.","Some graphics accelerators support multitexturing in which two or more textures are accessed during the same rendering pass. See, for example, Microsoft's Direct X 6.0 SBK (1998); Segal et al., \u201cThe Open GL Graphics System: A Specification\u201d (Version 1.2.1) (March 1998) (www.OpenGL.org). Certain PC graphics accelerator cards also provide single pass multitexturing. However, further improvements are possible.","The present invention provides a generalized shade tree blender that can be used for multitexturing as well as a number of other flexible blending effects. In accordance with one aspect provided by this invention, recirculating shader hardware within a graphics pipeline can be controlled to provide a number of independently controllable blending stages. A shader hardware includes intermediate storage for results of previous blending operations. The shader hardware can select different inputs and perform different operations for each blending stage. Thus, relatively low cost and compact shader hardware can be used to implement arbitrarily complex shade trees.","In accordance with another aspect provided by this invention, the results of a first texture mapping operation is provided to a reconfigurable shader. The shader performs a blending operation in response to the first texture mapping operation. The shader is then reconfigured, and is connected to receive the results of a further texturing operation. The reconfigured shader combines its previous results with the results of the further texturing operation to provide a blended output.","In accordance with a further aspect provided by this invention, a shader can be recirculated any desired number of times to implement an arbitrarily complex shading model. Each recirculation or \u201cstage\u201d can be programmed to have any one of a number of desired blending operations and to blend from selected ones of a variety of color, opacity or depth sources. The number of recirculations may be limited in a particular implementation in view of real-time rendering timing constraints, but a reasonable number of recirculation stages (e.g., fifteen) can provide great flexibility in implementing a variety of complex shading models.","In accordance with another aspect provided by this invention, a recirculating shade tree pixel blender is implemented in hardware to minimize processing time per stage. In more detail, a preferred embodiment of this invention provides a relatively low chip-footprint, versatile texture-environment processing subsystem including a hardware accelerated programmable texture shader\/pixel blender that circulates computed color, opacity and other data over multiple cycles\/stages. The texture environment subsystem can combine per-vertex lighting, textures, rasterized colors, opacities, and depths to form pixel parameters for display. Blending operations for color (e.g., RGB) and alpha components may be independently processed within the texture environment subsystem by a blending unit comprising a set of color\/alpha combiner (shader) hardware that is reused over multiple processing stages to implement multitexturing and other effects. Selectable current-color\/opacity input\/output registers may be shared among all stages to store intermediate results. The shader hardware can be reconfigured for each stage to provide a chain of specifiable blending\/shading operations supporting single rendering pass multitexturing and other effects.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1","b":["50","50"]},"In this example, system  is capable of processing, interactively in real-time, a digital representation or model of a three-dimensional world. System  can display some or all of the world from any arbitrary viewpoint. For example, system  can interactively change the viewpoint in response to real-time inputs from handheld controllers , or other input devices. This allows the game player to see the world through the eyes of someone within or outside of the world. System  can be used for applications that do not require real-time 3D interactive display (e.g., 2D display generation and\/or non-interactive display), but the capability of displaying quality 3D images very quickly can be used to create very realistic and exciting game play or other graphical interactions.","To play a video game or other application using system , the user first connects a main unit  to his or her color television set  or other display device by connecting a cable  between the two. Main unit  produces both video signals and audio signals for controlling color television set . The video signals are what controls the images displayed on the television screen , and the audio signals are played back as sound through television stereo loudspeakers L, R.","The user also needs to connect main unit  to a power source. This power source may be a conventional AC adapter (not shown) that plugs into a standard home electrical wall socket and converts the house current into a lower DC voltage signal suitable for powering the main unit . Batteries could be used in other implementations.","The user may use hand controllers , to control main unit . Controls  can be used, for example, to specify the direction (up or down, left or right, closer or further away) that a character displayed on television  should move within a 3D world. Controls  also provide input for other applications (e.g., menu selection, pointer\/cursor control, etc.). Controllers  can take a variety of forms. In this example, controllers  shown each include controls  such as joysticks, push buttons and\/or directional switches. Controllers  may be connected to main unit  by cables or wirelessly via electromagnetic (e.g., radio or infrared) waves.","To play an application such as a game, the user selects an appropriate storage medium  storing the video game or other application he or she wants to play, and inserts that storage medium into a slot  in main unit . Storage medium  may, for example, be a specially encoded and\/or encrypted optical and\/or magnetic disk. The user may operate a power switch  to turn on main unit  and cause the main unit to begin running the video game or other application based on the software stored in the storage medium . The user may operate controllers  to provide inputs to main unit . For example, operating a control  may cause the game or other application to start. Moving other controls  can cause animated characters to move in different directions or change the user's point of view in a 3D world. Depending upon the particular software stored within the storage medium , the various controls  on the controller  can perform different functions at different times.","Example Electronics of Overall System",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 2","b":"50","ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["a main processor (CPU) ,","a main memory , and","a graphics and audio processor ."]}}}},"In this example, main processor  (e.g., an enhanced IBM Power PC 750) receives inputs from handheld controllers  (and\/or other input devices) via graphics and audio processor . Main processor  interactively responds to user inputs, and executes a video game or other program supplied, for example, by external storage media  via a mass storage access device  such as an optical disk drive. As one example, in the context of video game play, main processor  can perform collision detection and animation processing in addition to a variety of interactive and control functions.","In this example, main processor  generates 3D graphics and audio commands and sends them to graphics and audio processor . The graphics and audio processor  processes these commands to generate interesting visual images on display  and interesting stereo sound on stereo loudspeakers R, L or other suitable sound-generating devices.","Example system  includes a video encoder  that receives image signals from graphics and audio processor  and converts the image signals into analog and\/or digital video signals suitable for display on a standard display device such as a computer monitor or home color television set . System  also includes an audio codec (compressor\/decompressor)  that compresses and decompresses digitized audio signals and may also convert between digital and analog audio signaling formats as needed. Audio codec  can receive audio inputs via a buffer  and provide them to graphics and audio processor  for processing (e.g., mixing with other audio signals the processor generates and\/or receives via a streaming audio output of mass storage access device ). Graphics and audio processor  in this example can store audio related information in an audio memory  that is available for audio tasks. Graphics and audio processor  provides the resulting audio output signals to audio codec  for decompression and conversion to analog signals (e.g., via buffer amplifiers L, R) so they can be reproduced by loudspeakers L, R.","Graphics and audio processor  has the ability to communicate with various additional devices that may be present within system . For example, a parallel digital bus  may be used to communicate with mass storage access device  and\/or other components. A serial peripheral bus  may communicate with a variety of peripheral or other devices including, for example:\n\n",{"@attributes":{"id":"p-0048","num":"0053"},"figref":"FIG. 3","b":["114","114","114"],"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["a processor interface ,","a memory interface\/controller ,","a 3D graphics processor ,","an audio digital signal processor (DSP) ,","an audio memory interface ,","an audio interface and mixer ,","a peripheral controller , and","a display controller ."]}}}},"3D graphics processor  performs graphics processing tasks. Audio digital signal processor  performs audio processing tasks. Display controller  accesses image information from main memory  and provides it to video encoder  for display on display device . Audio interface and mixer  interfaces with audio codec , and can also mix audio from different sources (e.g., streaming audio from mass storage access device , the output of audio DSP , and external audio input received via audio codec ). Processor interface  provides a data and control interface between main processor  and graphics and audio processor .","Memory interface  provides a data and control interface between graphics and audio processor  and memory . In this example, main processor  accesses main memory  via processor interface  and memory interface  that are part of graphics and audio processor . Peripheral controller  provides a data and control interface between graphics and audio processor  and the various peripherals mentioned above. Audio memory interface  provides an interface with audio memory .","Example Graphics Pipeline",{"@attributes":{"id":"p-0051","num":"0064"},"figref":"FIG. 4","b":["154","154","200","180","110","200","110","115","111","114","111","114"]},"Command processor  receives display commands from main processor  and parses them\u2014obtaining any additional data necessary to process them from shared memory . The command processor  provides a stream of vertex commands to graphics pipeline  for 2D and\/or 3D processing and rendering. Graphics pipeline  generates images based on these commands. The resulting image information may be transferred to main memory  for access by display controller\/video interface unit \u2014which displays the frame buffer output of pipeline  on display .",{"@attributes":{"id":"p-0053","num":"0066"},"figref":"FIG. 5","b":["154","110","210","212","214","112","200","150","110","210","110","200"],"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["command streams from main memory  via an on-chip FIFO memory buffer  that receives and buffers the graphics commands for synchronization\/flow control and load balancing,","display lists  from main memory  via an on-chip call FIFO memory buffer , and","vertex attributes from the command stream and\/or from vertex arrays  in main memory  via a vertex cache ."]}}}},"Command processor  performs command processing operations that convert attribute types to floating point format, and pass the resulting complete vertex polygon data to graphics pipeline  for rendering\/rasterization. A programmable memory arbitration circuitry  (see ) arbitrates access to shared main memory  between graphics pipeline , command processor  and display controller\/video interface unit .",{"@attributes":{"id":"p-0055","num":"0071"},"figref":"FIG. 4","b":"180","ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["a transform unit ,","a setup\/rasterizer ,","a texture unit ,","a texture environment unit , and","a pixel engine ."]}}}},"Transform unit  performs a variety of 2D and 3D transform and other operations (see FIG. ). Transform unit  may include one or more matrix memories for storing matrices used in transformation processing . Transform unit  transforms incoming geometry per vertex from object space to screen space; and transforms incoming texture coordinates and computes projective texture coordinates (). Transform unit  may also perform polygon clipping\/culling . Lighting processing also performed by transform unit provides per vertex lighting computations for up to eight independent lights in one example embodiment. Transform unit  can also perform texture coordinate generation () for embossed type bump mapping effects, as well as polygon clipping\/culling operations ().","Setup\/rasterizer  includes a setup unit which receives vertex data from transform unit  and sends triangle setup information to one or more rasterizer units () performing edge rasterization, texture coordinate rasterization and color rasterization.","Texture unit  (which may include an on-chip texture memory (TMEM) ) performs various tasks related to texturing including for example:\n\n","For details concerning the operation of blocks ,and , a more detailed description of the example graphics pipeline circuitry and procedures for performing regular and indirect texture look-up operations is disclosed in commonly assigned co-pending patent application, Ser. No. 09\/722,382, entitled \u201cMethod And Apparatus For Direct And Indirect Texture Processing In A Graphics System\u201d and its corresponding provisional application, Ser. No. 60\/226,891, filed Aug. 23, 2000, both of which are incorporated herein by this reference.","Texture unit  outputs filtered texture values to the texture environment unit  for texture environment processing (). Texture environment unit  blends polygon and texture color\/alpha\/depth, and can also perform texture fog processing () to achieve inverse range based fog effects. Texture environment unit  can provide multiple stages to perform a variety of other interesting environment-related functions based for example on color\/alpha modulation, embossing, detail texturing, texture swapping, clamping, and depth blending.","As shown in , texture environment unit in the example embodiment includes a recirculating shader . Recirculating shader  in this example comprises a hardware-based general purpose blender that can blend between a number of selected inputs and can retain blended results for further blending in a subsequent blending operation. Recirculating shader  in this example comprises reusable blending logic that can implement a number of different blending operations. In the example embodiment, recirculating shader  can retain a number of different distinct previous blending results and can blend newly provided values with any of these previously blended results. This allows recirculating shader  to implement any arbitrary shade tree through successive recirculated stages. See, for example, Cook, , pages 223-231 (July 1984). The complexity of the shade tree that recirculating shader  can implement is limited by the total number of times recirculating shader  can recirculate within a given rendering pass. In the example embodiment, recirculating shader  can provide up to fifteen recirculated stages in the example embodiment but different implementations could provide different numbers of recirculating stages.","Once texture environment unit  generates a blended color\/alpha\/z output, pixel engine  performs depth (z) compare () and frame buffer pixel blending (). In this example, pixel engine  stores data into an embedded (on-chip) frame buffer memory . Graphics pipeline  may include one or more embedded DRAM memories  to store frame buffer and\/or texture information locally. Z compares \u2032 can also be performed at an earlier stage in the graphics pipeline  depending on the rendering mode currently in effect (e.g., z compares can be performed earlier if alpha blending is not required). The pixel engine  includes a copy operation that periodically writes on-chip frame buffer  to main memory  for access by display\/video interface unit . This copy operation can also be used to copy embedded frame buffer  contents to textures in the main memory  for dynamic texture synthesis effects. Anti-aliasing and other filtering can be performed during the copy-out operation. The frame buffer output of graphics pipeline  (which is ultimately stored in main memory ) is read each frame by display\/video interface unit . Display controller\/video interface  provides digital RGB pixel values for display on display .","Example Recirculating Shader",{"@attributes":{"id":"p-0063","num":"0088"},"figref":["FIG. 6","FIG. 7","FIG. 6","FIG. 6"],"b":"602"},"In more detail, recirculating shader  in the example embodiment can select between any of the following types of inputs:\n\n","Each independently controlled recirculation of recirculating shader  may be referred to as a \u201cstage.\u201d In the example embodiment, recirculating shader  is implemented by high-speed hardware logic in an application-specific integrated circuit (ASIC). Recirculation of a high-speed hardware logic functionality to provide a number of independently-controlled logical stages provides flexibility by allowing any desired number of shading\/blending stages while reducing hardware complexity and required integrated circuit real estate. Each recirculating shader  stage in the example embodiment computes independent blending operations for color (RGB) and alpha (transparency). The blending computation in the example embodiment can be programmed by the application running on main processor  from a number of different operations including, for example:\n\n",{"@attributes":{"id":"p-0066","num":"0116"},"figref":["FIG. 7","FIG. 5"],"b":["602","400","504","602","400","602"]},"Example Recirculating Shader Implementation",{"@attributes":{"id":"p-0067","num":"0117"},"figref":"FIG. 8","b":["602","600","602","656","658","658","660","660","656"]},"In the example embodiment, recirculating shader  provides a color component operation and a separate alpha component operation for each blending stage. For a given stage, the operation performed by block  can be different for the color component and the alpha component. The color and alpha component operations can be independently controlled by the application running on main microprocessor . This ability to provide independent color and alpha operation controls for each recirculating stage allows recirculating shader  to perform arbitrarily complex alpha (transparency) trees of operations at no additional cost in terms of processing speed. The alpha produced by the last stage of recirculating shader  is input to alpha compare block . The results of this alpha compare operation  can be used to, for example, conditionally mask color and\/or z writes to embedded frame buffer .","In the example embodiment, the final blended output of the last blending stage is stored in register () for color output and\/or alpha thresholding . A z-texturing path is also provided for z-texturing. See copending commonly assigned U.S. patent application Ser. No. 09\/722,378 of Leather et al. entitled \u201cZ-Texturing\u201d and its corresponding Provisional Application No. 60\/226,913, filed Aug. 23, 2000, both of which are incorporated herein by reference.","Example Input Multiplexer Configuration",{"@attributes":{"id":"p-0070","num":"0120"},"figref":["FIG. 9","FIG. 9"],"b":["656","656","656"],"i":["a ","d "],"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":{"@attributes":{"id":"ul0017-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":["the contents of register (),","the contents of register (),","the contents of register (),","the contents of register (),","texture color(s),","texture alpha(s),","constant (register) color(s),","constant (register) alpha(s),","rasterized color(s),","rasterized alpha(s),","a few useful fixed constants,","programmable constants,","texture color components copied to other texture color channels (this feature is useful for dot product, intensity calculation and color space conversion),","other inputs."]}}}},"Input controls to multiplexers  can be specified independently for each r recirculating shader stage. Multiplexer  outputs in example embodiment are unsigned 8-bit values or signed 10-bit values but other implementations could provide different precisions.","Example Blending Calculations\/Operations",{"@attributes":{"id":"p-0072","num":"0136"},"figref":"FIG. 10","b":["658","602"],"br":{},"in-line-formulae":[{},{}],"i":["R","D","\u2212C","A+C*B"],"sup":"sub"},"The arguments A, B, C and D in calculation block  in the example embodiment are selected from:\n\n","Calculation block  operates on values A, B and C in the example embodiment. The output of calculation block  is passed through an optional negate block  and is added by adder  with the output of \u201cD\u201d multiplexer (D) and an optional bias value. The resulting sum can be scaled by a scaler block  and clamped by a clamp block  before being stored in any one of registers (), (), (), () for output and\/or subsequent further blending.","In the example embodiment, scale block  can scale by 0.5, 1, 2 or 4\u2014but other implementations would provide other scaling factors. Clamping block  can support a number of different clamping modes. In one implementation, incoming values A, B, C may be unsigned 8-bit values in one implementation, incoming value D can be a signed 10-bit value, and the output of clamp block  can be a signed 10-bit value.",{"@attributes":{"id":"p-0076","num":"0146"},"figref":["FIG. 11","FIG. 10"],"b":["602","664","664","664","664","664","664","664","664","664","664","664","666"],"i":["b","c","a","d","b ","d","c ","d"]},"In the embodiment shown in , an additional comparator  is provided to compare multiplexer  outputs A and D, with the results of the comparison being used to select between multiplexer  output C and a zero value (via multiplexer ). An additional multiplexer  is provided in the data path to select between the output of sign operator  and the output of multiplexer  (i.e., the result of the comparison operation). Such comparisons can save recirculation stages by performing a blending calculation and a compare result operation all in one recirculation stage. This comparator  in the example embodiment can compare one, two or three channels simultaneously to provide 8-bit, 16-bit or 24-bit compares.","In the example embodiment shown in , scale operation  provides scaling at any of the following factors:\n\n","In the example embodiment shown in , inputs to multiplexer  may optionally be passed through \u201ccolor swap\u201d blocks  before calculation by block . Color swap block  can be used to broadcast each color component (R, G, or B) to the other two color components. See , B. This feature can be used for dot product, intensity calculation and color space conversion, for example.","The example embodiment shown in  includes support for static and programmable constants. In one embodiment, a constant select is used to select an arbitrary constant value determined by constant select registers specifying whether to use one of plural statically defined values or one of plural programmable color register values. Such programmable and fixed constants provide flexibility in the blending operation. In other embodiments, a smaller number of fixed constants (e.g., 1.0) could be used instead.","The  data path can be set up for different blending operations such as, for example, those specified in D3D of DirectX 6.0 or 7.0. In the example embodiment, seven parameters are used to program a recirculating shader  blending stage:\n\n","The following are some example blending operations:","SelectArg\n\n=(0, 0, 0, 0, 0, 0)=\n\nModulate, Modulate2\u00d7, Modulate4\u00d7\n\n=(0, 0, 0, 0, 0)=\n","The components of argument B and C are multiplied together. A scaling factor of 2 or 4 can be used for brightening:","\u2003=(0, 0, 0, 0, 1)=*2\n\n=(0, 0, 0, 0, 2)=*4\n\nAdd\n","The components of the arguments are added together:\n\n=(, 0, 0, 0, 0, 0)=\n\nAddSigned, AddSigned2\u00d7\n","The components of the arguments are added with a \u22120.5 bias, making the effective range of values from \u22120.5 to 0.5. The result can be multiplied by two for brightening:\n\n=(, 0, 0, 0, \u22120.5, 0)=\u22120.5\n\n=(, 0, 0, 0, \u22120.5, 1)=(\u22120.5)*2\n\nSubtract\n","The components of the second argument is subtracted from the first argument:\n\n=(, 0, 0, 1, \u22120, 0)=\n\nAddSmooth\n","The basic add operation is mathematically correct for glows, fog, etc. However, it can saturate abruptly causing a contouring artifact. A better looking but less mathematically correct approach is to subtract the product:\n\n=(, 0, , 0, 0, 0)=*(1)\n\nBlendDiffuseAlpha, BlendTextureAlpha, BlendFactorAlpha, BlendCurrentAlpha\n","Linear blending is performed using the alpha from: interpolated alpha from vertices (C=rasterized alpha), alpha from current texture (C=texture alpha), a constant alpha (C=constant alpha), and\/or alpha of current color (C=computed alpha):\n\n=(, 0, 0, 0, 0)=*(1)+\n\nBlendTextureAlphaPM\n","Linear blending with a pre-multiplied alpha:\n\n=(, 0, 0, 0, 0)=*(1)\n\nModulateAlpha_AddColor\n","The second argument is modulated with the first's alpha and the result is added to the first argument.\n\n=(0, 0, 0, 0)=\n\nModulateColor_AddAlpha\n","The arguments are modulated and the first argument's alpha is then added:\n\n=(0, 0, 0, 0)=\n\nModulateInvAlpha_AddColor\n","Similar to ModulateAlpha_AddColor, but it uses the inverse of the first argument's alpha:\n\n=(, 0, 0, 0, 0)=(1)*\n\nModulateInvColor_AddAlpha\n","Similar to ModulateColor_AddAlpha, but it uses the inverse of the first color:\n\n=(, 0, 0, 0, 0)=(1)*\n\nModulateInvColor_AddAlpha\n","Similar to ModulateColor_AddAlpha, but it uses the inverse of the first color:\n\n=(, 0, 0, 0, 0)=(1)*\n\nSpecular Color and Texture\n","In addition to the above operation, more complicated blending can be achieved by using multiple stages. For example:\n\nFinal Color=Specular Texture*Specular Color+Diffuse Texture*Diffuse Color\n","It can be implemented using two stages as:\n\n","This example is for embossing:\n\nFinal Color=(Diffuse Color+Constant*(Normal\u2212Normal))*Material Texture\n\nIt can be implemented using three stages as:\n\n","This example is for detail texturing. The difference textures have a bias of 0.5.\n\nFinal Color=Base Texture+(Difference Texture A\u22120.5)+(Difference Texture B=0.5)\n","It can be implemented as:\n\n","In the example embodiment, clamp block  may provide any of the following clamping modes:",{"@attributes":{"id":"p-0101","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["tev_alpha_env(mode)","clamp","description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TEV_MODE_LINEAR","TEV_CLAMP_HI","S = (R > 11023) ? 1023:(R <\u2212 1024)? \u22121024:R)"]},{"entry":[{},"TEV_CLAMP_LO","S + (R > 255) ? 255:((R < 0) ? 0:R)"]},{"entry":["TEV_MODE_GEO","TEV_CLAMP_HI","S = (R >= 0) ? 255:0"]},{"entry":[{},"TEV_CLAMP_LO","S = (R >= 0) ? 0:255"]},{"entry":[{},"TEV_CLAMP_HI","S = (R == 0) ? 255:0"]},{"entry":[{},"TEV_CLAMP_LO","S = (R == 0) ? 0:255"]},{"entry":[{},"TEV_CLAMP_HI","S = (R <= 0) ? 255:0"]},{"entry":[{},"TEV_CLAMP_LO","S = (R <= 0) ? 0:255"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The example embodiment recirculating shader  supports different alpha functions. Note that in the example embodiment, the alpha compare operation is not part of the recirculation stage, but rather, is performed after recirculation is complete. See FIG. . In the example embodiment, the alpha function compares the source alpha with a reference alpha using any one of the following operations:\n\n","The alpha functionality of recirculating shader  (e.g., in combination with the non-recirculating alpha compare) can be used to provide a transparency tree analogous to a shade tree. In particular, recirculating shader 's alpha functionality can be used to provide N logical alpha operations on M alpha inputs, where N and M can be any integers. The combination of alpha compares and alpha logical operations can be used, for example, to provide non-photorealistic effects such as cartoon outlining. See, for example, commonly assigned copending U.S. patent application Ser. No. 09\/726,212 of Law et al. entitled \u201cMethod and Apparatus For Providing Non-Photorealistic Cartoon Outlining Within A Graphics System\u201d and its corresponding provisional application, serial No. 60\/226,915, filed Aug. 23, 2000, both of which are incorporated herein by this reference.","Example Z Texturing","Shader  supports sprites with depth by modifying the screen z value using texture mapping. Once enabled, shader  sends four z values to pixel engine  per quad instead of a reference z and two slopes. Each z value is obtained by adding a z texel to the quad reference z or replacing the reference z with the z texel. See the commonly-assigned z texturing patent application referenced above.",{"@attributes":{"id":"p-0105","num":"0206"},"figref":"FIG. 13","b":["600","602","600","690","692","694","602","690","692"]},{"@attributes":{"id":"p-0106","num":"0207"},"figref":"FIG. 14"},"Example Use of Recirculating Shader for Multitexturing",{"@attributes":{"id":"p-0107","num":"0208"},"figref":"FIG. 15","b":["602","500","500","602","300","602","500"]},"In the example embodiment, recirculating shader  retains intermediate blending results for further blending with additional information provided by recirculating texture unit . Soon after recirculating texture unit  develops a final texture mapping output in a sequence of texture mapping outputs, recirculating shader  can perform a corresponding final blend operation and output the blending results via fog block for depth buffering, final color blending with frame buffer  contents, and display.",{"@attributes":{"id":"p-0109","num":"0210"},"figref":["FIG. 16","FIG. 16"],"b":["602","6","300","1002","50","500","1004","602","602","1008","602","1010","602","300","1010","1010","602"],"i":"e "},"Recirculating shader  temporarily stores the output of blend operation  as an intermediate result (block ). The entire process may then be recirculated any number of times to retrieve and blend additional sets of texture data. In the example embodiment, recirculating shader  can perform blocks ,  at the same time that texture unit  performs blocks ,  to retrieve an additional texture mapping.",{"@attributes":{"id":"p-0111","num":"0212"},"figref":["FIG. 17","FIG. 17"],"b":["602","602"]},"Because example preferred embodiment system  is a real-time rendering system, the number of times that recirculating texture unit  can recirculate is limited by the amount of time it takes for each recirculation relative to the time between image frames (e.g., 1\/30 or 1\/60 of a second). In one example embodiment, the total number of recirculations that recirculating texture unit  can perform in a single rendering pass might be eight, although different implementations might provide different numbers of recirculations. In the example embodiment, recirculating shader  can recirculate approximately twice as many times as texture unit  can recirculate. The additional recirculations provided by recirculating shader  can be used to perform a number of enhanced and interesting image effects including, for example, fog, z texturing, environment mapping, embossing, detailed texturing, and other imaging effects. The texture input to recirculating shader  are preferably set to null during stages where texture unit  cannot make a texture available.",{"@attributes":{"id":"p-0113","num":"0214"},"figref":"FIG. 18","b":["602","110","214","300","300","500","400","504","602"]},"Example Register Interface",{"@attributes":{"id":"p-0114","num":"0215"},"figref":"FIG. 19","b":"19","chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"160.87mm","wi":"112.52mm","file":"US07034828-20060425-C00001.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},{"@attributes":{"id":"p-0115","num":"0216"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"217pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["register","name","format","description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["gen_mode","ntev","4","Specifies the current texture stage count (1-16)."]},{"entry":["tev_color_env_i","dest","2","Specifies the destination register."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_CDEST_CCO","Color Register 0"]},{"entry":[{},"1","TEV_CDEST_CC1","Color Register 1"]},{"entry":[{},"2","TEV_CDEST_CC2","Color Register 2"]},{"entry":[{},"3","TEV_CDEST_CC3","Color Register 3"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"shift","2","When in analog blend mode, this field specifies the amount to shift"]},{"entry":[{},{},{},"the output:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SHIFT_O","No shift."]},{"entry":[{},"1","TEV_SHIFT_1","Shift left by 1."]},{"entry":[{},"2","TEV_SHIFT_2","Shift left by 2."]},{"entry":[{},"3","TEV_SHIFT_R","Shift right by 1."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"When in compare mode (bias=3, revB only), the field specifies the"]},{"entry":[{},"size and component select for the compare:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SHIFT_R8","Compare red channels only."]},{"entry":[{},"1","TEV_SHIFT_RG16","Compare red\/green channels as"]},{"entry":[{},{},{},"16 bit values."]},{"entry":[{},"2","TEV_SHIFT_RGB24","Compare red\/green\/blue"]},{"entry":[{},{},{},"channels as 24 bit values"]},{"entry":[{},"3","TEV_SHIFT_RGB8","Compare red, green and blue"]},{"entry":[{},{},{},"channels separately"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"clamp","1","Specifies the clamping operation (see Section 9)."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_CLAMP_HI","Clamp to \u22121024, +1023"]},{"entry":[{},"1","TEV_CLAMP_LO","Clamp to 0.255"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sub","1","When in analog blend mode, this field specifies add or subtract of"]},{"entry":[{},{},{},"the blend result:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SUB_ADD","output = d + (1\u2212c)*a + c*b + bias"]},{"entry":[{},"1","TEV_SUB_SUB","output = d \u2212 (1\u2212c)*a \u2212 c*b + bias"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"When in compare mode (bias=3, revB only), the field specifies the"]},{"entry":[{},"size and component select for the compare:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SUB_GT","output = d + ((a>b)?c:0)"]},{"entry":[{},"1","TEV_SUB_EQ","output = d + ((a==b)?c:0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bias","2","Specifies the value of bias."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SHIFT_R8","Compare red channels only."]},{"entry":[{},"1","TEV_SHIFT_RG16","Compare red\/green channels as"]},{"entry":[{},{},{},"16 bit values."]},{"entry":[{},"2","TEV_SHIFT_RGB24","Compare red\/green\/blue"]},{"entry":[{},{},{},"channels as 24 bit values"]},{"entry":[{},"3","TEV_SHIFT_RGB8","Compare red, green and blue"]},{"entry":[{},{},{},"channels separately"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"clamp","1","Specifies the clamping operation (see Section 9)."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_CLAMP_HI","Clamp to \u22121024, +1023"]},{"entry":[{},"1","TEV_CLAMP_LO","Clamp to 0.255"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sub","1","Specifies add or subtract of the blend result."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SUB_ADD","Add blend result."]},{"entry":[{},"1","TEV_CLAMP_SUB","Subtract blend result."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"When in compare mode (bias=3, revB only), this field specifies the"]},{"entry":[{},"compare function:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SUB_GT","output = d + ((a>b)?c:0)"]},{"entry":[{},"1","TEV_SUB_EQ","output = d + ((a==b)?c:0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"bias","2","Specifies the value of bias."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_BIAS_ZERO","0"]},{"entry":[{},"1","TEV_BIAS_PLUS","+0.5"]},{"entry":[{},"2","TEV_BIAS_MINUS","\u22120.5"]},{"entry":[{},"3","TEV_BIAS_COMPARE","Select \u201ccompare\u201d mode for"]},{"entry":[{},{},{},"blender. (revB only)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sela","3","Specifies argument A:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_ASEL_A_CA0","Register 0 alpha."]},{"entry":[{},"1","TEV_ASEL_A_CA1","Register 1 alpha."]},{"entry":[{},"2","TEV_ASEL_A_CA2","Register 2 alpha."]},{"entry":[{},"3","TEV_ASEL_A_CA3","Register 3 alpha."]},{"entry":[{},"4","TEV_ASEL_A_TXA","Texture alpha."]},{"entry":[{},"5","TEV_ASEL_A_RSA","Rasterized alpha."]},{"entry":[{},"6","TEV_ASEL_A_KK","Constant Color (see kasel)"]},{"entry":[{},"7","TEV_ASEL_A_K00","0.0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"selb","3","Specifies argument B. selb is similar to sela."]},{"entry":[{},"selc","3","Specifies argument C. selc is similar to sela."]},{"entry":[{},"seld","3","Specifies argument D. seld is similar to sela."]},{"entry":[{},"tsel,","2","Specifies the texture color swapping mode."]},{"entry":[{},"(revA)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_BIAS_ZERO","0"]},{"entry":[{},"1","TEV_BIAS_PLUS","+0.5"]},{"entry":[{},"2","TEV_BIAS_MINUS","\u22120.5"]},{"entry":[{},"3","TEV_BIAS_COMPARE","Select \u201ccompare\u201d mode for"]},{"entry":[{},{},{},"blender. (revB only)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sela","4","Specifies argument A."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_CSEL_CC0","Register 0 color."]},{"entry":[{},"1","TEV_CSEL_CA0","Register 0 alpha."]},{"entry":[{},"2","TEV_CSEL_CC1","Register 1 color."]},{"entry":[{},"3","TEV_CSEL_CA1","Register 1 alpha."]},{"entry":[{},"4","TEV_CSEL_CC2","Register 2 color."]},{"entry":[{},"5","TEV_CSEL_CA2","Register 2 alpha."]},{"entry":[{},"6","TEV_CSEL_CC3","Register 3 color."]},{"entry":[{},"7","TEV_CSEL_CA3","Register 3 alpha."]},{"entry":[{},"8","TEV_CSEL_TXC","Texture color."]},{"entry":[{},"9","TEV_CSEL_TXA","Texture alpha."]},{"entry":[{},"A","TEV_CSEL_RSC","Rasterized color."]},{"entry":[{},"B","TEV_CSEL_RSA","Rasterized alpha."]},{"entry":[{},"C","REVA: TEV_CSEL_K10","1.0"]},{"entry":[{},{},"REVB: TEV_CSEL-KK","Constant Color (see kcsel)"]},{"entry":[{},"D","TEV_CSEL_K05","0.5"]},{"entry":[{},"E","TEV_CSEL_K25","0.25"]},{"entry":[{},"F","TEV_CSEL_K00","0.0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"selb","4","Specifies argument B. selb is similar to sela"]},{"entry":[{},"selc","4","Specifies argument C. selc is similar to sela."]},{"entry":[{},"seld","4","Specifies argument D. seld is similar to sela."]},{"entry":["tev_alpha_env_i","dest","2","Specifies the destination register."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_ADEST_CA0","Color Register 0"]},{"entry":[{},"1","TEV_ADEST_CA1","Color Register 1"]},{"entry":[{},"2","TEV_ADEST_CA2","Color Register 2"]},{"entry":[{},"3","TEV_ADEST_CA3","Color Register 3"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"shift","2","Specifies the amount to shift."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SHIFT_0","No shift."]},{"entry":[{},"1","TEV_SHIFT_1","Shift left by 1."]},{"entry":[{},"2","TEV_SHIFT_2","Shift left by 2."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"When in compare mode (bias=3, revB only), the field specifies the"]},{"entry":[{},"size and component select for the compare:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_SWAP_0","RGBA => RGBA"]},{"entry":[{},"1","TEV_SWAP_R","RGBA => RRRA"]},{"entry":[{},"2","TEV_SWAP_G","RGB1 => GGGA"]},{"entry":[{},"3","TEV_SWAP_B","RGBA => BBBA"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mode","2","Specifies the clamping mode (see Section 9). Rev. A. only!"]},{"entry":[{},"(revA)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_MODE_LINEAR","Linear clamping."]},{"entry":[{},"1","TEV_MODE_GE0","Greater than ore equal to 0."]},{"entry":[{},"2","TEV_MODE_EQ0","Equal to 0."]},{"entry":[{},"3","TEV_MODE_LE0","Less than or equal to 0."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"tsel,","2","Specifies the texture and raster color swapping mode."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rsel","0","TEV_SWAP_0","Use swap mode 0"]},{"entry":[{},"(revB)","1","TEV_SWAP_R","Use swap mode 1"]},{"entry":[{},{},"2","TEV_SWAP_G","Use swap mode 2"]},{"entry":[{},{},"3","TEV_SWAP_B","Use swap mode 3"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["tev_registerl_i","r, a","s2.8","Specifies the value of the texture current color."]},{"entry":["tev_registerh_i","g, b","s2.8","Specifies the value of the texture current color."]},{"entry":["tev_kregisterl_i","kr, ka","0.8","Specifies the value of the constant color. This feature only applies"]},{"entry":[{},{},{},"to rev B."]},{"entry":["tev_kregisterh_i","kg, kb","0.8","Specifies the value of the constant color. This feature only applies"]},{"entry":[{},{},{},"to rev"]},{"entry":["tev_range_adj_c","center","10","Specifies the screen's x center for range adjustment."]},{"entry":[{},"enb","1","Enable range adjustment"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_ENB_DISABLE","Disable range adjustment."]},{"entry":[{},"1","TEV_ENB_ENABLE","Enable range adjustment."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["rev_range_adj_k","r2k,","u4.8","Specifies the range adjustment function."]},{"entry":[{},"r2k+l",{},{"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"adj","mo":"=","mfrac":{"msqrt":{"mrow":{"msup":[{"mi":"x","mn":"2"},{"mi":"k","mn":"2"}],"mo":"+"}},"mi":"k"}}}}}]},{"entry":["tev_fog_param_0","a","s11e8","Specifies the \u201ca\u201d parameter of the screen to eye space conversion"]},{"entry":[{},{},{},"function:"]},{"entry":[{},{},{},{"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["Z","e"]},"mo":"=","mfrac":{"mi":"a","mrow":{"mi":"b","mo":"-","msub":{"mi":["Z","s"]}}}}}}}]},{"entry":["tev_fog_param_1","b_mag","u0.24","Specifies the \u201cb\u201d parameter of the z screen to eye space conversion"]},{"entry":[{},{},{},"function:"]},{"entry":[{},{},{},{"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["Z","e"]},"mo":"=","mfrac":{"mi":"a","mrow":{"mi":"b_mag","mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":["zs","b_shf"],"mo":">>"}}}}}}}}]},{"entry":["tev_fog_param_2","b_shf","5","Specifies the amount to pre-shift screen z. This is equivalent to the"]},{"entry":[{},{},{},"value of \u201cb\u201d parameter's exponent +1."]},{"entry":["tev_fog_param_3","fsel","3","Specifies the fog type as follows:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_FSEL_OFF","No Fog."]},{"entry":[{},"1","reserved"]},{"entry":[{},"2","TEV_FSEL_LIN","Exponential Fog"]},{"entry":[{},"3","reserved"]},{"entry":[{},"4","TEV_FSEL_EXP","Exponential Fog"]},{"entry":[{},"5","TEV_FSEL_EX2","Exponential Squared Fog"]},{"entry":[{},"6","TEV_FSEL_BXP","Backward Exp Fog"]},{"entry":[{},"7","TEV_FSEL_BX2","Backward Exp Squared Fog"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"proj","1","Specifies whether we have a perspective or orthographic"]},{"entry":[{},{},{},"projection."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_FOG_PERSP","Perspective projection"]},{"entry":[{},"1","TEV_FOG_ORTHO","Orthographic projection"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"c","s11e8","Specifies the amount to subtract from eye-space Z after range"]},{"entry":[{},{},{},"adjustment."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["tev_fog_color","r, g, b","8","Specifies the value of fog color."]},{"entry":["tev_alphafunc","op0","3","Specifies under what condition the alpha 0 for a pixel is to be"]},{"entry":[{},{},{},"forced to 1."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_AOP_NEVER","Never"]},{"entry":[{},"1","TEV_AOP_LESS","Alpha < AF_VAL"]},{"entry":[{},"2","TEV_AOP_EQUAL","Alpha = AF_VAL"]},{"entry":[{},"3","TEV_AOP_LE","Alpha <= AF_VAL"]},{"entry":[{},"4","TEV_AOP_GREATER","Alpha > AF_VAL"]},{"entry":[{},"5","TEV_AOP_NOTEQUAL","Alpha != AF_VAL"]},{"entry":[{},"6","TEV_AOP_GE","Alpha >= AF_VAL"]},{"entry":[{},"7","TEV_AOP_ALWAYS","Always"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"op1","3","Specifies alpha operation 1. Similar to op0."]},{"entry":[{},"logic","2","Specifies the logic operation in combining the two alpha"]},{"entry":[{},{},{},"comparison."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_LOGIC_AND","AND"]},{"entry":[{},"1","TEV_LOGIC_OR","OR"]},{"entry":[{},"2","TEV_LOGIC_XOR","XOR"]},{"entry":[{},"3","TEV_LOGIC_XNOR","XNOR"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"a0","8","Reference alpha 0."]},{"entry":[{},"a1","8","Reference alpha 1."]},{"entry":["tev_env_z_0","zoff","u24.0","Specifies the z bias used in a z texture."]},{"entry":["tev_env_z_1","type","2","Specifies the z texel type."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_Z_TYPE_U8","u8.0"]},{"entry":[{},"1","TEV_Z_TYPE_U16","u16.0"]},{"entry":[{},"2","TEV_Z_TYPE_U24","u24.0"]},{"entry":[{},"3","reserved"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"op","2","Enables z texturing."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_Z_OP_OFF","Disable"]},{"entry":[{},"1","TEV_Z_OP_ADD","Add"]},{"entry":[{},"2","TEV_Z_OP_REP","Replace"]},{"entry":[{},"3","reserved"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["tev_ksel_i","kcsel,","5","Selects constant color\/scalar for each of 16 states. This feature"]},{"entry":["(RevB)","kasel",{},"only applies to rev B."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","TEV_KSEL_1","1.0",{},{}]},{"entry":[{},"1","TEV_KSEL_7_8","0.875"]},{"entry":[{},"2","TEV_KSEL_3_4","0.75"]},{"entry":[{},"3","TEV_KSEL_5_8","0.625"]},{"entry":[{},"4","TEV_KSEL_1_2","0.5"]},{"entry":[{},"5","TEV_KSEL_3_8","0.375"]},{"entry":[{},"6","TEV_KSEL_1_4",".025"]},{"entry":[{},"7","TEV_KSEL_1_8","0.125"]},{"entry":[{},"8"]},{"entry":[{},"9"]},{"entry":[{},"10"]},{"entry":[{},"11"]},{"entry":[{},"12","TEV_KSEL_K0","Constant Color 0 (rgb)"]},{"entry":[{},"13","TEV_KSEL_K1","Constant Color 1 (rgb)"]},{"entry":[{},"14","TEV_KSEL_K2","Constant Color 2 (rgb)",{}," kcsel only"]},{"entry":[{},"15","TEV_KSEL_K3","Constant Color 3 (rgb)"]},{"entry":[{},"16","TEV_KSEL_K0_R","Constant Color 0 (r)"]},{"entry":[{},"17","TEV_KSEL_K1_R","Constant Color 1 (r)"]},{"entry":[{},"18","TEV_KSEL_K2_R","Constant Color 2 (r)"]},{"entry":[{},"19","TEV_KSEL_K3_R","Constant Color 3 (r)"]},{"entry":[{},"20","TEV_KSEL_K0_R","Constant Color 0 (g)"]},{"entry":[{},"21","TEV_KSEL_K1_G","Constant Color 1 (g)"]},{"entry":[{},"22","TEV_KSEL_K2_G","Constant Color 2 (g)"]},{"entry":[{},"23","TEV_KSEL_K3_G","Constant Color 3 (g)"]},{"entry":[{},"24","TEV_KSEL_K0_B","Constant Color 0 (b)"]},{"entry":[{},"25","TEV_KSEL_K1_B","Constant Color 1 (b)"]},{"entry":[{},"26","TEV_KSEL_K2_B","Constant Color 2 (b)"]},{"entry":[{},"27","TEV_KSEL_K3_B","Constant Color 3 (b)"]},{"entry":[{},"28","TEV_KSEL_K0_A","Constant Color 0 (a)"]},{"entry":[{},"29","TEV_KSEL_K1_A","Constant Color 1 (a)"]},{"entry":[{},"30","TEV_KSEL_K2_A","Constant Color 2 (a)"]},{"entry":[{},"31","TEV_KSEL_K3_A","Constant Color 3 (a)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"xr, xg,","Specifies one of four swap modes. During each stage, \u201ctsel\u201d"]},{"entry":[{},"xb, xa","selects the swap mode for texture and \u201crsel\u201d selects the swap"]},{"entry":[{},{},"mode for the rasterization color:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"red","green","blue","alpha",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"xr",{},"xg",{},"xb",{},"xa",{}]},{"entry":[{},"0 0","red","0 0","red","0 0","red","0 0","red"]},{"entry":[{},"0 1","green","0 1","green","0 1","green","0 1","green"]},{"entry":[{},"1 0","blue","1 0","blue","1 0","blue","1 0","blue"]},{"entry":[{},"1 1","alpha","1 1","alpha","1 1","alpha","1 1","alpha"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"On reset, these values get initialized as follows (for revA"]},{"entry":[{},"compatibility):"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"xr","xg","xb","xa",{}]},{"entry":[{},"Swap Mode 0","0 0","0 1","1 0","1 1"]},{"entry":[{},"Swap Mode 1","0 0","0 0","0 0","1 1"]},{"entry":[{},"Swap Mode 2","0 1","0 1","0 1","1 1"]},{"entry":[{},"Swap Mode 3","1 0","1 0","1 0","1 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}}]}}},"The following are example application programming interface calls:","GXSetTevOp","Description: This is a convenience function designed to make initial programming of the Texture Environment unit easier. This macro calls GXSetTevColorIn, GXSetTevColorOp, GXSetTevAlphaIn, and GXSetTevAlphaOp with predefined arguments to implement familiar texture combining functions.","To enable a consecutive set of recirculating shader stages, the application should call the GXSetNumTevStages function.","In the table below, Cv is the output color for the stage, Cr is the output color of previous stage, and Ct is the texture color. Av is the output alpha for a stage, Ar is the output alpha of previous stage, and At is the texture alpha. As a special case, rasterized color (GX_CC_RASC) is used as Cr and rasterized alpha (GX_CA_RASA) is used as Ar at the first recirculating shader stage because there is no previous stage.",{"@attributes":{"id":"p-0120","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Mode","Color Op","Alpha Op"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"GX_MODULATE","Cv = CrCt","Av = ArAt"]},{"entry":[{},"GX_DECAL","Cv = (1 \u2212 At)Cr + AtCt","Av = Ar"]},{"entry":[{},"GX_REPLACE","Cv = Ct","Av = At"]},{"entry":[{},"GX_BLEND","Cv = (1 \u2212 Ct)Cr + Ct","Av = AtAr"]},{"entry":[{},"GX_PASSCLR","Cv = Cr","Av = Ar"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0033","list-style":"none"},"li":["Example usage:","void GXSetTevOp(GXTevStageID id, GXTevMode mode);\n\nGXTevStageID\n"]}},"Enumerated Values\n\n","Texture Environment (Recirculating shader) stage name.","GXTevMode","Enumerated Values:","GX_DECAL\n\n","This function enables a consecutive number of Texture Environment (recirculating shader) stages. The output pixel color (before fogging and blending) is the result from the last stage. The last recirculating shader stage must write to register GX_TEVPREV, see GXSetTevColorOp and GXSetTevAlphaOp. At least one recirculating shader stage should be enabled. If a Z-texture is enabled, the Z texture is looked up on the last stage, see GXSetZTexture.","The association of lighting colors, texture coordinates, and texture maps with a recirculating shader stage is set using GXSetTevOrder. The number of texture coordinates available is set using GXSetNumTexGens. The number of color channels available is set using GXSetNumChans.","GXInit will set nStages to 1 as a default.\n\n","This function sets the input operands of the Texture Environment (recirculating shader) color combiner unit. The input operands a, b, and c are RGB colors where each component is unsigned 8-bit (0<=a,b,c<=255). The d input operand is an RGB color where each component is a signed 10-bit input (\u22121024<=d<=1023).","In the cases where the input operand is an alpha value (GX_CC_A, GX_CC_A, GX_CC_A, GX_CC_APREV, GX_CC_TEXA, GX_CC_RASA), the alpha value is replicated across the three color channels (R=A, G=A, B=A).","The function implemented by this recirculating shader stage is set using the function GXSetTevColorOp.","The output of this stage is directed by default to register GX_TEVPREV (see GXInit), but may be set explicitly by GXSetTevColorOp.","The registers used to store the output of Recirculating shader stages can also be used as inputs, GX_CC_C, GX_CC_C, GX_CC_C, GX_CC_CPREV. You can program these registers with constant color values using GXSetTevColor or GXSetTevColorS.","Each register can store either an unsigned 8-bit number or a signed 10-bit number per component (RGB). If a signed 10-bit number is selected for inputs a, b, or c, the number is truncated to 8 bits. No attempt is made to convert the number, the most significant bits are simply discarded.","The input operands GX_CC_RASC and GX_CC_RASA are the result of the per-vertex lighting equations. The input operands GX_CC_TEXC and GX_CC_TEXA are the texture inputs for this stage. The texture color input GX_CC_TEXC, may have its color components swapped before input by setting operands GX_TC_TEXRRR, GX_TEXGGG or GX_TC_TEXBBB. You can select one of the swap operands per Recirculating shader stage. In an example embodiment, it is illegal to use both GX_TC_TEXRRR and GX_TC_GGG in the same stage.","GXSetTevOrder associates a shader stage with particular colors and textures.",{"@attributes":{"id":"p-0136","num":"0263"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Arguments"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["stage","Name of the Recirculating shader stage."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["a","Input color operand, unsigned 8b per component."]},{"entry":["b","Input color operand, unsigned 8b per component."]},{"entry":["c","Input color operand, unsigned 8b per component."]},{"entry":["d","Input color operand, signed 10b per component."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":["Example usage:","void GXSetTevColorIn(\n    \n    "]}},"This function sets the input operands for one stage of the Texture Environment (recirculating shader) alpha combiner unit. The input operands a, b, and c are unsigned 8-bit inputs (0<=a,b,c<=255). The d input operand is a signed 10-bit input (\u22121024<=d<=1023).","Each shader stage implements the following function:\n\nreg=((op)((1.0)*)+bias)*scale;\n","The operations described by op, bias, and scale are programmable using the GXSetTevAlphaOp function.","The output of this stage is directed by default to register GX_TEVPASS (see GXInit), but may be set explicitly by GXSetTevAlphaOp. The result can be clamped to two ranges, 0 to 255 or \u22121024 to 1023, based on the clamp mode set by","GXSetTevClampMode. When the input a, b, or c is from a signed 10-bit number (either the results of a previous recirculating shader stage or an input constant) only the 8 least-significant bits are used. There is no attempt to convert the number, the upper bits are simply discarded.","The registers used to store the output of Recirculating shader stages can also be used as inputs, GX_CA_A, GX_CA_A, GX_CA_A, GX_CA_APREV. You can program these registers with constant alpha values using GXSetTevColor or GXSetTevColorS.","The input operand GX_CA_RASA is the result of the per-vertex lighting equations. The input operand GX_CA_TEXA is the texture alpha input for this stage. You can select the colors and textures to which these inputs correspond using GXSetTevOrder.",{"@attributes":{"id":"p-0144","num":"0278"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Arguments"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["stage","The name of the stage."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["a","Input operand, u8."]},{"entry":["b","Input operand, u8."]},{"entry":["c","Input operand, u8"]},{"entry":["d","Input operand, s10."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"ul":{"@attributes":{"id":"ul0041","list-style":"none"},"li":["Example usage:","void GXSetTevAlphaIn(\n    \n    "]}},"This function sets the op, scale, bias, and clamping operation for the color combiner function for this stage of the Texture Environment (recirculating shader) unit. This function also specifies the output register, out_reg, that will contain the result of the color combiner function. The color combiner function is:\n\nout_reg=((op)((1.0)*)+bias)*scale;\n","The input parameters a, b, c, and d are selected using the GXSetTevColorIn function. The a, b, and c inputs are unsigned inputs (0<=a,b,c<=255). The d input is a signed input (\u22121024<=d<=1023). The result, out_reg, can also be a signed result, depending on the clamp enable and the current clamping mode, see GXSetTevClampMode.","The recirculating shader output registers are shared among all the recirculating shader stages. The recirculating shader output registers can also be used as constant color inputs, so the application should be careful to allocate input and output registers so no collision occurs when implementing a particular equation. The application must output to GX_TEVPREV in the last active recirculating shader stage.","The function GXSetTevOp provides a simpler way to set the parameters of GXSetTevColorIn and GXSetTevColorOp based on predefined equation names. You should not mix usage of GXSetTevOp and GXSetTevColorIn\/GXSetTevColorOp.","GXSetTevOp makes some assumptions about the output register usage, namely that GX_TEVPREV is always the output register and is used to pass the result of the previous recirculating shader stage to the next recirculating shader stage.",{"@attributes":{"id":"p-0150","num":"0291"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Arguments"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"stage","Recirculating shader stage name."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"op","Recirculating shader operation."]},{"entry":[{},"add_bias","Bias value."]},{"entry":[{},"scale","Scale value."]},{"entry":[{},"clamp","Clamp results when GX_TRUE"]},{"entry":[{},"out_reg","Output register name. The last active"]},{"entry":[{},{},"Recirculating shader stage writes to"]},{"entry":[{},{},"GX_TEVPREV."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":["Example usage:","void GXSetTevColorOp(\n    \n    "]}},"This function sets the op, scale, bias, and clamping operation for the alpha combiner function for this stage of the Texture Environment (recirculating shader) unit. This function also specifies the register, out_reg, that will contain the result of the alpha combiner function. The alpha combiner function is:\n\nout_reg=((op)((1.0)*)+bias)*scale;\n","The input parameters a, b, c, and d are set using GXSetTevAlphaIn. The a, b, and c inputs are unsigned inputs (0<=a,b,c<=255). The d input is a signed input (\u22121024<=d<=1023). The result, out_reg, can also be a signed result, depending on the clamp enable and the current clamping mode, see GXSetTevClampMode.","You must enable a consecutive number of recirculating shader stages using GXSetTevStages. The last active recirculating shader stage writes its output to register GX_TEVPREV.",{"@attributes":{"id":"p-0154","num":"0303"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Arguments"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"The name of the recirculating shader"]},{"entry":[{},"stage","stage."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"op","recirculating shader operation."]},{"entry":[{},"bias","Bias value."]},{"entry":[{},"scale","Scale value."]},{"entry":[{},"clamp","Clamp results when GX_TRUE."]},{"entry":[{},"out_reg","Output register name."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":["Example usage:","void GXSetTevAlphaOp(\n    \n    "]}},"This function is used to set one of the constant color registers in the Texture Environment (recirculating shader) unit. These registers are available to all recirculating shader stages. At least one of these registers is used to pass the output of one recirculating shader stage to the next in a multi-texture configuration. The application is responsible for allocating these registers so that no collisions in usage occur.","This function can set unsigned 8-bit colors. To set signed, 10-bit colors use GXSetTexColorS.","Arguments",{"@attributes":{"id":"p-0157","num":"0000"},"ul":{"@attributes":{"id":"ul0047","list-style":"none"},"li":["id=Color register id.","color=Constant color value.","Example usage: void GXSetTevColor(GXTevRegID id, GXColor color);\n\nGXSetTevColorS\n\nDescription\n"]}},"This function is used to set one of the constant color registers in the Texture Environment (recirculating shader) unit. These registers are available to all recirculating shader stages. At least one of these registers is used to pass the output of one recirculating shader stage to the next in a multi-texture configuration. The application is responsible for allocating these registers so that no collisions in usage occur.","This function enables the color components to be signed 10-bit numbers. To set 8-bit unsigned colors (the common case) use GXSetTevColor.","Arguments",{"@attributes":{"id":"p-0160","num":"0000"},"ul":{"@attributes":{"id":"ul0048","list-style":"none"},"li":["id=Color register id.","color=Constant color value. Each color component can have the range \u22121024 to +1023.","Example usage: void GXSetTevColorS(GXTevRegID id, GXColorS color);\n\nGXSetTevClampMode\n\nDescription\n"]}},"This function sets the clamp mode for this stage in the Texture Environment (recirculating shader) unit. This mode is used for both alpha and color combiners. The mode effects how the clamp controls set by GXSetTevColorOp and GXSetTevAlphaOp are interpreted as shown in the table below. R is the TEV stage result color.",{"@attributes":{"id":"p-0162","num":"0323"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GXInit sets mode to GX_TC_LINEAR."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"clamp -",{}]},{"entry":["mode - shared","independent",{}]},{"entry":["for alpha and","for alpha",{}]},{"entry":["color TEV","and color TEV","description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["GX_TC_LINEAR","GX_FALSE","clamp such that \u22121024 <= R"]},{"entry":[{},{},"<= 1023"]},{"entry":[{},"GX_TRUE","clamp such that 0 <= R"]},{"entry":[{},{},"<= 255"]},{"entry":["GX_TC_GE","GX_FALSE","output = (R >= 0) ? 255:0"]},{"entry":[{},"GX_TRUE","output = (R >= 0) ? 0:255"]},{"entry":["GX_TC_EQ","GX_FALSE","output = (R == 0) ? 255:0"]},{"entry":[{},"GX_TRUE","output = (R == 0) ? 0:255"]},{"entry":["GX_TC_LE","GX_FALSE","output = (R <= 0) ? 255:0"]},{"entry":[{},"GX_TRUE","output = (R <= 0) ? 0:255"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":"stage = Tev stage ID. "},{"entry":"mode = Clamp mode (Accepted values are GX_TC_LINEAR, GX_TC_GE, GX_TC_LE, GX_TC_EQ). "}]}}]}},"ul":{"@attributes":{"id":"ul0049","list-style":"none"},"li":["Example usage:","void GXSetTevClampMode(\n    \n    "]}},"This function sets the parameters for the alpha compare function which uses the alpha output from the last active Texture Environment (recirculating shader) stage. The number of active recirculating shader stages are specified using GXSetTevStages.","The output alpha can be used in the blending equation (see GXSetBlendMode) to control how source and destination (frame buffer) pixels are combined.","The alpha compare operation is:\n\nalpha_pass=(alpha_src (comp) ref)(op)(alpha_src (comp) ref)\n\nwhere alpha_src is the alpha from the last active Recirculating shader stage. As an example, you can implement these equations:\n\nalpha_pass=(alpha_src>ref) AND (alpha_src<ref)\n\nor\n\nalpha_pass=(alpha_src>ref) OR (alpha_src<ref)\n","The Z compare can occur either before or after texturing, see GXSetZCompLoc. in the case where Z compare occurs before texturing, the Z is written based only on the Z test. The color is written if both the Z test and alpha test pass.","When Z compare occurs after texturing, the color and Z are written if both the Z test and alpha test pass. When using texture to make cutout shapes (like billboard trees) that need to be correctly Z buffered, you should configure the pipeline to Z buffer after texturing.","Arguments",{"@attributes":{"id":"p-0168","num":"0000"},"ul":{"@attributes":{"id":"ul0051","list-style":"none"},"li":["comp=Comparison subfunction .","ref=Reference value for subfunction , 8-bit.","op=Operation for combining subfunction and subfunction. Accepted values are: GX_AOP_AND, GX_AOP_OR, GX_AOP XOR, GX_AOP_XNOR.","comp=Comparison subfunction .","ref=Reference value for subfunction , 8-bit.","Example usage:","void GXSetAlphaCompare(\n    \n    "]}},"This function specifies the texture and rasterized color that will be available as inputs to this Texture Environment (recirculating shader) stage. The texture coordinate coord is generated from input attributes using the GXSetTexCoordGen function, and is used to look up the texture map, previously loaded by GXLoadTexObj. The color to rasterize for this stage is also specified. The color is the result of per-vertex lighting which is controlled by the GXSetChanCtrl function.","Note that this function does not enable the recirculating shader stage. To enable a consecutive number of Recirculating shader stages, starting at stage GX_TEVSTAGE, use the GXSetNumTevStages function.","The operation of each recirculating shader stage is independent. The color operations are controlled by GXSetTevColorIn and GXSetTevColorOp. The alpha operations are controlled by GXSetTevAlphaIn and GXSetTevAlphaOp.","The number of texture coordinates available for all the active recirculating shader stages is set using GXSetNumTexGens. The number of color channels available for all the active recirculating shader stages is set using GXSetNumChans. Active recirculating shader stages should not reference more texture coordinates or colors than are being generated.","Using GXSetTevOrder, it is possible to broadcast a single texture coordinate to many textures as long as the textures are the same size:\n\n","You may also use any generated texture coordinate in any recirculating shader stage:\n\n","If no texture is used in a recirculating shader stage, set coord and map to NULL:\n\n","If no color is used in a recirculating shader stage, set color to NULL:\n\n","GXSetTevOrder will scale the normalized texture coordinates produced by GXSetTexCoordGen according to the size of the texture map in the function call. For this reason, texture coordinates can only be broadcast to multiple texture maps if and only if the maps are the same size. In some case, you may want to generate a texture coordinate having a certain scale, but disable the texture lookup (this comes up when generating texture coordinates for indirect bump mapping). To accomplish this, use the GX_TEXMAP_DISABLE flag:\n\n","This will scale GX_TEXCOOR using GX_TEXMAP but disable the lookup of GX_TEXMAP.","GXInit describes the default recirculating shader order.","Arguments",{"@attributes":{"id":"p-0180","num":"0000"},"ul":{"@attributes":{"id":"ul0058","list-style":"none"},"li":["stage=Recirculating shader stage ID.","coord=Texture coordinate ID.","map=Texture Map ID.","color=Color channel. Accepted values are: GX_COLORA, GX_COLORA and GX_COLOR_NULL.","Example usage:\n    \n    "]}},{"@attributes":{"id":"p-0181","num":"0000"},"ul":{"@attributes":{"id":"ul0061","list-style":"none"},"li":["This page shows some samples of the Texture Environment (TEV) settings.","One Rasterized Color","e.g. Polygons with vertex colors","e.g. Vertex lighting","This configuration passes rasterized color channel directly by using PASSCLR operation. No texture is used.","\/\/ One Rasterized Color","\/\/ The channel COLORA is supposed to have lit color.","GXSetNumTevStages();","GXSetTevOrder(\n    \n    ","GXSetTevOp(GX_TEVSTAGE, GX_PASSCLR);","One Texture","e.g. Simple texture mapping"]}},"This configuration is used for displaying the texture color directly. No rasterized color can be used.\n\n","This configuration uses the DECAL operation. The texture should contain alpha value which will be used for blending.\n\n","This configuration uses neither the output from lighting unit or any texture.\n\n","No texture is used. The first stage passes the first rasterized color by using PASSCLR operation. The second stage adds two colors where a detailed setting is required.\n\n","If the specular color is allowed to be white only, you may use alpha channel for specular lit color which will be broadcasted to each RGB component on a TEV stage. Since it requires only one stage, we can obtain better fill-rate than using two channels. This method can be used if the alpha is not reserved for another purpose.\n\n","Certain of the above-described system components  could be implemented as other than the home video game console configuration described above. For example, one could run graphics application or other software written for system  on a platform with a different configuration that emulates system  or is otherwise compatible with it. If the other platform can successfully emulate, simulate and\/or provide some or all of the hardware and software resources of system , then the other platform will be able to successfully execute the software.","As one example, an emulator may provide a hardware and\/or software configuration (platform) that is different from the hardware and\/or software configuration (platform) of system . The emulator system might include software and\/or hardware components that emulate or simulate some or all of hardware and\/or software components of the system for which the application software was written. For example, the emulator system could comprise a general purpose digital computer such as a personal computer, which executes a software emulator program that simulates the hardware and\/or firmware of system .","Some general purpose digital computers (e.g., IBM or Macintosh personal computers and compatibles) are now equipped with 3D graphics cards that provide 3D graphics pipelines compliant with DirectX or other standard 3D graphics command APIs. They may also be equipped with stereophonic sound cards that provide high quality stereophonic sound based on a standard set of sound commands. Such multimedia-hardware-equipped personal computers running emulator software may have sufficient performance to approximate the graphics and sound performance of system . Emulator software controls the hardware resources on the personal computer platform to simulate the processing, 3D graphics, sound, peripheral and other capabilities of the home video game console platform for which the game programmer wrote the game software.",{"@attributes":{"id":"p-0190","num":"0519"},"figref":"FIG. 20A","b":["1201","1303","62","1201","1303","1201","62","1201","1303","50","62","1201"]},"As one example, in the case where the software is written for execution on a platform using an IBM PowerPC or other specific processor and the host  is a personal computer using a different (e.g., Intel) processor, emulator  fetches one or a sequence of binary-image program instructions from storage medium  and converts these program instructions to one or more equivalent Intel binary-image program instructions. The emulator  also fetches and\/or generates graphics commands and audio commands intended for processing by the graphics and audio processor , and converts these commands into a format or formats that can be processed by hardware and\/or software graphics and audio processing resources available on host . As one example, emulator  may convert these commands into commands that can be processed by specific graphics and\/or or sound hardware of the host  (e.g., using standard DirectX, OpenGL and\/or sound APIs).","An emulator  used to provide some or all of the features of the video game system described above may also be provided with a graphic user interface (GUI) that simplifies or automates the selection of various options and screen modes for games run using the emulator. In one example, such an emulator  may further include enhanced functionality as compared with the host platform for which the software was originally intended.",{"@attributes":{"id":"p-0193","num":"0522"},"figref":"FIG. 20B","b":["1201","1303","1201","1203","1205","1207","1205","1203","1207","1207","1252","1254","1256","1201","1252","1201","1209","1211","1213","1215","1217","1219","1209","1217","1207","1221","1225","1201"]},"A number of program modules including emulator  may be stored on the hard disk , removable magnetic disk , optical disk  and\/or the ROM  and\/or the RAM  of system memory . Such program modules may include an operating system providing graphics and sound APIs, one or more application programs, other program modules, program data and game data. A user may enter commands and information into personal computer system  through input devices such as a keyboard , pointing device , microphones, joysticks, game controllers, satellite dishes, scanners, or the like. These and other input devices can be connected to processing unit  through a serial port interface  that is coupled to system bus , but may be connected r by other interfaces, such as a parallel port, game port Fire wire bus or a universal serial bus (USB). A monitor  or other type of display device is also connected to system bus  via an interface, such as a video adapter .","System  may also include a modem  or other network interface means for establishing communications over a network  such as the Internet. Modem , which may be internal or external, is connected to system bus  via serial port interface . A network interface  may also be provided for allowing system  to communicate with a remote computing device  (e.g., another system ) via a local area network  (or such communication may be via wide area network  or other communications path such as dial-up or other communications means). System  will typically include other peripheral output devices, such as printers and other standard peripheral devices.","In one example, video adapter  may include a 3D graphics pipeline chip set providing fast 3D graphics rendering in response to 3D graphics commands issued based on a standard 3D graphics application programmer interface such as Microsoft's DirectX 7.0 or other version. A set of stereo loudspeakers  is also connected to system bus  via a sound generating interface such as a conventional \u201csound card\u201d providing hardware and embedded software support for generating high quality stereophonic sound based on sound commands provided by bus . These hardware capabilities allow system  to provide sufficient graphics and sound speed performance to play software stored in storage medium .","All documents referenced above are hereby incorporated by reference.","While the invention has been described in connection with what is presently considered to be the most practical and preferred embodiment, it is to be understood that the invention is not to be limited to the disclosed embodiment, but on the contrary, is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims."],"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND AND SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXAMPLE EMBODIMENTS OF THE INVENTION","EXAMPLES"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features and advantages provided by the invention will be better and more completely understood by referring to the following detailed description of presently preferred embodiments in conjunction with the drawings, of which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 12A and 12B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 20A and 20B"}]},"DETDESC":[{},{}]}
