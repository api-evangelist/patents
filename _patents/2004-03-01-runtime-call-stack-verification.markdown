---
title: Run-time call stack verification
abstract: Run-time call stack verification is used to determine that a code module has been called by a legitimate caller. A return address on the stack indicates where execution is to return upon execution of the next return instruction, and this return address is indicative of where the code module was called from. The code module may determine that the call is allowed, or disallowed, based on the location of the return address. A calling convention is provided that allows the code module to be called through an intermediary, while also preserving the original return address that was in effect at the time the intermediary was called and also resisting modification to the call stack during the time that the original return address is being verified.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07546587&OS=07546587&RS=07546587
owner: Microsoft Corporation
number: 07546587
owner_city: Redmond
owner_country: US
publication_date: 20040301
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Example Process of Verifying a Call Stack"],"p":["The present invention relates generally to the field of computing, and, more particularly, to the verification of a call stack.","There are certain applications of computing in which functions performed by the computer are sensitive and need to be protected from abuse and attack. For example, in a digital rights management (DRM) system that protects valuable (e.g., copyrighted) content from being used in an unlicensed manner, the content is typically stored in an encrypted form, and is decrypted only under the circumstances specified in an electronic license. Thus, the code that applies the decryption key to generate clear content is a sensitive piece of code, in the sense that such code should not divulge the decryption key, and should provide clear content only under circumstances that provide reasonable assurance that the clear content will not be misused or distributed in a manner that is contrary to license. The piece of code that performs the decryption function or any sensitive operations is, in some contexts, referred to as a \u201cblack box.\u201d Such a black box should resist attempts by attackers to manipulate or misuse the black box binary or application which has the rights to the clear content in a manner that would divulge the key or the clear content.","A black box (or other program module that performs a sensitive function) should implement tamper-resistant measures that are designed to thwart known types of attack on the black box or the application which leverages its functionality. Typical tamper-resistance measures may include code obfuscation, code encryption, self-modification of code, and other known techniques that tend to confound analysis and manipulation of code.","While a computer program may employ tamper-resistant measures of the type described above, one security weakness not easily addressed by such techniques arises at the boundary between two code modules. Modem programs are typically modularized into components that communicate with each other by way of an interface. For example, the black box described above can be implemented as a dynamic-link library (DLL), which can be linked to, and called by, one or more application programs. The advantage to such a design is that the black box's function can be used (\u201cconsumed\u201d) by many programs, without that function having to be implemented explicitly by each program, and without the inner workings of the black box having to be explicitly disclosed to the various third party vendors who may write the consuming programs. It also allows updates to the black box software to be made, for example to fix bugs or add additional tamper-resistance, without needing to recompile and reship all of the application programs which rely on its function. The disadvantage to such a design from a security standpoint, however, is that modularization generally facilitates and encourages the interoperation of code modules (e.g., in theory, any application can link to and call a DLL), while the security of the black box may depend on restricting the circumstances under which the black box can be called (e.g., the black box should not permit its decryption function to be called by applications that might disseminate valuable content in the clear).","Standard tamper-resistance techniques are focused on setting up a boundary around a code module and protecting that boundary from breach. However, since a DLL necessarily shares a permeable interface with its calling application, the standard tamper-resistance techniques do not address the need for protection in terms of how, and under what circumstances, this interface is used to permit access to the DLL's functionality.","In view of the foregoing, there is a need for a system that overcomes the drawbacks of the prior art.","The present invention helps to prevent a code module from being used in an unauthorized manner, or under inappropriate circumstances. The invention operates by verifying the call stack in order to ensure that that the code module has been called under legitimate circumstances.","When a function is called, the caller leaves a \u201creturn address\u201d on the program stack. The return address is the address of the instruction to which the program counter is to be pointed after the called function completes execution. Since this instruction is generally the instruction that immediately follows the call instruction, the return address effectively identifies where the called function was called from. Since the return address is located inside the calling application, the return address can be used to identify the application that made the call. If the called code module maintains a record of legitimate sources that are permitted to call the code module, the return address effectively allows the called code module to distinguish legitimate calls from illegitimate ones. Thus, a code module may permit itself to be called from certain addresses within certain applications, and may otherwise reject attempts to be called by other sources. In the case, for example, of the black box that performs decryption, an illegitimate call may indicate that a rogue application is attempting to use the black box to perform the decryption function for nefarious purposes, and upon detecting such a misuse the black box can take appropriate action.","Additional security may be provided by verifying not only that the return address is within the calling application, but also that the calling application has not been modified relative to a known state. Thus, a checksum or hash of the calling application (or of some subset of pages of the calling application) may be taken and stored; then, when the program module detects that it has been called by the calling application, this checksum or hash may be recomputed and compared with the stored checksum or hash to verify that the calling application has not been modified.","Since there are certain classes of attack that take advantage of the standard calling convention that is used to invoke the functions of a program module (e.g., by adjusting the return address on the stack so that the called function will return to an unexpected location), it is preferable that the program module to be protected not be directly exposed to the calling application. In a preferred embodiment, the calling application calls an intermediate module which, in turn, uses a non-standard calling convention to call or jump into the protected module. The non-standard calling convention is preferably designed to preserve the return address that was in effect at the time that the calling application made the call (so that the return address is available to, and can be verified by, the protected code module itself), while also being designed to cause an operating failure if the return address on the call stack is modified.","Other features of the invention are described below.","Overview","There are some computer security models that depend on protecting a given code module from tampering or misuse. Many security technologies focus on detecting and preventing code tampering in order to prevent hackers from modifying a code module to perform an unintended function. However, it is also desirable to ensure that an unmodified code module is called only under legitimate circumstances. The present invention provides mechanisms that assist a code module in verifying the circumstances under which it has been invoked.","Exemplary Computing Arrangement",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, embedded systems, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules and other data may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit  may represent multiple logical processing units such as those supported on a multi-threaded processor. The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus). The system bus  may also be implemented as a point-to-point connection, switching fabric, or the like, among the communicating devices.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Calling of a Dynamic-Link Library by a Program Module","A computer program typically makes use of modules that have a separate and independent existence from the computer program itself. For example, when an application program  (shown in ) executes, that application program may make use of a program module  (also shown in ) during that execution.  shows how a computer program may make use of a separate program module.","In , application program  comprises a series of instructions that are located at some known place in memory. During the execution of application program , an instruction  is encountered to call a method that is not located within the boundaries of application program . (\u201cNot located within the boundaries,\u201d in this context, means that the called method is located outside of the portion of memory that is allocated to application program .) In the example of , instruction  causes a method in program module  to be called.","Program module  may, for example, be a dynamic-link library (\u201cDLL\u201d)\u2014i.e., a file containing a set of executable methods (or functions) that can be loaded into memory and executed by a program such as application program . In the example of , program module  contains methods  through n, and the call  issued by application program  invokes the second method. When call  is made, the processor on which application program  is executing begins to execute method . Method  will likely contain a \u201creturn\u201d instruction; when the return instruction is encountered, the processor will return () to application program  and will resume executing application program  at the instruction contained at address . Since address  is where execution resumes after the \u201creturn\u201d instruction is encountered, address  is referred to as a \u201creturn address.\u201d As is known in the art, standard calling conventions generally store the return address on the stack at the time of the call.","It will be understood that  shows application program  as the computer program that makes use of a separate program module; however, any type of computer program may use a separate program module, and an \u201capplication\u201d is merely one example of such a computer program. In general, the environment in which a computer program executes may permit one program module (of which an \u201capplication program\u201d is just one example) to make use of another program module.","Use of a Return Address to Identify a Caller","Typically, return address  is the address of the memory location that immediately follows the call instruction. Since return address  is part of the computer program (or other program module) that issued the call instruction, the identity of return address  essentially identifies the calling entity. Since one DLL can be called by different entities, knowing the return address allows identification of the entity that issued the last call instruction that was issued prior to entry of the DLL when using standard calling conventions and an import address table.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3","FIG. 3"],"b":["135","1","135","2","136","135","2","136","206","2","206","2","135","2","135","2","206","1","135","1","206","1","135","1"]},"Moreover, the return address may imply not merely the identity of the calling program, but also a specific location within the calling program. Since the return address is typically the address that immediately follows the call instruction, knowing that the return address is the address of memory location () may imply that program module  was called by a particular function (or even particular line of code) within application program ().","Being able to identify the caller may have useful security implications. For example, program module  may be cryptographic software that hides a decryption key and uses the key to decrypt valuable content. The security model in which such cryptographic software participates may be such that program module  should only perform the decryption function for callers of verifiable integrity. For example, application program () may be an application that has been certified as being capable of protecting valuable content from illicit copying, whereas application () may be an unknown application (or an application that is known to exhibit rogue behavior with respect to valuable content). Thus, application () should be allowed to call program module  to perform the decryption function, while application () should not be allowed to call program module . Thus, it may be useful for a called program module  to be able to identify its caller, and the return address is one mechanism by which the caller can be identified.","Integrity of Identified Caller","As described above in connection with , a return address can be used to identify a caller. As further described above, such identification of the caller has security implications, since there are security models that depend on certain functions being callable only by known programs whose behavior is understood. In this sense, identifying the caller provides a measure of security to the extent that an identifiable caller will exhibit known behavior. However, this type of security can be thwarted if the \u201cknown\u201d caller can be modified to behave in some unexpected manner. For example, when security is based on requiring a function to be called only by a certified calling application, a hacker may modify the certified calling application to exhibit nefarious behavior.","Such an attack on the security of the system can be thwarted by verifying that the caller's code (or at least a portion of the caller's code) has not been modified relative to some known state for that code. Thus, it is desirable to store a checksum, hash, or similar datum that represents the calling code in a known state. For example, in  application  is the calling application. Application  makes a call to an external program module , with a return address . Program module  regards application  as a legitimate caller, and regards calls with return address  as coming from a legitimate place within application , and this checksum is stored. Checksum  may be derived from the entirety of application , or from the page(s) that immediately surround return address  (reference numeral ). At the time that program module  is called from application , checksum  can be recomputed based on application  (or pages ) and then compared with the stored checksum. If the re-computed and stored checksums match, it can be infeffed that application  (or the relevant pages  of application ) have not been modified relative to a known previous state. Example mechanisms for verifying that a caller has not been modified are more particularly discussed below in the section entitled \u201cmodule authentication,\u201d and in subsequent sections.","As noted above, in one security model program module  performs a sensitive function (e.g., the decryption of valuable information), and should only perform this function for a caller whose behavior is known and trusted (e.g., an application that will render the valuable content in an ephemeral manner, but that will not allow the content to be disseminated in the clear to other users). Thus, the caller's return address allows the caller to be identified so it can be determined whether the caller is a known and trusted caller; additionally, verifying checksum  allows it to be determined that the caller's code (and, therefore, its behavior) remains in the state that the code was in at the time the checksum was created (at which time the caller's behavior, presumably, was believed to be trustworthy).","Indirect Calling of Program Module","When a program module needs to be protected from misuse or tampering, security benefits can be derived from exerting tight control on the manner in which the program module can be entered. One way to achieve this control is to prevent the program module from being called directly by applications. Instead, an intermediate module can be exposed to applications, and all calls to the protected program module may be made by the intermediate module on behalf of the application that calls the intermediate module. This structure ensures that the protected program module is always called by a known entity. Moreover, as more particularly discussed below, the known entity can use a special calling convention to enter the protected program module, and this calling convention can be designed to provide additional security.","Thus, in the example of , program module  is a dynamic-link library (DLL) that performs sensitive functions that should be performed under controlled circumstances (e.g., decryption of valuable information). Application  (depicted, by way of example, as a \u201c3rd party client application\u201d) is a software application that calls on program module  to perform such functions. (Program module , in the example of , is a \u201cblack box,\u201d which is discussed above; additionally, in the example of , the black box is implemented as a DLL named \u201csecrep.dll\u201d.) Application , however, does not call program module  directly, but rather calls program module  through an intermediate module . In the example of , intermediate module  is a DLL named \u201cmsdrm.dll,\u201d which exposes an application programming interface (API) that provides DRM-related functions to applications. Program module  includes functionality called \u201cblack box stubs,\u201d which are the code segments that are callable by application  and are used by intermediate module  to call into the black box. Preferably, the stubs are carefully contrived hand-coded assembly language stubs that perform a unique calling convention into the black box; such a calling convention is more particularly described below. (It should be understood that the references to DRM functionality and to the black box are merely exemplary, and the structure of  is not limited to DRM systems.)","Thus, program module  is not exposed directly to application . There are certain classes of attacks that allow program module  to be misused by application program ; these attacks are based on application program 's having a direct interface to program module , so requiring application program  to call program module  indirectly helps to guard against this class of attack. Preferably, intermediate module  uses a non-standard calling convention to call program module . An example of such a non-standard calling convention is more particularly discussed below.","Calling Convention","As discussed above, using a non-standard convention may be part of an overall security framework. A non-standard calling convention may thwart certain types of attacks that are based on the protocol by which function calls occur. Additionally, the particular non-standard calling convention described below has the advantage that it can preserve a caller's return address across more than one call boundary (i.e., if function  calls function , which calls function  using the non-standard calling convention described below, then function 's return address can be known to function ; under a standard calling convention, function 's return address would be generally unavailable to function ).","In the example of , program module  is exposed to application , but program module  is not exposed to application . However, program module  contains \u201cstubs\u201d that can be used to enter program module \u2014i.e., application  invokes the stubs, and this invocation identifies the particular functionality from program module  that application  would like to perform. The stubs, in turn, invoke the relevant code in program module . Program module , in this example, includes the code need to verify and authenticate the caller (i.e., application ), and the stubs contain data required by the verification and authentication code. Preferably, this data is mixed into the stubs' instruction streams. The call into program module  passes the address of this data to the verification and authentication code \u201csurreptitiously.\u201d That is, data used by the verification and authentication code is inserted into the instruction stream immediately after the call to program module ; since the call causes the address immediately following the call instruction to be pushed onto the stack as a return address, the stack contains a pointer to the data in what would be the return address using a standard calling convention. If a standard tool were to patch the stub, then the return address will no longer point to the actual data that is needed by the verification function. The address of the stub itself is also preserved and the entire stub is verified by the code that ultimately executes the call (or jump) into the code providing the requested functionality, for example a content decryption request, in program module .","On the x86 processor architecture, the DRMxxxStub therefore looks like (in pseudo-assembly):",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"push cArgs","; number of DRMxxx function parameters"]},{"entry":[{},"call dword ptr","; call blackbox \u201cdemux\u201d authenticator"]},{"entry":[{},"[g_pfnBBJump]"]},{"entry":[{},"0x07","; data injected in instruction stream"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The return address pushed on to the stack as a result of the \u201ccall\u201d will actually point at the \u201c0\u00d707\u201d data. The blackbox demux authenticator will not actually return to that location, but will simply use the data and return directly to the calling application instead. This prevents standard profilers and binary patching tools from adding logging or redirection code at this interface, and prevents debuggers from adding breakpoints. It should be noted that data such as \u201c0\u00d707\u201d is different for each stub and will be interpreted as a random instruction opcode by disassemblers (in this case, \u201cpop es\u201d), which is also a benefit. Since most instructions are longer than one byte, the bogus opcode will cause further mistakes in the disassembly as parts of other stubs are interpreted as part of that instruction (i.e. the disassembler gets \u201cout of alignment\u201d).","On an \u00d786, the following is the call stack layout upon entering BBJump:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/","|","|"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","|DRMxxx Stub Return Address","| esp"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","|Parameter Depth (cArgs)","| esp+ 4h"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","|Ret Addr App\/msdrm.dll","| esp+ 8h"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","|DRMxxx Parameter 1","| esp+ 8h+4h"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| ...","|"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","|DRMxxx Parameter n","| esp+ 8h+nDepth"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","|App\/msdrm.dll local stack","| esp+0Ch+nDepth"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"BBJump uses the DRMxxx Stub return address to verify the stub has not been modified and to access the embedded data, which is actually a vtable entry descriptor for the desired DRM service. This descriptor and the \u201cParameter Depth\u201d are used by the demux to call the desired function, DRMxxxPub, inside the blackbox and to prepare the stack for return to the application (i.e. resetting the stack to adhere to _stdcall calling convention). The vtable is a covered (i.e. encrypted) list of function pointers inside the binary, in random order (i.e. encrypted and ordered uniquely for each blackbox).","After verification, the application return address is inserted in the stack below the DRMxxx parameters, so that BBJump will return directly to the application rather than the stub. The DRMxxx Stub Return Address is replaced on the stack with the address of the DRMxxxPub address, and the cArgs is replaced with a return address inside BBJump for cleanup. The following shows the stack after these replacements have been performed:",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| DRMxxxPub Address","| esp"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| BBJump_Cleanup address","| esp+ 4h"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| Ret Addr App\/msdrm.dll","| esp+ 8h"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| DRMxxx Parameter 1","| esp+ 8h+4h"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| ...","|"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| DRMxxx Parameter n","| esp+ 8h+4*cArgs"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| Ret Addr App\/msdrm.dll","| esp+0Ch+4*cArgs"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},"\/\/","| App\/msdrm.dll local stack","| esp+10h+4*cArgs"]},{"entry":[{},"\/\/","|-------------------------------","|"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"By doing this, the subsequent jump into the unique v-table uncovering code will transition into the DRMxxxPub function when it attempts to \u201creturn\u201d to BBJump. That is, the address of the DRMxxxPub function is surreptitiously used by BBJump to force the blackbox to transition into the DRMxxxPub function without returning to BBJump and making another call. Since the BBJump Cleanup address has been inserted below that, DRMxxxPub will return directly to BBJump for cleanup, which includes obliterating sensitive data from the recently used parts of the stack.","The code which performs the call stack verification expects that the DRM API was called through the application's Import Address Table (IAT), the default behavior when the linker links the binary to a DLL. The call site is verified to have one of the standard IAT transitions. In theory, the application should call directly to the address of the blackbox stub function which called into BBJump. However, the \u201ctail-call optimization\u201d prevents generally requiring this (i.e. the call might be to another part of the application which then jumps into the blackbox stub). (\u201cTail-call optimization\u201d refers to the case where the last instruction in a first function is to call a second function. Since it is not necessary to be able to return to the first function to execute more instructions, a compiler can optimize the generated code by generating an instruction to jump into the second function\u2014thereby saving the relatively high cost of performing a true function call to the second function. The return instruction in the second function will then cause a return not to the first function, but rather to the function that issued a call to the first function (or, more generally, to whatever context appears at the next level down the call stack). This optimization saves the expense of one function call and one return, but the cost of this optimization, from the perspective of call-stack verification, is that the call stack cannot be used to verify that the second function was called by the first, since a jump into the second function is not reflected in the call stack.) Additional restrictions on how the application is built, however, could enable this verification. The following is the expected instruction stream for an IAT call:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ IAT indirection (disp32 is an address in the IAT):"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","; call relative disp32 (i.e. function call within module)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","Caller:","call Thunk","; E8","EB 7E 01 00"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","call 00017EEBh","; E8","EB 7E 01 00"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","; jmp absolute indirect disp32","Mod=00 Op=100 R\/M=101"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","Thunk:","jmp dword ptr [disp32]","; FF 25 0C 11 CB 00"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","jmp dword ptr [00CB110Ch]","; FF 25 0C 11 CB 00"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ or:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","; call absolute indirect disp32","Mod=00 Op=010 R\/M=101"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/","call dword ptr [disp32]","; FF 15 0C 11 CB 00"]},{"entry":["\/\/","call dword ptr [00CB110Ch]","; FF 15 0C 11 CB 00"]},{"entry":"\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ Note:","The compiler uses the first convention by default across DLL"]},{"entry":["\/\/","boundaries. However, if declspec(dllimport) modifier is specified"]},{"entry":["\/\/"," with the function declaration (i.e. in the header for the API), the"]},{"entry":["\/\/"," compiler will resolve the function name to imp_xxx which yields"]},{"entry":["\/\/"," the second convention."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The verification code also checks that the BBJump and blackbox stub code has not been tampered with. Here is the instruction stream it expects, respectively:",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/","|----","|",{},{}]},{"entry":["\/\/ pbBBJump[\u221210]","| 8D","|===","|"]},{"entry":["\/\/","|----","|","|"]},{"entry":["\/\/ pbBBJump[\u22129]","| 44","|","|"]},{"entry":["\/\/","|----","|","|-lea eax, [esp\u22124h]"]},{"entry":["\/\/ pbBBJump[\u22128]","| 24","|","|"]},{"entry":["\/\/","|----","|","|"]},{"entry":["\/\/ pbBBJump[\u22127]","| FC","|===","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/","|----","|",{}]},{"entry":["\/\/ pbBBJump[\u22126]","| 50","|-push eax"]},{"entry":["\/\/","|----","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ pbBBJump[\u22125]","| E8","|=================","|",{}]},{"entry":["\/\/","|----","|","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ pbBBJump[\u22124]","| xx","|===","|","|",{}]},{"entry":["\/\/","|----","|","|","|"]},{"entry":["\/\/","| xx","|","|","|-call BBCheckStack"]},{"entry":["\/\/","|----","|","|-dwCallDelta","|"]},{"entry":["\/\/","| xx","|","|","|"]},{"entry":["\/\/","|----","|","|","|"]},{"entry":["\/\/","| xx","|===","|=============","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","|----","|",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ pbBBJump[ 0]","| 85","|===","|",{}]},{"entry":["\/\/","|----","|","|-test eax, eax"]},{"entry":["\/\/ pbBBJump[ 1]","| C0","|===","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/","|----","|",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/",{},{},{},{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\/\/---------------------------------------------------------------------------",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/",{},{},{}]},{"entry":["\/\/","|----","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ pbStubRA[\u22128]","| 6A","|=========","|",{}]},{"entry":["\/\/","|----","|","|-push cArgs"]},{"entry":["\/\/ pbStubRA[\u22127]","| xx","|-cArgs===","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/","|----","|",{},{}]},{"entry":["\/\/ pbStubRA[\u22126]","| FF","|=================","|"]},{"entry":["\/\/","|----","|","|"]},{"entry":["\/\/ pbStubRA[\u22125]","| 15","|","|"]},{"entry":["\/\/","|----","|","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ pbStubRA[\u22124]","| xx","|===","|","|",{}]},{"entry":["\/\/","|----","|","|","|-call dword ptr [g_pfnBBJump]"]},{"entry":["\/\/","| xx","|","|","|"]},{"entry":["\/\/","|----","|","|-pdwBBJump","|"]},{"entry":["\/\/","| xx","|","|","|"]},{"entry":["\/\/","|----","|","|","|"]},{"entry":["\/\/","| xx","|===","|============","|"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/","|----","|",{}]},{"entry":["\/\/ pbStubRA[ 0]","| xx","|-iVTable"]},{"entry":["\/\/","|----","|"]},{"entry":"\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/---------------------------------------------------------------------------"},{"entry":"\/\/"},{"entry":"\/\/ pbAppRA always points to the instruction following a call.\u2003However, the"},{"entry":"\/\/ call might have ultimately reached us:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ 1) direct:","call absolute indirect (reg and\/or disp32) to DRMxxx"]},{"entry":["\/\/ 2) chain:","call relative to series of functions which jmp absolute"]},{"entry":["\/\/","indirect, the last of which jmps to DRMxxx"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ IAT is a special case of 2), where the chain is only 1 deep.\u20032) can also"},{"entry":"\/\/ occur as a compiler optimization if a call to a function is the last"},{"entry":"\/\/ instruction of the caller function (and stack clean up is not an issue)."},{"entry":"\/\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6","FIG. 5"],"b":["135","602","502","604","602","606","604","606","606","604","608","608","610","135","135","602","602","602","502"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 7"},"Initially, a call from an application program is received  at an intermediate module (e.g., intermediate module , shown in ). The intermediate module uses a non-standard calling convention to call into (or jump to)  a program module. As discussed above, the non-standard calling convention resists certain classes of attacks involving the program module that would be easily carried out if there were a conventional interface into the program module. The identity of the caller is then verified  based on the return address of the original call. The relevant return address is that which was specified when the initial call was made at ; the non-standard calling convention is designed, among other things, to preserve this return address in some manner so that it can be verified from inside the program module that is called at .","After the identity of the original caller has been identified based on the return address at , the integrity of the caller is verified at  based on a checksum\u2014i.e., a checksum is computed based on the caller (or some portion thereof), and the computed checksum is compared with a stored checksum. Assuming that the caller's integrity is verified, the stack values are set  so that the return address points back to the original caller (i.e, the caller who made the call to the intermediate module). A jump is then made  into the part of the program module that will perform the function requested (i.e., the function that the original caller desired to perform when making the call at ), and, when this function is complete, a return instruction is then executed  which pops the stack and returns to the return address that was placed on the stack at  (which is the same as the return address specified by the original caller).","Module Authentication","As noted above, one feature provided herein is to authenticate the code that calls a program module\u2014i.e., to verify that the code surrounding the call has not been modified relative to a known state. The following description relates to the module authentication procedure.","Module authentication is a security feature that helps protect the application execution environment against tampering. When used properly, it provides some level of protection against code patching, redirection and software breakpoints. The level of protection is dependent on the number of modules in the applications process space that are authenticated and the frequency of the authentication.","There are two phases to module authentication. Static authentication is a one-time check of module on-disk images while dynamic authentication is a check of the in-memory module images. Dynamic authentication is ongoing process since tampering can occur anytime in the life of the application process.","In practice, application performance and the openness of a Win32 process limit authentication to a subset of modules. The application specifies this subset of all its loaded modules via the application manifest. All modules that receive sensitive data should generally be authenticated.","Static Module Authentication","The purpose of static module authentication is to establish the authenticity of the on-disk images of important executable modules in the application process space. This includes both application and system modules. Static authentication does little to protect the execution environment directly, but it does serve an important purpose:\n\n","For standard static authentication, the PE (portable executable) file on the persistent storage device (which is usually a disk, but can also be flash memory on a portable device) is hashed and checked against a signed hash value. To compute the file hash, the PE headers of the file must be parsed in order to avoid hashing data that can legitimately change after the file is created. Examples are timestamps and global data sections. The algorithm for hashing the PE file is the same one used by WINDOWS\u2122 operating system for signing system binaries.","Dynamic Module Authentication","Dynamic module authentication is the authentication of the in-memory images of modules loaded in the process. While static module authentication only gives an assurance that the executable file on disk hasn't been tampered, dynamic module authentication gives an assurance that code pages in memory haven't been tampered. It is the mechanism by which the RM system protects the application's execution environment against attacks such as code redirection via import tables or inserted jump instructions and even software breakpoints (int 3's). Since code pages can be tampered anytime during the life the process, dynamic module authentication is an ongoing task. Dynamic module authentication can be expensive and has to be managed carefully.","The setup of dynamic authentication involves computing the expected in-memory page hashes of all read-only module pages. The page hashes are stored in tables for quick reference in subsequent page verification. The basis for establishing what the code pages should look like in memory is a signed disk image of the PE file itself or its corresponding prehash. Determining the expected page hash is complicated by the existence of relocations and import address tables. Authenticating relocated pages and import tables forces us to apply the logic used by the WINDOWS\u2122 operating system loader. For example, if the module being authenticated was rebased by the OS, we have to apply relocation fix-ups to the appropriate addresses before computing each page hash. If the module has static imports or delay imports, we have to mimic the loader when computing the expected import address table (IAT).","The verification phase involves computing hashes of actual memory pages for comparison with expected hash values stored during dynamic module authentication setup. Two types of verification are enabled. First, arbitrarily-sized portions of the authenticated modules can be checked at run-time for verification. This checking can be performed on a random sample of pages to increase the likelihood of detecting tampering in a large application. The second type of validation enabled is that of run-time call stack validation. If it is assumed that the address of the instructions in the application that call into the RM system can be reliably determined, dynamic module authentication enables targeted verification of the application. The address of the caller can be validated to come from within an \u201callowed\u201d module. This prevents calls into the RM system directly from untrusted code. In addition, the memory pages surrounding and containing the call instruction to the RM system can be authenticated to protect against tampering. This check prevents an adversary from using a tampered \u201callowed\u201d caller.","IAT Checking","A simple and common way to redirect code is to modify a module's import address table (IAT). We attempt to prevent this obvious attack as part of dynamic module authentication. We protect both static IATs and delay load IATs by independently constructing (\u201cbinding\u201d) the IATs and comparing to the actual IAT in use.","It is noted that the foregoing examples have been provided merely for the purpose of explanation and are in no way to be construed as limiting of the present invention. While the invention has been described with reference to various embodiments, it is understood that the words which have been used herein are words of description and illustration, rather than words of limitations. Further, although the invention has been described herein with reference to particular means, materials and embodiments, the invention is not intended to be limited to the particulars disclosed herein; rather, the invention extends to all functionally equivalent structures, methods and uses, such as are within the scope of the appended claims. Those skilled in the art, having the benefit of the teachings of this specification, may effect numerous modifications thereto and changes may be made without departing from the scope and spirit of the invention in its aspects."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings example constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
