---
title: Visualizing and updating sequences and segments in a video surveillance system
abstract: Techniques are disclosed for visually conveying a sequence storing an ordered string of symbols generated from kinematic data derived from analyzing an input stream of video frames depicting one or more foreground objects. The sequence may represent information learned by a video surveillance system. A request may be received to view the sequence or a segment partitioned form the sequence. A visual representation of the segment may be generated and superimposed over a background image associated with the scene. A user interface may be configured to display the visual representation of the sequence or segment and to allow a user to view and/or modify properties associated with the sequence or segment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08493409&OS=08493409&RS=08493409
owner: Behavioral Recognition Systems, Inc.
number: 08493409
owner_city: Houston
owner_country: US
publication_date: 20090818
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","Embodiments of the invention provide techniques for conveying information learned by a video surveillance system. More specifically, embodiments of the invention relate to techniques for visualizing and updating kinematic segments in a video surveillance system.","2. Description of the Related Art","Some currently available video surveillance systems provide simple object recognition capabilities. For example, a video surveillance system may be configured to classify a group of pixels (referred to as a \u201cblob\u201d) in a given frame as being a particular object (e.g., a person or vehicle). Once identified, a \u201cblob\u201d may be tracked frame-to-frame in order to follow the \u201cblob\u201d moving through the scene over time, e.g., a person walking across the field of vision of a video surveillance camera. Further, such systems may be configured to determine when an object has engaged in certain predefined behaviors.","However, such surveillance systems typically require that the objects and\/or behaviors which may be recognized by the system to be defined in advance. Thus, in practice, these systems rely on predefined definitions for objects and\/or behaviors to evaluate a video sequence. In other words, unless the underlying system includes a description for a particular object or behavior, the system is generally incapable of recognizing that behavior (or at least instances of the pattern describing the particular object or behavior). Thus, what is \u201cnormal\u201d or \u201cabnormal\u201d behavior needs to be defined in advance, and separate software products need to be developed to recognize additional objects or behaviors. This results in surveillance systems with recognition capabilities that are labor intensive and prohibitively costly to maintain or adapt for different specialized applications. Accordingly, currently available video surveillance systems are typically unable to recognize new patterns of behavior that may emerge in a given scene or recognize changes in existing patterns. More generally, such systems are often unable to identify objects, events, behaviors, or patterns as being \u201cnormal\u201d or \u201cabnormal\u201d by observing what happens in the scene over time; instead, such systems rely on static patterns defined in advance.","One embodiment of the invention includes a computer-implemented method. The method may generally include receiving a request to view a sequence storing an ordered string of symbols, wherein the sequence is generated from kinematic data derived from analyzing an input stream of video frames depicting one or more foreground objects; retrieving a background image associated with a scene depicted in the input stream of video frames; generating a visual representation of the requested sequence; and superimposing the visual representation of the requested sequence over the background image, wherein the position of each symbol of the ordered string of symbols in the sequence is superimposed at a position in the background image corresponding to a spatial location in the scene where the kinematic data associated with the respective symbol was obtained.","Another embodiment of the invention includes a computer-readable storage medium containing a program which, when executed by a computer processor, performs an operation. The operation may generally include receiving a request to view a sequence storing an ordered string of symbols, wherein the sequence is generated from kinematic data derived from analyzing an input stream of video frames depicting one or more foreground objects; retrieving a background image associated with a scene depicted in the input stream of video frames; generating a visual representation of the requested sequence; and superimposing the visual representation of the requested sequence over the background image, wherein the position of each symbol of the ordered string of symbols in the sequence is superimposed at a position in the background image corresponding to a spatial location in the scene where the kinematic data associated with the respective symbol was obtained.","Still another embodiment of the invention includes a system. The system may include a video input source configured to provide a sequence of video frames, each depicting a scene, a processor and a memory containing a program. The program, when executed by the processor, is configured to perform an operation. The operation may generally include receiving a request to view a sequence storing an ordered string of symbols, wherein the sequence is generated from kinematic data derived from analyzing an input stream of video frames depicting one or more foreground objects; retrieving a background image associated with a scene depicted in the input stream of video frames; generating a visual representation of the requested sequence; and superimposing the visual representation of the requested sequence over the background image, wherein the position of each symbol of the ordered string of symbols in the sequence is superimposed at a position in the background image corresponding to a spatial location in the scene where the kinematic data associated with the respective symbol was obtained.","Embodiments of the invention provide an interface configured to visually convey information learned by a behavior-recognition system. The behavior-recognition system may be configured to identify, learn, and recognize patterns of behavior by observing and evaluating events depicted by a sequence of video frames. In a particular embodiment, the behavior-recognition system may include both a computer vision engine and a machine learning engine. The computer vision engine may be configured to evaluate a stream of video frames. Typically, each frame of video may be characterized using multiple color (or grayscale) channels (e.g., a radiance value between 0-255 and a set of red, green, and blue (RGB) color channels values, each between 0-255). Further, the computer vision engine may generate a background image by observing the scene over a number of video frames. For example, consider a video camera trained on a stretch of a highway. In such a case, the background would include the roadway surface, the medians, any guard rails or other safety devices, and traffic control devices, etc., that are visible to the camera. Vehicles traveling on the roadway (and any other person or thing engaging in some activity) that are visible to the camera would represent scene foreground objects.","The computer vision engine may compare the pixel values for a given frame with the background image and identify objects as they appear and move about the scene. Typically, when a region of the scene (referred to as a \u201cblob\u201d or \u201cpatch\u201d) is observed with appearance values that differ substantially from the background image, that region is identified as depicting a foreground object. Once identified, the object may be evaluated by a classifier configured to determine what is depicted by the foreground object (e.g., a vehicle or a person). Further, the computer vision engine may identify features (e.g., height\/width in pixels, average color values, shape, area, and the like) used to track the object from frame-to-frame. Further still, the computer vision engine may derive a variety of information while tracking the object from frame-to-frame, e.g., position, current (and projected) trajectory, direction, orientation, velocity, acceleration, size, color, and the like. In one embodiment, the computer vision outputs this information as a stream of \u201ccontext events\u201d describing a collection of kinematic information related to each foreground object detected in the video frames. Each context event may provide kinematic data related to a foreground object observed by the computer vision engine in the sequence of video frames.","Data output from the computer vision engine may be supplied to the machine learning engine. In one embodiment, the machine learning engine may evaluate the context events to generate \u201cprimitive events\u201d describing object behavior. Each primitive event may provide semantic meaning to a group of one or more context events. For example, assume a camera records a car entering a scene, and that the car turns and parks in a parking spot. In such a case, the computer vision engine could initially recognize the car as a foreground object; classify it as being a vehicle, and output kinematic data describing the position, movement, speed, etc., of the car in the context event stream. In turn, a primitive event detector could generate a stream of primitive events from the context event stream such as \u201cvehicle appears,\u201d \u201cvehicle turns,\u201d \u201cvehicle slowing,\u201d and \u201cvehicle stops\u201d (once the kinematic information about the car indicated a speed of 0). As events occur, and re-occur, the machine learning engine may create, encode, store, retrieve, and reinforce patterns representing the events observed to have occurred, e.g., long-term memories (or long-term \u201cpercepts\u201d) representing a higher-level abstraction of a car parking in the scene\u2014generated from the primitive events underlying multiple observations of different cars entering and parking. The interface may be configured to visually convey such patterns. Specifically, the patterns may be stored in a long-term memory of the machine learning engine. Further still, patterns representing an anomalous event (relative to prior observation) or events identified as an event of interest may result in alerts passed to users of the behavioral recognition system.","In one embodiment, the machine learning engine may generate kinematic data describing behavior of a foreground object in a scene. Suppose the computer vision engine observes a car pulling up, parking, and a driver of the car exiting the car and walking. In response, the machine learning engine may generate a sequence that includes \u201cvehicle appears,\u201d \u201cvehicle slowing,\u201d \u201cvehicle stops,\u201d \u201chuman appears,\u201d \u201chuman starts,\u201d and \u201chuman moving.\u201d Of course, the sequence of kinematic data may be arbitrary symbols. For example, in one embodiment, a voting experts technique is used to generate segments from a sequence of symbols assigned to clusters of an adaptive resonance theory (ART) network. The ART network itself may cluster nodes of a self-organizing map (SOM). Further, the SOM may be created by mapping inputs of kinematic data derived from observations of the computer vision engine monitoring agents moving about the scene (e.g., a person or a vehicle moving within the field of vision of the camera). However, for purposes of readability, kinematic data is sometimes described herein using the agent-action approach used above (e.g., \u201cperson moving\u201d).","In one embodiment, the machine-learning engine may partition the sequence into segments. For example, the machine-learning engine may partition the sequence into a first segment and a second segment. For instance, in the parking scenario described above, the first segment may include kinematic data describing the car pulling up and parking (e.g., \u201cvehicle appears,\u201d \u201cvehicle slowing,\u201d and \u201cvehicle stops\u201d). The second segment may include kinematic data describing the driver exiting the car and walking (e.g., \u201chuman appears,\u201d \u201chuman starts,\u201d and \u201chuman moving\u201d). Consequently, the machine learning engine may evaluate each segment individually. Further, combinations of sequences and segments may be evaluated against prior observations to detect anomalous events.","In one embodiment, a voting experts approach may be used to generate the segments from a sequence of kinematic data. The voting experts approach provides an unsupervised induction-learning technique used for segmenting sequences into segments. In particular, the voting experts approach computes statistical signatures of different-length segments in a set of sequences and identifies the most probable segments in the sequences, based on the statistical signatures. The voting experts identify segments having low internal entropies (a measure of randomness), while also maximizing entropies at boundaries between segments.","As stated, the video surveillance system may be configured to identity anomalous segments. More specifically, the video surveillance system uses inductive reasoning to identify general patterns of behavior (as represented by the observed sequence labels) to estimate a probability density function for different activities (representing the statistical likelihood of a given segment being observed). Doing so allows the video surveillance system to generate an alert when an intra-trajectory observed segment does not satisfy the estimated normal-activity statistics. Similarly, the video surveillance system may also generate alerts for inter-trajectory observations that do not satisfy the estimated normal-activity statistics for interactions between the sequences of different objects.","In one embodiment, the machine-learning engine may also include a transaction server. The transaction server may generate a visual representation of sequences of agent behavior, as well of how the machine learning engine segmented a particular sequence. Further, the transaction server may generate a visualization of sequences (or segments) identified as being anomalous, relative to the sequences (and segments) of other agents observed by the computer vision engine to have engaged in the same (or similar behavior). Thus, the transaction server allows users to explore data learned by the machine-learning engine. Further, the transaction server allows users to specify how the system is to respond to certain observed events and\/or behaviors (for example, when to produce (or not produce) an alert). For instance, the transaction server may receive a request to view a segment\u2014or a request to view segments for a particular agent (e.g., for a person). In response, the transaction server may generate a visual representation of the segment superimposed over a background model. The background model provides an image of the scene expected when the background is visible to the camera. Alternatively, the transaction server may also transmit learned data to a client application. The client application may generate a visual representation of the segment from the learned data. Further, the transaction server may also receive user requests to associate metadata with a segment. The metadata may be used to guide system behavior. For example, a user may provide a name for a segment, specify a rule that the system should generate an alert (or refrain from generating an alert) when a sequence of events that match a segment is observed, or otherwise modify metadata associated with a segment.","In the following, reference is made to embodiments of the invention. However, it should be understood that the invention is not limited to any specifically described embodiment. Instead, any combination of the following features and elements, whether related to different embodiments or not, is contemplated to implement and practice the invention. Furthermore, in various embodiments the invention provides numerous advantages over the prior art. However, although embodiments of the invention may achieve advantages over other possible solutions and\/or over the prior art, whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus, the following aspects, features, embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim(s). Likewise, reference to \u201cthe invention\u201d shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim(s).","One embodiment of the invention is implemented as a program product for use with a computer system. The program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Examples of computer-readable storage media include (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM or DVD-ROM disks readable by an optical media drive) on which information is permanently stored; (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive) on which alterable information is stored. Such computer-readable storage media, when carrying computer-readable instructions that direct the functions of the present invention, are embodiments of the present invention. Other examples media include communications media through which information is conveyed to a computer, such as through a computer or telephone network, including wireless communications networks.","In general, the routines executed to implement the embodiments of the invention may be part of an operating system or a specific application, component, program, module, object, or sequence of instructions. The computer program of the present invention is comprised typically of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions. Also, programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition, various programs described herein may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However, it should be appreciated that any particular program nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and\/or implied by such nomenclature.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","b":["100","100","105","110","115","118","110","105","115","115","120","125","130","135","140","135","140","105"]},"Network  receives video data (e.g., video stream(s), video images, or the like) from the video input source . The video input source  may be a video camera, a VCR, DVR, DVD, computer, web-cam device, or the like. For example, the video input source  may be a stationary video camera aimed at a certain area (e.g., a subway station, a parking lot, a building entry\/exit, etc.), which records the events taking place therein. Generally, the area visible to the camera is referred to as the \u201cscene.\u201d The video input source  may be configured to record the scene as a sequence of individual video frames at a specified frame-rate (e.g., 24 frames per second), where each frame includes a fixed number of pixels (e.g., 320\u00d7240). Each pixel of each frame may specify a color value (e.g., an RGB value) or grayscale value (e.g., a radiance value between 0-255). Further, the video stream may be formatted using known such formats e.g., MPEG2, MJPEG, MPEG4, H.263, H.264, and the like. Additionally, although shown as a single video input source , the system  may support many video cameras\u2014each observing a distinct scene. Further, each camera may have multiple preset positions (i.e., a single camera may, in fact, be trained on more than one scene). In such cases, a separate instance of the computer vision engine  and machine learning-engine  may be available to observe the video stream from each camera (and presets, if any).","The computer vision engine  may be configured to analyze this raw information to identify active objects in the video stream, classify the objects, derive a variety of metadata regarding the actions and interactions of such objects, and supply this information to a machine-learning engine . In turn, the machine-learning engine  may be configured to evaluate, observe, learn, and remember details regarding events (and types of events) that transpire within the scene over time.","In one embodiment, the machine-learning engine  receives the video frames and the data generated by the computer vision engine . The machine-learning engine  may be configured to analyze the received data, build semantic representations of events depicted in the video frames, detect patterns, and, ultimately, to learn from these observed patterns to identify normal and\/or abnormal events. Additionally, data describing whether a normal\/abnormal behavior\/event has been determined and\/or what such behavior\/event is may be provided to output devices  to issue alerts, for example, an alert message presented on a GUI screen. In general, the computer vision engine  and the machine-learning engine  both process video data in real-time. However, time scales for processing information by the computer vision engine  and the machine-learning engine  may differ. For example, in one embodiment, the computer vision engine  processes the received video data frame-by-frame, while the machine-learning engine  processes data every N-frames. In other words, while the computer vision engine  analyzes each frame in real-time to derive a set of information about what is occurring within a given frame, the machine-learning engine  is not constrained by the real-time frame rate of the video input.","Note, however,  illustrates merely one possible arrangement of the behavior-recognition system . For example, although the video input source  is shown connected to the computer system  via the network , the network  is not always present or needed (e.g., the video input source  may be directly connected to the computer system ). Further, various components and modules of the behavior-recognition system  may be implemented in other systems. For example, in one embodiment, the computer vision engine  may be implemented as a part of a video input device (e.g., as a firmware component wired directly into a video camera). In such a case, the output of the video camera may be provided to the machine-learning engine  for analysis. Similarly, the output from the computer vision engine  and machine-learning engine  may be supplied over computer network  to other computer systems. For example, the computer vision engine  and machine-learning engine  may be installed on a server system and configured to process video from multiple input sources (i.e., from multiple cameras). In such a case, a client application running on another computer system may request (or receive) the results of over network .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 1"],"b":["135","140","135","205","210","215","220","205","210","215","220","105","140","205","210","215","220","205","210","215","220"]},"In one embodiment, the BG\/FG component  may be configured to separate each frame of video provided by the video input source  into a stationary or static part (the scene background) and a collection of volatile parts (the scene foreground.) The frame itself may include a two-dimensional array of pixel values for multiple channels (e.g., RGB channels for color video or grayscale channel or radiance channel for black and white video). In one embodiment, the BG\/FG component  may model the background states for each pixel using a corresponding ART network. In such a case, mature clusters in the art network for a given pixel may represent a distinct background state for the scene being observed. That is, each mature cluster may represent a pixel color value (and mean and variance from that value) expected to be observed in a frame of video when the background of the scene is visible to the camera. Typically, a cluster in the ART network is \u201cmature\u201d after a specified number of inputs have been mapped to that pixel. For example, consider a camera fixed on an elevator lobby. An ART network corresponding to a pixel could steadily fluctuate between a pixel color value obtained when an elevator door was closed and one when it was open\u2014with other colors transiently being observed as agents (people) move about the scene. This could result in an ART network with two mature clusters (one modeling the color values when the elevator door is closed and one modeling when it is open). In this manner, each pixel may be classified as depicting scene foreground or scene background (from frame-to-frame) using an ART network modeling a given pixel.","Additionally, the BG\/FG component  may be configured to generate a mask used to identify which pixels of the scene are classified as depicting foreground and, conversely, which pixels are classified as depicting scene background. The BG\/FG component  then identifies regions of the scene that contain a portion of scene foreground (referred to as a foreground \u201cblob\u201d or \u201cpatch\u201d) and supplies this information to subsequent stages of the pipeline. In one embodiment, a patch may be evaluated over a number of frames before being forwarded to other components of the computer vision engine . For example, the BG\/FG component  may evaluate features of a patch from frame-to-frame to make an initial determination that the patch depicts a foreground agent in the scene as opposed to simply a patch of pixels classified as foreground due to camera noise or changes in scene lighting. Additionally, pixels classified as depicting scene background maybe used to a background image modeling the scene.","The tracker component  may receive the foreground patches produced by the BG\/FG component  and generate computational models for the patches. The tracker component  may be configured to use this information, and each successive frame of raw-video, to attempt to track the motion of the objects depicted by the foreground patches as they move about the scene.","The estimator\/identifier component  may receive the output of the tracker component  (and the BF\/FG component ) and classify each tracked object as being one of a known category of objects. For example, in one embodiment, estimator\/identifier component  may classify a tracked object as being a \u201cperson,\u201d a \u201cvehicle,\u201d an \u201cunknown,\u201d or an \u201cother.\u201d In this context, the classification of \u201cother\u201d represents an affirmative assertion that the object is neither a \u201cperson\u201d nor a \u201cvehicle.\u201d Additionally, the estimator\/identifier component may identify characteristics of the tracked object, e.g., for a person, a prediction of gender, an estimation of a pose (e.g., standing or sitting) or an indication of whether the person is carrying an object. In an alternative embodiment, the machine learning engine  may classify foreground objects observed by the vision engine . For example, the machine-learning engine  may include an unsupervised classifier configured to observe and distinguish among different agent types (e.g., between people and vehicles) based on a plurality of micro-features (e.g., size, speed, appearance, etc.).","The context processor component  may receive the output from other stages of the pipeline (i.e., the tracked objects, the background and foreground models, and the results of the estimator\/identifier component ). Using this information, the context processor  may be configured to generate a stream of context events regarding objects tracked (by tracker component ) and classified (by estimator identifier component ). For example, the context processor component  may evaluate a foreground object from frame-to-frame and output context events describing that object's height, width (in pixels), position (as a 2D coordinate in the scene), acceleration, velocity, orientation angle, etc.","The computer vision engine  may take the outputs of the components , , , and  describing the motions and actions of the tracked objects in the scene and supply this information to the machine-learning engine . In one embodiment, the primitive event detector  may be configured to receive the output of the computer vision engine  (i.e., the video images, the object classifications, and context event stream) and generate a sequence of primitive events\u2014labeling the observed actions or behaviors in the video with semantic meaning. For example, assume the computer vision engine  has identified a foreground object and classified that foreground object as being a vehicle and the context processor component  estimates the kinematic data regarding the car's position and velocity. In such a case, this information is supplied to the machine-learning engine  and the primitive event detector . In turn, the primitive event detector  may generate a semantic symbol stream providing a simple linguistic description of actions engaged in by the vehicle. For example, a sequence of primitive events related to observations of the computer vision engine  occurring at a parking lot could include formal language vectors representing the following: \u201cvehicle appears in scene,\u201d \u201cvehicle moves to a given location,\u201d \u201cvehicle stops moving,\u201d \u201cperson appears proximate to vehicle,\u201d \u201cperson moves,\u201d person leaves scene\u201d \u201cperson appears in scene,\u201d \u201cperson moves proximate to vehicle,\u201d \u201cperson disappears,\u201d \u201cvehicle starts moving,\u201d and \u201cvehicle disappears.\u201d As described in greater detail below, the primitive event stream may be supplied to excite the perceptual associative memory .","Illustratively, the machine-learning engine  includes a long-term memory , a perceptual memory , an episodic memory , a workspace , codelets , and a mapper component . In one embodiment, the perceptual memory , the episodic memory , and the long-term memory  are used to identify patterns of behavior, evaluate events that transpire in the scene, and encode and store observations. Generally, the perceptual memory  receives the output of the computer vision engine  (e.g., the context event stream) and a primitive event stream generated by primitive event detector . The episodic memory  stores data representing observed events with details related to a particular episode, e.g., information describing time and space details related on an event. That is, the episodic memory  may encode specific details of a particular event, i.e., \u201cwhat and where\u201d something occurred within a scene, such as a particular vehicle (car A) moved to a location believed to be a parking space (parking space ) at 9:43 AM.","The long-term memory  may store data generalizing events observed in the scene. To continue with the example of a vehicle parking, the long-term memory  may encode information capturing observations and generalizations learned by an analysis of the behavior of objects in the scene such as \u201cvehicles tend to park in a particular place in the scene,\u201d \u201cwhen parking vehicles tend to move a certain speed,\u201d and \u201cafter a vehicle parks, people tend to appear in the scene proximate to the vehicle,\u201d etc. Thus, the long-term memory  stores observations about what happens within a scene with much of the particular episodic details stripped away. In this way, when a new event occurs, memories from the episodic memory  and the long-term memory  may be used to relate and understand a current event, i.e., the new event may be compared with past experience, leading to both reinforcement, decay, and adjustments to the information stored in the long-term memory , over time. In a particular embodiment, the long-term memory  may be implemented as a binary ART network and a sparse-distributed memory data structure.","The mapper component  may receive the context event stream and the primitive event stream and parse information to multiple ART networks to generate statistical models of what occurs in the scene for different groups of context events and primitive events.","Generally, the workspace  provides a computational engine for the machine-learning engine . For example, the workspace  may be configured to copy information from the perceptual memory , retrieve relevant memories from the episodic memory  and the long-term memory , select and invoke the execution of one of codelets . In one embodiment, each codelet  is a software program configured to evaluate different sequences of events and to determine how one sequence may follow (or otherwise relate to) another (e.g., a finite state machine). More generally, the codelet may provide a software module configured to detect interesting patterns from the streams of data fed to the machine-learning engine. In turn, the codelet  may create, retrieve, reinforce, or modify memories in the episodic memory  and the long-term memory . By repeatedly scheduling codelets  for execution, copying memories and percepts to\/from the workspace , the machine-learning engine  performs a cognitive cycle used to observe, and learn, about patterns of behavior that occur within the scene.","Further, both the computer vision engine  and the machine learning engine  may interface with a transaction server  and a GUI tool  to allow users to explore data learned by the machine-learning engine , according to one embodiment. Users may also specify, via the GUI tool , how the system is to respond to certain observed events and\/or behaviors (for example, when to produce (or not produce) an alert). Note, while  shows the transaction server  as being separate from the machine learning engine , those skilled in the art will recognize that the transaction server  may readily be integrated as part of the machine learning engine .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3","FIG. 1"],"b":["300","115","105","135","140","270","105","301","135","135","302","140","302","135","302","302","135","302","135","302"]},"In one embodiment, the machine learning engine  may include a self-organizing map (SOM) . The machine learning engine  may supply each kinematic point as an input vector to the SOM . For example, a six-dimensional input vector may be supplied that includes: (i) a height in pixels of the foreground object; (ii) a width in pixels of the foreground object; (iii) a velocity in the horizontal direction of the foreground object; (iv) a velocity in the vertical direction of the foreground object; (v) an x-coordinate of the foreground object in the frame; and (vi) a y-coordinate of the foreground object in the frame. As is known, a SOM provides an artificial neural network trained using unsupervised learning to produce a low-dimensional, discretized representation of a higher-dimensional input space of training samples. The discretized representation is called a map and is typically two-dimensional. Thus, the SOM allows high-dimensional data to be visualized. Further, like many artificial neural networks, SOMs operate in two modes: training and mapping. Training builds the map using sample vector inputs. Mapping automatically assigning new input vectors to a node of the SOM.","A SOM includes nodes, each node occupying a distinct position in the map. Further, each node includes a weight vector of the same dimension as the input vectors. The nodes may typically be arranged in an evenly spaced fashion and in a hexagonal or rectangular grid. The SOM maps data from a higher dimensional input space to a lower dimensional map space. For each input vector, the SOM identifies a node having the closest weight vector. The closest weight vector may be identified by computing a Euclidean distance between the input vector and the weight vector. Once identified, the SOM may assign distinct position (i.e., coordinates) of the node in the map to the input vector. The SOM may also adjust the weight vector of the node (and weight vectors of neighboring nodes within a given radius of the node) based on the mapped input vector. The SOM may also decrease the radius over time (as input vectors are mapped).","In one embodiment, the machine learning engine  may also include an Adaptive Resonance Theory (ART) network . Upon each input vector mapping to a node in the SOM  (i.e., for each adjustment of the SOM ), the machine learning engine  may supply the SOM  to the ART network . As is known, Adaptive Resonance Theory describes a number of neural network models which use supervised and unsupervised learning methods. In one embodiment, the ART network  generates clusters from the nodes of the SOM . Each cluster represents a statistical distribution of a specific mix of kinematic properties (e.g., velocity and position) of nodes of the SOM  which are perceived by the ART network . Further, the ART network  may assign an arbitrary identifier (or symbol) to each cluster. In one embodiment, the ART network  may be configured to provide dynamic clustering. That is, a cluster in ART network  may change in size\/shape as each set of SOM nodes is mapped to that cluster. A cluster may initially be defined as a relatively small size. However, as inputs are mapped to that cluster, the size may grow and change over time. Further, the clusters may decay over time. For example, if a cluster does not receive a set of SOM nodes (reinforcing the importance of that cluster) for a specified period of time, such a cluster may be removed from an ART network .","In one embodiment, the machine learning engine  may include voting experts . As used herein, a \u201cvoting expert\u201d refers to an application configured to partition a sequence of symbols into subsequences\u2014referred to as segments. Voting Experts generally refers to an unsupervised algorithm for finding chunks in sequences (i.e., segmenting a sequence). A chunk refers to a grouping of symbols of clusters, such that entropy within the grouping is relatively low, while entropy at boundaries of the grouping (i.e., between the grouping and adjacent labels) is relatively high. In this respect, a chunk may be said to exhibit an information theoretic \u201csignature\u201d (by which the chunk may be identified). Entropy between two labels refers to a measure of familiarity, i.e., how often the two labels have been observed to occur. Suppose Voting Experts is supplied with text from an English novel, with spaces and all forms of punctuation removed. Voting Experts may determine how to find chunks (i.e., words in the English language) in what appears to Voting Experts to be just a stream of characters (i.e., the text from the English).","In one embodiment, upon receiving clusters from the ART network  for each input vector mapping to a node in the SOM , the machine learning engine  identifies the cluster for the node that the respective input vector maps to. The machine learning engine  supplies an identifier (or label) for the cluster to the voting experts . That is, as the SOM  assigns input vectors to nodes of the map and self-adjusts (for example, at a rate of five Hertz, or five input vectors per second), the ART network  clusters nodes of each adjusted SOM , and the machine learning engine  supplies a sequence of labels  (of clusters) to the voting experts  (for example, at a rate of five labels per second).","Like finding words in a stream of characters, the voting experts  may find segments  in a stream of labels , based on the entropy present in the sequences. For instance, in the parking scenario described above, the voting experts  may identify, from a stream of labels  (assigned, e.g., to ART network clusters), a first segment that includes labels corresponding to the car pulling up and parking (e.g., \u201cvehicle appears,\u201d \u201cvehicle slowing,\u201d and \u201cvehicle stops\u201d). The voting experts  may also identify a second segment that includes labels corresponding to the driver exiting the car and walking (e.g., \u201chuman appears,\u201d \u201chuman starts,\u201d and \u201chuman moving\u201d). Specifically, the voting experts  may compute entropy values from a sequence of all labels  thus far received by the voting experts . That is, the voting experts  may determine all possible segments  of the sequence. The voting experts  may store the all possible segments  in an n-gram trie .","As is known, an n-gram is a subsequence of n items from a given sequence. The items in question may be phonemes, syllables, letters, words, etc. Generally, an \u201cn-gram model\u201d is a type of probabilistic model for predicting the next item in a sequence. Further, a \u201ctrie\u201d (or prefix tree) is an ordered tree data structure that stores an associative array where keys of the associative array are typically strings. An associative array is an abstract data type composed of a collection of unique keys and a collection of values, where each key is associated with one or more values.","Once all possible segments (based on the observed inputs sequence up to a depth of n) are stored in the n-gram trie , the voting experts  may determine frequencies and probabilities for each n-gram (i.e., for each possible segment). The voting experts  may also determine, based on the frequencies and probabilities, how to partition subsequently observed sequences of labels  into segments . Further details of the Voting Experts  are described in co-pending U.S. patent application Ser. No. 12\/543,379, filed Aug. 18, 2009, titled \u201cAdaptive Voting Experts for Incremental Segmentation of Sequences with Prediction in A Video Surveillance System,\u201d by Cobb, et al., which is herein incorporated by reference in its entirety.","For instance, in the scenario of the picnic table described above, the voting experts  may partition the sequence into a first segment and a second segment. The first segment may include labels (of clusters) corresponding to the person walking to the picnic table (e.g., \u201chuman appears,\u201d \u201chuman moving,\u201d and \u201chuman stops\u201d). The second segment may include labels corresponding to the person leaving the picnic table (e.g., \u201chuman starts,\u201d \u201chuman moving,\u201d and \u201chuman disappears\u201d). Further, the voting experts  may integrate each (partitioned) segment into the n-gram trie . If a partitioned segment is anomalous, the machine learning engine  may generate an alert for the partitioned segment. From the partitioned segments, the machine learning engine  may more accurately determine whether each segment of a newly received sequence is anomalous\u2014by comparing the probabilities of observing a sequence (or segment) as represented by the ngram trie  to the actual observations. For events that have a probability falling below a specified threshold, alerts may be generated. For example, alerts may be generated for an intra-sequence anomaly (i.e., when a low probability sequence is observed) and for inter-sequence anomalies (i.e., when two different sequences interact with one another).","In one embodiment, the GUI tool  and the transaction server  allow users to retrieve and generate visualizations of sequences (generated by the SOM-ART) and segments (generated by the voting experts). For example, the transaction server  may be configured to processes user requests from the GUI tool  to generate and display a visualization of a segment. Table I shows examples of transactions that may be supported by the transaction server :",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE I"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Transactions supported by the transaction server 260"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Transaction","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Get preset list","Obtain a list of presets for a specified camera"]},{"entry":["Get scene image","Obtain a picture that represents a scene as"]},{"entry":[{},"viewed by the camera"]},{"entry":["Get segments, ART","Obtains all learned data for a specified preset"]},{"entry":["labels, and SOM nodes","(e.g., including properties)"]},{"entry":["Set always alert","Specifies to always alert on event(s) matching"]},{"entry":[{},"a specified segment"]},{"entry":["Set always ignore","Specifies to never alert on event(s) matching"]},{"entry":[{},"a specified segment"]},{"entry":["Modify property","Modify a specified property of a segment"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 4","b":["260","404","406","260","404","260","260"]},"As shown, the method  begins at step , where the user  invokes the client . At step , a user interacts with the client  to connect to the transaction server . For example, the client  may connect to a specified IP address and port number on which the transaction server  is listening. At step , the client  queries for a list of cameras and associated presets . Each preset may include a location and orientation of a video camera observing (or having observed) a scene. At step , the transaction server  returns a list of cameras and presets to the client . At step , the client  displays the list of cameras and presets to the user .","At step , the user  selects a camera and a preset. The client  then queries for a list of segments, ART labels, and SOM nodes from the server  for the selected camera and preset (step ). At step , the server  returns the list of segments, ART labels, and SOM nodes to the client . Alternatively, the server  may be configured to return a list of segments for a currently active scene being observed by the computer vision engine  and machine-learning engine . At step , the client  displays the list of segments to the user . The user  may select a segment from the list. The client  may then display properties associated with the selected segment. The properties may include an identifier for the segment, a label for the segment, alert preferences for the segment, etc. The client  may also allow the user  to modify one or more properties for a segment. For example, a user  may modify a label for a segment to customize how the GUI tool  conveys information for the segment.","At step , the user  modifies a property of a segment via the client . At step , the client  sends a request to the server  to update the property of the segment. At step , the server  attempts to update the property of the segment and returns a result to the client  indicating success or failure of the attempted update. After the step , the method  terminates. The client  may also continue to interact with the server (e.g., via the steps , , or ).",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 5","b":["500","140","500","302","504","506","507","508","510","512","514"]},"As shown, the visualization  of the SOM arranges each node of the SOM in an evenly spaced fashion and in a hexagonal grid. Further, each node may be shaded to indicate which cluster the node belongs to (i.e., as classified by the ART network). A user may specify, via the radio buttons , whether to select a SOM node or a cluster of SOM nodes, according to one embodiment. As shown, the radio buttons  indicate that a SOM node (rather than a cluster) is to be selected. A user may click on any SOM node in the visualization  of the SOM to select the SOM node. Alternatively, if the radio buttons  indicate that a cluster of SOM nodes is to be selected, clicking on any SOM node in the visualization  of the SOM may select the cluster to which the SOM node belongs. That is, clicking the SOM node may select all SOM nodes belonging to the cluster (as classified by the ART network).","In one embodiment, upon receiving user input selecting a SOM node, the GUI tool  displays a visualization  of the SOM node. Because a SOM node includes a weight vector that represents kinematic data such as position, velocity, size, and acceleration of foreground objects observed in a scene, the visualization  may be derived from the weight vector of the SOM node. The GUI tool may superimpose the visualization  over a background model representing the scene, according to one embodiment. In particular, the GUI tool may visually distinguish a segment  from a sequence  (e.g., by color). For example, in the scenario of the picnic table previously described, the segment corresponding to the person walking to the picnic table may be set apart from the sequence corresponding to the person walking to the picnic table, smoking, and leaving the picnic table.","Aside from selecting a cluster by clicking on the SOM, a user may also select a cluster from the list  of clusters, according to one embodiment. Further, a user may navigate through the list  of clusters (e.g., using arrow keys of a keyboard or using a scroll bar for the list  of clusters). Upon receiving user input selecting a cluster (e.g., from the list  of clusters or from the SOM ), the GUI tool  may highlight, in the visualization  of the SOM, SOM nodes belonging to the cluster. Further, the GUI tool may also display a visualization  of the SOM nodes belonging to the cluster. The visualization  may be derived from the weight vectors of the SOM nodes belonging to the cluster. Specifically, the GUI tool may display a visualization of each SOM node belonging to the cluster. The GUI tool may also display a visualization of a statistical average of all SOM nodes belonging to the cluster. The GUI tool  may distinguish the visualization of the statistical average from the visualizations of the SOM nodes (e.g., by color). The GUI tool may superimpose the visualizations over a background model representing the scene, according to one embodiment.","As shown, the count  of clusters indicates that the ART network classifies the nodes of the SOM into a total of twenty-four clusters. Further, the count  of segments indicates that the voting expert partitions a sequence of cluster identifiers (as described above, for nodes in each adjusted SOM that a foreground objects maps to) into a total of five hundred and two segments.","A user may select a segment from the list  of segments, according to one embodiment. Further, the user may navigate through the list  of segments (e.g., using arrow keys of a keyboard or using a scroll bar for the list  of segments). Upon receiving user input selecting a segment, the GUI tool  may display a visualization  of the selected segment. For example, GUI tool  may represent each cluster label of the segment using an arrow superimposed over a background model for the scene. The GUI tool  may determine the appearance of each arrow based on the respective cluster symbol. For example, the color of an arrow may represent a velocity of the object, while the size of an arrow may represent the size of the foreground object. Of course, the manner in which segments are visually represented may be adapted to suit the needs of a particular case.","In one embodiment, the GUI tool  may also display properties  of the selected segment. As shown, the properties  of the segment include an identifier for the segment, a symbol of the segment, whether to alert upon detecting behavior of a foreground object that matches the segment, a length of the segment, and other data for the segment. The user may supply or modify the symbol or label for the segment, according to one embodiment. Further, the user may also set the machine-learning engine  to alert (or not to alert) whenever the machine-learning engine determines that a series of events matching the segment has occurred.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 6","b":["600","600","610","260","260","620","260","630","260","140","140","640","260","260","270"]},"Further, the GUI tool  may be configured to allow the user to view and\/or modify properties of any segment selected by the user. At step , the transaction server  may output the visual representation for display. After step , the method  terminates.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 7","b":["700","700","710","260","720","260","725","730","260","140","735","740","260","140","745","725","735","745","260","750","740","750","700"]},"Advantageously, embodiments of the invention provide users with a visualization of data observed by a machine-learning engine of a behavior recognition system. Further, the visualization may provide an interface used to guide system behavior. In one embodiment, a GUI tool allows a user to visualize and manipulate segments derived by a video surveillance system. For example, users may specify that observations that match an existing segment is to always (or never) result in an alert. Further, the GUI tool may allow users to modify other various properties associated with a segment, including semantic labels used to name the segment.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features, advantages, and objects of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments illustrated in the appended drawings.","It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
