---
title: Storage API for a common data platform
abstract: An application program interface (API) for a data platform. The API includes a generic data access component that exposes at least one of stores, sessions, transactions, and query services of the data platform, which data platform is associated with a data store. A data classes component of the API provides canonical, application-independent classes that expose types and relationships of a data model of the data platform. The API includes a domain data classes component of application-specific and framework-specific classes that expose domain-specific properties and behaviors of the data platform. The data platform can be a common data platform that interfaces to the data store to provide data services accessible by a plurality of disparate application frameworks, which data services allow a corresponding application of the different frameworks to access the data store.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07685561&OS=07685561&RS=07685561
owner: Microsoft Corporation
number: 07685561
owner_city: Redmond
owner_country: US
publication_date: 20050802
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Provisional Patent Application Ser. No. 60\/657,522 entitled \u201cSTORAGE API FOR A COMMON DATA PLATFORM\u201d and filed Feb. 28, 2005. This application is related to U.S. Provisional Patent Application Ser. No. 60\/657,556 entitled \u201cPLATFORM FOR DATA SERVICES ACROSS DISPARATE APPLICATION FRAMEWORKS\u201d and filed Feb. 28, 2005, U.S. patent application Ser. No. 11\/171,905 entitled \u201cPLATFORM FOR DATA SERVICES ACROSS DISPARATE APPLICATION FRAMEWORKS\u201d and filed Jun. 30, 2005, U.S. Provisional Patent Application Ser. No. 60\/657,295 entitled \u201cDATA MODEL FOR OBJECT-RELATIONAL DATA\u201d filed on Feb. 28, 2005, and U.S. patent application Ser. No. 11\/228,731 entitled \u201cDATA MODEL FOR OBJECT-RELATIONAL DATA\u201d and filed Sep. 16, 2005. The entireties of the above-noted application are incorporated by reference herein.","Data has become an important asset in almost every application, whether it is a Line-of-Business (LOB) application framework utilized for browsing products and generating orders, or a Personal Information Management (PIM) end-user application used for scheduling a meeting between people. Applications perform both data access\/manipulation and data management operations on the application data. Typical application operations query a collection of data, fetch the result set, execute some application logic that changes the state of the data, and finally, persists the data to the storage medium.","Traditionally, client\/server applications relegated the query and persistence actions to database management systems (DBMS), deployed in the data tier. If there is data-centric logic, it is coded as stored procedures in the database system. The database system operated on data in terms of tables and rows, and the application, in the application tier, operated on the data in terms of programming language objects (e.g., Classes and Structs). The mismatch in data manipulation services (and mechanisms) in the application and the data tiers was tolerable in the client\/server systems. However, with the advent of the web technology (and Service Oriented Architectures) and with wider acceptance of application servers, applications are becoming multi-tier, and more importantly, data is now present in every tier.","In such tiered application architectures, data is manipulated in multiple tiers. In addition, with hardware advances in addressability and large memories, more data is becoming memory resident. Applications are also dealing with different types of data such as objects, files, and XML (eXtensible Markup Language) data, for example.","In such hardware and software environments, the need for rich data access and manipulation services, well-integrated with the programming environments, is increasing. One conventional implementation introduced to address the aforementioned problems is a data platform. The data platform provides a collection of services (mechanisms) for applications to access, manipulate, and manage data that is well integrated with the application programming environment. However, such a conventional architecture falls short in many respects. Some key requirements for such a data platform include complex object modeling, rich relationships, the separation of logical and physical data abstractions, query rich data model concepts, active notifications, better integration with middle-tier infrastructure. Thus, there is a substantial unmet need in the art for an improved data platform.","The following presents a simplified summary in order to provide a basic understanding of some aspects of the disclosed innovation. This summary is not an extensive overview, and it is not intended to identify key\/critical elements or to delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.","The innovation disclosed and claimed herein, in one aspect thereof, comprises an application program interface (API) for a data platform. The API includes a generic data access component that exposes at least one of stores, sessions, transactions, and query services of the data platform, which data platform is associated with a data store. A data classes component of the API provides canonical, application-independent classes that expose types and relationships of a data model of the data platform. The API includes a domain data classes component of application-specific and framework-specific classes that expose domain-specific properties and behaviors of the data platform. The data platform can be a common data platform that interfaces to the data store to provide data services accessible by a plurality of disparate application frameworks, which data services allow a corresponding application of the different frameworks to access the data store.","In another aspect, the API includes five core classes. A TableSet class can be generated from a data model schema and provides strongly typed access to tables defined within the schema. A StorageDomain class defines the store over which the rest of the classes operate. A StorageContext class provides a context for the session. The StorageContext class defines the scope for identity management, change tracking and concurrency conflict handling, with methods for refreshing or saving changes to objects within the current context. StorageSearcher classes are used to build composable object-based queries against the data store. A StorageView class provides a rich application view over a set of results. StorageView classes support operations such as filtering, sorting, scrolling, grouping, sectioning, expanding\/collapsing sections, etc.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the disclosed innovation are described herein in connection with the following description and the annexed drawings. These aspects are indicative, however, of but a few of the various ways in which the principles disclosed herein can be employed and is intended to include all such aspects and their equivalents. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings.","The innovation is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding thereof. It can be evident, however, that the innovation can be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate a description thereof.","As used in this application, the terms \u201ccomponent\u201d and \u201csystem\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, a hard disk drive, multiple storage drives (of optical and\/or magnetic storage medium), an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers.","While certain ways of displaying information to users are shown and described with respect to certain figures as screenshots, those skilled in the relevant art will recognize that various other alternatives can be employed. The terms \u201cscreen,\u201d \u201cweb page,\u201d and \u201cpage\u201d are generally used interchangeably herein. The pages or screens are stored and\/or transmitted as display descriptions, as graphical user interfaces, or by other methods of depicting information on a screen (whether personal computer, PDA, mobile telephone, or other suitable device, for example) where the layout and information or content to be displayed on the page is stored in memory, database, or another storage facility.","A novel common data platform (CDP) is comprised of a common data model (CDM) that describes objects and how they are related, and a persistent store and services for working with in-memory representations of those objects. The CDP provides an innovative platform for working with persistent data as application objects. The CDP includes a novel application programming interface (API) that is custom tailored to the underlying data model and services defined as part of the platform. The functionality of the CDP is exposed through a set of classes. The definition of those classes, including their public members (e.g., methods and properties) comprises the API for working with the objects within the CDP.","Referring initially to the drawings,  illustrates a storage API  of a data platform  (e.g., the CDP) in accordance with an innovative aspect. The API  provides the programming interface for applications using the data platform (e.g., the CDP) in the form of classes, interfaces, and static helper functions. Database programming language integration (e.g., C# sequence operators) is also part of this API layer. In support thereof, the API  includes a CDM data classes component  which is a set of canonical, application-independent classes that expose CDM concepts such as Entity, Relationship, Extension, etc. A generic data access component  is provided as part of the API  to expose stores, sessions, transactions (e.g., StorageContext), query services (e.g., StorageSearcher), and CRUD services (e.g., SaveChanges). CRUD (Create, Retrieve, Update, and Delete) services are the basic processes that are applied to data. The API  also includes a domain data classes component  which are application\/framework-specific classes such as Contact, Message, PurchaseOrders that conform to the CDM, but expose domain-specific properties and behaviors.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["200","202","204","206","208","210"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["106","300","300","300","300"]},"The storage API  consists of the following core classes and , illustrates the relationships between the StorageDomain, StorageContext, TableSet, StorageSearcher and StorageView. Additional classes can be defined in support of these core classes.","TableSet\u2014A TableSet class can be generated from a data model schema and provides strongly typed access to tables defined within the schema. A TableSet instance wraps one or more StorageContext instances, and uses the underlying StorageContext class and associated StorageDomain class for querying, navigating and updating the objects. Additional methods can be added to the generated TableSet class for schema-specific or framework-specific functionality.","StorageDomain\u2014A class that defines the store over which the rest of the classes operate. Different types of stores implement their own specific StorageDomain classes. The StorageDomain may be used directly, or in conjunction with a TableSet.","StorageContext\u2014A class that provides a context for the session. The StorageContext class defines the scope for identity management, change tracking and concurrency conflict handling, with methods for refreshing or saving changes to objects within the current context. The StorageContext class uses a StorageDomain class in order to communicate with the store (for example, in refreshing data or persisting changes). The StorageContext may be used directly, or in conjunction with a TableSet.","StorageSearcher\u2014StorageSearcher classes are used to build composable object-based queries against the data store. The StorageSearcher class generates a StorageExpression class which is executed by a StorageDomain, typically within a StorageContext. The StorageSearcher supports enumerating results in a forward-only, streamed fashion, or construction of a rich, scrollable StorageView.","StorageView\u2014A StorageView class provides a rich application view over a set of results. StorageViews support operations such as filtering, sorting, scrolling, grouping, sectioning, expanding\/collapsing sections, etc.","Referring now to , there is illustrated a methodology of providing a storage API for a data model. At , a data platform (e.g., a CDP) is received for utilization over a data store. At , an API is provided that includes base classes which represent CDM concepts such as for example, entity, relationship, extension. Underlying functionality of the data platform can be exposed to overlying applications and application frameworks via common CDM data classes defined in the API of the subject invention. At , a class is provided that defines the data store over which other API classes operate. At , a class is provided which is used to build object-based queries against the data store. At , a class is provided that defines a session context, and includes identity management, change tracking, conflict handling, etc. At , a class is provided that generates from a schema and provides typed access to tables of the schema. At , a class is provided that facilitates a view of the result set(s). At , a set of domain-specific classes are defined in order to represent the specific entities and relationships described by an instance of a CDM schema.","The following sections detail the class and member definitions that make up the API for a common data model.","StorageDomain Class. The StorageDomain class is used to encapsulate store information, such as server, authentication, mapping, and so forth. A base storage domain class is derived from for each type of store to provide store-specific information. The base StorageDomain type can be defined as follows:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public abstract class StorageDomain : IDisposable"]},{"entry":[{},"{ }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"WinFSDomain Class. An example of a StorageDomain against a WinFS store can look like the following:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class WinFSDomain : StorageDomain"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public WinFSDomain( );"]},{"entry":[{},"\u2003public WinFSDomain(string share);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A WinFSDomain constructor can take information to specify the store and scope within the store, for example, through a UNC (universal naming convention) share name. Alternatively, a default constructor can use default store information, for example, to the root of the default store. The UNC is a standard for identifying servers, printers and other resources in a network, which originated in the UNIX community. A UNC path uses double slashes or backslashes to precede the name of the computer.","SqlStorageDomain Class. An example of a StorageDomain against a relational store (e.g., SQL database) can look like the following:",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class SqlStorageDomain : StorageDomain"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public SqlStorageDomain( );"]},{"entry":[{},"\u2003public SqlStorageDomain(String connectionString);"]},{"entry":[{},"\u2003public SqlStorageDomain(SqlConnection connection, String"]},{"entry":[{},"\u2003\u2003mappingFile);"]},{"entry":[{},"\u2003public SqlStorageDomain(SqlConnection connection,"]},{"entry":[{},"\u2003\u2003IRelationalMapping mapping);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The SqlStorageDomain constructor can take connection information, for example, in the form of a connection string containing connection and mapping information, or a named configuration containing such information. Alternatively, the constructor can take a connection object along with mapping information in the form of a mapping file or an object that implements a standard mapping interface. Alternatively, a default constructor may use default connection or mapping information, for example from a configuration file.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5","b":"500"},{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class TableSet : IDisposable"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public TableSet( StorageContext context, string tableSetName );"]},{"entry":[{},"\u2003public TableSet( StorageDomain domain, string tableSetName );"]},{"entry":[{},"\u2003public TableSet( StateManager manager, string tableSetName);"]},{"entry":[{},"\u2003public void Dispose( );"]},{"entry":[{},"\u2003public StorageContext Context { get; }"]},{"entry":[{},"\u2003public string Name { get; }"]},{"entry":[{},"\u2003public Table<T> GetTable<T>(string propertyName);"]},{"entry":[{},"\u2003public object GetTableSetReference(string propertyName);"]},{"entry":[{},"\u2003public void SaveChanges( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A TableSet is generally constructed with the name of the set of tables within the Schema. Alternatively, the set of tables within the schema can be determined through an alternate mechanism, for example through default naming, a configuration file, etc. A StorageContext can be provided to the TableSet in order to associate the TableSet with an existing StorageContext. Alternatively, a StorageDomain can be provided to the TableSet to associate the TableSet with a StorageDomain. Alternatively still, the TableSet can be provided a common state manager.","At , a SaveChanges method can be provided to save the data objects associated with the table set. An asynchronous version of this method may also be provided. At , a GetTable method can be provided for constructing and returning an object representing a table in schema (e.g., a Table<T>) based on the name provided. At , a GetTableSetReference method can be provided to return a TableSetReference.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":"600"},{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public partial WinFSData : TableSet {"},{"entry":"\u2003public WinFSData( StorageContext context );"},{"entry":"\u2003public WinFSData( StorageContext context, string tableSetName );"},{"entry":"\u2003public WinFSData( );"},{"entry":"\u2003public WinFSData( string share );"},{"entry":"\u2003public Item GetRootItem( ) { }"},{"entry":"\u2003public Item GetItemByPath( string path ) { }"},{"entry":"\u2003public Table<Item> Items { get { } }"},{"entry":"\u2003public Table<Link> Links { get { } }"},{"entry":"\u2003public Table<ItemExtension> ItemExtensions { get { } }"},{"entry":"\u2003public Table<ItemFragment> ItemFragments { get { } }"},{"entry":"\u2003\/\/ Copy methods"},{"entry":"\u2003public Ref<Item> CopyItem(string sourceItemName, string"},{"entry":"\u2003\u2003destinationItemName );"},{"entry":"\u2003public Ref<Item> CopyItem(string sourceItemName, string"},{"entry":"\u2003\u2003destinationItemName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CopyItemOptions options );"},{"entry":"\u2003public Ref<Item> CopyItem(string sourceItemName, string"},{"entry":"\u2003\u2003destinationItemName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003StorageContext destinationContext,"},{"entry":"\u2003\u2003CopyItemOptions options );"},{"entry":"\u2003public Ref<Item> CopyItem( Ref<Item> sourceItemRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Ref<Item> destinationContainerRef );"},{"entry":"\u2003public Ref<Item> CopyItem( Ref<Item> sourceItemRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Ref<Item> destinationContainerRef,"},{"entry":"\u2003\u2003CopyItemOptions options);"},{"entry":"\u2003public Ref<Item> CopyItem( Ref<Item> sourceItemRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Ref<Item> destinationContainerRef, string"},{"entry":"\u2003\u2003newNamespaceName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CopyItemOptions options);"},{"entry":"\u2003public Ref<Item> CopyItem( Item sourceItem, Item"},{"entry":"\u2003\u2003destinationContainer );"},{"entry":"\u2003public Ref<Item> CopyItem( Item sourceItem, Item"},{"entry":"\u2003\u2003destinationContainer,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CopyItemOptions options);"},{"entry":"\u2003public Ref<Item> CopyItem( Item sourceItem, Item"},{"entry":"\u2003\u2003destinationContainer,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string newNamespaceName, CopyItemOptions"},{"entry":"\u2003\u2003options);"},{"entry":"\u2003\/\/ Move Methods"},{"entry":"\u2003public void MoveItem( string sourceItemName, string"},{"entry":"\u2003\u2003destinationItemName );"},{"entry":"\u2003public void MoveItem( string sourceItemName, string"},{"entry":"\u2003\u2003destinationItemName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003MoveItemOptions options );"},{"entry":"\u2003public void MoveItem( Ref<Item> sourceItemRef, Ref<Item>"},{"entry":"\u2003\u2003destinationContainerRef );"},{"entry":"\u2003public void MoveItem( Ref<Item> sourceItemRef, Ref<Item>"},{"entry":"\u2003\u2003destinationContainerRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string newNamespaceName, MoveItemOptions"},{"entry":"\u2003\u2003options );"},{"entry":"\u2003public void MoveItem( Item sourceItem, Item destinationContainer"},{"entry":"\u2003\u2003);"},{"entry":"\u2003public void MoveItem( Item sourceItem, Item"},{"entry":"\u2003\u2003destinationContainer,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string newNamespaceName, MoveItemOptions"},{"entry":"\u2003\u2003options );"},{"entry":"\u2003\/\/ Delete Methods"},{"entry":"\u2003public void DeleteItem ( string itemName );"},{"entry":"\u2003public void DeleteItem ( string itemName, ItemDeleteOptions"},{"entry":"\u2003\u2003options );"},{"entry":"\u2003public void DeleteItem ( Ref<Item> itemRef );"},{"entry":"\u2003public void DeleteItem ( Ref<Item> itemRef, ItemDeleteOptions"},{"entry":"\u2003\u2003options );"},{"entry":"\u2003public void DeleteItem ( Item item );"},{"entry":"\u2003public void DeleteItem ( Item item, ItemDeleteOptions options );"},{"entry":"\u2003\/\/ Export Methods"},{"entry":"\u2003public void ExportItem( string itemName, Stream stream );"},{"entry":"\u2003public void ExportItem( string itemName, string fileName );"},{"entry":"\u2003public void ExportItem( string itemName, string fileName,"},{"entry":"\u2003\u2003\u2003\u2003ExportItemOptions options );"},{"entry":"\u2003public void ExportItem( Ref<Item> itemRef, Stream stream );"},{"entry":"\u2003public void ExportItem( Ref<Item> itemRef, string fileName );"},{"entry":"\u2003public void ExportItem( Ref<Item> itemRef, string fileName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ExportItemOptions options );"},{"entry":"\u2003public void ExportItem( Item item, Stream stream );"},{"entry":"\u2003public void ExportItem( Item item, string fileName );"},{"entry":"\u2003public void ExportItem( Item item, string fileName,"},{"entry":"\u2003\u2003ExportItemOptions options );"},{"entry":"\u2003\/\/ Import Methods"},{"entry":"\u2003public void ImportItem( Stream stream, string itemName );"},{"entry":"\u2003public void ImportItem( string fileName, string itemName );"},{"entry":"\u2003public void ImportItem( string fileName, string itemName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ImportItemOptions options );"},{"entry":"\u2003public void ImportItem( Stream stream, Ref<Item>"},{"entry":"\u2003\u2003containerItemRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string namespaceName );"},{"entry":"\u2003public void ImportItem( Stream stream, Ref<Item>"},{"entry":"\u2003\u2003containerItemRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string namespaceName );"},{"entry":"\u2003public void ImportItem( string fileName, Ref<Item>"},{"entry":"\u2003\u2003containerItemRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string namespaceName );"},{"entry":"\u2003public void ImportItem( string fileName, Ref<Item>"},{"entry":"\u2003\u2003containerItemRef,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string namespaceName,"},{"entry":"\u2003\u2003ImportItemOptions options );"},{"entry":"\u2003public void ImportItem( Stream stream, Item containerItem,"},{"entry":"\u2003\u2003string uniuqeName );"},{"entry":"\u2003public void ImportItem( string fileName, Item containerItem,"},{"entry":"\u2003\u2003string namespaceName );"},{"entry":"\u2003public void ImportItem( string fileName, Item item, string"},{"entry":"\u2003\u2003name spaceName,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ImportItemOptions options );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A WinFSData constructor can be constructed with an existing StorageContext, or may create a StorageContext using specified information (such as a UNC share) or default information (for example, the root of a default store). Additionally, a tableset Name can be specified to associate the WinFSData class with a particular named tableset instance.","At , a GetRootItem method can be provided to return the root of the domain. An asynchronous version of this method can also be provided. At , a GetItemByPath method can be provided in order to return an item given its path. An asynchronous version of this method can also be provided.","At , Items, ItemExtensions and ItemFragments properties can be provided to return objects representing Items, ItemExtensions, and ItemFragments tables. At , a Links property can be provided to return an object representing the Links table. At , methods are provided for copying, moving and deleting items. A CopyItem method can be provided to copy the specified item to another location within a store. A MoveItem method can be provided to move the specified item within a store. A DeleteItem method provides deletion of the specified item from a store. At , methods are provided for importing and exporting items. An ExportItem method can be provided to export the specified item from a store. An ImportItem method can be provided to import the specified item into a store. Asynchronous versions of the CopyItem method, MoveItem method, DeleteItem method, ExportItem method and ImportItem method can also be provided.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7","b":"700"},{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class Table<T> {"]},{"entry":[{},"\u2003public Table(StorageContext context, string TableName);"]},{"entry":[{},"\u2003public Table(StorageDomain domain, string TableName);"]},{"entry":[{},"\u2003public StorageContext Context { get; internal set;}"]},{"entry":[{},"\u2003public StorageDomain Domain { get; internal set;}"]},{"entry":[{},"\u2003public StorageSearcher<T> Searcher { get; }"]},{"entry":[{},"\u2003\/\/ Support ICollection"]},{"entry":[{},"\u2003bool ICollection<T>.Add(T obj);"]},{"entry":[{},"\u2003void ICollection<T>.Remove(T obj);"]},{"entry":[{},"\u2003void ICollection<T>.Clear( );"]},{"entry":[{},"\u2003bool ICollection<T>.Contains(T t);"]},{"entry":[{},"\u2003public virtual int Count { get; }"]},{"entry":[{},"\u2003void ICollection<T>.CopyTo(T[ ] array, int arrayIndex);"]},{"entry":[{},"\u2003bool ICollection<T>.IsReadonly { get { }}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The Table<T> class can be constructed with information that specifies the StorageContext or StorageDomain, along with the name of the corresponding table in the schema. At , a Context property can be provided in order to return the StorageContext associated with the Table<T> class. At , a Domain property can be provided in order to return the StorageDomain associated with the Table<T> class. At , a Searcher property can be exposed in order to return a StorageSearcher against the corresponding table in the store. At , methods are provided for adding, removing, and clearing objects. An Add method can be exposed in order to add an object to the table. A Remove method can be exposed in order to specify an object to be removed from the table. A Clear method can be exposed in order to clear the table. At , a Contains method can be exposed in order to return whether or not the table contains a specified object. At , a Count method can be exposed in order to specify the total number of objects within the table. At , a method is provided that copies objects into a table. At , a property is provided that exposes if a table is read-only. A CopyTo method can be exposed in order to copy the specified objects into the table. An IsReadOnly property can be exposed in order to return whether or not the table can be added to or removed from.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class StorageContext : IDisposable {"},{"entry":"\u2003public StorageContext( );"},{"entry":"\u2003public StorageContext(StorageDomain domain);"},{"entry":"\u2003public object GetObjectByKey(StorageKey key);"},{"entry":"\u2003public StorageKey GetObjectKey(object o);"},{"entry":"\u2003public void SaveChanges( );"},{"entry":"\u2003public void Refresh(RefreshMode options, IEnumerable<object>"},{"entry":"\u2003\u2003objects);"},{"entry":"\u2003public void Refresh(RefreshMode options, params object[ ] objects);"},{"entry":"\u2003public void Dispose( );"},{"entry":"\u2003public StorageDomain Domain { get; }"},{"entry":"\u2003public void Add(object o);"},{"entry":"\u2003public void MarkForDeletion(object o);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The StorageContext is constructed given a StorageDomain, which provides store information. Alternatively, a StorageContext can be constructed with no StorageDomain and obtain store information from a default source, such as a configuration file.","At , a method is provided that returns an object via a key. GetObjectByKey method can be provided to return the object within the StorageContext associated with a particular key. This method could alternatively be broken out into a separate StateManagement object. An asynchronous version of this method may also be provided. At , a GetObjectKey method can be provided to return the key associated with a particular object within the StorageContext. This method can alternatively be broken out into a separate StateManagement object. At , a SaveChanges method can be provided to save additions, deletions, or modifications to object within the StorageContext. An asynchronous version of this method may also be provided.","At , a Refresh method can be provided to refresh the objects within the StorageContext with the current store values. An explicit set of objects to refresh can be specified, for example through an enumerator or as parameters. Additional options can be specified to control how change conflicts are handled. An asynchronous version of this method can also be provided. At , an Add method can be provided to associate a new object with the StorageContext. This method could alternatively be broken out into a separate StateManagement object. At , a MarkForDeletion method can be provided to mark an object within the StorageContext to be deleted when SaveChanges is called. This method can alternatively be broken out into a separate StateManagement object. At , a StorageDomain property can be provided to return the StorageDomain associated with the StorageContext.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 9","b":"900"},{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class StorageSearcher<T> : IStorageSearcher, IEnumerable<T>"},{"entry":"\u2003where T : class"},{"entry":"{"},{"entry":"\u2003public StorageSearcher(string expression);"},{"entry":"\u2003public StorageSearcher(string expression, object[ ] parameters);"},{"entry":"\u2003public StorageSearcher(string expression, object[ ] parameters,"},{"entry":"\u2003\u2003StorageContext context);"},{"entry":"\u2003public StorageSearcher(StorageExpression expression);"},{"entry":"\u2003public StorageSearcher(StorageExpression expression,"},{"entry":"\u2003\u2003StorageContext context);"},{"entry":"\u2003public StorageSearcher(string expression, object[ ] parameters,"},{"entry":"\u2003\u2003StorageDomain store);"},{"entry":"\u2003public StorageSearcher(StorageExpression expression,"},{"entry":"\u2003\u2003StorageDomain store);"},{"entry":"\u2003public StorageContext Context { get; }"},{"entry":"\u2003public StorageDomain Domain { get; }"},{"entry":"\u2003public StorageExpression Expression { get; }"},{"entry":"\u2003Type IStorageSearcher.ResultType { get; }"},{"entry":"\u2003public StorageSearcher<T> BindContext(StorageContext context);"},{"entry":"\u2003IStorageSearcher IStorageSearcher.BindContext(StorageContext"},{"entry":"\u2003\u2003context);"},{"entry":"\u2003public StorageSearcher<T> BindParameters(IDictionary<string,"},{"entry":"\u2003\u2003object> parameters);"},{"entry":"\u2003IStorageSearcher IStorageSearcher.BindParameters(IDictionary"},{"entry":"\u2003\u2003parameters);"},{"entry":"\u2003public StorageSearcher<T> Filter(string expression, params"},{"entry":"\u2003\u2003object[ ] parameters);"},{"entry":"\u2003public StorageSearcher<U> FilterByType<U>( ) where U : T;"},{"entry":"\u2003public StorageSearcher<U> TreatAsType<U>( );"},{"entry":"\u2003public StorageSearcher<T> Sort(string expression, params"},{"entry":"\u2003\u2003object[ ] parameters);"},{"entry":"\u2003public StorageSearcher<StorageRecord> Project(string expression,"},{"entry":"\u2003\u2003params object[ ] parameters);"},{"entry":"\u2003public StorageSearcher<StorageRecord> Group(string expression,"},{"entry":"\u2003\u2003params object[ ] parameters);"},{"entry":"\u2003public StorageSearcher<T> Union(StorageSearcher<T> searcher);"},{"entry":"\u2003public StorageSearcher<U> Query<U>(string expression, params"},{"entry":"\u2003\u2003object[ ] parameters);"},{"entry":"\u2003public StorageSearcher<U> Query<U>(StorageExpression"},{"entry":"\u2003\u2003expression);"},{"entry":"\u2003IStorageSearcher IStorageSearcher.Query(Type resultType,"},{"entry":"\u2003\u2003StorageExpression expression);"},{"entry":"\u2003IStorageSearcher IStorageSearcher.Query(Type resultType, string"},{"entry":"\u2003\u2003expression,"},{"entry":"\u2003\u2003\u2003params object[ ] parameters);"},{"entry":"\u2003public IEnumerator<T> GetEnumerator( );"},{"entry":"\u2003IEnumerator IEnumerable.GetEnumerator( );"},{"entry":"\u2003public T GetFirst( );"},{"entry":"\u2003object IStorageSearcher.GetFirst( );"},{"entry":"\u2003public int GetCount( );"},{"entry":"\u2003public List<T> GetList( );"},{"entry":"\u2003public StorageView<StorageViewRecord> CreateView( );"},{"entry":"\u2003public StorageView<StorageViewRecord>"},{"entry":"\u2003\u2003CreateView(StorageViewDefinition definition);"},{"entry":"\u2003public StorageView<StorageViewRecord> CreateView("},{"entry":"\u2003\u2003StorageViewDefinition definition, StorageViewOptions options);"},{"entry":"\u2003public StorageView<T> CreateView<T> (StorageViewDefinition"},{"entry":"\u2003\u2003definition, StorageViewOptions options) where T :"},{"entry":"\u2003\u2003StorageViewRecord { }"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A StorageSearcher can be constructed with a StorageContext or StorageDomain to specify the context or store to which the StorageSearcher is bound. Additionally, a query expression can be specified to initialize a StorageSearcher, either as a string or StorageExpression object tree.","At , a Query method can be provided to construct a new StorageSearcher that encapsulates an arbitrary query expression. At , filter methods are provided. A Filter method can be provided to construct a new StorageSearcher that encapsulates a filter over the query results that would be produced by the input searcher. A FilterByType method can be provided to construct a new StorageSearcher that encapsulates a filter over the query results that would be produced by the input searcher. A TreatAsType method can be provided to construct a new StorageSearcher that treats the query results that would be produced by the input searcher as a different type.","At , Sort, Project, Group, and Union methods are provided. A Sort method can be provided to construct a new StorageSearcher that encapsulates a sort of the query results that would be produced by the input searcher. A Project method can be provided to construct a new StorageSearcher that encapsulates a projection of the query results that would be produced by the input searcher. A Group method can be provided to construct a new StorageSearcher that encapsulates a grouping of the query results that would be produced by the input searcher. A Union method can be provided to construct a new StorageSearcher that encapsulates the union of the query results that would be produced by two input searchers. The above are only examples and are not to be construed as limiting. Additional methods can be provided on the StorageSearcher to represent additional query operations. In other words, query operations can be exposed as methods on the StorageSearcher class that returns new StorageSearchers.","At , a GetEnumerator method can be provided to return an enumerator that can be used to access query results. An asynchronous version of this method can also be provided. At , methods are provided that return a first result of a query. Asynchronous versions of these methods can also be provided. A GetFirst method can be provided to return the first result. An asynchronous version of this method can also be provided. GetCount method can be provided to return a count of the results. An asynchronous version of this method can also be provided. At , CreateView method can be provide to create a StorageView from the StorageSearcher query. The CreateView method may take a StorageViewDefinition with or without additional options to specify information specific to the view.","The StorageRecord class is used as the result type of a searcher when the query will return data that doesn't correspond to any particular application defined type. For example, the result of a Project or Group operation is a collection of StorageRecord objects.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ StorageRecord represents a value in a structurally typed query"]},{"entry":[{},"\u2003\u2003result."]},{"entry":[{},"public class StorageRecord :"]},{"entry":[{},"\u2003\u2003System.ComponentModel.ICustomTypeDescriptor"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/ Gets the value of a field"]},{"entry":[{},"\u2003public object this[string name] { get; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 10","b":"1000"},{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"sealed public class StorageView<T> : IVirtualList,"},{"entry":"\u2003\u2003IServiceContainer, IEnumerable, IListSource, IDisposable"},{"entry":"\u2003where T: StorageViewRecord"},{"entry":"{"},{"entry":"\u2003public StorageViewDefinition CopyDefinition( ) { }"},{"entry":"\u2003public void ApplyDefinition(StorageViewDefinition definition) {"},{"entry":"\u2003\u2003}"},{"entry":"\u2003public int Count { get;}"},{"entry":"\u2003public T Current { get;}"},{"entry":"\u2003public T this[ViewRecordBookmark bookmark] {get;}"},{"entry":"\u2003public T FindRecord(ViewRecordBookmark bookmark, bool forward,"},{"entry":"\u2003\u2003string expression, params object[ ] parameters) { }"},{"entry":"\u2003public T FindRecord(StorageViewSeekOrigin seekOrigin, bool"},{"entry":"\u2003\u2003forward, string expression, params object[ ] parameters) { }"},{"entry":"\u2003public void MoveCurrentPosition(StorageViewSeekOrigin"},{"entry":"\u2003\u2003seekOrigin, int offset);"},{"entry":"\u2003public void MoveCurrentPosition(ViewRecordBookmark bookmark, int"},{"entry":"\u2003\u2003offset);"},{"entry":"\u2003public void Refresh( ) { }"},{"entry":"\u2003public ViewRecordBookmark GetBookmarkFromBinary(byte[ ]"},{"entry":"\u2003\u2003bookmark) { }"},{"entry":"\u2003public byte[ ] GetBinaryFromBookmark(ViewRecordBookmark"},{"entry":"\u2003\u2003bookmark) { }"},{"entry":"\u2003public void CollapseSection(params object[ ] sectionValues){ }"},{"entry":"\u2003public void CollapseSection(ViewRecordBookmark bookmark){ }"},{"entry":"\u2003public void ExpandSection(params object[ ] sectionValues){ }"},{"entry":"\u2003public void ExpandSection(ViewRecordBookmark bookmark){ }"},{"entry":"\u2003public void CollapseAllSections( ) { }"},{"entry":"\u2003public void ExpandAllSections( ) { }"},{"entry":"\u2003public void ExpandSectionLevel(int sectionLevel){ }"},{"entry":"\u2003public void LoadSectionExpandState(System.Xml.XmlReader reader);"},{"entry":"\u2003public void SaveSectionExpandState(System.Xml.XmlWriter writer);"},{"entry":"\u2003public void SetExtendedFields(StorageViewRecord[ ] records,"},{"entry":"\u2003\u2003string fields);"},{"entry":"\u2003public IList IListSource.GetList( );"},{"entry":"\u2003public event ViewChangedEventHandler ViewChanged;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"At , a CopyDefinition method can be provided to create a new instance of the StorageViewDefinition. An ApplyDefinition method can be provided to apply the specified StorageViewDefinition to the current StorageView. An asynchronous version of this method may also be provided. At , methods are provided for finding records, returning record counts, and a current record. A FindRecord method can be provided to find a StorageViewRecord within the current StorageView according to the specified filter, relative to a specified position or bookmark. An asynchronous version of this method may also be provided. A Count method can be provided to return the number of records within the current StorageView. An asynchronous version of this method may also be provided. A Current method can be provided in order to return the current StorageViewRecord within the StorageView.","At , an indexed accessor (e.g., this[ ]) can be provided in order to return the StorageViewRecord for a given Bookmark. An asynchronous version of this method may also be provided. At , methods are provided for moving position and refreshing a view. A MoveCurrentPosition method can be provided in order to move the current position within the StorageView according to a specified position or bookmark and offset. An asynchronous version of this method may also be provided. A Refresh method can be provided in order to refresh the data within a static StorageView with the current values from the store. An asynchronous version of this method may also be provided. At , methods are provided to get bookmarks and binary representation thereof. A GetBookmarkFromBinary method can be provided in order to get a bookmark from a persistent binary representation. A GetBinaryFromBookmark method can be provided in order to get a persistent binary representation from a Bookmark.","At , methods are provided for expanding, collapsing sections, levels and fields. A CollapseAllSections method can be provided in order to collapse all sections defined within the StorageView. An asynchronous version of this method may also be provided. An ExpandAllSections method can be provided in order to expand all sections defined within the StorageView. An asynchronous version of this method may also be provided. An ExpandSectionLevel method can be provided in order to expand all sections up to and including the specified level. An asynchronous version of this method may also be provided.","At , a method is provided for extending fields of records. A SetExtendedFields method can be provided in order to define extended fields associated with a set of StorageViewRecords. At , methods are provided for saving and loading state of expanded sections. A LoadSectionExpandState method can be provided to load the state specifying the set of sections that are expanded. An asynchronous version of this method may also be provided. A SaveSectionExpandState method can be provided in order to save the state specifying the set of sections that are expanded. The StorageView may expose a ViewChanged event for notifying the listener when the StorageView has changed.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 11","b":"1100"},{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class StorageViewDefinition"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public string Sort { get; set;}"]},{"entry":[{},"\u2003public IList<StorageViewSection> Sections { get;}"]},{"entry":[{},"\u2003public int SectionExpandLevel { get; set; }"]},{"entry":[{},"\u2003public string Filter { get; set;}"]},{"entry":[{},"\u2003public void SetFilter(string expression, params object[ ]"]},{"entry":[{},"\u2003\u2003parameters);"]},{"entry":[{},"\u2003public string Fields { get; set;}"]},{"entry":[{},"\u2003public void SetFields(string expression, params object[ ]"]},{"entry":[{},"\u2003\u2003parameters);"]},{"entry":[{},"\u2003public IDictionary<string,object> Parameters { get;}"]},{"entry":[{},"\u2003public bool AutoRefresh { get; set; }"]},{"entry":[{},"\u2003public int PageSize { get; set;}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"At , a Sort property can be provided to get or set the sort criteria for the StorageView. At , properties are provided for altering and expanding sections. A Sections property can be provided in order to alter the list of Sections defined within the StorageView. A SectionExpandLevel property can be provided in order to expand the sections up to and including the specified level. At , a property and a method are provided for filtering operations. A Filter property can be exposed in order to filter the StorageView to expose only those StorageViewRecords matching the specified filter condition. A SetFilter method can be exposed in order to filter the StorageView to expose only those StorageViewRecords matching the specified filter condition using the specified parameters. At , a property and a method are provided that limit exposed fields. A Fields property can be exposed in order to limit the fields exposed by the StorageView to those Fields specified. A Fields method can be exposed in order to limit the fields exposed by the StorageView to those Fields specified using the specified parameters.","At , a collection is provided that lists parameters utilized by filter, sort, and sections. A Parameters collection can be exposed listing the parameters used by the filter, sort, and sections specifications. At , a Boolean AutoRefresh property can be exposed in order to specify whether or not the StorageView is automatically kept in sync with changes to the store. At , a PageSize property can be exposed in order specify the number of StorageViewRecords to be retrieved at a time from the store.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 12","b":"1200"},{"@attributes":{"id":"p-0085","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class StorageViewRecord : StorageRecord, IPropertyChange"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public virtual bool IsSectionRecord { get; }"]},{"entry":[{},"\u2003public virtual int SectionLevel { get; }"]},{"entry":[{},"\u2003public virtual string SectionName { get; }"]},{"entry":[{},"\u2003public virtual bool IsSectionExpanded { get; }"]},{"entry":[{},"\u2003public virtual ViewRecordBookmark Bookmark { get; }"]},{"entry":[{},"\u2003protected virtual void SetValueinRecord(int i, object value);"]},{"entry":[{},"\u2003protected virtual void SetValueinRecord(string name, object"]},{"entry":[{},"\u2003\u2003value);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"At , an IsSectionRecord property can be exposed in order to return whether or not the StorageViewRecord represents a section header record in the StorageView. At , properties are provided for section information. A SectionLevel property can be exposed in order to return the level of the StorageViewRecord within the StorageView. A SectionName property can be exposed in order to return the name of the section within the StorageView. An IsSectionExpanded property can be exposed in order to return whether or not the section is expanded. At , a Bookmark property can be exposed in order to return a bookmark for the current StorageViewRecord. At , a SetValueinRecord method can be exposed in order to set the value of the specified field within the StorageViewRecord. The field can be specified by name or by ordinal.","A StorageViewSection is used to define a section (group) within a StorageView.",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class StorageViewSection"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public StorageViewSection(string field) { }"]},{"entry":[{},"\u2003public string Field { get; }"]},{"entry":[{},"\u2003public string AggregateFields { get; set; }"]},{"entry":[{},"\u2003public string Sort { get; set; }"]},{"entry":[{},"\u2003public string Having { get; set; }"]},{"entry":[{},"\u2003public void SetHaving(string expression, params object[ ]"]},{"entry":[{},"\u2003\u2003parameters);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The StorageViewSection can be constructed specifying the field within a StorageView on which the section is being defined. A Field property can be exposed to return the field within the StorageView on which the section is defined. An AggregateFields property can be exposed in order to get or set the aggregates to calculate for the section. A Sort property can be exposed in order to specify an ordering for the StorageViewRecords within the section. A Having property can be exposed in order to restrict the StorageViewRecords according to the Aggregate fields specified. A SetHaving method can be exposed in order to restrict the StorageViewRecords according to the Aggregate fields specified along with a set of parameters.","A StorageCollection<T> class is used to represent a strongly typed collection of objects whose population can be deferred. For example, a StorageCollection can be used in a collection property of a parent object. The StorageCollection can be populated explicitly or implicitly when its content is accessed.",{"@attributes":{"id":"p-0091","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class StorageCollection<T> : ICollection<T>, IBindingList,"]},{"entry":[{},"\u2003\u2003ITypedList {"]},{"entry":[{},"\u2003public StorageCollection( );"]},{"entry":[{},"\u2003public StorageCollection(object parent, StorageContext ctx,"]},{"entry":[{},"\u2003\u2003string role);"]},{"entry":[{},"\u2003public StorageContext Context { get; internal set;}"]},{"entry":[{},"\u2003public StorageDomain Domain { get; internal set;}"]},{"entry":[{},"\u2003public void Fill( );"]},{"entry":[{},"\u2003public void Fill(StorageSearcher<T> searcher);"]},{"entry":[{},"\u2003public void Fill(IEnumerable<T> values);"]},{"entry":[{},"\u2003public bool IsFilled { get;}"]},{"entry":[{},"\u2003public void Reset( );"]},{"entry":[{},"\u2003public StorageSearcher<T> Searcher { get; }"]},{"entry":[{},"\u2003public IEnumerator<T> GetEnumerator( );"]},{"entry":[{},"\u2003\/\/ Support for ICollection"]},{"entry":[{},"\u2003bool ICollection<T>.Add(T obj);"]},{"entry":[{},"\u2003void ICollection<T>.Remove(T obj);"]},{"entry":[{},"\u2003void ICollection<T>.Clear( );"]},{"entry":[{},"\u2003bool ICollection<T>.Contains(T t);"]},{"entry":[{},"\u2003public virtual int Count { get; }"]},{"entry":[{},"\u2003void ICollection<T>.CopyTo(T[ ] array, int arrayIndex);"]},{"entry":[{},"\u2003bool ICollection<T>.IsReadOnly { get { } }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The StorageCollection can be constructed with information specifying the StorageContext or StorageDomain, parent object, and role associated with the StorageCollection, for example if the StorageCollection represents the objects within a collection property of a parent object.","A Context property can be provided in order to return the StorageContext associated with the StorageCollection. A Domain property can be provided in order to return the StorageDomain associated with the StorageCollection. A Fill method can be provided in order to add objects to the collection. The fill method can take an IEnumerable<T> or a StorageSearcher, or can use the parent and role properties, along with a StorageDomain or StorageContext, in order to generate a request to populate the StorageCollection. An IsFilled property can be exposed in order to return whether or not the StorageCollection has been populated. A Reset method can be exposed in order to reset the StorageCollection.","A Searcher property can be exposed in order to return a StorageSearcher against the store corresponding to definition of the collection. A GetEnumerator method can be exposed in order to return an enumerator over the contents of the StorageCollection. An Add method can be exposed in order to add an object to the StorageCollection. A Remove method can be exposed in order to remove an object from the StorageCollection. A Clear method can be exposed in order to clear the StorageCollection. A Contains method can be exposed in order to return whether or not the StorageCollection contains a specified object instance. A Count method can be exposed in order to specify the total number of objects within the StorageCollection. A CopyTo method can be exposed in order to copy the specified objects into the StorageCollection. An IsReadOnly property can be exposed in order to return whether or not the StorageCollection can be added to or removed from.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 13","b":["1300","100","1302","1302","1304","1306","1302","1302","100","1304","1308","1310","100","1302"]},"The CDP runtime component  is a layer that implements the various features exposed in the public API layer . It implements the common data model by providing object-relational mapping and query mapping, enforcing data model constraints, etc. More specifically, the CDP runtime  includes: a common data model component implementation; a query processor component; a sessions and transactions component; an object cache, which can include a session cache and an explicit cache; a services component that includes change tracking, conflict detection, and eventing; a cursors and rules component; a business logic hosting component; and a persistence and query engine, which provides the core persistence and query services. Internal to persistence and query services are the object-relational mappings, including query\/update mappings. The CDP  also includes the constraint\/security engine  which provides for applying constraints against the data store  and security policies, for example, role-based security.","Referring now to , there is illustrated a block diagram of a computer operable to execute the disclosed API architecture. In order to provide additional context for various aspects of the subject invention,  and the following discussion are intended to provide a brief, general description of a suitable computing environment  in which the various aspects of the invention can be implemented. While the invention has been described above in the general context of computer-executable instructions that may run on one or more computers, those skilled in the art will recognize that the invention also can be implemented in combination with other program modules and\/or as a combination of hardware and software.","Generally, program modules include routines, programs, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, minicomputers, mainframe computers, as well as personal computers, hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which can be operatively coupled to one or more associated devices.","The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules can be located in both local and remote memory storage devices.","A computer typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer and includes both volatile and non-volatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media can comprise computer storage media and communication media. Computer storage media includes both volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital video disk (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computer.","Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","With reference again to , the exemplary environment  for implementing various aspects of the invention includes a computer , the computer  including a processing unit , a system memory  and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various commercially available processors. Dual microprocessors and other multi-processor architectures may also be employed as the processing unit .","The system bus  can be any of several types of bus structure that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures. The system memory  includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) is stored in a non-volatile memory  such as ROM, EPROM, EEPROM, which BIOS contains the basic routines that help to transfer information between elements within the computer , such as during start-up. The RAM  can also include a high-speed RAM such as static RAM for caching data.","The computer  further includes an internal hard disk drive (HDD)  (e.g., EIDE, SATA), which internal hard disk drive  may also be configured for external use in a suitable chassis (not shown), a magnetic floppy disk drive (FDD) , (e.g., to read from or write to a removable diskette ) and an optical disk drive , (e.g., reading a CD-ROM disk  or, to read from or write to other high capacity optical media such as the DVD). The hard disk drive , magnetic disk drive  and optical disk drive  can be connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface  and an optical drive interface , respectively. The interface  for external drive implementations includes at least one or both of Universal Serial Bus (USB) and IEEE 1394 interface technologies. Other external drive connection technologies are within contemplation of the subject invention.","The drives and their associated computer-readable media provide non-volatile storage of data, data structures, computer-executable instructions, and so forth. For the computer , the drives and media accommodate the storage of any data in a suitable digital format. Although the description of computer-readable media above refers to a HDD, a removable magnetic diskette, and a removable optical media such as a CD or DVD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as zip drives, magnetic cassettes, flash memory cards, cartridges, and the like, may also be used in the exemplary operating environment, and further, that any such media may contain computer-executable instructions for performing the methods of the invention.","A number of program modules can be stored in the drives and RAM , including an operating system , one or more application programs , other program modules  and program data . All or portions of the operating system, applications, modules, and\/or data can also be cached in the RAM . It is appreciated that the invention can be implemented with various commercially available operating systems or combinations of operating systems.","A user can enter commands and information into the computer  through one or more wired\/wireless input devices, e.g., a keyboard  and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, an IR remote control, a joystick, a game pad, a stylus pen, touch screen, or the like. These and other input devices are often connected to the processing unit  through an input device interface  that is coupled to the system bus , but can be connected by other interfaces, such as a parallel port, an IEEE 1394 serial port, a game port, a USB port, an IR interface, etc.","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , a computer typically includes other peripheral output devices (not shown), such as speakers, printers, etc.","The computer  may operate in a networked environment using logical connections via wired and\/or wireless communications to one or more remote computers, such as a remote computer(s) . The remote computer(s)  can be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory\/storage device  is illustrated. The logical connections depicted include wired\/wireless connectivity to a local area network (LAN)  and\/or larger networks, e.g., a wide area network (WAN) . Such LAN and WAN networking environments are commonplace in offices and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communications network, e.g., the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a wired and\/or wireless communication network interface or adapter . The adaptor  may facilitate wired or wireless communication to the LAN , which may also include a wireless access point disposed thereon for communicating with the wireless adaptor .","When used in a WAN networking environment, the computer  can include a modem , or is connected to a communications server on the WAN , or has other means for establishing communications over the WAN , such as by way of the Internet. The modem , which can be internal or external and a wired or wireless device, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, can be stored in the remote memory\/storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with any wireless devices or entities operatively disposed in wireless communication, e.g., a printer, scanner, desktop and\/or portable computer, portable data assistant, communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi and Bluetooth\u2122 wireless technologies. Thus, the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices.","Wi-Fi, or Wireless Fidelity, allows connection to the Internet from a couch at home, a bed in a hotel room, or a conference room at work, without wires. Wi-Fi is a wireless technology similar to that used in a cell phone that enables such devices, e.g., computers, to send and receive data indoors and out; anywhere within the range of a base station. Wi-Fi networks use radio technologies called IEEE 802.11 (a, b, g, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wired networks (which use IEEE 802.3 or Ethernet). Wi-Fi networks operate in the unlicensed 2.4 and 5 GHz radio bands, at an 11 Mbps (802.11a) or 54 Mbps (802.11b) data rate, for example, or with products that contain both bands (dual band), so the networks can provide real-world performance similar to the basic 10BaseT wired Ethernet networks used in many offices.","Referring now to , there is illustrated a schematic block diagram of an exemplary computing environment  in accordance with the subject invention. The system  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The client(s)  can house cookie(s) and\/or associated contextual information by employing the invention, for example.","The system  also includes one or more server(s) . The server(s)  can also be hardware and\/or software (e.g., threads, processes, computing devices). The servers  can house threads to perform transformations by employing the invention, for example. One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and\/or associated contextual information, for example. The system  includes a communication framework  (e.g., a global communication network such as the Internet) that can be employed to facilitate communications between the client(s)  and the server(s) .","Communications can be facilitated via a wired (including optical fiber) and\/or wireless technology. The client(s)  are operatively connected to one or more client data store(s)  that can be employed to store information local to the client(s)  (e.g., cookie(s) and\/or associated contextual information). Similarly, the server(s)  are operatively connected to one or more server data store(s)  that can be employed to store information local to the servers .","What has been described above includes examples of the disclosed innovation. It is, of course, not possible to describe every conceivable combination of components and\/or methodologies, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the innovation is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
