---
title: Generic USB drivers
abstract: Techniques are disclosed to provide generic USB drivers. More particularly, a generic USB device driver architecture is described which enables development through a user-mode USB library that accesses a generic kernel-mode driver. In a described implementation, a method includes loading a kernel-mode generic device driver in response to a plug-in event of a device. A user software component accesses the device by utilizing routines provided by the generic user-mode library (e.g., a dynamic link library (DLL)) that communicates with the generic device driver.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07802022&OS=07802022&RS=07802022
owner: Microsoft Corporation
number: 07802022
owner_city: Redmond
owner_country: US
publication_date: 20040429
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","DeviceHandle","InterfaceHandle","InterfaceHandle","InterfaceHandle","AlternateInterfaceNumber","UsbAltInterfaceDescriptor","InterfaceHandle","InformationType","BufferLength","Buffer","DEVICE_SPEED (0x01)","PHYSICAL_DEVICE_ID (0x02)","InterfaceHandle","DescriptorType","Index","LanguageID","Buffer","BufferLength","LengthTransferred","InterfaceHandle","InterfaceNumber","InterfaceHandle","InterfaceNumber","InterfaceHandle","AlternateInterfaceNumber","PipeIndex","PipeInformation","InterfaceHandle","PipeID","PolicyType","ValueLength","Value","SHORT_PACKET_TERMINATE (0x01)","AUTO_CLEAR_STALL (0x02)","PIPE_TRANSFER_TIMEOUT (0x03)","IGNORE_SHORT_PACKETS (0x04)","ALLOW_PARTIAL_READS (0x05)","AUTO_FLUSH (0x06)","Raw_IO (0x07)","InterfaceHandle","PipeID","PolicyType","ValueLength","Value","InterfaceHandle","PipeID","PolicyType","ValueLength","Value","FIFO_SIZE (0x01)","NOTIFICATION_THRESHOLD (0x03)","InterfaceHandle","PipeID","PolicyType","ValueLength","Value","InterfaceHandle","PipeID","FifoDataNotification","FifoDataNotificationContext","InterfaceHandle","PipeID","InterfaceHandle","PipeID","Buffer","BufferLength","LengthTransferred","Overlapped","InterfaceHandle","PipeID","Buffer","BufferLength","LengthTransferred","Overlapped","InterfaceHandle","PipeID","Buffer","BufferLength","LengthTransferred","Overlapped","InterfaceHandle","SetupPacket","Buffer","BufferLength","LengthTransferred","Overlapped","InterfaceHandle","PipeID","InterfaceHandle","PipeID","InterfaceHandle","PipeID","InterfaceHandle","PolicyType","ValueLength","Value","AUTO_SUSPEND (0x01)","ENABLE_WAKE (0x02)","SUSPEND_DELAY (0x03)","InterfaceHandle","PolicyType","ValueLength","Value","InterfaceHandle","InterfaceHandle","CONCLUSION"],"p":["A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. \u00a92004 Microsoft Corporation. All rights reserved.","The present invention generally relates to digital communications and, in an implementation, to generic universal serial bus (USB) drivers.","As computers become more commonplace, an ever-increasing number of functionalities are incorporated into a single computer system. Often, the additional functionality is provided by attaching an external device to the computer system. In turn, the external device communicates with the computer system to provide the additional functionality.","The Universal serial bus (USB) has become a standard communication channel for connecting external devices to a computer system. USB allows a number of devices to be connected to a same computer system simultaneously, while providing relatively high bandwidth. For example, the latest commonly available version of USB (e.g., USB 2.0) can transfer up to 480 Mbps (mega bits per second).","Vendors who provide USB devices are generally required to provide device drivers to enable access to these devices. Commonly, a device driver is a program and set of data that allows a computer system to access the device (e.g., read data from the device, write data to the device, send commands to the device, and receive status data from the device).","Currently, most USB device vendors are required to provide kernel-mode device drivers for their devices. Generally, a kernel is the central part of an operating system (OS) which remains active and in control of a computer system while the OS is running. For example, the kernel provides the necessary services (such as memory and process management) to the computer system. As a result, kernel-mode drivers can easily cause an unrecoverable system-wide crash in the event of the smallest of malfunctions (or bugs). Additionally, implementing USB drivers in kernel-mode necessitates investment of time and energy in programming complicated kernel-mode drivers, in addition to extra hardware or software required for testing the kernel-mode driver. Furthermore, when upgrading an OS, incompatible or outdated kernel-mode device driver may cause a crash and prevent a successful system upgrade.","Techniques are disclosed to provide a generic USB driver. More particularly, a generic USB device driver architecture is described, which enables development through a user-mode USB library that communicates with a generic kernel-mode driver.","In a described implementation, a method includes loading a kernel-mode generic device driver in response to a plug-in event of a device. A user software component accesses the device by utilizing routines provided by a generic user-mode library (e.g., a dynamic link library (DLL)) that communicates with the generic device driver.","In another implementation, a separate generic device driver is loaded for each plugged-in device, or for each functionality supported by a device.","In some implementations, articles of manufacture are provided as computer program products. One implementation of a computer program product provides a computer program storage medium readable by a computer system and encoding a computer program. Another implementation of a computer program product may be provided in a computer data signal embodied in a carrier wave by a computing system and encoding the computer program.","Moreover, the computer program product encodes a computer program for a computer process executing on a computer system. The computer process loads a kernel-mode generic device driver in response to a plug-in event of a device (as may be detected by a plug and play module). A user software component accesses the device by utilizing routines provided by a generic user-mode library (e.g., a dynamic link library (DLL)).","Other implementations are also described and recited herein.","The following disclosure describes techniques to provide a generic device driver architecture. More specifically, Techniques are disclosed to provide generic USB drivers. More particularly, the architecture utilizes a user-mode USB library which accesses a generic kernel-mode driver. The architecture, in part, reduces the development time of device drivers, improves the end-user experience (e.g., by limiting system-wide crashes whether during normal operations or an upgrade process), and centralize testing and debugging. The architecture may also be utilized to improve input-output (I\/O) handling, security, and power management as will be further discussed herein. Moreover, the techniques discussed herein may be implemented as software, firmware, hardware, and\/or combinations thereof.","Overview of Generic Drivers",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIGS. 1 and 2","FIG. 2"],"b":["100","100","102","104","102","106","106","106","108","108","104"]},"The user-mode environment  includes a generic USB user-mode library  and a user software component . Accordingly, the user software component  is a user-mode software component in an implementation. The generic USB user-mode library  provides routines (or application programming interfaces (APIs)) which may be utilized by the USB user software component  to communicate with or control the USB device. In an implementation, the generic USB user-mode library  is a DLL. Accordingly, the USB user software component  may manage a USB device from the user-mode environment  by invoking routines in the user mode rather than the kernel mode. A number of exemplary APIs will be further discussed below under the same title.","Such an implementation is envisioned to reduce system-wide crashes because if the USB user software component  (or a routine provided by the generic USB user-mode library ) crashes, the kernel's operation remain unaffected. Additionally, such a system () reduces the development time of device drivers and centralize testing and debugging (in part, because only one computer system is needed to test the USB interface, i.e., even when a user-mode software component crashes, the system remains operational).","In one implementation, data corresponding to the communication interface between USB core stack  and the generic USB driver  is published to developers or otherwise available publicly, as well as information regarding the interface between the USB user software component  and the generic USB user-mode library . In an implementation, the information regarding the interface between the generic USB driver  and the generic USB user-mode library  need not be published.","Generic Drivers for Multiple Devices",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":["200","200","102","104","106","110","112"]},"The system  includes a USB bus  to communicate data (as will be further discussed with reference to  below). A USB bus is but one example and other types of data communication buses (such as a wired or wireless communication bus, e.g., Bluetooth, small computer system interface (SCSI), and the like) may be utilized in the system .","As illustrated in , the USB bus  is coupled to the USB core stack  (as discussed with respect to ). The USB core stack  is in turn coupled to a physical device object (PDO) to facilitate communication with a USB hub . The USB hub  allows multiple USB devices to be handled in the kernel-mode environment . Accordingly, it is envisioned that the generic USB drivers () may be coupled between the kernel-mode environment  and the user-mode environment .","As illustrated in , multiple PDOs may be utilized to facilitate communication with various drivers (e.g., the generic USB driver  and a USB composite driver ). The user environment  may communicate with each generic USB driver () through functionality discovered and\/or identified by globally unique identifiers (GUID) . Each GUID  uniquely identifies its USB interface\/function. In one exemplary implementation, the format for the GUID key in the OS registry file and\/or driver file (e.g., information file (INF)), such as the Windows OS available through Microsoft Corporation of Redmond, Wash., is as follows:\n\n","Accordingly, each GUID  identifies functionality supported by the corresponding device which may be utilized by the USB user-mode software component . For example, a user-mode software component will search for any drivers that expose their GUID of interest to find the device(s) that support the desired functionality. A USB user software component  may then communicate with a USB device through the generic USB user-mode library  as discussed with reference to .","It is envisioned that multiple USB hubs () may be utilized to permit communication with multiple USB devices or functionalities incorporated within a single USB device. For example, a USB hub () may be utilized to allow access to different functionalities within a keyboard with multimedia command buttons, in addition to key stroke buttons or integrated pointing devices (e.g., joystick and or touch pad).","Generic Device Driver Operation",{"@attributes":{"id":"p-0035","num":"0035"},"figref":["FIG. 3","FIGS. 1 and 2","FIG. 2"],"b":["300","302","106","306","308","108"]},"The matched generic driver (e.g.,  of ) is loaded () to facilitate communication between the loaded device driver of stage  and a user software component (e.g.,  of ). In a stage , a unique ID is registered (such as discussed with reference to  of ). Finally, the plugged-in device may be accessed () by the user software component through the generic device driver.","In an implementation, it is envisioned that the PNP module matches the extracted device ID to the generic device driver (e.g., where the generic device driver is compatible with the plugged-in device), rather than another device ID. This in turn eliminates the need for loading any additional drivers. Accordingly, in one implementation, a kernel-mode generic device driver is loaded in response to a plug-in event of a device and a user software component accesses the device by utilizing routines provided by the generic user-mode library. The generic user-mode library is communicatively coupled to the generic device driver. The routines may be implemented as APIs (which will be further discussed below under the title \u201cexemplary APIs\u201d). Furthermore, a separate generic device driver may be loaded for each plugged-in device (or functionalities supported by the device).","I\/O Handling in Generic Device Drivers",{"@attributes":{"id":"p-0039","num":"0039"},"figref":["FIG. 4","FIGS. 1 and 2","FIGS. 1 and 2","FIG. 1"],"b":["400","400","112","110","110"]},"For example, the initialization may reset the generic USB device driver's state and behavior to a default and prepare the generic USB device driver to handle further operations. The reading may read data from a specific endpoint on the corresponding device and the writing may write data to a specific endpoint on the corresponding device. The release may clean up all resources claimed during the session that was started with the initialization.","With respect to data length considerations, a USB input (i.e., data from the device to a host or computing system discussed with reference to ) endpoint can transfer anywhere from 0 bytes up to that endpoint's specified maximum packet size at a time, so the software on the host system needs to be prepared to receive up to this maximum size for each packet in the transfer (where a transfer is made up of multiple packets). If a user-mode software component (e.g.,  of ) requests a transfer that is not a multiple of this maximum packet size, then the generic USB device driver may automatically adjust the size of this transfer. Accordingly, if the user software component requests a data transfer with a length insufficient to handle all possible data transfer sizes from the device, the length of the data transfer is increased. This may be accomplished by splitting the client's (the client being the user-mode software component) buffer into at least two separate transfers (this is also referred to as \u201csegmentation\u201d). The first transfer size may be the largest multiple of maximum packet size (\u201cMaxPacket\u201d hereinafter) that is less than the client's requested transfer size. The buffer for this first transfer is the first N*MaxPacket (where this value is the size of this first sub-transfer) of the client's buffer, so no memory copy is required. The second transfer is MaxPacket bytes. The buffer for this second transfer is a newly allocated buffer in an implementation. Once both transfers are complete, the data from the second transfer is copied back into the client's buffer until either the client buffer is full, or a short packet is reached. If any data is left over from the second transfer after the copy, it may or may not be saved away for the next transfer request, based on the pipe policy for that endpoint. It is also envisioned that if there is a short packet in the first transfer, the second transfer may never be issued.","Moreover, a USB host controller, in conjunction with the USB core stack (e.g.,  of ), often may only handle transfer buffers up to a specific size. This size may be different for different host controller implementations. The generic USB device driver takes these size limits into account and if a client's transfer request exceeds this limit, the transfer is split into two or more transfers where all are less than or equal to this limit. In one implementation, there are no buffer copies required to implement this as each sub-transfer's buffer is just a part of the client's original buffer.","As illustrated in , the method  initializes in a stage , e.g., by defining a data structure utilized to access the device. The initialization stage may reset the policy settings to default values (as will be further discussed below with reference to exemplary APIs, such as WinUsb_Initialize). The initialization stage enables the generic user-mode library (e.g., the DLL associated with 110 of ) to run in one implementation.","The method  defines the pipe policy () which may define the behavior of the generic device driver including, for example, time outs, end of packets, auto recovery from error, packet termination guidelines, short packet handling, partial reads such as used for reading headers prior to the actual data to anticipate the amount of data that is to be transferred, discarding extra data that is of no interest, and\/or raw data handling (which indicates that a user software component is guaranteeing proper data handling), as will be further discussed below with reference to exemplary APIs, such as WinUsb_SetPipePolicy. In an implementation, each endpoint may have a pipe in a generic USB driver that is individually configurable.","Some of these exemplary pipe behavior settings are further discussed below in accordance with various implementations:\n\n","In one implementation, the user software component may then define a first-in, first-out (FIFO) buffer policy () (e.g., for a specific pipe (endpoint)) and start filing the FIFO from the device (), as will be further discussed below with reference to exemplary APIs, such as WinUsb_SetFifoPolicy and WinUSB_StartFifo. The FIFO may then be read (e.g., by calling WinUsb_ReadFifo API discussed below). In one implementation, one FIFO is provided for each pipe. It is also envisioned that data may be read by using WinUsb_ReadPipe. Accordingly, a FIFO is not required for reading data. However, a FIFO may be used for a specific class of devices which may generate data at an arbitrary time, or that constantly streams data, for example.","The pipe is then read or written to in a stage . Moreover, as detailed below, other APIs are available for handling I\/O which enable a user software component to more finely control the I\/O functions. For example, in an implementation, if the device responds with a packet that is too large for the client buffer, the data is added at the beginning of the next transfer (if this option is enabled, for example, by Allow_Partial_Reads).","Exemplary APIs","One or more exemplary APIs are illustrated below which may be utilized in the Microsoft Windows\u00ae environment to provide the routines discussed with reference to . For example, routines (e.g., in generic USB user-mode library  of ) may support the following actions (as will be further discussed below):\n\n","The exemplary APIs discussed below are prefaced by \u201cWinUSB\u201d to indicate that they correspond to a generic USB device driver for the Microsoft Windows\u00ae OS. It is envisioned that other naming conventions may be utilized. Also, a sample call, parameter, and return values for each API is highlighted below.","1. WinUsb_Initialize","The WinUsb_Initialize function initializes the WinUsb data structures. Note that the policy settings are reset to the default values when this function is called. An exemplary method for calling this API is:\n\n","Parameters","The handle to the device that was returned by a routine to create a file (e.g., CreateFile). WinUsb uses overlapped I\/O so a flag (e.g., FILE_FLAG_OVERLAPPED) should be specified in the CreateFile call.","This is the interface handle that can be used for all other WinUSB API function calls. This is an opaque handle that is generated by WinUSB.","Return Value","This function returns TRUE if it succeeded. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","2. WinUsb_Free","The WinUsb_Free function frees all the resources that were allocated by WinUsb_Initialize. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","Return Value","This function returns TRUE if it succeeded. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","3. WinUsb_QueryAlternateInterface","The WinUsb_QueryAlternateInterface function returns the first alternate interface descriptor for a particular interface handle. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is a value that indicates the alternate interface to return. A value of 0 indicates the first alternate interface, a value of 1 indicates the second alternate interface, and so forth.","A pointer to a caller-allocated USB_INTERFACE_DESCRIPTOR structure.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","4. WinUsb_QueryDeviceInformation","The WinUsb_QueryDeviceInformation function returns information about the physical device that is associated with a WINUSB interface. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is a value that specifies which interface information value to retrieve.","This the length, in bytes, of Buffer, or the maximum number of bytes to read. This parameter may be set to the actual number of bytes that were copied into Buffer.","This is a caller-allocated buffer that receives the requested value.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Notes","The following list describes the possible InformationType values.","This request will return one of the following values, based on the speed of the device.\n\n","This value contains the physical device identifier of the device.","5. WinUsb_GetDescriptor","The WinUsb_GetDescriptor function returns a requested descriptor. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is a value that specifies the type of descriptor to return. For the standard values, reference may be made to the USB specification which is available at http:\/\/www.usb.org.","This is the descriptor index, which is documented in the USB specification.","This is a value that specifies the language identifier, if the requested descriptor is a string descriptor.","This is a caller-allocated buffer that receives the requested descriptor.","This is the length, in bytes, of Buffer, or the maximum number of bytes to read.","This receives the actual number of bytes that were copied into Buffer.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","6. WinUsb_SetCurrentAlternateInterface","The WinUsb_SetCurrentAlternateInterface function selects a specified alternate interface setting for an interface. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the value contained in the bInterfaceNumber member of the PUSB_INTERFACE_DESCRIPTOR structure, which was populated by WinUsb_QueryAlternateInterface.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","7. WinUsb_GetCurrentAlternateInterface","The WinUsb_GetCurrentAlternateInterface function gets the current alternate interface setting for an interface. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle returned from WinUsb_Initialize","This is a pointer to a UCHAR that will receive the currently selected alternate interface.","Return Value","This function returns TRUE, if the function succeeds and populates the structure. Otherwise, it returns FALSE and the logged error can be retrieved by a call to GetLastError.","8. WinUsb_QueryPipe","The WinUsb_QueryPipe function returns the pipe information for a specified pipe that is associated with an interface. Note that the default control pipe may not be returned. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is a value that specifies the alternate interface to which the information is to be return.","This is a value that specifies the pipe to which the information is returned. This value is not the same as the PipeId in one implementation. Instead, it represents the pipe in the interface's list. A value of 0 signifies the first pipe, a value of 1 signifies the second pipe, and so forth. This value should be less than bNumEndpoints in the interface's descriptor.","This is a pointer to a caller-allocated WINUSB_PIPE_INFORMATION structure.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Notes","The definition of the WINUSB_PIPE_INFORMATION structure may be as follows:\n\n","The PipeId member is the USB 8-bit (hexadecimal) endpoint address, which consists of a 7-bit address and a direction bit.","9. WinUsb_SetPipePolicy","The WinUsb_SetPipePolicy function sets the policy for a specific pipe (endpoint). An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the pipe identifier of the pipe to set the policy for.","This is a value that specifies the policy parameter to change.","This is the length, in bytes, of the buffer that Value points to, or zero if Value does not point to a buffer.","The new value for the policy parameter that is specified by PolicyType.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Notes","The following list describes the possible PolicyType values:","If Value is TRUE (nonzero), every WRITE(OUT) request that is a multiple of the maximum packet size for the endpoint is terminated with a zero-length packet. The default is FALSE.","If Value is TRUE (nonzero), a stall PID will be ignored and, unless first-in, first-out (FIFO) buffering is being used, an error will be returned. In this case, however, the pipe will not be halted and data will continue to flow. This parameter has no effect on CONTROL pipes. Note that the host automatically clears the device stall condition. The default is FALSE.","Value is the amount of time, in milliseconds that a transfer should be cancelled after. A value of zero signifies an infinite amount of time. The default is an infinite amount of time.","If Value is TRUE (nonzero), a read operation will not complete when a short packet is received. Instead, the operation will complete only when the specified number of bytes is read. If Value is FALSE, a read operation will complete when either the specified number of bytes is read or a short packet is received. The default is FALSE.","If Value is FALSE (zero), the read request will fail if the device returns more data than was requested. If Value is TRUE, the extra data is saved, and it is returned at the beginning of the data for the following read request. The default is TRUE.","If Value is FALSE (zero) and the device returns more data than was requested, the remaining data will be discarded. If Value is TRUE, the behavior depends on the value of ALLOW_PARTIAL_READS. Either the data will be saved and then returned at the beginning of the data for the following read request, or the request will fail. The default is FALSE.","This enables a user software component (such as  of ) to guarantee proper data handling. If the data provided by the user software component is in improper format, the data may be flushed.","10. WinUsb_GetPipePolicy","The WinUsb_GetPipePolicy function gets the policy for a specific pipe (endpoint). An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the pipe identifier of the pipe to get the policy for.","This is a value that specifies the policy parameter to get.","This is a pointer to the length of the buffer that Value points to. On output, this parameter receives the length of the data that was copied into the Value buffer.","This is a pointer to a buffer that receives the specified pipe policy value.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","11. WinUsb_SetFifoPolicy","The WinUsb_SetFifoPolicy function sets the policy for a specific pipe (endpoint). An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the pipe identifier of the pipe to set the policy for.","This is a value that specifies the policy parameter to change.","This is the length, in bytes, of the buffer that Value points to, or zero if Value does not point to a buffer.","This is the new value for the policy parameter that is specified by PolicyType.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Notes","The following list describes the possible PolicyType values.","Value is the size, in bytes, of the FIFO input buffer. The default value is 16\u00d7MaxPacketSize. If this limit is reached, data will be lost.","Value is the number of bytes that should be present in the FIFO buffer before the callback function is called. If IGNORE_SHORT_PACKETS is FALSE and a short packet is encountered, the callback function will be called anyway.","12. WinUsb_GetFifoPolicy","The WinUsb_GetFifoPolicy function gets the policy for a specific pipe (endpoint). An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the pipe identifier of the pipe to get the policy for.","This is a value that specifies the policy parameter to get.","This is a pointer to the length of the buffer that Value points to. On output, this parameter receives the length of the data that was copied into the Value buffer.","This is a pointer to a buffer that receives the specified FIFO policy parameter.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","13. WinUsb_StartFifo","The WinUsb_StartFifo function starts the automatic read mechanism that reads data from the device into a FIFO buffer. When data is added to this buffer, the FifoDataNotification function is called, which notifies the client of the presence of the data. The client can then issue requests to read data from the FIFO buffer. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the pipe identifier of the pipe to affect.","This is an optional callback function to be called when the notification threshold is reached.","This is an optional context to be passed to the FifoDataNotification callback function.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Notes","The PWINUSB_NOTIFICATION_CALLBACK type declaration is as follows:\n\n","One possible value for the NotificationType member is FifoDataAvailable (0x01). This value indicates that the FIFO buffer contains enough data for a ReadFifo request of NOTIFICATION_THRESHOLD bytes to complete immediately. As such, the NotificationParameter member can be ignored.","14. WinUsb_StopFifo","The WinUsb_StopFifo function stops the automatic read mechanism. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the pipe identifier of the pipe to affect.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","15. WinUsb_ReadFifo","The WinUsb_ReadFifo function reads data from a pipe's FIFO buffer. Note that the USB packet size does not factor in to the transfer for a read request. If the device responds with a packet that is too large for the client buffer, the data is added at the beginning of the next transfer if ALLOW_PARTIAL_READS is TRUE. If ALLOW_PARTIAL_READS is FALSE, the read request will fail. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the identifier of the pipe to read from.","This is a caller-allocated buffer to read the data into.","This is the length, in bytes, of Buffer, or the maximum number of bytes to read.","This is a pointer to a ULONG that receives the actual number of bytes that were copied into Buffer.","This is an optional pointer to an OVERLAPPED structure, which is used for asynchronous operations. If this parameter is specified, this function will immediately return, and the event is signaled when the operation is complete.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","16. WinUsb_ReadPipe","The WinUsb_ReadPipe function reads data from the pipe. Note that the USB packet size does not factor in to the transfer for a read request. If the device responds with a packet that is too large for the client buffer, the data is added at the beginning of the next transfer if ALLOW_PARTIAL_READS is TRUE. If ALLOW_PARTIAL_READS is FALSE, the read request will fail. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the identifier of the pipe to read from.","This is a caller-allocated buffer to read the data into.","This is the length, in bytes, of Buffer, or the maximum number of bytes to read.","This is a pointer to a ULONG that receives the actual number of bytes that were copied into Buffer.","This is an optional pointer to an OVERLAPPED structure, which is used for asynchronous operations. If this parameter is specified, this function will immediately return, and the event is signaled when the operation is complete.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","17. WinUsb_WritePipe","The WinUsb_WritePipe function writes data to the pipe. An method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the identifier of the pipe to write to.","This is a caller-allocated buffer that contains the data to write.","This is the number of bytes to write.","This is a pointer to a ULONG that receives the actual number of bytes that were written to the pipe.","This is an optional pointer to an OVERLAPPED structure, which is used for asynchronous operations. If this parameter is specified, this function will return, and the event is signaled when the operation is complete.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","18. WinUsb_ControlTransfer","The WinUsb_ControlTransfer function transmits data over the default control endpoint. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the 8-byte setup packet.","This is a caller-allocated buffer that contains the data to transfer.","This is the number of bytes to transfer, not including the setup packet.","This is a pointer to a ULONG that receives the actual number of transferred bytes.","This is an optional pointer to an OVERLAPPED structure, which is used for asynchronous operations. If this parameter is specified, this function will immediately return, and the event is signaled when the operation is complete.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Notes","The WINUSB_SETUP_PACKET structure declaration is as follows:\n\n","19. WinUsb_ResetPipe","The WinUsb_ResetPipe function resets the data toggle and clears the stall condition on a pipe. An exemplary method for calling this API is:\n\n","Parameters","This the interface handle that was returned by WinUsb_Initialize.","This is the identifier of the control pipe.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","20. WinUsb_AbortPipe","The WinUsb_AbortPipe function aborts all the pending transfers for a pipe. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the identifier of the control pipe.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","21. WinUsb_FlushPipe","The WinUsb_FlushPipe function discards any data that was saved as a result of the device returning more data than the client requested. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is the identifier of the control pipe.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Power Management",{"@attributes":{"id":"p-0263","num":"0444"},"figref":["FIG. 5","FIG. 6","FIGS. 1-4"],"b":["500","500"]},"A power management policy is defined for the attached device(s) (), e.g., through the generic USB user-mode library (e.g.,  of ). The power policy may include provisions on whether automatic suspension is allowed, whether the device may be automatically awakened, and\/or whether a minimum delay threshold is set for suspending the device (as is further discussed with reference to the exemplary APIs, such as WinUsb_SetInterfacePowerPolicy).","More specifically, the automatic suspension may involve detecting when a device has become \u201cidle,\u201d possibly meaning that there has not been a transfer in a specified amount of time, at which point the generic USB driver (e.g.,  of ) may suspend the device to save power. In an implementation, the generic USB driver will automatically detect when the device needs to be powered back up, and will do so at the appropriate times.","With respect to automatically awakening the computing system, a client (such as  of ) may configure the generic USB device driver's behavior to allow the device to wake the computing system from a low-power state (e.g., standby or hibernation). In an implementation, the generic USB device driver will handle all operations required to prepare the device and the computing system for this capability.","Furthermore, the delay threshold time period may be set such that a client (such as  of ) may specify an amount of time that the generic USB device driver needs to guarantee will pass after the last transfer before suspending the device. Accordingly, the delay threshold may specify a time period after a data transfer and the computing system waits for the time period after the data transfer to pass before the device enters the suspend mode.","Once condition(s) for entering a suspend mode are met (e.g., in accordance with the power policy in effect) (), the device enters a low-power state (). This in turn allows the computing system to which the device is attached (whether through wires or wirelessly as discussed previously) to enter a low-power state ().","The method  is envisioned to allow power savings even in situations where multiple devices are attached to a computing system by utilizing the functionality provided by the generic device drivers discussed herein. Namely, in absence of a generic device driver configuration, multiple devices attached to the computing system may not enter their suspend modes simultaneously or for a sufficient period of time to enable effective overall power saving by the computing system.","In various implementations, the following list summarizes the behavior across power management states:\n\n","Moreover, as detailed below, other APIs are available for handling power management which enable a user software component to more finely control the power management functions.","1. WinUsb_SetInterfacePowerPolicy","The WinUsb_SetInterfacePowerPolicy function sets the power policy for the device. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is a value that specifies the policy parameter to change.","This is the length, in bytes, of the buffer that Value points to, or zero if Value does not point to a buffer.","This is the new value for the policy parameter that is specified by PolicyType.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Notes","The following list describes the possible PolicyType values:","If Value is TRUE (nonzero), the device will be suspended when no transfers are pending. The default is TRUE.","Set Value to TRUE if the device supports WAKE. The default is FALSE.","Value is the minimum amount of time, in milliseconds, that the driver should wait after any transfer before it can suspend the device. The default is five seconds.","2. WinUsb_GetInterfacePowerPolicy","The WinUsb_GetInterfacePowerPolicy function gets the power policy for the device. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","This is a value that specifies the policy parameter to get.","This is a pointer to the length of the buffer that Value points to. On output, this parameter receives the length of the data that was copied into the Value buffer.","This is a pointer to a buffer that receives the specified power policy value.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","3. WinUsb_EnableInterfaceIdle","The WinUsb_EnableInterfaceIdle function indicates that an in interface is idle so that the operating system can power down the device (USB suspend). This is how user-mode clients support a selective suspend. Any access (read or write) to one of the pipes automatically brings the interface out of the idle state, so no query of the idle state is provided. Calling this function does not guarantee that the device will be suspended; it is merely a suggestion that the device is currently capable of supporting USB suspend state. If the FIFO buffer is running, it will continue to run until the device is actually suspended. An exemplary method for calling this API is:\n\n","Parameters","This is the interface handle that was returned by WinUsb_Initialize.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","4. WinUsb_DisableInterfaceIdle","The WinUsb_DisableInterfaceldle function either prevents the device from being suspended or wakes up the device if it has already been suspended. An exemplary method for calling this API is:\n\n","Parameters","The interface handle that was returned by WinUsb_Initialize.","Return Value","This function returns TRUE if it succeeded and populated the structure. Otherwise, it returns FALSE, and the logged error can be retrieved by calling GetLastError.","Security","In one implementation, security is provided through the named device object created by a IoRegisterDeviceInterface in the generic device driver . Security attributes can be specified for this symbolic link limiting who can open it.","In such an implementation, only one user software component (e.g., ) can have the link opened at any given time, so when a software component opens the link no other software components can access the interface unless that software component gets the actual handle.","It is envisioned that the control pipe for a physical device may be shared among multiple interfaces (e.g., for different functionalities supported by the device), so a user software component may be able to send control commands to another interface. This may require certain restrictions on control transfers in an implementation. Additionally, security access on a symbolic link may be handled by setting the security attributes on the PDO ().","General Computing Environment",{"@attributes":{"id":"p-0312","num":"0519"},"figref":"FIG. 6","b":["600","600","108","110","112","600","600","600"]},"Computer environment  includes a general-purpose computing device in the form of a computer . The components of computer  can include, but are not limited to, one or more processors or processing units  (optionally including a cryptographic processor or co-processor), a system memory , and a system bus  that couples various system components including the processor  to the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Such media can be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media.","The system memory  includes computer-readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by one or more interfaces (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer-readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computing system and environment.","Any number of program modules can be stored on the hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of example, an operating system , one or more application programs , other program modules , and program data . Each of such operating system , one or more application programs , other program modules , and program data  (or some combination thereof) may implement all or part of the resident components that support the distributed file system.","A user can enter commands and information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a USB (such as discussed with reference to ). The USB port may be utilized to connect a camera, personal digital assistant (PDA), MP3 device, video capture device, a flash card reader, and the like to the computer environment .","A monitor  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices can include components such as speakers (not shown) and a printer  which can be connected to computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, the remote computing device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, game console, and the like. The remote computing device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of remote computer . For purposes of illustration, application programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computing device , and are executed by the data processor(s) of the computer.","Various modules and techniques may be described herein in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various implementations.","An implementation of these modules and techniques may be stored on or transmitted across some form of computer-readable media. Computer-readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer-readable media may include \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","\u201cComputer storage media\u201d includes volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer.","\u201cCommunication media\u201d typically includes computer-readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, radio frequency (RF), infrared, Wi-Fi, cellular, Bluetooth enabled, and other wireless media. Combinations of any of the above are also included within the scope of computer-readable media.","In one implementation, the hardware device whose information is accessed (such as discussed with reference to ) may be any device coupled with components of the general computer environment  (such as the processing units ). Also, the hardware device may be a peripheral device of the general computer environment  (such as the mouse , keyboard , printer , and the like).","Thus, although the invention has been described in language specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. For example, the techniques described herein may be applied to wired or wireless communication channels (such as Bluetooth, small computer system interface (SCSI), and the like). Accordingly, the specific features and acts are disclosed as exemplary forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is described with reference to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different figures indicates similar or identical items.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
