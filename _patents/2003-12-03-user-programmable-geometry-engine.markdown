---
title: User programmable geometry engine
abstract: A programmable geometry engine is described. One embodiment of the programmable geometry engine includes a programmable primitive engine configured to receive primitive commands that include information for processing vertex data using user-developed programs or subroutines. The programmable primitive engine also is configured to transmit program commands that include program pointers and data pointers. In addition, the programmable geometry engine includes a processing engine configured to receive the program commands. The processing engine is further configured to retrieve the user-developed programs or subroutines using the program pointers and to retrieve vertex data using the data pointers. Also, the processing engine is configured to process the vertex data based on instructions included in the user-developed programs or subroutines to produce processed vertex data and to transmit results to the programmable primitive engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06900810&OS=06900810&RS=06900810
owner: NVIDIA Corporation
number: 06900810
owner_city: Santa Clara
owner_country: US
publication_date: 20031203
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION(S)","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application relates to, and claims the priority benefit of, U.S. Provisional Patent Application No. 60\/462,484, titled \u201cUser Programmable Primitive Engine,\u201d filed on Apr. 10, 2003. The subject matter of this related application is hereby incorporated by reference.","This application also relates to application No. Ser. No. 10\/727,679, titled \u201cNeighbor and Edge Indexing,\u201d filed on Dec. 4, 2003. The subject matter of this related application also is hereby incorporated by reference.","The present invention generally relates to graphics processing and more specifically to a user programmable geometry engine.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","100"]},"As shown, imaging path  receives image data . Image data  is processed to have pixels unpacked at . Geometry path  receives geometry data , namely, geometry primitives. At , vertices of geometry data  are unpacked. Unpacking of pixels at  and unpacking of vertices at  are both performed in partial response to display lists  input into imaging path  and geometry path , respectively. Persons skilled in the art will appreciate that conventional user programming in geometry path  is based on the stream of unpacked vertices provided to vertex operations . Further, evaluators  are located in front of vertex operations . Tessellation therefore occurs before vertex operations  in this particular configuration of graphics pipeline .","As  also shows, at , pixel operations are performed on unpacked pixels . At , vertex operations are performed on unpacked vertices . Texture data or texels generated from pixel operations  are stored in texture memory . At , image rasterization is done on pixel data following pixel operations . Texture data as well as geometry data produced from vertex operations  are rasterized with geometric rasterization at . Image rasterization  and geometric rasterization  outputs are combined and processed by fragment operations , the output of which is provided to frame buffer .","Graphics processors that implement the functionality of graphics pipelines, such as graphics pipeline , may have user-programming capability, but such programmability typically is limited to vertex-oriented processing. For example, graphics processors with user-programmability may include one or more processing units, such as vertex engines, that are capable of processing a stream of vertices using various user-developed programs or subroutines. By providing such a programmable vertex engine, the flexibility and functionality of the graphics processor is enhanced. However, a graphics processor with this type of programmable vertex engine limits a user to influencing only how vertex data is manipulated. A more flexible graphics processor would also enable a user to influence how primitives are manipulated in the graphics pipeline.","In addition to the foregoing, in current architectures such as that depicted in graphics pipeline , evaluation usually is performed prior to performing many vertex operations such as matrix palette skinning. As is commonly known, an evaluator is used in a graphics pipeline for a variety of functions such as computing geometry defined by bi-variate polynomials and tessellating such geometry. A specific problem with this order of operations is that when a vertex program operates on one of the vertices of a triangle during matrix palette skinning, the vertex program typically selects a subset of matrices and weights from a predefined set of matrices configured for skinning operations and performs the necessary weighted transforms. If, however, that triangle derives from a patch, the vertices of the triangle have no immediately obvious matrices or weights, thereby defeating matrix palette skinning. A more feasible approach would be to apply the skinning operations to the control points of the patch and then tessellate. The current architecture, however precludes such an approach. Further, to achieve this same effect in the current architecture all matrices affecting the control points of a patch must influence the final position of the evaluated positions. As all relevant operations are linear, this means that all of the active matrices have to be interpolated and applied to the evaluated positions. This requires the union of all active matrices to be included in the relevant operations, resulting in a far larger number of matrices being applied to each generated vertex, thereby making these skinning calculations largely impractical.","Another limitation of the current architecture pertains to load balancing. In a typical configuration, dedicated, statically portioned hardware units perform the various operations in the graphics pipeline such as evaluation and transform and lighting computations. Further, to the extent that one of these units has a disproportionately greater number of operations to perform, the current architecture has no way of offloading any of those calculations to other operational units in the graphics processor. As a result, one or more such units may act as a bottleneck in the graphics pipeline.","One embodiment of a programmable geometry engine includes a programmable primitive engine configured to receive primitive commands that include information for processing vertex data using user-developed programs or subroutines. The programmable primitive engine also is configured to transmit program commands that include program pointers and data pointers. In addition, the programmable geometry engine includes a processing engine configured to receive the program commands. The processing engine is further configured to retrieve the user-developed programs or subroutines using the program pointers and to retrieve vertex data using the data pointers. Also, the processing engine is configured to process the vertex data based on instructions included in the user-developed programs or subroutines to produce processed vertex data and to transmit results to the programmable primitive engine.","One advantage of the disclosed programmable geometry engine is that it may be configured to implement specific user-programmed functions. This functionality provides users with the ability to influence a variety of computational parameters and metrics that determine how a graphics processor actually generates primitives in the graphics pipeline. Another advantage is that the disclosed programmable geometry engine has the flexibility to perform vertex operations before and\/or after primitive operations. Such flexibility in the architecture enables matrix palette skinning to be performed after tessellation, if so desired. In addition, the programmable geometry engine may include multiple fixed function engines and a scheduler, which arbitrates access to one or more processing engines among the different fixed function engines. The scheduler may be configured to load balance among the different fixed function engines by allowing a fixed function engine with greater processing needs to transmit program commands to the processing engine(s) more frequently than those fixed function engines requiring less processing support. Such load balancing may reduce bottlenecks in the graphics pipeline.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 2"],"b":["200","200","200"]},"As shown, graphics pipeline  includes a programmable geometry engine , which is configured for per-vertex operations, primitive assembly and per-primitive operations. The functionality of programmable geometry engine  includes both programmable vertex processing and programmable primitive processing. As described in further detail below in conjunction with , programmable primitive processing is provided by combining various functional engines, such as a subdivision engine or a mesh engine (otherwise referred to as a \u201ctessellation engine\u201d or an \u201cevaluator\u201d), with one or more vertex engines. Notably, the functional engines are configured to cause the one or more vertex engines to execute various user-developed programs or subroutines for various primitive processing operations. As described in further detail herein, this functionality, among other things, enables users to influence a variety of computational parameters and metrics that determine how a graphics processor (which would include programmable geometry engine ) actually generates primitives in graphics pipeline .","As  also shows, image and geometry data  are provided to programmable geometry engine  and display lists . In one embodiment, image and geometry data  is equivalent to image data  and geometry data  of , and display lists  is equivalent to display lists  of FIG. . In response, display lists  provides display listed or indexed image and geometry data to programmable geometry engine  and pixel operations . In one embodiment, pixel operations  is equivalent to pixel operations  of FIG. . In response to receiving indexed image and geometry data, pixel operations  output pixels to texture memory  and image and geometric rasterization , and programmable geometry engine  outputs primitives to image and geometric rasterization . In one embodiment, texture memory  is equivalent to texture memory  of , and image and geometric rasterization  is equivalent to image rasterization  and geometric rasterization . Output from image and geometric rasterization  is provided to fragment operations , and output of fragment operations  is provided to frame buffer . Frame buffer  may be accessed for image generation as well a for feed back to pixel operations . In one embodiment, fragment operations  is equivalent to fragment operations  of , and frame buffer  is equivalent to frame buffer  of FIG. .",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3","b":["300","300","301","310","300"]},"Computer  may include, without limitation, a graphics processor , an input\/output interface , a host processor  and a graphics memory . Graphics processor  includes memory controller , which arbitrates access to graphics memory  among the various operational elements of graphics processor . Memory controller  may be coupled directly to graphics memory  or may be coupled indirectly to graphics memory  through an input\/output interface . As persons skilled in the art will understand, graphics processor  may be configured to perform some or all of the operations of the logical elements of graphics pipeline  of FIG. .","Input\/output devices  are coupled to graphics processor  through input\/output interface . In one embodiment, graphics processor  is coupled to host processor  through input\/output interface . In an alternative embodiment, graphics processor  may be coupled directly to host processor . Similarly, in one embodiment, graphics memory  is coupled to host processor  through input\/output interface , but, in an alternative embodiment, graphics memory  may be coupled directly to host processor .","Graphics memory  may be any memory used to store graphics data or program instructions to be executed by graphics processor . For example, graphics memory  may include portions of system memory, local memory directly coupled to graphics processor  or register files coupled to the computational units within graphics processor .",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4","b":["400","400","402","404","416","424","424","402","424","416","416","308","416","404","424","404","400","302","3"]},"More specifically, IDX  is coupled to a front end , which is coupled to input\/output interface . As described above in conjunction with , input\/output interface  is coupled to graphics memory  (not shown). IDX  is configured to access vertex data and related primitive commands from graphics memory  via front end  and input\/output interface . IDX  is further configured to transmit those vertex data and primitive commands to vertex RAM  and programmable primitive engine , respectively. Vertex data may include any graphics data associated with a given vertex and may also include any graphics information associated with the neighbors of that vertex. Examples of vertex data include, without limitation, position, texture coordinates, color, luminance, alpha (i.e., transparency) and the like as well as index information for vertices and their neighbors. Primitive commands may include any information related to primitive processing such as pointers to user-developed primitive programs or subroutines stored in graphics memory , index information for the vertices of the primitives processed using those user-developed primitive programs or subroutines, index information for the neighbors of those vertices, processing instructions and the like.","Programmable primitive engine  may include, without limitation, any number of fixed function engines as represented by a first fixed function engine , a second fixed function, engine  and continuing up to and including an Nth fixed function engine . Each of first fixed function engine , second fixed function engine  and Nth fixed function engine  may be configured to process an original primitive such as a cube strip, a tetrahedron strip, a triangle strip, a quad strip, a triangle fan, a quad fan, a triangle, a quad, a line, and point and the like or to arbitrarily generate primitives of a single type. Further, as described in further detail herein, first fixed function engine , second fixed function engine  and Nth fixed function engine  are configured to enable programmable geometry engine  to implement specific user-programmed functions for various primitive processing operations such as, for example, processing vertex data, generating individual primitives, subdividing primitives, generating meshes of primitives and the like. As persons skilled in the art will understand, each of first fixed function engine , second fixed function engine  and Nth fixed function engine  has the same general configuration. For this reason, the configuration of only first fixed function engine  is described herein.","In one embodiment, first fixed function engine  is configured to receive primitive commands transmitted by IDX . First fixed function engine  is further configured to determine whether any of the received primitive commands relate to it\u2014meaning that first fixed function engine  determines whether it is supposed to process any of the received primitive commands (each primitive command that relates to first fixed function engine  is hereinafter referred to as a \u201crelated primitive command\u201d).","For example, in one embodiment, each primitive command transmitted by IDX  includes one or more flags, each flag corresponding to a different fixed function engine in programmable primitive engine . If a given fixed function engine (e.g., first fixed function engine ) is supposed to process a particular primitive command, then the flag in that primitive command corresponding to the given fixed function engine is enabled. By contrast, if the given fixed function engine is not supposed to process the particular primitive command, then the flag in the primitive command corresponding to the given fixed function engine is disabled. In such an embodiment, each fixed function engine in programmable primitive engine  is configured to read the flags included in a primitive command transmitted by IDX  to determine whether to process that primitive command.","In an alternative embodiment, each fixed function engine in programmable primitive engine  may be configured with one or more internal flags, each flag corresponding to a different primitive type (e.g., triangle, line, point and the like). A given fixed function engine may further be configured such that if a particular flag within the fixed function engine is enabled, then that fixed function engine processes all primitive commands related to the primitive type corresponding to the enabled flag. Similarly, the fixed function engine may be configured such that if a particular flag is disabled, then the fixed function engine does not process (and simply passes through) all primitive commands related to the primitive type corresponding to the disabled flag. In another alternative embodiment, a given fixed function engine may be configured with one or more enabled internal flags, each flag corresponding to a different primitive type that the fixed function engine is configured to process. In such a configuration, the fixed function engine is configured not to process (and simply to pass through) any primitive command that is not related to a primitive type corresponding to the one or more enabled flags. In yet another alternative embodiment, a given fixed function engine may be configured to process all primitive commands corresponding to a particular primitive type. In such an embodiment, the fixed function engine is configured not to process (and simply to pass through) any primitive command that is not related to the primitive type that the fixed function engine is configured to process.","If first fixed function engine  determines that none of the received primitive commands are related primitive commands, then first fixed function engine  is configured to transmit the primitive commands to the next fixed function engine in programmable primitive engine . As  shows, the second fixed function engine  is the next fixed function engine in programmable primitive engine . If, however, first fixed function engine  determines that at least one of the received primitive commands is a related primitive command, then first fixed function engine  is configured to wait to receive a complete set of such related primitive commands before processing any of the related primitive command (the group of related primitive commands is hereinafter referred to as the \u201cset of related primitive commands\u201d).","In one embodiment, first fixed function engine  is configured to determine whether it has received the complete set of related primitive commands by attempting to assemble a primitive using the vertex index information contained in the related primitive commands that have been already received. As persons skilled in the art will understand, being able to assemble a primitive confirms that the information for each vertex of that primitive has been received. If first fixed function engine  is able to assemble a primitive, then first fixed function engine  has received the complete set of related primitive commands. If first fixed function engine  is not able to assemble a primitive, then first fixed function engine  has not yet received the complete set of related primitive commands. In the latter case, first fixed function engine  is configured to wait to receive additional related primitive commands and to attempt to assemble a primitive again. First fixed function engine  is further configured to repeat the process of waiting for additional related primitive commands and attempting to assemble a primitive until first fixed function engine  is able to assemble a primitive (thereby indicating that first fixed function engine  has received the complete set of related primitive commands).","Once the complete set of related primitive commands has been received, first fixed function engine  is configured to identify a first primitive command in the set of related primitive commands to be processed. First fixed function engine  is configured to generate a program command corresponding to this first primitive command and to transmit the program command to vertex engine  for processing. The program command contains all information necessary for vertex engine  to carry out the computations specified by the first primitive command. For example, the program command may include, without limitation, a pointer to the user-developed program or subroutine that vertex engine  is to execute (also referred to as a \u201cprogram pointer\u201d), one or more pointers to vertex data on which vertex engine  is to perform specific operations, including index information for the vertices of the primitive that first fixed function engine  is processing and\/or index information for the neighbors of those vertices (also referred to as a \u201cdata pointer\u201d), u, v, w interpolation weights and the like.","As described in further detail herein, vertex engine  is configured to process the program command and to return the corresponding results to first fixed function engine . These results may be any type of state information related to the type of user-programmed function that first fixed function engine  is configured to implement. Results may include, for example, level of detail (\u201cLOD\u201d) or edge test calculations, computed vertices, vector products, sign data, comparison results, mesh densities and the like.","First fixed function engine  is configured to determine whether to wait until vertex engine  processes the program command and returns the corresponding results before transmitting another program command to vertex engine . First fixed function engine  may make this determination from, for example, instructions included in the primitive command or program command currently being processed or from information included in results received from vertex engine  that correspond to a previously processed program command.","Upon determining not to wait for vertex engine  to return the corresponding results, first fixed function engine  is configured to determine whether to transmit the same program command again to vertex engine  for processing. However, upon determining to wait, first fixed function engine  is configured instead to wait to receive the corresponding results from vertex engine  and to interpret those results once they are received. First fixed function engine  is configured then to determine whether to transmit the same program command again to vertex engine  for processing. First fixed function engine  may make this determination from, for example, instructions included in the primitive command or program command currently being processed or from information included in results received from vertex engine  that correspond to a previously processed program command.","Upon determining to transmit the same program command again to vertex engine  for processing, first fixed function engine  is configured to resend the program command to vertex engine . However, upon determining not to transmit the same program command again, first fixed function engine  is configured instead to determine whether all of the primitive commands in the set of related primitive commands have been processed.","Upon determining that one or more primitive commands in the set of related primitive commands remain unprocessed, first fixed function engine  is configured to identify the next primitive command in the set of related primitive commands to be processed. First fixed function engine  is configured to process this next primitive command in the same manner as described above in conjunction with the first primitive command. More generally, first fixed function engine  is configured to process each primitive command in the set of related primitive commands in the manner described above in conjunction with the first primitive command until all primitive commands in the set of related primitive commands have been processed.","However, upon determining that all primitive commands in the set of related primitive commands have been processed, first fixed function engine  is configured instead to transmit the primitive commands received from IDX  that remain unprocessed to the next fixed function engine in programmable primitive engine . The next fixed function engine, second fixed function engine  in the embodiment of , is configured to process all of the primitive commands received from IDX  pertaining to it as described herein with respect to first fixed function engine . After processing all such primitive commands, second fixed function engine  is configured to transmit the unprocessed primitive commands received from IDX  to the next fixed function engine in programmable primitive engine . The fixed function engines in programmable primitive engine  are configured to follow this general procedure described herein until all of the primitive commands received from IDX  have been processed.","Persons skilled in the art will understand that first fixed function engine  may be configured to transmit program commands to vertex engine  and to receive and interpret corresponding results in any technically feasible manner. Persons skilled in the art therefore will recognize, for example, that neither the way that first fixed function engine  determines whether to wait for vertex engine  to return results before sending another program command to vertex engine  for processing nor the way that first fixed function engine  determines whether to resend a given program command to vertex engine  for processing in any way limits the scope of the present invention.","One should further note that, as described herein, a given fixed function engine may be configured to generate primitives with their own topologies, as opposed to being configured to process previously generated primitives. In such a configuration, the fixed function engine may output, among other things, index information for the vertices of the generated primitives, index information for the neighbors of those vertices, processing instructions and the like. The fixed function engine may be further configured to transmit this output, constituting one or more additional unprocessed primitive commands, to the next fixed function engine in programmable primitive engine , as previously described herein with respect to the primitive commands transmitted by IDX .","Programmable primitive engine  also may include one or more memory caches as represented by a first-in-first-out memory (\u201cFIFO\u201d)  and a FIFO . As  shows, FIFO  is coupled to first fixed function engine  and second fixed function engine , and FIFO  is coupled to second fixed function engine  and the next fixed function engine (not shown) in programmable primitive engine . FIFO  is configured to store unprocessed primitive commands transmitted by first fixed function engine  (including those generated by first fixed function engine ) to second fixed function engine . FIFO  is configured to store unprocessed primitive programs transmitted by second fixed function engine  (including those generated by second fixed function engine ) to the next fixed function engine in programmable primitive engine . In such an embodiment, second fixed function engine  is configured to access any unprocessed primitive commands stored in FIFO , and the next fixed function engine in programmable primitive engine  following second fixed function engine  is configured to access any unprocessed primitive commands stored in FIFO . Persons skilled in the art will understand that in alternative embodiments, programmable primitive engine  may not include FIFO  and\/or FIFO . In these embodiments, first fixed function engine  transmits all unprocessed primitive commands directly to second fixed function engine  and\/or second fixed function engine  transmits. all unprocessed primitive commands directly to the next fixed function engine in programmable primitive engine .","Persons skilled in the art will understand that each fixed function engine included in programmable primitive engine  may be configured to cause the implementation of any type of user-programmed function. Programmable primitive engine  therefore may be configured to cause the implementation of any desired combination of user-programmed functions. For example, programmable primitive engine  may be configured such that first fixed function engine  and second fixed function engine  cause the implementation of the same user-programmed function, and Nth fixed function engine  causes the implementation of a different user-programmed function. Alternatively, programmable primitive engine  may be configured such that each of first fixed function engine , second fixed function engine  and Nth fixed function engine  either causes the implementation of the same user-programmed function or causes the implementation of a different user-programmed function. In yet other alternative embodiments, programmable primitive engine  may be configured such that at least one other fixed function engine causes the implementation of the same user-programmed function as first fixed function engine , second fixed function engine  and\/or Nth fixed function engine . In addition, persons skilled in the art will appreciate that, in alternative embodiments, any given fixed function engine configured to cause the implementation of one type of user-programmed function may be reconfigured to cause the implementation of another type of user-programmed function.","In one embodiment, first fixed function engine , second fixed function engine  and Nth fixed function engine  are configured as state machines. In alternative embodiments, first fixed function engine , second fixed function engine  and Nth fixed function engine  may be configured in any other technically feasible way so long as each of first fixed function engine , second fixed function engine  and Nth fixed function engine  functions as intended. Finally, the functionality of first fixed function engine , second fixed function engine  and Nth fixed function engine  may be implemented in hardware and\/or software.","Vertex RAM  is configured to store and to manage access to vertex data received from IDX  as well as processed vertex data received from vertex engine . Vertex RAM  may be any other type of storage resource such as, for example, a cache or a register file. As shown, vertex RAM  may include, without limitation, a vertex allocator , an input buffer  and any number of output buffers as represented by a first output buffer , a second output buffer  and continuing up to and including an nth output buffer . In one embodiment, vertex allocator  is configured to receive vertex data from IDX  and to transmit that vertex data to input buffer , which is configured to store vertex data received from IDX . Each of first output buffer , second output buffer  and nth output buffer  is configured to store processed vertex data received from vertex engine , as described in further detail herein.","Vertex engine  is the general computational engine underlying programmable geometry engine . As shown, vertex engine  may include, without limitation, a floating point processor , a memory  and a scheduler . Memory  is coupled to floating point processor  and memory controller  and is configured to store locally user-developed programs or subroutines to be executed by floating point processor .","Scheduler  is coupled to floating point processor  and each of the fixed function engines in programmable primitive engine  (e.g., first fixed function engine , second fixed function engine  and Nth fixed function engine  in FIG. ). Scheduler  is configured to arbitrate access to floating point processor  among the different fixed function engines. In one embodiment, scheduler  is configured to determine which fixed function engines in programmable primitive engine  require relatively more processing support based on the content of a given set of primitive commands and the configuration of programmable primitive engine . Scheduler  is further configured to regulate when each fixed function engine in programmable primitive engine  is able to transmit a program command to floating point processor . These capabilities enable scheduler  to load balance among the various fixed function engines by allowing those fixed function engines requiring more processing support to transmit program commands to floating point processor  more frequently than those fixed function engines requiring less processing support. As persons skilled in the art will recognize, load balancing between the various fixed function engines may reduce bottlenecks in programmable primitive engine  caused by one or more fixed function engines having disproportionately greater processing needs than the other fixed function engines in programmable primitive engine .","Floating point processor  is configured to receive program commands transmitted to vertex engine  by any of the fixed function engines in programmable primitive engine  (e.g., first fixed function engine , second fixed function engine  and Nth fixed function engine ). Floating point processor  is further configured to interpret and to execute each such program command. More specifically, upon receiving a given program command, floating point processor  is configured to retrieve the user-developed program or subroutine stored in graphics memory  at the memory location designated by the program pointer contained in the program command and to store that program or subroutine in memory . In one embodiment, floating point processor  accesses the user-developed program or subroutine via memory controller . Floating point processor  is further configured to retrieve the vertex data stored in vertex RAM  at the memory location(s) designated by the data pointer(s) contained in the program command (this vertex data is hereinafter referred to as the \u201csource data\u201d).","After retrieving the source data, floating point processor  is configured to process the source data. As persons skilled in the art will understand, the instructions contained in the user-developed program or subroutine configure floating point processor  to perform specific operations on the source data, producing processed vertex data. Floating point processor  is configured to transmit this processed vertex data to vertex RAM  for storage. Finally, floating point processor  is configured to transmit the corresponding results to the fixed function engine in programmable primitive engine  that transmitted the program command to vertex engine , as previously described herein.","In one embodiment, for a given set of program commands transmitted by a specific fixed function engine in programmable primitive engine , vertex data stored in input buffer  is the source data processed according to the first program command of that set. Floating point processor  is configured to transmit the corresponding processed vertex data to first output buffer  for storage. This vertex data stored in output buffer  then becomes the source data processed according to the second program command of the set of transmitted program commands. Floating point processor  is configured to transmit the corresponding processed vertex data to second output buffer  for storage. This vertex data stored in second output buffer  then becomes the source data processed according to the third program command of the set of transmitted program commands. Floating point processor  is configured to repeat this pattern of retrieving vertex data from and transmitting processed vertex data to the various output buffers of vertex RAM  until floating point processor  has processed all of the program commands in the set of transmitted program commands.","In alternative embodiments, floating point processor  may retrieve vertex data from and transmit processed vertex data to the different memory buffers of vertex RAM  in any technically feasible fashion. Further, vertex allocator , input buffer  and the various output buffers (e.g., first output buffer , second output buffer  and nth output buffer ) may be configure in any manner so long as vertex RAM  functions as intended. Persons skilled in the art will therefore recognize that neither the manner in which floating point processor  retrieves vertex data from or transmits processed vertex data to vertex RAM  nor the configuration of vertex RAM  in any way limits the scope of the invention.","In alternative embodiments, vertex engine  also may be configured to perform vertex shading operations. For example, in an alternative embodiment, IDX  may be configured to transmit vertex data to vertex engine  for vertex shading operations prior to transmitting that vertex data to vertex RAM . In such a situation, floating point processor  may execute one or more user-developed or other vertex programs to process the vertex data. These vertex programs reside in graphics memory  and may be accessed by floating point processor  via memory controller . In other alternative embodiments, vertex engine  may perform vertex shading operations on vertex data residing in vertex RAM  between processing different sets of program commands transmitted by the various fixed function engines in programmable primitive engine . For example, in one alternative embodiment, vertex engine  may be configured to perform vertex shading operations after processing a set of program commands transmitted by first fixed function engine  but before processing a set of program commands transmitted by second fixed function engine . In yet another alternative embodiment, vertex engine  may be configured to perform vertex shading operations each time vertex engine  finishes processing a set of program commands transmitted by any of the fixed function engines in programmable primitive engine .","In addition, in alternative embodiments, programmable geometry engine  may be configured with any number of vertex engines . For example, if programmable primitive engine  includes three fixed function engines, one of which requires far greater processing support than the other two, programmable geometry engine  may include two vertex engines . One vertex engine  may be configured to process program commands transmitted by the fixed function engine requiring greater processing support, and the other vertex engine  may be configured to process program commands transmitted by the other two fixed function engines. In another alternative embodiment, programmable geometry engine  may include one vertex engine  for each fixed function engine in programmable primitive engine . Persons skilled in the art will recognize that programmable geometry engine  may be configured with any combination of vertex engines  and fixed function engines in programmable primitive engine  and that, therefore, the number of vertex engines  in no way limits the scope of the invention. In addition, persons skilled in the art will understand that in embodiments including more than one vertex engine , vertex allocator  may be configured to arbitrate access to vertex data stored in vertex RAM  such that two or more vertex engines  may not simultaneously access the same vertex data for processing.","As  also shows, programmable geometry engine  may include a viewport\/set-up unit  and a rasterization unit . Viewport\/set-up unit  is configured to access vertex data from vertex RAM  and to perform viewport transformations, viewport clipping, matrix translation to screen space, and the like, as well as triangle or primitive set-up, derivative computations, culling and the like. Rasterization unit  is configured to receive processed vertex data transmitted by viewport\/set-up unit  and to convert the vertex data to pixel fragments.","As persons skilled in the art will recognize, the general functionality of programmable geometry engine  enables users to influence a variety of computational parameters and metrics that determine how a graphics processor, such as graphics processor , actually generates primitives in the graphics pipeline (e.g., graphics pipeline ). Users exert such influence by writing the user-developed programs and subroutines that vertex engine  executes to calculate the various computational parameters and metrics (as well as to generate vertices for both processed and newly-generated primitives). Further, as these calculations are performed on a primitive-by-primitive or a vertex-by-vertex basis, users have influence over the local decisions that determine how primitives are generated in the graphics pipeline (e.g., graphics pipeline ).","For example, a user may write a tessellation program with two subroutines, an initialization subroutine and an evaluation subroutine. The initialization subroutine may be responsible for calculating the LOD of the mesh, and the evaluation subroutine may be responsible for generating the vertices of the primitives in the mesh. Programmable geometry engine  may be configured such that one of the fixed function engines in programmable primitive engine  transmits to vertex engine  program commands that call on the two subroutines of this tessellation program when tessellation needs to be performed over a given region of an object. First, vertex engine  may execute the initialization subroutine to calculate the LOD of the mesh, and then vertex engine  may execute the evaluation subroutine several times over to generate the requisite number of vertices for the mesh. As the user may write the algorithm(s) used to calculate the LOD of the mesh, the user may influence how densely the tessellated region is populated with primitives. Further, as one of the fixed function engines in programmable primitive engine  may be configured to call this tessellation program for every primitive transmitted to programmable geometry engine , the user may influence the level of tessellation over various regions on a primitive-by-primitive basis.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 5","FIGS. 1-4"]},"As  shows, the method of processing a set of primitive commands starts at step  where a fixed function engine in programmable primitive engine , such as any of first fixed function engine , second fixed function engine  or Nth fixed function engine , receives a series of primitive commands. In step , the fixed function engine determines whether any of the received primitive commands are related primitive commands\u2014meaning, as previously described herein, that the fixed function engine determines whether it is supposed to process any of the received primitive commands. As previously described herein, in one embodiment, each primitive command includes one or more flags, each flag corresponding to a different fixed function engine in programmable primitive engine . For a given primitive command, each of the one or more flags is either enabled or disabled, thereby indicating whether the fixed function engine corresponding to a particular flag should process the primitive command. If the fixed function engine determines that none of the received primitive commands are related primitive commands, then the method proceeds to step  where the fixed function engine transmits the unprocessed received primitive commands to the next fixed function engine in programmable primitive engine . If, however, the fixed function engine determines that at least one of the received primitive commands is a related primitive command, then the method proceeds to step .","In step , the fixed function engine attempts to assemble a primitive using the vertex index information contained in the related primitive commands that have already been received. Being able to assemble the primitive confirms that the fixed function engine has received the index information for each vertex of the current primitive as well as a complete set of related primitive commands. If the fixed function engine is not able to assemble a primitive, then the fixed function engine has not yet received the complete set of related primitive commands. In the latter case, the fixed function engine waits to receive additional related primitive commands and then attempts to assemble a primitive again. The fixed function engine repeats the process of waiting for additional related primitive commands and attempting to assemble a primitive until it is able to assemble a primitive (thereby indicating that the fixed function engine has received the complete set of related primitive commands). Once the fixed function engine is able to assemble the primitive, then the method proceeds to step .","In step , the fixed function engine identifies the first primitive command in the set of related primitive commands to be processed. In step , the fixed function engine generates a program command corresponding to the first primitive command and transmits that program command to vertex engine  for processing. In step , the fixed function engine determines whether to wait until vertex engine  returns the corresponding results: before sending another program command to vertex engine  for processing. As previously described herein, the fixed function engine may make this determination from, for example, instructions included in the primitive command or program command currently being processed or from information included in results received from vertex engine  that correspond to a previously processed program command.","If the fixed function engine determines that it should not wait for vertex engine  to return the corresponding results, the method proceeds to step . If, however, the fixed function engine determines that it should wait for vertex engine  to return the corresponding results, then the method instead proceeds to step . In step , the fixed function engine waits for vertex engine  to process the program command and to return the corresponding results. In step , the fixed function engine receives the results from vertex engine  and interprets those results, and the method then proceeds to step .","In step , the fixed function engine determines whether it should transmit the same program command again to vertex engine  for processing. Again, as described previously herein, the fixed function engine may make this determination from, for example, instructions included in the primitive command or program command currently being processed or from information included in results received from vertex engine  that correspond to a previously processed program command. If the fixed function engine determines that it should transmit the same program command to vertex engine , then the method returns to step . If, however, the fixed function engine determines that it should not transmit the same program command to vertex engine , then the method instead proceeds to step .","In step , the fixed function engine determines whether all primitive commands in the set of related primitive commands have been processed. If all related primitive commands have been processed, then the method returns to step  where the fixed function engine transmits all received primitive commands that remain unprocessed to the next fixed function engine in programmable primitive engine . If, however, all related primitive commands have not been processed, then the method instead proceeds to step . In step , the fixed function engine identifies the next primitive command in the set of related primitive commands to be processed, and the method returns to step .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 6","FIGS. 1-4"]},"As shown in , the method of processing a primitive command starts at step  where floating point processor  in vertex engine  receives a program command transmitted by one of the fixed function blocks in programmable primitive engine , such as any of first fixed function engine , second fixed function engine  or Nth fixed function engine . In step , floating point processor  retrieves the user-developed program or subroutine stored in graphics memory  at the memory location designated by the program pointer contained in the program command. Floating point processor  stores this program or subroutine in memory . In step , floating point processor  retrieves source data stored in vertex RAM  at the memory location(s) designated by the data pointer(s) contained in the program command.","In step , floating point processor processes the source data. The instructions contained in the user-developed program or subroutine stored in memory  configure floating point processor  to perform specific operations on the source data, producing processed vertex data. In step , floating point processor  transmits the processed vertex. data to one of the output buffers in vertex RAM , such as first output buffer , second output buffer  or nth output buffer , for storage. In step , floating point processor  transmits the corresponding results back to the fixed function engine in programmable primitive engine  that transmitted the program command to vertex engine . In step , floating point processor  waits to receive the next program command from one of the fixed function engines in programmable primitive engine . The method then returns to step .",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 7","b":["700","700","718","704","706","730","732"]},"As previously described herein, IDX  obtains primitive commands from a graphics memory such as graphics memory  (not shown). These primitive commands include a \u201cvertex list\u201d for at least one primitive. This vertex list includes vertices for such a primitive as well as indices for obtaining vertex data from vertex cache , if available, or from vertex RAM . The vertex list also may include indices for obtaining vertex data for neighbors and\/or edge data. Vertex streams are provided to vertex RAM . Vertex streams include vertex data obtained from a graphics memory such as graphics memory .","Vertex RAM  is configured similarly to vertex RAM  of FIG.  and is for storing both vertex data obtained from the graphics memory and processed vertex data output by vertex engine . As vertex RAM  is a shared resource, a memory resource manager  manages access to vertex RAM  by the different elements of programmable geometry engine  such as IDX , vertex engine  and the different fixed function engines in programmable primitive engine . In addition, as persons skilled in the art will recognize, vertex RAM  includes a memory controller, such as memory controller , through which vertex engine  accesses user-developed programs or subroutines for primitive processing operations (as specified by the program commands received from programmable primitive engine ) as well as programs or subroutines for vertex shading operations.","Vertex engine  includes a vertex cache , memory resource manager , one or more vector engines  and a scheduler . Vertex engine  is configured to function in the same general manner as vertex engine , as described above in conjunction with FIG. .","Programmable primitive engine  includes three fixed function engines, a subdivision engine , a mesh engine  and a general program\/software clipper , each of which is configured to enable programmable geometry engine  to implement a specific user-programmed function as described in further detail herein. Programmable primitive engine  also includes a FIFO buffer , which is coupled to subdivision engine  and mesh engine , and a FIFO buffer , which is coupled to mesh engine  and general program\/software clipper .","Primitive assembly unit  has similar functionality to that of viewport\/set-up unit  of FIG. . Primitive assembly unit  is therefore configured to perform viewport transformations, viewport clipping, matrix translation to screen space, and the like, as well as triangle or primitive set-up, derivative computations, culling and the like.","As  also shows, programmable primitive engine  may be configured to implement all or part of a programming model that includes four different types of user-developed primitive programs. The four types of primitive programs are a single-vertex or transform program, a subdivision program suite, a mesh program suite and a general program. As previously described herein, each of the fixed function engines in programmable primitive engine  may be configured to cause vertex engine  to perform primitive processing operations using one of the four types of user-developed primitive programs. In the embodiment of , subdivision engine  is configured to cause vertex engine  to perform primitive processing operations using the suite of user-developed subdivision programs, mesh engine  is configured to cause vertex engine  to perform primitive processing operations using the suite of user-developed mesh programs, and general program\/software clipper  is configured to cause vertex engine  to perform primitive processing operations using the user-developed general program.","The single-vertex or transform program accepts one vertex as input and produces one vertex as output. Single-vertex programs may be used for transformation and per-vertex lighting setup. Single-vertex programs may be used in conjunction with other program types, but the single-vertex program typically is run prior to providing vertices to either subdivision, mesh or general programs.","The subdivision program suite includes six programs (or subroutines) that are used to subdivide one or more primitives. The six programs are an edge test program, a limit point program, a face control point program, an edge control point program, a vertex control point refinement program and edge data refinement program.","The edge test program is used to determine if an edge should be subdivided or further subdivided. For example, if the program computes an edge value greater than 1.0 for a particular edge, then that edge is divided and each resulting subdivision is subject to possible additional subdivision. If the program computes an edge value less than or equal to 1.0 for the edge, then the edge is not divided. The edge test program may have access to control points of the edge being tested and may be able to access one-ring neighbors of those control points. Further, the edge test program may have access to the limit points of the endpoints of the edge being tested but not to the one-ring neighbors of those limit points.","The limit point program typically is used to calculate a limit point (i.e., the final position of a vertex) from a control point and the one-ring neighbors of that control point.","The face control point program is used to determine a new control point in the center of a face of a primitive. The face control point program typically is used only in quad subdivision schemes. In many instances, the new control point is simply the average of the four vertices of the face of the quad at issue.","The edge control point program typically is used to determine a new control point in the center of an edge.","The vertex control point refinement program is used to refine a control point prior to instituting the next level of subdivision. The control point at the current subdivision level corresponding to the refined control point and the neighbors of the control point at the current subdivision level may be used as inputs to vertex control point refinement program.","The edge data refinement program is used to determine edge data for the two new edges created when an edge having edge data is subdivided. The inputs to the edge data refinement program are the control points of the edge prior to being subdivided and the original edge data of that edge. The edge data refinement program computes new edge data for the new edge connecting vertex  to the new edge control point. The edge data refinement program typically is executed twice, once for each new edge, with the vertices being swapped the second time the program is executed.","The mesh program suite includes three programs used for tessellation. The three programs are a mesh global constants evaluation program, an adaptive mesh density program and a mesh points evaluation program.","The mesh global constants evaluation program is used to perform certain up-front tessellation-related computations, such as calculating Bezier control points for NPatches. This program typically is executed once per primitive prior to evaluating any sample points. Primitive data are the inputs to the mesh global constants evaluation program, and the output is a single vertex. The data in this single vertex may be made available to the mesh points evaluation program.","The adaptive mesh density program is used to compute the integer or fractional tessellation values for the sides of a primitive. This program enables adaptive tessellation and typically is executed once per primitive prior to evaluating any sample points. Primitive data are the inputs to the adaptive mesh density program, and the output is a single vector.","The mesh points evaluation program is used to evaluate a single position on a mesh. The inputs to this program are primitive data, the output of the global constants evaluation program and a position, (u,v) or (u,v,w), in parametric space, and the output is a single vertex.","Finally, the general program is used to arbitrarily generate primitives of a single type. The inputs to this program are the primitive data, and the outputs are streams of vertices of arbitrary length. The output type may be any type of primitive, including strips or fans of that type of primitive. Further, the general program may be executed using the primitives generated by the mesh and subdivision programs.","One advantage of the disclosed fixed function engine (e.g., first fixed function engine ) is that it enables programmable geometry engine  to be configured to implement specific user-programmed functions. This functionality provides users with the ability to influence a variety of computational parameters and metrics that determine how a graphics processor (e.g., graphics processor ) actually generates primitives in the graphics pipeline (e.g. graphics pipeline ). Another advantage is that the disclosed fixed function engine provides programmable geometry engine  with the flexibility to perform vertex operations before and\/or after primitive operations. Such flexibility in the architecture enables matrix palette skinning to be performed after tessellation, if so desired. In addition, programmable geometry engine  that includes multiple fixed function engines may be configured with scheduler  that arbitrates access to one or more vertex engines  among the different fixed function engines. Scheduler  may be configured to load balance among the different fixed function engines by allowing a fixed function engine with greater processing needs to transmit program commands to vertex engine(s)  more frequently than those fixed function engines requiring less processing support. Such load balancing may reduce bottlenecks in the graphics pipeline.","The invention has been described above with reference to specific embodiments. Persons skilled in the art, however, will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
