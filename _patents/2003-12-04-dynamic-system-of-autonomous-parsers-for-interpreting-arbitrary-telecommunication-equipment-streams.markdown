---
title: Dynamic system of autonomous parsers for interpreting arbitrary telecommunication equipment streams
abstract: A system for parsing an arbitrary input stream is provided that includes a plurality of parsers -operable to parse an input stream, each parser corresponding to a unique input structure, and a parser selection agent  operable to receive the input stream and select a subset of the plurality of parsers to parse the input stream.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07873992&OS=07873992&RS=07873992
owner: Avaya Inc.
number: 07873992
owner_city: Basking Ridge
owner_country: US
publication_date: 20031204
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","The Parsing and Encoding Agents","The Encoding Agent","Autonomous Heuristic Parser"],"p":["The present invention is directed generally to parsers and specifically to parsers for interpreting arbitrary streams of information.",{"@attributes":{"id":"p-0003","num":"0002"},"figref":"FIG. 1","b":["100","104","108","112","116","100","104","120","124","108","100","104","128","132","136","124","136","140","140","144","148"]},"The alarm handler  receives alarms and\/or error messages from the enterprise telecommunication component , reads the alarm and\/or error messages, optionally adds additional information depending on the application, formats, and forwards the alarms to the alarm fault manager  either via a serial interface (not shown) and the enterprise modem , typically in ASCII form, or via an ethernet interface (not shown), typically in a collection of packets constructed as defined in the TCP\/IP suite of protocols. The alarm handler  can add to the alarm and\/or error message a standardized header to aid in parsing the alarms or route the alarms to specific alarm reception centers that anticipate the form of the alarm.","The alarm fault manager  accepts and processes messages received from the alarm handler, logs the messages and passes the processed information to the database . The manager  comprises an encoder , an IP alarm manager , and a formatting agent . The encoder  passes processed Simple Network Management Protocol or SNMP messages from the alarm handler  to the formatting agent  and receives the messages back in ASCII form. An example of a suitable encoder is the G2\u2122 encoder manufactured by Gensym\u2122. The formatting agent  also formats the messages into a specified format for further processing. The formatting agent  further includes various parsers to parse the received messages and an encoder application (not shown) to encode the alarm information into the fields in the specified format. The encoder  correlates and filters the messages, and the IP alarm manager  provides an application processing interface with the database  for the processed, correlated and filtered messages.","The service provider typically monitors alarms generated by various types of enterprise telecommunication components and alarm handlers. For example, the telecommunication components can be PBX's made by manufacturers including Avaya Inc.\u2122, Northern Telecom\u2122, and Siemens\u2122. The alarm handler can also be made by different manufacturers, such as the Access Security Gateway\u2122 manufactured by Ion Network\u2122 and Site Event Buffer\u2122 manufactured by Teltronics\u2122. The ability to process the arbitrary streams from various manufacturers using differing alarm syntaxes, symbols, and formats is limited. The alarm messages are vendor specific and not standardized. In addition, an alarm stream of one syntax and format may be nested deep within another alarm stream of a different syntax and format without any header information to help differentiate among the differing alarm streams. To make matters worse, some alarm formats are proprietary and must be reverse engineered. The parsers currently in the formatting agent  employ rather simplistic parsing techniques that are often unable to parse accurately the alarm streams, thereby diminishing the ability of the service provider to accurately and effectively monitor the alarms received from the enterprise network.","These and other needs are addressed by the various embodiments and configurations of the present invention. The present invention is directed to parser designs able to parse streams of information containing differently structured information and differently structured streams of information generated by one of a number of possible computational sources.","In a first embodiment, a method for parsing an arbitrary input stream is provided that includes the steps of:","(a) receiving an input stream that includes information defined by first and second input structures;","(b) providing some or all of the input stream to one or more of a number of parsers;","(c) receiving output from each of the parsers; and","(d) performing one or more of the following substeps:\n\n","A parsing agent typically manipulates a number of individual (autonomous) parsers. The parsing agent can provide a standardized, vendor independent method of identifying, parsing and classifying alarms\/error messages for a variety of differing protocols, such as Northern Telecom\u2122 PBX, Northern Telecom\u2122 Meridian Mail\u2122, Northern Telecom\u2122 SNMP traps, Siemens\u2122, Access Security Gateway\u2122, and Site Event Buffer\u2122 telecommunication equipment at a single, centralized site over commonly shared trunks.","The parsing agent can return a variety of differing outputs, which in a preferred configuration is a parse tree. The nodes of the parse tree can be traversed, using recursive function calls, to identify nodes requiring additional parsing or nodes of interest to a client.","The selection of the parser to parse differing portions of the input stream can be effected in many ways. In one configuration, one or more tokens are identified in the input stream, and, based on the identified tokens, one of a plurality of parsers is selected. As will be appreciated, \u201ctokens\u201d refer to a definition of a grouping of characters. Each token typically has a corresponding regular expression related to the grouping of characters. A \u201cregular expression\u201d refers to ways of defining a possible series of characters and normally include a regular-expression definition comprising a set of characters (the alphabet), productions, a set of operators, character classes, and grouping parentheses). In another configuration, the parser is typically selected when a match condition is found to exist based on the parsed output. Where multiple parsed outputs correspond to the same segment of the stream, it is determined which of the outputs most likely corresponds to the segment. The determination can be made using any suitable technique, such as a least squares fit analysis to assess the degree to which the output matches the segment. The output having the best fit is selected.","In a second embodiment, the method is performed by a dynamic system of autonomous parsers for converting arbitrary telecommunication data streams. The system behaves outwardly as a single parser. The system is dynamic in that it follows a trajectory in some space of points (defined in mathematics as a manifold). In the embodiment, the points represent discrete parsers. The parsers are autonomous because they are not informed about what sort of input they will receive. Accordingly, the parsers must cooperate and\/or compete amongst themselves as to which ones will ultimately be applied. The system is arbitrary in and that the system may easily incorporate new data streams. The system is able convert telecommunication data streams in that the system transforms the input into a standard form rather than simply interpreting the input.","In another embodiment, an encoding agent is provided that transforms alarm\/error messages received in a number of different formats and\/or texts into a universal format and\/or text for further processing. The encoding agent can provide not only a simple alarm type code but also include a maintenance object and additional operator data, known as the case object, to technicians and downstream software such as expert systems. The expert systems can use the case object to automatically service the alarmed equipment without human intervention, resulting in substantial cost savings. The encoding agent further can provide for the economies of multi-server\/single queue alarm reception that reduce the number of public switch telephone network trunks required for alarm reception because all of the alarms are funneled through a single piece of hardware and software.","In yet another embodiment, a method for parsing computer generated information is provided that includes the steps of:","(a) receiving a stream of information generated by one of a number of possible different computational sources, with each computational source generating a stream corresponding to a unique input structure;","(b) comparing some or all of the stream with a set of tokens to provide a subset of tokens identified therein;","(c) heuristically identifying, from among a number of possible input structures and\/or a number of possible computational sources, an input structure corresponding to the stream and\/or a computational source that generated the stream; and","(d) parsing the stream based on the identified input structure and\/or computational source.","Each of the tokens can have a corresponding method expressing a set of syntactical and\/or semantical relationships relating to the respective token or a set of tokens of which it is a member. In that event, the heuristically identifying step can invoke a corresponding method for each token in the subset of tokens. The methods can cause a set of flags to be assigned a corresponding set of values depending on the presence or absence of a syntactical and\/or semantical relationship. The values of the flags are used to heuristically identify the input structure and\/or computational source.","Unlike the prior art, this embodiment does not require the client to provide a flag external to the input stream to identify or assist in the identification of the input structure and\/or computational source.","The various embodiments of the present invention can have a number of advantages compared to the prior art. For example, the present invention does not require the use of a standardized header in alarm\/error messages because it can support communications from not only known alarm\/error message sources but also arbitrary (nonstandardized) sources. This ability permits the use of a single centralized alarm\/error message reception center. The single centralized alarm\/error message reception center can provide the economies of multi-server\/single queue alarm\/error reception that reduces the number of public switch telephone network trunks, equipment, and staff required for alarm reception because all alarms are funneled through a single piece of software and hardware. The present invention can capture more detail than prior art systems and even more detail than is generally provided by the headers of alarm\/error messages because formal language grammar descriptions can be used to generate automatically new alarm parsers. The use of grammars and parse trees can differ from prior art applications of formal language theory. In formal language theory, the practice is to have the parse trees generated from the grammar contain as much information about the input stream as possible; this results in very complex difficult-to-maintain grammars. The present invention commonly partitions the grammars into smaller, more maintainable segments that are then manipulated by the parser selection agent. The improved maintainability can reduce software support costs and new alarm streams can be more easily added.","These and other advantages will be apparent from the disclosure of the invention(s) contained herein.","The above-described embodiments and configurations are neither complete nor exhaustive. As will be appreciated, other embodiments of the invention are possible utilizing, alone or in combination, one or more of the features set forth above or described in detail below.",{"@attributes":{"id":"p-0036","num":"0037"},"figref":["FIG. 2","FIG. 1"],"b":["200","204","152"]},"Referring to , a more detailed view of the components of the parsing agent  is provided. The parsing agent  includes a parser selection agent  in communication with a plurality of parsers -. The parser selection agent  is typically a higher-level object that selects which of the plurality of parsers -are able to effectively parse all or portions of the incoming data stream. The parsers can be configured in a software design factory pattern. As noted previously, the incoming data stream is typically arbitrary in that it generally contains information having non-standard formats, which may be nested arbitrarily deep within one another without any header information to help differentiate among stream segments with different formats.","Using any of a number of selection techniques, the parser selection agent receives an input stream to be parsed and selects one or more parsers to receive all or specified parts of the stream. The technique, for example, can be to select all of the parsers, a subset of the parsers, and each individual parser in sequence after the previously selected parser provides parsed information. The selection process may be recursive or non-recursive, depending on the application.","Each of the parsers -can be any suitable computational component that identifies structure in information (e.g., data or code) and produces defined output based on the identification. The parser can employ any selected parsing algorithm, such as LL(k), operator precedence, simple precedence, SLR(k), LALR(k), LR(k), and general context free. As will be appreciated, \u201cS\u201d refers to simple, \u201cLA\u201d to look ahead, the first letter refers to how the input is read (L=left-to-right and R=right-to-left), the second letter refers to the kind of parse produced (L=leftmost derivation and R=rightmost derivation), and k refers to the number of lookahead symbols considered.","Each of the parsers -is defined by a unique input structure and a set of grammars\/grammar rules that define what type of information it can successfully parse. For example, the first parser uses a first input structure and set of grammars\/grammar rules to parse information having a first structure, and the second parser uses a second input structure and set of grammars\/grammar rules to parse information having a second structure. The first and second structures are different, and the first and second sets of grammars\/grammar rules are different. In another example, the first parser parses a first programming language and the second parser a second different programming language.","In one configuration, the parser selection agent  is configured to perform prefiltering using regular expressions or tokens to make heuristic guesses about the input structure and therefore the appropriate parser(s) to select. For example, the agent can be configured to identify unique characters, groups of characters, or arrangements of characters that indicate a corresponding input structure of the information and provide the stream to the parser corresponding to that input structure. For example, the parser selection agent  can use lexical and grammar rules to identify a most likely parser or set of parser(s) to parse the information.","The parser selection agent  determines if there is a match between a selected parser and an assigned portion of the stream by evaluating the output received from the parser. A \u201cmatch\u201d, for example, can exist when a selected type of, a recognizable, a predetermined, and\/or a defined output is received. For example, the output for a match to exist can be a concrete or abstract syntax parse tree, a simple recognizable string, a \u201ctrue\u201d or \u201cfalse\u201d indication, one or more symbol tables, a number, and\/or other data structures as appropriate to the application. As will be appreciated, a \u201cconcrete\u201d parse tree is a structure that shows the syntax or structure of the input while an \u201cabstract\u201d parse tree is a structure that shows the semantics or meaning of the input. A \u201cno match\u201d can exist when the selection agent  receives a defined feedback, such as a null value, an error message, or a failure message, from the selected parser.","Where a single stream comprises multiple, differing input structures, which may be nested or embedded in one another, the selection agent  can initially divide the stream into separate strings and provide each string to a selected parser or group of parsers or provide the entire stream to each of a number of selected parsers either concurrently or sequentially. In the latter case, the parser may return acceptable and recognizable output on some portion of the stream and unacceptable and recognizable output on the other portions of the stream.","Referring now to , the operation of the parser selection agent  will now be described.","In step , the parser selection agent  receives a request to parse an input stream and receives the input stream. The request can include an indication of specific symbols or characters in the stream for which a parser is to be selected. The request can also include criteria for the parsed output depending on the type of parser requested.","In decision diamond , the agent  determines whether the input stream comprises an end of string indication. It not, decision diamond , is repeated until the indication is received. If so, the agent  proceeds to step .","In step , the agent  selects one or more parsers based on defined selection criteria. The selection criteria is discussed above.","In step , the agent  provides all or part of the input stream (or string) to the parsers selected in step  along with a command to parse the provided information and return a specific type of output. For example, the command \u201cparse file\u201d followed by the name of a file and the name of string commands the parser to parse the identified string (located in the named file) and return an abstract syntax parse tree. The command can be sent only to the selected parser(s) or be sent to an application programming interface or API and include a \u201ctype\u201d field, which indicates which of the parsers is to execute the command. The type field is indicative of a particular input structure. The API would select the parser to execute the command based on the type field.",{"@attributes":{"id":"p-0049","num":"0050"},"figref":"FIG. 5"},"In step , the parser receives the request to parse and the input string.","In step , the characters in the string are mapped by a lexer to tokens using the tokens' respective regular expressions to provide a first output . The first output is useful where an input stream is being scanned to determine structure without the construction of a parse tree or where only a few pieces of information need to be extracted.","In steps  and , first pass syntactical analysis is performed in which tokens are grouped into structured phrases. The grouping can be effected in one pass to produce a second output  or multiple passes to form a third output . In the single pass configuration, analysis and synthesis are performed concurrently. In the multiple pass configuration, analysis is performed first and synthesis second. The third output is typically a parse tree, which is traversed during the synthesis phase. As will be appreciated, only tokens of interest are included in the nodes of the parse tree.","In step , semantic analysis is performed. Semantic analysis assigns meaning to structure or to the third output  to produce a fourth output . As will be appreciated, semantical analysis can be performed as tokens are processed, as a separate pass after a parse tree is constructed as shown in step , or at both of these times. Any of a number of techniques can be used, from informal code fragments to formal attribute grammars. Attribute grammars associate data elements with nodes, specify equations to propagate the data, and a mechanism to perform the evaluation. When attribute grammars are used, each of the parsers -corresponds to a unique set of attribute grammars.","In step , any of the first, second, third or fourth outputs are provided to the parser selection agent .","Referring again to  in step , the agent  receives output from the selected parser(s) and in step  selects the portions of the output from the selected parser(s) for which a \u201cmatch\u201d condition is found. Where multiple parser(s) return a parse output, known mathematical techniques, such as a least squares fit, can be used to determine which of the parser(s) is a true match for the corresponding portion of the input string. In decision diamond  if any portion of the string only has a \u201cno match\u201d condition on any portion of the string, the agent  can return to step  and select one or more additional parsers using the criteria previously described. This is effected by comparing the successfully parsed string portions against the original stream and identifying string portions which were not successfully parsed. When no parser can be found to match a portion of the stream or the entire stream, an error message may be returned to the requestor or client.","In one embodiment, recursive node processing can be performed on a parse tree output to identify nodes requiring additional parsing. In recursive node processing, the agent  analyzes the nodes of the parse tree (e.g., evaluate the types of nodes in the tree) and, based on the nodal analysis, selects one or more additional set(s) of parsers to parse the identified nodes.","The successfully matched portions of the stream is an optional first selection agent output  to be returned to the requesting computational component.","In step , the agent  can perform recursive node processing of the output when the output is a tree structure to identify nodes of interest to the requestor. The identified nodes of interest form an optional second agent output .","In step , the first and\/or second selection agent output ,  is provided to the client requestor.","In another parser system configuration which is referred to hereinafter as the chain of unique responsibility parser, the parser system output is different in certain respects from that of the parser system configuration described above. The chain of unique responsibility parser appears to a client (either a human user or a software application) as a single parser that is invoked with an input string of characters or input stream to be parsed and, like the previously described parser system configuration, returns to the client some set of data structures that describe the structure of the input. These data structures may include a parse tree, one or more symbol tables, and\/or other data structures as appropriate to the application. The difference in output from the previously described configuration is that, when no parser can be identified to handle the input stream or more than one can be identified, then an error message is returned to the client. In the case of the previously described parser system configuration, it is possible to have more than one parser be able to parse the same or differing segments of the input stream without an error condition.","The chain of unique responsibility parser is applied in a dynamic data environment, with new language dialects and parsers being added periodically. These extensions need to be incorporated while minimizing the potential for introducing errors in the previously existing implementation.","Internally, the chain of unique responsibility parser is configured as depicted in , namely a higher level parser selection agent  and a set of lower level parsers -, with each parser -being configured to parse a different language dialect. The beginning of the input string to be parsed is passed to each parser, either sequentially or in parallel, to make a determination as to whether each parser can parse the input. Each parser receives input of sufficient length, based on the parser, to be able to accept (a \u201cmatch\u201d condition) or reject (a \u201cno match\u201d condition) the received string. When no parser can parse the received string (there is no \u201cmatch\u201d condition), an error message is returned to the client. When multiple parsers indicate a \u201cmatch\u201d condition, an error message is also returned to the client since each input string is a distinct language dialect to be processed by a distinct parser. The latter situation indicates either an incomplete input string fragment or an implementation error in one or more parsers. It is preferable to detect a problem as soon as possible to facilitate repair and to prevent erroneous processing by the wrong parser resulting in incorrect output. When a unique parser is identified (only one \u201cmatch\u201d condition is found), it is passed the entire input string for processing and the result of the parse is returned to the client.","The encoding agent  encodes alarms and error messages of differing types and formats\/structures into a standard format\/structure. In one configuration, the encoding agent  uses a software pattern called an abstract adapter. The encoder includes the following components: (a) a parse tree, such as an abstract syntax tree, with uniquely named nodes (which contain information of interest) provided by the parser selection agent ; (b) an abstract iterator or search engine (not shown) used to traverse the parse tree; and (c) a formatting engine (not shown) that uses the abstract iterator to locate nodes of interest and convert the associated alarm text to a standard format.","The standardized format of the alarms\/error messages includes a plurality of fields. The fields include a first field comprising a prefix and a product ID\/alarm ID (identifying the alarmed component and\/or component issuing the alarm), a second field comprising a space character, a third field comprising the day of the month for the alarm\/error event, a fourth field comprising a field separator, a fifth field comprising the hour of the day of the alarm\/error event, a sixth field comprising a field separator, a seventh field comprising a minute of the alarm\/error event, an eighth field comprising a field separator, a ninth field comprising an alarm\/error type indicator, a tenth field comprising a field separator, an eleventh field comprising alarm information (e.g., the text of the alarm\/error message), and a twelfth field comprising a space character.","The operation of the encoding agent  will be discussed with reference to .","In step , the encoding agent receives the first and\/or second selection agent output , . As noted, the output is preferably in the form of a parse tree, the nodes of which contain desired or selected information.","In step , the encoding agent  iteratively traverses the nodes of the parse tree to locate node(s) of interest. As will be appreciated, the nodes can include any of a number of structures such as a token, a regular expression, a boolean truth value, a string, and\/or a number. This is typically done by identifying defined information in the nodes that is of interest.","In step , the formatting engine converts each of the located node(s) of interest into a standard format. This step may be performed as each node is located or after all of the nodes are located and marked in some manner, such as using a flag. The engine enables alarms\/error messages from different manufacturers and types of devices to be placed in a common format and, in some configurations, using common characters or a standard text to define similar types of events\/information. For example, an alarm value \u201c03\u201d of one alarm protocol will be converted to a corresponding standard alarm value in a standard protocol, such as \u201c01\u201d, for a common type of alarm.","In step , the alarm message is logged by the alarm fault manager .","In step , the encoding agent  obtains the product ID value (if not already in the alarm\/error message), and in step  places the product ID value in the corresponding alarm\/error message.","In step , the revised alarm\/error message is provided to the formatting agent  when further processing is required or to the alarm manager  for entry into the database .","In another embodiment, an autonomous heuristic parser is provided. The autonomous heuristic parser is designed to parse a set of computer-generated data from a number of sources, such as the digital screen representations from various telecommunications systems, without being informed ahead of time which computational component source the data was generated by (in the case of screens, without being informed ahead of time from which screen the input was taken). In a prior art approach, a tag is passed to the parser indicating the type of screen from which the input string was taken, along with the input string to be parsed, to direct the parser how to parse the string to locate the desired information. The tag, for example, informs the parser what part of the string to ignore and what to parse. However, this approach requires an extra selection step to select a parser and has the potential to cause an error return or incorrect parsed output if the wrong tag is supplied to the parser with the input. In the autonomous heuristic parser, only the input string is provided. No external tag is supplied to the parser with the input string. The parser is able to determine autonomously, using a declarative programming rather than a procedural programming approach, from the beginning of the string which set of screens (or which set of sources) are candidates to have generated the input and then heuristically narrow the field to a single candidate and perform the parse without additional external information. The lexer of the heuristic parser is configured to ignore extraneous information in the string. The autonomous heuristic parser is applied typically in a static environment, in which all the language dialects are known at the time of the parser implementation.","Internally, the specifications of all language dialects to be parsed are preferably implemented with a single parser. In this configuration, the heuristic parser is configured to parse a plurality of differing input structures using a specification aggregating the varying input structures or tokens\/grammars\/grammar rules\/attribute grammars for all of the input structures. As will be appreciated, the heuristic parser can also be implemented using a design similar to that of , in which a higher level object parser selection agent acts as the heuristic parser and, when a decision is made from a portion of the input stream as to which parser is a match, provides the entire input stream to an appropriate lower level parser to complete the parse of the stream. The latter implementation is, however, more complex and generally not preferred.","After parsing the beginning of the input string, the parser can determine autonomously which of the language dialects it has been given, without being told explicitly ahead of time by a tag which dialect to expect. This approach can eliminate a source of error in which the wrong dialect could be specified for an input string, resulting either in an error or an incorrect result.",{"@attributes":{"id":"p-0075","num":"0076"},"figref":"FIG. 7"},"Referring to , the architecture comprises an enterprise telecommunications component  such as PBX, in communication with an interface device , such as an Access Secured Gateway\u2122 or Site Effect Buffer\u2122. Modems  and  are provided to convey communications back and forth via the Public Switch Telephone Network . An administrative server  is provided at the service provider side of the communications link. The administrative server  includes, for example, an expert system. A heuristic parser  is in communication with the administrative server . The administrative server  requests that the PBX provide the digital representations of one or more PBX screens to permit the identification of selected information in the graphical information in the digital representation. As will be appreciated, the digital representation can include a variety of graphical information, such as hardware and\/or software release numbers, font specifications, and displayed text.","In effect, the heuristic parser  compares the input stream to a group of tokens and grammars, identifies one or more tokens and grammars that match a parsed portion of the input stream, and, based on the identified set of tokens and grammars, identifies the appropriate input structure from a number of possible input structures to use in parsing the input string. The heuristic parser can use lexical analysis, syntactical analysis, semantical analysis, and a combination thereof to identify a group of potential input structures and finally the correct input structure. In lexical analysis, certain tokens and grammars can be unique to a particular input structure and other tokens and grammars shared by multiple input structures. In syntactical analysis, the tokens are grouped into structured phrases. In semantical analysis, meaning is assigned to the identified tokens. In a preferred embodiment, a table is provided listing tokens and, for each token, a corresponding method or routine to be invoked when the token is identified. The method or routine includes expressions of syntactical and\/or semantical relationships involving or otherwise related to the presence of the respective token. When a token is identified and the corresponding method is invoked, various other characters or tokens, if identified, cause a flag to be set to a first state and if not identified cause the flag to be set to a second different state. Depending on the tokens identified and the flag setting(s), the further performance of lexical, syntactical and\/or semantic analyses is directed and\/or the source of the input stream or the input structure can be identified. Stated another way, the methods and flag setting(s) heuristically narrow down the field of candidate input structures to a single input structure.","A sample table of tokens in the form of regular expressions and corresponding methods is depicted below:",{"@attributes":{"id":"p-0079","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"TOKEN","METHOD"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t=<ADDR2>","{ addr2Action( t ); }"]},{"entry":[{},"| t=<DATA>","{ dataAction( t ); }"]},{"entry":[{},"| t=<MENUCMD>","{ menuCmdAction ( t ); }"]},{"entry":[{},"| t=<CSMONITOR>","{ csMonitorAction ( t ); }"]},{"entry":[{},"| t=<SERVICE>","{ serviceAction ( t ); }"]},{"entry":[{},"| t=<CUSTOMER>","{ customerAction ( t ); }"]},{"entry":[{},"| t=<NODE>","{ nodeAction ( t ); }"]},{"entry":[{},"| t=<SUPPORT>","{ supportAction ( t ); }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The specifications for the methods corresponding to tokens \u201c<ADDR2>\u201d, \u201c<DATA>\u201d, \u201c<MENUCMD>\u201d, and \u201c<CSMONITOR>\u201d are as follows:",{"@attributes":{"id":"p-0081","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/\u2003Called on ><ADDR2> tokens."},{"entry":"private void addr2Action ( Token t )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show_T ( ADDR2\u2033, t );"]},{"entry":[{},"curAddr = t.image;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"\/\/\u2003Called on <DATA> tokens."},{"entry":"private void dataAction ( Token t )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show_T ( \u201cDATA\u201d, t );"]},{"entry":[{},"\/\/ Look for \u201cEMML\u201d followed by a character that is not a space."]},{"entry":[{},"\/\/ If found, save the rest of the string as the version number."]},{"entry":[{},"if ( t.image.startsWith ( \u201cEMML\u201d ) ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int c = t.image.charAt ( 4 );"]},{"entry":[{},"if ( c != 32 )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"version = t.image.substring ( 4 );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Look for the string defined in refNumber (the 2nd if below),"]},{"entry":[{},"\/\/ and if found, set the sawRefNo flag. The very next DATA token"]},{"entry":[{},"\/\/ contains the version number. Next time we get here, the flag"]},{"entry":[{},"\/\/ is true, so pick out the 3 chars that comprise the version"]},{"entry":[{},"\/\/ number, and format them with \u2018.\u2019 chars. Clear the flag."]},{"entry":[{},"if ( sawRefNo ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"index = t.image.lastIndexOf ( \u201c\u2002\u201d );"]},{"entry":[{},"refVersion = t.image.substring( index+1 );"]},{"entry":[{},"version = refVersion . substring ( 7, 8 )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"+ \u201c.\u201d"]},{"entry":[{},"+ refVersion . substring( 8, 9 )"]},{"entry":[{},"+ \u201c.\u201d"]},{"entry":[{},"+ refVersion . substring( 9, 10 );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sawRefNo = false;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"else if ( t.image.equals( refNumber ) )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"sawRefNo = true;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Build a node that contains the version number."]},{"entry":[{},"if ( ( vers == null ) && ( version != null ) ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tree = new SimpleNode( \u201cStart\u201d, null );"]},{"entry":[{},"vers = new SimpleNode( \u201cVersion\u201d, version );"]},{"entry":[{},"tree . AddChild( vers, 0 );"]},{"entry":[{},"vers . SetParent( tree );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ CS Monitor Screen"]},{"entry":[{},"if (onCSMonScr ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if ( st == null )"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"st = new SymTab( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String s = t.image;"]},{"entry":[{},"if ( ( rowService != null ) && ( curAddr.startsWith( rowService"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"st . put ( ServiceText, t.image );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else if ( ( rowCustomer != null ) && ( curAddr.startsWith) rowC"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"st . put ( CustomerText, t.image );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else if ( ( rowNode != null ) && ( curAddr.startsWith( rowNode"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"st . put( NodeText, t.image );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else if ( ( rowSupport != null ) && ( curAddr.startsWith( rowSu"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"st . put ( SupportText, t.image );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Called on <MENUCMD> tokens."]},{"entry":[{},"private void menuCmdAction ( Token t )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show_T( \u201cMENUCMD\u201d, t );"]},{"entry":[{},"\/\/ Check the end of the menu cmd strings for the commands"]},{"entry":[{},"\/\/ in which we're interested (target1 & 2), and if found,"]},{"entry":[{},"\/\/ save the associated cmd tag in the . . .Tag. variable."]},{"entry":[{},"\/\/ Build a node that contains the command tag."]},{"entry":[{},"if ( t.image.endsWith( target1 ) ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"targetTag1 = t.image.charAt ( 0 );"]},{"entry":[{},"tag = new SimpleNode( \u201cCmdTag\u201d, String . valueOf ( targetTag1 )"]},{"entry":[{},"desc = new SimpleNode ( \u201cCmdDesc\u201d, target1 );"]},{"entry":[{},"tree = new simpleNode ( \u201cStart\u201d, null );"]},{"entry":[{},"tree . AddChild( desc, 1 );"]},{"entry":[{},"tree . AddChild( tag, 0 );"]},{"entry":[{},"tag . SetParent( tree );"]},{"entry":[{},"desc . SetParent( tree );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} else if ( t.image.endsWith( target2 ) ) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"targetTag2 = t.image.charAt( 0 );"]},{"entry":[{},"tag = new SimpleNode( \u201cCmdTag\u201d, String . valueOf( targetTag2 )"]},{"entry":[{},"desc = new SimpleNode( \u201cCmdDesc\u201d, target2 );"]},{"entry":[{},"tree = new SimpleNode( \u201cStart\u201d, null );"]},{"entry":[{},"tree . AddChild( desc, 1 );"]},{"entry":[{},"tree . AddChild ( tag, 0 );"]},{"entry":[{},"tag . SetParent( tree );"]},{"entry":[{},"desc . SetParent( tree );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ If searching - that is, the parser was called via the"]},{"entry":[{},"\/\/ StartSearch( String ) method. If the end of a MENUCMD"]},{"entry":[{},"\/\/ token matches the string, retrieve the first char of the token."]},{"entry":[{},"if ( searching && t.image.endsWith( findMe ) )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"foundMe = String . valueOf ( t.image.charAt ( 0 ) );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Actions called on the CS Monitor Download screen."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private void csMonitorAction( Token t )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show_T( \u201cCSMONITOR\u201d, t );"]},{"entry":[{},"onCSMonScr = true;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"private void serviceAction( Token t )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show_T( \u201cSERVICE\u201d, t );"]},{"entry":[{},"rowService = curAddr . substring( 0, 4 );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"private void customerAction ( Token t )"]},{"entry":[{},"("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show_T( \u201cCUSTOMER\u201d, t );"]},{"entry":[{},"rowCustomer = curAddr . substring( 0, 4 );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"private void nodeAction( Token t )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show_T ( \u201cNODE\u201d, t );"]},{"entry":[{},"rowNode = curAddr . substring( 0, 4 );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"private void supportAction( Token t )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ArtParserTokenManager . show _T( \u201cSUPPORT\u201d, t );"]},{"entry":[{},"rowSupport = curAddr . substring ( 0, 4 );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/\u2002Variables to record the parsing status."]},{"entry":[{},"\/\/\u2003Usage varies by parser."]},{"entry":[{},"private boolean lexErr = false;"]},{"entry":[{},"private boolean synErr = false;"]},{"entry":[{},"private boolean semErr = false"]},{"entry":[{},"private boolean debug = false;"]},{"entry":[{},"\/\/\u2002Symbol table populated by parser with data"]},{"entry":[{},"\/\/\u2002from the CD Monitor download screen."]},{"entry":[{},"private SymTab st = null;"]},{"entry":[{},"\/\/\u2002Variables for determining the version number of the product,"]},{"entry":[{},"\/\/\u2002and constructing Ast trees."]},{"entry":[{},"private SimpleNode tag = null;"]},{"entry":[{},"private SimpleNode desc = null;"]},{"entry":[{},"private SimpleNode vers = null;"]},{"entry":[{},"private static final String target1 = \u201cEMML11\u201d;"]},{"entry":[{},"private char targetTag1 = \u2018?\u2019;"]},{"entry":[{},"private static final String target2 = \u201cDirect AMO Dialog\u201d;"]},{"entry":[{},"private char targetTag2 = \u2018?\u2019;"]},{"entry":[{},"private boolean searching = false;"]},{"entry":[{},"private String findMe = null;"]},{"entry":[{},"private String foundMe = \u201c\u2009\u201d;"]},{"entry":[{},"private final String refNumber = \u201c| SP REFERENCE NO.\u201d;"]},{"entry":[{},"private boolean sawRefNo = false;"]},{"entry":[{},"private int index = \u22121;"]},{"entry":[{},"private String refVersion = null;"]},{"entry":[{},"private String version = null;"]},{"entry":[{},"\/\/\u2002Variables for recognizing data on the CS Monitor Download screen."]},{"entry":[{},"\/\/\u2002NOTE: The ...Text strings below MUST match the strings for"]},{"entry":[{},"\/\/\u2002these tokens in the lexical analyzer specification!"]},{"entry":[{},"private static final String ServiceText = \u201cService Area\u201d;"]},{"entry":[{},"private static final String CustomerText = \u201cCustomer Number\u201d;"]},{"entry":[{},"private static final String NodeText = \u201cNode\u201d;"]},{"entry":[{},"private static final String SupportText = \u201cSupport Center Phone No.\u201d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private boolean onCSMonScr = false;","\/\/ on the CS Monitor screen"]},{"entry":[{},"private String curAddr = null;","\/\/ current cursor address"]},{"entry":[{},"private String rowService = null;","\/\/ Service Area cursor row"]},{"entry":[{},"private String rowCustomer = null;","\/\/ Customer Number cursor row"]},{"entry":[{},"private String rowNode = null;","\/\/ Node cursor row"]},{"entry":[{},"private String rowSupport = null;","\/\/ Support Center cursor row"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PARSER_END (ArtParser)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As can be seen from the above specifications, flags include \u201csawRefNo\u201d, and \u201con CSMonScr\u201d.","The operation of the heuristic parser  will now be described with reference to .","In step , the heuristic parser  receives from the administrative server a request to parse an input stream and the input stream itself.","In step , the parser  maps characters to tokens and in step  records the token names and locations in the input stream. As will be, appreciated, the steps for creating tokens are normally (a) to divide up a representative stream into the fewest pieces that show some repeating structure; (b) for the pieces selected as meeting design criteria, to define a token to correspond to each group including a regular expression for the group; and (c) to give each token a name.","In step , for each recorded token a corresponding method is invoked to locate predetermined text in the string, set appropriate flags, and thereby identify the source of the input stream and the type of input stream or corresponding input structure. Steps  and  are performed heuristically until the correct input structure is identified.","In step , which may be performed during or after the heuristic determination of the appropriate input structure, a parse tree is created having nodes corresponding to the predetermined characters or groupings of characters of interest to the client requestor.","After the parse is complete, the parser , in step , provides the output to the administrative server .","A number of variations and modifications of the invention can be used. It would be possible to provide for some features of the invention without providing others.","For example in one alternative embodiment, the parsing agent  is used with arbitrary streams other than alarm streams. Typically, these arbitrary streams are computer generated. Examples of such streams include graphical information such as screen scrapes, and the like.","In another alternative embodiment, the parsing agent , encoding agent , and\/or heuristic parser  are implemented as a logic circuit, software, or as a combination of the two","The present invention, in various embodiments, includes components, methods, processes, systems and\/or apparatus substantially as depicted and described herein, including various embodiments, subcombinations, and subsets thereof. Those of skill in the art will understand how to make and use the present invention after understanding the present disclosure. The present invention, in various embodiments, includes providing devices and processes in the absence of items not depicted and\/or described herein or in various embodiments hereof, including in the absence of such items as may have been used in previous devices or processes, e.g. for improving performance, achieving ease and\\or reducing cost of implementation.","The foregoing discussion of the invention has been presented for purposes of illustration and description. The foregoing is not intended to limit the invention to the form or forms disclosed herein: In the foregoing Detailed Description for example, various features of the invention are grouped together in one or more embodiments for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus, the following claims are hereby incorporated into this Detailed Description, with each claim standing on its own as a separate preferred embodiment of the invention.","Moreover though the description of the invention has included description of one or more embodiments and certain variations and modifications, other variations and modifications are within the scope of the invention, e.g. as may be within the skill and knowledge of those in the art, after understanding the present disclosure. It is intended to obtain rights which include alternative embodiments to the extent permitted, including alternate, interchangeable and\/or equivalent structures, functions, ranges or steps to those claimed, whether or not such alternate, interchangeable and\/or equivalent structures, functions, ranges or steps are disclosed herein, and without intending to publicly dedicate any patentable subject matter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0028","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0030"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0031"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0031","num":"0032"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0032","num":"0033"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0033","num":"0034"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0034","num":"0035"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0036"},"figref":["FIG. 8","FIG. 7"]}]},"DETDESC":[{},{}]}
