---
title: Determining a mapping of an object to storage layer components
abstract: A method and apparatus for determining a mapping of a database object to storage layers is provided. According to one aspect, a database server generates views that represent which components of each storage layer store parts of the object. The views are based on information that the database server automatically gathers from one or more vendor libraries. Each library implements a common API. Each storage layer is associated with a library. The database server passes the object's identifier to each library's implementation of a get-mapping routine of the API. A process that is associated with the storage layer that recognizes the object's identifier responds with the identity of one or more components of the storage layer that store one or more parts of the object. The database server recursively uses this information to obtain mappings between storage layer components and underlying storage layer components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07577675&OS=07577675&RS=07577675
owner: Oracle International Corporation
number: 07577675
owner_city: Redwood Shores
owner_country: US
publication_date: 20030430
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION","Functional Overview","Determining which Components Store a Table","Determining a Mapping of a Storage Layer Component to Underlying Storage Layer Components","Mapping Information","Determining a Type of Relationship between Storage Layer Components","Example Database View","Managing Mapping Information","Using the Mapping Information to Improve Performance","Hardware Overview"],"p":["The present invention relates to data storage, and in particular, to determining a mapping of a database object to storage layer components.","An application, such as a database server, may store information on persistent storage devices, such as hard disk drives, so that the application can retrieve and use such information in the future. Because of the physical reality of persistent storage devices, persistent storage devices may be called \u201cphysical devices.\u201d On a physical device, information is typically stored in discrete logical units called \u201cblocks.\u201d For example, parts of a single file may be dispersed throughout multiple blocks on one or more physical devices. Each block stores a different part of the file. Each separate physical device may be viewed as a separate component within a storage layer.","Sometimes, an application indirectly interfaces with one or more physical devices through one or more intermediate storage layers that belong to a hierarchy of storage layers. Such a hierarchy of storage layers is also called an input\/output (I\/O) stack. For example, a database server application may interface directly with a file system. The file system may interface directly with a logical volume manager. The logical volume manager may interface directly with a storage subsystem that provides Redundant Array of Independent Disks (RAID), wherein each Disk is a separate physical device.","Through abstraction, each storage layer in the hierarchy may represent multiple different components of the storage layer as a single physical device. Such abstraction insulates upper storage layers from details that can be managed by lower storage layers. For example, a file may be divided into multiple parts, with each part being \u201cstored\u201d on a different logical volume. An application may instruct a file system to perform operations on the file without expressly indicating which logical volumes store the parts of the file. After receiving the file's identifier from the file system, a logical volume manager can determine which volumes store the parts of the file, and instruct a lower storage layer subsystem to perform corresponding operations on one or more of the relevant parts. Therefore, even though parts of a file may be dispersed throughout multiple logical volumes and multiple physical devices, the dispersion of the parts is transparent to the application that performs operations on the file.","It is useful to know on which physical devices the several blocks of a file are stored. In other words, it is useful to know a mapping between a file and the physical devices that collectively store the file. Such a mapping can be used, for example, to identify input\/output bottlenecks. However, due to the multiple intermediate storage layers discussed above, determining such a mapping can be a difficult, if not impossible, task.","For example, a \u201cfirst storage layer\u201d file system may be a product of a first vendor, a \u201csecond storage layer\u201d logical volume manager may be a product of a second vendor, and a \u201cthird storage layer\u201d RAID manager may be a product of a third vendor. Each vendor may or may not provide a tool to determine mappings between components of that vendor's storage layer and file parts stored on those components. Where such tools exist, they are not currently designed to work in conjunction with each other. Currently, in storage systems that involve multiple intermediate storage layers, there is no way for an application that only directly interfaces with an uppermost storage layer to determine which physical devices store blocks of a particular file.","In a database, a database object such as a table may be stored within a single file, or divided among multiple files. While a database server application may possess sufficient information to determine a mapping of a database object to one or more files, database server applications are currently unable to determine a mapping of a file to one or more physical devices in storage systems that involve multiple intermediate storage layers. By extension, database server applications are currently unable to determine a mapping of a database object to one or more physical devices in such storage systems.","A technique for determining a mapping of a database object to storage layer components that collectively store the database object is needed.","The approaches described in this section are approaches that could be pursued, but not necessarily approaches that have been previously conceived or pursued. Therefore, unless otherwise indicated, it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.","Techniques are described herein that allow a user or application to determine a mapping between a database object and components of a storage layer by querying one or more dynamically generated views that conveniently represent, for each storage layer in a storage system, which components of the storage layer actually or virtually store parts of the database object. Each view is defined by a query that extracts or derives data from tables that the view references. A database server automatically generates the views based on information that the database server automatically gathers from one or more vendor libraries, such as dynamic link libraries (DLLs).","Each vendor library includes one or more routines that implement a common Application Programming Interface (API). For the purpose of explanation, an embodiment shall be described in which each vendor library includes a \u201cget-mapping routine\u201d, and in which the interface to invoke the get-mapping routine is the same for all vendor libraries, though each of those libraries may implement the get-mapping routine in a different way.","A method and apparatus for determining a mapping of an object to storage layer components is described. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","Techniques are described herein that allow a user or application to determine a mapping between a database object and components of a storage layer by querying one or more dynamically generated views that conveniently represent, for each storage layer in a storage system, which components of the storage layer actually or virtually store parts of the database object. Each view is defined by a query that extracts or derives data from tables that the view references. A database server automatically generates the views based on information that the database server automatically gathers from one or more vendor libraries, such as dynamic link libraries (DLLs).","Each vendor library includes one or more routines that implement a common Application Programming Interface (API). For the purpose of explanation, an embodiment shall be described in which each vendor library includes a \u201cget-mapping routine\u201d, and in which the interface to invoke the get-mapping routine is the same for all vendor libraries, though each of those libraries may implement the get-mapping routine in a different way.","Each storage layer is associated with a get-mapping routine from one of the vendor libraries. According to one embodiment, to determine a mapping between a file and one or more second storage layer components, the database server passes the file's identifier to the first storage layer's implementation of the get-mapping routine. The first storage layer's get-mapping routine responds to the invocation with one or more identities of components of the second storage layer that store one or more parts of the file. The file itself may be viewed as a component of the first storage layer.","The database server uses the information obtained from first storage layer's get-mapping routine to recursively obtain information from lower storage layers. For example, to determine a mapping between a second-layer component and one or more third storage layer components, the database server passes the second-layer component's identifier to the second storage layer's get-mapping routine. The second storage layer's get-mapping routine responds to the invocation with one or more identities of components of the third storage layer that store one or more parts of the second-layer component. For each second-layer component that stores a part of the file (i.e., the first-layer component), the database server passes the second-layer component's identifier to the second storage layer's get-mapping routine. As a result, the database server obtains, from the second storage layer's get-mapping routine, identities for each component in the third storage layer that stores a part of a second-layer component that stores a part of the file.","Through this recursive technique, the database server ultimately obtains the identity of each physical device that stores one or more blocks of a file. Thus, the database server obtains a mapping between a file and one or more physical devices. For each database object in a database, the database server can determine one or more files that store the database object. Therefore, for every database object in a database, the database server can obtain mappings between a database object and one or more physical devices, and automatically and dynamically generate views that capture such mappings. To determine selected ones of such mappings, a user or application can query the views instead of struggling with multiple different vendor tools. As a result, a user or application can obtain a complete definition of a storage hierarchy and the relationships between the components thereof.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","100","102","104","104","116","116","106","106","106","106","104","104","104","106","104","106","104","106","100"]},"Storage layer A comprises a file . Thus, file  is referred to as a component of storage layer A. A file system may manage the components of storage layer A. Storage layer B comprises volumes A and B. Thus, volumes A and B are referred to as components of storage layer B. A logical volume manager may manage the components of storage layer B. Storage layer C comprises physical devices A-D. Thus, physical devices A-D are referred to as components of storage layer C. For example, the components of storage layer C may be independent physical devices in a RAID configuration. A RAID manager may manage the components of storage layer C.","Through abstraction, storage layers B and C may represent multiple ones of their respective components as a single physical device to the storage layer immediately above. In the example illustrated, storage layer C represents that separate physical devices A and B are a single physical device that comprises volume A. Consequently, the separateness of physical devices A and B is not apparent to entities that see only volume A. Similarly, storage layer C represents that separate physical devices C and D are a single physical device that comprises volume B. Consequently, the separateness of physical devices C and D is not apparent to entities that see only volume B. Likewise, storage layer B represents that separate volumes A and B are a single physical device that comprises file . Consequently, the separateness of volumes A and B is not apparent to entities that see only file .","The following example illustrates how parts of a single file may be distributed throughout multiple components of multiple storage layers of a storage hierarchy. A single file  may be divided into four subparts, each subpart comprising one or more blocks. A first subpart may be stored on physical device A. A second subpart may be stored on physical device B. A third subpart may be stored on physical device C. A fourth subpart may be stored on physical device D. Through a RAID manager associated with storage layer C, storage layer C represents physical devices A and B as a single physical device that comprises volume A. Also through the RAID manager, storage layer C represents physical devices C and D as a single physical device that comprises volume B. Thus, volume A virtually stores a first file part comprising the first and second subparts, and volume B virtually stores a second file part comprising the third and fourth subparts. Through a logical volume manager associated with storage layer B, storage layer B represents volumes A and B as a single physical device that comprises file .","According to one embodiment, each of get-mapping routines A-C resides in a different vendor library. However, through API , each of get-mapping routines A-C exposes the same common interface to database server . Thus, database server  interacts with each of get-mapping routines A-C by making calls through the same common interface provided by API . While each of get-mapping routines A-C may implement the API  in different ways, the names and the parameters accepted as input by the get-mapping routines are the same regardless of implementation.","For example, API  may define a routine with the name \u201cget-mapping\u201d that accepts a single parameter as input. The get-mapping routine B may be designed to determine which ones of volumes A and B store one or more parts of a file identified by the parameter. In contrast, the get-mapping routine C, while having the same name and input parameters as get-mapping routine B, may be designed to determine which ones of physical devices A-D store one or more parts of a volume identified by the parameter.","According to one embodiment, while each implementation of the get-mapping routine may operate relative to different ones of storage layers A-C in storage hierarchy , the function and results of the implementations of the method are similar. For example, regardless of the specific implementation, the get-mapping routine identifies one or more lower storage layer components that store divisions of a higher storage layer component identified by a parameter passed to the method. The component identified by the parameter may be a file, a volume, etc.","In various embodiments described hereafter, each get-mapping routine implementation is associated with a separate storage layer. However, in alternative embodiments, more than one storage layer may be associated with the same get-mapping routine implementation. The present invention is not limited to a one-to-one correlation between get-mapping implementations and storage system layers.","Because the interface exposed by each of get-mapping routines A-C is common, database server  can interface with each of get-mapping routines A-C in the same manner, without needing to determine which routine is associated with a particular storage layer. The definition of API  may be distributed to each vendor that produces a storage layer manager (e.g., a logical volume manager or RAID manager), so that each vendor can incorporate one or more routines that implements API  into the vendor library that corresponds to the storage layer.","According to one embodiment, to determine which components of a storage layer store parts of a database object, such as a table, database server  determines the identities of one or more files that collectively contain all of the parts of the database object. Parts of a database object may be contained in more than one file. Database server  may make such a determination based on information that database  stores.","For each file in which a database object part is contained, database server  does the following. Database server  invokes a get-mapping routine that is implemented by each of get-mapping routines A-C. In invoking each get-mapping routine, database server  passes a filename of the file to each routine implementation. For example, one such file may be file .","At least one of get-mapping routines A-C is associated with a storage layer that recognizes the filename. The get-mapping routine that is associated with a storage layer that recognizes the filename returns one or more volume identifiers. For example, in response to the invocation of the get-mapping routine, get-mapping routine A may determine that volume A stores a first part of the file identified by the filename, and that volume B stores a second part of file identified by the filename. Get-mapping routine A determines one or more volume identifiers, each of which stores a part of the file, and returns the one or more volume identifiers to database server . Thus, for each file, mappings between the file and one or more volumes are determined.","For each volume identifier, database server  does the following. Database server  invokes each of get-mapping routines A-C. This time, in invoking each get-mapping routine, database server  passes the volume identifier to each get-mapping routine.","At least one of get-mapping routines A-C is associated with a storage layer that recognizes the volume identifier. The get-mapping routine that is associated with the storage layer that recognizes the volume identifier returns one or more physical device identifiers. For example, in response to the invocation of the get-mapping routines, get-mapping routine B may determine that physical device A stores a first part of the volume identified by the volume identifier, and that physical device B stores a second part of the volume identified by the volume identifier. Get-mapping routine B determines one or more physical device identifiers, each of which stores a stores a part of a volume that stores a part of the file, and returns the one or more physical device identifiers to database server  as a result of the method. Thus, for each volume, mappings between the volume and one or more physical devices are determined.","By doing the above for each database object in a database, database  determines mappings between the database object and storage layer components that store parts of the database object at each level of granularity. Using these mappings, database  may dynamically generate views that a user or application can query to discover information about where any part of any database object or storage layer component is stored within any storage layer. In addition to the mappings described above, get-mapping routines A-C may return, to database , additional information that database  may use in generating the views. Examples of such additional information are provided below. Through the views, a complete picture of the relationships between components of each storage layer can be obtained. Using information obtained from the views, database I\/O performance can be evaluated, and relationships between storage layer components can be adjusted to improve database I\/O performance.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["200","200","102"]},"In block , an identifier of a component of a first storage layer is provided, through a common interface, to a first get-mapping routine that is associated with a first storage layer. For example, database server  may provide an identifier of file  to get-mapping routine A.","In embodiments where the database server does not know the correlation between the get-mapping routines A-C and the layers of the storage hierarchy, the database server may invoke all of get-mapping routines A-C during each iteration. Under these circumstances, only the get-mapping routine that recognizes the identifier returns positive results to the database server. As shall be described hereafter, those positive results are then used during the next iteration to get mapping information from the next lower layer in the storage hierarchy.","In block , one or more first mappings, between the components of the first storage layer and one or more components of the second storage layer, are received from the first get-mapping routine. The first mappings contain identifiers of each of the one or more components of the second storage layer. Continuing the example, database server  may receive, from get-mapping routine A, a mapping between file  and volume A, and a mapping between file  and volume B. Not recognizing the file identifier, get-mapping routines B and C return nothing to database server .","Recursively, in block , one or more identifiers, corresponding respectively to each of the one or more components of the second storage layer, are provided, through the common interface, to a second get-mapping routine that is associated with a second storage layer. Continuing the example, database server  may call get-mapping routine B to provide an identifier of volume A to get-mapping routine B. Similarly, database server  also may call get-mapping routine B to provide an identifier of volume B to get-mapping routine B.","As mentioned above, if database server  does not know which get-mapping routine is associated with a particular storage layer, then database server  also may make calls to get-mapping routines A and C. However, get-mapping routines A and C would not recognize the volume identifiers. Therefore, those routines would not return any positive results.","In block , one or more second mappings, between the one or more components of the second storage layer and one or more components of the third storage layer, are received from the second get-mapping routine. The second mappings contain identifiers of each of the one or more components of the third storage layer. Continuing the example, database server  may receive, from get-mapping routine B, as results of two separate invocations of the get-mapping routine B (one for each volume), a mapping between volume A and physical device A, a mapping between volume A and physical device B, a mapping between volume B and physical device C, and a mapping between volume B and physical device D. Not recognizing the volume identifiers, get-mapping routines A and C return nothing to database server .","The technique described above with reference to blocks - is not limited to two storage layers. The technique described above may be recursively applied to any number of storage layers. For each particular storage layer, identifiers of components of the particular storage layer may be provided to the get-mapping routine of the particular storage layer. In response to the provision of the identifiers, the get-mapping routine returns mappings between the components of the particular storage layer and one or more immediately-underlying-storage-layer components that store parts of the identified components of the particular storage layer.","When a get-mapping routine associated with a lowest storage layer is called, the get-mapping routine may return an indication that the components identified to the get-mapping routine are physical devices. A database server can determine from such an indication that the database server does not need to make any calls to get mappings for any lower storage layers. This is the case with storage layer C.","Along with a mapping between a particular storage layer component and one or more underlying storage layer components that store parts of the particular storage layer component, a get-mapping routine may return a component offset. The component offset indicates a beginning address in the underlying storage layer component where a part of the particular storage layer component is stored. A get-mapping routine also may return a size of the part. Additionally, a get-mapping routine may return an identity of the underlying storage layer in which the underlying storage component is contained.","In block , one or more database structures are generated based on the one or more first mappings and the one or more second mappings. Continuing the example, database  may generate database views, such as Oracle V$ tables, based on the mappings received from get-mapping routines A and B. The database views may be generated based on additional mappings received from additional get-mapping routines that are associated with additional storage layers. The database views may contain additional information derived from the information returned by the get-mapping routines.","By querying the database views, a user or application can determine, for any database object in the database, at any storage layer in the storage hierarchy, the identities of the components that store the parts. By querying the database views, a user or application can determine, for any block of a database object and any storage layer in the storage hierarchy, where the block is located in the storage layer. Together, the database views represent a complete \u201cpicture\u201d of the storage hierarchy, from database objects to blocks.","Parts of a component of a particular storage layer may be stored by one or more components of a storage layer immediately underlying the particular storage layer. The component of the particular storage layer may be referred to as a \u201cparent\u201d component of the underlying storage layer components that store the parts of the component of the particular storage layer. Inversely, the underlying storage layer components that store the parts of the component of the particular storage layer may be referred to as \u201cchild\u201d components of the component of the particular storage layer.","For example, physical device A may store a first part of volume A, and physical device B may storage a second part of volume A. In this case, components A and B can be referred to as child components of component A, and component A can be referred to as a parent component of components A and B. Similarly, components C and D may be called child components of component B, and component B can be called a parent component of components C and D.","The relationship between a parent component and one or more child components of the parent component may be any one of several different types of relationships. The type of relationship indicates how multiple child components are represented, or abstracted, as a single physical device to a parent component.","For example, a concatenation of components A and B may comprise volume A. In that case, component A contains a first sequential part of the data stored on volume A, and component B contains a last sequential part of the data stored on volume A.","For another example, component B may be a mirror of components C and D. In that case, components C and D store the same data. Mirroring is used, for example, when physical devices are in a RAID-1 configuration.","For another example, child components may be related to a parent component in a striping type of relationship. In that case, data is interleaved between the child components in equally sized sets of contiguous blocks called stripes. Striping is used, for example, when physical devices are in a RAID-0 configuration.","Once known, the type of relationship between a parent component and child components can be used in determining where parts of a database object, file, or other storage layer component are located. For example, if volume B is in a mirror type of relationship with physical devices C and D, and if volume B stores a part that is 50 kilobytes in size, then it may be determined that physical device C stores 50 kilobytes of the part, and physical device D also stores 50 kilobytes of the part.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 3","b":["300","300","102"]},"In block , an identifier of a component of a first storage layer is provided, through a common interface, to a get-mapping routine that is associated with the first storage layer. For example, database server  may provide an identifier of volume B to get-mapping routine B.","In block , a type of relationship between the component of the first storage layer and one or more components of the second storage layer is received from the get-mapping routine. Continuing the example, database  may receive, from get-mapping routine B, an indication that volume B is in a mirror type relationship with physical devices C and D. Some examples of types of relationships are mirror, concatenation, and striped configuration.","Along with the indication of the type of relationship between the component of the first storage layer and the one or more components of the second storage layer, identifiers of the one or more components of the second storage layer are received from the get-mapping routine that is associated with the second storage layer. The technique described above with reference to blocks - may be recursively applied to the identifiers of the one or more components of the second storage layer. For each particular storage layer, an identifier of a component of the particular storage layer may be provided to a particular get-mapping routine that is associated the particular storage layer. In response to the provision of the identifier, the particular get-mapping routine returns an indication of a type of relationship between the component of the particular storage layer and child components of the particular component, along with the identities of the child components.","In block , one or more database views are generated based on the type of relationship. Continuing the example, database  may generate database views, such as Oracle V$ tables, based on the type of relationship indicated by get-mapping routine B. For example, a view may indicate that volume B is in a mirror type relationship with physical devices C and D.","A user or application can query the one or more database views to obtain a complete concept of the components in each storage layer, and the types of relationships between components of different storage layers. For example, an application such as Oracle Enterprise Manager could generate a graphical representation of an entire storage hierarchy based on information queried from the database views. The storage hierarchy could be represented graphically as a tree of storage layer components.","Table 1 illustrates an example of selected columns and rows of a database view that shows where the parts of a database object are located in a storage hierarchy. Such a view may be derived, for example, by database server  using information that database  gathered by performing techniques  and , described above. The view illustrated in Table 1 may contain information selected from one or more other views.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Selections From An Example Database View"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["OBJECT","OBJECT","OBJECT","COMPONENT","COMPONENT","STORAGE"]},{"entry":["NAME","OFFSET","SIZE","OFFSET","IDENTIFIER","LAYER"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["EMP","\u20020","100\u2002","0","108","106A"]},{"entry":["EMP","\u20020","50","0","110A","106B"]},{"entry":["EMP","50","50","10\u2002","110B","106B"]},{"entry":["EMP","\u20020","25","0","112A","106C"]},{"entry":["EMP","50","50","0","112C","106C"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"The rows of Table 1 are generated for an example database object \u201cEMP\u201d that file  stores. In this example, the database object is 100 kilobytes (K) in size. The first column, \u201cOBJECT NAME,\u201d indicates that the name of the database object to which each row's data pertains. In this example, each row's data pertains to database object \u201cEMP\u201d. Each row contains data concerning a part of the database object at some level of granularity.","In this example, 50K of the 100K are stored virtually on volume A, and 50K of the 100K are stored virtually on volume B, as indicated by the \u201cOBJECT SIZE\u201d and \u201cCOMPONENT IDENTIFIER\u201d fields of the second and third rows. The \u201cOBJECT OFFSET\u201d of 0 in the second row indicates that the 50K stored on volume A are the 50K starting at offset 0 of the database object. In other words, the 50K stored on volume A are the first 50K of database object \u201cEMP\u201d. The \u201cCOMPONENT OFFSET\u201d of 0 in the first row indicates that the 50K stored on volume A begin at offset 0 of volume A.","The \u201cOBJECT OFFSET\u201d of 50 in the third row indicates that the 50K stored on volume B are the 50K starting at offset 50 of the database object. In other words, the 50K stored on volume B are the last 50K of database object \u201cEMP\u201d. The \u201cCOMPONENT OFFSET\u201d of 10 in the third row indicates that the 50K stored on volume B begin at offset 10 of volume B. The second and third rows additionally indicate that volumes A and B are components of \u201cSTORAGE LAYER\u201d B.","In this example, volume A comprises a concatenation of physical devices A and B. The fourth row indicates that 25K of the 50K stored on volume A are stored on physical device A, and that physical device A is a component of storage layer C. The fourth row indicates that the 25K stored on physical device A are the 25K starting at offset 0 of the database object. Based on the second row indicating that 50K of the database object stored on volume A are the 50K beginning at offset 0 of the database object, and the fourth row indicating that 25K of the database object stored on physical device A are the 25K beginning at offset 0 of the database object, it can be deduced that the 25K stored on physical device A are part of the 50K stored on volume A. Offsets within the database object are consistent throughout the storage layers.","In this example, volume B is a mirror of physical devices C and D. The fifth row indicates that 50K of the 50K stored on volume B are stored on physical device C, and that physical device C is a component of storage layer C. The fifth row indicates that the 50K stored on physical device C are the 50K starting at offset 50 of the database object. Based on the third row indicating that 50K of the database object stored on volume B are the 50K beginning at offset 50 of the database object, and the fifth row indicating that 50K of the database object stored on physical device C are the 50K beginning at offset 50 of the database object, it can be deduced that the 50K stored on physical device C are the 50K stored on volume B.","Information in a view may be derived mathematically from other information obtained through techniques described herein. For example, database server  may determine, through techniques described herein, that 50K of a file are stored on volume A at offset 0K, that 25K of volume A are stored on physical device A at offset 0K of the device, and that the remaining 1000K of volume A are stored on physical device B at offset 50K of the device. From this information, database server  may derive mathematically that 25K of the file are stored at offset 0K of physical device A, and the remaining 25K of the file are stored at offset 50K of physical device B. Database server  may use such derived information in generating a view.","As a database server generates a view, the database server may detect patterns in the data and consolidate rows of the view based on the detected patterns. In this way, information that would otherwise be represented in many rows of a view may be represented in fewer rows of the view.","By combining information about which storage layer components store parts of files, and which files store parts of database objects, such as tables, a database server may generate one or more views that illustrate which storage layers components store parts of database objects. The database server will already have access to information about which files store parts of database objects.","According to one embodiment, routines are provided for managing mapping information that belongs to views. Such routines may be provided, for example, as part of a Procedural Language\/Structured Query Language (PL\/SQL) package. Using such routines, data represented in views may be modified. For example, a user or application may modify one or more mappings, as represented in the views, so that a particular object is represented as being stored by different storage layer components, or so that a particular parent component is represented as being related to different child components. By modifying data represented in the views, a modified storage hierarchy may be constructed. The modified storage hierarchy can represent objects as being stored at locations other than the actual locations at which those objects are stored.","The PL\/SQL package may define several different procedures that may be called to cause a database server to determine different mappings. For example, a procedure called \u201cmap all\u201d may cause the database server to determine mappings, between files and storage layer components, for all files that comprise a database. For another example, a procedure called \u201cmap file\u201d may cause the database server to determine mappings between a specified file and storage layer components that store parts of the specified file. A procedure called \u201cmap component\u201d may cause the database server to determine mappings between a specified component, such as a volume, and the objects stored by the specified component. A procedure called \u201cmap object\u201d may cause the database server to determine mappings between a specified database object, such as a table, and storage layer components that store the specified database object.","A procedure called \u201csave\u201d may cause data in one or more views to be saved in the database's data dictionary on a persistent storage device. For example, a view that contains mappings between parent components and child components, and the types of relationships between the components, may be saved in the database's data dictionary. A procedure called \u201crestore\u201d may cause such data that is stored in the data dictionary to be loaded into the database server's memory as a view. In this manner, dynamically generated mappings can be saved and restored so that the mappings do not need to be re-generated every time that a database server is shut down and restarted. By saving modified mappings, a modified storage hierarchy can be saved for later retrieval and use.","The organization of a database may change after mappings are saved to the data dictionary. According to one embodiment, when mappings are restored from the data dictionary, a database server may quickly verify that the mappings are still correct, and modify the mappings to reflect the current database organization if the mappings are not current.","As a database server performs operations on data in a database, the database server may store information that identifies each operation. The database server may also store statistics on the performance of each operation. According to one embodiment, such operations may be simulated relative to a storage hierarchy that has been modified from an original storage hierarchy on which such operations were originally performed. New performance statistics may be generated based on the operations simulated relative to the modified storage hierarchy. Through such simulation, a user or application can determine whether an actual modification to the database would increase performance. For example, a user or application may determine whether the current configuration of the storage hierarchy creates an I\/O bottleneck due to one or more components being accessed disproportionately to other components. Database performance information generated through such simulation may indicate that objects currently consolidated on the disproportionately accessed components ought to be distributed among other components to balance I\/O operations.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 4","b":["400","400","402","404","402","400","406","402","404","406","404","400","408","402","404","410","402"]},"Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","The invention is related to the use of computer system  for implementing the techniques described herein. According to one embodiment of the invention, those techniques are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.","Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are exemplary forms of carrier waves transporting the information.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface .","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.","In the foregoing specification, embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus, the sole and exclusive indicator of what is the invention, and is intended by the applicants to be the invention, is the set of claims that issue from this application, in the specific form in which such claims issue, including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence, no limitation, element, property, feature, advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4","b":"400"}]},"DETDESC":[{},{}]}
