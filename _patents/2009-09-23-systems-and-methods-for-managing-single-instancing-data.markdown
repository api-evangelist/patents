---
title: Systems and methods for managing single instancing data
abstract: Described in detail herein are systems and methods for managing single instancing data. Using a single instance database and other constructs (e.g. sparse files), data density on archival media (e.g. magnetic tape) is improved, and the number of files per storage operation is reduced. According to one aspect of a method for managing single instancing data, for each storage operation, a chunk folder is created on a storage device that stores single instancing data. The chunk folder contains three files: 1) a file that contains data objects that have been single instanced; 2) a file that contains data objects that have not been eligible for single instancing; and 3) a metadata file used to track the location of data objects within the other files. A second storage operation subsequent to a first storage operation contains references to data objects in the chunk folder created by the first storage operation instead of the data objects themselves.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09015181&OS=09015181&RS=09015181
owner: CommVault Systems, Inc.
number: 09015181
owner_city: Tinton Falls
owner_country: US
publication_date: 20090923
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application claims the benefit of U.S. Patent Application No. 61\/100,686, filed on Sep. 26, 2008, entitled SYSTEMS AND METHODS FOR MANAGING SINGLE INSTANCING DATA, and is related to U.S. Patent Application No. 61\/180,791, filed on May 22, 2009, entitled BLOCK-LEVEL SINGLE INSTANCING, each of which is incorporated by reference in its entirety.","Single instancing in a data management system is often the process of attempting to store only a single instance of a file or data object on a storage device. In certain single instancing systems, a separate folder on the file system of the storage device is created for each backup or copy job performed. The files or data objects that are to be stored as a result of the backup or copy job are then placed in the separate folder.","Because there may be numerous computing systems in a data management system, each requiring multiple backup or copy jobs, these techniques may result in the creation of numerous folders, each containing numerous files. For example, if there are hundreds of computing systems, each having thousands of files or data objects to be backed up or copied, backing up or copying all of their files or data objects may potentially result in the creation of millions of files on the secondary storage device.","Certain file systems may not be capable of storing millions of files or more. Other file systems may be well-equipped to handle storing millions of files or more, but may not perform optimally in such situations. Accordingly, a system that provides for the backup or copy of large numbers of files across multiple computing systems would have significant utility.","The need exists for a system that overcomes the above problems, as well as one that provides additional benefits. Overall, the examples herein of some prior or related systems and their associated limitations are intended to be illustrative and not exclusive. Other limitations of existing or prior systems will become apparent to those of skill in the art upon reading the following Detailed Description.","In the drawings, the same reference numbers and acronyms identify elements or acts with the same or similar functionality for ease of understanding and convenience. To easily identify the discussion of any particular element or act, the most significant digit or digits in a reference number generally refers to the Figure number in which that element is first introduced (e.g., element  is first introduced and discussed with respect to ).","The headings provided herein are for convenience only and do not necessarily affect the scope or meaning of the claimed invention.","Overview","Described in detail herein are systems and methods for managing single instanced data (alternatively called deduplicated data) in a data storage network. Using a single instance database and other constructs (e.g. sparse files), data density on archival media (e.g., magnetic tape) is improved, and the number of files per storage operation is reduced. According to one aspect of a method for managing single instancing data, for each storage operation, a chunk folder is created on a storage device that stores single instancing data. The chunk folder contains three container files: 1) a container file that contains data objects that have been single instanced; 2) a container file that contains data objects that were not eligible for single instancing; and 3) an index file used to track the location of data objects within the other files. A second storage operation subsequent to a first storage operation contains references to data objects in the chunk folder created by the first storage operation instead of the data objects themselves.","By storing multiple data objects in a small number of container files (as few as two), the storing of each data object as a separate file on the file system of the storage device can be avoided. This reduces the number of files that would be stored on the file system of the storage device, thereby ensuring that the storage device can adequately store the data of computing devices in the data storage network. Therefore, the file system of the storage device may not necessarily have to contend with storing excessively large numbers of files, such as millions of files or more. Accordingly, these techniques enable very large numbers of data objects to be stored without regard to limitations of the file system of the storage device.","Various examples of the invention will now be described. The following description provides specific details for a thorough understanding and enabling description of these examples. One skilled in the art will understand, however, that the system may be practiced without many of these details. Additionally, some well-known structures or functions may not be shown or described in detail, so as to avoid unnecessarily obscuring the relevant description of the various examples.","The terminology used in the description presented below is intended to be interpreted in its broadest reasonable manner, even though it is being used in conjunction with a detailed description of certain specific examples of the system. Certain terms may even be emphasized below; however, any terminology intended to be interpreted in any restricted manner will be overtly and specifically defined as such in this Detailed Description.","Aspects of the invention will now be described in detail with respect to .  is a block diagram illustrating an environment in which aspects of the invention may be configured to operate.  are block diagrams illustrating various data structures:  illustrates a chunk folder and files contained within the chunk folder;  illustrates multiple chunk folders, files contained within the chunk folders and a reference from a file in one chunk folder to a file in another chunk folder;  illustrates a data structure for a index file; and  illustrates a data structure for storing data on secondary storage (e.g., on tape.)  are flow diagrams illustrating processes for restoring and pruning data, respectively.  are block diagrams illustrating various aspects of data storage. , B, A, B, and  are block diagrams illustrating various data structures and\/or tables that may be utilized by aspects of the invention.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIGS. 11A and 11B","FIGS. 11A and 11B","FIGS. 12A and 12B","FIG. 13","FIG. 14"],"b":["12","12","13"]},"Suitable Environments",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","100","102","104","105","103","102","102","104","104","105","103","105","103","102","104","102","104"]},"The media agent  includes various components that perform various functions. These components include a data object identification component , an identifier generation component , an identifier comparison component , and a criteria evaluation component . The file identification component  identifies files or data objects, such as in response to a storage operation. The identifier generation component  generates an identifier for the file or data object (identifiers are discussed in more detail below). The identifier comparison component  performs comparisons of identifiers of various files or data objects to determine if the files or data objects contain similar data (for example, the identifier comparison component  can compare identifiers of two or more files or data objects to determine if the files or data objects contain the same data; metadata such as access control lists (ACLs), descriptive metadata that describes the files or data objects (e.g., file name, file size, file author, etc.) of the two or more files or data objects may differ. The criteria evaluation component  evaluates aspects of files or data object against a set of criteria. The media agent  may also contain other components that perform other functions.","The clients , as part of their functioning, utilize data, which includes files, directories, metadata (e.g., ACLs, descriptive metadata, and any other streams associated with the data), and other data objects. (More details as to the storage operations involving ACLs may be found in the assignee's U.S. patent application Ser. No. 12\/058,518, entitled SYSTEM AND METHOD FOR STORAGE OPERATION ACCESS SECURITY, the entirety of which is incorporated by reference herein.) The data on the clients  is generally a primary copy (e.g., a production copy). During a copy, backup, archive or other storage operation, the clients  send a copy of each data object in the data to the media agent . The media agent  generates an identifier for each data object.","Examples of identifiers include a hash value, message digest, checksum, digital fingerprint, digital signature or other sequence of bytes that substantially uniquely identifies the file or data object in the data storage system. For example, identifiers could be generated using Message Digest Algorithm 5 (MD5) or Secure Hash Algorithm SHA . In some instances, the phrase \u201csubstantially unique\u201d is used to modify the term \u201cidentifier\u201d because algorithms used to produce hash values may result in collisions, where two different data objects, when hashed, result in the same hash value. However, depending upon the algorithm or cryptographic hash function used, collisions should be suitably rare and thus the identifier generated for a file or data object should be unique throughout the system. The term \u201cprobabilistically unique identifier\u201d may also be used. In this case, the phrase \u201cprobabilistically unique\u201d is used to indicate that collisions should be low-probability occurrences, and, therefore, the identifier should be unique throughout the system. In some examples, data object metadata (e.g., file name, file size) is also used to generate the identifier for the data object.","After generating the identifier for a data object, the media agent  determines whether it should be stored on the storage device . The storage device  stores a secondary copy (e.g., a backup copy) of the data of the clients . To determine this, the media agent  accesses the single instance database  to check if a copy or instance of the data object has already been stored on the storage device . The single instance database  utilizes one or more tables or other data structures to store the identifiers of the data objects that have already been stored on the storage device . If a copy or instance of the data object has not already been stored on the storage device , the media agent  sends the copy of the data object to the storage device  for storage and adds its identifier to the single instance database . If a copy or instance of the data object has already been stored, the media agent  can avoid sending another copy to the storage device . In this case, the media agent  may add a reference (e.g., to an index in the single instance database , such as by incrementing a reference count in the index) to the already stored instance of the data object, and may only store a pointer to the data object on the storage device . As explained below, adding a reference to the already stored instance of the data object enables storing only a single instance of the data object while still keeping track of other instances of the data object that do not need to be stored.","In some examples, instead of the clients  sending the data objects to the media agent  and the media agent  generating the identifiers, the clients  can themselves generate an identifier for each data object and transmit the identifiers to the media agent  for lookup in the single instance database . If the media agent  determines that an instance of a data object has not already been stored on the storage device , the media agent  can instruct the client  to send it a copy of the data object, which it then stores on the storage device . Alternatively, the client  itself can send the copy of the data object to the storage device . More details as to the generation of the identifiers may be found in the assignee's U.S. patent application Ser. No. 12\/058,367, entitled SYSTEM AND METHOD FOR STORING REDUNDANT INFORMATION, the entirety of which is incorporated by reference herein. In some examples, the media agent  generates the identifier on data already stored on the storage device  or on other storage devices (e.g., secondarily stored data is single instanced).","The media agent  can support encrypted data objects. For example, one client  could generate an identifier for a data object and then encrypt it using one encryption algorithm. Another client  could generate an identifier for another data object and then encrypt it using another encryption algorithm. If the two data objects are identical (meaning the two objects have the same data, while their metadata, such as ACLs or descriptors, could be different), they will both have the same identifier. The media agent  can then store both encrypted instances of the data object or only a single encrypted instance. In some examples, the media agent  stores a key or other mechanism to be used to encrypt and\/or decrypt data. The media agent  can also support compressed data objects. In general, the same compression algorithm may be used to compress data objects. Therefore, the media agent  can generate an identifier for a data object before or after it has been compressed. More details as to how the media agent  can support encryption and compression in a single instancing system may be found in the assignee's U.S. patent application Ser. No. 12\/145,342, entitled APPLICATION-AWARE AND REMOTE SINGLE INSTANCE DATA MANAGEMENT, the entirety of which is incorporated by reference herein.","Suitable Data Structures and Examples",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIGS. 2A and 2B","FIG. 2A"],"b":["103","200","202","103","204","206","208"]},"The chunk folder  and the files - may be equivalent to a directory and files (or folder and files) on a file system. For example, the chunk folder  may be a directory and the files - may be files located within the directory. As another example, the chunk folder  may be a file and the files - may be portions of the file. As another example, the files - may be collections of bytes grouped together. Those of skill in the art will understand that the chunk folder  and the files - may be comprised in various data structures and are not limited to a directory and files within the directory.","The media agent  places data objects in the \u201cS\u201d file  that meet certain criteria for single instancing. These criteria may include the following: 1) that the data object has been determined to be data or of type data (as opposed to metadata or of type metadata); and 2) that the data object is larger than a pre-configured size, such as 64 Kb. Type data is generally the payload portion of a file or data object (e.g., a file's contents) and type metadata is generally the metadata portion of the file or data object (e.g., metadata such as file name, file author, etc.). This pre-configured size may be configurable by an administrator or other user with the appropriate permissions. For example, if the administrator wants all data objects of type data be single instanced, the administrator can set the pre-configured size to 0 Kb. As another example, if the administrator wants only data objects of type data greater than 128 Kb to be single instanced, the administrator can set the pre-configured size to 128 Kb.","The media agent  determines if a data object meets these criteria by evaluating aspects of the data object (e.g., its type, its size) against the criteria. If so, and the data object has not already been stored on the storage device  (which the media agent determines by generating an identifier for the data object and looking up the identifier in the single instance database ), the media agent  places the data object in the \u201cS\u201d file . The media agent  may also apply other criteria that the data object must meet for single instancing (e.g., criteria based upon characterizing or classifying the data object using techniques such as those described in commonly assigned U.S. patent application Ser. No. 11\/564,119 (entitled SYSTEMS AND METHODS FOR CLASSIFYING AND TRANSFERRING INFORMATION IN A STORAGE NETWORK, the entirety of which is incorporated by reference herein).","For each data object that is placed in the \u201cS\u201d file , the media agent  adds a reference to the data object in the index file , called an internal reference. For example, the internal reference may be a pointer or link to the location of the data object in the \u201cS\u201d file. As further described herein, the media agent  maintains a primary table that contains all the single instance records of all data objects for which an identifier was created. The media agent  may add as the internal reference a record of the already stored instance of the data object from the primary table.","The media agent  places data objects in the \u201cN\u201d file  that do not meet the above criteria for single instancing. For example, a data object may be metadata (e.g., ACLs for a file that is placed in the \u201cS\u201d file, file descriptor information, etc.). In this case, the data object will be placed in the \u201cN\u201d file. As another example, a data object may be smaller than the pre-configured size, e.g., the data object is smaller than 64 Kb. In this case, the media agent  may incur too much overhead to generate its identifier and perform a lookup of the identifier in the single instance database . Therefore, the data object is placed in the \u201cN\u201d file. For each data object that is placed in the \u201cN\u201d file , the media agent  may also add a reference to the data object in the index file , called an internal reference. For example, the internal reference may be a pointer or link to the location(s) of the data object in the \u201cN\u201d file. A new \u201cN\u201d file may be created during each storage operation job.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2B","FIG. 2A","FIG. 2A"],"b":["210","210","200","202","104","202","202","208","206","204"]},"The second storage operation would result in the creation of the second chunk folder \u2032 illustrated in . As illustrated in , the second chunk folder \u2032 would have a second \u201cN\u201d file  containing the metadata (e.g., the ACLs of the single data object, regardless of whether or not they have changed) and a second index file . Instead of having a second \u201cS\u201d file , the second index file  would have a pointer  to the single data object contained in the first \u201cS\u201d file . Because an instance of the single data object is already contained within the first \u201cS\u201d file , there is no need for another instance of it to be contained within the second \u201cS\u201d file . However, there is a need to keep a record of the fact that the second storage operation involved an instance of the single data object. This is accomplished by the pointer  within the second index file .","In some cases, instead of always placing data objects in the \u201cN\u201d file  that do not meet the above criteria for single instancing, the media agent  generates an identifier for the data object, looks up the identifier in the single instance database  to see if the data object has already been stored, and if not, places it in the \u201cS\u201d file . If the data object has already been stored, the media agent would then add a pointer to the location of the instance of the previously stored data object in the index file . For example, this variation on the process could be used to single instance metadata instead of always storing it in the \u201cN\u201d file .",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2C","b":["220","204","220","222","224","222","206","208","224","206","208","206","208","206","208","208","224","104","208","104","222","224","204"]},"One advantage of the data structures , ,  illustrated in  and the techniques described herein is that they reduce the number of files stored on the file system of the storage device . Thus, there are at most three files created for each storage operation\u2014the index file , the \u201cN\u201d file , and the \u201cS\u201d file . Therefore, a maximum number of files on the file system of the storage device  will be the number of storage operations performed by media agent  multiplied by three. File systems of certain operating systems may have practical limits to the numbers of files that they can store that are well below their theoretical limits. For example, a file system may not, in practice, be able to store a number of files above a certain threshold without experienced significant system degradation (which can be defined in numerous ways, such as an increase in seek time of randomly accessed media that is ten percent longer than normal, a delay in reads or writes on randomly accessed media, or in other ways).","By storing multiple data objects in a small number of container files (as few as two), the storing of each data object as a separate file on the file systems of the storage device can be avoided. This reduces the number of files that would be stored on the file systems of the storage device, thereby ensuring that the storage device can adequately store the data of computing devices in the data storage network. Therefore, the file system of the storage device may not necessarily have to contend with storing excessively large numbers of files, such as millions of files or more. Accordingly, these techniques enable very large numbers of data objects to be stored without regard to limitations of the file system of the storage device.","Even if the media agent  performs numerous storage operations using these data structures , , this will result in far fewer files on the storage device  than storage operations where each involved data object is stored as a separate file. Another advantage is that the index files  could be used to replicate the data stored in the single instance database  or reconstruct the single instance database  if its data is ever lost or corrupted. This is because the index files  may store essentially the same information as what is stored in the single instance database .","However, the storage of data objects in containers such as the \u201cN\u201d file  and the \u201cS\u201d file  may create additional complexities when it comes time to prune or delete data objects involved in previous storage operations. This is because the data objects are not stored as files on the file system and thus cannot be directly referenced by the file system. For example, consider a first storage operation, involving a first file and a second file, and a second storage operation, involving the first file and a third file, both occurring on the same day. Further consider that the first storage operation's files are eligible to be pruned after 15 days and the second storage operation's files are eligible to be pruned after 30 days. Using the techniques described herein, the first storage operation would store the first and second files in an \u201cS\u201d file  and the second storage operation would store a pointer to the first file in an \u201cN\u201d file  and the third file in another \u201cS\u201d file .","After 15 days have elapsed, the first and second files are eligible to be pruned. The first file is referenced by the \u201cN\u201d file  of the second storage operation, and cannot yet be pruned. However, the second file, because it is not referenced by any \u201cN\u201d files  in any other storage operations, can be pruned. Using the index file  corresponding to the \u201cS\u201d file, the media agent  locates the second file within the \u201cS\u201d file . The media agent  can then instruct the operating system (e.g., a Windows operating system, a Unix operating system, a Linux operating system, etc.) of the storage device  to convert the \u201cS\u201d file  into a sparse file. A sparse file is well-known type of file having data within but not filling the file's logical space (e.g., at the beginning of the file and at the end of the file, and a hole or empty space in between). In converting the \u201cS\u201d file  into a sparse file, the portions corresponding to the second file may be zeroed out. These portions are then available for storage of other files or data objects by the operating system on storage devices (e.g., on magnetic disks, but sparse files may be used on other types of storage devices, such as tape or optical disks). Additionally or alternatively, the \u201cS\u201d file may be designated as a sparse file upon its creation.","After 30 days have elapsed, the first and third files are eligible to be pruned. Assuming that there are no intervening storage operations involving files that reference either of these files, both the first and third files can be pruned. The chunk folders  corresponding to the first and second storage operations can be deleted, thereby deleting the index files \u201c\u201d, the \u201cN\u201d files \u2033 and the \u201cS\u201d files  and recovering the space previously allocated for their storage. (The process for pruning data objects is discussed in greater detail with reference to, e.g., .) Therefore, the data structures , ,  illustrated in  and the techniques described herein also allow for pruning data objects to recover space previously allocated to them on the storage device .","Accordingly, the data structures , ,  illustrated in  and the techniques described herein enable the performance of storage operations cumulatively involving very large numbers of data objects, while still allowing for recovery of space allocated to these data objects when their storage is no longer required. For example, an administrator can back up numerous files across numerous clients and avoid storing redundant copies or instances of the files. The administrator can also easily recover space on the storage device  when it is no longer required to store the files, for example, as according to a retention policy that indicates for how long files are to be stored on the storage device . Accordingly, the data structures and techniques described herein enable the optimization of storage operations involving very large numbers of data objects.","After having been stored on the storage device , files contained in chunks may be moved to secondary storage, such as to disk drives or to tapes in tape drives. More details as to these operations may be found in the previously-referenced U.S. patent application Ser. No. 12\/058,367. In moving chunks to secondary storage, they may be converted into an archive file format. In some examples, the techniques described herein may be used to single instance data already stored on secondary storage.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 2D","b":["240","0","242","1","242","2","242","3","242"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIGS. 11A and 11B","FIG. 11A"],"b":["1100","1150","102","1100","130","1100","1102","1104","1104","1102","1104","1104","1104","1104","1104","1104"]},"Referring to , the data stream  has the stream header  and stream payload  aligned into multiple data blocks. In this example, the data blocks are of size 64 Kb. The first two stream header  and stream payload  pairs comprise a first data block of size 64 Kb. The first stream header  indicates that the length of the succeeding stream payload  is 63 Kb and that it is the start of a data block. (The stream header  may also include additional metadata.) The next stream header  indicates that the succeeding stream payload has a length of 1 Kb and that it is not the start of a new data block. Immediately following that stream payload  are an identifier header  and identifier data  pair. The identifier header  includes an indication that the succeeding identifier data  includes the identifier for the immediately previous data block. The identifier data  includes the identifier that the data agent (e.g., the identifier generation component ) generated for the data block. The data stream  also includes other stream header  and stream payload  pairs, which may be for SI data and\/or for non-SI data.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIGS. 12A and 12B","FIG. 12A"],"b":["105","1200","1250","1200","1202","1204","1206","1208","1220","1206","1208","1224","1204"]},"Referring to , the secondary table  includes information about links that refer to data blocks. The secondary table  includes an identifier column , a referring location column , and an offset column . For example, row  includes information about a reference to the data block having the identifier of \u201c0xA1B3FG\u201d (row  in the primary table ). The location of the link is indicated in column , at an offset of five within the indicated metadata file. As another example, row  includes information about another reference to the data block having the identifier of \u201c0xA1B3FG.\u201d This link is located at the location indicated in column , at an offset of 15 within the indicated metadata file. As another example, row  includes information about a reference to the block for which the identifier is \u201c0xC13804\u201d (row  in the primary table ). The location of the link is indicated in column , at an offset of 19 within the indicated metadata file.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 13","b":["103","1302","1304","1305","1302","1304","1304","1305","1306","1307","1308","1309","1310","1311","1313","1312","1314","1306","1307","1308","1309","1306","1307","1310","1311","1313","1312","1314","1310","1311","1313","1312","1314","1310","1311","1313","1306","1307","2","1310","1307","1305","1312","2","1310","1","1311","1307","1312"]},"As an example, the data structures illustrated in  may have been created as a result of two storage operations involving two clients . For example, a first storage operation on a first client  could result in the creation of the first chunk folder , and a second storage operation on a second client  could result in the creation of the second chunk folder . The container files \/ in the first chunk folder  would contain the blocks of SI data of the first client . If the two clients  have substantially similar data, the second storage operation on the data of the second client  would result in the media agent  storing primarily links to the data blocks of the first client  that are already stored in the container files \/. Accordingly, while a first storage operation may result in storing nearly all of the data subject to the storage operation, subsequent storage operations involving similar data may result in substantial data storage space savings, because links to already stored data blocks can be stored instead of additional instances of data blocks.","If the operating system of the media agent  supports sparse files, then when the media agent  creates container files \/\/, it can create them as sparse files. As previously described, a sparse file is type of file that may include empty space (e.g., a sparse file may have real data within it, such as at the beginning of the file and\/or at the end of the file, but may also have empty space in it that is not storing actual data, such as a contiguous range of bytes all having a value of zero). Having the container files \/\/ be sparse files allows the media agent  to free up space in the container files \/\/ when blocks of data in the container files \/\/ no longer need to be stored on the storage devices . In some examples, the media agent  creates a new container file \/\/ when a container file \/\/ either includes 100 blocks of data or when the size of the container file  exceeds 50 Mb. In other examples, the media agent  creates a new container file \/\/ when a container file \/\/ satisfies other criteria (e.g., it contains from approximately 100 to approximately 1000 blocks or when its size exceeds approximately 50 Mb to 1 Gb). Those of skill in the art will understand that the media agent  can create a new container file \/\/ when other criteria are met.","In some cases, a file on which a storage operation is performed may comprise a large number of data blocks. For example, a 100 Mb file may be comprised in 400 data blocks of size 256 Kb. If such a file is to be stored, its data blocks may span more than one container file, or even more than one chunk folder. As another example, a database file of 20 Gb may comprise over 40,000 data blocks of size 512 Kb. If such a database file is to be stored, its data blocks will likely span multiple container files, multiple chunk folders, and potentially multiple volume folders. As described in detail herein, restoring such files may thus requiring accessing multiple container files, chunk folders, and\/or volume folders to obtain the requisite data blocks.","One advantage of the data structures illustrated in  and\/or of the techniques described herein is that they significantly reduce the number of files stored on a file system of the storage device . This is at least partly due to the storage of data blocks within the container files \/\/. Even if numerous storage operations using these data structures are performed, this will result in far fewer files on the storage device  than storage operations where each data block is stored as a separate file. Therefore, the file system of the storage device  may not necessarily have to contend with storing excessively large numbers of files, such as millions of files or more. Accordingly, the systems and methods described herein enable very large numbers of blocks of data to be stored without regard to limitations of the file system of the storage device .","Another advantage is that the data storage system enables a reduction in the amount of blocks of data stored on the storage devices , while still maintaining at least one instance of each block of data in primary data. In examples where the data storage system stores a variable number of instances of blocks of data, blocks of data can be distributed across two or more storage devices , thereby adding a further aspect of redundancy.","Another advantage is that the metadata files \/, the metadata index files \/, the container files \/\/, and\/or the container index files \/ could be used to replicate the data stored in the single instance database  or reconstruct the single instance database  if the data of the single instance database  is ever lost and\/or corrupted.","The storage of data blocks in the container files may create additional complexities when it comes time to prune (delete) data blocks that the data storage system no longer need retain. This is because the data blocks are not stored as files on the file system on the storage device  and thus cannot be directly referenced by the file system. As described in detail with reference to , the media agent  uses the container index files \/ to keep track of which blocks of data are referenced and thus which blocks are not prunable (deletable).","In some examples, the use of the container index files \/, the metadata index files \/, and\/or the primary and secondary tables \/ to track data is a driver, agent or an additional file system that is layered on top of the existing file system of the storage device . This driver\/agent\/additional file system allows the data storage system to efficiently keep track of very large numbers of blocks of data, without regard to any limitations of the file systems of the storage devices . Accordingly, the data storage system can store very large numbers of blocks of data.","Accordingly, the data structures illustrated in  and the techniques described herein enable the performance of multiple storage operations cumulatively involving very large amounts of data, while still allowing for recovery of space on the storage device  when storage of certain data blocks is no longer required. For example, the data of numerous clients  can be protected without having to store redundant copies or instances of data blocks. Space on the storage device  can also be recovered when it is no longer necessary to store certain data blocks. Accordingly, storage operations involving very large amounts of data are enabled and optimized by the techniques described herein.","Restoring Data",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 3","b":["300","305"]},"At step  the media agent  is consulted to determine an archive file ID and an offset of the data object to be restored. The media agent  can determine this information from a data structure, such as a tree index (for example, a c-tree may be used, which, in some examples, is a type of self-balancing b-tree), it maintains for each archive file. For example, an archive file may be based on files  through n, with file  at offset 1, file  at offset 2, file n at offset n, and so on. The media agent  maintains one tree index per full storage operation cycle. (A storage operation cycle consists of a cycle from one full storage operation of a set of data, including any intervening incremental storage operations, until another full storage operation is performed.)  illustrates an example data structure  that the media agent  maintains. The data structure  includes an archive file ID item  which contains the identifier of archive files, a file or data object item  which contains the identifier of the file or data object, and an offset  containing the offset of the file or data object within the archive file.","The media agent  may also maintain a multiple-part identifier, such as a five-part identifier, that includes an enterprise or domain identifier (e.g., an identifier of a grouping of clients), a client identifier to identify the client\/host, an application type, a storage operation set identifier to identify when the storage operation data was obtained, and a subclient identifier to provide a further level of granularity within an enterprise to identify an origin, location, or use of the data (e.g., a file system on a client could be a subclient, or a database on a client could be a subclient).","Using the data structure maintained for the archive file, the media agent  determines the archive file ID and offset within the archive file of the data object to be restored. The media agent  then needs to determine which chunk contains the data object. To do so, the media agent  consults another server, such as a storage manager (discussed below), that has a data structure that maps the archive file ID and offset to the specific media (as well as the specific chunk file within the specific media, optionally). For example, the storage manager may maintain a database table that maps the archive file ID to specific media, such as the archive file ID to a bar code number for a magnetic tape cartridge storing that archive file.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 8B","b":["850","850","870","880","890","104","105"]},"At step , the secondary storage is accessed and the specific media, such as a specific tape cartridge in an automated tape library, is accessed. At step  the specific chunk folder  is opened, and the index file  is accessed. At step , the index file  is parsed until the stream header corresponding to the data object to be restored is accessed. At step , the location of the file is determined from the stream data. The stream data indicates the location of the data object to be restored, which is either in the \u201cS\u201d file  within the chunk folder  or within an \u201cS\u201d File  in another chunk folder  (or the \u201cN\u201d file for data objects that did not meet the criteria for single instancing). At step  the data object is retrieved or opened, and the data object is read and streamed back to restore it. Each data object may have a piece of data appended to it (e.g., an EOF marker) that indicates to the reader when to stop reading the data object. A similar piece of data may be prepended (e.g., a BOF marker) to the data object. The process  then concludes.","Pruning Data","Consider the example of a client for which a storage operation job was performed on Jan. 1, 2008, resulting in the creation of an archive file. A retention policy provides that the archive file has to be retained for 30 days. On Jan. 31, 2008, the archive file becomes prunable and thus can be deleted. Deleting the archive file may require deleting data stored in one or more chunks on one or more media. However, the archive file may not be able to be deleted if it is referenced by data objects within other archive files. This is to avoid orphaning data objects, e.g., by deleting a data object when it is still referenced in another archive file. The system keeps tracks of references to data objects in order to avoid orphaning data objects.","To assist in pruning, the single instance database  maintains a primary table and a secondary table. The primary table contains all the single instance records of all data objects for which an identifier was created. For each record in the primary table, the secondary table contains a record that may reference the record in the primary table.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIGS. 9A and 9B","b":["900","950","900","910","920","930","900"]},"The secondary table  has a secondary record ID column  which may contain primary keys, an archive file ID column  that contains the archive file ID, a file column  that contains the same identifier of the file or data object as in the primary table , and a referencecolumn  that contains an identifier (in the form of an archive file ID and an offset) of a file or data object that references the archive file. The secondary table  also has a referencecolumn  that contains an identifier (in the form of an archive file ID and an offset) of a referenced file or data object. The secondary table  may also contain other columns (not shown).",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 4","b":["400","105","400","405","410","104","900","950","415","104"]},"If the archive file has references out, the process  continues to step , where the references out are deleted. At step , the media agent  determines if the archive files referenced by the references out have other references in. If there are no other references in, at step , the media agent  prunes the archive files referenced by the references out.","If the archive file does not have any references out (step ), or if it does, and if the archive files referenced by the references out have other references in (step ), the process  continues at step . At this step, the media agent  determines if the archive file has references in. If it does have references in, this means the archive file cannot be pruned. The process continues at step , where the media agent  deletes the references in. At step  the media agent adds a reference to the archive file to a deleted archive file table (discussed below).","If the archive file does not have any references in (step ), the media agent  prunes the archive file. The media agent  then creates an entry in the deleted archive file table for the pruned archive file (if there wasn't already an entry) and adds a deleted timestamp to the entry. If there is already an entry for the pruned archive file, the media agent  adds a deleted timestamp to the entry.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 10","b":["1000","1000","1010","1020","1030","1040"],"sub":"IN "},"The process  will now be explained using the examples of the records shown in the primary and secondary tables , . At time T, the process  begins. At step , the media agent  receives a selection of AFto prune. At step  the media agent  looks up AF, in the primary  and secondary  tables. At step , the media agent  determines that AFhas a reference out, shown by entry  in the secondary table . (Entry  is shown in the secondary table  with strikethrough to indicate that it was previously deleted during an operation to prune AF.) At step  the media agent deletes this reference out by deleting entry  from the secondary table . At step  the media agent  determines if AFhas any other references in. Since the only reference in for AFis from AF(which is to be pruned), AFdoes not have any other references in. At step  the media agent  then prunes AFand adds a timestamp indicating that AFwas pruned at time Tat entry  of the deleted archive file table .","At step  the media agent  determines if AFhas any references in. AFhas a reference in from AF, shown in entry  of the secondary table . The media agent thus cannot prune AF. At step , the media agent deletes the references in to AFby deleting entry  from the secondary table . At step , the media agent adds entry  to the deleted archive file table , leaving the deleted timestamp blank. The blank timestamp indicates that AFshould be pruned. The process  then concludes.","At time T, the process  begins anew. At step , the media agent  receives a selection of AFto prune. At step  the media agent  looks up AF, in the primary  and secondary  tables. At step , the media agent  determines that AFhas a reference out, shown by entry  in the secondary table , that references AF. At step  the media agent deletes entry  from the secondary table . At step  the media agent  determines if AFhas any other references in. Since the only reference in for AFis from AF(which is to be pruned), AFdoes not have any other references in, and can now be pruned. At step  the media agent  then prunes AFand adds a timestamp indicating that AFwas pruned at time Tat entry  of the deleted archive file table . This entry now indicates that AFhas been pruned at time T.","At step , the media agent  determines if AFhas any references in. AFhas no references in listed in the secondary table . The media agent thus can prune AF. At step , the media agent  prunes AF. At step , the media agent  adds the entry  to the deleted archive file table  with a deleted timestamp as T. The process  then concludes.","The pruning process  thus enables the system to maximize available storage space for storing archive files by storing them efficiently and then deleting or pruning them when it is no longer necessary to store them. The pruning process  may have additional or fewer steps than the ones described, or their order may vary other than what is described. For example, instead of the media agent adding a timestamp to an entry in the deleted archive file table  to indicate when the archive file was pruned, the media agent may simply delete the entry from the deleted archive file table . As another example, entries in the primary table  may also be deleted when the corresponding archive files are deleted. Those of skill in the art will understand that other variations are of course possible.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 14","b":["1400","1400","104","1400","1400","104"]},"As previously noted, the data structures illustrated in  may have been created as a result of two jobs involving two clients . For example, a first job on a first client  could result in the creation of the first chunk folder , and a second job on a second client  could result in the creation of the second chunk folder . The process  is described using this example. More specifically, the process  is described below as pruning the data created as a result of the first job. Of course, a similar process may be used to delete other jobs, or even smaller increments of data or data objects, such as individual files or blocks.","At step  the media agent  determines the file, e.g., archive file, and the volume folders  and chunk folder  corresponding to the job to be pruned. The media agent  may do so, for example, by analyzing various data structures to determine this information. At step  the media agent  deletes the metadata file  and the metadata index file  in the chunk folder . The media agent  can delete the metadata file  and the metadata index file  in this example because these files include data, which is not referenced by any other data.","At step  the media agent  accesses the container file  and the container index file  in the chunk folder . The media agent  begins iterating through the data blocks in the container files . At step , beginning with a first block in the container file , the media agent  accesses the primary table  in the single instance database . The media agent  determines from the primary table  whether the reference count of a data block in the container file  is equal to zero. If so, this indicates that there are no references to the data block. The process  then continues at step , where the media agent  sets the entry in the container index file  corresponding to the data block equal to zero, thus indicating that there are no references to the data block, and therefore prunable.","If the reference count of a data block is not equal to zero, then the data block is not prunable, and the process  continues at step . At this step, the media agent  determines whether there are more data blocks in the container file . If so, the process  returns to step , where it accesses the next data block. If there are no more data blocks in the container file , the process  continues at step , where the media agent  determines whether all the entries in the container index file  corresponding to the container file  are equal to zero. As illustrated in , the second index entry in the container index file  is not equal to zero, thus indicating that the corresponding block in container file  is referenced (by data in the chunk folder , as earlier described). Accordingly, the container file  cannot be deleted.","However, if the container file  did not contain any referenced data blocks, then at step , the media agent  would delete the container file . The process would then continue at step , where the media agent  determines whether there are more container files. According to the example as illustrated in , there is an additional container file . The process  then returns to step , where it performs the same steps - for container file . As a result of performing these steps, the media agent  would also determine that the container file  cannot be deleted, because it contains a data block that is referenced (by data in the chunk folder , as earlier described).","After processing container files \/, the process  continues at step , where the media agent  determines whether to free up storage space in the container files \/. The media agent  may do so using various techniques. For example, if the operating system of the media agent  supports sparse files, then the media agent  may free up space by zeroing out the bytes in the container files corresponding to the space to be freed up. For a number of contiguous blocks (e.g., a threshold number of contiguous blocks, such as three contiguous blocks) for which the corresponding entries in the container index file  indicate that the blocks are not being referred to, then the media agent  may mark these portions of the container files \/ as available for storage by the operating system or the file system. The media agent  may do so by calling an API of the operating system to mark the unreferenced portions of the container files \/ as available for storage.","The media agent  may use certain optimizations to manage the number of times portions of the container file are marked as available for storage, such as only zeroing out bytes in container files when a threshold number of unreferenced contiguous blocks is reached (e.g., three unreferenced contiguous blocks). These optimizations may result in less overhead for the operating system because it reduces the number of contiguous ranges of zero-value bytes in the container files \/ that the operating system must keep track of (e.g., it reduces the amount of metadata about portions of the container files \/ that are available for storage).","If the operating system of the media agent  does not support sparse files, then the media agent  may free up space by truncating either the beginning or the end of the container files \/ (removing or deleting data at the beginning or end of the container files \/). The media agent  may do so by calling an API of the operating system, or by operating directly on the container files \/. For example, if a certain number of the last blocks of the container file are not being referred to, the media agent  may truncate these portions of the container files \/. Other techniques may be used to free up space in the container files \/ for storage of other data. At step  the media agent  frees up space in the container files \/. The process  then concludes.","As a result of the process , the chunk folder  would contain only the container files \/ and the container index file . At a later time, when the chunk folder  is pruned (the job that created this chunk folder is selected to be pruned), then the container files \/ in the chunk folder  can be deleted, because they no longer contain data blocks that is referenced by other data. Therefore, pruning data corresponding to a job may also result in pruning data corresponding to an earlier job, because the data corresponding to the earlier job is no longer referenced by the later job.","Although the process  is described with reference to the pruning of data corresponding to jobs (one or more storage operations), other data can also be pruned. For example, an administrator may wish to delete SI data but retain non-SI data. In such case, the administrator may instruct the media agent  to delete the container files \/\/ but retain the metadata files \/ and metadata index files \/. As another example, an administrator or storage policy may delete one or more specific files. In such case, the media agent  deletes the data blocks in the container files \/\/ corresponding to the specific files but retains other data blocks. The process  may include fewer or more steps than those described herein to accommodate these other pruning examples. Those of skill in the art will understand that data can be pruned in various fashions and therefore, that the process  is not limited to the steps described herein.","One advantage of the process  and the techniques described herein is that they enable the deletion of data on the storage devices  that no longer needs to be stored while still retaining data that needs to be stored, and doing so in a space-efficient manner. Space previously allocated for data blocks that no longer need to be stored can be reclaimed by the data storage system, and used to store other data. Accordingly, the techniques described herein provide for efficient use of available storage space (available on physical media).","Suitable System","The above system may be incorporated within a data storage system and may be subjected to a data stream during a data copy operation. Referring to , a block diagram illustrating components of a data stream  utilized by a suitable data storage and recovery system is shown. The data stream  may include client , a media agent , and a secondary storage device, such as VTL . For example, in storage operations, the system may store, receive, and\/or prepare data to be stored, copied, or backed up at a server or client. The system may then transfer the data to be stored to media agent , which may then refer to storage policies, schedule policies, and\/retention policies (and other policies) to choose a secondary storage device. The media agent  may include or be associated with an intermediate component, to be discussed herein.","The secondary storage device receives the data from the media agent  and stores the data as a secondary copy, such as a backup copy. Secondary storage devices may be magnetic tapes, optical disks, USB and other similar media, disk, and tape drives, and so on. Of course, the system may employ other configurations of data stream components not shown in .",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 6","b":["650","650","650","605","695","665","615","630","630","660","662","623","611","620","625","631","650","650"]},"The system  may generally include combinations of hardware and software components associated with performing storage operations on electronic data. Storage operations include copying, backing up, creating, storing, retrieving, and\/or migrating primary storage data (e.g., data stores  and\/or ) and secondary storage data (which may include, for example, snapshot copies, backup copies, hierarchical storage management (HSM) copies, archive copies, and other types of copies of electronic data stored on storage devices ). The system  may provide one or more integrated management consoles for users or system processes to interface with in order to perform certain storage operations on electronic data as further described herein. Such integrated management consoles may be displayed at a central control facility or several similar consoles distributed throughout multiple network locations to provide global or geographically specific network data storage information.","In one example, storage operations may be performed according to various storage preferences, for example, as expressed by a user preference, a storage policy, a schedule policy, and\/or a retention policy. A \u201cstorage policy\u201d is generally a data structure or other information source that includes a set of preferences and other storage criteria associated with performing a storage operation. The preferences and storage criteria may include, but are not limited to, a storage location, relationships between system components, network pathways to utilize in a storage operation, data characteristics, compression or encryption requirements, preferred system components to utilize in a storage operation, a single instancing or variable instancing policy to apply to the data, and\/or other criteria relating to a storage operation. For example, a storage policy may indicate that certain data is to be stored in the storage device , retained for a specified period of time before being aged to another tier of secondary storage, copied to the storage device  using a specified number of data streams, etc.","A \u201cschedule policy\u201d may specify a frequency with which to perform storage operations and a window of time within which to perform them. For example, a schedule policy may specify that a storage operation is to be performed every Saturday morning from 2:00 a.m. to 4:00 a.m. In some cases, the storage policy includes information generally specified by the schedule policy. (Put another way, the storage policy includes the schedule policy.) A \u201cretention policy\u201d may specify how long data is to be retained at specific tiers of storage or what criteria must be met before data may be pruned or moved from one tier of storage to another tier of storage. Storage policies, schedule policies and\/or retention policies may be stored in a database of the storage manager , to archive media as metadata for use in restore operations or other storage operations, or to other locations or components of the system .","The system  may comprise a storage operation cell that is one of multiple storage operation cells arranged in a hierarchy or other organization. Storage operation cells may be related to backup cells and provide some or all of the functionality of backup cells as described in the assignee's U.S. patent application Ser. No. 09\/354,058, now U.S. Pat. No. 7,395,282, which is incorporated herein by reference in its entirety. However, storage operation cells may also perform additional types of storage operations and other types of storage management functions that are not generally offered by backup cells.","Storage operation cells may contain not only physical devices, but also may represent logical concepts, organizations, and hierarchies. For example, a first storage operation cell may be configured to perform a first type of storage operations such as HSM operations, which may include backup or other types of data migration, and may include a variety of physical components including a storage manager  (or management agent ), a secondary storage computing device , a client , and other components as described herein. A second storage operation cell may contain the same or similar physical components; however, it may be configured to perform a second type of storage operations, such as storage resource management (SRM) operations, and may include monitoring a primary data copy or performing other known SRM operations.","Thus, as can be seen from the above, although the first and second storage operation cells are logically distinct entities configured to perform different management functions (i.e., HSM and SRM, respectively), each storage operation cell may contain the same or similar physical devices. Alternatively, different storage operation cells may contain some of the same physical devices and not others. For example, a storage operation cell configured to perform SRM tasks may contain a secondary storage computing device , client , or other network device connected to a primary storage volume, while a storage operation cell configured to perform HSM tasks may instead include a secondary storage computing device , client , or other network device connected to a secondary storage volume and not contain the elements or components associated with and including the primary storage volume. (The term \u201cconnected\u201d as used herein does not necessarily require a physical connection; rather, it could refer to two devices that are operably coupled to each other, communicably coupled to each other, in communication with each other, or more generally, refer to the capability of two devices to communicate with each other.) These two storage operation cells, however, may each include a different storage manager  that coordinates storage operations via the same secondary storage computing devices  and storage devices . This \u201coverlapping\u201d configuration allows storage resources to be accessed by more than one storage manager , such that multiple paths exist to each storage device  facilitating failover, load balancing, and promoting robust data access via alternative routes.","Alternatively or additionally, the same storage manager  may control two or more storage operation cells (whether or not each storage operation cell has its own dedicated storage manager ). Moreover, in certain embodiments, the extent or type of overlap may be user-defined (through a control console) or may be automatically configured to optimize data storage and\/or retrieval.","Data agent  may be a software module or part of a software module that is generally responsible for performing storage operations on the data of the client  stored in data store \/ or other memory location. Each client  may have at least one data agent  and the system  can support multiple clients . Data agent  may be distributed between client  and storage manager  (and any other intermediate components), or it may be deployed from a remote location or its functions approximated by a remote process that performs some or all of the functions of data agent .","The overall system  may employ multiple data agents , each of which may perform storage operations on data associated with a different application. For example, different individual data agents  may be designed to handle Microsoft Exchange data, Lotus Notes data, Microsoft Windows 2000 file system data, Microsoft Active Directory Objects data, and other types of data known in the art. Other embodiments may employ one or more generic data agents  that can handle and process multiple data types rather than using the specialized data agents described above.","If a client  has two or more types of data, one data agent  may be required for each data type to perform storage operations on the data of the client . For example, to back up, migrate, and restore all the data on a Microsoft Exchange 2000 server, the client  may use one Microsoft Exchange 2000 Mailbox data agent  to back up the Exchange 2000 mailboxes, one Microsoft Exchange 2000 Database data agent  to back up the Exchange 2000 databases, one Microsoft Exchange 2000 Public Folder data agent  to back up the Exchange 2000 Public Folders, and one Microsoft Windows 2000 File System data agent  to back up the file system of the client . These data agents  would be treated as four separate data agents  by the system even though they reside on the same client .","Alternatively, the overall system  may use one or more generic data agents , each of which may be capable of handling two or more data types. For example, one generic data agent  may be used to back up, migrate and restore Microsoft Exchange 2000 Mailbox data and Microsoft Exchange 2000 Database data while another generic data agent  may handle Microsoft Exchange 2000 Public Folder data and Microsoft Windows 2000 File System data, etc.","Data agents  may be responsible for arranging or packing data to be copied or migrated into a certain format such as an archive file. Nonetheless, it will be understood that this represents only one example, and any suitable packing or containerization technique or transfer methodology may be used if desired. Such an archive file may include metadata, a list of files or data objects copied, the file, and data objects themselves. Moreover, any data moved by the data agents may be tracked within the system by updating indexes associated with appropriate storage managers  or secondary storage computing devices . As used herein, a file or a data object refers to any collection or grouping of bytes of data that can be viewed as one or more logical units.","Generally speaking, storage manager  may be a software module or other application that coordinates and controls storage operations performed by the system . Storage manager  may communicate with some or all elements of the system , including clients , data agents , secondary storage computing devices , and storage devices , to initiate and manage storage operations (e.g., backups, migrations, data recovery operations, etc.).","Storage manager  may include a jobs agent  that monitors the status of some or all storage operations previously performed, currently being performed, or scheduled to be performed by the system . (One or more storage operations are alternatively referred to herein as a \u201cjob\u201d or \u201cjobs.\u201d) Jobs agent  may be communicatively coupled to an interface agent  (e.g., a software module or application). Interface agent  may include information processing and display software, such as a graphical user interface (\u201cGUI\u201d), an application programming interface (\u201cAPI\u201d), or other interactive interface through which users and system processes can retrieve information about the status of storage operations. For example, in an arrangement of multiple storage operations cell, through interface agent , users may optionally issue instructions to various storage operation cells regarding performance of the storage operations as described and contemplated herein. For example, a user may modify a schedule concerning the number of pending snapshot copies or other types of copies scheduled as needed to suit particular needs or requirements. As another example, a user may employ the GUI to view the status of pending storage operations in some or all of the storage operation cells in a given network or to monitor the status of certain components in a particular storage operation cell (e.g., the amount of storage capacity left in a particular storage device ).","Storage manager  may also include a management agent  that is typically implemented as a software module or application program. In general, management agent  provides an interface that allows various management agents  in other storage operation cells to communicate with one another. For example, assume a certain network configuration includes multiple storage operation cells hierarchically arranged or otherwise logically related in a WAN or LAN configuration. With this arrangement, each storage operation cell may be connected to the other through each respective interface agent . This allows each storage operation cell to send and receive certain pertinent information from other storage operation cells, including status information, routing information, information regarding capacity and utilization, etc. These communications paths may also be used to convey information and instructions regarding storage operations.","For example, a management agent  in a first storage operation cell may communicate with a management agent  in a second storage operation cell regarding the status of storage operations in the second storage operation cell. Another illustrative example includes the case where a management agent  in a first storage operation cell communicates with a management agent  in a second storage operation cell to control storage manager  (and other components) of the second storage operation cell via management agent  contained in storage manager .","Another illustrative example is the case where management agent  in a first storage operation cell communicates directly with and controls the components in a second storage operation cell and bypasses the storage manager  in the second storage operation cell. If desired, storage operation cells can also be organized hierarchically such that hierarchically superior cells control or pass information to hierarchically subordinate cells or vice versa.","Storage manager  may also maintain an index, a database, or other data structure . The data stored in database  may be used to indicate logical associations between components of the system, user preferences, management tasks, media containerization and data storage information or other useful data. For example, the storage manager  may use data from database  to track logical associations between secondary storage computing device  and storage devices  (or movement of data as containerized from primary to secondary storage).","Generally speaking, the secondary storage computing device , which may also be referred to as a media agent, may be implemented as a software module that conveys data, as directed by storage manager , between a client  and one or more storage devices  such as a tape library, a magnetic media storage device, an optical media storage device, or any other suitable storage device. In one embodiment, secondary storage computing device  may be communicatively coupled to and control a storage device . A secondary storage computing device  may be considered to be associated with a particular storage device  if that secondary storage computing device  is capable of routing and storing data to that particular storage device .","In operation, a secondary storage computing device  associated with a particular storage device  may instruct the storage device to use a robotic arm or other retrieval means to load or eject a certain storage media, and to subsequently archive, migrate, or restore data to or from that media. Secondary storage computing device  may communicate with a storage device  via a suitable communications path such as a SCSI or Fibre Channel communications link. In some embodiments, the storage device  may be communicatively coupled to the storage manager  via a SAN.","Each secondary storage computing device  may maintain an index, a database, or other data structure  that may store index data generated during storage operations for secondary storage (SS) as described herein, including creating a metabase (MB). For example, performing storage operations on Microsoft Exchange data may generate index data. Such index data provides a secondary storage computing device  or other external device with a fast and efficient mechanism for locating data stored or backed up. Thus, a secondary storage computing device index , or a database  of a storage manager , may store data associating a client  with a particular secondary storage computing device  or storage device , for example, as specified in a storage policy, while a database or other data structure in secondary storage computing device  may indicate where specifically the data of the client  is stored in storage device , what specific files were stored, and other information associated with storage of the data of the client . In some embodiments, such index data may be stored along with the data backed up in a storage device , with an additional copy of the index data written to index cache in a secondary storage device. Thus the data is readily available for use in storage operations and other activities without having to be first retrieved from the storage device .","Generally speaking, information stored in cache is typically recent information that reflects certain particulars about operations that have recently occurred. After a certain period of time, this information is sent to secondary storage and tracked. This information may need to be retrieved and uploaded back into a cache or other memory in a secondary computing device before data can be retrieved from storage device . In some embodiments, the cached information may include information regarding format or containerization of archives or other files stored on storage device .","One or more of the secondary storage computing devices  may also maintain one or more single instance databases . Single instancing (alternatively called data deduplication) generally refers to storing in secondary storage only a single instance of each data object (or data block) in a set of data (e.g., primary data). More details as to single instancing may be found in one or more of the following commonly-assigned U.S. patent applications: 1) U.S. patent application Ser. No. 11\/269,512 (entitled SYSTEM AND METHOD TO SUPPORT SINGLE INSTANCE STORAGE OPERATIONS); 2) U.S. patent application Ser. No. 12\/145,347 (entitled APPLICATION-AWARE AND REMOTE SINGLE INSTANCE DATA MANAGEMENT; or 3) U.S. patent application Ser. No. 12\/145,342 (entitled APPLICATION-AWARE AND REMOTE SINGLE INSTANCE DATA MANAGEMENT), 4) U.S. patent application Ser. No. 11\/963,623 (entitled SYSTEM AND METHOD FOR STORING REDUNDANT INFORMATION); and 5) U.S. patent application Ser. No. 11\/950,376 (entitled SYSTEMS AND METHODS FOR CREATING COPIES OF DATA SUCH AS ARCHIVE COPIES), each of which is incorporated by reference herein in its entirety.","In some examples, the secondary storage computing devices  maintain one or more variable instance databases. Variable instancing generally refers to storing in secondary storage one or more instances, but fewer than the total number of instances, of each data block (or data object) in a set of data (e.g., primary data). More details as to variable instancing may be found in the commonly-assigned U.S. Pat. App. No. 61\/164,803 (entitled STORING A VARIABLE NUMBER OF INSTANCES OF DATA OBJECTS).","In some embodiments, certain components may reside and execute on the same computer. For example, in some embodiments, a client  such as a data agent , or a storage manager , coordinates and directs local archiving, migration, and retrieval application functions as further described in the previously-referenced U.S. patent application Ser. No. 09\/610,738. This client  can function independently or together with other similar clients .","As shown in , secondary storage computing devices  each has its own associated metabase . Each client  may also have its own associated metabase . However in some embodiments, each \u201ctier\u201d of storage, such as primary storage, secondary storage, tertiary storage, etc., may have multiple metabases or a centralized metabase, as described herein. For example, rather than a separate metabase or index associated with each client  in , the metabases on this storage tier may be centralized. Similarly, second and other tiers of storage may have either centralized or distributed metabases. Moreover, mixed architecture systems may be used if desired, that may include a first tier centralized metabase system coupled to a second tier storage system having distributed metabases and vice versa, etc.","Moreover, in operation, a storage manager  or other management module may keep track of certain information that allows the storage manager  to select, designate, or otherwise identify metabases to be searched in response to certain queries as further described herein. Movement of data between primary and secondary storage may also involve movement of associated metadata and other tracking information as further described herein.","In some examples, primary data may be organized into one or more sub-clients. A sub-client is a portion of the data of one or more clients , and can contain either all of the data of the clients  or a designated subset thereof. As depicted in , the data store  includes two sub-clients. For example, an administrator (or other user with the appropriate permissions; the term administrator is used herein for brevity) may find it preferable to separate email data from financial data using two different sub-clients having different storage preferences, retention criteria, etc.","Referring to , a block diagram illustrating an example of components of a server or system  used in data storage operations is shown. A server, such as storage manager , may communicate with clients  to determine data to be copied to storage media. As described above, the storage manager  may contain a jobs agent , a management agent , a database , an interface module , and\/or other agents . Jobs agent  may manage and control the scheduling of jobs (such as copying data files) from clients  to media agents  (not shown). Management agent  may control the overall functionality and processes of the data storage system or may communicate with global managers. Database  or another data structure may store storage policies, schedule policies, retention policies, or other information, such as historical storage statistics, storage trend statistics, and so on. Interface module  may interact with a user interface, enabling the system to present information to administrators and receive feedback or other input from the administrators or with other components of the system (such as via APIs).","Block Level Single Instancing","Instead of single instancing files or data objects, single instancing can be performed on a block level. Files can be broken into blocks and transmitted using the techniques described herein. The blocks are typically fixed sizes, e.g., 64 Kb. An identifier is created for each block, and a lookup of the identifier is performed in the single instance database  to see if it has already been stored. If it has not, then the block can be stored. If it has, a reference to the block can be stored, using the techniques described herein.","For example, a data storage system may include multiple computing devices (e.g., client computing devices) that store primary data (e.g., production data such as system files, user files, etc.). The data storage system may also include a secondary storage computing device, a single instance database, and one or more storage devices that store copies of the primary data (e.g., secondary copies, tertiary copies, etc.). The secondary storage computing device receives blocks of data from the computing devices and accesses the single instance database to determine whether the blocks of data are unique (unique meaning that no instances of the blocks of data are already stored on the storage devices). If a block of data is unique, the single instance database stores it in a file on a storage device. If not, the secondary storage computing device can avoid storing the block of data on the storage devices.","The primary data of the computing devices can be divided into data that is eligible for single instancing and data that is not eligible for single instancing. An example of the latter is metadata (e.g., Master File Table information) and an example of the former is data (e.g., operating system and\/or application files). A file typically comprises one or more blocks as tracked by the file systems of the computing devices.","The computing devices align data that is eligible for single instancing into blocks of data (which may comprise one or more blocks as tracked by the file systems of the computing devices) and generate identifiers for the blocks of data that the secondary storage computing device uses to determine if the blocks of data are unique. This allows the secondary storage computing device to avoid generating identifiers for the blocks of data, which may be computationally expensive and\/or require a long time to perform. Therefore, distributed identifier generation apportions potentially lengthy operations across numerous computing devices, thereby freeing up the secondary storage computing device to perform other operations (e.g., storing data, retrieving data, pruning data, etc.).","The computing devices send the blocks of data and other data (e.g., metadata and\/or the data that is not eligible for single instancing) in a data stream to the secondary storage computing device. The secondary storage computing device receives the data stream and stores blocks of data and their identifiers in buffers in random access memory (RAM). The secondary storage computing device determines whether a block of data is already stored on a storage device. To do this, the secondary storage computing device determines, by analyzing data structures in the single instance database in view of the block's identifier, whether the block of data is already stored on a storage device. If it is, then the secondary storage computing device 1) stores a link to the already stored block of data in a metadata file and 2) discards the block of data from the memory buffer. If it is not, then the secondary storage computing device stores the block of data in a container file.","Because the size of a block of data and associated metadata is typically less then the size of a memory buffer, the secondary storage computing device can keep a single block of data in a single memory buffer while it looks up its identifier in the single instance database. This allows the secondary storage computing device to avoid writing the block of data to disk (an operation which is typically slower than storing the block of data in a RAM buffer) until the secondary storage computing device determines that it needs to store the block of data in a container file on a storage device. The secondary storage computing device stores data that is not eligible for single instancing in metadata files.","By storing multiple blocks of data in a single container file, the secondary storage computing device avoids storing each block of data as a separate file on the file systems of the storage devices. This reduces the number of files that would be stored on the file systems of the storage devices, thereby ensuring that the storage devices can adequately store the data of the computing devices in the data storage system.","One advantage of these techniques is that they significantly reduce the number of files stored on a file system of a computing device or storage device. This is at least partly due to the storage of data blocks within the container files. Even if the secondary storage computing device performs numerous storage operations, these techniques will result in storing far fewer files on the file system than storage operations where each data block is stored as a separate file. Therefore, the file system of the computing device or storage device may not necessarily have to contend with storing excessively large numbers of files, such as millions of files or more. Accordingly, these techniques enable very large numbers of blocks of data to be stored without regard to limitations of the file system of the computing device or storage device.","However, the storage of blocks of data in container files may create additional complexities when it comes time to prune or delete data. This is because a container file may contain blocks of data that are referenced by links in metadata files and thus cannot be deleted, because referenced blocks of data typically still need to be stored on the storage devices. Furthermore, because the blocks of data are not stored as files on the file systems of the storage devices, they cannot be directly referenced by the file system.","The systems and methods described herein provide solutions to these problems. The secondary storage computing device creates the container files as sparse files (typically only on operating systems that support sparse files, e.g., Windows operating systems, but also on other operating systems that support sparse files). A sparse file is type of file that may include empty space (e.g., a sparse file may have real data within it, such as at the beginning of the file and\/or at the end of the file, but may also have empty space in it that is not storing actual data, such as a contiguous range of bytes all having a value of zero). Second, the secondary storage computing device maintains a separate index that stores an indication of whether blocks of data in container files are referred to by links in metadata files. In some examples, this can be thought of as creating another file system on top of the existing file systems of the storage devices that keeps track of blocks of data in the container files.","When a block of data is not referred to and does not need to be stored, the secondary storage computing device can prune it. To prune data, the secondary storage computing device accesses the separate index to determine the blocks of data that are not referred to by links. On operating systems that support sparse files, the secondary storage computing device can free up space in the container files corresponding to those blocks of data by marking the portions of the physical media corresponding to the unreferenced portions of the container file as available for storage (e.g., by zeroing out the corresponding bytes in the container files). On operating systems that do not support sparse files, the secondary storage computing device can free up space in the container files by truncating the extreme portions of the container files (e.g., the beginnings and\/or the ends of the container files), thereby making the corresponding portions of the physical media available to store other data. Freeing up space in container files allows the operating system to utilize the freed-up space in other fashions (e.g., other programs may utilize the freed-up space).","Siloing a Single Instance Store","The combination of the data stored on the storage device  and the single instance database  can be termed a \u201csingle instance store.\u201d Siloing a single instance store refers to moving all the information stored in the single instance store to secondary storage, such as to tape, to create a silo of a single instance store. When this occurs, a new single instance store, comprising a new single instance database  and a new data structure (e.g., a new collection of one or more chunk folders ) on the storage device  is created. When this occurs, single instancing of data objects essentially starts over from the beginning.","This process can be repeated on a periodic or ad hoc basis to create multiple silos of single instance stores. Consider the following example. A single instance store can be siloed every 15 days. Starting at day 1, secondary copies of numerous data objects can be created on the storage device  using the techniques described herein. These data objects can be backed up to tape and the tapes sent offsite for storage (although the tapes are described as being sent offsite, they may not be sent offsite). On day 2, any incremental changes to the data objects would be picked up and copied over to the storage device , backed up to tape, and the tape sent offsite for storage. This continues until day 15, when the entire single instance store is backed up to tape. On day 16, a new single instance store is created at that time, and the above process would start anew. One advantage of this process is that up to 15 days worth of changes to data objects can be easily recovered.","Another advantage of this process that it may reduce the number of secondary media, such as tapes, needed to restore files. For example, the longer period of time between backups of a single instance store, the more tapes potentially could be needed to restore files. For example, a very large number of files could have references on a large number of tapes. All of the tapes would need to be mounted in order to restore all of the very large number of files. This could slow down the restore process to unacceptable levels.","Although a fifteen-day window has been described for siloing a single instance store, this window may be configurable based upon the storage needs of the implementer of the system. This window could be optimized based upon the rate of change of the data being stored. For example, if the rate of change of data is very small, then a longer siloing window can be used, because there is a lot of data being single instanced, and therefore tapes will be used at a slower rate. However, if the rate of change of data is very high, then a shorter siloing window may be necessary, because the amount of data that is being single instanced is actually very low, and therefore tapes will be used at a faster rate. This window can also be based on other factors, including tape usage, tape hardware, tape access times, numbers of restores, etc., in order to optimize the siloing window for the storage needs of the implementer of the system.","Conclusion","Systems and modules described herein may comprise software, firmware, hardware, or any combination(s) of software, firmware, or hardware suitable for the purposes described herein. Software and other modules may reside on servers, workstations, personal computers, computerized tablets, PDAs, and other devices suitable for the purposes described herein. Modules described herein may be executed by a general-purpose computer, e.g., a server computer, wireless device, or personal computer. Those skilled in the relevant art will appreciate that aspects of the invention can be practiced with other communications, data processing, or computer system configurations, including: Internet appliances, hand-held devices (including personal digital assistants (PDAs)), wearable computers, all manner of cellular or mobile phones, multi-processor systems, microprocessor-based or programmable consumer electronics, set-top boxes, network PCs, mini-computers, mainframe computers, and the like. Indeed, the terms \u201ccomputer,\u201d \u201cserver,\u201d \u201chost,\u201d \u201chost system,\u201d and the like, are generally used interchangeably herein and refer to any of the above devices and systems, as well as any data processor. Furthermore, aspects of the invention can be embodied in a special purpose computer or data processor that is specifically programmed, configured, or constructed to perform one or more of the computer-executable instructions explained in detail herein.","Software and other modules may be accessible via local memory, a network, a browser, or other application in an ASP context, or via another means suitable for the purposes described herein. Examples of the technology can also be practiced in distributed computing environments where tasks or modules are performed by remote processing devices, which are linked through a communications network, such as a Local Area Network (LAN), Wide Area Network (WAN), or the Internet. In a distributed computing environment, program modules may be located in both local and remote memory storage devices. Data structures described herein may comprise computer files, variables, programming arrays, programming structures, or any electronic information storage schemes or methods, or any combinations thereof, suitable for the purposes described herein. User interface elements described herein may comprise elements from graphical user interfaces, command line interfaces, and other interfaces suitable for the purposes described herein.","Examples of the technology may be stored or distributed on computer-readable media, including magnetically or optically readable computer disks, hard-wired or preprogrammed chips (e.g., EEPROM semiconductor chips), nanotechnology memory, biological memory, or other data storage media. Indeed, computer-implemented instructions, data structures, screen displays, and other data under aspects of the invention may be distributed over the Internet or over other networks (including wireless networks), on a propagated signal on a propagation medium (e.g., an electromagnetic wave(s), a sound wave, etc.) over a period of time, or they may be provided on any analog or digital network (packet switched, circuit switched, or other scheme).","Unless the context clearly requires otherwise, throughout the description and the claims, the words \u201ccomprise,\u201d \u201ccomprising,\u201d and the like are to be construed in an inclusive sense, as opposed to an exclusive or exhaustive sense; that is to say, in the sense of \u201cincluding, but not limited to.\u201d As used herein, the terms \u201cconnected,\u201d \u201ccoupled,\u201d or any variant thereof, means any connection or coupling, either direct or indirect, between two or more elements; the coupling or connection between the elements can be physical, logical, or a combination thereof. Additionally, the words \u201cherein,\u201d \u201cabove,\u201d \u201cbelow,\u201d and words of similar import, when used in this application, refer to this application as a whole and not to any particular portions of this application. Where the context permits, words in the above Detailed Description using the singular or plural number may also include the plural or singular number respectively. The word \u201cor,\u201d in reference to a list of two or more items, covers all of the following interpretations of the word: any of the items in the list, all of the items in the list, and any combination of the items in the list.","The above Detailed Description is not intended to be exhaustive or to limit the invention to the precise form disclosed above. While specific examples for the invention are described above for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. For example, while processes or blocks are presented in a given order, alternative implementations may perform routines having steps, or employ systems having blocks, in a different order, and some processes or blocks may be deleted, moved, added, subdivided, combined, and\/or modified to provide alternative or subcombinations. Each of these processes or blocks may be implemented in a variety of different ways. Also, while processes or blocks are at times shown as being performed in series, these processes or blocks may instead be performed or implemented in parallel, or may be performed at different times. Further any specific numbers noted herein are only examples: alternative implementations may employ differing values or ranges.","The teachings of the invention provided herein can be applied to other systems, not necessarily the system described above. The elements and acts of the various examples described above can be combined to provide further implementations of the invention.","Any patents and applications and other references noted above, including any that may be listed in accompanying filing papers, are incorporated herein by reference. Aspects of the invention can be modified, if necessary, to employ the systems, functions, and concepts of the various references described above to provide yet further implementations of the invention.","These and other changes can be made to the invention in light of the above Detailed Description. While the above description describes certain examples of the invention and describes the best mode contemplated, no matter how detailed the above appears in text, the invention can be practiced in many ways. Details of the system may vary considerably in its specific implementation, while still being encompassed by the invention disclosed herein. As noted above, particular terminology used when describing certain features or aspects of the invention should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics, features, or aspects of the invention with which that terminology is associated. In general, the terms used in the following claims should not be construed to limit the invention to the specific examples disclosed in the specification, unless the above Detailed Description section explicitly defines such terms. Accordingly, the actual scope of the invention encompasses not only the disclosed examples, but also all equivalent ways of practicing or implementing the invention under the claims.","While certain aspects of the invention are presented below in certain claim forms, the applicant contemplates the various aspects of the invention in any number of claim forms. For example, while only one aspect of the invention is recited as a means-plus-function claim under 35 U.S.C \u00a7112, \u00b66, other aspects may likewise be embodied as a means-plus-function claim, or in other forms, such as being embodied in a computer-readable medium. (Any claims intended to be treated under 35 U.S.C. \u00a7112, \u00b66, will begin with the words \u201cmeans for\u201d.) Accordingly, the applicant reserves the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIGS. 2A-2D"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 8A and 8B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 9A and 9B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 11A and 11B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 12A and 12B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
