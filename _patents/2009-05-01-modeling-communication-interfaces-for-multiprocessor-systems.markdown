---
title: Modeling communication interfaces for multiprocessor systems
abstract: In an embodiment, a graphical model may include a functional portion and a architectural portion. The architectural portion may describe a multiprocessor system. Inter-process communication blocks may be defined that describe the connectivity of functional blocks in the deployed version of the model. The IPC blocks may describe the connectivity of the blocks independent of the communication channel(s) that connect the processor nodes in the multiprocessor system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08204732&OS=08204732&RS=08204732
owner: The MathWorks, Inc.
number: 08204732
owner_city: Natick
owner_country: US
publication_date: 20090501
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","BACKGROUND","DETAILED DESCRIPTION","Overview","DEFINITIONS","System Description","Multiprocessor System Model","CONCLUSION"],"p":["The instant application claims priority from provisional application No. 61\/102,502, filed Oct. 3, 2008, the disclosure of which is incorporated by reference herein in its entirety.","Technical computing environments are known that present a user, such as a scientist or engineer, with an environment that enables efficient analysis and generation of technical applications. For example, users may perform analyses, visualize data, and develop algorithms. Technical computing environments may allow a technical researcher or designer to efficiently and quickly perform tasks such as research and product development.","Existing technical computing environments may be implemented as or run in conjunction with a graphically-based environment. For example, in one existing technical computing environment that is run in conjunction with a graphically-based environment, graphical simulation tools allow models to be built by connecting graphical blocks, where each block may represent an object associated with functionality and\/or data.","The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements. Also, the following detailed description does not limit the invention.","In modeling a system in a graphical modeling environment (GME), the system to be modeled may include a multiprocessor system such as a distributed embedded system or a parallel computing system. In a distributed embedded system, each processor may have a defined role and may perform different tasks from other processors. A parallel computing system may include multiple processors packaged as a unit in which a large problem is decomposed to smaller problems that can be run in parallel on the multiple processors.","Graphically represented blocks (i.e., functional elements) that are to be executed by different processors may need to communicate with one another over one or more logical channels that connect the blocks on different processors. A \u201cchannel,\u201d when eventually implemented in the run-time environment may correspond to, for example, a low-level local electrical bus, a network connection, or a long distance optical connection.","Models generated with graphical modeling tools may be simulated on a host computer or converted to computer code by the graphical modeling tool. The computer code can then be executed in the target multiprocessor environment. Graphical modeling tools may allow the user to separately specify an architectural model of the physical system, such as the number of processors and the communication channels through which they are connected, and the algorithm that is to be implemented by the model. A final, executable version of the model may then be based on a mapping of the functional model to the architectural model.","Implementations described herein relate to a graphical modeling environment (GME). The GME may be a part of or incorporate a technical computing environment (TCE). The models may include an architectural model that defines a physical or conceptual implementation of a multiprocessor system and a functional model that defines a desired algorithm that is to be implemented by the model. The architectural and functional versions of the model may be combined to create a version of the model that can be deployed in a target environment. In an implementation, inter-process communication (IPC) blocks may be defined that describe a connectivity of functional blocks in a deployed version of the model. The IPC blocks may describe functional properties of the communication, such as the connectivity of the blocks and the communication timing, independently of physical details of one or more communication channels that connect processor nodes in the multiprocessor system. The IPC blocks may then be further customized using an authoring language, as part of an application programming interface (API), to describe deployment details of communication interfaces that attach the processor nodes to one or more communication channels. The communication channels may be defined such that they describe functional properties of the communication, such as Bit Error Rate (BER) or latency, independently of the processor nodes and independently of the IPC blocks which are communicating data over the channels. A functionality of the communication between the processor nodes may be derived based on the communication interfaces and the functional properties of communication. The functionality of communication may be derived, for example, while evaluating or compiling the model. Note that the communication interfaces and the functional properties of the communication may be described in a partial manner such that the GME propagates and derives a functionality of the communication based on partial information.","A \u201cmultiprocessor system\u201d may be defined as a computing system in which multiple processors or processor cores communicate over one or more channels to execute a task. Each processor or processor core in a multiprocessor system may be referred to as a \u201cprocessor,\u201d \u201cprocessor node,\u201d or \u201cnode\u201d herein. Distributed embedded systems and task parallel computing systems are examples of multiprocessor systems.","A \u201cfunctional model,\u201d as used herein, may refer to a model that implements algorithmic elements in which a designer is interested. Generally, the functional model may be created without regard to implementation details of the physical system that is to implement the model. The \u201carchitectural model\u201d or \u201cdeployment model,\u201d as used herein, may refer to a target system in which the functional model is to be implemented. The deployment model may generally describe capabilities of the physical system such as its computational resources, memory resources and additional physical devices for which the functional model will be implemented. Consideration of the details of the physical system with respect to the requirements of the algorithmic elements in the functional model may be resolved as part of a mapping of the functional model to the architectural model.","The models described herein may be created in a graphical modeling environment (GME). The GME may incorporate or be part of a technical computing environment that may include any hardware and\/or software based logic that provides a computing environment that allows users to perform tasks related to disciplines, such as, but not limited to, mathematics, science, engineering, medicine, business, etc.","The GME may further provide mathematical functions and\/or graphical tools or blocks (e.g., for creating plots, surfaces, images, volumetric representations, etc.). In an implementation, the GME may provide these functions and\/or tools using toolboxes (e.g., toolboxes for signal processing, image processing, data plotting, parallel processing, etc.). In another implementation, the GME may provide these functions as block sets. In still another implementation, the GME may provide these functions in another way, such as via a library, etc.","The GME may implement an environment that provides for the graphical creation of models that are defined by users to implement desired functionality. Certain aspects of the GME, as it relates to the creation of models, will be described in more detail below.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","110","110","120","120"]},"Workstation  may operate as a single detached computing device. Alternatively, workstation  may be connected to a network , such as a local area network (LAN) or wide area network (WAN) such as the Internet. When workstation  is connected to a network, GME  may be run by multiple networked computing devices or by one or more remote computing devices. In such an implementation, GME  may be executed in a distributed manner, such as by executing on multiple computing devices simultaneously. Additionally, in some implementations, GME  may be executed over network  in a client-server relationship. For example, workstation  may act as a client that communicates with, using a web browser, a server that stores and potentially executes the GME program.","For example, as shown in , system  may include a remote GME  (e.g., a remotely located computing device running a GME) and\/or a GME service . GME service  may include a server computing device that provides a GME as a remote service. For instance, a GME may be provided as a web service. The web service may provide access to one or more programs provided by GME service .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["110","140","160","110","210","220","230","240","250","260","270","280","210","110"]},"Processing unit  may include a processor, microprocessor, or other types of processing logic that may interpret and execute instructions. Main memory  may include a random access memory (RAM) or another type of dynamic storage device that may store information and instructions for execution by processing unit . ROM  may include a ROM device or another type of static storage device that may store static information and\/or instructions for use by processing unit . Storage device  may include a magnetic and\/or optical recording medium and its corresponding drive.","Input device  may include a mechanism that permits an operator to input information to workstation , such as a keyboard, a mouse, a pen, a single- or multi-point interface such as a touchpad, a microphone, an accelerometer, gyroscope, a neural interface, voice recognition and\/or biometric mechanisms, etc. Output device  may include a mechanism that outputs information to the operator, including a display, a printer, a speaker, etc. Communication interface  may include any transceiver-like mechanism that enables workstation  to communicate with other devices and\/or systems. For example, communication interface  may include mechanisms for communicating with another device or system via a network, such as network .","As will be described in detail below, workstation  may perform certain operations in response to processing unit  executing software instructions contained in a computer-readable medium, such as main memory . For instance, workstation  may implement GME  by executing software instructions from main memory . A computer-readable medium may be defined as a physical or logical memory device. The software instructions may be read into main memory  from another computer-readable medium, such as storage device , or from another device via communication interface . The software instructions contained in main memory  may cause processing unit  to perform processes that will be described later. Alternatively, hardwired circuitry may be used in place of or in combination with software instructions to implement processes described herein. Thus, implementations described herein are not limited to any specific combination of hardware circuitry and software.","Although  shows exemplary components of workstation , in other implementations, workstation  may contain fewer, different, or additional components than depicted in . In still other implementations, one or more components of workstation  may perform one or more tasks performed by one or more other components of workstation .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":"120"},"Referring to , GME  may provide for the creation of a functional model (block ). GME  may, for example, provide one or more graphical interfaces through which a user can arrange graphical blocks that represent functionality and\/or data. A graphical block may itself be defined using one or more graphical blocks to create model sub-systems. At some level, blocks may be defined via computer code. Users of GME  may obtain blocks that define different functions by using, for example, blocks written by a manufacturer of the GME , from third parties, or by defining their own custom blocks. In alternative implementations, the functional model may be represented as, for example, a state transition diagram instead of a block diagram.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["400","400","1","410","2","415","3","420","4","425","5","430","6","435","7","440","410","440","1","2","3","4","4","5","6","3","7","120","410","440","120"]},"When designing functional model , the user, in general, may not need to be concerned with the details of how the model will be finally deployed.","Referring back to , GME  may also provide for the creation of an architectural model (block ). GME  may, for example, provide one or more graphical interfaces through which a user can arrange graphical blocks that represent functionality of the multiprocessing system on which functional model  is to be deployed.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 5A","FIG. 5A"],"b":["500","500","500","510","520","530","510","520","530"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 5B","FIG. 5A","FIG. 4"],"b":["520","530","520","540","1","540","540","550","1","550","550","540","410","440","540","500","500","510","520","500"]},"IPC blocks for a processor node may describe an interface that the processor node sees to a communication channel. Thus, for example, IPC blocks - to -N may describe an interface that processor node  sees to communication channel . The IPC blocks  may include, for instance, a \u201cread\u201d block and a \u201cwrite\u201d block that may be configured to implement reading and writing to the channel , respectively.","Communication channel  may include one or more channel functional blocks - through -N that describe the behavior of the channel. Communication channel  may also include port blocks - through -N which describe connection ports attached to the channel . The blocks that define communication channel  may, for instance, model properties of channel  such as the bandwidth of the channel, an error rate of the channel (e.g., bit error rate (BER) or packet error rate (PER)), the latency of the channel, or other properties relating to the channel. A model of channel  may be designed to be a model of an expected implementation of channel , such as, for example, a network connection, a direct physical connection (e.g., a serial bus), or a shared memory connection.","Channel functional blocks  and port blocks  of communication channel  may be associated with one or more parameters that define the operation of blocks  and port blocks . For example, if a block  introduces a network delay, a parameter associated with this block  may be the amount of delay, delay probability distribution that may be defined by mean and variance parameters, or maximum delay for the block . GME  may allow channel designers to define a mask for the parameters of communication channel , where the mask specifies which parameters for communication channel  are to be \u201cpublic\u201d parameters (i.e., the parameters that can normally be altered by external processor nodes or functional blocks) for communication channel .","A channel, such as communication channel , may also be specified as a library of different implementations at different levels of abstraction. For instance, a channel model of a bus may be expressed as a variable delay or in much more detail as a discrete-event model. Users may be allowed to use a user-interface to select a specific channel model from among the several implementations in the library for a simulation run of their deployment model to implement the channel. Additionally, a choice from the library may be made in an automated fashion based on actual signals being communicated on the channel. For instance, if the data being communicated is a vector of values, the channel may automatically configure itself to be an implementation that decomposes each vector element to a separate packet that is then passed through the channel. It should also be noted that within the library of implementations for a channel, one may also use an implementation that involves co-simulating with another software environment. For example, among different models of a bus in a library of channel models could be a bus which is in co-simulation with a System-C environment that has a full specification of the bus in the System-C language.","Referring back to , functional model  may be mapped to architectural model  (block ). Mapping the functional model to the architectural model may generally involve assigning functional units (e.g., blocks) in functional model  to the processing nodes and\/or the communication channel in the architectural model . In some implementations, the mapping of the functional model to the architectural model may be performed automatically by GME  or semi-automatically in which the user may guide GME  in mapping the functional units to the architectural model. When automatically or semi-automatically mapping the functional model to the architectural model, GME  may use algorithmic blocks of the processor nodes and communication channel(s) to optimize assignment of functional units to processor nodes. For example, if a communication channel, such as channel , has a low bandwidth, functional blocks that have a high inter-block data connection may tend to be mapped to the same processor nodes. In other implementations, the mapping may be performed manually, in which, for example, a user may map functional units to processing nodes in architectural model .","As part of the mapping process, certain properties of the functional blocks may be reconfigured or partially reconfigured in order to meet various algorithmic requirements of functionality with respect to capabilities and resources provided by hardware and\/or other architectural elements. For example, as part of the mapping, fixed-point data types may be reconsidered to make use of available word-sizes on target hardware. As another example, values of certain closed-loop gains may be readjusted to account for delays which may be incurred as a result of communication from one node to another.","Various properties of the functional blocks may be partially specified. Here, the GME may propagate, complete, and select the partially specified properties based on hardware and other architectural resources available. For example, the GME may select data types of block outputs to be the largest possible word size for accuracy or the smallest possible word size based on memory optimization settings.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 6","FIG. 6"],"b":["400","500","510","1","400","1","2","3","2","1","3","2","4","5","6","3","7","4","5","6","1","2","3","4","7","510","5","6","520","510","520","530","400","510","1","2","3","510","3","530","520","4","510","5","6","520","530","7","7","510"]},"Referring back to , functional model , after being mapped to architectural model , may be compiled for execution in a target environment (block ). In the example of , for instance, blocks F, F, F, F, and F may be compiled to execute on processor node  and blocks F and F may be compiled to execute on processor node .","The final deployed model may next be simulated on a host environment (e.g., workstation ) or executed in the target environment (block ). The target environment may include any of a number of arrangements of multiprocessor computing devices. For example, the target environment may include a distributed embedded system or a parallel computing system.","When mapping the functional model to the architectural model, connectivity between functional blocks located at different processing nodes may be specified. In existing systems, connectivity of functional blocks amongst different processing nodes may be specified as an aggregate connection path including links from a processor node to an input of the channel, from the input of the channel to an output of the channel, and from the output of the channel to the input of the destination processor node. This process is conceptually illustrated in , in which four processor nodes , , , and  are connected by a channel . Assume that a functional block  in processor node  generates data, (i.e., it functions as a data source) that is to be input to a functional block  to use the data (i.e., it is a data sink for the data generated by functional block ). As shown in , three different communication links (L, L, and L) are specified and each link may need to be separately specified. The links may be manually specified through various points in channel , such as the link, L, from functional block  to a first input port of channel .","Specifying connectivity as separate links that traverse channel , as shown in , can have a number of disadvantages. For example, the logical connectivity of functional blocks amongst different processing nodes may depend on the content and the implied connectivity of the communication channel. Therefore, if a different communication channel is used, the logical connectivity of the functional blocks may change. Connecting additional processing nodes to the channel may require a change in the description of the channel. This is because the description of the channel may depend on the number of communication interfaces that are attached to the channel.","Consistent with aspects described herein, inter-process communication (IPC) blocks may be defined that describe the connectivity of functional blocks in the deployed version of a model. The IPC blocks may describe the connectivity of the functional blocks independent of the communication channel(s) connecting the processing nodes. In an implementation, each IPC communication block may be associated with a label that designates the messages communicated by that IPC communication block. Connectivity between two IPC blocks can be automatically derived by matching different labels for IPC blocks. The actual connectivity of the channel may be independent of the logical connectivity of the IPC blocks.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 8","FIG. 8"],"b":["800","800","800","800","810","820","830","840","805","800","805","810","845","850","805","820","855","860","805","830","865","870","805","840","875","880","805"]},"IPC blocks , , , and  may be added to model  during, for instance, the design of the architectural model or the mapping of the functional model to the architectural model. GME  may provide a number of different types of IPC blocks that relate to inter-processor communication, such as the previously mentioned read blocks (e.g., read blocks  and ) and write blocks (e.g., write blocks  and ). Read blocks  and  may generally operate to provide an interface that receives data over communication channel  and provides it to one or more functional blocks. Write blocks  and  may generally operate to provide an interface that receives data from one or more functional blocks and transmits the data over communication channel . Additional types of IPC blocks, which perform different functions relating to inter-processor communications, may also be implemented by GME  and will be discussed in more detail below. Further, functions of one or more IPC blocks given herein may, in some implementations, be combined to be included in the functionality of a single block or separated into multiple different blocks. For example, in some implementations, the read and write IPC blocks may be implemented as a single read\/write IPC block.","As shown in , an IPC read and write block may be associated with a tag assigned by the user or GME . IPC read block  and IPC write block  are associated with the tag \u201cM\u201d while IPC read block  and IPC write block  are associated with the tag \u201cM\u201d. GME  may use the tags to determine which IPC read and write blocks should be connected, via communication channel , with one another. Thus, in the example of , IPC write block  should send its data to IPC read block  and IPC write block  should send its data to IPC read block . GME  may dynamically determine the appropriate IPC write block and read block connections based on the tags and subsequently use this information in various stages of model evaluation, compilation, simulation and\/or code generation. By using tags in the IPC read and write blocks, the logical connectivity of the blocks can be separated from the actual connectivity of communication channel . This may provide for the ability to view each processor node in a functional view where all IPC reads and writes are translated to functional data inputs and outputs.","Separating the logical connectivity of the IPC blocks from the actual connectivity of communication channel  can advantageously allow for efficient substitution of different channels into a model. For example, a user may wish to simulate the operation of a model with multiple different types of channels before deciding on a particular channel to use in the final system.","In addition to specifying connectivity tags, in some implementations, the IPC read and write blocks may be associated with additional parameters that specify further functional details about the timing of the read or write operations, respectively. These parameters may be modified through GME . These additional parameters may be specified independently of the actual details of the communication interface represented by the read and write blocks.","The IPC write blocks may additionally include parameters relating to, for example, whether the write operation is blocking or non-blocking, whether the write operation is buffered and the buffer size, and whether the write operation can be executed conditionally (for example, by placing an IPC write block inside of a conditionally triggered subsystem), and whether the write operation may be attached to an Interrupt Service Routine (ISR) to begin an asynchronous task. For conditional execution of the write operation, the write operation may be specified to emit signals only at discrete time instances. The IPC read blocks may additionally include parameters relating to whether the read operation is blocking or non-blocking, whether the read operation is buffered and the buffer size, and whether the read operation may be attached to an ISR to begin an asynchronous task. In the case of the write and read operations being attached to an ISR, the ISR or the task may be initiated upon writing a message or receiving a message from a designated port.","In some implementations, the communication channel may also specify constraints on an operation mode (blocking\/non-blocking), buffer sizes and triggering modes of the IPC blocks.","IPC read blocks  and , and IPC write blocks  and  can be conceptualized as blocks in the functional model  that correspond to data input ports and data output ports, respectively. The corresponding processor node may then be tested in a purely functional modeling environment. In addition, it may be desirable to validate that certain connections amongst IPC blocks are one-to-one or one-to-many. These constraints may be specified, for example, as a parameter of channel  itself. Examples of constraints that may be validated include, but are not limited to one-to-one connections, one-to-many connections, and many-to-one connections. Additionally, by using IPC read and write blocks, the functional connectivity of the model blocks does not necessarily depend on the actual details of the physical communication interface represented by the IPC read and write blocks","The above-described IPC read blocks and write blocks may allow topological constraints that are specified for the architectural model to be validated independently of the representation of communication channel .","In addition to IPC read blocks and IPC write blocks, GME  may provide additional IPC blocks that can be used to configure other aspects of an inter-processor communications interface.  is a diagram illustrating an exemplary model  including additional types of IPC blocks.","As shown in , model  includes a processor node  connected to a processor node  via a communication channel . A number of IPC blocks and functional model blocks are shown in processor nodes  and . The IPC blocks include: IPC write block , IPC read block , IPC initialization block , IPC setup block , IPC initialization block , and IPC status block . The functional blocks include: block F , block F , and block F . Assume the functional blocks represent generic arbitrary functional blocks. Functional block F  may function as a data source for IPC write block  and functional block F  may function as a data sink for IPC read block .","IPC write block  and IPC read block  may function similarly to IPC write block  and IPC read block  ().","IPC initialization block  may be a block provided by GME  that logically groups functions and\/or parameters that provide for the conditional initialization of an interface between processor node  and communication channel , potentially as a function of one or more input signals. In some implementations, certain aspects of the system, such as hardware relating to communication channel , may need to be initially configured. For example, for a synchronous bus, the data transmission rate for the bus may need to be configured. Parameters relating to IPC initialization block  may allow the user to control these initialization parameters. During run-time operation of the model, IPC initialization block  may initially, before operation of other blocks, initialize the channel interface. In some implementations, multiple IPC initialization blocks  may be used to initialize different aspects of the channel interface. As shown in , for instance, two IPC initialization blocks  and  are shown. Each may configure a different aspect of the channel interface. Furthermore, the \u201cinitialization\u201d performed by IPC initialization block  may, in some implementations, occur during run-time to effectively dynamically re-initialize a communication interface during operation of the model.","IPC status block  may be a block provided by GME  that monitors the status of the channel interface and produces output signals that represent the monitored status. IPC status block  may also maintain a log of the status of the channel interface. IPC status block  may make the status of the interface available to other blocks as one or more variables or other data structures. For example, IPC status block  may provide an output indicating whether the interface is functioning normally, an output indicating whether an error or exception occurred, an output indicating the bandwidth of the interface, an output indicating whether a network connection is valid or dropped, an output indicating whether a serial interface is \u201cready to transmit\u201d or \u201cready to receive,\u201d or other outputs. Other IPC blocks or model functional blocks may view the status of the interface by connecting to IPC status block . For instance, as shown in , functional block F  may connect to IPC status block  to receive the status of the interface. IPC initialization blocks may also particularly connect to IPC status block . The IPC initialization block may, for instance, reinitialize the interface if the IPC status block indicates certain exceptional conditions are occurring in the interface. As some examples of exceptional conditions, a detectable fault may occur in the system for which a re-initialization may be desirable to invoke a back-up system to replace the faulty components. As another example, to avoid interference with other transmitters, the transmission power of a wireless transmitter may be recomputed during a re-initialization event. In another example, to transmit critical information, the bandwidth allocated to the IPC interface may be rebalanced as part of the re-initialization process.","IPC setup block  may be a block provided by GME  to specify parameters of a communication interface that are common to IPC read, write, initialization, or status blocks associated with that interface. IPC setup block  may configure (e.g., initialize, terminate) the communication interface and monitor the communication interface. Examples of the parameters that may be specified by IPC setup block  include an Internet Protocol (IP) address in a TCP\/IP communication link, an interrupt request (IRQ) number of the communication device on a personal computer based processing node, or other vendor specific parameters of the communication device that may be driving the communication interface.","As previously mentioned, the communication channel itself may be modeled. Modeling the communication channel can be useful when simulating a model before final deployment of the model in its target system. More particularly, to support the logical connectivity discussed above between IPC read and write blocks, it may be important to validate the functional behavior of the communication channel such that the physical connection paths that follow the links in the channel are true to the logical paths. Consistent with aspects described herein, GME  may provide model connector blocks that function to aggregate messages being written to the communication channel.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 10","FIG. 8"],"b":["1000","1000","800","1005","1005","1010","1020","1030","1040","1045"]},"Channel inport block  may be a model connector block that may aggregate messages written to the channel by IPC write blocks connected to the channel. In , channel inport block  may receive messages associated with the IPC write blocks that have tags \u201cM\u201d and \u201cM.\u201d Channel inport block  may aggregate the messages into a single bus signal (e.g., a Simulink\u00ae Bus signal)","Blocks , , and  model communications through communication channel  as a channel that may randomly delay some messages. It can be appreciated that other communication channels may be modeled using different functional blocks. Switch block  may particularly represent a block that operates element-wise (i.e., on a message basis) on bus signals. For an element in the aggregate signal line, switch block  may output either the current message or a time delayed version (corresponding to a communication delay) of the current message received from delay block . The decision whether to output the current message or the time delayed version may be randomly determined based on the output of random block .","Blocks , , and  illustrate an exemplary model of a channel. In general, bus capable blocks can be used to model the behavior of any arbitrary channel.","Channel outport block  may be a model connector block that may receive the messages from switch  and provide the messages to the appropriate IPC read blocks. Channel outport block  may be implemented so that channel outport block  represents the aggregation of all messages being read from communication channel  by the connected IPC read blocks.","Using channel inport block  and channel outport block  to aggregate messages, as described above, can realize a number of advantages. For instance, communication channel  may model an ideal communication channel by ignoring duplicate labels at channel inport block  and channel outport block , and by directly connecting the channel inport block  to channel outport block . Additionally, as shown in , communication delay and data loss can be modeled for the channel by including delay blocks and switch blocks. Further, for a given model of communication channel , logical connectivity of IPC read and IPC write blocks (as indicated by their labels) may be verified by performing a search on the model of the communication channel and verifying that the signal paths that originate from a particular label at a channel inport block is routed to the same label at the channel outport block. GME  may derive the structure (e.g., during compilation of the block diagram) of a signal bus at channel inport block  and channel outport block  as a function of the IPC read and IPC write blocks that are attached to the channel.","The structure of the signal bus may contain an element for a signal being written to the channel. The element may have the same functional properties (e.g., sample time, dimensions, frame mode) as a corresponding signal that is being transmitted by an IPC write block associated with the channel. Consequently, using, for example, Simulink\u00ae bus expansion technology, blocks , , and , which are processing the signal bus, may also expand (e.g., for each a block, GME  may create a copy of the block for each element in the signal bus, where the copy may process an element of the signal bus, and may be compiled and interpreted to process the element with respect to the dimensions, sample time, and other functional properties of that element). Therefore, the model of the communication channel may not necessarily depend on the number of processing units and the number of IPC read and write blocks attached to the channel so that the channel may be reused in a different architectural model without changing its contents. Conversely, a communication channel may be replaced in a given architectural model with a different channel without changing the contents of the processing units that are connected to that channel. Further, existing bus signal logging technologies may be used to log data that is transmitted across the channel. Therefore, it may be possible to log and compute the dynamic behavior of the channel, such as the dynamic behavior of the channel described with terms such as bandwidth and congestion.","In some implementations, the channel signal sent over communication channel  may be implemented using either fixed or variable size signals. Variable size signals may be used, for example, to represent variable size messages. Additionally, the channel signal may be decorated to include timing information to indicate the times at which a message is delivered.","In time-based operation, a complete execution period of model  may include generating data at data source blocks (thereby producing the aggregate signal bus at the output of the channel inport ), generating a random number , processing each element of the signal bus by the delay , processing an element of the signal through the switch , and using the data at the data sink blocks. The IPC read, IPC write, channel inport and channel outport may be virtual blocks. That is, they may specify connectivity of functional blocks in the nodes to functional blocks in the channel. They would not typically be implemented during the execution of model . Instead, the actual deployed implementation of the channel would be used. Further, it is noted that the data source and data sink blocks may be arbitrary time based blocks, such as Simulink\u00ae blocks. Also, the delay and switch block that implement the channel behavior may be replaced by arbitrary time based blocks which are bus capable.","The operation of model  may also be described in a data flow based domain. A difference is that blocks may run when data is made available to them at their input ports. Consequently, execution of model  may include generating or receiving data at source blocks, generating a random number , processing each element of the data bus by the delay , processing an element of the signal through the switch , and using the data at the data sink blocks.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 11","FIG. 11"],"b":["120","1110","120"]},"The GME  may derive a first functionality of communication between the first logic and the second logic based on the channel, where the first logic is assigned to the first node and the second logic is assigned to the second node (block ). The first logic may be assigned from the first node to the third node and the GME  may derive a second functionality of communication based on the channel (block ).","For example,  are diagrams illustrating an exemplary model  of a multiprocessor system in which functionality of communication between nodes is derived. Referring to , model  may be provided by GME  (block ). Model  has three nodes , , and , and two functional blocks  and . A first functional block  is assigned to a first node  and a second functional block  is assigned to a second node . The nodes , , and  are connected via a channel  having a channel inport block , a delay block , and a channel outport block . In this instance, the GME  may derive a structure of a signal bus, which connects the two functional blocks  and  (block ). The signal bus may be derived according to (1) the label \u201cA\u201d specified in the IPC Read  and IPC Write  blocks and (2) properties of an IPC interface specified on the IPC Read  and IPC Write  blocks.","Referring now to , we may consider the same system  but with the first functional block  and the IPC write block  assigned to the third node . The GME  may derive the structure of the signal bus differently, which connects the two functional blocks  and , to be consistent with the label \u201cB\u201d specified in the IPC Read  and IPC Write  blocks (block ). Here, the signal bus may be derived according to one or more properties of an IPC interface specified on the IPC Read block  as present in processor  and an IPC interface specified on the IPC Write block  as present in processor . In both cases above, a delay amount or delay parameters, associated with delay block , and the structure of the signal bus, which connects functional blocks  and , may be derived from one or more properties of a node in which the assignment occurred and one or more properties of the IPC Read  and IPC Write  blocks.","In the discussion above, processor nodes , , , and  were described as connecting to a single communication channel over a single interface. In some implementations, a processor node may connect to multiple communication channels and specify multiple IPC ports labeled with unique identifiers. In this case, a tag on an IPC Reader or IPC Writer block may include multiple labels, such as a label of the form \u201cX.Y\u201d, where \u2018X\u2019 denotes an interface on the processor node and \u2018Y\u2019 denotes the message identifier as discussed above. Different interfaces for a processor node may correspond to different ports on the same communication channel or to different ports on different communication channels.","The IPC blocks described above may be provided to users of GME  as preconfigured blocks that provide the functionality described previously. In some implementations, users may be additionally given an option to customize the IPC blocks, for example, through an application programming interface (API). For example, through the API, users may be given an option to extend the functionality of the IPC blocks. It can be desirable to customize the behavior of IPC blocks for validation, simulation, and for code generation.","In an implementation, the API may be implemented through callback functions to GME . Code that implements customizable aspects of the IPC blocks can be code programmed in any number of programming languages, such as C, C++, M, Java. The API may be designed to represent two sets of callback functions that can be called by the modeling system, one for use during simulation and the other for generating code for deployment on a real-time target.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 13","b":["1300","1300","1310","1120","1330","1310","1320","1330","120"]},"Setup callback function  may be a function that is called by GME  at least each time the content of the callback function changes. In this callback, GME  may manipulate the run-time block object to add parameters to the represented block, which are parameters describing the characteristics of the IPC setup block. As shown in , setup callback function  is illustrated as calling a function named \u201caddDialogPrm\u201d method to register the \u201cMessagePriority\u201d' parameter and the \u201cMessageHeaderSize\u201d' parameter, which may describe the structure of a Controller Area Network (CAN) bus message. After a parameter is registered, the GME  may be later instructed, e.g., by a callback function, to display one or more user dialogs that allow the parameters to be viewed and\/or edited.","GME  may provide services to display parameters for a block, allow a user to specify a value for a parameter, and to evaluate and return the value of the parameter to other callbacks specified for the block. GME  may provide dialog boxes such as an \u201cedit box,\u201d a \u201ccombo box,\u201d and\/or a \u201ccheck box.\u201d For example, the call to function \u201caddDialogPrm\u201d in callback function  for the MessageHeaderSize parameter specifies that a \u201ccombo box\u201d should be displayed to the user for this parameter.","The CheckPrms callback function  may be a callback function designed to check and validate the parameters that are specified by the user of the GME and IPC blocks. In , CheckPrms callback function  is particularly illustrated as validating that the \u201cMessagePriority\u201d parameter was specified to be an integer larger than zero. The CheckPrms callback function may be invoked by the GME , for example, when a parameter value on the block is changed by a user, or when compiling the block diagram for execution, or during execution if the parameter value on the block is changed.","The DoPostProp callback function  may be a callback function configured to register work areas or data stores that may be shared amongst different IPC blocks. GME  may ensure that storage is provided during simulation and code generation for the specified vectors. GME  may also provide a way for other callbacks to access the work vectors for reading and writing through a run-time block object. In , the DoPostProp callback function  is particularly illustrated as registering a data store called \u201cHandle,\u201d which may represent a handle to a bus device driver. The DoPostProp callback function may be invoked by the GME , for example, while compiling the block diagram after having determined the input and output properties of a block such as the dimensions, sample times, or data types of the input and output ports of that block.","It can be appreciated that additional or alternate callback functions, other than the examples given above, may be added based on requirements and operational semantics of the modeling environment.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 14","FIG. 14"],"b":["1400","1400","120","120"]},"The callback functions shown in  may particularly include \u201cStart(blk)\u201d callback function , \u201cTerminate\u201d callback function , and \u201cOutputs(blk)\u201d callback function . Start callback function  may be a function that emits code which is to be executed at an initialization time of the real-time embedded code. In the example of , start callback function  is shown as a callback of an IPC setup block that initializes a device driver and stores an identity of the device driver in the \u201cHandle\u201d work vector. Terminate callback function  may be a function that emits code that handles a shutdown of a device driver. Outputs callback function  may be a callback function that emits code that is to be executed each time an IPC read block is invoked by the real-time system. As shown in , outputs callback function  receives and uses the \u201cMessagePriority\u201d and \u201cMessageHeaderSize\u201d parameters to select appropriate data from the device driver.","It can be appreciated that additional callback functions, other than the examples given above, may be added based on requirements and operational semantics of the modeling environment. The additional callback functions may be added based on the requirements and operational semantics of the block diagram modeling environment.","It should be noted that IPC blocks, such as described above, may support sub-classing. For example, if one were to design IPC blocks for a CAN interface, one can design the base CAN interface IPC blocks to have identical parameters on their user-interfaces. Semantic methods of the superclass associated with the IPC blocks may be overridden by one or more hardware-specific subclasses that may provide specialized implementations of those methods. This may allow hardware vendors to seamlessly tie into a GME, such as GME , with a custom implementation of a generic hardware interface.","An alternate approach to obtaining hardware specific subclasses of IPC blocks may involve using a block-based registration approach. Here, the IPC blocks may be implemented in the GME in a generic fashion to support simulation semantics in the GME. Hardware-specific code, which may be generated by the GME, may be implemented using an API that may be associated with a generic block in the GME. A hardware configuration set may be used to register a block with the GME during a registration phase.","For example, referring to , IPC read, IPC write, and IPC initialization blocks for a CAN interface for hardware provided by a vendor \u201cX\u201d may be implemented as three separate blocks using a standard block implementation API provided by the GME: CAN_READ , CAN_WRITE , and CAN_INIT , respectively. These blocks may be placed in a block library  and specified within the hardware configuration set .","Now suppose that a user wants to set up a model to generate code for a hardware target provided by vendor X that uses the CAN interface. Dialog box  in  associated with the model may be used to choose the target hardware for which the user wants to generate code. This dialog box displays and specifies various properties associated with the target configuration for the model based upon the hardware configuration set selected in box . Note that the hardware configuration set may be specified in other ways, such as via drop-down menus, commands, etc. The interfaces tab  may display a list  of various interfaces that are specified in the hardware configuration set. Note that this tab may also display editable interface-level properties for each interface.","Referring also to , the IPC read, IPC write, and IPC initialize blocks in the model may have an additional tab, on parameter dialog boxes associated with the blocks, to allow entry of parameters specific to the hardware target. For example, dialog box  may be a parameter dialog box for IPC Read block  (). The dialog box  may include a tab  that enables a user to specify various properties (e.g., hardware properties) of a CAN_READ  block that may be associated with the IPC Read block . In this example, a hardware (H\/W) port for the CAN_READ block may be specified using edit box .","After these parameters are configured, code specific to the hardware target of vendor X can be generated automatically from the GME. This may be accomplished in the GME by auto-inserting IPC blocks specific to target X, such as blocks , , and , in place of generic IPC blocks in the model and have them perform code generation roles that are encoded into their implementation. This approach may enable reuse of existing APIs for generic blocks in the GME.","Although the above description discussed techniques for implementing communicating interfaces over a channel for models that included separate functional and architectural models, in some implementations, an architectural model may not be necessary. More particularly, a functional model may be created that includes communication links between elements of the functional model. The communication links may be specified independently, such as by modeling the communication channel, as described above, of what is communicated over the communication links.","The foregoing description of implementations provides illustration and description, but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention.","For example, while a series of acts have been described with regard to , the order of the acts may be modified in other implementations. Further, non-dependent acts may be performed in parallel.","Also, the term \u201cuser\u201d has been used herein. The term \u201cuser\u201d is intended to be broadly interpreted to include, for example, a workstation or a user of a workstation.","It will be apparent that embodiments, as described herein, may be implemented in many different forms of software, firmware, wetware, and hardware in the implementations illustrated in the figures. The actual software code or specialized control hardware used to implement embodiments described herein is not limiting of the invention.","Further, certain portions of the invention may be implemented as \u201clogic\u201d that performs one or more functions. This logic may include hardware, such as an application specific integrated circuit or a field programmable gate array, software, or a combination of hardware and software.","It should be noted that one or more computer-readable media may store computer-executable instructions that when executed by a processing unit, such as processing unit , may perform various acts associated with one or more embodiments of the invention. The computer-readable media may be volatile or non-volatile and may include, for example, flash memories, removable disks, non-removable disks, and so on.","It should be further noted that various electromagnetic signals, such as wireless signals, electrical signals carried over a wire, optical signals carried over optical fiber, etc., may be encoded to carry computer-executable instructions, configured to implement one or more embodiments of the invention, on a network, such as, for example, network .","No element, act, or instruction used in the present application should be construed as critical or essential to the invention unless explicitly described as such. Also, as used herein, the article \u201ca\u201d is intended to include one or more items. Where only one item is intended, the term \u201cone\u201d or similar language is used. Further, the phrase \u201cbased on\u201d is intended to mean \u201cbased, at least in part, on\u201d unless explicitly stated otherwise."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate one or more implementations described herein and, together with the description, explain these implementations. In the drawings:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 12A-B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
