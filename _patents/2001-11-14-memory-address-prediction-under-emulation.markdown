---
title: Memory address prediction under emulation
abstract: Emulation of a guest computer architecture on a host system of another computer architecture. Legacy instructions are translated into translated instructions. If the particular legacy instruction is an operand-setting instruction for storing a value of a precedent operand, a corresponding flag is set when the value of the precedent operand has not been determined. If the particular legacy instruction is an operand-using instruction for using the precedent operand, a check is made to determine if the corresponding flag is set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07092869&OS=07092869&RS=07092869
owner: 
number: 07092869
owner_city: 
owner_country: 
publication_date: 20011114
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to computer systems and particularly to emulation of one computer architecture (the \u201cguest\u201d) via software on the hardware platform of another computer architecture (the \u201chost\u201d).","In typical computer architectures, computer source code is compiled\/assembled (at compile\/assembly time) into executable object code. The executable object code is executed at execution time on the hardware under control of the operating system. In order for computer source code written for a native architecture to run as a \u201cguest\u201d on a different architecture called a \u201chost\u201d architecture, the host architecture employs an emulator. The emulator emulates the native architecture while actually executing as a guest on the host architecture.","Various methods have been employed for emulating a guest computer architecture via software on the hardware platform of a host computer architecture. The categories of emulation are static emulation or dynamic emulation. In static emulation, the emulation is performed prior to run-time and in dynamic emulation, the emulation is performed at run-time.","One type of static emulation system employs object code translation. The native object code that is compiled\/assembled for a native system becomes the guest object code on a host system. The guest object code is translated in a manner that is similar to the way that original source code is compiled\/assembled into the object code for the native system. In the emulation case, however, rather than starting with the original source code, the emulation starts with the previously compiled\/assembled object code as prepared for the native system. The guest object code (the native object code on the host system) is passed through an emulator to form the translated object code. The translated object code is suitable for execution directly by the host system. Essentially, static emulation is a method of recompiling the native object code without using the original source code. The advantage of such static emulation is that the resulting translated object code can be optimized in much the same way that native object code is optimized when native object code is compiled\/assembled from original source code. Unfortunately, it is not always possible to glean all the necessary information statically from the native object code alone that was available when the original source code was compiled\/assembled from original source code.","Another method of static emulation is Application Programming Interface (API) mapping. This method of static emulation only applies to operating system code in which the API calls of the guest operating system are mapped to a host call or set of host calls that perform the equivalent function on the host system. The API mapping has a performance advantage since the host operating system software has been optimized for the host system. However, if the native and host systems are too dissimilar, then the desired mapping may not always be possible. Nevertheless, API mapping is a useful method for providing some degree of equivalent operating system functionality when used in conjunction with other forms of static or dynamic emulation.","Dynamic emulation is performed during run time. The main advantage of dynamic emulation is greater transparency to the user in that no pre-processing need be invoked by the user as is required for static emulation. A simple type of dynamic emulation uses an interpreter which fetches, parses, and decodes each guest instruction and responsively executes a routine to carry out the equivalent functions on the host system. The main disadvantage of an interpreter is one of low performance because of the significant overhead involved in processing every guest instruction each time it is executed. To mitigate the disadvantage of that overhead, a more advanced method of dynamic emulation sometimes called \u201cJIT\u201d (just-in-time) translation is employed.","In JIT dynamic emulation, the native object code is translated (similar to the static method), cached, and executed in piecemeal fashion, a small portion at a time. By translating only a small portion of guest object code that is likely to be executed next, the translation is performed in real time, essentially concurrently with the execution of the translated code. The translated code is cached (i.e. saved) to permit subsequent re-use without the need for re-translation. The initial translation overhead is therefore amortized over time, allowing the overall performance to approach that of static object code translation, especially within the most frequently used portions of the code. By using additional information regarding program behavior that can be gleaned at run-time, it is possible to optimize the translated code to obtain performance beyond that achievable with static translation alone.","Emulation frequently is used when a CISC architecture is emulated on a RISC architecture. A key difference between typical CISC and RISC architectures lies in the complexity of the memory access model that is supported. A defining characteristic of RISC architectures is the \u201cload\/store\u201d memory model in which the only memory access primitives provided are simple aligned loads, stores, and atomic updates. By way of distinction, CISC architectures, such as S\/390, support many more storage-referencing primitives of varying operand lengths with fewer restrictions on operand alignment. If the translated code resulting from translations from CISC architectures to RISC architectures fails to properly account for alignment variations existing in the CISC code, alignment faults occur upon execution of the translated code. The alignment fault processing during emulation is very costly in terms of wasted execution time.","One technique to guarantee avoidance of alignment faults is to use only 1-byte primitives so that proper byte boundary alignment always occurs for operands. Although using 1-byte primitives guarantees avoiding alignment faults in translated code, the use of only 1-byte primitives in translations is less efficient than necessary in most cases. The alternative, however, of always using larger primitives, such as 4-byte primitives, guarantees a large amount of wasted execution time required for processing alignment faults that necessarily occur with high frequency during execution of the translated code.","Some CISC instructions, such as the S\/390 LM instruction, use byte-aligned operands which can be predictably translated in advance without creating a byte alignment problem in the translated code. Other CISC instructions, such as the S\/390 MVC instruction, are unpredictable and use variable length operands which cannot be predictably translated in advance of execution of precedent instructions without creating a byte alignment problem in the translated code.","Instruction code for CISC architectures often employs indirect addressing where the actual address used for a particular CISC instruction is not determined until execution of a precedent CISC instruction executed just before that particular CISC instruction is executed. Translations of CISC instructions that occur before the execution of the precedent CISC instruction cannot know, for such CISC instructions, the byte size of the operands that result from execution of the precedent CISC instruction. Hence, the indirect addressing context used frequently in instruction code using CISC instructions presents the dilemma in connection with the translation of such CISC instructions of whether to use short primitives (such as 1-byte primitives) or long primitives (such as 4-byte primitives) in the translations of those CISC instructions. For such instructions, if short primitives are employed, then the translation is inefficient and if long primitives are employed, then execution of the translated code is inefficient. In either case the emulation is inefficient.","In order to take advantage of dynamic emulation, there is a need for improved dynamic emulators that help achieve the objectives of improved and more efficient computer system operation, particularly in the processing of variable length operands and other operations that create operand alignment problems.","The present invention is for emulation of a guest computer architecture on a host system of another computer architecture. The guest computer architecture has programs composed of legacy instructions. To perform the emulation of the legacy instructions on the host system, the legacy instructions are accessed in the host system.","Each particular legacy instruction is translated into one or more particular translated instructions for emulating the particular legacy instruction. If the particular legacy instruction is an operand-setting instruction for storing a value of a precedent operand, a corresponding flag is set when the value of the precedent operand has not been determined. If the particular legacy instruction is an operand-using instruction for using the precedent operand, a check is made to determine if the corresponding flag is set. If the corresponding flag is set, translation of the operand-using instruction is suspended and the one or more particular translated instructions corresponding to the operand-setting instruction are executed to determine the value of the precedent operand. Thereafter, the translation of the legacy instructions is resumed using the value of the precedent operand in the resumed translation. If the corresponding flag is not set, the translation of the operand-using instruction continues without suspension.","In one embodiment, the suspending of the translation inserts a resume_translation call into a stream of the translated instructions in place of translations of the operand-using instruction. The execution of the one or more particular translated instructions continues until the resume_translation call is reached and then the translation resumes by translating the operand-using instruction.","In one specific embodiment, the particular legacy instruction is an unpredictable operand-using instruction having unpredictable byte alignment, for example, because the unpredictable operand-using instruction uses operands of variable length. If the particular legacy instruction is a predictable operand-using instruction, the checking is bypassed and the translation continues, for example, where the predictable operand-using instruction employs fixed-length operands.","In a typical embodiment, the legacy instructions are for a legacy system having a S\/390 architecture and the legacy instructions are object code instructions compiled\/assembled for the S\/390 system and the translated instructions are for execution in a RISC architecture.","The foregoing and other objects, features and advantages of the invention will be apparent from the following detailed description in conjunction with the drawings.","In , a complex of computer systems , including computer systems -, -, . . . , -F, is presented where the target computer systems -, . . . , -F use translated code for emulating the native computer system -. The computer systems -, -, . . . , -F are shown in a complex, each receiving the same executable codes. Typically, each of the computer systems -, -, . . . , -F is a stand-alone system and not in the same complex. The computer systems -, -, . . . , -F are organized as having a operating systems -, -, . . . , -F, respectively, and having hardware systems -, -, . . . , -F, respectively. In , the host system , in a typical embodiment, is a stand-alone system which receives executable legacy code  as an input.","For the computer systems  of , source code , programmed in a convenient language, represents many application and other programs that collectively constitute a large investment in time and knowledge for owners of native computer systems. The native system - has available well-perfected compilers\/assemblers  for forming native executable code  (legacy code) that efficiently executes application and other programs on the native system -. For the computer systems -, . . . , -F, however, well-perfected compilers\/assemblers may not be available or, even if available, the source code  may not always be available. In order to help preserve the investment in the application and other programs of the native computer system, emulators are employed to execute the executable legacy code on one or more of the target computer systems -, . . . , -F. Typically, the target computer systems -, . . ., -F are new computer systems that have a different architecture. The objective is to preserve the investment in the application and other programs of the native architecture by enabling them to execute by emulation on the target computer systems.","In , the native executable code  is used directly in the computer system - according to the native architecture which includes a native operating system - and a native hardware system -. Also, the native executable code  is processed by the emulator - to produce translated code, TC, for execution by the target system - according to an architecture different from the native architecture and which includes an operating system - and a hardware system -. Similarly, the native executable code  is processed by the emulator -F to produce translated code, TC, for execution by the target system -F according to an architecture different from the native architecture and which includes an operating system -F and a hardware system -F.","In , further details of the host system  of  are shown. The group access unit  accesses legacy code (LC) and presents the legacy code in groups (LC) to a legacy code translator . The legacy code translator  stores detailed information about the translation in translation store  and flags the loading of a precedent operand for use by a subsequent dependent instruction by setting a translation flag corresponding to that precedent operand in register flag store . The legacy code translator  also stores the executable blocks of host code in a translated code (TC) cache . The translated code (TC) output from the cache  is executed in execution unit -F.","A typical example of a known emulation is illustrated in . In this example, legacy code is being translated to translated code where the legacy code is complex instruction set code (CISC) for a CISC architecture computer system and the translated code is reduced instruction set code (RISC) for a RISC architecture computer system. In the  example, the legacy code is for the S\/390 architecture. In the example, the code has been simplified for purposes of clarity of explanation. The same principles apply to translations from any given architecture to any other architecture.","In , a typical example of CISC legacy code consists of eight S\/390 instructions (with hexadecimal instruction byte addresses , , , C, , ,  and A) followed by 14 bytes of operand data (with hexadecimal byte addresses , , A) for a total of 44 bytes. The first step in the translation is to access the legacy code blocks. In the example, there are three 16-byte aligned blocks (a first block at addresses , , , C; a second block at addresses , , , A; and a third block at addresses , , A). Each CISC block is translated into a block of corresponding RISC code by translating each CISC instruction in a block in order. One or more RISC instructions are required to perform the equivalent function of each CISC instruction depending on the degree of complexity of each CISC instruction.","In the example of , the CISC instructions BALR, SRA, and AR each require only one RISC instruction, the CISC instructions AH and SH require three RISC instructions, and the CISC instructions LM and MVC require four RISC instructions. The third CISC block (with addresses , , A) consists solely of operand data and does not require translation. The blocks of RISC translated code emitted from the emulation are executed by the target computer system - of . A transfer routine is called at the end of each RISC block to locate the next block. At the end of the first block, XFER_SEQUENTIAL is called to look up the cache location of the RISC block corresponding to the next sequential CISC address ( in the example). The second block ends in a branch (BC), and therefore calls XFER_TARGET to perform the analogous look-up function for the CISC branch target address.","The  example includes S\/390 CISC instructions, including the LM instruction that uses fixed length operands which can be predictably translated without creating a byte alignment problem in the translated code. The  example also includes the MVC instruction that is unpredictable in its byte alignment since it uses variable length operands which cannot be predictably translated with respect to byte alignment in advance of execution of the precedent BALR instruction.","The  example represents instruction code of the type frequently occurring in CISC architectures for indirect addressing. The actual address used for the particular CISC instruction MVC is not determined until execution of the precedent operand-setting CISC instruction BALR. The precedent instruction BALR is executed before the operand-using dependent instruction MVC is executed. Translation of the MVC instruction presents the primitive size choice dilemma that frequently occurs in the translation of CISC code. The dilemma in  is whether in the translation to use short primitives (such as 1-byte primitives) or long primitives (such as 4-byte primitives) in the translation of MVC. Neither of these choices, however, results in efficient emulation.","In the  example, the second operand, DATA3, for the MVC fetch instruction is 4 bytes in length but is only aligned to a 2-byte boundary. If the target RISC architecture does not support unaligned references, then the LD4 primitive used in  to emulate the MVC fetch instruction will incur an alignment fault, and the costly overhead to process that alignment fault, during execution of the translated code. Although it might have been desirable in  to decompose the MVC fetch into two separate 2-byte aligned LD2 primitives, this decomposition is not done in the  example because the fetch address is a function of the contents of the base register B. The value in the B register has not been determined at the time of translation in the  example because the operand-setting precedent BALR instruction which loads B for subsequent operand-using dependent instructions has not yet executed.","In , an example of an embodiment of emulation is shown that, on a statistically significant basis, overcomes alignment faults and other execution phenomena in environments where instructions in RISC architectures have more limited capabilities than instructions in CISC architectures, particularly RISC instructions that have more limited alignment capabilities than the CISC instructions that they emulate.","In , the code example of  is modified to permit the code translation process to interact with the translated code execution process. The interaction reduces operand alignment problems and inefficiencies and as a result, improved and more efficient emulation is achieved. Specifically, the  example operates to execute translated operand-setting precedent instructions (such as BALR) that store operands in registers for use by subsequent operand-using dependent translated instructions (such as the translations of MVC). Each translation of a precedent CISC instruction, which has as its function the loading of a precedent operand for use by a subsequent dependent instruction, sets a translation flag corresponding to that precedent operand in register flag store . translation of subsequent translated instructions that depend on the precedent operand for efficient translation query the register flag store  to determine if the flag is set or not. If the flag is set, translation is suspended and execution is resumed until the precedent instruction is executed to produce the precedent operand and the untranslated dependent instruction is encountered. Thereafter all flags are cleared and translation of the dependent instruction and ensuing instruction stream continues.","In the example of , to record the dependency on register values of subsequent dependent instructions, a set of register-specific flags in flag store  are maintained by the translator  of . In operation all the flags are initialized to zero when translation begins. When an instruction (such as BALR) which modifies a particular register (such as the B register) is translated, then the flag for the particular register (B flag) is set in flag store . Subsequent instructions (such as LM, MVC) that use a particular register (the B register in this example) test the appropriate flag (B) to determine whether a dependency exists. In the example of , the next instruction after the operand-setting precedent instruction BALR is LM and LM does indeed depend on B. However, because LM operands are typically aligned so that the risk of an alignment fault is small, the LM instruction is a predictable precedent-using instruction that is automatically translated by translator  using the efficient LD primitives notwithstanding that the B flag is set. Because the LM instruction writes R and R, the corresponding R and R flags are set in flag store .","The MVC instruction is next and is an operand-using instruction that also depends on B. Because MVC operands are often unaligned, it is unwise to always use 4-byte aligned primitives automatically in translations of such instructions. Similarly, it is unwise always to use 1-byte primitives, the only ones guaranteed never to fault, because such uses result in translations that are less efficient statistically in most cases. Rather, because the MVC instruction is an unpredictable operand-using instruction, the  example temporarily suspends translation and saves the essential context of the translation. Instead of emitting the MVC translation after the BALR and LM translations have been emitted, translation of MVC is suspended and a RESUME_TRANSLATION call routine is emitted instead. Translation remains suspended while execution of the translated code (MOV) for the BALR instruction and execution of the translated code (ADD, LD, ADD, LD) for the LM instruction occur. After the LM instruction translated code execution, the execution stream reaches the RESUME_TRANSLATION call which operates to restore the translation context and resumes the translation at the MVC instruction (using the now known value of B). The MVC translation is emitted based on the value of B loaded by the BALR instruction and overwrites the RESUME_TRANSLATION call that was emitted earlier at the time of suspending translation. In the translation, the current contents of B are used to calculate the value of the DATA and DATA memory addresses. These operations reveal that DATA is 4-byte aligned, but DATA is only 2-byte aligned. The translator  of  therefore emits the non-faulting LD sequence as shown for DATA while using the more efficient ST sequence for DATA. In summary, the translated code for MVC uses the most efficient primitives (2-byte aligned and 4-byte aligned) which do not cause an alignment fault during execution of the translated code assuming, with high probability, that the value of B used is correct.","After translation of MVC, the translation in  then proceeds as in  commencing with the AH instruction.","In the  example, the possibility of a fault has not been entirely eliminated since the value of B used is the value determined for the current path through the code shown in . In the unlikely event that some other code were to load a different value in B and then branch directly to BASE, for example, a fault in the execution of the translated code of  could still occur. The  embodiment uses memory address prediction in that it predicts that the current value of B is likely to be the correct value of B even though, in general, the future value of an indirect memory address cannot always be guaranteed with certainty. The prediction is good in a vast majority of instances so that on a statistical basis efficient translation occurs. Similarly, for the LM instruction, the  embodiment statistically, with high reliability, predicts the byte alignment of the LM operands. The predictions of the types described used for each CISC instruction are stored in the translator  and are used as part of the translation process.","While the invention has been particularly shown and described with reference to preferred embodiments thereof it will be understood by those skilled in the art that various changes in form and details maybe made therein without departing from the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 1","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
