---
title: Distributed environment type computer system able to achieve high speed consecutive message communications by service layer
abstract: A distributed environment type computer system enabling a service layer to execute consecutive message communications at a high speed provided with a message transferring unit, a service layer for providing a specific additional service to an application, a policy manager for supplying a policy, a communication layer for transferring messages, an analyzing unit for extracting from a message the parameters describing the message, while dividing the parameters into static parameters and dynamic parameters, and a requesting unit for requesting the policy manager to acquire a group of policies allocated to the static parameters using the static parameters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07051107&OS=07051107&RS=07051107
owner: Fujitsu Limited
number: 07051107
owner_city: Kawasaki
owner_country: JP
publication_date: 20020205
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to a plurality of computer systems for transferring messages in accordance with application software under a distributed environment, more particularly relates to a service layer built into a computer system and providing additional service in accordance with a certain policy and to a policy manager centrally managing the above policies in cooperation with a service layer.","2. Description of the Related Art","The recent growth of computer networks has led to the extensive transfer of information among a number of distributed computer systems based on application software. This environment is generally called a \u201cdistributed environment.\u201d","Such a distributed environment is generally realized by separate application software for providing general functions and communication layers for generally providing functions relating to communications. Here, a \u201ccommunication layer\u201d includes physical communication functions, that is, communication channels or communication networks, communication protocols defining these physical communication functions as communication procedures, operating systems (OS) or application programming interfaces (API) for providing communication protocols to the application software, distributed platform layers (DPL) incorporating advanced communication functions or communication support functions, etc. As a typical example of a DPL, so-called \u201ccommon object request broker architecture\u201d (CORBA) providing more extensive communication functions than the operating systems may be mentioned.","As will be explained later in detail with reference to the drawings, there are the following four problems in the related art.","In certain types of modes of use of distributed environments, sometimes the applications transfer large numbers of different types of messages in a short time. For example, a remote control application realized using the above CORBA (i) sends a request inquiring about the internal status of another application, (ii) sends a request for processing, (iii) sends a request for inquiry once again, and (iv) sends another request for processing, that is, sometimes a large number of different requests are asked to be made within a short time.","In such a case, with a first system configuration ( and  explained later), each time there is a request, a so-called \u201ccache misshit\u201d occurs where a suitable policy cannot be acquired from a policy cache function unit and excess time ends up being spent for acquiring the policy from the policy manager. In this way, despite the presence of a cache mechanism, there is a first problem that this cache misshit makes efficient operation impossible.","On the other hand, faced with such a cache misshit, a cache in a general computer system, for example, fetches and caches certain corresponding areas in the memory consecutively. Due to this, cache misshits in consecutive memory access are prevented. This is general practice. In the case of the above policy cache, however, often the group of required policies are not consecutive. Therefore, the above general cache could not exhibit its inherent effectiveness. In other words, in the above case, there was the second problem that the policies had to be acquired based on a suitable strategy predicting the required policies.","Further, in a second system configuration (FIG.  and  explained later), even if policies were suitably cached, the service layer had to negotiate with the service layer of the other party in the communication for each policy. Therefore, there was the third problem that communication time and processing time were required for the negotiations and excess time ended up being spent.","Further, in the second system configuration, the negotiation over policy between the policy managers was completed in advance and the negotiations between the service layers during the communications were eliminated, but no means have been realized for guaranteeing the reliability of the completion of the advance negotiations. Therefore, the service layers cannot prevent the occurrence of mismatches of policies due to illegitimate actions or human error in settings at the policy managers or mismatches of policies due to errors in transmission of policies arising due to communication errors.","Further, in the above second system configuration, there was the fourth problem that, in the above type of mode of use, excess time is taken in the communication of messages and the reliability of the negotiations over policies performed between two service layers cannot be guaranteed. This was disadvantageous to the user.","An object of the present invention is to provide a computer system able to greatly reduce the processing which a service layer performs for each message communication for inquiring about a policy to a policy manager or able to eliminate the processing for negotiations relating to application of a policy performed with the service layer of another party and therefore enabling a service layer to execute consecutive message communications at a high speed.","Another object of the present invention is to provide a service layer, policy cache function unit, and policy manager for such a computer system.","To attain the above object, the computer system according to the present invention is configured as follows, that is, is comprised of a message sending\/receiving means (), a service layer () for providing a specific additional service to an application (), a policy manager for supplying a policy, a communication layer for transferring a message, an analyzing means () for extracting from a message parameters describing the message divided into static parameters () and dynamic parameters (), and a requesting means () for requesting the policy manager () to acquire a group of policies allocated to the static parameters. Due to this, a distributed environment type computer system is provided enabling a service layer to execute consecutive message communications at a high speed.","Before describing the preferred embodiments, the related art and the disadvantages therein will be explained in further detail with reference to the drawings for background purposes.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 12","FIG. 13"]},"First, the distributed environment type computer system shown in  and  will be explained in brief.","In the distributed environment explained above, the system configuration of  and  is characterized by the introduction of service layers (, ) providing additional services not realizable by the communication layers between the communication layers (, ) and the application software (, ).","The service layers are independent from the communication layers and the application software and provide additional services. Due to this, it is possible to eliminate the trouble of developing application software while maintaining the general applicability of both the communication layers and application software. In this respect, the service layers are advantageous. Note that as a known example of such a service layer, there is a CORBA security service disclosed in the following Reference 1:","Reference 1: Object Management Group (OMG), CORBA Services: Security Service Specification, Version 1.7, December 1999 (available from (http:\/\/www.omg.org\/technology\/documents\/formal\/security-service.htm)","Further, the security service layers shown in  and  are disclosed in the following Reference 2, Reference 2\u2032, Reference 2\u2033, and Reference 3.","Reference 2: Institute of Electronics, Information, and Communications Engineers, Ninth Telecommunications Management (TM) Research Conference (preprints distributed on May 18, 2000) (related materials available from http:\/\/www.ieice.or.jp\/cs\/tm\/jpn\/tmken\/tm-9.html)","Reference 2\u2032: International Conference APNOMS2000 (draft copy presented May 26, 2000, camera ready copy presented on August 25, and preprints distributed October 11) (related materials available from http:\/\/www.ieice.or.jp\/cs\/tm\/apnoms\/2000\/)","Reference 2\u2033: German Patent Application No. 10024347.9 (filed May 17, 2000)","[Note: References 2, 2\u2032, and 2\u2033, are substantially the same in content]","Reference 3: Japanese Patent Application No. 2001-55323 \u201cCommunication Security Management System and Program of Same\u201d (filed Feb. 28, 2001)","In general, in a distributed environment, the service function portion comprising the service layers (, ) is distributed along with the distributed application software. Therefore, the above service function portion is instructed on the method of operation from the outside. By managing the content of the instructions all together at one location for each management area (one unit of group of computer systems to be managed), it is possible to eliminate the trouble of managing the methods of operation all over the place and possible to improve the system efficiency. The content of an instruction on the method of operation is called a \u201cpolicy\u201d. The above references disclose to manage the service layers by such policies.","More specifically, References 2, 2\u2032, and 2\u2033 describe frameworks for negotiating with other parties in communication to determine the policies for use in the service layers (, ). Further, Reference 3 describes a framework for negotiating a policy in advance so as not to cause a difference with the other party in communication in policy managers (, ).","Here, refer to  and .","As illustrated in these figures, a distributed environment type computer system can be roughly divided into applications (application software)  and , service layers  and , communication layers  and , and policy managers  and .","The applications  and  are application software for message communications using the communication layers  and  and use the message sending\/receiving means  and  for communication.","The service layers  and  are present between the applications  and  and the communication layers  and  and provide additional services not provided by the communication layers  and  in place of the applications. The service layers  and  are comprised of analyzing means  and , requesting means  and , and controlling means  and . The requesting means  and  are provided with policy acquisition function units  and  and negotiation function units  and .","On the other hand, the policy managers  and  are provided with policy memory areas  and , response function units  and , and advance negotiation function units  and .","The computer system shown in  and  is constructed based on the above References 2, 2\u2032, 2\u2033, and 3. The computer system can be used in actual practice, but has the disadvantage that the processing time and the communication time by which the service layers  and  acquire a policy end up becoming long. Therefore, the present assignee devised the computer system shown in  and .",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 14","FIG. 15"]},"As shown in these figures, the distributed environment type computer system upon which the present invention is predicated comprises the system configuration shown in  and  plus the policy cache function units  and .","If using a temporary memory area broadly in use in computer systems or communication systems, that is, a cache framework, in this way, the processing time and the communication time, etc. when acquiring a policy, can be shortened and the operation of the service layers  and  can be made much higher in speed.","If actually trying to run the computer system shown in  and , however, it is found that new disadvantages end up arising (explained later). A fully practical computer system has not yet been developed. That is, further improvements are necessary. The present invention makes such improvements (explained later).","Here, the operation of the system shown in  and  will be simply explained.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 16","FIG. 17","FIG. 14","FIG. 15"]},"Note that the distributed environment type computer system handled by the present invention covers a plurality of computer systems, but for simplification, only two computer systems are illustrated. Further, these two computer systems perform substantially the same processing, so the computer system handling application  ( and ) is explained as a representative example. The computer system handling application  ( and ) will be simply referred to as the computer system of the \u201cother party\u201d or the application of the \u201cother party\u201d.","Referring to  and , when the application  sends a message to the application  using the message sending\/receiving means  (S), the analyzing means  of the service layer  analyzes the message using a parameter acquisition function unit  and extracts from it the parameters necessary for controlling the services (S).","The extracted parameters are transferred to the requesting means . The requesting means  acquires the policy corresponding to the parameters by retrieving that policy from a group of policies cached in a policy cache function unit  (S). If there is no such policy, it inquires at the policy manager  (NO at S, S).","When obtaining a policy from the policy manager  (YES at S), the means stores that policy in the policy cache function unit  (S). If no policy can be obtained (NO at S), the routine proceeds to step S.","Next, the means negotiates with the requesting means  of the other party in the communication using the negotiation function unit  as to whether the obtained policy may be used to control the service (S). If the negotiations succeed (YES at S), the policy is transferred to the controlling means . The controlling means  controls the service as instructed by the policy (S). The message is communicated through the communication layers  and  under this control. The message sending\/receiving means  of the application  of the other party can then receive that message (S).","In this case, to reduce the chances for failure in negotiations, the policy manager  and the policy manager  of the other party may negotiate in advance using advance negotiation function units  and  to match policies to be sent back from the response function units  and .","As explained earlier, in certain types of modes of use of distributed environments, sometimes the applications transfer large numbers of different types of messages in a short time. For example, a remote control application realized using the above CORBA (i) sends a request for inquiring about the internal status of another application, (ii) sends a request for processing, (iii) sends a request for inquiry once again, and (iv) sends another request for processing, that is, sometimes a large number of different requests are asked to be made within a short time.","In such a case, in the system configuration of  and , each time there is a new request (aforementioned various requests), a so-called \u201ccache misshit\u201d occurs where a suitable policy cannot be acquired from the policy cache function unit  () and excess time ends up being spent for acquiring a policy from the policy manager  (). In this way, despite the presence of a cache mechanism, there is above-mentioned first problem that this cache misshit makes efficient operation impossible.","On the other hand, faced with such a cache misshit, a cache in a general computer system, for example, fetches and caches certain corresponding areas in the memory consecutively. Due to this, cache misshits in consecutive memory access are prevented. This is general practice. In the case of the above policy cache, however, often the group of required policies are not consecutive. Therefore, the above general cache could not exhibit its inherent effectiveness. In other words, in the above case, there was the above second problem that the policies had to be acquired based on a suitable strategy predicting the required policies.","Further, in a system configuration of  and , even if policies were suitably cached, the service layer  had to negotiate with the service layer  of the other party in the communication for each policy. Therefore, there was the above third problem that communication time and processing time were required for the negotiations and excess time ended up being spent.","Further, in the system configuration of  and , the negotiation over policy between the policy managers  and  was completed in advance and the negotiations between the service layers  and  during the communications were eliminated, but no means have been realized for guaranteeing the reliability of the completion of the advance negotiations. Therefore, the service layers  () cannot prevent the occurrence of mismatches of policies due to illegitimate actions or human error in settings at the policy managers  () or mismatches of policies due to errors in transmission of policies arising due to communication errors.","Further, in the system configuration of  and , there was the above fourth problem that, in the above type of mode of use, excess time is taken in the communication of messages and the reliability of the negotiations over policies performed between two service layers cannot be guaranteed. This was disadvantageous to the user.","The present invention was made in consideration of the above problems and provides a computer system able to greatly reduce the processing which the service layer  performs for each message communication for inquiring about a policy to the policy manager  or able to eliminate the processing for negotiations relating to application of a policy performed with the service layer  of another party and therefore enabling a service layer  to execute consecutive message communications at a high speed.","Further, the present invention provides a service layer, policy cache function unit, and policy manager for such a computer system. The present invention will be described in detail below.","In the present invention, policies are cached by the technique of, first, dividing the parameters handled in the service layer  into \u201cstatic parameters\u201d and \u201cdynamic parameters\u201d. \u201cStatic parameters\u201d are parameters which do not change over a relatively long period, while \u201cdynamic parameters\u201d are parameters which change over a relatively short period.","Second, to display whether a policy cached at the policy cache function unit  has finished being negotiated or not, the function unit  is given a \u201cnegotiation completion flag\u201d.","Third, to enable the service layer  to acquire a plurality of policies all together from the policy manager , use is made of a \u201cpolicy cluster\u201d comprised of a set of a plurality of policies and allocation rules for allocating the policies to the parameters.","Fourth, to display the fact that the policy cluster as a whole generated by the policy manager  has finished being negotiated in advance with the policy manager  of the other party, the policy cluster is given a \u201cnegotiation completion tag\u201d. This negotiation completion tag has a value agreed upon between the plurality of policy managers (, ).","Fifth, to guarantee the fact that the policy cluster as a whole has finished being negotiated, the policy cluster is given \u201csignature information\u201d.","According to the computer system of the present invention employing the above first to fifth techniques, the following effects are obtained:","a) It is possible to strategically cache a group of policies required in a certain period by static parameters which do not change over a long period. Therefore, the frequency of cache misshits falls and the time required for communicating messages can be shortened.","b) Further, by marking already negotiated policies by negotiation completion flags in the policy cache function unit , it is possible to eliminate negotiations to be performed the second and later times and possible to further shorten the time required for message communications.","c) Further, by using the policy cluster, it is possible to acquire a group of policies and allocation rules of the parameters of the policies all together. Further, the fact that the policy cluster as a whole has finished being negotiated can be easily confirmed by the service layer  by one negotiation. Further, by having the signature information in the policy cluster verified by the service layer , it is possible to detect an illegitimate policy cluster or the occurrence of human error, communication error, etc. and possible to further improve the reliability.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 1","FIG. 2"]},"Note that throughout the figures, similar constituent elements are assigned the same reference numerals or symbols.","The computer system () handling the application  among the two computer systems illustrated will be explained below as a representative case.","The computer system shown in  is basically similar to the computer system shown in  and .","That is, the computer system is provided with a message sending\/receiving means  for transferring a series of messages based on an application , a service layer  for providing a specific additional service to the application  in accordance with a policy of specific control or instructions to each message, a policy manager  for holding and centrally managing various policies and supplying a policy corresponding to a message in accordance with a request for acquisition from the service layer , and a communication layer  for transferring messages given the service by the service layer  in accordance with the policy with the application  of the other party.","In this computer system, one feature of the present invention is the analyzing means  and requesting means  in the service layer .","The analyzing means  extracts the parameters described in a message for specifying the message, while dividing it into static parameters not changing over a relatively long period and dynamic parameters changing over a relatively short period.","The requesting means  requests the acquisition of a group of policies allocated to static parameters from the policy manager  using the extracted static parameters.","The policy manager  receives a request for acquisition of a group of policies using the static policies from the requesting means  in this way has a response function unit  for generating a policy cluster and returning it to the requesting means  when receiving the request. Here, the policy cluster is comprised of at least a group of policies corresponding to overall parameters comprised of the static parameters and various changing dynamic parameters and policy allocation rules indicating the allocations of the group of policies corresponding to the overall parameters (see  and ).","The requesting means  for acquiring a policy cluster returned from the response function unit  in this way is provided with a policy cache function unit (). The policy cache function unit  temporarily stores in a readable manner the above policy cluster returned from the policy manager . After the start of the transfer of a message, when a policy cluster allocated to the overall parameters sent is stored in the policy cache function unit , the corresponding policy is acquired from there.","The policy cache function unit  is provided with a negotiation completion flag area (see ). A negotiation completion flag is a flag displaying that agreement has been reached when the service layer  of the other party supporting the application  of the other party is negotiated with in advance and agreement has been reached on the policy to be used between the two.","As another one related to the above negotiation completion flag, a negotiation completion tag (see ) is used. That is, the policy manager  negotiates in advance with the policy manager  of the other party supporting the application  of the other party and, when agreement is reached between the two on the policy to be used, records a negotiation completion tag displaying that agreement has been reached in the policy cluster. Further, the policy manager  has a signature function unit  generating a signature (see ) guaranteeing that the content of the policy cluster is legitimate.","Related to the negotiation completion flag is the negotiation function unit . That is, the requesting means  has a negotiation function unit  which uses the negotiation completion tag displayed in a policy cluster to confirm the legitimacy of the negotiation completion tag in advance with the service layer  of the other party when acquiring a policy cluster from the policy manager . Here, the negotiation function unit  negotiates for the plurality of policies included in the policy cluster all together.","The requesting means  has a signature verification function unit  provided corresponding to the above signature function unit  for verifying that the signature displayed in the policy cluster is legitimate when acquiring a policy cluster from the policy manager .","To further improve the understanding of the above computer system, the above-mentioned \u201cparameters\u201d, \u201cpolicy clusters\u201d, and \u201cpolicy cache function unit\u201d will be explained below in detail.","[Parameters]","The present invention assumes that the parameters are comprised of a plurality of items and assumes that these are valid in most cases.","In most modes of use, only part of the parameters for acquiring a policy change over a short period. Taking as an example the above CORBA, in the application  of the other party in the communication, the class name called (or the interface name), the method name called (or the operation name), the argument list given, etc. change remarkably in a relatively short period.","As opposed to this, the names (identifiers) of the two hosts communicating with each other and also the name of the user using the application, etc. do not change over a relatively long period. This will be explained with reference to .",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 3"},"As shown in the figure, the parameters (overall parameters)  are classified into static parameters  comprised of items not easily changing over a long period and dynamic parameters  comprised of items easily changing over a short period. In other words, items which cannot be determined until the service layer  actually receives the message may be defined as dynamic parameters, while items which the service layer can determine before receiving the message may be defined as static parameters.","The dynamic parameters  are extracted by the analyzing means  from the messages by the dynamic parameter analyzing function unit .","On the other hand, the static parameters  are extracted by the static parameter analyzing function unit  provided in the analyzing means . The static parameters  do not change over the long term, so it is possible to delimit part (or all) of the group of policies required when the static parameters  are fixed and only the dynamic parameters  change among the overall parameters .","[Policy Cluster]","When transferring a specific group of policies from the policy manager  () to the service layer  (), it is desirable to transfer a plurality of groups of policies all together. Therefore, allocation rules for determining which policy should be used in which case (that is, at what value of a dynamic parameter) are also transferred for such groups of policies. The present invention introduces the above-mentioned policy cluster combining these.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":["FIG. 4","FIG. 5"]},"The policy cluster generated by the policy manager  includes a policy list , a policy allocation rule list , a negotiation completion tag , and other auxiliary information (in the illustrated example, the issuer information ), and information on a digital signature  given to the same. Note that a digital signature is prepared from certain data by a certain type of arithmetic operation and is a cryptographic technique enabling verification of the integrity of the content or source of the data. One using the RSA (Rivest, Shamir, and Adleman) calculation algorithm is widely known.","In the example of , the issuer name  may be any information, but in the case of showing the source by the signature , it is a name or identifier indicating the party giving the signature.","The negotiation completion tag  may also be any information, but the method of determination of the value will be explained later.","Next, the list of the policy allocation rules  lists the allocation rules for policies for parameters (overall parameters) comprised of sets of the values of the parameters and the policy names. Note that in the case of a policy cluster acquired by static parameters, the values of the parameters usually are held by all of the same designated static parameter portions.","The policy list  lists the policies indicated in the list of the policy allocation rules .","The signature  is a digital signature given to all data of a policy cluster other than the section on the signature  by a predetermined signature method.","[Policy Cache Function Unit]",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 6","FIG. 7"]},"A group of policies (also sometimes a single policy) acquired by the service layer  () all together in the form of a policy cluster ( and ) can be temporarily stored in the policy cache function unit  () through a suitable process.","The policy cache function unit  is comprised of a cache memory  for storing policies, a policy cache table  for recording the memory addresses of the policies, and a cache control unit  for writing, reading, retrieving, etc. data using the memory or table.","The policy cache function unit  is characterized by the facts that:\n\n","Note that in the example of , both of the cache tables  and  are given information on the cache expiration dates  and . This information however is added only when necessary.","Here, the characterizing configurations of the service layer  (), cache function unit  (), and policy manager  () will be described all together and finally the flow of processing of the computer system as a whole shown in  and  will be explained with reference to  to .","[Service Layer]","First, looking at the service layer , the service layer provides a specific additional service in accordance with a policy to a series of messages transferred based on the application  while contacting an outside policy manager . The service layer  has an analyzing means  for extracting from a message, for specifying the same, the parameters described in the message, while dividing it into static parameters  not changing over a relatively long period and dynamic parameters  changing over a relatively short period and a requesting means  for requesting from the policy manager  the acquisition of the group of policies allocated to the static parameters  by using the extracted static parameters .","Further, the service layer has a controlling means  for executing an additional service in accordance with a policy.","Further, the above analyzing means  is comprised of a static parameter analyzing function unit  for extracting static parameters  and a dynamic parameter analyzing function unit  for extracting dynamic parameters .","On the other hand, the requesting means  has a policy acquisition function unit  for acquiring a group of policies allocated from the policy manager  for the static parameters  using the static parameters  described in a message sent to the application  of the other party.","Further, the requesting means  has a policy cache function unit  for temporarily storing in a readable manner the group of policies acquired from the policy acquisition function unit .","Further, the requesting means  has a negotiation function unit  for negotiating for agreement between the two parties (, ) regarding the policy to be used with the service layer  of the other party supporting the application  of the other party for each policy of the group of policies acquired from the policy manager  or the policy cache function unit .","Further, the requesting means  has a signature verification function unit  for verifying if a signature  described for a group of policies acquired from the policy manager  or from the policy cache function unit  is legitimate.","[Policy Cache Function Unit]","Next, looking at the policy cache function unit , the policy cache function unit is provided in the service layer  providing a specific additional service in accordance with a policy to a series of messages transferred based on an application while contacting an external policy manager . The policy cache function unit  has a cache memory  for acquiring from the policy manager  and temporarily storing one or more policies for specific control or instructions to the messages, a policy cache table  for recording memory addresses in the cache memory  storing the policies in correspondence with the policies, and an allocation rule cache table  for establishing allocation rules of policies for the parameters described in the messages so as to specify the messages.","The allocation rule cache table  negotiates in advance with the service layer  supporting the application  of the other party transferring the message and includes an area of a negotiation completion flag  for displaying that agreement has been reached on a policy recorded in the allocation rule cache table  when agreement is reached on the policies to be used between the two (, ).","[Policy Manager]","Finally, if looking at the policy manager , it contacts the service layer  providing a specific additional service for a series of messages transferred based on the application  and supplies to this service layer  one or more policies for specific control or instructions to the messages. The policy manager  has a response function unit  for generating a policy cluster ( and ) and returning it to the service layer  when acquisition of a policy is requested by the service layer  by static parameters  among parameters described in the message for specifying the message classified into static parameters  not changing over a relatively long period and dynamic parameters  changing over a relatively short time. Here, a policy cluster is comprised of at least a group of policies corresponding to the overall parameters () comprised of static parameters  and various changing dynamic parameters  and policy allocation rules  showing the allocation of each of the group of policies with respect to each of the overall parameters.","On the other hand, the policy manager  has an advance negotiation function unit  which negotiates in advance with the policy manager  of the other party supporting the application  of the other party transferring the message and generates a negotiation completion tag  for recording the fact of agreement when the two (, ) reach agreement on the policy to be used in the policy cluster ( and ) and preferably has a signature function unit  for generating a signature  for guaranteeing that the content of the policy cluster is legitimate.","Finally, the flow of the processing of the computer system as a whole according to the present invention shown in  and  will be explained with reference to flow charts.",{"@attributes":{"id":"p-0138","num":"0139"},"figref":["FIG. 8","FIG. 9","FIG. 10","FIG. 11"]},"First, an explanation will be given with reference to  and .","According to the flow chart shown in above-mentioned  and , the service layer  starts operating from the time when the message sending\/receiving means  of the application  sends a message. It communicates the message after analyzing the message, acquiring the policy, and executing control by the policy cache and policy.","As opposed to this, the processing according to the present invention is divided into the operation for acquiring the policy cluster in advance and the operation for acquiring a policy at the time of message communications.","[Advance Acquisition of Policy Cluster]",{"@attributes":{"id":"p-0143","num":"0144"},"figref":["FIG. 8","FIG. 9"],"b":["1","1","1"]},"When the processing is started on such an occasion, the service layer  extracts static parameters  by the static parameter analyzing function unit  of the analyzing means  (S). The method by which the static parameter analyzing function unit extracts the static parameters (for example, the host name, user name, etc.) depends on the type of the static parameters used and the type of mounting. For example, inquiring at the hardware, inquiring at the operating system or other software, acquisition from the environmental variables, inquiring at the application, and other methods may be mentioned. The thus obtained static parameters can for example be stored by the analyzing means  until the parameters are erased or overwritten by a suitable occasion or means. In this case, after this, the means can automatically link the static parameters and dynamic parameters to form single overall parameters  each time dynamic parameters  are extracted.","Using the thus obtained static parameters , the requesting means  uses the policy acquisition function unit  to inquire about a suitable policy cluster at the policy manager  (S). The policy manager  sends back the policy cluster ( and ) including part (or all) of the group of policies corresponding to the static parameters . The policy cluster may be generated after receiving an inquiry from the function unit , but it is preferable to prepare and hold it in advance. This is particularly the case when using a negotiation completion tag  ( and ). Note that the generation of a policy cluster will be explained in detail later.","When the service layer  obtains a policy cluster (YES at S), it can verify the signature  and negotiate for the policy cluster in a block. At this time, however, it judges if there is a signature  in the policy cluster (S) and then temporarily stores the group of policies of the policy list  comprising the policy clusters and the policy allocation rules  in the policy cache function unit .","The signature  is verified by the signature verification function unit  of the requesting means  (S). In the case of the above-mentioned RSA computation algorithm, it uses the public key of the issuer (signer)  of the policy cluster to confirm that the policy cluster has indeed been prepared by the issuer and, if prepared, if it has been altered. If the signature is illegitimate (NO at S), error processing for the case of an illegitimate signature is performed (S).","As an example of this error processing, reporting to the user, recording in a log, stopping the operation of the service layer  and application , ignoring the signature in the same way as when there is no signature, etc. may be considered.","The block negotiation of the policy cluster is performed by the negotiation function unit  of the requesting means . If the policy cluster has a negotiation completion tag  and that tag  is used, the negotiation function unit  contacts the negotiation function unit  of the service layer  of the other party in the communication and confirms if the negotiation completion tag  is legitimate or matches etc. If the tag is not legitimate, the entire policy cluster is deemed to have finished being negotiated. On the other hand, if a negotiation completion tag  is not used, the negotiation function unit  checks all (or part) of the policy allocation rules  included in the policy cluster with the negotiation function unit  of the service layer  of the other party in the communication. If the rules  match at both, it is deemed that negotiations have been completed (S).","Note that while not shown, the requesting means  of the other party in communication receiving the negotiations also uses a suitable means to acquire the policy cluster. As the method, it is possible to extract the static parameters by the above method in advance and use the static parameters to acquire a policy cluster from the policy manager . Further, the negotiation function units (, ) can exchange parts of the parameters to make up for insufficient information.","Next, the requesting means  disassembles the policy cluster and stores it in the policy cache function unit  (same for requesting means  of other party in communications) (S). That is, it takes out the designated policy in accordance with the individual policy allocation rules  and stores it in the cache memory  while correctly recording it in the cache table  ().","At this time, when it is deemed that the policy has finished being negotiated, a negotiation completion flag  is set in the corresponding allocation rule cache table  ( and ) (in the example of , the flag  is made YES).","[Advance Generation of Policy Cluster and Advance Negotiations]","As already explained, a policy cluster can be generated and negotiated in advance. To generate a policy cluster for a value of a certain static parameter , the policy manager  pulls out all or part of the group of rules corresponding to the static parameter value from the group of policy allocation rules (not shown) and stores the group of rules and policies which the group of rules allocate in the policy cluster. It is also possible to add auxiliary information (for example, the name of the issuer) or negotiation completion flag to this. If giving a signature, finally the signature is given to the policies and the auxiliary information as a whole.","The negotiation completion flag may be any information and gives a value not contradictory with the other policy manager with which the negotiations have been completed. \u201cNot contradictory\u201d means simply that the values be made the same, but it is desirable to select values which will not allow collisions to easily occur. For example, the method may be mentioned of using a serial number or date at the first half of the negotiation tag and using a random number in the second half to connect the two (see T of ).","Further, while the values are different, it is also possible to use a digital signature or other cryptographic technique to give a value which is trustworthy and not able to be forged. Naturally, the method of block negotiation of the policy cluster by the negotiation function units of the service layers  and  is determined by the method of generation of the policy cluster.","[Time of Message Communications]",{"@attributes":{"id":"p-0158","num":"0159"},"figref":["FIG. 10","FIG. 11"]},"The message sending\/receiving means  of the application  sends the message (S). When the service layer  receives the message, the analyzing means  of the service layer  uses the dynamic parameter analyzing function unit  to analyze the received message and extract the dynamic parameters  (S). For example, in the case of the above-mentioned CORBA, the class name, method name, argument list, etc. to be called up are obtained as dynamic parameters. The dynamic parameters are combined with the already acquired static parameters to form the overall parameters  for the received message (S).","Next, the requesting means  uses the overall parameters  to successively inquire at the policy cache function unit  and policy manager  and acquire the policy allocated to that parameter (S).","When obtaining it from the policy cache function unit  (YES at S), it refers to the allocation rule cache table  and confirms if the policy has finished being negotiated ().","On the other hand, when the policy cannot be found in the policy cache function unit  (NO at S) and is acquired from the policy manager  (YES at S and S), it is possible to store the acquired policy in the policy cache function unit . In this case, it is deemed that the negotiations for that policy have not been completed.","If the acquired policy has not finished being negotiated (NO at S), the requesting means  uses the negotiation function unit  to negotiate with the function unit  of the other party in the communications (S). The method of negotiating over a single policy is not particularly limited in the present invention, but for example the methods of negotiation of comparing just the names of the policies or comparing the content of the control indicating the policies may be considered.","Further, regarding the method for determining the result of the negotiations, the method of deeming that the negotiations have not succeeded when the two policies do not match and using one policy based on a certain priority order may be considered. Whatever the case, the result of negotiations is stored as a negotiation completion flag  in the policy cache function unit . When the negotiations do not succeed (NO in S), error processing for when any negotiations fail is performed (S).","On the other hand, when the negotiations have been completed or the negotiations have succeeded (YES of S), the policy is given to the controlling means . The controlling means  and  of the service layers  and  involved in the communications perform control designated by the policy (S). As explained above, the content of the control typically includes verification, encryption, signature, and other security functions. The present invention is not however limited to such security functions.","When this control has ended, the message is propagated through the communication layers  and  under the suitable control of the controlling means  and , and the application  of the other party in the communications receives this.","In the above explanation, the processing when a policy was not found in the cache function unit  or when negotiations were not yet completed for a policy was explained. By suitably acquiring policies all together or conducting block negotiations by policy clusters, cache misshits or encounters with policies not negotiated is reduced to the minimum. Therefore, processing for making inquiries to policy managers  or processing for negotiating for each policy can be skipped and fast operation becomes possible.","Summarizing the effects of the invention, according to the present invention, it is possible to eliminate the need as much as possible for processing for inquiring about policies or negotiating with another party in communications for every message communication, which easily occurs in a mode of use where a plurality of different types of messages are communicated in a distributed environment in a short time. Therefore, in such a mode of usage, it becomes possible for a service layer to process at a high speed consecutive message communications.","Further, it is possible for a service layer to detect in advance a mismatch of policies or information relating to the presence of completed advance negotiations of policies due to illegitimate policy managers or human error, communication error, etc. and possible to further enhance the reliability of computer systems.","While the invention has been described with reference to specific embodiments chosen for purpose of illustration, it should be apparent that numerous modifications could be made thereto by those skilled in the art without departing from the basic concept and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other objects and features of the present invention will become clearer from the following description of the preferred embodiments given with reference to the attached drawings, wherein:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 16","FIG. 14","FIG. 15"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 17","FIG. 14","FIG. 15"]}]},"DETDESC":[{},{}]}
