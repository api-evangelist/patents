---
title: Method and apparatus for virtualizing network resources
abstract: A method and apparatus for managing communications for collaborative applications. Middleware uses, network, application, and middleware resource information together with user information to facilitate communications between the application resources and the users via a hierarchical control structure that implements a communication overlay tree. That overlay tree is implemented in view of network constraints, and on the users and on their communication constraints. The middleware provides user index identifiers that inform the application that specific users have communication interests in specific parts of the application space. To send data to users that are interested in a specific part of the application space the application sends that data with a list of user index identifiers. The middleware then associates the user index identifiers with individual users and routes sent data to the individual users along the overlay tree.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07792936&OS=07792936&RS=07792936
owner: International Business Machines Corporation
number: 07792936
owner_city: Armonk
owner_country: US
publication_date: 20031201
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["1. Field of the Invention","Embodiments of the present invention generally relate to network communications. More specifically, embodiments of the present invention relate to managing communications between application servers and users using middleware.","2. Description of the Related Art","Large scale collaborative systems, e.g., grid computing, represent a growing class of distributed computing systems that enable users to dynamically and virtually share applications, data, and computational resources. The essence of a collaborative system is the virtualization of computing to enable users to obtain a high level of computing power at low cost. Applications that take advantage of distributed computing systems have been and currently are being developed by academic and commercial organizations.","Many distributed computing applications are subject to service level agreements (SLA) having quality of service (QoS) requirements. It is thus necessary for an application that is subject to such SLA agreements to implement resource allocation strategies to meet the QoS constraints. For example, it may be desirable to route communications through network servers that are closest to individual users in terms of round trip time. It may also be desirable to provide different network server allocation strategies based on user class and application types. Meeting such constraints can require complex communication networks and effective communication management.","Current state of the art communication management is usually based on implementing an application-specific network layer mechanism. Such network layer mechanisms are often difficult, costly, and time-consuming to implement and maintain. This is despite the fact that there are numerous similarities in the communication primitives of many application-specific network layer mechanisms. Even when application-specific network layer mechanisms are implemented, most do not take into account the actual network conditions that can and do impact communications.","Therefore, there is a need for a communication solution that manages the communication requirements while accounting for the resource conditions. A communication solution that takes into account actual network conditions would be particularly helpful. A communication solution that relieves applications from the task of explicitly handling all communication requirements would be especially useful.","In one embodiment, the principles of the present invention generally provide for middleware communication solutions that manage communications for collaborative applications such that the applications are relieved of the task of explicitly handling communications. Such middleware communication solutions use multiple attributes, such as network conditions, application logic, and application server resources, to establish network communications and to handle heterogeneity in service level agreement (SLA) requirements among applications and users.","An embodiment of the present invention obtains attribute information regarding such features as middleware resources; network resources such as application servers, network servers, node capacities, round trip travel times and other network factors; and users and their communication constraints (such as SLA\/QoS requirements). Based on the attribute information, the middleware indexes the application resources (servers) to reflect their position in the attribute space. When users contact the middleware, the middleware indexes those users to reflect their individual interests in the parts of the application space that match their requirements. The middleware then facilitates communications between the application resources (servers) and the users via a hierarchical control structure that implements a communication overlay tree between the application resources and the individual users. That overlay tree is implemented in view of network constraints, such as the network node forwarding capacity and round trip travel times, and on the users and on their communication constraints. The middleware provides to the application, via application servers that are selected using the communication overlay tree, user index identifiers. Those identifiers inform the application that specific users (identified only by index identifiers) have communication interests in specific parts of the application space. When the application wants to send data to users that are interested in a specific part of the application space, the application sends that data, via the application resources that were provided with the user's index identifiers, and a list of user index identifiers of the users having interest in that part of the application space. The middleware associates the user index identifiers with individual users and routes the sent data to the individual users along the communication overlay tree.","In an embodiment of the present invention, if a significant change in the attributes that impact a user occurs then that user is remapped into the communication overlay tree.","An embodiment of the present invention makes use of application program interfaces (API) for communications with the middleware.","To facilitate understanding, identical reference numerals have been used, wherever possible, to designate identical elements that are common to the figures.","The present invention routes information from collaborative applications to application users using communication middleware that virtualizes a communication network. Referring now to , the virtualization process starts at step , and proceeds at step  by indexing of resources via scalable map construction. This is followed in sequence by a step  of associating the resources at the middleware, a step  of routing path construction, and a step  of handlings fault using soft state protocols.  shows the virtualization process as being continuous by looping back to step  to reflect possible re-associating of resources at the middleware.","The virtualization process is performed in the context of a communication network  that is illustrated in  and that is in accord with the principles of the present invention. The network includes an application  that runs on one or more application servers A, B, C, and D. The application servers connect via network links A, B, C, and D, to middleware . The middleware may include middleware servers A, B, and C that communicated with users A-I. The application servers, middleware servers, and users A-I can be geographically distributed. The middleware servers A, B, and C connect to the A-I via links A-I. Additionally, the middleware servers can connect to users, application resources, other middleware servers, or any other type of network node  via a network server .","The application servers (A-D) run one or more instantiations of the application  (or multiple applications) that are used by the users A-I. The middleware , via its middleware servers A-C, manages the network communications based on multiple attributes that are subsequently described. The middleware  implements communications between the application servers (A-D) and the users A-I and network node  via a hierarchical control structure that establishes a communication overlay tree that spans between the application resources, the individual users A-I, and the network node , and through a middleware server A-C. For example, the middleware can associate an applications server (A-D) with a middleware server (A-C) and with a particular user (A-I) such that communications between that application server and that user through that middleware server has the shortest round trip travel time. In another example, the middleware servers A-C can provide different application server-to-user allocation strategies based on user classes and application types.","To accomplish the step  of indexing of resources via scalable map construction, the middleware  is provided with attribute information such that the entire network space can be portioned into a set of regions. That network space includes the: middleware servers A-C (in general, middleware resources); network resources such as the application servers (A-D), network servers, node capacities, round trip travel times and other network constraints; and users and their communication constraints (such as QoS). Based on that information, at step  the middleware associates resources by forming partitions based on a metric, such as network delay, that is specified by the application and\/or users.","For example, it may be desirable to partition a network space based on AS (autonomous system) prefixes that are assigned to different network domains. In such an indexing scheme, all of the AS prefixes are gathered and then a desired set of bins are created, with each bin being assigned a partition of the prefix sets. Based on the closet prefix matching, bin j may be assigned all of the prefixes 192.X.X.X and 200.X.X.X. Next, each bin is assigned a representative server\/controller\u2014this server\/controller may either be a physical or a logical one. This assignment is done based on a desired metric, say, closet match in the prefix set to the IP address of the server. If server(i) is assigned to bin(j), the assignment might be that server(i) would be managing the network space partition defined by bin(j). In summary, each bin would be assigned an index space for the server to allocate its managed users an ID reflecting this association of virtual space. It should be understood that this portioning example is merely a suggested one and should not be understood as restricting the indexing space in any way. Indexing can be based on metrics that are gathered via active and\/or passive monitoring.","Note that the above example illustrates one possible approach for defining the network map and associating a set of servers to each part of the network space. A network map construction need not be passive. For example, it is possible to construct a map using measured network delays and then creating a set of partitions or regions that are close to each other in terms of network delay. For facilitating such a measurement based map construction, an external measurement infrastructure, such as landmark based measurement, may be used. Reference, for example, T. S. Eugene Ng and Hui Zhang, \u201cPredicting Internet Network Distance with Coordinates-Based Approaches,\u201d INFOCOM'02, New York, N.Y., June 2002.","The looping in  reflects the fact that a severe change in the attributes that are used for the initial indexing may require repartitioning of the assigned space. It is assumed that that will be rare event that happens over a very large time scale. The simple solution is to recompute the partitioning and reassignment of the indexing. As an example, consider the previous illustration of fixed binning based on AS prefixes. Assume an AS prefix in bin i is found to be closer to prefixes in bin j in terms of network delay due to changes in the network conditions. In this case, the chosen prefix is assigned to bin j. Due to this reassignment; there would be a change in the assignment of IDs to the users that belonged to the chosen AS prefix. This reassignment requires notification to the application servers and changing the association information that is maintained in the middleware servers. Consider for example that subnet described by prefix 9.2.X.X earlier, belonged to bin(i). Due to changes in the network conditions, later it was found that 9.2.X.X is closer to subnets managed by bin (j) as 9.2.X.X become closer to 11.x.x.x that was in bin(j). In this case, the partitioning is adjusted to meet the new partitioning conditions. Thus the space that was managed by 9.2.x.x now would belong to bin(j). As a result of this reclustering process, a new representative may be chosen for this bin. Once updated reassignment of the ID that are managed earlier by this bin(j) may be performed to reflect this change. Thus the indexing would change to reflect this adaptation process.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2","b":["202","202","206","206","204","204"]},"When a user intends to use an application server (A-D), its request is redirected to a middleware server (A-C). Based on its requirements and its positioning in the application attribute space, an appropriate cluster is determined for the association with the virtual space. Once this choice is made, a virtual ID is assigned to the user in such a way that it reflects its association with this cluster. One simple indexing would be to add the cluster ID to the IP address of the user as a prefix to derive its virtual ID. The application server would then be informed about this user by announcing the user's virtual ID to the server.","As an example, consider a user that wants the nearest server in terms of network delay. In such case, the user is assigned a virtual ID from the ID space managed by the server that is closest to the user in terms of network delay. In other words, an index is assigned this user from the index space assigned to the virtual space managed by that server. This assigned ID reflects the association of the user with this server. One possible approach is to add the server ID as the prefix to the IP address of the user to generate the ID for the user. Given this attribute aware indexing, an appropriate server is assigned for this user. Appropriate control messages are sent to this chosen server to communicate the request from the user using the user's assigned virtual ID.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["300","302","304","306","308"]},"With the node delay measurements available, at step , in the communication interest space nodes are assigned to the communication groups that overlap with their communication interest. Then, at step , servers nodes that map to the communication group are selected. Then, at step , node virtual IDs are assigned based on the network bin assignment, delay measurement and the ID of the selected server node. The process then stops at step .","The step  of associating resources at the middleware also includes maintaining the association of indexes with the actual IP address of every user in the middleware server. The middleware server that keeps this association information is determined according to the control hierarchy that manages the set of middleware servers or policies that are in place for sharing the management load. Middleware server control protocol may decide to replicate this information at other middleware servers. The user is returned a descriptor that reflects the middleware server that it should contact for further communication within the application space. Provisions are made to hide the mapping of real identities (IP addresses etc.) to the virtual IDs within the middleware server.","The step  of constructing a routing path typically takes the form of creating a communication overlay tree.  illustrates an example of a communication overlay tree  for communications between application resources A-A and users U-U via middleware M-M and nodes N-N. As shown, node N clusters A-A together and routes communications through M, node N clusters A-A together and routes communications through both M and M, while node N clusters A-A together and routes communications through M. Further, node N links U, U, and N together. Node N also connects to M and to U. M also connects directly to U and to node N, which in turn links U and U. Thus, A can send data to M via node N, and M can route that data to N to U. It should be understood that the overlay tree  is configured by the middleware based on multiple attributes.","While we present on method of tree building, others exist. Reference, for example, \u201cEnabling Conferencing Applications on the Internet using an Overlay Multicast Architecture\u201d, Yang-hua Chu, Sanjay G. Rao, Srinivasan, Seshan and Hui Zhang, Proceedings of ACM SIGCOMM, San Diego, Calif., August 2001; \u201cA Case For End System Multicast\u201d, Yang-hua Chu, Sanjay G. Rao and Hui Zhang, Proceedings of ACM SIGMETRICS, Santa Clara, Calif., June 2000, pp 1-12; and \u201cScalable Application Layer Multicast,\u201d Suman Banerjee, Bobby Bhattacharjee, Christopher Kommareddy, ACM Sigcomm, August 2002.","The set of users that are to be notified for any event depends on the application logic and on the session management module. The application uses application programming interfaces (APIs) to communicate with to the middleware server or through a session management module. Given a notification event and a set of users, a middleware server determines the actual identity of the users that have to be contacted. Using this lookup information, appropriate users are notified by constructing an efficient data path overlay connecting these nodes. Two types of overlays that may be used include a common overlay that is independent of the session and a per-session overlay that depends on the session. While a common overlay is simple to construct, it may not be the most efficient in terms of bandwidth usage and latency. Thus, in some applications a specific per-session overlay path is useful.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5","b":["500","500","502","504","506","508"]},"Under some conditions there may be a need to adapt the overlay path. First, if nodes arrival or departure in a session, or if there is a change in the network condition that changes the clustering\/partitioning of the network and communication space. At step  a query is made as to whether a node arrives or departs. If so, at step  a determination is made if there is a need to change the leader node. If not changed, at step  local changes are made to the overlay tree. However, if there is a need to a change the leader node (for example, the leader node departed), at step  new overlay tree is created. This change is propagated to the upper hierarchy so that inter-cluster path is established as well.","If a node has not arrived or departed, at step  a query is made as to whether a change in network and\/or communication interests the membership within a cluster has changed. If so, a jump to step  is made to determine if a leadership change is required. Steps  and  are then run appropriately. If not, a loop is made back to determine if a node has arrived or departed. In this manner, changes to the network are monitored and the network is corrected appropriately.","The constructed overlay tree is adaptive to changes in node network attributes and group membership. An adaptive method is shown in . That method starts at step  and proceeds at step  by determining if a node network attribute has changed. If so, a jump is made to a step  (which is discussed subsequently). However, if at step  the determination was that a node network attribute has not changed the method  proceeds to a step  where a determination is made as to whether the group membership has changed. If not, a loop is made back to step . In this manner a continuous monitoring for changes that impact the constructed overlay tree is performed. If a node network attribute has changed (at step ), or if the group membership has changed, (at step ), at step  a multi-cast tree is (re) computed. Then, at step , based on the computed multi-cast tree the prior multi-cast tree is modified.","The forgoing is performed within the network shown in . The middleware  provides to the application , via application servers A-D, user index identifiers. The application server that is supplied with a particular user index identifier is selected from the communication overlay tree . The user index identifiers inform the application  that specific users, which are identified only by index identifiers, have communication interests in specific parts of the application space. Thus, the application  becomes aware that a user (A-I) has an interest in a specific part of the application, and that communications have been initiated via a particular middleware server (A-C) through a particular application server (A-D). However, the application  does not know the identity of the user or the position of that user in the communication overlay tree .","Based on the application's logic and session information, when the application  determines that it should send data to users that are interested in a specific part of the application space, the application  sends that data, via the application server (A-D) that was provided with the users index identifiers, together with a list of user index identifiers of the users having interest in that part of the application space. The middleware  then associates the user index identifiers with individual users (A-I) and routes the sent data to the individual users (A-I) along the communication overlay tree .","Since the middleware  manages communications between the users (A-I) and the application  over a network having nodes, to run efficiently the communication network  should operate according to specific communication protocols and should support the communication overlay tree . Communication protocols are established by providing application developers with application programming interfaces (APIs) for interfacing applications  and users (A-I) with the middleware  software. The APIs implement appropriate and standardized communication primitives that enable application developers to develop applications  such that the users A-I can interface through the middleware  to an application  running on an application server A-D.","Supporting the communication overlay tree requires implementing steps that are related to tree construction and to tree use.  illustrates a method  of supporting the communication overlay tree. That method begins at step  and proceeds at step  by indexing network resources using a scalable map. That scalable map identifies application servers (A-D) and resources, middleware servers (A-C), network nodes (), and various network communication parameters such as node forwarding capacity, round trip time delays between nodes, packet loss rates, and other network constraints. Thus, the mapping represents data gathering regarding the network environment that the overlay tree  is to operate in. It should be understood that step  is ongoing in that the network environment is dynamic. Any noticeable change in SLA or in a condition that affects a user's perceived SLA can initiate a new indexing of the network resources.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2","b":["1","3","1","202","202","203","212","204","202","202","202","202","203","204","204","302","303"]},"After the network resources are clustered at step , at step  the users are indexed. When a user enters the communication network , the user's requirements and interests are input to a middleware server A-C, and thus to the middleware . Requirements and interests can be sent as user vectors in which various bits represent pre-assigned features. Then, at step , based on the user requirements, user interests, the position of the user in the application attribute space, and network resources between the user and a middleware server, the middleware determines an appropriate application server cluster for the user. For example, this association may reflect the nearest application server to the user based on time or based on acceptable packet data losses. Based on the indexing method that is used, at step  the user is assigned an index identifier that is passed to the application  via an appropriate application server A-D and that is sent back to the user. The index identifier informs the application  that a user A-I is interested in a specific part of the application space and that communications are to go through a particular application server A-D to a particular middleware server A-C. The user is also returned a communication descriptor that identifies the middleware server A-C that it should contact for further communications within the application space.","However, the middleware  tracks the actual user and its location within the communication overlay tree , such as by indexing the user's IP address along with the user index identifier. The actual middleware server A-C that keeps this association information is determined according to a middleware control hierarchy that manages the middleware servers. In addition, middleware server control protocols may decide to replicate this information in one or more of the other middleware servers.","Following step , at step  the application logic and\/or a session management module of an application determines a list of users A-I that are to receive data based on the occurrence of a notification event. At step , when a notification event is detected, the application  sends data to the predetermined middleware server A-C together with the list of users A-I that are to receive data. At step  the middleware  then determines the actual identities (IP addresses) of the users A-I that are to be contacted and then sends the data to those users. In practice, the application  or the session management module uses the provided APIs to describe the set of users to the appropriate middleware server A-C.","Given that that association of users A-I and application servers A-D are maintained at the middleware servers A-C, it is useful to support uninterrupted communication in the advent of middleware server failure. Step , fault handling, is achieved by two sets of mechanisms. The first one is to replicate the states at multiple middleware nodes besides the designated server. The second is to fail over to the backup server when it is detected that the parent server has failed. Several approaches can be used to detect the failure. For example, each user may use keep-alive messages to check for node failures. In the advent of node failures, alternate servers are contacted to re-establish the connection. Also in addition to node failures, it is possible to choose a backup server (or a freshly chosen server) if there is performance degradation.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 7","b":["700","700","710","720","725","727","710","730","720","710","700","740"]},"Although the middleware server  is depicted as a general purpose computer that is programmed to perform various control functions in accordance with the present invention, the invention can be implemented in hardware, for example, as an application specified integrated circuit (ASIC). As such, the process steps described herein are intended to be broadly interpreted as being equivalently performed by software, hardware, or a combination thereof. Furthermore, the computer readable media  is a computer readable memory that stores information that can be run and\/or accessed by the processor .","The foregoing results in a virtualized network in which communications are managed and handled by middleware that relieves the application and the user from having to explicitly communicate with each other and in which communications are based on the network conditions.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
