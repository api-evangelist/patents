---
title: Context-based routing in multi-hop networks
abstract: Context-based routing in multi-hop networks involves using a context-based routing metric. In a described implementation, respective path values are calculated for respective ones of multiple paths using the context-based routing metric. A path is selected from the multiple paths responsive to the calculated path values. Data is transmitted over at least one link of the selected path. In an example embodiment, the context-based routing metric is ascertained responsive to an estimated service interval (ESI) of a bottleneck link of each path of the multiple paths. In another example embodiment, the context-based routing metric is ascertained responsive to an expected resource consumption (ERC) metric. In an example embodiment of path selection, the path is selected using a context-based path pruning (CPP) technique that involves maintaining multiple local contexts at each intermediate node, with each local context representing at least one partial path.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07693939&OS=07693939&RS=07693939
owner: Microsoft Corporation
number: 07693939
owner_city: Redmond
owner_country: US
publication_date: 20070507
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Introduction to Context-Based Routing in Multi-Hop Networks","Example Implementations for Context-Based Routing in Multi-Radio Mesh Networks","1. Introduction","Context-Based Routing in Multi-Radio Mesh Networks","2. Self-Interference Aware Routing Metric","3. Context-Based Path Pruning","4. Alternative Applications for Context-Based Routing","5. Conclusion","Context-Based Routing in Multi-Radio Mesh Networks","Example Implementations for Routing with a Markovian Metric to Promote Local Mixing","1. Introduction","Routing with a Markovian Metric to Promote Local Mixing","2. Markovian Metric","3. Markovian Metric for Local Mixing","5. Conclusion","Routing with a Markovian Metric to Promote Local Mixing","Example Device Implementations"],"p":["Some networks, including some wireless networks, are pre-planned and centrally-controlled. A single provider can organize the network nodes and installs the infrastructure. Operationally, a centralized entity has a wealth of knowledge about various network characteristics. Consequently, a routing between two communication participants at different network nodes may be pre-planned and centrally-controlled.","On the other hand, ad hoc networks, including wireless ad hoc networks, do not usually involve significant pre-planning or centralized control. One or perhaps a few network nodes are often established by different individuals. These individuals activate their respective network nodes, which are designed to automatically interoperate with other network nodes that are established by other individuals. Even without pre-planning or centralized control, operation of these ad hoc networks still entails routing connections for communication participants between two network nodes. Mechanisms and techniques for effectively determining efficient routings can involve considering and sharing parameters across many network nodes as well as appropriately balancing a multitude of factors.","Context-based routing in multi-hop networks involves using a context-based routing metric. In a described implementation, respective path values are calculated for respective ones of multiple paths using the context-based routing metric. A path is selected from the multiple paths responsive to the calculated path values. Data is transmitted over at least one link of the selected path. In an example embodiment, the context-based routing metric is ascertained responsive to an estimated service interval (ESI) of a bottleneck link of each path of the multiple paths. In another example embodiment, the context-based routing metric is ascertained responsive to an expected resource consumption (ERC) metric. In an example embodiment of path selection, the path is selected using a context-based path pruning (CPP) technique that involves maintaining multiple local contexts at each intermediate node, with each local context representing at least one partial path.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover, other method, system, scheme, apparatus, device, media, procedure, API, arrangement, etc. implementations are described herein.","A fundamental problem in multi-hop wireless networks is routing, e.g., moving packets from a source node to a destination node. Routing protocols have traditionally been based on finding shortest (cheapest) paths under certain cost metrics. A conventional routing metric models the cost of a path as the sum of the costs on the constituting links, where the cost of a link typically reflects the link quality in one way or another (e.g., loss rate, supported bit-rate, delay, etc.). The routing system then aims at finding the path offering the lowest total cost.","However, such common practice is not adequate for all scenarios, especially as new wireless technologies appear in the lower layers of the networking stack. For example, a promising technique for improving the capacity of mesh networks is to use multiple radios. With multiple radios, a device can transmit and receive at the same time, including on different radio interfaces. The radio spectrum can therefore potentially be utilized more efficiently because more concurrent communications can be packed in spectrum, space, and time when using multiple radios. Hence, multiple radios open up new opportunities for high throughput wireless communications. A key challenge towards unleashing the potential of multiple radios in wireless mesh networks is interference-aware routing. Example implementations for a self-interference aware routing protocol for multi-radio wireless mesh networks are described herein.","To model the self-interference of the links on a path, a Self-Interference aware routing Metric (SIM) is described. It is a context-based metric in that the cost of a link depends on what other (e.g., previous) links are used in the route. The cross-coupling of the links in a context-based metric renders it challenging to find the minimum cost route. In particular, a direct application of Dijkstra's shortest path algorithm fails to incorporate the impact of past decisions on the future parts of the route. Hence, a context-based path pruning (CPP) method is also described. The CPP method prunes suboptimal partial-paths based on fixed-length contexts as it explores the path space.","Thus, implementations of the described interference-aware approach involve two synergistic building blocks: (1) a context-based path metric (the SIM) that properly models the link interdependencies, and (2) an efficient algorithm (the CPP method) for route optimization under the context-based path metric. Together, they constitute an instance of a general context-based routing paradigm, which is applicable to scenarios where modeling the interactions between different links is relevant to performance. Other applications of this paradigm for wired and wireless networks are also described herein below.","Another example is local mixing, a recent link layer advance that exploits the broadcast nature of the wireless medium. The local mixing engine may reside between the routing and media access control (MAC) layers. It maintains information about the packets each neighbor has and identifies opportunities to mix the outgoing packets via network coding to reduce the, e.g., number of transmissions in the air. Local mixing, on its own, can improve the link layer efficiency. The gain of this technique, however, depends on the traffic pattern in the network, and hence the routing decisions. An implementation that is described herein involves a routing method based on a Markovian metric that can find routes that are likely to have more mixing opportunities.","This Markovian metric models the cost of a path as the cost of the first hop, plus the cost of the second hop conditioned on the first hop, and so on. A Markovian metric is used to model the reduction of channel resource consumption due to local mixing. This leads to routing decisions that can better take advantage of local mixing opportunities. Throughput gains and resource savings can be achieved by applying the Markovian metric to facilitate local mixing.","The description that follows is divided into two major sections: \u201cExample Implementations for Context-Based Routing in Multi-Radio Mesh Networks\u201d and \u201cExample Implementations for Routing with a Markovian Metric to Promote Local Mixing\u201d. Certain realizations of the latter may be considered as specific implementations of the former, including optionally with wireless nodes having only one radio. The principles described herein may also be applied to other networks having multiple links originating and terminating at different nodes.","Generally, context-based routing in multi-hop networks may be implemented in many different network types and topologies. However, an example network is illustrated in  and described below.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1","FIG. 16"],"b":["100","100","102","100","102","1","102","2","102","3","102","4","102","5","102","102"],"i":"n"},"Each network node  may be in communication with one or more other network nodes  via at least one network communications link , some of which are explicitly denoted in . Each link  may be a wired link or a wireless link. A path  is shown between network node () and network node (); path  extends through network nodes () and (). Although the illustrated path  includes three links , a path may be more generally comprised of any two or more links .","To enable wireless communication, one or more network nodes  may be realized as a wireless network node *. Each wireless node * includes at least one radio . Two radios () and () are specifically shown. However, each wireless node * may have \u201cr\u201d radios , in which \u201cr\u201d represents some positive integer 1, 2, 3, 4, . . . r.","Each radio  enables a wireless network node * to communicate on a wireless channel. Each radio is typically capable of communicating via one or more wireless links * in accordance with at least one wireless standard. Example wireless standards include, but are not limited to, IEEE 802.11 standards, IEEE 802.16 standards, IEEE 802.22 standards, UWB, and so forth. By way of example only, multiple such wireless network nodes * may form a wireless ad hoc mesh network.","As introduced above, a promising technology for improving the capacity of wireless mesh networks is to use multiple radios at each node. With multiple radios, a device can transmit and receive at the same time, including on different radio interfaces. The radio spectrum can also be utilized more efficiently because more concurrent communications can be packed in spectrum, space, and time. However, maximizing the benefit of multiple radios calls for intelligent routing decisions that are aware of multiple radios and can take advantage of them. In particular, routes that contain low interference among the constituting links are chosen.","Generally, example implementations for Context-based Routing Protocol (CRP) for interference-aware routing in multi-radio networks are described herein. CRP addresses some open issues and challenges on this problem. In a described implementation, CRP has two principle components: (1) a new path metric (the SIM), and (2) a novel context-based path selection technique (the CPP method).","One aspect of the first component, the SIM metric, is that it is context-dependent. In other words, it assesses the cost of each link in the context of previous hops for the path under consideration. As described further herein below, the SIM metric is a weighted sum of the estimated transmission time (ETT) and the maximum expected service interval (ESI) at the bottleneck link. Similar to how the long term throughput of a pipelining system is determined by the bottleneck component, the long term throughput of a wireless route is determined by the bottleneck link. Herein below, we show that the maximum ESI term can be interpreted as an \u201cideally achievable\u201d throughput assuming perfect scheduling.","Because the SIM metric is context-dependent, a direct application of the Dijkstra's shortest path algorithm may lead to rather suboptimal paths. The reason is that Dijkstra's algorithm operates on an optimality principle: The shortest path from s to t via v is the shortest path from s to v concatenated with the shortest path from v to t. Such an optimality principle no longer holds for a context-based metric. In response to this situation, the second component of CRP is a general context-based path pruning method (CPP) for discovering good paths using a context-based metric. To model the context of a partial path while avoiding the exponential growth in the number of partial paths, CPP maintains a set of paths that reach each node v, corresponding to different local contexts. Each local context can be viewed as a concise summary of the dominating history of all the partial paths that end with that local context, based on the observation that older history usually has less impact on the future. The current best path under each local context is maintained and considered further for possible expansion into an s-t path.","In short, implementing the interference-aware routing approach of CRP involves (i) properly modeling the link interdependencies (e.g., via the SIM metric) and (ii) handling the ensuing algorithmic challenges in route optimization (e.g., via the CPP method). The use of local contexts in pruning is synergistic with the use of contexts in cost modeling. Together they present a general context-based routing paradigm, which is applicable in scenarios where modeling link-interdependencies is relevant.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["102","102","202","204","206","208"]},"Context-based routing metric ascertainer  ascertains a context-based routing metric, such as a SIM metric, a Markovian metric (e.g., ERC), and so forth. Path value calculator  calculates a value for a given path under a selected context-based routing metric. Context-based routing metric ascertainer  and path value calculator , for example, may cooperatively interact in the performance of their functions. The calculated values for different paths may be compared in order to select a preferred path.","Path selector  selects a preferred path responsive to the calculated values for multiple potential paths. Path selector  may implement, for example, a context-based path pruning (CPP) technique as described herein. Path value calculator  and path selector , for example, may cooperatively interact in the performance of their functions. Once a path has been selected, or at least a first link of a selected path has been determined, data for a communication may be transmitted by data transmitter  using a radio .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 3","FIGS. 1 and 2"],"b":["300","300","302","308","300","102","300"]},"In a described implementation, starting at block , a context-based routing metric is ascertained. At block , respective path values for respective paths of multiple paths are calculated using the context-based routing metric. Example implementations for the actions of blocks  and  are described herein below in Section 2, which is entitled \u201cSelf-Interference Aware Routing Metric\u201d.","At block , a path from the multiple paths is selected responsive to the calculated path values using a context-based path pruning technique. Example implementations for the actions of block  are described herein below in Section 3, which is entitled \u201cContext-Based Path Pruning\u201d. It should be understood that a final path value associated with and representing the cost of a given path, as well as a final path selection, may be achieved gradually under a described implementation of CPP. At block , data is transmitted over at least one link of the selected path toward the ultimate destination of the data.","For an example implementation, we describe in this section a first component of CRP: the self-interference aware metric (SIM). By way of example only, we address a multi-hop wireless network equipped with multiple radios. Without loss of generality, we assume that each radio is tuned to a fixed channel for an extended duration and that a route specifies the interfaces to be traversed.","We define the SIM metric as a weighted sum of two terms: the expected transmission time (ETT) and the expected service interval (ESI). An example equation version of the SIM metric is presented below as equation (M0), with \u201cM\u201d denoting a multi-radio embodiment:",{"@attributes":{"id":"p-0049","num":"0048"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"SIM","mo":"\u2061","mrow":{"mo":["(",")"]}},{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mi":"\u03b2"}},{"munder":{"mo":"\u2211","mi":"k"},"mo":"\u2062","mrow":{"mi":"ETT","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["e","k"]}}}}],"mo":"\u2062"},{"mi":"\u03b2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"munder":{"mi":["max","k"]},"mo":"\u2062","mrow":{"mrow":{"mi":"ESI","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["e","k"]},{"mrow":{"mi":"k","mo":"-","mn":"1"}}],"mo":"|"}}},"mo":"."}}}],"mo":"+"}],"mo":["\u2062","\u2062"],"mover":{"mo":"=","mi":"\u0394"}}},{"mrow":{"mo":["(",")"],"mi":"M0"}}]}}}},"br":{},"sub":"k ","img":{"@attributes":{"id":"CUSTOM-CHARACTER-00001","he":"2.12mm","wi":"2.12mm","file":"US07693939-20100406-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4","b":"400"},"A sub-optimal routing is shown in network topology (b). With network topology (b), primary interference occurs when two adjacent nodes transmit on the same channel, and secondary interference occurs when two nodes that are separated by only one intervening or intermediate node transmit on the same channel. An example superior, if not optimal, routing is shown in network topology (c). Any two nodes that are communicating on the same channel for the illustrated path are thus maximally separated. Using the SIM metric, the path in (c) exhibits a lower cost than the path in (b). Hence, SIM allows us to distinguish these two paths.","2.1 Expected Transmission Time (ETT)","In a described implementation, the first term for the SIM metric is the sum of the ETT along the route. The ETT metric aims at estimating the average transmission time for sending a unit amount of data. It may be defined as indicated in equation (M1) below:",{"@attributes":{"id":"p-0054","num":"0053"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"ETT","mo":["\u2062","\u2062"],"mover":{"mo":"=","mi":"\u0394"},"mrow":{"mfrac":{"mi":"ETX","mrow":{"mi":["Link","Bit","Rate"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},"mo":"."}}},{"mrow":{"mo":["(",")"],"mi":"M1"}}]}}}}},"For equation (M1), the ETX metric estimates the number of transmissions, including retransmissions, needed to send a unicast packet across a link. It is computed as ETX1\/(1\u2212p), where p is the probability that a single packet transmission over link e is not successful. The \u201cLink Bit-Rate\u201d in equation (M1) can be measured by, for example, a technique of packet pairs. This method can produce sufficiently accurate estimates of link bandwidths.","2.2 ESI of the Bottleneck Link","In a described implementation, the second term is the estimated service interval (ESI) at the bottleneck link. This variable therefore reflects how fast the route can send packets in the absence of contending traffic. The \u201cmax\u201d operation is used here instead of the sum operation. This can be explained by a pipeline analogy. In a pipeline system including several processing stages, the long term throughput is determined by that of the bottleneck stage, instead of the average throughput of the stages. Sending packets along a wireless route is similar or analogous. Thus, the long term throughput of a flow is determined by that of the bottleneck link.","The ESI of a link may be defined as shown below in equation (M2):",{"@attributes":{"id":"p-0059","num":"0058"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"ESI","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["e","k"]},{"mrow":{"mi":"k","mo":"-","mn":"1"}}],"mo":"|"}}},{"mrow":[{"mi":"ETT","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["e","k"]}}},{"munder":{"mo":"\u2211","mrow":{"mi":["j","k"],"mo":"<"}},"mo":"\u2062","mrow":{"msub":{"mi":["p","jk"]},"mo":"\u2062","mrow":{"mrow":{"mi":"ETT","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["e","j"]}}},"mo":"."}}}],"mo":"+"}],"mo":["\u2062","\u2062"],"mover":{"mo":"=","mi":"\u0394"}}},{"mrow":{"mo":["(",")"],"mi":"M2"}}]}}}},"br":{},"sub":["jk ","j ","k ","jk "]},"Characterizing the interference relations among the links can be challenging. One method is to make use of actual interference measurements. Consider two links, A\u2192B and C\u2192D, using the same channel. There are four primary forms of interference: (i) C can sense A's transmission via physical or virtual carrier sensing, and hence refrains from accessing the medium; (ii) A can sense C's transmission; (iii) transmissions of A and C collide in D; and (iv) transmissions of A and C collide in B. Based on this, we adopt without loss of generality a simplified approach for the description herein: We treat the two links as interfering if A has a link to C or D with sufficiently good quality, or C has a link to A or B with sufficiently good quality.","The ESI expression of equation (M2) leaves out the interference caused by other contending traffic. This is a simplification in modeling; hence, the interference caused by other contending traffic may alternatively be incorporated into an implementation. The ESI expression (M2) considers the self-interference from the previous hops of the route by adding up the expected transmission times of the previous links. The intuition is that the packets at the link need to share the channel with the interfering links on the route.","It is possible to also add the ETTs from the subsequent links on the path (as well as from the previous links) because both previous and subsequent links can create interference. Although this approach can alternatively be adopted, the following theorem explains why it is not adopted herein.","Theorem 1 (Interpretation of Bottleneck ESI): Assuming ideal scheduling, sufficiently long flow, absence of contending traffic, and an ideal binary interference model dictated by a conflict graph, the end-to-end throughput of 1\/maxESI(e|) is achievable.","Proof of Theorem 1: Under the assumptions in the theorem's claim, finding the optimal end-to-end throughput essentially amounts to finding an optimal interference-free scheduling of the uses of the constituting links. If we can schedule each link to transfer B bits in T seconds, then the throughput B\/T can be achieved. It is well known that this problem can be viewed as a continuous version of the graph coloring problem on the conflict graph.","In greedy coloring algorithms, nodes in a graph are visited one by one. Each node tries to reuse some existing colors if possible. If not, the node selects a new color. With this procedure, it is easy to see that the graph can be colored in \u0394(U)+1 colors, where \u0394(U) is the maximum degree of a vertex. The greedy coloring algorithm always looks at the already colored nodes, but not future nodes. Hence, in fact the upper-bound can be tightened to one plus the maximum number of already-colored neighbors for the nodes.","We now apply a greedy-coloring-like algorithm for scheduling the links on a route. This is illustrated in  for a path with 6 links eto e.  is a block diagram  of an example interference-free scheduling of six links with regard to an estimated service interval (ESI) at a bottleneck link. We visit the links on the route sequentially, from the first hop to the last hop. For each link e, find one or more intervals with a total length of ETT(e). Similarly to greedy coloring, when assigning the intervals to a link, we only need to examine the previous links, but not future links. With this greedy scheduling process, we can finish the assignment in a total duration of maxESI(e|). If we repeat this scheduling pattern for a sufficiently long time, then we can deliver one packet end to end every maxESI(e|) (sec). Hence, the throughput is achievable.","The Theorem 1 above shows that the bottleneck ESI corresponds to a theoretically achievable throughput. Conversely, if a link einterferes with a set \u2111 of previous links, then typically links in \u2111\u222a{e} would be expected to mutually interfere (hence forming a clique in the conflict graph). If that indeed is the case, then we cannot deliver more than one packet end to end every maxESI(e|) (sec). Thus, this relatively non-rigorous argument shows that the maximum throughput is roughly around maxESI(e|).","2.3 An Alternative System Model","In an example implementation as described above, we assumed without loss of generality that each radio interface is tuned to a fixed channel for an extended time duration. This is referred to herein as a \u201cstatic\u201d channel assignment.","However, there are alternative system models for using multiple radios in which each node has at least two radios. By way of example only, for each node some of its radio interfaces are fixed at certain channels and the remaining are tunable. To send a packet to a node v, a node tunes one of its tunable interfaces to one of node v's fixed interfaces. This model is referred to herein as a \u201csemi-static\u201d channel assignment. Under the semi-static model, to specify a route, we can specify the sequence of receiving interfaces (e.g., via their IP addresses, etc.). The ESI metric can therefore also be applied to the semi-static model with essentially no changes.","In this section, we describe example implementations of a second component of CRP: the CPP path selection algorithm. In addition to defining a good path metric, another challenge is to find the optimal (or near-optimal or at least superior) route under a given path metric. As a starting point, we first consider a link state routing framework. In link state routing, each router measures the cost to each of its neighbors, constructs a packet including these measurements, sends it to all other routers, and computes the shortest paths locally. A centralized algorithm for computing the shortest paths may therefore be adopted with link state routing. However, the CPP method can also be applied in some other, distributed settings. Examples of other settings and protocols are described herein below in Section 3.2, which is entitled \u201cApplying CPP to Other Protocols\u201d.","The relatively simpler problem of finding the optimal path under a decomposable path metric is described first by way of review. In a decomposable path metric, each link has a nonnegative cost, and the cost of a path is the sum of the costs of the constituting links. This problem is well understood. For example, the classical shortest path algorithm by Dijkstra can be applied to find the optimal path with complexity O(|V|), where |V| denotes the number of nodes in the network.","Dijkstra's algorithm maintains upper-bound labels f(v) on the lengths of minimum-cost s-v paths for all v\u03b5V. The label of each node is either temporary or permanent, throughout the execution of the algorithm. At each iteration, a temporary label with least total cost is made permanent and the remaining temporary labels are updated. Specifically, if v* has the minimum total cost among the temporary nodes, then we update the cost of every other temporary node w using equation (M3) below:\n\n():=min{(), (*)+()}.\u2003\u2003(M3)\n","In contrast, the SIM metric is history-dependent. As a result, finding the shortest path under the SIM metric is a new challenge. For example, a direct application of the Dijkstra's shortest path algorithm may lead to highly suboptimal paths with the history-dependent SIM metric. Consider the example shown in .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 6","b":["600","1","2","1","2","1","1","1","1","2","1"]},"The reason that Dijkstra's algorithm returns a suboptimal route is that it operates on an optimality principle: The shortest path from s to t via v is the shortest path from s to v concatenated with the shortest path from v to t. Consequently, each node only needs to remember the cost of the best s-v path. Such an optimality principle no longer holds for a metric such as SIM; instead, an s-v path Pmay have a larger cost than an s-v path Pbut still eventually lead to a lower overall cost toward the final destination node t.","We describe herein example implementations of a context-based path pruning (CPP) technique. It can be applied as a (heuristic) method for optimizing a context-based metric. To model the potential impact of past hops on future hops, we maintain a set of paths that reach each node v (instead of a single s-v path having minimum cost). Thus, a set of partial paths that reach each intermediate node as the partial paths are extended link-by-link toward a destination node are maintained.","An issue that arises is: How many paths should we store at each node as we search for a good s-t path? Storing all paths would apparently result in an exponential complexity. To keep the complexity manageable, we constrain the amount of memory at each node. It is observed that the effect of self-interference has a localized nature. Normally, given what happened in the recent past (i.e., the first few previous hops), the older history is unlikely to have a significant impact on the future.","This observation motivates us to organize the memory at each node according to several local contexts. Each local context can be viewed as a concise summary of the dominating history of all the partial paths that end with that local context, based on the observation that older history usually has less impact on the future. During an execution of a CPP algorithm, each node stores the current best (during the execution of the algorithm) path under each possible local context. The current best paths that are stored are considered further for potential expansion into an s-t path.","The local contexts can be defined in a number of manners. For example, we can define the local context of a path as the sequence of links in the last l hops. As another example, we can define the local context of a path as the sequence of channels taken by the links in the last l hops. Either of these definitions can provide reasonable summaries of the past that would impact the future. Other local context definitions can alternatively be adopted.","3.1 Dijkstra-Style Realization of CPP","In a described implementation, a CPP method can be performed using a Dijkstra-style instantiation. Algorithm 1 shows such an example Dijkstra-style instantiation of a CPP method. A pseudo-code version of an example CPP method is thus provided below as Algorithm 1.",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Algorithm 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"INPUT: A function that can evaluate the cost of a"]},{"entry":[{},"path."]},{"entry":[{},"T := {s}; \/* The set of temporary paths. *\/"]},{"entry":[{},"P := \u2205; \/* The set of permanent paths. *\/"]},{"entry":[{},"while T \u2260 \u2205 do"]},{"entry":[{},"\u2003choose the path  * from T with the minimum cost;"]},{"entry":[{},"\u2003T := T \u2212  *; P := P +  *;"]},{"entry":[{},"\u2003for each valid extension of  *, say  \u2009=  * + e,"]},{"entry":[{},"\u2003do"]},{"entry":[{},"\u2003\u2003c := LocalContext( );"]},{"entry":[{},"\u2003\u2003if T \u222a P contains a path Q with local context c"]},{"entry":[{},"\u2003\u2003then"]},{"entry":[{},"\u2003\u2003\u2003replace Q by  \u2009if it has a lower cost than  ;"]},{"entry":[{},"\u2003\u2003else"]},{"entry":[{},"\u2003\u2003\u2003T := T +  ;"]},{"entry":[{},"\u2003\u2003end if"]},{"entry":[{},"\u2003end for"]},{"entry":[{},"end while"]},{"entry":[{},"OUTPUT: For each node \u03bd, find the best local context"]},{"entry":[{},"c*(\u03bd) resulting in minimum cost. For each context c"]},{"entry":[{},"of each node \u03bd, store the best link reaching it with"]},{"entry":[{},"minimum cost. To recover a route from \u03bd to s, back-"]},{"entry":[{},"track from c*(\u03bd) along the best links toward s."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"With respect to the pseudo code in Algorithm 1 above, we maintain a set T of temporary paths and a set P of permanent paths. In each step, we choose the temporary path with minimum cost. Such a path, say *, is made permanent. Then we consider the possible ways of extending * toward an s-t path. For each extension =*+e, we determine its local context and search for a path with the same local context in T and P. If a path with the same local context already exists, then such an existing path is compared with  and the winner is retained. If a path with the same local context does not exist, then  is added to T.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 8","FIGS. 1 and 2"],"b":["800","800","802","816","800","102","800"]},"In a described implementation, starting at block , a minimum cost path is selected from a set of temporary paths. At block , the sets of temporary paths and permanent paths are updated. For example, the selected path may be removed from the set of temporary paths, and the selected path may be added to the set of permanent paths. At block , the selected minimum cost path is extended by a link to create a valid extended path. At block , the local context of the valid extended path is ascertained using a predetermined function.","At block , it is determined if any path from the set of temporary paths or the set of permanent paths is associated with the same ascertained local context. If not (if there are no others with the same local context), then at block  the valid extended path is added to the set of temporary paths.","If there is a path with the same local context (as determined at block ), then at block  it is determined if the cost of the valid extended path is less than the path with the same ascertained local context. If so, then at block  the path having the same local context is replaced with the valid extended path. If not, then the minimum cost path is extended by a different link (at block ). The minimum cost path is also extended by a different link (at block ) after blocks  and . Although not specifically indicated in , flow diagram  may be repeated from block  until the set of temporary paths is empty.","An alternative approach to understanding and implementing a CPP method is described below. For each physical node v, we introduce one vertex vfor each local context c that is applicable to v, and we interconnect the vertices according to the original connectivity. We denote such a context-expanded graph by G. Algorithm 1 can be interpreted as applying the Dijkstra's algorithm to the expanded graph Gto find a shortest path tree in G.","When employing path metrics (such as SIM) that are not decomposable, the cost update step needs to be revised. Instead of using equation (M3) above, node v* first reconstructs the current best path from the source, say sv*. Then each neighbor node w of v is updated using equation (M4) below:",{"@attributes":{"id":"p-0091","num":"0090"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"w"}},{"mi":"min","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mrow":[{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"w"}},{"mi":"cost","mo":["(",")"],"mrow":{"mrow":{"mi":["s","v"],"mo":["\u2062","\u2062","*"],"mover":{"mrow":{"mo":["~","->"]}}},"mo":"->","mi":"w"}}],"mo":","}}}],"mo":":="},"mo":","}},{"mrow":{"mo":["(",")"],"mi":"M4"}}]}}}},"br":{}},"We now illustrate this context-expanded graph using an example four-node scenario as shown in , which is a graphical depiction of an example four-node network topology  having up to three orthogonal channels to illustrate a context-based path pruning technique. These four nodes are labeled A, B, C, and D. There are three orthogonal links from A to B, two orthogonal links from B to C, and one link from C to D. The channel numbers (CH#) are shown above the link, and the ETT metrics are shown below the links. For the sake of clarity, consider \u03b2=0.5 and the simplified interference model noted above in Section 2.2 \u201cESI of the Bottleneck Link\u201d. In this example, Dijkstra's algorithm using equation (M4) for non-decomposable path metrics returns A-(CH)\u2192B-(CH)\u2192C-(CH)\u2192D, with a total cost of 2.55.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 9A","FIG. 7"],"b":["900","1","2","3"],"sub":"c"},"To connect Algorithm 1 with running Dijkstra's algorithm (with equation (M4)) over the expanded graph, we can view each node as storing the current best path with which it is reached from the source. The current best path can be obtained by backtracking along the best links that reach each node. With a one-hop-based local context as shown in , the route found is A-(CH)\u2192B-(CH)\u2192C-(CH)\u2192D, with a total cost of 2.5.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 9B","FIG. 7"],"b":["900","3","2","1"]},"3.1.1 Optimality","If the path metric indeed has a fixed memory span (say, 1 hop), then a CPP technique with the local context defined by the 1-hop links is guaranteed to find the optimal solution (because no pruning step is suboptimal). Other metrics, however, may have a longer memory span. The SIM path metric, for example, has a memory span that can potentially involve the entire path history. Nevertheless, even if a selected path metric has a longer memory span than the length of the local contexts, the CPP method can still be applied as an effective heuristic method.","3.1.2 Complexity","As noted above, Algorithm 1 can be essentially viewed as applying Dijkstra's algorithm with equation (M4) over the expanded graph. With Algorithm 1, however, the involved vertices and links are constructed on the fly, without explicitly maintaining the expanded graph. Due to the connection between Algorithm 1 and Dijkstra's algorithm, we can easily conclude that the time complexity of Algorithm 1 is O(C), where C is the total number of local contexts at all nodes.","If we define the local context of a path as the sequence of channels taken by the links in the last l hops, then C is upper-bounded by (K+K+ . . . +K)*|V(G)|, where K is the number of channels in the system and V(G) is the set of nodes in the original network. Although other values of l may be adopted, for an example practical implementation with current hardware\/software\/processing technologies, we specifically propose to use l=2. For this example, l=2 leads to a specific complexity that is given by equation (M5) below:",{"@attributes":{"id":"p-0099","num":"0098"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"O","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"K","mo":"+","msup":{"mi":"K","mn":"2"}}},{"mo":["\uf603","\uf604"],"mi":"V"}],"mo":"\u00b7"}},"mn":"2"}}},"mo":"."}},{"mrow":{"mo":["(",")"],"mi":"M5"}}]}}}}},"3.2 Applying CPP to Other Protocols","The CPP method is a general method to efficiently explore the path space. It can also be applied to other scenarios in other settings including, but not limited to, distance vector protocols, on-demand route discovery, and so forth.","First, we describe how CPP can be implemented in a framework based on the Bellman-Ford shortest path algorithm. The Bellman-Ford algorithm maintains for each node v first the minimum cost s-v path with 0 interior nodes, then the minimum cost s-v path with \u22661 interior node, then the minimum cost s-v path with \u22662 interior nodes, and so on. Similar to what is described above for Dijkstra's method, to use the CPP method, we essentially can run the Bellman-Ford algorithm over the context-expanded graph G. Specifically, we maintain a set Qof paths. For k=1 to |V(G)|\u22122, we consider the paths in the Qset one by one. For each path * in consideration, we examine all possible paths obtained by extending * by one more hop. For each extended path =*+e, we then check if there exists a path Q in the current set with the same local context. If not, the extended path  is inserted into the set; otherwise, the path  is compared with the existing path Q and the better is retained.","The practical counterpart of Bellman-Ford's algorithm is the distance vector protocol (e.g. DSDV). Originally, each router maintains a table (i.e., a vector) giving the best known cost to reach each destination and the associated interface(s). Tables are updated by exchanging information with neighbor nodes. To adapt to our current context-expanded graph scenario, first we construct the context-expanded graph in a reverse manner.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 10","FIG. 7"],"b":["1000","1","1","2","1","1","2","1","2","1","1","3","2","1"],"sub":"c"},"CPP can also be applied to on-demand route discovery protocols including, but not limited to, dynamic source routing (DSR), DSR with ETX, and so forth. In DSR, a source node broadcasts route request packets to discover routes to a destination. When a node forwards a route request, it appends its address and the related link costs. To implement CPP in DSR, when a node receives a request it has already forwarded, it forwards it again if the path cost to a neighbor v is better than the best which it has already forwarded with the same local context.","Context-based routing may be implemented in applications that extend beyond self-interference aware routing. In this section, alternative implementations and applications of context-based routing are described.","Network Coding: Network coding has been proposed as a link layer enhancement technique for wireless networks. Consider a 3-node chain A-B-C with two opposite flows A\u2192C and C\u2192A. In this case, the middle node B can XOR two packets traveling in opposite directions thereby reducing the transmissions required for packet exchange from 4 down to 3 transmissions. However, previous schemes proposed for network coding are opportunistic and critically depend on the traffic pattern in the network and thus the routing decisions. To increase the benefit of network coding, routes that create more mixing opportunities can be ascertained and selected. Context-based routing can be applied in such scenarios.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIG. 11","FIG. 11"],"b":["1100","1100"]},"Node B knows that a packet arriving from A and going to C can be mixed with the background flow. Consequently, node B can announce a lower conditional cost for a cost(B\u2192C|A\u2192B) to attract new flows to adopt a route that can be mixed with the background flows. With the illustrated example, node B announces that the cost(B\u2192C) equals $1 generally. However, it also announces that the cost(B\u2192C|A\u2192B) equals half of the general amount. The lower cost is justified by the lower resource that the path consumes. In this network coding scenario, the path metric has a one-hop memory; hence, the CPP method can find the optimal route.","Furthermore, it is possible to combine multiple context-based metrics in systems where context is required to model multiple phenomena. As an example, we can potentially perform route selection in a wireless network with multiple radios as well as local mixing. To that end, but by way of example only, \u201cRouting with a Markovian Metric to Promote Local Mixing\u201d is described in greater detail herein below.","Multicast: While the description above applies context-based routing to multi-radio unicast, context-based routing can also be applied to optimize multicast trees in multi-radio networks.","Optical Networks: The problem of choosing light-paths in a WDM optical network has some synergy with a wireless network equipped with multiple radios. Each optical router has multiple incoming wavelengths and outgoing wavelengths. Some costlier devices can also perform wavelength conversion. Thus, the cost of choosing an outgoing wavelength can depend on context. For example, the cost can depend on the incoming wavelength and the cost of conversion.","In the description above, we present example implementations for routing metrics and route selection performed in multi-radio wireless networks. Context information can be used to enhance, if not optimize, routes when interdependencies between links in a path exist. An example context-based metric that is described herein above is the SIM metric. An associated context-based route selection method, the CPP method, is also described. Although they may be implemented separately, they jointly provide an effective way for performing interference-aware routing in multi-radio networks. CRP can find good routes when frequency reuse is possible, heterogeneous nodes exist in the network, and\/or transient bottlenecks occur. Hence, it is a good general purpose routing protocol for multi-radio wireless network meshes.","Network coding refers to a scheme where a node is allowed to generate output data by mixing (i.e., computing certain functions of) its received data. The broadcast property of, e.g., the wireless medium renders network coding particularly useful.","Consider nodes v, v, von a line, as illustrated in .  is a graphical depiction of an example three-node network topology  to illustrate how transmissions can be saved using local mixing\/network coding. Suppose vwants to send packet xto vvia vand vwants to send packet xto vvia v. A conventional solution without network coding requires 4 transmissions over the air. This non-network coding approach is illustrated in ). Using network coding, on the other hand, this packet exchange can be performed using 3 transmissions. This network coding approach is illustrated in ).","The principles illustrated in  can be generalized to a chain of nodes. For packet exchanges between two wireless nodes along a line, the consumed channel resources can potentially be halved. Such advantages can be realized in practice. For example, each wireless router can examine its local buffer and mix a left-bound packet with a right-bound packet (here \u201cleft\u201d and \u201cright\u201d are in the relative sense). Such a mixture packet can be de-mixed by the left and right neighbors.","As another example, a framework for exploiting network coding and the broadcast medium to improve the efficiency of unicasting in multi-hop wireless networks has been presented. Each node snoops on the medium and buffers packets it has heard. A node also informs its neighbors which packets it has overheard. This allows nodes to know roughly what packets are available at each neighbor (i.e., \u201cwho has what?\u201d). Knowing \u201cwho has what\u201d in the neighborhood, a node examines its pending outgoing packets and decides how to form output mixture packets, with the objective of most efficiently utilizing the medium.","Thus, a link layer enhancement scheme can be implemented in the networking stack.  is a block diagram showing an example network layer relationship  for routing to promote local mixing with a local mixing engine shunt. As is illustrated in , the local mixing engine sits above the MAC layer (e.g., for IEEE 802.11) and below the network layer (e.g., for routing). Given the routing decisions, the local mixing engine tries to identify mixing opportunities. It has been shown that local mixing can improve the link layer efficiency. The gain of this technique, however, depends on the traffic pattern in the network. Thus, the description herein below involves making routing decisions that increase, if not maximize, the benefits offered by the local mixing engine.","By way of example only, the description herein below focuses on wireless mesh networks (e.g., static multi-hop wireless networks). However, the described implementations and principles are applicable to other wireless networks and\/or wired networks. State-of-the-art routing protocols for wireless mesh networks have traditionally been based on finding shortest paths under certain cost metrics. The simplest path metric is the hop count. However, various link quality metrics have also been proposed for static wireless mesh networks. These metrics include, by way of example but not limitation, the per-hop round-trip time (RTT), the expected transmission count (ETX), the expected transmission time (ETT), and so forth.","One approach is to modify the link metrics to take into account the effect of the local mixing engine in reducing the transmissions over the air. This, however, is not straightforward. Consider the example setting illustrated in .  is a graphical depiction of an example nine-node mesh network topology  having two long-term background flows () and (). These two long-term flows in the network are: v\u2192v\u2192v(()) and v\u2192v\u2192v(()).","We want to find a good routing path from vto v. Due to the existence of the local mixing engine, the route v\u2192v\u2192v\u2192v\u2192vis a good solution because the packets belonging to this new flow can be mixed with the packets belonging to the opposite flow v\u2192v\u2192v, resulting in improved resource efficiency. To encourage using such a route, link v\u2192vcan announce a lower cost. There are some issues in doing so, because a packet from vthat traverses v\u2192vmay not share a ride with a packet from vthat traverses v\u2192v, although a packet from vthat traverses v\u2192vcan.","The example above reveals that in the presence of the local mixing engine, assessing the channel resource incurred by a packet transmission involves some context information about where the packet arrives from. For example, we can say that given the current traffic condition, the cost for sending a packet from vto vthat previously arrives from v, is smaller. An observation here is the relevancy of defining link cost based on some context information. This leads to the concept of a Markovian metric, which is described below.","A conventional routing metric models the cost of a path as the sum of the costs on the individual links. In contrast, an example Markovian metric introduces context information into the cost modeling. The cost of sending a packet (or a stream of packets) across a link is thus allowed to depend on where the packet (or the stream) arrived from. The cost of a path is modeled as the cost of the first hop, plus the cost of the second hop conditioned on the first hop, and so on.","Definition 1 (example Markovian metric): Consider a path =v\u2192v\u2192 . . . \u2192v. A Markovian metric models the cost of a path as the sum of the conditional costs on the links as is shown by equation (L1), with \u201cL\u201d denoting a local mixing embodiment:",{"@attributes":{"id":"p-0125","num":"0124"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"cost","mo":"\u2061","mrow":{"mo":["(",")"]}},{"mrow":[{"mi":"cost","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"v","mn":"0"},{"mi":"v","mn":"1"}],"mo":"->"}}},{"mi":"cost","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"v","mn":"1"},"mo":"->","mrow":{"mrow":{"msub":[{"mi":"v","mn":"2"},{"mi":"v","mn":"0"}],"mo":"|"},"mo":"->","msub":{"mi":"v","mn":"1"}}}}},{"mrow":{"mi":"cost","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"v","mrow":{"mi":"k","mo":"-","mn":"1"}},"mo":"->","mrow":{"mrow":{"msub":[{"mi":["v","k"]},{"mi":"v","mrow":{"mi":"k","mo":"-","mn":"2"}}],"mo":"|"},"mo":"->","msub":{"mi":"v","mrow":{"mi":"k","mo":"-","mn":"1"}}}}}},"mo":"."}],"mo":["+","+","+"],"mi":"\u2026"}],"mo":["\u2062","\u2062"],"mover":{"mo":"=","mi":"\u0394"}}},{"mrow":{"mo":["(",")"],"mi":"L1"}}]}}}},"br":{}},"The conventional routing metric can be viewed as a special case of the Markovian metric where all of the conditional link costs are equal to their unconditional counterparts. The decomposition relation of equation (L1) is reminiscent of the decomposition of the joint probability distribution of random variables forming a Markov chain into a product of the conditional probabilities. Thus, a Markovian metric to an unconditional metric is like a Markov chain to a memoryless sequence of random variables.","Due to this decomposition structure, the dynamic programming principle still applies. Hence, finding the shortest path with a Markovian metric can still be done in polynomial time. In a practical network, support for the Markovian metric can be added relatively easily into an existing routing framework that uses a conventional routing metric.","2.1 The Dot Graph Representation","Properly defining the conditional and unconditional link costs and computing them are central issues in the applications of a Markovian metric. A relatively concrete example can be found below in Section 3, which is entitled \u201cMarkovian Metric for Local Mixing\u201d. In this section, we assume that we are given a set of unconditional link costs Wand a set of conditional link costs W. For ease in notation, we use wto denote an unconditional link cost \u201ccost(v\u2192v) and wto denote a conditional link cost \u201ccost(v\u2192v|v\u2192v).","A graphical representation of these costs, which is termed herein the dot graph, is described below. We denote the original graph by G and the resulting dot graph by \u0120. For the example network in , the graphical representation of the link costs is illustrated in .  is a graphical depiction of an example nine-node mesh network topology  that illustrates conditional and unconditional link costs. In this example, we assume each unconditional link cost is 1 and there are two conditional costs: w=0.5 and w=0.5. For instance, here cost(v\u2192v|v\u2192v)<cost(v\u2192v) because a packet from vto vthat arrived from vcan be mixed with the existing traffic in the flow v\u2192v\u2192v.","In a described implementation, to produce \u0120, we first add to G a dot for each directed link in the original graph, which \u201csplits\u201d the original link into two halves. Thus, there is a one-to-one correspondence between the links in the original graph G and the dots in \u0120. With slight abuse of notation, we refer to these dots as the names for the links in G; for example, the dot that splits the link from vto vis referred to as e. Therefore, \u0120 has |V(G)|+|E(G)| nodes.","Second, for each conditional link cost \u201ccost(v\u2192v|v\u2192v)\u201d in the given set W, we draw an edge from the dot eto the dot e. These edges, together with the edges generated by splitting the original links, constitute the edge set of the dot graph. To distinguish from the edges in the original graph, we call an edge in the dot graph a wire. Therefore, \u0120 has 2|E(G)|+|W| wires.","Third, we associate a cost label with each wire in \u0120. The cost of a wire from a physical node v\u03b5V(G) to a dot e\u03b5V(\u0120) is the given unconditional cost of the link, w. The cost of a wire from a dot e\u03b5V(\u0120) to a physical node v\u03b5V(G) is 0. The cost of a wire from a dot e\u03b5V(\u0120) to another dot e\u03b5V(\u0120) is wthe given conditional cost of the link.","In general, we allow the coexistence of a conditional cost and unconditional cost for the same link, e.g., a cost(b\u2192c|a\u2192b) and a cost(b\u2192c). We assume the conditional link cost is less than or equal to its corresponding unconditional link cost. This is without loss of generality because we can define the unconditional cost on a link as the maximum of the corresponding conditional link costs. The meaning is intuitive: The unconditional link cost represents a conservative estimate of the cost incurred; given further context information, the cost may be lower. For example, in , w=0.5<w=1; intuitively, there is a \u201cshort cut\u201d from eto e.","2.2 Minimum Cost Routing Using a Markovian Metric","For a described implementation and from an intuitive perspective, the dot graph models the existence of short cuts at various places in the network. It is easy to see that a path in the dot graph \u0120 maps into a route in the original network and that the cost of the route is the total cost along the path in \u0120. For instance, consider a path from vto vin \u0120 with the path identified by enumeration (L2) below:\n\nv\u2192e\u2192e\u2192v\u2192e\u2192v\u2192e\u2192v.\u2003\u2003(L2)\n\nThe above path enumeration (L2) corresponds to the physical route v\u2192v\u2192v\u2192v\u2192v. The cost of the path is: w+w+w+w=3.5. In comparison, consider the path that is identified by enumeration (L3) below:\n\nv\u2192e\u2192v\u2192e\u2192v\u2192e\u2192v\u2192e\u2192v.\u2003\u2003(L3)\n\nThe above path enumeration (L3) corresponds to the physical route v\u2192v\u2192v\u2192v\u2192v, which has a cost of 4. Therefore, path is better than path .\n","More generally, to find the minimum cost route between two physical nodes, a shortest path algorithm is applied over the dot graph. For example, with Dijkstra's algorithm, the complexity is O(|V(\u0120)|). Irrelevant dots in \u0120 can be removed. In other words, a dot emay be introduced only if there is a need to express a related conditional link cost, e.g., when Wincludes a cost w* or w*. (Here, the asterisk symbol \u201c*\u201d is used as a wildcard.) By excluding the irrelevant dots, the number of vertices in the dot graph can be reduced to O(|V(G)|+min{|E(G)|, 2|W|}).","Proposition 1 (Min-Cost Routing w\/Markovian Metric): Given a set of unconditional link costs Wand a set of conditional link costs W, the minimum cost routing from a source node s to a destination or sink node t can be found by running a shortest path algorithm over the dot graph. This can be done in complexity O((|V(G)|+min{|E(G)|, 2|W|})).","2.3 Adaptive Routing in a Practical Network","The dot graph representation makes it easier to see how to modify the existing routing protocols for a Markovian metric system. Essentially, a physical node vplays several characters in a distributed routing algorithm, including those of its neighboring dots that do not physically exist. In particular, by way of example only, the computational responsibility can be divided as follows. Let each physical node vbe responsible for its own outgoing wires of vplus the outgoing wires of its incoming dots e*. For example, in  physical node vimplements the computation involving wires e*\u2192v, v\u2192e*, e\u2192e. Example approaches to supporting a Markovian metric in two types of representative routing algorithms are described below.","1) Link State Routing: Example protocols in this category include OLSR, LQSR, and so forth. In link state routing, each router measures the cost to each of its neighbors, constructs a packet including these measurements, sends it to all other routers, and computes the shortest paths locally using this information.","To support a Markovian metric, the following changes are involved in a link state routing system. Each router can measure the unconditional and conditional costs along the links\/wires it is responsible for and broadcast the measurements to all other routers. Take node vin  as an example. Here vneeds to measure the unconditional costs to each neighbor, as well as the conditional costs of the form cost(e\u2192e).","2) Distance Vector Routing: An example protocol amongst other protocols in this category is DSDV. In distance vector routing (also known as the Bellman-Ford algorithm), each router maintains a table (i.e., a vector) giving the best known cost to reach each destination and which interface to use to get there. There tables are updated by exchanging information with the neighbors.","Let us start with a first-cut solution. Once every T milliseconds each router sends each neighbor a list of its estimated minimum cost to reach each destination. Since each physical node vis also playing the roles of its incoming dots, a first-cut implementation aggregates the tables from vand its incoming dots. For example, consider node vin . This node vis also responsible for playing the roles of e, e, e. Thus, the aggregated table includes one minimum cost from eto v, for i=1, 3, 5 and all other such destinations. The estimated minimum cost to reach destination vis denoted herein as cost(e\u02dc\u2192v). Thus, in this case, the following equality (L4) holds:\n\ncost()=cost()=cost().\u2003\u2003(L4)\n","Similar scenarios may occur whenever the conditional cost cannot lead to a lower route to the given node v. In these scenarios, sending both cost(e\u02dc\u2192v) and cost(e\u02dc\u2192v) is wasteful. To remove such redundancy, we can include in the table cost(v\u02dc\u2192v), and then cost(e*\u02dc\u2192v) only if it is lower than cost(v\u02dc\u2192v). This more efficiently utilizes communication bandwidth.","In this section, an example approach to using a Markovian metric to increase, if not maximize, the benefit of local mixing is described. An issue with this goal is properly defining the link costs and computing them. We begin the consideration of link metrics with the unconditional link metrics. Although other link metrics can be employed, one popular link quality metric is the expected transmission count (ETX). This metric estimates the number of transmissions, including retransmissions, needed to send a unicast packet across a link. It may be obtained by measuring the loss probabilities of broadcast packets between pairs of neighboring nodes.","The ETX metric can be viewed as a characterization of the amount of resource consumed by a packet transmission. With the local mixing engine, several packets may share a ride in the air. Naturally, the passengers can share the airfare. In effect, each participating source packet is getting a discount. Such a discount, however, cannot be accurately modeled by an unconditional metric such as ETX because the applicability of the discount depends on the previous hop of the packet.","In contrast, we therefore describe a conditional link metric termed herein the expected resource consumption (ERC) metric, which models the cost saving due to local mixing. Consider a packet sent in the air. If it is a mixture of k source packets, then each ingredient source packet is charged 1\/k the resource consumed by the packet transmission. The resource consumed by the transmission can be measured in terms of, e.g., air time, consumed energy, some combination thereof, and so forth.","3.1 Computation of Expected Resource Consumption (ERC)","We now describe an example scheme for computing the ERC. Each node maintains a table with wire information, such as a \u201cWireInfoTable\u201d. Each row of the table contains the measured statistics about a wire, say e\u2192e, which crosses the current node v. The packets forwarded by the current node can be classified into categories associated with the wires. A packet that is received along eand sent along efalls into the category \u201ce\u2192e\u201d.","For each wire category, we collect the total number of packets sent and the total resource consumed in a sliding time window. The total resource consumption is obtained by adding the resource consumption for each sent packet. Although other charging models may be employed, a relatively simple charging model is described herein. For example, if a source packet across wire e\u2192eis sent in a mixture of 3 packets, we set the resource consumption of this source packet as \u2153 of the ETX of link e. Alternatively, other metrics can be used in lieu of ETX, such as ETT, and so forth.","To implement the sliding window computation efficiently, the time axis can be quantized into discrete slots of equal length. A sliding window of N slots is thus used. For each wire, we maintain a circular buffer of N bins; at any time, one of the N bins is active. At the start of each slot, we shift the active bin pointer once and clear the statistics in the new active bin. Each time a packet is transmitted in the air, we update the statistics in the current active bin accordingly. By way of example only, N may be set equal to 10 slots, each with a length of length 0.5 s. Other values of i and slot lengths may alternatively be used.","To evaluate the conditional link metric for a certain wire e\u2192e, we first obtain the ERC for each slot, say n, using equation (L5) below:",{"@attributes":{"id":"p-0154","num":"0153"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":["erc","n"]},"mo":":=","mrow":{"mfrac":{"mrow":[{"mi":["Resource","consumed","by","pkts","sent","in","slot","n"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mi":["#","of","packets","sent","in","slot","n"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}]},"mo":"."}}},{"mrow":{"mo":["(",")"],"mi":"L5"}}]}}}},"br":{}},{"@attributes":{"id":"p-0155","num":"0154"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"ERC","mo":":=","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"n","mo":"=","mn":"0"},{"mi":"N","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"msub":[{"mi":["\u03b1","n"]},{"mi":["erc","n"]}],"mo":"\u2062"}}},{"msub":{"mi":["\u03b1","n"]},"mo":"=","mrow":{"mrow":{"msup":{"mi":"\u03b1","mrow":{"mi":["N","n"],"mo":["-","-"],"mn":"1"}},"mo":["(",")"],"mfrac":{"mrow":[{"mn":"1","mo":"-","mi":"\u03b1"},{"mn":"1","mo":"-","msup":{"mi":["\u03b1","N"]}}]}},"mo":"."}}],"mo":";"}},{"mrow":{"mo":["(",")"],"mi":"L6"}}]}}}},"br":{}},"The measurement method described above generates an estimate of the current ERC, which is the ERC seen by a flow whose packets are currently being mixed. In addition to the current ERC, we collect another statistic called the marginal ERC, which is the ERC meant for a flow that has not been actively using the wire. The marginal ERC represents an estimate of the ERC if a small amount of new traffic is added to a particular wire e\u2192e. If the existing flows already use up most of the mixing opportunities, then the marginal ERC will likely not have a high discount. Both the current ERC and the marginal ERC are reported.","To compute the marginal ERC in a described implementation, an example rule is applied. Specifically, for a wire e\u2192ein a given time slot, we examine the number of unmixed packets y in the reverse wire e\u2192e. If y is large enough, then there will likely be more mixing opportunities; hence we set the marginal ERC as a larger value. As a specific example, if y\u226725, then we set the marginal ERC as 0.75 of the ETX (e.g., a 25% discount); otherwise, we set the marginal ERC as the ETX (e.g., no discount). However, other marginal ERC computational approaches may alternatively be employed.","3.2 Route Stabilization Via Randomized Route Holding","In a described implementation, potential oscillations are avoided with randomized route holding. In order to model the resource reduction due to local mixing, the ERC takes the traffic load into account. This can potentially cause oscillation in the routing decisions. Notably, the discounts offered by the local mixing engine exist only when the flows cross in certain ways. Stated alternatively, the advertised discounts have restrictions; hence, only a few qualifying flows may find them attractive. Because the discounts benefit all the flows whose packets are being mixed, there is incentive for flows to route in a certain cooperative manner that is ultimately mutually beneficial.","If the flows try such a mutually beneficial arrangement for some time, they will confirm the discounts and tend to stay in the arrangement. Such an arrangement is analogous to the Nash equilibrium in game theory, where no player wants to deviate from its current strategy given all other players' strategies. However, a complication is that there can be more than one equilibrium. We want the flows to make dynamic decisions that eventually settle down to one equilibrium.","To facilitate settling down to one equilibrium, the following strategy may be implemented. To prevent potential route oscillations, we require each flow to stay for at least Tduration after each route change, where Tis a random variable. The randomization of the mandatory route holding time Tis used to avoid flows from changing routes at the same time. For an additional oscillation avoidance measure, after the mandatory route holding duration, each node may be permitted to switch to a new route only if the new route offers an appreciably smaller total cost.","An example Markovian metric is described herein. The Markovian metric models the cost of a path as the sum of the individual conditional link costs. It is somewhat analogous to the decomposition of the joint probability of a Markov chain into a product of conditional probabilities. The Markovian metric can be used to make routing decisions that better take advantage of local mixing.","An example expected resource consumption (ERC) metric is described as a conditional link metric that models the cost reduction due to local mixing. Markovian metric routing using the ERC link metric can reduce the total resource consumption of a path, leading to better system efficiency. With such a Markovian metric, flows tend to self-organize themselves toward an equilibrium arrangement that can benefit each other. Example techniques that can facilitate flows settling down into an equilibrium are also described.","The local mixing engine, on its own, can improve the link layer efficiency. It identifies mixing opportunities on the fly and takes advantage of them if they are present. Routing with a Markovian metric makes local mixing more useful as it creates more mixing opportunities. This can translate to notable resource saving and throughput gain.",{"@attributes":{"id":"p-0165","num":"0164"},"figref":["FIG. 16","FIG. 1"],"b":["1602","1602","100","102","1602","100","102","100"]},"As illustrated, two devices () and () are capable of engaging in communications via network . Communications include, by way of example but not limitation, the exchange of wireless network parameters (e.g., by broadcast or specifically addressed), interactions to effectuate a path routing, interactions to facilitate local mixing, packet forwarding for a flow, and so forth. Although two devices  are specifically shown, one or more than two devices  may be employed, depending on implementation.","Generally, a device  may represent any computer or processing-capable device, such as a server device; a workstation or other general computer device; a data storage repository apparatus; a personal digital assistant (PDA); a mobile phone; a gaming platform; an entertainment device; a router computing node; a mesh or other network node; a wireless access point; some combination thereof; and so forth. As illustrated, device  includes one or more input\/output (I\/O) interfaces , at least one processor , and one or more media . Media  include processor-executable instructions .","In a described implementation of device , I\/O interfaces  may include (i) a network interface for communicating across network , (ii) a display device interface for displaying information on a display screen, (iii) one or more man-machine interfaces, and so forth. Examples of (i) network interfaces include a network card, a modem, one or more ports, a network communications stack, a radio , and so forth. Examples of (ii) display device interfaces include a graphics driver, a graphics card, a hardware or software driver for a screen or monitor, and so forth. Examples of (iii) man-machine interfaces include those that communicate by wire or wirelessly to man-machine interface devices  (e.g., a keyboard, a remote, a mouse or other graphical pointing device, etc.).","Generally, processor  is capable of executing, performing, and\/or otherwise effectuating processor-executable instructions, such as processor-executable instructions . Media  is comprised of one or more processor-accessible media. In other words, media  may include processor-executable instructions  that are executable by processor  to effectuate the performance of functions by device . Processor-executable instructions may be embodied as software, firmware, hardware, fixed logic circuitry, some combination thereof, and so forth.","Thus, realizations for context-based routing in multi-hop networks may be described in the general context of processor-executable instructions. Generally, processor-executable instructions include routines, programs, applications, coding, modules, protocols, objects, components, metadata and definitions thereof, data structures, application programming interfaces (APIs), etc. that perform and\/or enable particular tasks and\/or implement particular abstract data types. Processor-executable instructions may be located in separate storage media, executed by different processors, and\/or propagated over or extant on various transmission media.","Processor(s)  may be implemented using any applicable processing-capable technology. Media  may be any available media that is included as part of and\/or accessible by device . It includes volatile and non-volatile media, removable and non-removable media, storage and transmission media (e.g., wireless or wired communication channels), hard-coded logic media, combinations thereof, and so forth. Media  is tangible media when it is embodied as a manufacture and\/or composition of matter. For example, media  may include an array of disks or flash memory for longer-term mass storage of processor-executable instructions , random access memory (RAM) for shorter-term storing of instructions that are currently being executed and\/or otherwise processed, link(s) on network  for transmitting communications, and so forth.","As specifically illustrated, media  comprises at least processor-executable instructions . Generally, processor-executable instructions , when executed by processor , enable device  to perform the various functions described herein. Such functions include, but are not limited to: (i) those actions that are illustrated in flow diagrams  and  (of ); (ii) the producing, transmitting, receiving, processing, etc. of link parameters and\/or path metrics; (iii) the functions of components - (of ); (iv) the virtual nodes of context-expanded graphs A, B, and  (of , , and ); and so forth.","The devices, actions, aspects, features, functions, procedures, modules, data structures, protocols, network nodes, communications, etc. of  are illustrated in diagrams that are divided into multiple blocks and other elements. However, the order, interconnections, interrelationships, layout, etc. in which  are described and\/or shown are not intended to be construed as a limitation, and any number of the blocks and\/or other elements can be modified, combined, rearranged, augmented, omitted, etc. in any manner to implement one or more systems, methods, devices, procedures, media, apparatuses, arrangements, etc. for context-based routing in multi-hop networks.","Although systems, media, devices, methods, procedures, apparatuses, mechanisms, schemes, approaches, processes, arrangements, and other implementations have been described in language specific to structural, logical, algorithmic, and functional features and\/or diagrams, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like and\/or corresponding aspects, features, and components.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 9A","FIG. 7"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 9B","FIG. 7"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 10","FIG. 7"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
