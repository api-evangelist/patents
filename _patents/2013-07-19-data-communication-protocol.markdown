---
title: Data communication protocol
abstract: Described is a data communication protocol, in which a client and server negotiate in a manner that does not require the client to retry negotiation when servers are not capable of the client-desired protocol. In one example implementation, the desired protocol is SMB 2.0 or greater. The protocol describes a create command with possibly additional context data attached for built-in extensibility, and a compound command comprising a plurality of related commands or unrelated commands. A multi-channel command requests data transfer on a separate data channel, a signed capability verification may be used to ensure that a secure connection is established, and the protocol provides the ability to transfer extended error data from the server in response to a request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09438696&OS=09438696&RS=09438696
owner: Microsoft Technology Licensing, LLC
number: 09438696
owner_city: Redmond
owner_country: US
publication_date: 20130719
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["The present application is a continuation of United States Application Ser. No. 13\/663,827 filed Oct. 30, 2012, now U.S. Pat. No. 8,825,885 issued Sep. 2, 2014, which is a continuation of United States Application Ser. No. 11\/182,251 filed Jul. 15, 2005, now U.S. Pat. 8,332,526 issued Dec. 11, 2012, which claims priority to U.S. provisional patent application Ser. No. 60\/685,008, filed May 25, 2005, and herein incorporated by reference. The present application is related to copending United States patent application entitled \u201cData Communication Coordination with Sequence Numbers\u201dU.S. Application Ser. No. 11\/182,989, filed concurrently herewith, now U.S. Pat. No. 8,316,129 issued Nov. 20, 2012, assigned to the assignee of the present invention, and hereby incorporated by reference.","Many data communication protocols that are still in use today, such as the SMB (Server Message Block) protocol, were developed at a time when computing resources were very different, e.g., network bandwidth was typically limited and memory was very precious. As a result, when used in contemporary networks, such protocols may limit overall performance. For example, because of having been designed when memory was limited, small buffer sizes are used, requiring more round trips to communicate large amounts of data.","Moreover, the existing SMB protocol has other limitations that have become apparent over time. For example, the existing SMB protocol is susceptible to denial of service attacks; the design of the protocol makes it difficult to fight these attacks. Likewise, the method for ensuring packet security is cumbersome. Also, there is no current mechanism for performing quality of service-like operations, in that a trusted client, for example, obtains the same server resources as an untrusted client.","Although various revisions, or dialects, of the SMB protocol have been developed over time, each those dialects are essentially patch-based approaches that tweak various parts to add some additional features. Thus, extensibility is not straightforward. In sum, while still a frequently-used and valuable protocol, existing SMB versions are less than ideal when used with contemporary network resources.","Briefly, various aspects of the present invention are directed towards a data communication protocol, which a client and server use for communication, such as for file sharing. The client sends a negotiation packet to a server that identifies a set of protocol dialects the client understands. The packet is in a format such that without requiring another request, a server incapable of communicating via the second data communication protocol will indicate the first communication protocol should be used. If the server is capable of communicating via the second data communication protocol, it will respond as such. The client will invoke a driver that handles communication with the server via the corresponding protocol indicated by the server. In one example implementation, the second communication protocol is SMB 2.0 or greater.","Other aspects and enhancements of the protocol may include a create command with additional context data attached, and a compound command comprising a plurality of related commands or unrelated commands. Still other aspects and enhancements include a multi-channel command related to requesting data transfer on a separate data channel, a signed capability verification request to ensure that a secure connection is established, and the ability to transfer extended error data from the server in response to a request.","When a server receives a compound request, the server determines whether the compound request contains unrelated commands or related commands. When the compound request contains unrelated commands, each request is handled as a separate request, otherwise, when the compound request contains related commands, each request is handled sequentially. When the related commands including a create\/open command, the file handle from the create\/open command is used for each subsequent related command at the server, e.g., without needing to wait for the handle back from the client.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings.","Exemplary Operating Environment",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to: personal computers, server computers, hand-held or laptop devices, tablet devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, one of variety of network appliance devices, such as print servers or printers themselves, as well as NAS storage devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in local and\/or remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules  and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, described above and illustrated in , provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a tablet, or electronic digitizer, , a microphone , a keyboard  and pointing device , commonly referred to as mouse, trackball or touch pad. Other input devices not shown in  may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . The monitor  may also be integrated with a touch-screen panel or the like. Note that the monitor and\/or touch screen panel can be physically coupled to a housing in which the computing device  is incorporated, such as in a tablet-type personal computer. In addition, computers such as the computing device  may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface  or the like.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Data Communication Protocol","Various aspects of the technology described herein are directed towards a data communication protocol, such as a later version (2.x or greater) of the SMB protocol. In one example implementation generally described herein, the SMB protocol is used for file data transfer. However, as can be readily appreciated, the present invention is not limited to file data, let alone any particular implementation or examples described herein. Instead, numerous ways to implement the present invention are feasible, including for use in communication with printers, named data pipes, generic devices and so forth. As such, the present invention is not limited to any of the particular file-based examples used herein, but rather may be used numerous ways that provide benefits and advantages in computing in general.","Other various aspects of the technology described herein are directed towards a new revision of SMB upon which file-server interaction may be built. As will be understood, a more lightweight protocol is provided that supports existing (up-level) functionality, along with being more scalable and easier to update with new features.","Turning to  of the drawings, there is shown a block diagram representing an example networking environment in which a client  communicates with a server  through one or more communication channels. Although the functions and components of the client machine  and the server  are described as being located within two separate computers, such as the main computer system  and remote computer system  of , the components of these two computers or the functions performed thereby may be provided on one machine, or may be distributed over a number of computers.","Network file system commands from an application program  are handled by a client redirector component , which communicates with a counterpart common network module (SRVNET)  to carry out the commands on the file system . Before such commands are processed, a communication protocol that the client and server agree upon, generally the most recent version\/dialect that both understand, is negotiated.","In general, the client  establishes a connection and then negotiates with the server  to ultimately set up a session, as generally represented in . While a client may directly indicate to a server that it is an SMB 2.x client, (wherein as used herein, the number 2.x represents any newer version relative to existing SMB 1.x versions), a client may also negotiate via a backwards-compatible negotiation packet. In this way, a client can also communicate with a server that is only SMB 1.x capable, yet do so without needing to set up a separate connection should an attempt at a higher-level negotiation fails. At the same time, the code for implementing each protocol may be packaged into its own independent driver.","In one example implementation, a client SMB engine component  provides a packet to a server (e.g., the server ) that indicates that the client  is negotiating at least an SMB 1.0 session. For a client  that speaks both the SMB1 dialects and the new SMB2 revision of the protocol, the client may send a traditional SMB1 negotiate packet, but that further contains an indication that this packet is actually requesting SMB 2.x, if available. An SMB2-capable server will detect this request and respond with an SMB2 negotiate response. More particularly, to indicate that the client  is capable of SMB 2.x, the SMB 1.0 negotiation packet includes a set of dialect strings, one of which indicates that the client is also capable of SMB 2.x communication.","The client  thus sends an initial negotiate that includes the minor revision numbers that the client  supports. One current revision is 0 (zero), i.e., SMB 2.0; in the future, a client may claim to support any subset of the dialect revisions.","When the server  receives the packet, it will respond based on its capabilities. A server  may respond with an SMB 1.0 negotiation response, along with any 1.x dialect information, or if capable of SMB 2.x communication, will respond with an SMB 2.0 negotiation response. A particular SMB dialect revision may also be returned that matches one of the dialect strings, ordinarily the largest numbered version that the server  can handle among the dialect versions that the client  provided.","To this end, once the server  knows which dialect revisions the client  speaks, it compares these to the revisions that the server  understands, and returns the preferred common dialect revision (which will usually be the highest). For example, if the server supports dialects 1-8, but the client only supports 1, 2 and 4, the server will return 4. This gives the client  a clear understanding of which commands it will be able to send to the server . To select which dialect to use, the SRVNET module  essentially starts a negotiation, handing the packet to each SMB provider -that it has, from highest to lowest in order with respect to versions\/dialects, until one SMB provider agrees to handle this communication session based on the packet contents. Thereafter, communications on this connection are routed to that provider, in this example the SMB 2.0 provider .","At the client end, the SMB engine component  receives the response, and based on the version\/dialect information in the response, knows which client SMB component -to use to communicate with the server. In this manner, both the client  and server  agree on which SMB dialect to use for a given session. Note that a client may have multiple SMB components -running at the same time, each a different version\/dialect, whereby, for example, a client may be communicating with one server over SMB 1.x at the same time the client is communicating with another server over SMB 2.x.","The server  also returns other information to the client, including a security mode which tells the client  whether the server  will require security signatures. Note that previously, security signatures were available, however the first few (e.g., capabilities negotiation) packets were in the clear, whereby an attacker could force a client into a lower-level protocol in which the attacker knows its vulnerabilities.","Secure connect operates by providing another, capabilities verification round-trip that is signed, (regardless of whether signing is enabled or not).  shows such a request\/response following session setup. Other information can be put in the packet, such as an IP address, so that the server can actually verify that it, and not another entity, responded. Signing can be turned off if IPSEC or any other form of network security is active.","The server  may return capabilities bits for the server, e.g., whether the server is DFS (Distributed File System) aware, and whether it is LWIO (Lightweight IO) capable. The client  disregards any capability bits it does not understand, which may happen if the server  has a newer version than the client's corresponding version. Other information that may be returned in the negotiate exchange includes the server's unique ID, the maximum read\/write size the server will accept, a data offset hint for faster write processing, the current system time of the server, and security information used to seed authentication in the case of extended security.","Session setup handles the authentication process for a new session, which may be a multiple round-trip event. The client  queries the local security system for a security blob to send over the network, and sends the first session setup, filling in the capabilities, the maximum size fields, and a VcNumber, described below. The server  receives this blob and gives it to the security system. If the server  determines that more information is needed, it will return its own security blob with the error code STATUS_MORE_PROCESSING_REQUIRED. The client  passes this blob back to the local security system, and the process will repeat until a failure occurs or authentication is successful.","The VcNumber tells the server  whether there may be other connections established from this same client . If this is zero, the server  assumes no other connections have been made from this client, and will tear down any such connections it finds (assuming them to be stale). If the VcNumber is one or more, the server  will not tear down any existing connections.","The Channel tells the server  that this client  is attempting to establish another connection with an existing session. The session can be identified by the user\/computer pair from which this session setup was received. The channels share the same TreeId\/UserId\/ProcessId\/FileId information. For a channel authentication, the authentication blob may be a challenge-response that is encrypted across the first channel and sent back out across the second channel to allow the client  and server  to mutually authenticate each other. On a successful response, the server  will also notify the client  if it has been authenticated as Guest or as a Null user, if either is applicable.","Once a session is set up, the client  may perform data transfer using the various commands described below, including create, read, write and close, as well as perform file locking and directory-related operations. As described in the aforementioned \u201cData Communication Coordination with Sequence Numbers\u201d patent application, when using these commands, the server is able to control the client's use of server resources. Also, the protocol provides a number of efficiency improvements with respect to what information is communicated, and how it is communicated.","As generally represented in , the create command has been extended to allow context information to be attached to the command; in general, the context information comprises arbitrary extra create parameters that are tagged to the create command. For example, a transaction identifier for a transactional file system-related create command may be attached. As long as the server understands the extra context information, the server can be informed of the extended information, (note that servers will ignore extra data that they not understood), and return information associated with the context. As can be readily appreciated, this provides for additional functionality without changing the protocol, essentially providing built-in extensibility.","Command IDs and dialect revision numbers are provided for in a new SMB header, set forth below. The header has a USHORT for the command field as opposed to a UCHAR; by using the first byte of this USHORT to denote the dialect, and the latter byte to denote the command, the command table is well defined for existing commands, with a large proportion open for later expansion. In general, the client may maintain a table for each dialect that contains the pointers to the function to issue a given command. For a client with a single dialect supported, the table would be as set forth below:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Command","Dialect #1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Create","SmbCreate1"]},{"entry":[{},"Read","SmbRead1"]},{"entry":[{},"Write","SmbWrite1"]},{"entry":[{},"Close","SmbClose1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"For caching functionality, more information may be retrieved from the file on Close. As such, a new Close command is provided to support this new functionality. Now the client supports two dialects, and the table is as set forth below:",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Command","Dialect #2","Dialect #1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Create","SmbCreate1","SmbCreate1"]},{"entry":[{},"Read","SmbRead1","SmbRead1"]},{"entry":[{},"Write","SmbWrite1","SmbWrite1"]},{"entry":[{},"Close","SmbClose2","SmbClose1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Note that most of the functionality stayed the same, except for the changed Close command. Also, the client can now talk to Dialect 2 servers and use the new functionality, but for Dialect 1 servers it still uses the old functionality. There are no changes to the communicating with Dialect 1 servers.","As technology evolves, new network hardware becomes available, such as capable of performing relatively much larger reads and writes. For this release, Dialect #3 is provided, whereby the table is enlarged as follows:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Command","Dialect #3","Dialect #2","Dialect #1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Create","SmbCreate1","SmbCreate1","SmbCreate1"]},{"entry":[{},"Read","SmbRead3","SmbRead1","SmbRead1"]},{"entry":[{},"Write","SmbWrite3","SmbWrite1","SmbWrite1"]},{"entry":[{},"Close","SmbClose2","SmbClose2","SmbClose1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}}}},"A client with such a table can speak the three dialects, and will take advantage of the functionality that is available in each dialect. Some advantages of using this method include that each SMB command can be mapped back to the dialect it was introduced into, because the command is made of (Dialect Command). This makes it easy to determine when commands were introduced, and what servers support them. If the functionality for a given command is not changed in a new dialect, the code does not change. If the functionality is changed, the down-level interface code does not change, but rather new code is added to support the new functionality.","On the server side, a server dispatch table becomes a double switch between (Dialect) and (Command). This allows for logically separating the new functionality in the code, making it easier to understand and change.","Turning to one aspect of the protocol that provides efficiency, multiple commands may be compounded into a single packet, (or some lesser number of packets). Complex tasks may thus be performed in a manner that reduces the number of round trips between the client  and server . By way of example, a compound request packet may contain a command to create\/open a file, a command to write to the file and a command read from the file. Compounding thus works with related operations, (e.g., having the same file handle) and also provides for unrelated operations to be combined.","An example of compounding related requests is generally represented in , where (in contrast to , for example) a single request can handle a write and read, providing the appropriate parameters. Note that as represented in , a single request may receive a compound response and\/or individual responses, depending, for example, on when they complete. More complex requests, such as create\/open, read, write and close may be in a single request. This is accomplished by marking a packet as having related operations; the server will know that the file handle it receives following the create\/open applies to the other commands in the compound request. Note, however, that related compound requests are handled in the order they are packaged, and thus it is up to the client to ensure they are ordered correctly before sending.","Compounding in SMB2 is simpler than the complex rules that existed in SMB1. To this end, the SMB2 HEADER (detailed below) contains a \u201cNextOffset\u201d that is used to identify the offset of the header of the next command from the header of the current command. Each command has its own SMB2_HEADER, including a separate MessageId. The server response or responses may come as a single compounded response, or as separate responses, as represented in . In the event of a failure, the response would be the same as any other failed command.","For unrelated messages, the commands will always be processed as if they were received separately. This allows a redirector or intermediate component to automatically compound packets that are unrelated. A delay may be used to obtain packets to compound, particularly if the delay time is small relative to the round-trip time. Because the server treats them as received separately, the server need not be otherwise modified to unpack such compound unrelated requests. The entity that performed the compounding may have to separate any compound responses, however, since the server may combine otherwise separate responses.","The related mode allows the client to send a series of commands that are to be executed in sequence with the result of one command potentially being used in the next command. Such commands share the same Session\/Process\/Tree\/File ID, they will be executed sequentially, and will stop processing on the first error. If there were other commands to process after the failure, the operations are immediately failed with STATUS_NOT_PROCESSED. An example of how this may be used is to pair a Session Setup with a Tree Connect. If the session fails to be established, the tree connect will never be attempted and will fail with STATUS_NOT_PROCESSED. If the session setup succeeds, the tree connect is done using the SessionId from the session setup command. The same method could be used to do a Create followed by a QueryFileInformation, or even a Create-Read-Close set.","Conditional and implied compounding are also feasible. For example, a conditional compound command may be sent, such as open and also read if the file is less than 64 KB, thus opening and automatically obtaining small files in one round trip, but only opening large files. Implied compounding, such as automatically returning directory enumeration data in response to an open directory request, even if not expressly requested, may also cut down round trips. The benefits and advantages to such enhanced compounding increase in high-latency networks.","Another way in which the protocol facilitates improved efficiency is via multiple channel communication. Between a client and server, a transport connection for commands may be used, with a command that specifies an alternate channel to stream data. For example, a read request may specify the offset and length as well as an alternate channel to read data into; a write request operates similarly.  shows an example of a 1 GB read request starting from offset 0 and requesting the data to be streamed to data channel 5.","Streaming data on an alternate channel provides a number of benefits, includes eliminating the need to include and process packet headers. The client can pre-post a buffer and have the data streamed therein, eliminating the need to copy from one buffer to another as in conventional single-channel communication. Fairness is another benefit, in that, for example, one request on the control channel will not have to wait for a large amount of data (e.g., 5 GB) to complete be transmitted before that other request is handled, because the 5 GB will go over the data channel.","As multiple NIC's are becoming more common, the protocol takes advantage of any available network bandwidth. This includes working across multiple connections for the same session, regardless of the transport (or NIC) on which they are established. Specialized hardware may be employed.","Thus, with SMB 2.x, a session is not bound to a connection. Instead, multiple \u201cchannels\u201d may be established that exist across different physical connections. Sessions can exist on each of these connections, and the IDs used to refer to files and processes are common across channels. This allows for having a normal channel for doing namespace operations and creates, but using specialized network hardware for reads and writes when available. Still further, small network glitches may not result in lost data, because as long as one channel remains open to a session, the session stays alive. Various implementation details are described herein with reference to the Session Setup command and the Read\/Write commands.","By way of example, consider a client that establishes a connection over simple TCP to the server over an enterprise's public network. This is the first connection, so it is always channel 0. Once both sides detect that they have a private network for doing data transfers, (e.g., each has a gigabit card), the client and server may establish a second connection over this card, as channel 1. While the client is browsing some files, the directory queries are being sent over channel 0, while the data is being sent over channel 1. If the client wants to browse into some directories that are encrypted on the server, when the client requests the data, the redirector realizes that the data is sensitive, so it establishes a new channel (channel 2) to the server that has IP Sec (IP security) active on it. When the client requests the sensitive data, it will ask it be sent over channel 2, while normal less-sensitive data could continue to come over channel 1 (as it is faster).","As can be readily appreciated, the opportunity for QoS and security improvements, along with the simple bandwidth gain, provides significant benefits. Note that on a channel read\/write, the server\/client can lay down the receive buffer before any data is read, so the mechanism can further eliminate the need to copy out of the data movement, which can also improve server\/client scalability.","Further, SMB error packets are allowed to be tagged with arbitrary data. Thus, a description of why something failed, which may provide value. Symbolic link evaluation is one example where tagging with arbitrary data provides a client with useful information, as generally represented in . Essentially, a client create request may fail by asking for a path that is actually a symbolic link to another path. Instead of simply failing the request, information providing the new path allows the client to change to a reparse path, which will ultimately succeed; note that iteration over a number of requests may be required to find a path that will succeed.","Example Protocol Definition","The new header is a 64-byte structure (e.g., twice the size of one current structure).",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _SMB2_HEADER {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UCHAR","Protocol[4];","\/\/ Contains 0xFE,\u2018S\u2019,\u2018M\u2019,\u2018B\u2019"]},{"entry":[{},"USHORT","StructureSize;","\/\/ = sizeof(SMB2_HEADER)."]},{"entry":[{},{},{},"\/\/ (versioning)"]},{"entry":[{},"USHORT","Epoch;","\/\/ incremented every time the"]},{"entry":[{},{},{},"\/\/ server restarts"]},{"entry":[{},"NTSTATUS","Status;","\/\/ Status of the command"]},{"entry":[{},"USHORT","Command;","\/\/ The command for this packet"]},{"entry":[{},{},{},"\/\/ union"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003USHORT","CreditsRequested;","\/\/ On client send, request for"]},{"entry":[{},{},{},"\/\/ more credits"]},{"entry":[{},"\u2003\u2003USHORT","CreditsGranted;","\/\/ On server response, credits"]},{"entry":[{},{},{},"\/\/ granted to client"]},{"entry":[{},"};"]},{"entry":[{},"ULONG","Flags;"]},{"entry":[{},"ULONG","Reserved;"]},{"entry":[{},"UINT64","MessageId;","\/\/ Identifies this message"]},{"entry":[{},{},{},"\/\/ send\/response"]},{"entry":[{},"union"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003struct"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003UINT64","ProcessId;","\/\/ Process identifier"]},{"entry":[{},"\u2003\u2003\u2003\u2003UINT64","SessionId;","\/\/ Session identifier"]},{"entry":[{},"\u2003\u2003\u2003\u2003ULONG","TreeId;","\/\/ Tree Connect identifier"]},{"entry":[{},"\u2003\u2003};"]},{"entry":[{},"\u2003\u2003struct"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003UINT64","AsyncId;","\/\/ Used to identify long standing"]},{"entry":[{},{},{},"\/\/ commands"]},{"entry":[{},"\u2003\u2003};"]},{"entry":[{},"};"]},{"entry":[{},"UCHAR","Signature[8];","\/\/ Signature for the packet"]},{"entry":[{},"ULONG","NextCommand;","\/\/ Offset from to next"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} _SMB2_HEADER, *PSMB2_HEADER;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Protocol is simply the protocol identifier, to identify the packet. For the existing SMB implementations, this consists of {0xFF, \u2018S\u2019, \u2018M\u2019, \u2018B\u2019}. For the new protocol this shall be {0xFE, \u2018S\u2019, \u2018M\u2019, \u2018B\u2019}.","StructureSize identifies the size of the SMB2 HEADER structure, and will be used for minor versioning within the Header itself, if other changes are introduced later on.","Epoch represents the \u201cversion count\u201d of a server. This is incremented when a server is cycled (or the server service is stopped and started) to indicate to the client whether the server might have maintained state across a disconnect. This is for future use with persistent handles, and can be considered \u201cReserved\u201d for the time being.","Status gives the error status for a given operation, as in the existing SMB implementation.","Command identifies the command for the packet, as described herein.","CreditsGranted\/CreditsRequested are used by the client on a send to request more credits, and by the server on the response to grant more credits within the new credit management scheme, as described in the related patent application entitled \u201cData Communication Coordination with Sequence Numbers.\u201d","Flags related to the message include:","#define SMB2_FLAGS_SERVER_TO_REDIR 0x00000001","When present, indicates the message is a response as opposed to a request","#define SMB2_FLAGS_ASYNC_COMMAND 0x00000002","On response, the server returns STATUS_PENDING with this flag set to indicate that we are processing it asynchronously.","#define SMB2_FLAGS_RELATED_OPERATIONS 0x00000004","Set on a client message send of a compounded message to indicate that the operations are related, so the file opened in the Create is used as the FileId for later operations.","#define SMB2_FLAGS_SIGNED 0x00000008","Set when the packet has been signed. The receiver should verify the signature. The key used for signing is based on the session that sent the packet.","#define SMB2_FLAGS_DFS_OPERATION 0x10000000","This is a DFS operation. The server should allow DFS to munge the name. This could be replaced with a create option.","MessageId Identifies a message being sent with its response.","ProcessId describes the client-side identification of the process issuing the command.","SessionId identifies the established session for the command, or 0 if no session is being used.","TreeId Identifies the tree connect for the command, or 0 if no tree connect is being used.","AsyncId: as described in the related patent application entitled \u201cData Communication Coordination with Sequence Numbers,\u201d message IDs are actually sequence numbers, and the window of available sequence numbers is always set to slide to the right. A command that will run for an extremely long time (such as a named-pipe read or change-notification, or a create that pends on an oplock break, any of which can block indefinitely) may hold up the ability of the window to slide. To work around this issue, the server can optionally respond to any command with STATUS_PENDING and setting the SMB2_FLAGS_ASYNC_COMMAND flag mentioned above and providing a unique identifier in place of the Session\/Tree\/ProcessId. This means the client can continue sliding the window as if it received a response. At some point later, the true response will come with a matching AsyncId (and CommandId) to satisfy the request. In the event that the client wants to cancel such a command, the client sends a cancel with the flag set and the matching AsyncId.","The security signature is the same as in the previous protocol, except that there is no longer a hidden index number. The index is not necessary with the use of sequence numbers for the MID. (This prevents replayability directly). This allows the use of security signatures without forcing the operations to be sequenced on their way to the transport.","NextCommand is the offset of the next command in the message from the beginning of this header. Messages should be quad-aligned. The use of the SMB2_FLAGS_RELATED_COMMAND allows various abilities for compounding, as described above.","Command Formats","Negotiate","As described above, the client and server exchange negotiate request and response as part of the handshake that helps them determine each other's capabilities.",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["%define SMB2_NEGOTIATE_SIGNING_ENABLED","0x01"]},{"entry":["#define SMB2_NEGOTIATE_SIGNING_REQUIRED","0x02"]},{"entry":["#define SMB2_GLOBAL_CAP_DFS","0x00000001"]},{"entry":["#define SMB2_GLOBAL_CAP_LWIO","0x00000002"]},{"entry":["#define SMB2_GLOBAL_CAP_TXF","0x00000004"]},{"entry":["#define SMB2_GLOBAL_CAP_CSE","0x00000008"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _SMB2_REQ_NEGOTIATE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"USHORT StructureSize;","\/\/ = sizeof(SMB2_REQ_NEGOTIATE)"]},{"entry":[{},"USHORT Reserved;","\/\/ = 0"]},{"entry":[{},"ULONG DialectCount;","\/\/ Number of dialects we support"]},{"entry":[{},"USHORT Dialects[ ];","\/\/ Array of dialect revision"]},{"entry":[{},{},"\/\/ numbers."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_NEGOTIATE, *PSMB2_REQ_NEGOTIATE;"},{"entry":"typedef struct _SMB2_RESP_NEGOTIATE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"USHORT StructureSize;","\/\/ = sizeof(SMB2_RESP_NEGOTIATE)"]},{"entry":[{},"USHORT SecurityMode;","\/\/ = signing flags"]},{"entry":[{},"USHORT DialectRevision;","\/\/ Server selected dialect from"]},{"entry":[{},{},"\/\/ received list"]},{"entry":[{},"USHORT Reserved;"]},{"entry":[{},"GUID ServerGuid;","\/\/ Server generated GUID"]},{"entry":[{},"ULONG Capabilities;","\/\/ Global server capability flags"]},{"entry":[{},"ULONG MaxTransactSize;","\/\/ Largest transact buffer we will"]},{"entry":[{},{},"\/\/ accept or send"]},{"entry":[{},"ULONG MaxReadSize;","\/\/ Largest size read supported"]},{"entry":[{},"ULONG MaxWriteSize;","\/\/ Largest size write supported"]},{"entry":[{},"UINT64 SystemTime;","\/\/ System (UTC) time on the server"]},{"entry":[{},"USHORT EncryptionKeyOffset;"]},{"entry":[{},"USHORT EncryptionKeyLength;"]},{"entry":[{},"USHORT SecurityBufferOffset;"]},{"entry":[{},"USHORT SecurityBufferLength;"]},{"entry":[{},"UCHAR Buffer[1];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_NEGOTIATE, *PSMB2_RESP_NEGOTIATE;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"As described above, Session Setup handles the authentication process for a new session.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _SMB2_REQ_SESSION_SETUP"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"USHORT StructureSize;","\/\/ = sizeof(SMB2_REQ_SESSION_SETUP)"]},{"entry":[{},"USHORT VcNumber;","\/\/ 0 = first connection, nonzero ="]},{"entry":[{},{},"\/\/ additional"]},{"entry":[{},"ULONG Capabilities;","\/\/ Capabilities of the client."]},{"entry":[{},"ULONG Channel;","\/\/ nonzero = binding new channel to"]},{"entry":[{},{},"\/\/ session"]},{"entry":[{},"USHORT SecurityBufferOffset;"]},{"entry":[{},"USHORT SecurityBufferLength;"]},{"entry":[{},"UCHAR Buffer[1];","\/\/ Security buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} SMB2_REQ_SESSION_SETUP, *PSMB2_REQ_SESSION_SETUP;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_SESSION_FLAG_IS_GUEST","0x0001"]},{"entry":["#define SMB2_SESSION_FLAG_IS_NULL","0x0002"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _SMB2_RESP_SESSION_SETUP"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"USHORT StructureSize;","\/\/ ="]},{"entry":[{},{},"\/\/ sizeof(SMB2_RESP_SESSION_SETUP)"]},{"entry":[{},"USHORT SessionFlags;"]},{"entry":[{},"USHORT SecurityBufferOffset;"]},{"entry":[{},"USHORT SecurityBufferLength;"]},{"entry":[{},"UCHAR Buffer[1];","\/\/ Security buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Logs off an existing session.",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _SMB2_REQ_LOGOFF {"]},{"entry":[{},"\u2003\u2003USHORT StructureSize;"]},{"entry":[{},"\u2003\u2003USHORT Reserved;"]},{"entry":[{},"} SMB2_REQ_LOGOFF;"]},{"entry":[{},"typedef struct _SMB2_RESP_LOGOFF {"]},{"entry":[{},"\u2003\u2003USHORT StructureSize;"]},{"entry":[{},"\u2003\u2003USHORT Reserved;"]},{"entry":[{},"} SMB2_RESP_LOGOFF;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"This command tears down the session with the SessionId specified in the header. Open files are closed, and other existing structures (tree connects, etc.) are torn down. No more operations can be processed for the given SessionId.","Tree Connect","Creates a tree connection to a shared resource on the server machine.",{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _SMB2_REQ_TREE_CONNECT"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"USHORT StructureSize;","\/\/ = sizeof"]},{"entry":[{},{},"(SMB2_REQ_TREE_CONNECT)"]},{"entry":[{},"USHORT Reserved;"]},{"entry":[{},"USHORT PathOffset;","\/\/ Full path (i.e. \\\\SERVER\\SHARE)"]},{"entry":[{},"USHORT PathLength;"]},{"entry":[{},"UCHAR Buffer[1];"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_TREE_CONNECT,"},{"entry":"*PSMB2_REQ_TREE_CONNECT;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_SHAREFLAG_MANUAL_CACHING","0x00000000"]},{"entry":["#define SMB2_SHAREFLAG_AUTO_CACHING","0x00000001"]},{"entry":["#define SMB2_SHAREFLAG_VDO_CACHING","0x00000002"]},{"entry":["#define SMB2_SHAREFLAG_NO_CACHING","0x00000003"]},{"entry":["#define SMB2_SHAREFLAG_CACHING_FLAGS","0x00000003"]},{"entry":"\/\/ Reserved share cap 0x00000001"},{"entry":"\/\/ Reserved share cap 0x00000002"},{"entry":"\/\/ Reserved share cap 0x00000004"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_SHARE_CAP_DFS","0x00000008\u2003\/\/ This is a"]},{"entry":[{},"DFS share"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_SHARE_TYPE_DISK","0x01"]},{"entry":["#define SMB2_SHARE_TYPE_PIPE","0x02"]},{"entry":"typedef struct _SMB2_RESP_TREE_CONNECT"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"USHORT StructureSize;","\/\/ = sizeof"]},{"entry":[{},{},"(SMB2_RESP_TREE_CONNECT)"]},{"entry":[{},"UCHAR ShareType;"]},{"entry":[{},"UCHAR Reserved;"]},{"entry":[{},"ULONG\u2003ShareFlags;"]},{"entry":[{},"ULONG\u2003Capabilities;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_TREE_CONNECT,"},{"entry":"*PSMB2_RESP_TREE_CONNECT;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The client issues this command to the server to establish a tree connection. The Path is of the form \\\\server\\share and is filled into the buffer. Inclusion of the server name allows for features like share scoping.","On successful response from the server, the client receives the TreeId in the header along with the ShareFlags and ShareCapabilities. Currently, the share flags indicate to the client what the CSC caching properties are for a share, but more may be added later on. The capabilities tell the client whether the file system backing the share supports either file-level security, timewarp, TxF (transactional file system), or client-side encryption. If a file system supports these properties on some subtrees but not all (such as the case of mount points), it should return that it does support them and simply fail the individual requests to use them in cases where it is not allowed. The client should ignore any flags or capabilities it does not understand.","Tree Disconnect","Tears down an existing TreeConnect.",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _SMB2_REQ_TREE_DISCONNECT {"]},{"entry":[{},"\u2003\u2002\u2009USHORT StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT Reserved;"]},{"entry":[{},"} SMB2_REQ_TREE_DISCONNECT;"]},{"entry":[{},"typedef struct _SMB2_REQ_TREE_DISCONNECT {"]},{"entry":[{},"\u2003\u2002\u2009USHORT StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT Reserved;"]},{"entry":[{},"} SMB2_REQ_TREE_DISCONNECT;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Once the command is processed, no more operations can be successfully completed on the given TreeId. The TreeId is taken from the header.","Create","Opens a file, printer, or pipe.",{"@attributes":{"id":"p-0110","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_OPLOCK_LEVEL_NONE","0"]},{"entry":["#define SMB2_OPLOCK_LEVEL_II","1"]},{"entry":["#define SMB2_OPLOCK_LEVEL_EXCLUSIVE","8"]},{"entry":["#define SMB2_OPLOCK_LEVEL_BATCH","9"]},{"entry":["#define SMB2_OPLOCK_LEVEL_DIRCHANGE","16"]},{"entry":"typedef struct _SMB2_REQ_CREATE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\/\/ = sizeof(SMB2_REQ_CREATE)"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002SecurityFlags;","\/\/ QOS security flags"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002RequestedOplockLevel;","\/\/ Desired oplock level"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002ImpersonationLevel;","\/\/ QOS security info"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009SmbCreateFlags;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009RootDirectoryFid;","\/\/ For relative opens"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2002\u2009ACCESS_MASK DesiredAccess;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002FileAttributes;",{}]},{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002ShareAccess;"]},{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002CreateDisposition;"]},{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002CreateOptions;"]},{"entry":["\u2003\u2002\u2009USHORT","\u2003\u2002NameOffset;","\/\/ Name relative to share"]},{"entry":["\u2003\u2002\u2009USHORT","\u2003\u2002NameLength;"]},{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002CreateContextsOffset;","\/\/ Extra create parameters"]},{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002CreateContextsLength;"]},{"entry":["\u2003\u2002\u2009UCHAR","\u2003\u2002Buffer[1];","\/\/ Name[ ], CreateContexts[ ]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_CREATE, *PSMB2_REQ_CREATE;"},{"entry":"typedef struct _SMB2_CREATE_CONTEXT"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002Next;"]},{"entry":["\u2003\u2002\u2009USHORT","\u2003\u2002NameOffset;"]},{"entry":["\u2003\u2002\u2009USHORT","\u2003\u2002NameSize;"]},{"entry":["\u2003\u2002\u2009USHORT","\u2003\u2002Reserved;"]},{"entry":["\u2003\u2002\u2009USHORT","\u2003\u2002DataOffset;"]},{"entry":["\u2003\u2002\u2009ULONG","\u2003\u2002DataSize;"]},{"entry":["\u2003\u2002\u2009UCHAR","\u2003\u2002Buffer[1];\u2003\/\/ Name[ ], Data[ ]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} SMB2_CREATE_CONTEXT, *PSMB2_CREATE_CONTEXT;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["typedef struct _SMB2_RESP_CREATE",{}]},{"entry":"{"},{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\/\/ = sizeof(SMB2_RESP_CREATE)"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002OplockLevel;","\/\/ The oplock granted on the file"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002Reserved;"},{"entry":["\u2003\u2002\u2009ULONG \u2002CreateAction;","\/\/ Action taken by create"]},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009FileId;","\/\/ ID for this open"]},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009CreationTime;","\/\/ File time information"]},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009LastAccessTime;"},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009LastWriteTime;"},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009LastChangeTime;"},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009AllocationSize;","\/\/ File size information"]},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009EndOfFile;"},{"entry":["\u2003\u2002\u2009ULONG\u2002\u2009FileAttributes;","\/\/ NT attributes of the file"]},{"entry":["\u2003\u2002\u2009ULONG Reserved2;","\/\/ For 8-byte alignment"]},{"entry":["\u2003\u2002\u2009ULONG CreateContextsOffset;","\/\/ Responses for Extra Create"]},{"entry":[{},"\/\/ Parameters"]},{"entry":"\u2003\u2002\u2009ULONG CreateContextsLength;"},{"entry":["\u2003\u2002\u2009UCHAR Buffer[1];","\/\/ CreateContexts[ ]"]},{"entry":"} SMB2_RESP_CREATE, *PSMB2_RESP_CREATE;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_CREATE_EA_BUFFER","(ULONG)(\u2018AtxE\u2019)"]},{"entry":["#define SMB2_CREATE_SD_BUFFER","(ULONG)(\u2018DceS\u2019)"]},{"entry":["#define SMB2_CREATE_MARSHALLED_TRANSACTION","(ULONG)(\u2018xTrM\u2019)"]},{"entry":["#define SMB2_CREATE_MINIVERSION","(ULONG)(\u2018rVnM\u2019)"]},{"entry":["#define SMB2_CREATE_VERSION","(ULONG)(\u2018sreV\u2019)"]},{"entry":["#define SMB2_CREATE_NTFS_FID","(ULONG)(\u2018diFN\u2019)"]},{"entry":["#define SMB2_CREATE_TIMEWARP_TOKEN","(ULONG)(\u2018prWT\u2019)"]},{"entry":["#define SMB2_CREATE_EFS_STREAM","(ULONG)(\u2018sfE$\u2019)"]},{"entry":["#define SMB2_CREATE_CLIENT_SIDE_ENCRYPTION","(ULONG)(\u20181ESC\u2019)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The create request is a variable length request to allow creation of files with various attributes other than the traditional well-defined attributes. The standard case (where no extended attributes are present) is straightforward; the client fills in the RootDirectoryFid (for a relative open if desired), the DesiredAccess, FileAttributes, ShareAccess, CreateDisposition, and CreateOptions. They set the desired oplock level, and fill in the SecurityFlags & Impersonation level for QoS. Currently there are no SmbCreateFlags defined but space has been allocated for their use. The client sends this packet to the server, which opens the file and either returns a failure code, or returns Success along with the FileId that identifies the file, the Creation\/LastAccess\/LastWrite\/LastChangeTime, the AllocationSize and EndOfFile information, and the FileAttributes.","That is the normal case that operates in much the same way that the current protocol does. For more advanced cases, consider that the user wants to create a file with extended attributes (EAs). In the previous protocol, there was an entirely different way of handling this, through a Transact call. Now, the client can build up the create request as normal, but also add a CreateContext to the end of the create request. The request would have the name \u201cExtA\u201d and the Data would contain the EAs to set on the file. When the server receives this, it would parse out the EA data and issue it with the create. Create contexts can also be returned on the create response to provide additional information. For the first iteration, the names will be of length  so we can format them as a long and switch on them. The current list of CreateContext's is as follows:\n\n","A client sends a Close to close an instance of a file that was opened previously. Once a close is processed, no file operations are allowed on the previous FID.",{"@attributes":{"id":"p-0114","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct _SMB2_REQ_CLOSE {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2002\u2009USHORT","\u2003\u2003StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT","\u2003\u2003Reserved;"]},{"entry":[{},"\u2003\u2002\u2009ULONG","\u2003\u2003Flags;"]},{"entry":[{},"\u2003\u2002\u2009UINT64","\u2003\u2003FileId;"]},{"entry":[{},"\u2003\u2002\u2009UINT64","\u2003\u2003LastWriteTime;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} SMB2_REQ_CLOSE, *PSMB2_REQ_CLOSE;"]},{"entry":[{},"typedef struct _SMB2_RESP_CLOSE {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2002\u2009USHORT","\u2003\u2003StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT","\u2003\u2003Reserved;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} SMB2_RESP_CLOSE, *PSMB2_RESP_CLOSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"For the Close command, the client specifies the FileId of the file being closed, along with the LastWriteTime (in SystemTime format). This allows the client to set the last time a cached write was performed on the file as the last written time on the file. The client can also send zero for the LastWriteTime to indicate that they do not wish to specify one. The structure also allots room for Close flags which are currently undefined, but may be used at a later point.","Flush","A flush command informs the server to flush out all cached data on a given file.",{"@attributes":{"id":"p-0117","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _SMB2_REQ_FLUSH {"]},{"entry":[{},"\u2003\u2002\u2009USHORT StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT Reserved1;"]},{"entry":[{},"\u2003\u2002\u2009ULONG \u2002Reserved2;"]},{"entry":[{},"\u2003\u2002\u2009UINT64 \u2002\u2009FileId;"]},{"entry":[{},"} SMB2_REQ_FLUSH, *PSMB2_REQ_FLUSH;"]},{"entry":[{},"typedef struct _SMB2_RESP_FLUSH {"]},{"entry":[{},"\u2003\u2002\u2009USHORT StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT Reserved;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Upon successful response from the server, the client is guaranteed that all cached data has been flushed to its backing persistent store. The client specifies the FileId of the file it wishes to flush. A flush on a pipe will not return until all data is consumed from that pipe, which may take a while.","Read","Reads data from an open file.",{"@attributes":{"id":"p-0120","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["typedef struct _SMB2_REQ_READ",{}]},{"entry":"{"},{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2002\u2009\/\/ = sizeof(SMB2_REQ_READ)"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002Padding;","\u2002\u2009\/\/ Requested padding of read data"]},{"entry":[{},"\u2002\u2009\/\/ response from beginning of header"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002Reserved;"},{"entry":["\u2003\u2002\u2009ULONG \u2002Length;","\u2002\u2009\/\/ The length of the read to send on"]},{"entry":[{},"\u2002\u2009\/\/ this channel"]},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009Offset;","\u2002\u2009\/\/ Offset of the read"]},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009FileId;","\u2002\u2009\/\/ Identifier of the file"]},{"entry":[{},"\u2002\u2009\/\/ being read"]},{"entry":["\u2003\u2002\u2009ULONG \u2002MinimumCount;","\u2002\u2009\/\/ The minimum bytes to read and"]},{"entry":[{},"\u2002\u2009\/\/ consider success"]},{"entry":["\u2003\u2002\u2009ULONG \u2002Channel;","\u2002\u2009\/\/ The channel to send the remaining"]},{"entry":[{},"\u2002\u2009\/\/ data on"]},{"entry":["\u2003\u2002\u2009ULONG \u2002RemainingBytes;","\/\/ If channel != 0, additional bytes to"]},{"entry":[{},"\/\/ be read and sent on channel,"]},{"entry":[{},"\/\/ otherwise how much more planned to read"]},{"entry":["\u2003\u2002\u2009USHORT ReadChannelInfoOffset;","\u2002\u2009\/\/ If channel != 0, information about"]},{"entry":["\u2003\u2002\u2009USHORT ReadChannelInfoLength;","\u2002\u2009\/\/ channel to send additional data on."]},{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\u2002\u2009\/\/ ReadChannelInfo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_READ, *PSMB2_REQ_READ;"},{"entry":"typedef struct _SMB2_RESP_READ"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2002\u2009\/\/ = sizeof(SMB2_RESP_READ)"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002DataOffset;","\u2002\u2009\/\/ Offset to data in the packet"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002Reserved;"},{"entry":["\u2003\u2002\u2009ULONG \u2002DataLength;","\u2002\u2009\/\/ Length of data returns as part of"]},{"entry":[{},"\u2002\u2009\/\/ this packet"]},{"entry":["\u2003\u2002\u2009ULONG \u2002DataRemaining;","\u2002\u2009\/\/ Length of data that is being sent on"]},{"entry":[{},"\u2002\u2009\/\/ the alternate channel if specified,"]},{"entry":[{},"\u2002\u2009\/\/ otherwise how much more we are ready"]},{"entry":[{},"\u2002\u2009\/\/ to have read"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\/\/Pad[ ], Data[ ]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_READ, *PSMB2_RESP_READ;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Read is pretty self explanatory. The client specifies the file (via FileId), the offset, and the length of the read, and the server returns the data. There are a couple other things the client can specify. The MinCount tells the server the minimum amount it will read from a file for a successful return. If the read comes up short, the server will simply return a failure instead of returning the entire data buffer. The client can also recommend Padding for better processing. This is the offset into the read response packet where the server should put the data. This allows the client to lay down the read response buffers in a more efficient way when it receives the information off the transports. The remaining field indicates to the server how much the entire read will be for if this is only a section of the read. Thus, if the client is going to read 8 k in 1 k chunks, it would issue a read for 1 k with Remaining=7 k. This allows the server the option to optimize by reading the entire 8 k in one operation and buffering the data back to the client.","On the server response, it indicates how much data it is returning (in the DataLength field) along with the DataRemaining that was specified in the read command.","If the channel specified in the command is not the channel that the command came in on, than the user is asking for a channel read. This means that if I request a read on channel 0 with \u201cchannel=1\u201d and \u201cLength=0, Remaining=64 k\u201d, the server will respond with \u201cDataLength=0, DataRemaining=64 k\u201d and the next 64 k bytes that come across Channel 1 will be the data. The client is responsible for synchronizing this to make sure no data responses are outstanding on channel 1 when this command is issued. A client could also issue (on channel 0) \u201cread Channel=1, DataLength=1 k, Remaining=7 k\u201d, such that the response would contain the first 1 k of data and the rest of the data (the last 7 k) would be streamed across channel 1.","Write","Writes data to an open file.",{"@attributes":{"id":"p-0125","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["typedef struct _SMB2_REQ_WRITE",{}]},{"entry":"{"},{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\/\/ = sizeof(SMB2_REQ_WRITE)"]},{"entry":["\u2003\u2002\u2009USHORT DataOffset;","\/\/ Offset to data from header"]},{"entry":["\u2003\u2002\u2009ULONG \u2002Length;","\/\/ Length of data being written"]},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009Offset;","\/\/ File offset of the write"]},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009FileId;","\/\/ Identifier for the file being"]},{"entry":[{},"\/\/ written to"]},{"entry":["\u2003\u2002\u2009ULONG \u2002Channel;","\/\/ If non-zero, the channel where"]},{"entry":[{},"\/\/ the remaining data should be sent"]},{"entry":["\u2003\u2002\u2009ULONG \u2002Remaining;","\u2002\/\/ Number of bytes to be sent on"]},{"entry":"channel"},{"entry":["\u2003\u2002\u2009USHORT WriteChannelInfoOffset;","\/\/ If channel != 0, information"]},{"entry":[{},"\/\/ about the channel"]},{"entry":["\u2003\u2002\u2009USHORT WriteChannelInfoLength;","\/\/ we wish to write data to."]},{"entry":"\u2003\u2002\u2009ULONG \u2002Flags;"},{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\/\/ WriteChannelInfo"]},{"entry":"} SMB2_REQ_WRITE, *PSMB2_REQ_WRITE;"},{"entry":"typedef struct _SMB2_RESP_WRITE"},{"entry":"{"},{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\/\/ = sizeof(SMB2_RESP_WRITE)"]},{"entry":"\u2003\u2002\u2009USHORT Reserved;"},{"entry":["\u2003\u2002\u2009ULONG \u2002Count;","\/\/ How much of the data was written"]},{"entry":["\u2003\u2002\u2009ULONG \u2002Remaining;","\/\/ How many bytes we can receive on"]},{"entry":[{},"\/\/ the channel"]},{"entry":["\u2003\u2002\u2009USHORT WriteChannelInfoOffset;","\/\/ If channel != 0, optional"]},{"entry":[{},"\/\/ information about the channel we"]},{"entry":["\u2003\u2002\u2009USHORT WriteChannelInfoLength;","\/\/ wish to write data to."]},{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\u2002\/\/ WriteChannelInfo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_WRITE, *PSMB2_RESP_WRITE;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The client fills in the file (identified by the FileId), the offset, and the length for the write, and attached the data. It is recommended that the data be padded as returned in the original negotiate response to help server performance. The client can also indicate how much more data it will write to the server to allow the server to optimize. On the response, the server indicates how much was written, and returns the amount it is still expecting.","If the channel specified in the write is not the channel the command came in on, than the client is asking to stream the data on another channel. An example would be a write received on channel 0 with \u201cChannel=1, Length=0, Remaining=64 k\u201d. The client is asking to stream a 64 k write on Channel 1. The server would respond with \u201cCount=0, Remaining=64 k\u201d to allow the write. The response will include and AsyncId for a second response that will come after the data is sent on the channel and ack'd. Then the next 64 k bytes streamed on Channel 1 would be the data. (No header). Upon completion, the server will send a SMB2_RESP_WRITE on channel 0 to indicate the success\/failure of the operation and use the AsyncId information to send a second reply, unless the specific channel allows for inherent acknowledgement in which case it will occur on the channel itself.","Break_Oplock","Used to request and acknowledge the release of opportunistic locks taken on a file.",{"@attributes":{"id":"p-0129","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct _SMB2_REQ_BREAK_OPLOCK"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\u2003\u2009\/\/ = sizeof"]},{"entry":[{},"\u2003\u2003\u2009(SMB2_REQ_BREAK_OPLOCK)"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002OplockLevel;","\u2003\u2003\u2009\/\/ Level to break to.\u2003(Level2 or"]},{"entry":[{},"\u2003\u2003\u2009None)"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002Reserved;"},{"entry":["\u2003\u2002\u2009ULONG \u2002Reserved2;","\u2003\u2002\u2009\/\/ Timeout in seconds"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009FileId;","\u2003\u2003\u2003\/\/ Identifier of the file being locked\/"]},{"entry":[{},"\u2003\u2003\u2003unlocked"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_BREAK_OPLOCK,"},{"entry":"*PSMB2_REQ_BREAK_OPLOCK;"},{"entry":"typedef struct _SMB2_RESP_BREAK_OPLOCK"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\u2003\u2003\u2009\/\/ = sizeof(SMB2_RESP_LOCK)"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002OplockLevel;","\u2003\u2003\u2002\u2009\/\/ Level broken to\u2003(<= level"]},{"entry":[{},"\u2003\u2003\u2002\u2009requested)"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002Reserved;"},{"entry":"\u2003\u2002\u2009ULONG Reserved2;"},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009FileId;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_BREAK_OPLOCK,"},{"entry":"*PSMB2_RESP_BREAK_OPLOCK;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"When another user requests access to a file that a client holds an opportunistic lock on in a fashion that requires breaking the existing lock, SRV will send an SMB2_RESP_BREAK_OPLOCK to the client. The client is then expected to send a REQ_BREAK_OPLOCK for the given file to release their oplock, and SRV will respond again to acknowledge this.","Lock","Used to request byte-range locks, and also used to request opportunistic locks (and inform the client when one is broken).",{"@attributes":{"id":"p-0132","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_LOCKFLAG_SHARED_LOCK","0x01"]},{"entry":["#define SMB2_LOCKFLAG_EXCLUSIVE_LOCK","0x02"]},{"entry":["#define SMB2_LOCKFLAG_UNLOCK","0x04"]},{"entry":["#define SMB2_LOCKFLAG_FAIL_IMMEDIATELY","0x10"]},{"entry":"typedef struct _SMB2_LOCK"},{"entry":"{"},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009Offset;"},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009Length;"},{"entry":"\u2003\u2002\u2009ULONG Flags;"},{"entry":"\u2003\u2002\u2009ULONG Reserved;"},{"entry":"} SMB2_LOCK, *PSMB2_LOCK;"},{"entry":"typedef struct _SMB2_REQ_LOCK"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009\/\/ = sizeof"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009(SMB2_REQ_LOCK)"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002LockCount;"},{"entry":"\u2003\u2002\u2009ULONG \u2002Reserved;"},{"entry":["\u2003\u2002\u2009UINT64\u2002\u2009FileId;","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009\/\/ Identifier of the file"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009\/\/ being locked\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009unlocked"]},{"entry":["SMB2_LOCK Locks[1];","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009\/\/ Array of size"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009(LockCount)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_LOCK, *PSMB2_REQ_LOCK;"},{"entry":"typedef struct _SMB2_RESP_LOCK"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009\/\/ = sizeof"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2009(SMB2_RESP_LOCK)"]},{"entry":"\u2003\u2002\u2009USHORT Reserved;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_LOCK, *PSMB2_RESP_LOCK;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Syntax for the LOCK request is similar to the SMB1 Lock request. The client specifies the FileId, and one or more SMB_LOCK structures indicating the offset and length they wish to lock. All of these LOCK structures must be either locks or unlocks. However, you can mix shared and exclusive lock requests in a single batched lock operation. The most common use for lock batching would be claiming a series of locks as part of a batch oplock break, and is most useful when you are assured that all the locks will succeed.","A successful return indicates to the client that they attained (or released) the requested byte range locks. On the failure case, the byte range locks were not granted.","Echo","Echo is used by a client to determine whether a server is still up at a given point in time. Upon receipt of this command, the server will simply turn it around and return success.",{"@attributes":{"id":"p-0136","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _SMB2_REQ_ECHO {"]},{"entry":[{},"\u2003\u2002\u2009USHORT StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT Reserved;"]},{"entry":[{},"} SMB2_REQ_ECHO, *PSMB2_REQ_ECHO;"]},{"entry":[{},"typedef struct _SMB2_RESP_ECHO {"]},{"entry":[{},"\u2003\u2002\u2009USHORT StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT Reserved;"]},{"entry":[{},"} SMB2_RESP_ECHO, *PSMB2_RESP_ECHO;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The server responds to the packet to indicate it is working properly. Used to allow the client to \u201cping\u201d the server.","Cancel","Used by the client to request the cancellation of a sent operation.",{"@attributes":{"id":"p-0139","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _SMB2_REQ_CANCEL {"]},{"entry":[{},"\u2003\u2002\u2009USHORT StructureSize;"]},{"entry":[{},"\u2003\u2002\u2009USHORT Reserved;"]},{"entry":[{},"} SMB2_REQ_CANCEL, *PSMB2_REQ_CANCEL;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A cancel has no response, but should result in the command itself either being completed successfully, or failing with STATUS_CANCELLED, and it should happen as soon as possible. The operation being sent is identified because it will share the MessageId of the cancel command. This is the one case where a MessageId sent to the server may already have been used previously. If a response came with an AsyncId, that should be present in the header, and will be used to locate the command on the server.","Ioctl","Ioctl is used to issue a Device Control or a File System Control command across the network.",{"@attributes":{"id":"p-0142","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\/\/ Request",{}]},{"entry":"typedef struct _SMB2_REQ_IOCTL"},{"entry":"{"},{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\u2002\/\/ = sizeof(SMB2_REQ_TRANSACT)"]},{"entry":"\u2003\u2002\u2009USHORT Reserved;"},{"entry":"\u2003\u2002\u2009ULONG \u2002CtlCode;"},{"entry":"\u2003\u2002\u2009UINT64 \u2002FileId;"},{"entry":["\u2003\u2002\u2009ULONG \u2002InputOffset;","\u2003\/\/ Bytes for input buffer"]},{"entry":["\u2003\u2002\u2009ULONG \u2002InputCount;","\u2003\/\/ Count of parameter bytes in this"]},{"entry":[{},"\u2003\/\/ message"]},{"entry":["\u2003\u2002\u2009ULONG \u2002MaxInputResponse;","\u2003\/\/ Max bytes server can return for"]},{"entry":[{},"\u2003\/\/ response parameters"]},{"entry":["\u2003\u2002\u2009ULONG \u2002OutputOffset;","\u2003\/\/ Data bytes location"]},{"entry":["\u2003\u2002\u2009ULONG \u2002OutputCount;","\u2003\/\/ Count of data bytes in this"]},{"entry":[{},"\u2003\/\/ message"]},{"entry":["\u2003\u2002\u2009ULONG \u2002MaxOutputResponse;","\u2003\/\/ Max bytes server can return for"]},{"entry":[{},"\u2003\/\/ response data"]},{"entry":"\u2003\u2002\u2009ULONG \u2002Flags;"},{"entry":"\u2003\u2002\u2009ULONG \u2002Reserved2;"},{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\u2003\u2002\/\/ Parameters[ ], Data[ ]"]},{"entry":"} SMB2_REQ_IOCTL, *PSMB2_REQ_IOCTL;"},{"entry":[{},"\u2003\/\/ Response"]},{"entry":"typedef struct _SMB2_RESP_IOCTL"},{"entry":"{"},{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\u2002\/\/ = sizeof(SMB2_RESP_TRANSACT)"]},{"entry":"\u2003\u2002\u2009USHORT Reserved;"},{"entry":"\u2003\u2002\u2009ULONG \u2002CtlCode;"},{"entry":"\u2003\u2002\u2009UINT64 \u2002FileId;"},{"entry":["\u2003\u2002\u2009ULONG \u2002InputOffset;","\u2003\/\/ Bytes for input buffer"]},{"entry":["\u2003\u2002\u2009ULONG \u2002InputCount;","\u2003\/\/ Count of parameter bytes in this"]},{"entry":[{},"\u2003\/\/ message"]},{"entry":["ULONG \u2002OutputOffset;","\u2003\/\/ Data bytes location"]},{"entry":["ULONG \u2002OutputCount;","\u2003\/\/ Count of data bytes in this"]},{"entry":[{},"\u2003\/\/ message"]},{"entry":"\u2003\u2002\u2009ULONG \u2002Flags;"},{"entry":"\u2003\u2002\u2009ULONG \u2002Reserved2;"},{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\u2003\u2002\/\/ Parameters[ ], Data[ ]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_IOCTL, *PSMB2_RESP_IOCTL;} SMB2_RESP_TRANSACT,"},{"entry":"*PSMB2_RESP_TRANSACT;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"An IOCTL is used for issuing a generic file system or device control command across the network. It packs the input and output buffers based on the METHOD of the control code and sends them across the network. The server side than repackages them and issues the FSCTL\/IOCTL against the file object. The results are likewise packed up and returned to the user with the status code. The set of allowable FSCTL\/IOCTL codes can be limited by both SRV or the underlying file systems. (Not all are necessarily valid remotely.)","For buffered or direct requests, only Input is valid on request and Output is sent on response. For neither requests, both Input and Output are sent both ways.","Query Directory","Allows the client to query directory enumerations on an open directory handle across the network.",{"@attributes":{"id":"p-0146","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2002\u2009\/\/"},{"entry":"\u2003\u2002\u2009\/\/ QUERY_DIRECTORY Command"},{"entry":"\u2003\u2002\u2009\/\/"},{"entry":"\u2003\u2002\u2009#define SMB2_REOPEN\u2003\u2003\u20030x10"},{"entry":"\u2003\u2002\u2009\/\/ Request"},{"entry":"\u2003\u2002\u2009typedef struct _SMB2_REQ_QUERY_DIRECTORY"},{"entry":"\u2003\u2002\u2009{"},{"entry":"\u2003\u2003\u2003\u2002USHORT StructureSize;\u2003\u2003\u2003\u2003\u2003\/\/ ="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\/\/ sizeof"},{"entry":"\u2003\u2003\u2003\u2002(SMB2_REQ_QUERY_DIRECTORY)"},{"entry":"\u2003\u2003\u2003\u2002UCHAR \u2002FileInformationClass;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2002UCHAR \u2002Flags;","\u2003\u2003\/\/ SL_\/SMB2_flags"]},{"entry":"\u2003\u2003\u2003\u2002ULONG \u2002FileIndex;"},{"entry":"\u2003\u2003\u2003\u2002UINT64 \u2002FileId;"},{"entry":"\u2003\u2003\u2003\u2002USHORT FileNameOffset;"},{"entry":"\u2003\u2003\u2003\u2002USHORT FileNameLength;"},{"entry":"\u2003\u2003\u2003\u2002ULONG \u2002OutputBufferLength;"},{"entry":["\u2003\u2003\u2003\u2002UCHAR \u2002Buffer[1];","\u2003\u2003\/\/ FileName parameter"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2002\u2009} SMB2_REQ_QUERY_DIRECTORY,"},{"entry":"\u2003\u2002\u2009*PSMB2_REQ_QUERY_DIRECTORY;"},{"entry":"\u2003\u2002\u2009\/\/ Response"},{"entry":"\u2003\u2002\u2009typedef struct _SMB2_RESP_QUERY_DIRECTORY"},{"entry":"\u2003\u2002\u2009{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003\u2003\u2002USHORT StructureSize;","\u2003\u2003\/\/ ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"sizeof(SMB2_RESP_QUERY_DIRECTORY)"},{"entry":"\u2003\u2003\u2003\u2002USHORT OutputBufferOffset;"},{"entry":"\u2003\u2003\u2003\u2002ULONG \u2002OutputBufferLength;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003\u2003\u2002UCHAR \u2002Buffer[1];","\u2003\u2003\/\/ Response data"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_QUERY_DIRECTORY,"},{"entry":"*PSMB2_RESP_QUERY_DIRECTORY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The QueryDirectory call matches existing NT semantics very closely. The caller provides the InfoClass, the FileId for the directory open, the filename portion (that specifies either the wildcard\/file search params or the resume name for an existing search) and any valid SL_flags associated with the call, and SRV will return a buffer up to OutputBufferLength.","There is also a new flag (SMB2_REOPEN) that can be included in the QueryDirectory flags structure. This flag is a stronger version of the SL_RESTART_SCAN flag. The latter only allows restarting scans where the search specified hasn't changed. (i.e. restart a *.* or a t* search.) The latter tells the server to restart a scan where the search specified has changed. To use this flag, the caller must guarantee exclusive use across the call, and no outstanding operations (such as change notifies). The server takes the appropriate steps to perform this operation, which may involve closing and reopening the underlying directory handle on the server side. This is transparent to the client.","Change Notify","This potentially long-running operation allows a client to register for change notifications on a directory.",{"@attributes":{"id":"p-0150","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ CHANGE_NOTIFY Command"},{"entry":"\/\/"},{"entry":"\/\/ Request"},{"entry":"typedef struct _SMB2_REQ_CHANGE_NOTIFY"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\/\/ ="]},{"entry":[{},"\u2003\/\/ sizeof"]},{"entry":[{},"\u2003(SMB2_REQ_CHANGE_NOTIFY)"]},{"entry":["\u2003\u2002\u2009USHORT Flags;","\u2003\/\/ SL_WATCH_TREE?"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2002\u2009ULONG \u2002OutputBufferLength;"},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009FileId;"},{"entry":"\u2003\u2002\u2009ULONG \u2002CompletionFilter;"},{"entry":"\u2003\u2002\u2009ULONG \u2002Reserved;"},{"entry":"} SMB2_REQ_CHANGE_NOTIFY,"},{"entry":"*PSMB2_REQ_CHANGE_NOTIFY;"},{"entry":"\/\/ Response"},{"entry":"typedef struct _SMB2_RESP_CHANGE_NOTIFY"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2002\/\/ ="]},{"entry":[{},"\u2002\/\/ sizeof"]},{"entry":[{},"\u2002(SMB2_RESP_CHANGE_NOTIFY)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2002\u2009USHORT OutputBufferOffset;"},{"entry":"\u2003\u2002\u2009ULONG \u2002OutputBufferLength;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\u2003\u2003\/\/ Notify data"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_CHANGE_NOTIFY,"},{"entry":"*PSMB2_RESP_CHANGE_NOTIFY;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The caller sends the FileId for the directory along with a CompletionFilter specifying which changes the caller is interested in. They also can send the SL_WATCH_TREE flag to indicate a recursive notify operation. This operation will almost always invoke the \u201casync\u201d behavior since it can pend for an infinite amount of time. Also note that any further change notify requests on the same handle will pend waiting for the first to complete, just as in local file system behavior.","Query Info","Allows the client to query information from the remote system. Currently this can be used to query file information, file-system information, security information, or quota information.",{"@attributes":{"id":"p-0153","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ QUERY_INFO"},{"entry":"\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define SMB2_0_INFO_FILE","\u2003\u20020x01"]},{"entry":["#define SMB2_0_INFO_FILESYSTEM","\u2003\u20020x02"]},{"entry":["#define SMB2_0_INFO_SECURITY","\u2003\u20020x03"]},{"entry":["#define SMB2_0_INFO_QUOTA","\u2003\u20020x04"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _SMB2_QUERY_QUOTA_INFO {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009UCHAR ReturnSingleEntry;","\u2003\/\/ Indicates that only a single"]},{"entry":[{},"\u2003\/\/ entry should be returned rather"]},{"entry":[{},"\u2003\/\/ than filling the buffer with"]},{"entry":[{},"\u2003\/\/ as many entries as"]},{"entry":[{},"\u2003possible."]},{"entry":["\u2003\u2002\u2009UCHAR RestartScan;","\u2003\/\/ Indicates whether the scan of the"]},{"entry":[{},"\u2003\/\/ quota information is to be"]},{"entry":[{},"\u2003\/\/ restarted from the beginning."]},{"entry":"\u2003\u2002\u2009USHORT Reserved;"},{"entry":["\u2003\u2002\u2009ULONG SidListLength;","\u2003\/\/ Supplies the length of the SID"]},{"entry":[{},"\u2003\/\/ list if present"]},{"entry":["\u2003\u2002\u2009ULONG StartSidLength;","\u2003\/\/ Supplies optional SID that"]},{"entry":[{},"\u2003\/\/ indicates the returned information"]},{"entry":[{},"\u2003\/\/ is to start with an entry other"]},{"entry":[{},"\u2003\/\/ than the first. This parameter is"]},{"entry":[{},"\u2003\/\/ ignored if a SidList is given"]},{"entry":["\u2003\u2002\u2009ULONG StartSidOffset;","\u2003\/\/ Supplies the offset of Start Sid"]},{"entry":[{},"\u2003\/\/ in the buffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_QUERY_QUOTA_INFO, *PSMB2_QUERY_QUOTA_INFO;"},{"entry":"\/\/ Request"},{"entry":"typedef struct _SMB2_REQ_QUERY_INFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\/\/ = sizeof"]},{"entry":[{},"\u2003(SMB2_REQ_QUERY_INFO)"]},{"entry":["\u2003\u2002\u2009UCHAR \u2002InfoType;","\u2003\/\/ Determines info type"]},{"entry":[{},"\u2003\/\/(SMB2_0_INFO_*)"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002FileInfoClass;"},{"entry":"\u2003\u2002\u2009ULONG \u2002OutputBufferLength;"},{"entry":["\u2003\u2002\u2009USHORT InputBufferOffset;","\u2003\/\/ Input buffer only valid on"]},{"entry":[{},"\u2003\/\/ Quota calls"]},{"entry":"\u2003\u2002\u2009USHORT Reserved;"},{"entry":"\u2003\u2002\u2009ULONG \u2002InputBufferLength;"},{"entry":"\u2003\u2002\u2009Union {"},{"entry":["\u2003\u2003\u2003\u2002\u2009ULONG \u2002SecurityInformation;","\u2003\/\/ For Query Security calls"]},{"entry":["\u2003\u2003\u2003\u2002\u2009ULONG \u2002EaIndex;","\u2003\/\/ For QueryEA calls"]},{"entry":"\u2003\u2002\u2009};"},{"entry":"\u2003\u2002\u2009ULONG \u2002Flags;"},{"entry":"\u2003\u2002\u2009UINT64\u2002\u2009FileId;"},{"entry":"\u2003\u2002\u2009UCHAR \u2002Buffer[1];"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_QUERY_INFO, *PSMB2_REQ_QUERY_INFO;"},{"entry":"\/\/ Response"},{"entry":"typedef struct _SMB2_RESP_QUERY_INFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2002\/\/ = sizeof"]},{"entry":[{},"\u2002(SMB2_RESP_QUERY_INFO)"]},{"entry":"\u2003\u2002\u2009USHORT OutputBufferOffset;"},{"entry":"\u2003\u2002\u2009ULONG \u2002OutputBufferLength;"},{"entry":["\u2003\u2002\u2009UChAR \u2002\u2009Buffer[1];","\u2003\/\/ File Info"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"343pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_QUERY_INFO, *PSMB2_RESP_QUERY_INFO;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The client specifies in the InfoType the SMB2_0_INFO_* options to indicate whether this is a request for file information, file system information, security information, or quota information. The FileId denotes the file in question (for file info or security information.) The volume the file resides on is used for file system info or quota requests.","The sub-information level is filled into FileInfoClass, and is dependent on the type of information being queried. For file information queries it will be a FILE_INFORMATION_CLASS, where as for file system information it will be a FS_INFORMATION_CLASS. For quota and security, it will be 0.","The input buffer is currently only used for Quota requests, as they take the SMB2_QUERY_QUOTA_INFO structure on input to determine what is being asked for. For the other requests it will be empty.","OutputBufferLength specifies the maximum amount of data to return to the user.","Set Info","Allows the client to set information on the remote system. Currently this can be used to set file information, file-system information, security information, or quota information.",{"@attributes":{"id":"p-0159","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/"},{"entry":"\/\/ SET_INFO"},{"entry":"\/\/"},{"entry":"\/\/ Request"},{"entry":"typedef struct _SMB2_REQ_SET_INFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\/\/ = sizeof"]},{"entry":[{},"\u2003(SMB2_REQ_SET_INFO)"]},{"entry":"\u2003\u2002\u2009UCHAR \u2002InfoType;"},{"entry":"\u2003\u2002\u2009UCHAR \u2002FileInfoClass;"},{"entry":"\u2003\u2002\u2009ULONG \u2002BufferLength;"},{"entry":"\u2003\u2002\u2009USHORT BufferOffset;"},{"entry":"\u2003\u2002\u2009USHORT Reserved;"},{"entry":"\u2003\u2002\u2009Union {"},{"entry":"\u2003\u2003\u2003\u2002\u2009ULONG \u2002Reserved2;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003\u2002\u2009ULONG \u2002SecurityInformation;\u2003\/\/ For SET_SECURITY calls"},{"entry":"\u2003\u2002\u2009};"},{"entry":"\u2003\u2002\u2009UINT64 \u2002\u2009FileId;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2002\u2009UCHAR \u2002Buffer[1];","\u2003\/\/ File info"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_REQ_SET_INFO, *PSMB2_REQ_SET_INFO;"},{"entry":"\/\/ Response"},{"entry":"typedef struct SMB2_RESP_SET_INFO"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2002\u2009USHORT StructureSize;","\u2003\/\/ = sizeof"]},{"entry":[{},"\u2003(SMB2_RESP_SET_INFO)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} SMB2_RESP_SET_INFO, *PSMB2_RESP_SET_INFO;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The type of information being set and the specific class are set in the Flags and FileInfoClass fields as described for QUERY_INFO. The input buffer provided is the information being set, and the FileId identifies the file.","For SetSecurity calls, the SecurityInformation field denotes the info being set. (i.e. OWNER_SECURITY_INFORMATION, etc.)","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and not limited in the accompanying figures in which like reference numerals indicate similar elements and in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
