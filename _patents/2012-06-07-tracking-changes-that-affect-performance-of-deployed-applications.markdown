---
title: Tracking changes that affect performance of deployed applications
abstract: An application monitoring infrastructure that enables application configuration changes on multiple machines across multiple OS types to be tracked by identifying data containers that are to be monitored for changes, detecting a change to a monitored data container, and storing data representative of a changed version of the monitored data container responsive to detecting that the monitored container was changed. The data containers that are to be monitored for changes are identified from templates, and a unique template is provisioned for each of the applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954387&OS=08954387&RS=08954387
owner: VMware, Inc.
number: 08954387
owner_city: Palo Alto
owner_country: US
publication_date: 20120607
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION(S)","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is related to U.S. patent application entitled \u201cCorrelating Performance Degradation of Applications to Specific Changes Made to Applications,\u201d filed concurrently herewith, and having Ser. No. 13\/491,329.","With the transition to virtualized infrastructure in recent years, outages due to configuration changes to applications have been on the rise. Some of the more common configuration changes include code push, and changes to the clustering configuration, number of threads allocated to applications, and datastore configuration. Although many of these changes are tested prior to rolling them out in the production environment, outages and significant performance degradations are not discovered, indeed cannot be discovered, if they result from scale issues, e.g., when the changes are rolled out in a cloud environment having virtual machines that number in the millions.","One or more embodiments disclosed herein provide an application monitoring infrastructure that enables application configuration changes on multiple machines across multiple OS types to be tracked, and correlated to performance degradation and outages.","A method for tracking configuration changes of applications, according to an embodiment, includes the steps of identifying data containers that are to be monitored for changes, detecting a change to a monitored data container, and storing data representative of a changed version of the monitored data container responsive to detecting that the monitored container was changed, wherein the data containers that are to be monitored for changes are identified from templates, and a unique template is provisioned for each of the applications.","A method for tracking configuration changes of applications, according to another embodiment, includes the steps of identifying data containers that are to be monitored for changes, receiving notifications of file events, transforming multiple file events into a normalized file event, detecting a change to a monitored data container based on the normalized file event, and storing data representative of a changed version of the monitored data container responsive to detecting that the monitored container was changed.","Further embodiments of the present invention include, without limitation, a non-transitory computer-readable storage medium that includes instructions that enable a computer system to implement one or more aspects of the above methods as well as a computer system configured to implement one or more aspects of the above methods.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1","FIG. 1"],"b":["10","20","20","100","10","10","20","10","20"]},"Each of health monitoring server , central monitoring server , and monitored machines  includes hardware components of a conventional computing device, such as processor and system memory, and system level software. Health monitoring server  further includes software components running on top of its system level software, one of which is shown in  as health monitor . Health monitor  communicates with central monitoring server  over a network to retrieve application performance data and change data from central monitoring server  through an application programming interface (API) . Health monitor  also processes the retrieved performance data and change data to generate various GUIs that are presented to the system administrator through a display .","Central monitoring server  further includes software components running on top of its system software, which are shown in  as central monitor  and API . Central monitor  communicates with monitored machines  to collect application performance and change data from them, and store them in an event store . Central monitor  makes such collected data available to health monitor  through API .","Each of monitored machines  includes one or more applications  running on top of its system software. It also includes a performance monitoring agent  that monitors the performance and\/or behavior of applications , such as central processing unit (CPU) usage, physical memory usage, and latency, and a change monitoring agent  that monitors changes to various files and folders designated by the system administrator as being monitoring targets. Some examples of applications that can be tracked include web server applications such as Tomcat, JBoss, Websphere, Weblogic, and IIS, and database applications such as MySQL, PostgreSQL, Oracle, and MSSQL. Monitored machines  may be physical or virtual machines. Physical machines include any computing device, such as server-grade computing platforms, desktop and laptop computing devices, and mobile computing devices, such as tablet computers and smart phones.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2","b":["110","110","100","51","110","100","70","70","100","100"]},{"@attributes":{"id":"p-0020","num":"0019"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<plugin package=\u201corg.hyperic.hq.plugin.tomcat\u201d name=\u201ctomcat\u201d",{}]},{"entry":[{},"version=\u201c@project.version@\u201d>",{}]},{"entry":[{},"<metrics name=\u201cSome_metrics\u201d>",{}]},{"entry":[{},"\u2002<\/metrics>",{}]},{"entry":[{},"\u2002<server name=\u201cApache Tomcat\u201d version=\u201c5.5\u201d",{}]},{"entry":[{},"\u2002platforms=\u201cUnix,Win32\u201d>",{}]},{"entry":[{},"\u2003<property name=\u201cVERSION_FILE\u201d",{}]},{"entry":[{},"\u2003value=\u201cserver\/lib\/catalina-storeconfig.jar\u201d\/>",{}]},{"entry":[{},"\u2003<plugin type=\u201cconfig_track\u201d",{}]},{"entry":[{},"\u2003class=\u201corg.hyperic.hq.product.FileChangeTrackPlugin\u201d>",{}]},{"entry":[{},"\u2003\u2002<monitored>",{}]},{"entry":[{},"\u2003\u2003<folder path=\u201cconf\u201d recursive=\u201ctrue\u201d",{}]},{"entry":[{},"\u2003\u2003filter=\u201c.*.properties|.*.xml|.*.policy\u201d\/>",{}]},{"entry":[{},"\u2003\u2003<folder path=\u201cbin\u201d recursive=\u201cfalse\u201d filter=\u201c.*.bat|.*.xml|.*.sh\u201d\/>",{}]},{"entry":[{},"\u2003\u2003<folder path=\u201clib\u201d recursive=\u201cfalse\u201d filter=\u201c.*.jar\u201d\/>",{}]},{"entry":[{},"\u2003\u2003<folder path=\u201cwebapps\u201d recursive=\u201ctrue\u201d",{}]},{"entry":[{},"\u2003\u2003\u2002filter=\u201c.*\\.jar|.*\\.dll|.*\\.class|.*\\.jsp|.*\\.php|.*\\.pl|.*\\.js|.*\\.",{}]},{"entry":[{},"\u2003\u2003\u2002py|.*\\.pyc|.*\\.cgi\u201d\/>",{}]},{"entry":[{},"\u2003\u2003<folder path=\u201cdata\u201d recursive=\u201cfalse\u201d filter=\u201c.*\\.conf\u201d\/>",{}]},{"entry":[{},"\u2003\u2003<!-- system variable PGDATA -->",{}]},{"entry":[{},"\u2003\u2003<folder path=\u201c%PGDATA%\u201d recursive=\u201cfalse\u201d filter=\u201c.*\\.conf\u201d\/>",{}]},{"entry":[{},"\u2003\u2002<\/monitored>",{}]},{"entry":[{},"\u2003<\/plugin>",{}]},{"entry":[{},"\u2002<\/server>",{}]},{"entry":[{},"<\/plugin>"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Monitoring template  for an application identifies the application being monitored, and paths of folders and files to be monitored, some recursively, for that application. In the example given in TABLE 1, the application being monitored is \u201cApache Tomcat\u201d and the folders and files that are to be monitored recursively have a recursive flag set to be true. Within a monitored folder, a regular expression filter is used to determine which files are monitored. In addition, monitoring template  may designate folders and files to be monitored using environmental or system variables so that files that affect the performance of the application and whose location on the file system is determined by environment\/system variables may be monitored and tracked according to embodiments described herein. Using monitoring template , the folders and files for any application being monitored may be custom defined. By using monitoring template , the number of folders and files to be monitored can be reduced to a manageable (practical) number.","Change monitoring agent  monitors changes to various files and folders of particular applications  being monitored as specified in monitoring templates . As shown, change monitoring agent  includes two modules. The first is an event processor  that receives notifications from the system software of monitored machine  that a certain folder or file has been changed. The particular components of system software that are providing the notifications are a file system (FS) monitor , a database (DB) monitor , and for Microsoft Windows\u00ae systems, a registry monitor . In one embodiment, a Java\u00ae library known as \u201cjpathwatch\u201d is used to monitor file system changes such as file creation and deletion, file modification, file renaming, and changes in subfolders. As will be further described below in conjunction with , event processor  evaluates the changes detected by FS monitor , DB monitor , and registry monitor  and produces change events for further processing by change tracker , which is the second module within change monitoring agent  shown in . Change tracker  receives change events from event processor  and processes the versioning of the changes to files using a versioning tool to store any changes to the files in change repository , which may be provisioned in system memory or local storage. In one embodiment, the versioning tool known as Git is used.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3","b":["60","62"]},"The method begins at step  when FS monitor  detects one or more change events on the same file or folder during a configurable time period, Tmin. In some situations, multiple change events relating to effectively the same change are triggered, and this time period is set so that such change events can be captured and analyzed collectively. In one embodiment, this time period is set as 2 milliseconds. At step , event processor  determines whether or not the file or folder should be monitored, based on the installed applications that it discovered through application monitor  and the monitoring templates . For each monitored folder, event processor  registers with the underlying system software for change event notifications. If the file or folder for which the change event is detected at step  is not specified in a monitoring template's filter of an installed application, the method ends. On the other hand, if the file or folder for which the change event is detected at step  is specified in a monitoring template of an installed application, step  is executed where event processor  determines the application ID (App ID) of the installed application for which the file or folder is being monitored. Then, at step , event processor  determines whether a single file event is being processed. If a single event is being processed, step  is executed, where event processor  issues a change event, including the App ID and the path to the changed file to change tracker . If, on the other hand, a folder event or multiple file events are being processed, step  is executed.","At step , event processor  determines whether it can transform a folder event or multiple file events into a single, normalized event, without relying on any OS-specific knowledge. For example, if two or more modify events are triggered for the same file within the time period, Tmin, event processor  may interpret all such modify events as a single modify event. In such situations, event processor , at step , transforms the multiple events into a single, normalized event. Thereafter, step  is executed, where event processor  issues a change event, including the App ID and the path(s) to any changed files to change tracker . The method ends after step  as there are no more change events to process.","If, at step , event processor  determines that it cannot transform a folder event or multiple events into a single, normalized event, without relying on any OS-specific knowledge, steps  and  are executed. At step , event processor  determines the OS-type and, at step , event processor  determines whether it can transform the folder event or multiple events into a single, normalized event, with reliance on OS-specific knowledge. For example, in Windows\u00ae OS, a file creation triggers five separate events\u2014create, delete, recreate, modify, and modify. Event processor , at step , transforms all such events into a single, normalized file creation event and, at step , issues a change event, including the App ID and the path to the newly created file, to change tracker . Another example is a folder copy event in Windows\u00ae OS, which triggers a folder create event and multiple file events for each file in the folder. Event processor , at step , transforms the folder copy event and the subsequent file events into a single, normalized folder event and, at step , issues a change event, including the App ID and the paths to the files in the folder, to change tracker . With Linux\u00ae OS, where a folder copy event triggers only a single folder event, event processor , at step , transforms the folder copy event into a single, normalized folder event and, at step , issues a change event, including the App ID and the paths to the files in the folder, to change tracker . In all three examples given above, the method ends after step  as there are no more change events to process.","In some situations where normalization may not be desired or cannot be implemented, each change event is processed as a separate change event at step . The method ends when it is determined at step  that all change events have been processed.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4","b":["61","61","414","424"]},"When change tracker  pulls a change event with a file path and a change type (create, delete or modify) from a queue of change events maintained by event processor , change tracker  accesses the files at the indicated file path. This method begins at step  with the accessing of one such file. In some situations, the accessed file may be an archive file such as a JAR file or a WAR file, and change tracker  checks for this at step . If the accessed file is an archive file, change tracker extracts a file to process from the archive file at step , and step  is executed thereafter. If not, the method proceeds directly to step  and the accessed file is processed.","At step , the processed file is checked for changes. If there are no changes, the file is not versioned and the method jumps to step . If there are changes, a change ID and a time stamp for the changes is generated at step . If the changed file is binary file, as determined at step , a hash of the binary file is generated (step ) and stored in change repository  along with the change ID and the time stamp (step ). If, on the other hand, the changed file is a text file, a diff operation is performed on the text file against the prior version of the text file to generate a diff file (step ) and the diff file is stored in change repository  along with the change ID and the time stamp (step ).","If the file being processed is an archive file, as determined at step , step  is executed to see if there is any more file to be extracted from the archive file. If there is any more file to be extracted from the archive file, the method returns to step  where another file is extracted. If there are no more files to be extracted from the archive file or the file being processed is not an archive file, change tracker  executes step  to see if there are any more files to process. The method ends if there are no more files to process, and returns to step  if there is at least one more file to process.","As previously described, central monitor  of central monitoring server  communicates with monitored machines  to collect performance and change data from them, and store them in event store . The frequency of the collection is configurable. The performance data that are collected include App ID and time history of the CPU usage, memory usage, and latency. The change data that are collected and stored in event store  include the change ID, App ID, time stamp, path of changed file, and the diff file.","Health monitor  of health monitoring server  accesses the performance data and the change data through API  to carry out a method for generating, and processing inputs made to, an application performance monitoring UI. The steps of this method are illustrated in .","At step , health monitor  displays a list of applications being monitored on a UI. A system administrator viewing the UI may select an application of interest, e.g., travel web server. Upon receiving this selection at step , health monitor displays a performance monitoring UI for the selected application at step . A sample performance monitoring UI is illustrated in , and shows a time history of CPU usage  and latency . A user-selectable warning symbol  is displayed at a particular point in time of the illustrated time histories as an indicator of when performance degradation of the selected application has occurred. When the system administrator makes an input selection (e.g., a mouse click or a tap on a touch screen) on warning symbol  and health monitor  receives this selection at step , health monitor  queries central monitoring server  for change events that are close in time to the performance degradation. In response to the query, central monitoring server  searches change data of the selected application maintained in event store  and returns the requested data to health monitor . At step , health monitor  displays the change events on another UI, one example of which is illustrated in . Upon viewing the change events, the system administrator may implement fixes or roll back the changes that caused the performance degradation by making an input selection on top of one of the change events (step ). In the sample illustration of , the code change implemented at 13:40:06 can be rolled back by manipulating cursor  to that location and making an input selection on that highlighted line. In response to the input selection, health monitor  issues an undo command identifying the change event by its change ID through API  (step ). Central monitoring server  passes this undo command to the appropriate monitored machine and, in turn, the monitored machine executes the undo command using its versioning tool.","If the monitored machine is a virtual machine, as an alternative to the pinpoint rolling back, the entire virtual machine may be rolled back to the most recent snapshot that was taken prior to the point in time performance degradation was observed.","The various embodiments described herein may employ various computer-implemented operations involving data stored in computer systems. For example, these operations may require physical manipulation of physical quantities\u2014usually, though not necessarily, these quantities may take the form of electrical or magnetic signals, where they or representations of them are capable of being stored, transferred, combined, compared, or otherwise manipulated. Further, such manipulations are often referred to in terms, such as producing, identifying, determining, or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition, one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes, or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular, various general purpose machines may be used with computer programs written in accordance with the teachings herein, or it may be more convenient to construct a more specialized apparatus to perform the required operations.","The various embodiments described herein may be practiced with other computer system configurations including hand-held devices, microprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.","One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system\u2014computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive, network attached storage (NAS), read-only memory, random-access memory (e.g., a flash memory device), a CD (Compact Discs)\u2014CD-ROM, a CD-R, or a CD-RW, a DVD (Digital Versatile Disc), a magnetic tape, and other optical and non-optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.","Although one or more embodiments of the present invention have been described in some detail for clarity of understanding, it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly, the described embodiments are to be considered as illustrative and not restrictive, and the scope of the claims is not to be limited to details given herein, but may be modified within the scope and equivalents of the claims. In the claims, elements and\/or steps do not imply any particular order of operation, unless explicitly stated in the claims.","Virtualization systems in accordance with the various embodiments may be implemented as hosted embodiments, non-hosted embodiments or as embodiments that tend to blur distinctions between the two, are all envisioned. Furthermore, various virtualization operations may be wholly or partially implemented in hardware. For example, a hardware implementation may employ a look-up table for modification of storage access requests to secure non-disk data.","Many variations, modifications, additions, and improvements are possible, regardless the degree of virtualization. The virtualization software can therefore include components of a host, console, or guest operating system that performs virtualization functions. Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention(s). In general, structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the appended claim(s)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6B"}]},"DETDESC":[{},{}]}
