---
title: Distributed computing system hierarchal structure manipulation
abstract: A hierarchal structure manipulation system may include a nested table generation module to generate nested tables representing hierarchal relationships of computing systems in a distributed computing environment. A hierarchal structure manipulation module may access at least one nested table to manipulate a hierarchal structure represented by the nested table. The hierarchal structure manipulation module may use a generic algebraic specification to manipulate the hierarchal structure represented by the nested table. The generic algebraic specification may provide a generic abstraction across a plurality of the computing systems in the distributed computing environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08856190&OS=08856190&RS=08856190
owner: Accenture Global Services Limited
number: 08856190
owner_city: Dublin
owner_country: IE
publication_date: 20110630
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["In distributed computing environments such as cloud computing, users may use multiple server-based computational resources via a network. In such environments and other computing environments generally, hierarchical organizations of data may be represented and manipulated by systems, such as, file systems, database schemas, compilers, eXtensible Markup Language (XML), HyperText Markup Language (HTML), Electronic data interchange (EDI), relational data, any type of user-defined structure, or a proprietary structure a company or organization may use. Application programming interfaces (APIs) may be used to access services. In distributed computing environments, each cloud may have different API calls. Hierarchical data vendors may offer libraries that export API calls that deal with low-level details of hierarchical structure organizations, with such calls being referred to as canonical API calls. These calls are orthogonal and may create a basis for building the next level of functionality. These APIs may be complicated and may have a steep learning curve to master their functionality. The difficulties in using the foregoing libraries are the result of complex interactions among the canonical APIs. For example, in order to access certain elements in a XML tree using Document Object Model (DOM) API, the tree may be loaded in memory and a handle to the structure that represents this tree may be obtained in order to be used in subsequent API calls.","As a result of the complex dependencies among canonical APIs, software can be difficult to write. For example, even though the basic functionality of the MICROSOFT XML API and the XERCES XML API are comparable, their APIs may not be equivalent. This means that if a MICROSOFT implementation is to be replaced with the XERCES implementation, a software rewrite may be needed.","A preliminary step in designing software that manipulates hierarchical data may include writing a requirement specification. The choice of a language for this specification may also be carefully decided. If the chosen language is implementation specific and depends on the compiler used, then it may be difficult to convert such a specification to a different language. Another difficulty may include detection of possible ambiguities in the selected language because of its complex semantics.","Alternatively, if the chosen language is too formal, it may require significant efforts to translate the formal specification into a sequence of algorithmic steps implemented in a particular language. Formal methods may provide a higher level of abstraction than a series of algorithmic steps. However, problems may occur when the impedance mismatch between a formal specification and implementation languages with canonical APIs is significant. In such a case, the high level of abstraction that can be achieved in formal specifications is grounded. Not only can it be difficult to verify the implementation code against the formal specification, it may also be impractical to write a code analyzer that checks various semantic aspects of data manipulation.","For simplicity and illustrative purposes, the principles of the embodiments are described by referring mainly to examples thereof. In the following description, numerous specific details are set forth in order to provide a thorough understanding of the embodiments. It will be apparent that the embodiments may be practiced without limitation to all the specific details. Also, the embodiments may be used together in various combinations.","1. Overview","In distributed computing environments such as cloud computing and in other multi-computer computing environments generally, it can be beneficial to have a formal specification whose semantics is close to those of a group of implementation languages. Program formal specifications may be precise and defined in abstract terms without overwhelming details of canonical APIs. The specifications may be refined into concrete implementations using predefined rules. Further, formal methods may provide tools that can detect deviations of program implementations from the original specifications. The hierarchal structure manipulation system described herein provides a formal specification for hierarchical structures that may be translated into implementation in languages such as, for example, C++, C#, and Java. The hierarchal structure manipulation system may include a set of axioms for representing hierarchical structures, and provides clear and concise notations that may be translated into programming implementations.","Hierarchical structures may be defined by a set of axioms that state their properties. For hierarchal structures, an abstract syntax tree (AST) may be defined as a tree representation of an abstract syntactic structure of source code written in a programming language. An AST may differ from implementation to implementation of a parser. Each node of the tree may denote a construct occurring in the source code. A parser may analyze text, made of a sequence of tokens (e.g., words), to determine its grammatical structure with respect to a given formal grammar. The parser may be provided at a front end of a compiler. A compiler, as is conventionally known, transforms source code, which may be written in a high-level programming language, into another computer language, such as assembly or some other low-level computer language. A compiler may include the front end, a middle end and a back end. The front end may check whether a program is correctly written in terms of the programming language syntax and semantics. The front end may then generate an intermediate representation (IR) of the source code for processing by the middle end. The front end may also manage a symbol table, which may be defined as a data structure mapping each symbol in the source code to associated information such as location, type and scope. The middle end may optimize the IR, and generate another IR for the back end. The back end may be responsible for translating the IR from the middle end into assembly code.","Depending on the goals of a compiler design, an AST may carry attributes for subsequent analyses and target platform code generation. The complexity of an AST may be proportional to, for example, the number of different types of nodes multiplied by the number of different types of attributes in each node. The complexity of data structures can result in the complicated APIs that manipulate the data structures. The foregoing complexity-related factors and other factors may lead to incompatibility of different components of compilers. These factors may also lead to complexity in a rule sections of a parser, which may present difficulties during debugging and maintenance. The coupling between the programming language dependent parsing and subsequent parts, for example, semantic analysis, may also present difficulties for reusing parts of different compilers.","Applicability of the hierarchal structure manipulation system to systems that use hierarchical structures by implementing a C# parser is described below by way of example. The implementation process includes construction and manipulation of large ASTs. The hierarchal structure manipulation system addresses the foregoing and other difficulties encountered when dealing with ASTs by providing a general approach that allows for syntax-tree level API independent of a specific tree implementation.","Various techniques may be used to allow developers to compose compilers using reusable components. The ability of constituent components to interoperate may enhance the functionality of a compiler. The IR may be considered the link that provides for such interoperability. However, IRs may be language dependent, and use additional infrastructure to operate. For example, the ZEPHYR AST description language offers a grammar and tools that compiler developers may use in order to generate code that processes ASTs. Other IR implementations may offer various syntactic and semantic rules that may require extensive up-front investment from compiler developers without a clear vision of the achievement of interoperability with other components of other compilers. Known IR implementations however may not preserve the value of the original Backus Normal Form (BNF) grammar, while also facilitating mapping to the concrete language syntax. BNF may be defined as a notation technique for context-free grammars, which may be used to describe the syntax of languages used in computing. Examples of languages may include computer programming languages, document formats, instruction sets and communication protocols. For the hierarchal structure manipulation system, an example of generating an IR that addresses the foregoing and other limitations is described below, and an example based in XML is provided.","As described above, hierarchical structures may be defined by a set of axioms that state their properties. For example, a property of a XML data may state that it should have exactly one root element. Algebraic specifications may provide term rewriting that replaces a part of an equation by another part. The hierarchal structure manipulation system includes a framework that takes formal specifications of hierarchical systems and generates its implementation in a chosen language. The hierarchal structure manipulation system provides an abstraction over different canonical APIs that manipulate hierarchical systems. A front end for the hierarchal structure manipulation system may be implemented as a Hierarchal Structure Manipulation Language (HSML) that uses the facilities of polymorphism and overloading to implement an algebraic notation, denoted ASHIES (Algebraic Specification for Hierarchical Structures). In distributed computing environments such as cloud computing, and in computing environments generally, the different API calls in such environments may be buried into ASHIES. An implementation of HSML in C++ that utilizes parametric polymorphisms and C# implementation that is based on the subtype polymorphism is described below. Both implementations also use ad-hoc polymorphism for operator and method overloading to implement ASHIES.","As described in further detail below, the hierarchal structure manipulation system may include a nested table generation module to generate nested tables representing hierarchal relationships of computing systems in a distributed computing environment. A hierarchal structure manipulation module may access at least one nested table to manipulate a hierarchal structure represented by the nested table. Manipulation of a hierarchal structure may defined as any type of query or command based access, transformation or use of information in the hierarchal structure. The system may include a hierarchal structure viewer module for viewing a hierarchal structure that can be manipulated by a user. The hierarchal structure manipulation module may use a generic algebraic specification (i.e. ASHIES) to manipulate the hierarchal structure represented by the nested table. The generic algebraic specification may provide a generic abstraction across a plurality of the computing systems in the distributed computing environment.","With regard to manipulation of hierarchical structures, various notations may provide for such manipulation and may be considered languages. When a program is written using complex and difficult-to-remember APIs, this may present difficulties in analysis on the subject of code transformation with the following reduction and subsequent automation of repetitive programming tasks. The HSML may be based on an abstraction that treats tree structures as multidimensional arrays. HSML may offer a concise algebraic notation that can be turned into implementation without exposing any APIs.","In certain aspects, building an IR may be considered a mandatory step in modern compiler construction that does not have a clear algorithmic definition. Once defined, the IR influences the subsequent steps of compiler development such as code generation, optimization, etc. Therefore, it may be prudent to decide upon the form and content of IR at an early stage to avoid subsequent rewriting of compiler parts.","Code transformation and conversion tools have become more common with the proliferation of programming languages. An example of such a tool includes a tool for converting C++ into Java source code. In such tools, the real conversion strategy may be determined on the grammar level. When IR reflects the original grammar with encoded transformational dependencies, then a tool can be built that automatically generates the target language code from the IR. For each matching pair of grammar rules in both languages, a conversion strategy may be determined and then coded. The API developed to perform the conversion may be a parser tool dependent. However, each parser tool may be language dependent. For example, when LEX\/YACC is used, then the parser generated code may be in C or C++. This may impose constraints on the representation of ASTs, API, and subsequently the rest of the compiler. The capability of taking an IR and feeding it into a different compiler may improve the quality of the generated code and facilitate conversion between different languages.","XML may be used as a de-facto industry standard for data exchange. XML may provide a universal format for representing any data structure, and various parsers that process XML file structures into the internal representation called DOM. Each node in the DOM may have the same datatype and may have a different number of attributes that describe its structure. In an example described below, the hierarchal structure manipulation system allows compiler developers to build a XML-based intermediate language when parsing any source language. The HSML offers a concise syntax for navigation of XML DOM. The HSML may be used to code the rule sections of parsers. Since both ASTs and XML have strictly hierarchical structures, XML-based ASTs may be built. With such an AST constructed, HSML may be used to traverse and manipulate tree elements. The HSML based approach described herein also allows for automatic generation of code for the front end of a compiler. HSML may be implemented on top of C++ and provides symbolic computational properties to manipulate hierarchical structures. The hierarchal structure manipulation system also provides for a XML-based intermediate representation (XMLIR) that improves various front-end compiler algorithms such as symbol table creation and lookup, and AST generation and traversal.","The hierarchal structure manipulation system provides significant reduction of code required to build ASTs, symbol table, and inheritance hierarchies. The hierarchal structure manipulation system also provides for defining of an IR based on a fixed sequence of steps to build a compiler front end. Instead of proposing new platform-dependent APIs, the HSML may provide parameterized uniform access to hierarchical structures with arbitrary defined types. The uniform semantics may reduce complexity of the underlying structure manipulation mechanisms and expose only the operations over explicitly defined types.","The HSML may thus provide a uniform method of accessing, analyzing and manipulating a hierarchal structure. If the structure format changes, the same HSML code may be used. By using a subset of overloaded operators for a HSMLGenericAccess class as described in further detail below, the hierarchal tree structure may be manipulated, independent of the hierarchal structure. The HSML thus provides an abstraction on top of existing function calls to thus subsume the complexity of the function calls.","2. System",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 1","FIG. 2","FIGS. 1 and 2","FIG. 3"],"b":["100","103","100","101","120","102","103","100","104","105","105","103","106","105","106","107","105","105","100","108","107","109","100"]},"Algebraic Specification for Hierarchical Structures (ASHIES) is described with reference to .","For distributed computing environments such as cloud computing, and in computing environments generally, as discussed in further detail below, ASHIES provides the generic abstraction across all types of platforms in such environments. Algebraic specifications may state operations in terms of other operations called algebraic equivalences. For example, a group of canonical APIs that move an element in a hierarchical structure under a different branch may be written as two basic operations: \u2018copy\u2019 the element to its new location and \u2018remove\u2019 the old element. These two operations may be stated as a single \u2018move\u2019 operation. Writing these operations as equations may provide term rewriting. For example, if equation GetElement[\u201cA\u201d]=y means that the element that bears symbolic name A is located in a tree and its value is set to variable y, then the equation GetElement[GetElement[\u201cA\u201d]] if y is equal to \u201cA\u201d may be replaced with y.","As described herein, ASHIES provides for support of intuitive syntax for facilitating programming with hierarchical structures and for facilitating translation into implementation languages. Generally, there may be a strong binding between the names of elements of hierarchical structures and their locations in computer memory. This binding may lead to strong coupling between names of variables and functions that manipulate them. For example, for an element called Salary of a hierarchical structure, a variable of float type that has name m_EmployeeSalary may be created. Subsequently, functions that manipulate this element may be referenced with names that have meaningful semantics, for example, IncreaseSalary or SetSalary. Parameters and return types of these functions may naturally depend on the type of the variable m_EmployeeSalary. If the element Salary were to be replaced with a different element called Commission that has the type integer, even though the formal specification may be readily changed, the maintenance of software for these hierarchical structures can become difficult. A developer may locate all places where the variable m_EmployeeSalary is used, replace it with a new name, and change the names and possibly parameters and return types of functions that manipulate this variable. All usage of these functions may be changed as well. This can be a manual and tedious task. A significant change in the structure of the tree and the logic that manipulates it can be even more difficult to address. Such a change may require a major rewrite of the software with little to no possibility of code reuse.","Many hierarchical structures may bind string-based names to physical representations of elements. For example, XML and HTML are examples of such structures. Each element has a name called a tag that can be assigned a value, and attributes that can also have values. An element may contain many nested elements to any level of depth. The World Wide Web Consortium (W3C) defines a model to represent hierarchical document content internally called the DOM. DOM level-2 is a specification that defines a platform- and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of documents. Commercial parsers may use DOM to internally represent document content. Using DOM, software developers may access any component of a hierarchical-structured document using a standardized set of interfaces.","For example, referring to , an example is shown representing expression X*(Y+6\/Z) using a hierarchical structure such as an AST. X, Y, and Z may be identifiers that are assigned numerical values. As shown in , each of the algebraic operations is described using tags, for example <multiply> for product, <sum> for addition, and <divide> for ratio of two numbers.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5","FIG. 5","FIG. 6","FIG. 5","FIG. 6","FIG. 7","FIG. 6"]},"In order to facilitate programming with hierarchical structures, the system  uses type hiding. Generally, hierarchical structures such as XML and HTML DOM contain different data types. The inherent heterogeneousity of these structures may dictate the need for separate API calls for each type. However, since the operations performed over the nodes of different types may be similar, a HSMLGenericAccess class is provided. The HSMLGenericAccess class may address the types and implementation of hierarchical structure nodes. The relationships among nodes of different types may thus be modeled by performing an implicit conversion of their values. For example, in order to convert a XML attribute into a node while preserving its value, the details of the node and attribute structures may be omitted. This may be accomplished by writing expression x[\u201cParentNode\u201d]+=x[\u201cSomeNode\u201d](\u201cAttrNode\u201d). The left value (I-value) of this expression may navigate to ParentNode of a structure encapsulated in instance x of the HSMLGenericAccess class. The I-value may return a reference to the instance that has an internal current node pointer set to the first node in the collection of all ParentNodes. The right value (r-value) of this expression may navigate to attribute AttrNode under SomeNode. An internal structure of this instance may keep the values of the attribute name and its value. When calling operator += the name of the attribute may be added as a new node under ParentNode and its value set to be the value of the attribute node. Since the node is moved to its new location, the attribute may be deleted after the operation is completed.","In order to write a statement, a HSMLGenericAccess type object may be written without use of any manipulation operators, such as +=. For example, the statement x[\u201cParentNode\u201d] allows for navigation of the internal pointer to ParentNode node encapsulated in instance x of the HSMLGenericAccess class. The internal pointers may be reset to their original values when an operation is accomplished over an instance of the class.","The HSMLGenericAccess class may also function as a smart pointer. The implementation object passed as a template parameter to this class and its internals may be accessed any time. This may be accomplished by overloading the dereferencing operator \u2192 that allows a developer to retrieve the internal objects and their operations to invoke them manually by using pointers. The HSMLGenericAccess class also provides for internal object life span management as well as all internal pointers and their memory allocation and deallocation. The reference semantics of the HSML may require that an object is shallow-copied in assignment and other situations when copying is required. The new internal object may be allocated and all pointers to the internal structures are copied. This approach is beneficial in making operations faster and occupying less memory. This approach however requires the HSMLGenericAccess class to have a reference counter that may prevent the creation of dangling pointers.","The HSML operators may be the members of the HSMLGenericAccess template class. Bracket operator [ ] may denote the access to a DOM element. For example, the bracket operator [ ] may be overloaded for the access by element name bound to a Standard Template Library (STL) type string variable and by the order number in the collection that is of integer type. For example, the STL may be defined as a software library partially included in the C++ Standard Library. The declarations of the operators in C++ are shown in . These operators may be overloaded to take arguments, such as integer and string as shown in .","The parameter class T may be a system-dependent implementation of a hierarchical structure API, for example, a DOM proprietary API. Nodes and attributes in hierarchical structures may be accessed by their names or the order number in the collection of nodes or attributes on the same level. The HSML approach may thus consider such structures as multidimensional arrays. When accessing an element, the next node may be accessed either by its name or the order number. The combination of overloaded operators [ ] may allow for access to nodes by their names and some by their order number. A DOM document may be represented as a multidimensional array and stored in a variable named \u201cdoc\u201d. For example, statement doc[\u201cbody][\u201csection2\u201d][2] may navigate to section 2, item 3 of the document body.","The HSMLGenericAccess class may thus provide for use of the same generic operations on data, and may be extended as needed. For example, for a new data structure, the HSMLGenericAccess class may be extended by adding to it specific data dependent manipulations for implementing the generic operations described herein.","The HSML overloaded operators are described.","The HSML may use overloaded operators +, +=, \u2212=, <<, >>, <, >, ==, !=, <=, >= in order to provide algebraic level manipulation of tree structure elements. Operators + and += may be overloaded to take a parameter such as a string name of a node or an attribute to add to the current node. Operators + and += may also accept an instance of the HSMLGenericAccess class as a parameter. For example, if x and y represent two DOM documents, statement x[\u201cbody][\u201csection2\u201d][2]+=y[\u201ctitle\u201d][\u201csub\u201d] may mean that the subtitle for document y is copied and appended to section 2, item 3 of the body for document x. The semantics of \u2212 and \u2212= operators may be similar to the + operators with the difference of removing nodes and attributes instead of adding them.","Stream operators may read the values of nodes and attributes and copy them into the destination variables. The stream operators may determine the type of a value automatically and perform the proper conversion. Comparison operators may allow for compact comparison semantics. For example, expression y[\u201cB\u201d]>=3 may allow for checking to determine if there are more than three nodes named \u201cB\u201d in the collection of nodes under the root node of instance y. As described herein, for the HSML, a DOM representation may be treated as a multidimensional array. The array may be recursively defined as a container matrix, where E is a matrix of elements and A is a matrix of attributes, as follows:",{"@attributes":{"id":"p-0063","num":"0062"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mrow":{"mo":["[","]"],"mi":"E"}}},{"mtd":{"mrow":{"mo":["[","]"],"mi":"A"}}}]}},"mo":"\u2003"}}},"br":{}},{"@attributes":{"id":"p-0064","num":"0063"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"mo":["[","]"],"mi":"Variable"}},{"mrow":{"mo":["[","]"],"mi":"Variable"}},{"mrow":{"mo":["[","]"],"mi":"Method"}}]},{"mtd":[{"mrow":{"mo":["[","]"],"mi":"Type"}},{"mrow":{"mo":["[","]"],"mi":"Type"}},{"mrow":{"mo":["[","]"],"mi":"empty"}}]}]}},"mo":"\u2003"}}}},"Based on the foregoing, referring to  (described in further detail below), a program may be considered as an element or a matrix that contains another element such as Class, with Class containing elements Method and Variable. The matrix may thus include elements and attributes, and may be defined recursively. For example, by accessing an element of the matrix, the element may itself include another matrix which may be accessed recursively. Each subsequently accessed matrix may include elements which may include respective matrices that may be accessed recursively.","Based on the abstraction that each element and attribute may have a value, the HSML allows parameterized access to DOM elements. The HSML may provide access to the elements of a container that is defined by both name and its order in a collection of containers. As described herein, the HSML may function as a generic library for providing access to a DOM-based data representation, with the data representation being considered a multidimensional array.","As discussed above, in distributed computing environments such as cloud computing, and in computing environments generally, ASHIES provides the generic abstraction across all types of platforms in such environments. ASHIES may function as a language and provide a method of abstraction that is universal for different computing environments. For example, for clouds such as AZURE or EC2, instead of different abstractions specific to each cloud, ASHIES provides a general abstraction that operates with any platform. The general abstraction is based on the concept of having nest tables that contain nested tables. For example, a table may include headers and each cell in the table may be a table itself with headers. For an external table, all the cells in the table may be accessed by specifying the row and the header name. Once accessed, the cell may be a table itself, which includes headers and rows. In this manner, the tables may be recursively accessed until a desired data element is reached.","Referring to , an example of nested tables is provided. As shown in , each cell may contain a table which in turn contains cells that contain other tables. Assuming a reification object (RO) represents this table, the cell at column 2 and row 2 may be accessed using the following notation, RO[\u201cPoint A\u201d][1], where \u201cPoint A\u201d is the name of the column and 1 is the index of the row (the numbering starts with zero). The operation RO[\u201cPoint A\u201d][1] returns a table that is contained in this cell, and the cells of the nested table may be accessed using the same notation RO[\u201cPoint A\u201d][1][\u201cPoint C\u201d][\u201cPoint D\u201d] returning the value 91.","The generic abstraction provided by ASHIES may thus be based on the abstraction of tables into tables. A table may be the generic abstraction of a data representation, where headers may name data and rows may specify different data entries. Every cell in the table may be another table, and the cells may be accessed by the foregoing HSML operators. The tables may also represent clusters of computers, with a first cluster of computers being a primary table, every cell in that table being a cluster including sub-clusters, with each sub-cluster being a table. In this manner, the lowest level table may represent a computer, which may have files that can be accessed to retrieve desired data element(s).","The HSML may provide parameterized uniform access to hierarchical structures with arbitrary defined types. The uniform semantics may reduce complexity of the underlying structure manipulation mechanisms and expose only the operations over explicitly defined types. The HSML may provide compositional semantics that separate the essence of the hierarchal structure manipulation problem from its complexity. The redundancy of various APIs may be hidden by HSML symbols and unified operational semantics. The HSML approach may facilitate writing of compact program specifications in the HSML for manipulating hierarchical structures that can be directly transformed into a working program.","Each hierarchical structure may be represented by a directed graph where nodes designate data types, edges determine the dependency hierarchy, and the nodes include attributes. Each attribute, as well as a node may have a value. A state of each node may be a union of its value and values of its attributes. A collection of connected nodes within a hierarchical structure may be called a branch. A branch may be a hierarchical structure itself. Examples of operations that are provided over hierarchical structures may include copy, move, remove, get value, set value, and path navigation within the structure. In order to implement these operations, the parameterized class HSMLGenericAccess is provided. A basis for this implementation is that for each hierarchical structure there exists an implementation dependent API that implements these operations. As discussed above, the parameterized class HSMLGenericAccess is declared as shown in .","The HSMLGenericAccess class takes the specific hierarchical structure implementation class as a template parameter and uses its methods to provide uniform access specification to the class users. The class may overload the stream operators >> and << to retrieve and set values of major primitive types. Besides the general copy constructor and assignment operator, the class may overload minus and plus operators as well as array access and functors.","An example of the HSML code to perform manipulations over a hierarchal structure, such as a XML file, is now described with reference to .","In order to describe use of the HSMLGenericAccess class, a XML example describing a hierarchical structure is shown in . As shown in , nodes A, B, C, and D may be considered as non-terminals that map to BNF grammar. Node D has values 1 and 2. While various manipulations may be performed, such as reading\/writing values, deleting\/adding nodes, deleting\/adding attributes, or copying branches etc., an example is provided of locating nodes D that have value 1 and attribute called Type having value \u201cstruct\u201d, and moving these nodes under the node B. The resulting XML file after performing manipulation over its structure is shown in . Using the HSMLGenericAccess class, an example of the HSML code to perform actions over the XML file is shown in .","Referring to , it can be seen that the HSML code does not use any proprietary API calls. The access and manipulation of the XML tree may thus be performed via the overloaded operators that accepted the custom type names as parameters. The HSML thus provides a concise program that does not require knowledge of any proprietary API, such as, the Microsoft XML DOM parser to process the data.","Based on the foregoing example, the HSML code as shown by example in  does not use any specific function calls that are proprietary to the data structure. For example, the HSML code does not use any XML specific data calls that would make the code specific for XML or another data structure type. Thus if the data structure were changed from XML to another hierarchal data structure such as HTML, EDI, relational data, any type of user-defined structure, or a proprietary structure a company or organization may use, the HSML code would remain the same. Based on the specific hierarchal structure, a corresponding HSMLGenericAccess class may be provided, and include the requisite low level function calls for the data structure type. The names A, B, C etc. of  may be generic names represented using different data representations.  thus show an example of a structure represented by a data representation (), manipulation thereof (), and the HSML code to manipulate the structure ().","Referring to , examples of application of the HSML code are described for building a parser.","As an example, grammar for a calculator in YACC is described. Referring to , the LEX specification for recognizing tokens of double-type numbers and identifiers is shown. For the calculator expressions for the LEX specification of , for certain regular expressions in LEX, rule sections that create XML data types may be defined and populated with attributes. For example, for a double precision float number, a XML type named \u201cNumber\u201d may be created and an attribute named \u201cValue\u201d may be added. The value of this attribute may be set as a numeric value of the token. Similar actions may be performed when a regular pattern defining identifiers is recognized. In this case, a XML type called \u201cIdentifier\u201d may be created, and the attribute \u201cName\u201d may be added to it, thus setting its value to be the identifier's recognized name.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 14","FIG. 14"]},"Referring to , the XMLIR produced as a result of parsing arithmetic expression X1\/(X2*(X3\u22125.11*(X4+8))) is shown.","Referring to , the grammar rules in the resulting AST are shown. By embedding grammar rules in the AST, a compiler may achieve the following benefits. For example, embedding of grammar rules facilitates trace of the paths in the AST knowing the derivations in the grammar. Further, the process of mapping grammar rules to an AST may also be automated since a developer does not need to think about what API to use for a specific rule.","In order to illustrate the XIL data as a visible parse tree graph, an editor, such as XML SPY, that uses eXtensible Stylesheet Language Transformations (XSLT) transformation properties, may be used. Referring to , a visual presentation of a XIL parse tree provided by XML SPY is shown.","An example of building a symbol table using the HSML-based approach is described.","A compiler may include a symbol table as a central data structure. The symbol table may hold information on program identifiers with their attributes, such as types and initial values. The symbol table may be created by traversing an AST and harvesting all related information from its nodes. The HSML-based approach may be used to accomplish tasks in building a symbol table. In the  expression calculator example, variables may be freely defined in an expression. However, the variables may be assigned values in order to evaluate the expression. An example of a technique for accomplishing this may be to traverse the XMLIR tree and find all nodes of type \u201cIdentifier\u201d that do not have attribute Value. Once such a node is found, a user of the calculator may be requested to supply a value for a variable. However, the same variable may be encountered many times in an expression. Thus all distinct variables in a symbol table may be listed and referenced on an as needed basis.","The algorithm for creation of a symbol tree from XIL using HSML is shown in . Referring to , function CreateSymbolTree may take two parameters of HSMLGenericAccess type. The first parameter xir may contain XMLIR representation of a parsed source program and second parameter st may contain the resulting symbol table. The for-loop may create an integer variable i that serves as an iterator through the nodes of xir. A node i of xir may be retrieved and assigned to a temporary variable branch of HSMLGenericAccess type. The node may be checked to determine if it is an \u201cIdentifier\u201d type node. If it is not, then CreateSymbolTree may be recursively called to process the children of the current node. Otherwise, the \u201cName\u201d attribute of the \u201cIdentifier\u201d type node may be retrieved, and checked to determine if this entry already exists in the symbol table. If it does not exist, then a user may be prompted to enter a numeric value for this identifier, with the value being set to the \u201cValue\u201d attribute of the node, and then added to the symbol table. Referring to , it can be seen that the algorithm does not use any proprietary API to manipulate the AST. Furthermore, the description is formal and may be readily fed into various verification tools to check for correctness.","Aggregated containment levels are described with reference to .","As discussed above with reference to , it was assumed that the key used for symbol table lookup was the identifier. In modern programming languages, the same name may be used to refer to multiple objects within the same program. A containment level is the textual region of the program in which a binding of an identifier to its name is active. A complex form of a program may contain aggregated containment levels. When the original grammar defines aggregated containment levels, the process that builds a symbol tables may become complicated. The resulting AST may be traversed a number of times in order to determine all containment level dependencies among the nodes. The implementation thus magnifies the complexity created by a hierarchical structure traversal API. One aspect of the approach described herein for creating a symbol table with aggregated containment levels may be that the information about the aggregated containment levels is embedded in the original grammar, and is extracted during traversal of the XMLIR with initial information about the containment levels of rules and dependencies.","Referring to , an example of a directed graph representation and its grammar are respectively shown. A directed graph may be defined as a pair G=(V,A) of a set V, whose elements are called vertices or nodes, and a set A of ordered pairs of vertices, called arcs, directed edges, or arrows. Referring to , the top node A may designate the top containment level. As shown in , root computer A may communicate with either leased computer B or leased computer C and leased computer D. Leased computer B may communicate with processing nodes e, f and g. Leased computer C may communicate with either leased computer K or processing nodes I and Q. Leased computer D may communicate with processing nodes m, n and o. Leased computer K may communicate with processing node p. Further, leased computer Q may communicate with processing node r and s.","Referring to , the algorithm thus shows how different aggregated containment levels may be accessed using the implementation of ASHIES and the generic operators to obtain different containment levels and navigate generic hierarchal structures. The algorithm thus provides an example of traversing trees and accessing data with different containment levels, and linking nodes that are allocated on different platforms. The nodes of  may also represent data in different formats. The algorithm is thus generic and may be used to access any type of data located on cloud computing or other platforms on any different nodes in different formats.  thus provides an example of representation of such nodes.","An example of the resulting symbol table is shown in . The name of each containment level may become a node in the resulting XMLIR symbol table. The aggregated containment levels may become children nodes under the XMLIR node of the parent containment level. An example may be if node f is a name of a class that contains method r that returns type void and contains internally defined variables internalvariable1, internalvariable2, and so forth. Instead of keeping a running count of block numbers or using similar processes, the hierarchy may be navigated when looking for a certain level of containment level or its name. Once it is found, all containment level identifiers may be found by getting the list of child nodes.","The algorithm for building a symbol table containing aggregated containment levels from XMLIR is shown in . The symbol table that is implemented as an instance of HSMLGenericAccess class may be initialized. Since XML files may have only one root node, the root node may be created during the initialization step. The XMLIR tree may also be initialized by setting its root node to be the current node. As shown in , the BUILDSCOPES function may be recursively called that takes a reference to a XMLIR node as its first parameter and a reference to the symbol table.","Application for HSML for generic cloud computing is described with reference to .","In an example, a process of the HSML operating with XML may be modeled as the progression of an order as it moves from the top of the tree to its leaves. If a XML file contains information about a parsed program in XMLIR, then the information model may describe the classes, class methods and variables. The HSML may operate with types of data as opposed to instances of data.","Referring to , an example is illustrated of a schematic  of a hierarchal structure, which in this example is a tree structure describing grammar production rules. The schematic  may include XML elements  including element attributes . For the particular example of , the schematic  may also include a top element called Program that is not necessarily the root of a XML file, and a child element called Class. Additional elements and attributes may be provided. Each Class element may include child elements called Methods and Variables. The relationship between the parent element and the child element may be shown with an arrow  directed from the parent to the child. Each element may include additional elements of the same type and on the same level.","In order to manipulate the  structure, a developer may consider finding all variables with a certain type declared in a class. For example, if MICROSOFT XML (MSXML) parser is used to parse the XML file into DOM, then a set of operations in pseudocode is shown in . The DOM may be defined as a cross-platform and language-independent convention for representing and interacting with objects in HTML, eXtensible HyperText Markup Language (XHTML) and XML documents. Aspects of the DOM (e.g. elements) may be addressed and manipulated within the syntax of the programming language in use. Each line of the pseudocode may require developers to write a substantial amount of code. Manipulation of XML data may include, for example, the following operations on elements and attributes: path navigation, copying, moving, adding, removing, and setting and retrieving their values. XSLT and XPath may not remove the need for writing code that initializes XML documents and copies elements. As described herein, for the HSML, a DOM representation may be treated as a multidimensional array. The array may be recursively defined as a container matrix, where E is a matrix of elements and A is a matrix of attributes, as follows:",{"@attributes":{"id":"p-0096","num":"0095"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mrow":{"mo":["[","]"],"mi":"E"}}},{"mtd":{"mrow":{"mo":["[","]"],"mi":"A"}}}]}},"mo":"\u2003"}}},"br":{}},{"@attributes":{"id":"p-0097","num":"0096"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"mo":["[","]"],"mi":"Variable"}},{"mrow":{"mo":["[","]"],"mi":"Variable"}},{"mrow":{"mo":["[","]"],"mi":"Method"}}]},{"mtd":[{"mrow":{"mo":["[","]"],"mi":"Type"}},{"mrow":{"mo":["[","]"],"mi":"Type"}},{"mrow":{"mo":["[","]"],"mi":"empty"}}]}]}},"mo":"\u2003"}}}},"Based on the foregoing, referring to , a program may be considered as an element or a matrix that contains another element such as Class, with Class containing elements Method and Variable. The matrix may thus include elements and attributes, and may be defined recursively. For example, by accessing an element of the matrix, the element may itself include another matrix which may be accessed recursively. Each subsequently accessed matrix may include elements which may include respective matrices that may be accessed recursively.","Based on the abstraction that each element and attribute may have a value, the HSML allows parameterized access to DOM elements. The HSML may provide access to the elements of a container that is defined by both name and its order in the collection of containers. As described herein, the HSML may function as a generic library for providing access to a DOM-based data representation, with the data representation being considered a multidimensional array.","Semantics of the HSML are described.","The HSML may provide for support of intuitive syntax for facilitating programming with hierarchical structures, and allow extensions to facilitate incorporation into the language structure. Generally, hierarchical structures such as XML and HTML DOM contain different data types. The inherent heterogeneousity of these structures may dictate the need for separate API calls for each type. However, since the operations performed over the nodes of different types may be similar, the parameterized HSMLGenericAccess class is provided. The HSMLGenericAccess class may address the types and implementation of hierarchical structure nodes. The relationships among nodes of different types may thus be modeled by performing an implicit conversion of their values. For example, in order to convert a XML attribute into a node while preserving its value, the details of the node and attribute structures may be omitted. This may be accomplished by writing expression x[\u201cParentNode\u201d]+=x[\u201cSomeNode\u201d](\u201cAttrNode\u201d). The left value (I-value) of this expression may navigate to ParentNode of a structure encapsulated in instance x of the HSMLGenericAccess class. The I-value may return a reference to the instance that has an internal current node pointer set to the first node in the collection of all ParentNodes. The right value (r-value) of this expression may navigate to attribute AttrNode under SomeNode. An internal structure of this instance may keep the values of the attribute name and its value. When calling operator += the name of the attribute may be added as a new node under ParentNode and its value set to be the value of the attribute node. Since the node is moved to its new location, the attribute may be deleted after the operation is completed.","As described above, in order to write a statement, a HSMLGenericAccess type object may be written without use of any manipulation operators, such as +=. For example, the statement x[\u201cParentNode\u201d] allows for navigation of the internal pointer to ParentNode node encapsulated in instance x of the HSMLGenericAccess class. The internal pointers may be reset to their original values when an operation is accomplished over an instance of the class.","The HSMLGenericAccess class also functions as a smart pointer. The implementation object passed as a template parameter to this class and its internals may be accessed any time. This may be done by overloading the dereferencing operator \u2192 that allows a developer to retrieve the internal objects and their operations to invoke them manually by using pointers. The HSMLGenericAccess class provides the internal object lifespan management as well as all internal pointers and their memory allocation and de-allocation. The reference semantics of the HSML may require that an object is shallow-copied in assignment and other situations when copying is required. The new internal object may be allocated and all pointers to the internal structures may be copied. This approach may be beneficial in making operations faster and occupying less memory. This approach however requires the HSMLGenericAccess class to have a reference counter that may prevent the creation of dangling pointers.","Operators [ ] and ( ) of the HSMLGenericAccess class are described.","The operators [ ] and ( ) may be the members of the HSMLGenericAccess template class. Bracket operator [ ] may denote the access to a DOM element. For example, the bracket operator [ ] may be overloaded for the access by element name bound to a STL type string variable and by the order number in the collection that is of integer type. The declarations of the operators in C++ are shown in . The operators may be overloaded to take arguments of two types: integer and string. For example, the STL may be defined as a software library partially included in the C++ Standard Library. The parameter class T may be a system-dependent implementation of a hierarchical structure API, for example, a DOM proprietary API. As discussed above, nodes and attributes in hierarchical structures may be accessed by their names or the order number in the collection of nodes or attributes on the same level. The HSML approach may thus consider such structures as multidimensional arrays. When accessing an element, the next node may be accessed either by its name or the order number. The combination of overloaded operators [ ] may allow for access to nodes by their names and some by their order number. As discussed above, a DOM document may be represented as a multidimensional array and stored in a variable named \u201cdoc\u201d. For example, statement doc[\u201cbody][\u201csection2\u201d][2] may navigate to section 2, item 3 of the document body.","An example of an application of using HSML to build parsers, such as a C# parser, is described with reference to .","Referring to , the HSML approach may be used to build parsers, such as a C# parser. The use of XMLIR processes may reduce the compiler design and development time. The C# parser may be built by implementing a context-free grammar of the full set of C# with the exception of unsafe code and preprocessor directives. As a starting point, user-consumption grammar rules may be used. The HSML approach as described herein may also be used to build code-dependent editors. With XMLIR as a starting point, a tool may be built for providing the visual representation of XMLIR and a symbol table. Referring to , the front end of the tool that provides for browsing XMLIR and symbol table data is shown.","The HSML code  may thus provide a uniform method of accessing and manipulating hierarchal structures, such as the XML structure of . If the structure format changes, the same HSML code may be used, as described above for the example for . Data may be accessed in a standard manner as information access using multidimensional arrays. By using a subset of overloaded operators for the HSMLGenericAccess class as described above, the hierarchal tree structure may be manipulated, independent of the hierarchal structure. As also described above, HSML may also provide a generic hierarchal structure by providing a uniform way to represent the hierarchal structure. The generic hierarchal structure may also be adjusted to the facilities of an existing language. For example, by using the HSMLGenericAccess class, facilities of an existing programming language may be used. Thus when using existing syntax, an existing compiler may be leveraged. For example, by introducing the HSMLGenericAccess class in C++ or C# (or another programming language), data access and syntax may be implemented, and semantics may, be applied without developing a language extension. By using facilities of an existing programming language, the implementation may function as a library as opposed to a programming language. By providing a generic hierarchal structure, a holistic view of a multi-language system may be obtained, regardless of the programming language used to implement the system.","3. Method",{"@attributes":{"id":"p-0109","num":"0108"},"figref":["FIG. 25","FIGS. 1-24"],"b":["300","105","300","100","300"]},"At block , the system  may receive the query  from a user for manipulation of the hierarchal structure . The query  may be in the form of an expression represented in the generic algebraic specification (i.e. ASHIES). Alternatively, the system  may convert the query by the user to an appropriate generic algebraic specification as described above. As described above, for the hierarchal structure , hierarchical organizations of data may be represented and manipulated by systems, such as, file systems, database schemas, compilers, eXtensible Markup Language (XML), HyperText Markup Language (HTML), Electronic data interchange (EDI), relational data, any type of user-defined structure, or a proprietary structure a company or organization may use. As also described above, the generic algebraic specification may use overloaded operators that are members of the HSMLGenericAccess class.","At block , the system  may generate nested tables representing hierarchal relationships of the computing systems  in the distributed computing environment . As described above, the distributed computing environment  may be a cloud computing environment.","At block , the system  may access at least one nested table representing the hierarchal structure  from the set of nested tables.","At block , the system  may manipulate the hierarchal structure  by using the generic algebraic specification. As described above, the generic algebraic specification ASHIES may also provide a generic abstraction across the computing systems . ASHIES may also provide a generic abstraction across programming languages in the distributed computing environment.","At block , the system  may generate the response , which may be in the form of a data manipulation represented by the query expression.","4. Computer Readable Medium",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 26","b":["400","400","400","100","400"]},"The computer system  includes a processor  that may implement or execute machine readable instructions performing some or all of the methods, functions and other processes described herein. Commands and data from the processor  are communicated over a communication bus . The computer system  also includes a main memory , such as a random access memory (RAM), where the machine readable instructions and data for the processor  may reside during runtime, and a secondary data storage , which may be non-volatile and stores machine readable instructions and data. The memory and data storage are examples of computer readable mediums.","The computer system  may include an I\/O device , such as a keyboard, a mouse, a display, etc. The computer system  may include a network interface  for connecting to a network. Other known electronic components may be added or substituted in the computer system .","While the embodiments have been described with reference to examples, various modifications to the described embodiments may be made without departing from the scope of the claimed embodiments."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The embodiments are described with reference to the following figures:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 26"}]},"DETDESC":[{},{}]}
