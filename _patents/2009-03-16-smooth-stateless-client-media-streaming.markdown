---
title: Smooth, stateless client media streaming
abstract: An adaptive streaming system is described herein that provides a stateless connection between the client and server for streaming media playback in which the data is formatted in a manner that allows the client to make decisions and react more quickly to changing network conditions. The client requests uniform chunks of media from the server that include a portion of the media. The adaptive streaming system requests portions of a media file or of a live streaming event in small-sized chunks each having a distinguished URL. This allows streaming media data to be cached by existing Internet cache infrastructure. Each chunk contains metadata information that describes the encoding of the chunk and media content for playback by the client. The server may provide chunks in multiple encodings so that the client can switch quickly to chunks of a different bit rate or playback speed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621044&OS=08621044&RS=08621044
owner: Microsoft Corporation
number: 08621044
owner_city: Redmond
owner_country: US
publication_date: 20090316
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Streaming media is multimedia that is constantly received by, and normally presented to, an end-user (using a client) while it is being delivered by a streaming provider (using a server). Several protocols exist for streaming media, including the Real-time Streaming Protocol (RTSP), Real-time Transport Protocol (RTP), and the Real-time Transport Control Protocol (RTCP), which streaming applications often use together. The Real Time Streaming Protocol (RTSP), developed by the Internet Engineering Task Force (IETF) and created in 1998 as Request For Comments (RFC) 2326, is a protocol for use in streaming media systems, which allows a client to remotely control a streaming media server, issuing VCR-like commands such as \u201cplay\u201d and \u201cpause\u201d, and allowing time-based access to files on a server.","The sending of streaming data itself is not part of the RTSP protocol. Most RTSP servers use the standards-based RTP as the transport protocol for the actual audio\/video data, acting somewhat as a metadata channel. RTP defines a standardized packet format for delivering audio and video over the Internet. RTP was developed by the Audio-Video Transport Working Group of the IETF and first published in 1996 as RFC 1889, and superseded by RFC 3550 in 2003. The protocol is similar in syntax and operation to Hypertext Transport Protocol (HTTP), but RTSP adds new requests. While HTTP is stateless, RTSP is a stateful protocol. RTSP uses a session ID to keep track of sessions when needed. RTSP messages are sent from client to server, although some exceptions exist where the server will send messages to the client.","Streaming applications usually use RTP in conjunction with RTCP. While RTP carries the media streams (e.g., audio and video) or out-of-band signaling (dual-tone multi-frequency (DTMF)), streaming applications use RTCP to monitor transmission statistics and quality of service (QoS) information. RTP allows only one type of message, one that carries data from the source to the destination. In many cases, there is a need for other messages in a session. These messages control the flow and quality of data and allow the recipient to send feedback to the source or sources. RTCP is a protocol designed for this purpose. RTCP has five types of messages: sender report, receiver report, source description message, bye message, and application-specific message. RTCP provides out-of-band control information for an RTP flow and partners with RTP in the delivery and packaging of multimedia data, but does not transport any data itself. Streaming applications use RTCP to periodically transmit control packets to participants in a streaming multimedia session. One function of RTCP is to provide feedback on the quality of service RTP is providing. RTCP gathers statistics on a media connection and information such as bytes sent, packets sent, lost packets, jitter, feedback, and round trip delay. An application may use this information to increase the quality of service, perhaps by limiting flow or using a different codec or bit rate.","One problem with existing media streaming architectures is the tight coupling between server and client. The stateful connection between client and server creates additional server overhead, because the server tracks the current state of each client. This also limits the scalability of the server. In addition, the client cannot quickly react to changing conditions, such as increased packet loss, reduced bandwidth, user requests for different content or to modify the existing content (e.g., speed up or rewind), and so forth, without first communicating with the server and waiting for the server to adapt and respond. Often, when a client reports a lower available bandwidth (e.g., through RTCP), the server does not adapt quickly enough causing breaks in the media to be noticed by the user on the client as packets that exceed the available bandwidth are not received and new lower bit rate packets are not sent from the server in time. To avoid these problems, clients often buffer data, but buffering introduces latency, which for live events may be unacceptable.","In addition, the Internet contains many types of downloadable media content items, including audio, video, documents, and so forth. These content items are often very large, such as video in the hundreds of megabytes. Users often retrieve documents over the Internet using HTTP through a web browser. The Internet has built up a large infrastructure of routers and proxies that are effective at caching data for HTTP. Servers can provide cached data to clients with less delay and by using fewer resources than re-requesting the content from the original source. For example, a user in New York may download a content item served from a host in Japan, and receive the content item through a router in California. If a user in New Jersey requests the same file, the router in California may be able to provide the content item without again requesting the data from the host in Japan. This reduces the network traffic over possibly strained routes, and allows the user in New Jersey to receive the content item with less latency.","Unfortunately, live media often cannot be cached using existing protocols, and each client requests the media from the same server or set of servers. In addition, when streaming media can be cached, specialized cache hardware is often involved, rather than existing and readily available HTTP-based Internet caching infrastructure. The lack of caching limits the number of concurrent viewers and requests that the servers can handle, and limits the attendance of a live event. The world is increasingly using the Internet to consume up to the minute live information, such as the record number of users that watched live events such as the opening of the 2008 Olympics via the Internet. The limitations of current technology are slowing adoption of the Internet as a medium for consuming this type of media content.","An adaptive streaming system is described herein that provides a stateless connection between the client and server for streaming media playback in which the data is formatted in a manner that allows the client to make decisions traditionally performed by the server and therefore react more quickly to changing network conditions. The client requests uniform chunks of media from the server that include a portion of the media. The adaptive streaming system requests portions of a media file or of a live streaming event in small-sized chunks each having a distinguished URL. This allows existing Internet cache infrastructure to cache streaming media, thereby allowing more clients to view the same content at about the same time. As the event progresses, the client continues requesting chunks until the end of the event or media. Each chunk contains metadata information that describes the encoding of the chunk and media content for playback by the client. The server may provide chunks in multiple encodings so that the client can switch quickly to chunks of a different bit rate or playback speed. Thus, the adaptive streaming system provides an improved experience to the user with fewer breaks in streaming media playback, and an increased likelihood that the client will receive the media with lower latency from a more local cache server.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","An adaptive streaming system is described herein that provides a stateless connection between the client and server for streaming media playback in which the data is formatted in a manner that allows the client to make decisions often left to the server in past protocols, and therefore react more quickly to changing network conditions. In addition, the adaptive streaming system operates in a manner that allows existing Internet cache infrastructure to cache streaming media data, thereby allowing more clients to view the same content at about the same time. The adaptive streaming system requests portions of a media file or of a live streaming event in small-sized chunks each having a distinguished URL. Each chunk may be a media file in its own right or may be a part of a whole media file. As the event progresses, the client continues requesting chunks until the end of the event. Each chunk contains metadata information that describes the encoding of the chunk and media content for playback by the client. The server may provide chunks in multiple encodings so that the client can, for example, switch quickly to chunks of a different bit rate or playback speed. Because the chunks adhere to World Wide Web Consortium (W3C) HTTP standards, the chunks are small enough to be cached, and the system provides the chunks in the same way to each client, the chunks are naturally cached by existing Internet infrastructure without modification. Thus, the adaptive streaming system provides an improved experience to the user with fewer breaks in streaming media playback, and an increased likelihood that the client will receive the media with lower latency from a more local cache server. Because the connection between the client and server is stateless, the same client and server need not be connected for the duration of a long event. The stateless system described herein has no server affinity, allowing clients to piece together manifests from servers that may have begun at different times, and also allowing server administrators to bring up or shut down origin servers as load dictates.","In some embodiments, the adaptive streaming system uses a new data transmission format between the server and client. The client requests chunks of media from a server that include a portion of the media. For example, for a 10-minute file, the client may request 2-second chunks. Note that unlike typical streaming where the server pushes data to the client, in this case the client pulls media chunks from the server. In the case of a live stream, the server may be creating the media on the fly and producing chunks to respond to client requests. Thus, the client may only be several chunks behind the server in terms of how fast the server creates chunks and how fast the client requests chunks.","Each chunk contains metadata and media content. The metadata may describe useful information about the media content, such as the bit rate of the media content, where the media content fits into a larger media element (e.g., this chunk represents offset 1:10 in a 10 minute video clip), the codec used to encode the media content, and so forth. The client uses this information to place the chunk into a storyboard of the larger media element and to properly decode and playback the media content.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","110","120","130","140","150","160","100"]},"The chunk request component  makes requests from the client for individual media chunks from the server. As shown in , the client's request may pass first to an edge server (e.g., an Internet cache), then to an origin server, and then to an ingest server. At each stage, if the requested data is found, then the request does not go to the next level. For example, if the edge server has the requested data, then the client receives the data from the edge server and the origin server does not receive the request. Each chunk may have a Uniform Resource Locator (URL) that individually identifies the chunk. Internet cache servers are good at caching server responses to specific URL requests (e.g., HTTP GET). Thus, when the first client calls through to the server to get a chunk, the edge servers cache that chunk and subsequent clients that request the same chunk may receive the chunk from the edge server (based on the cache lifetime and server time to live (TTL) settings). The chunk request component  receives the chunk and passes it to the chunk parsing component  for interpretation.","The chunk parsing component  interprets the format of a media chunk received by the chunk request component  and separates the chunk into its component parts. Typically, the chunk includes a header portion containing metadata, and a data portion containing media content. The chunk parsing component provides the metadata to the manifest assembly component  and the media content to the media playback component .","The manifest assembly component  builds a manifest that describes the media element to which received media content belongs. Large media files that clients download as a whole (i.e., not streamed) often include a manifest describing the whole file, the codecs and bit rates used to encode various portions of the file, markers about meaningful positions with the file, and so forth. During streaming, particularly live content, a server cannot provide a complete manifest because the event is still ongoing. Thus, the server provides as much of the manifest as it can through the metadata in the media chunks. The server may also provide an application-programming interface (API), such as a predefined URL, for the client to request the manifest up to the current point in the media stream. This can be useful when the client joins a live, streamed event after the event is already in progress. The manifest allows the client to request previously streamed portions of the media element (e.g., by rewinding), and the client continues to receive new portions of the manifest through the metadata of the streamed media chunks.","The manifest assembly component  builds a manifest similar to that available for a complete media file. Thus, as the event proceeds if the user wants to skip backwards in the media (e.g., rewind or jump to a particular position), then skip forward again, the user can do so and the client uses the assembled manifest to find the appropriate chunk or chunks to playback to the user. When the user pauses, the system  may continue to receive media chunks (or only the metadata portion of chunks based on a distinguished request URL), so that the manifest assembly component  can continue to build the manifest and be ready for any user requests (e.g., skip to the current live position or play from the pause point) after the user is done pausing. The client-side assembled manifest allows the client to play the media event back as on-demand content as soon as the event is over, and to skip around within the media event as it is going on.","The media playback component  plays back received media content using the client hardware. The media playback component  may invoke one or more codecs to interpret the container within which the media content is transported and to decompress or otherwise decode the media content from a compressed format to a raw format (e.g., YV12, RGBA, or PCM audio samples) ready for playback. The media playback component  may then provide the raw format media content to an operating system API (e.g., Microsoft DirectX) for playback on local computer system sound and video hardware, such as a display and speakers.","The QoS monitoring component  analyzes the success of receiving packets from the server and adapts the client's requests based on a set of current network and other conditions. For example, if the client is routinely receiving media chunks late, then the component  may determine that the bandwidth between the client and the server is inadequate for the current bit rate, and the client may begin requesting media chunks at a lower bit rate. QoS monitoring may include measurement of other heuristics, such as render frame rate, window size, buffer size, frequency of rebuffering, and so forth. Media chunks for each bit rate may have a distinguished URL so that chunks for various bit rates are cached by Internet cache infrastructure. Note that the server does not track client state and does not know what bit rate any particular client is currently playing. The server can simply provide the same media element in a variety of bit rates to satisfy potential client requests under a range of conditions. In addition, the initial manifest and\/or metadata that the client receives may include information about the bit rates and other encoding properties available from the server, so that the client can choose the encoding that will provide a good client experience.","Note that when switching bit rates, the client simply begins requesting the new bit rate and playing back the new bit rate chunks as the client receives the chunks. The client does not have to send control information to the server and wait for the server to adapt the stream. The client's request may not even reach the server due to a cache in between the client and server satisfying the request. Thus, the client is much quicker to react than clients in traditional media streaming systems are, and the burden on the server of having different clients connecting under various current conditions is reduced dramatically. In addition, because current conditions tend to be localized, it is likely that many clients in a particular geographic region or on a particular Internet service provider (ISP) will experience similar conditions and will request similar media encodings (e.g., bit rates). Because caches also tend to be localized, it is likely that the clients in a particular situation will find that the cache near them is \u201cwarm\u201d with the data that they each request, so that the latency experienced by each client will be low.","The clock synchronization component  synchronizes the clocks of the server and the client. Although absolute time is not generally relevant to the client and server, being able to identify a particular chunk and knowing the rate (i.e. cadence) at which to request chunks is relevant to the client. For example, if the client requests data too quickly, the server will not yet have the data and will respond with error responses (e.g., an HTTP  not found error response) creating many spurious requests that unnecessarily consume bandwidth. On the other hand, if the client requests data too slowly, then the client may not have data in time for playback creating noticeable breaks in the media played back to the user. Thus, the client and server work well when the client knows the rate at which the server is producing new chunks and knows where the current chunk fits into the overall timeline. The clock synchronization component  provides this information by allowing the server and client to have a similar clock value at a particular time. The server may also mark each media chunk with the time at which the server created the chunk.","Clock synchronization also gives the server a common reference across each of the encoders. For example, the server may encode data in multiple bit rates and using multiple codecs at the same time. Each encoder may reference encoded data in a different way, but the timestamp can be set in common across all encoders. In this way, if a client requests a particular chunk, the client will get media representing the same period regardless of the encoding that the client selects.","The computing device on which the system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives or other non-volatile storage media). The memory and storage devices are computer-readable storage media that may be encoded with computer-executable instructions (e.g., software) that implement or enable the system. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on.","Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.","The system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":["210","240","270","220","230","220","230","220","230"]},"The content delivery network  includes one or more ingest servers  and one or more origin servers . The ingest servers  receive encoded media in each of the encoding formats from the encoders  and create a manifest describing the encoded media. The ingest servers  may create and store the media chunks described herein or may create the chunks on the fly as they are requested. The ingest servers  can receive pushed data, such as via an HTTP POST, from the encoders , or via pull by requesting data from the encoders . The encoders  and ingest servers  may be connected in a variety of redundant configurations. For example, each encoder may send encoded media data to each of the ingest servers , or only to one ingest server until a failure occurs. The origin servers  are the servers that respond to client requests for media chunks. The origin servers  may also be configured in a variety of redundant configurations.","The external network  includes edge servers  and other Internet (or other network) infrastructure and clients . When a client makes a request for a media chunk, the client addresses the request to the origin servers . Because of the design of network caching, if one of the edge servers  contains the data, then that edge server may respond to the client without passing along the request. However, if the data is not available at the edge server, then the edge server forwards the request to one of the origin servers . Likewise, if one of the origin servers  receives a request for data that is not available, the origin server may request the data from one of the ingest servers .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 3","FIG. 4"],"b":["310","320","330"]},"Continuing in decision block , if the system determines that the current QoS metric is too low and the client connection to the server cannot handle the current encoding, then the system continues at block , else the system loops to block  to handle the next chunk. Continuing in block , the system selects a different encoding of the media, wherein the system selects a different encoding by requesting data from a different URL for subsequent chunks from the server. For example, the system may select an encoding that consumes half the bandwidth of the current encoding. Likewise, the system may determine that the QoS metric indicates that the client can handle a higher bit rate encoding, and the client may request a higher bit rate for subsequent chunks. In this way, the client adjusts the bit rate up and down based on current conditions.","Although  illustrates the QoS determination as occurring after each chunk, those of ordinary skill in the art will recognize that other QoS implementations are common, such as waiting a fixed number of packets or chunks (e.g., every 10th packet) to make a QoS determination. After block , the system loops to block  to handle the next chunk if one is available or completes if no further media is available (not shown).",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":["410","420","430"]},"Continuing in block , the system adds the chunk metadata to an ongoing media manifest that describes information about a larger media element to which each of the media data chunks belongs. For example, the system may store a manifest in memory that contains the metadata from each chunk of a media file. Continuing in block , the system plays the media data using a codec identified by the chunk metadata and hardware of the client. The media data may include video, audio, and other types of data that the system plays back on hardware including a display, speakers, and so forth. Alternatively or additionally, the data may include non-audiovisual data (e.g., text) that is consumed in some other way than playback, in which case the system acts on the data based on the type of data. After block , these steps conclude.","In some embodiments, the adaptive streaming system provides digital video recorder (DVR)-like functionality for live media streams. In other words, users can pause a live stream, seek within the live stream, and so forth, without adding work or state tracking for the server. In a live stream, there are several scenarios like a missed scene, a pause to take a break, joining the event late and intend to watch from start, and so forth that are enabled by the system allowing the user to play chunks in various orders and at various times. Based on the assembled manifest described herein, the system offers the user control over how they watch a live stream. These controls are available today with TV via a DVR. The adaptive streaming system includes client controls to respond to user actions and manage playback of a live stream in a non-live mode by seeking to various locations in the manifest. In addition, the client can switch between live and non-live viewing during playback.","In some embodiments, the adaptive streaming system operates within a web browser plug-in. For example, the system may be included in a Microsoft Silverlight application. Microsoft Silverlight receives references in web pages to applications contained in containers called XAP files. Microsoft Silverlight extracts the XAP file and invokes the application. Microsoft Silverlight provides applications with a sandboxed, secure environment in which to run so that a user's computer system is protected from malicious or erroneous application code. Microsoft Silverlight provides APIs that applications can call to playback media in a way that shields the user's computer system and hardware from potentially harmful application actions. Thus, Microsoft Silverlight and other browser plug-ins can provide all of the functionality of an environment in which the adaptive streaming system expects to operate.","In some embodiments, the adaptive streaming system receives metadata of later chunks in a current chunk. For example, the server may hold a particular chunk that is ready until some number of additional chunks (e.g., two chunks) is available. Then, the server may send the chunk along with metadata information about the next few chunks. The client can use this information to know what is coming and adapt appropriately. This allows the client to intelligently adjust the request rate. For example, if a client requests a chunk and it does not have any information about later chunks, then the client knows it is requesting data too fast. If the client requests a chunk and receives information about too many later chunks, then the client may be requesting information too slow. Thus, the client can adapt using the advance metadata as a hint.","In some embodiments, the adaptive streaming system provides a plug-in model for heuristics to determine which encoding of media to use at a particular time. For example, the system may allow an administrator to select among several strategies for determining the bit rate at which to request media chunks based on a particular condition (e.g., reduced bandwidth or increased packet loss). In addition, content providers may include their own heuristics for determining the encoding to use, and may provide the heuristics as application modules or application dependency modules in an application package (e.g., a Microsoft Silverlight XAP) file that the client downloads when playing media from the content provider.","In some embodiments, the adaptive streaming system stores the assembled manifest described herein for later use, such as playback the day after a live event. During a live event, the client may have requested chunks of various encodings based on the network conditions. The client browser may also contain these chunks in the browser's cache. If the user requests to play back the media later, it may be most efficient to attempt to play back the media from the local cache, which generally means that the client requests the exact same chunks that were originally played. By storing the manifest with metadata from each chunk that was actually received, the client can play the media back continuously using the same encodings that were requested previously. This may enable the user to watch the media in scenarios, such as an airplane, where connectivity to the origin server may be unavailable.","In some embodiments, the adaptive streaming system provides logic for synchronizing related media streams. For example, a live audiovisual event may include one or more video streams (e.g., camera angles) and one or more audio streams (e.g., languages). As the client downloads the audio and video chunks separately, the system plays the audio and video media content in sync by aligning the time information associated with each chunk, as described further herein with reference to clock synchronization. The system may also synchronize other types of data, such as slides in a slide presentation, images, text, and so forth.","In some embodiments, the adaptive streaming system provides client-side logic for switching to different play rate streams (e.g., trick play) provided by the server. For example, the server may include 2\u00d7, 5\u00d7, 0.5\u00d7, and other speeds of playback. The client can switch to a stream of a different rate to provide the appearance to the user that the media is fast-forwarding (e.g., 2\u00d7) or rewinding (e.g., 0.5\u00d7). To switch, the client simply requests a different media chunk, e.g., at a different URL. The client can smoothly switch between playing chunks at the current rate and playing chunks at a different rate by continuing to play the particular chunks that are received. This provides a seamless experience to the end user with little latency between the user's request and the change in the media playback. This also saves network bandwidth as the client does not download, for example, 2 times the data to play media twice as fast, but rather downloads a reduced size encoding of the media that is encoded at the accelerated rate.","In some embodiments, the adaptive streaming system receives highlight markers in the metadata. A highlight may include any interesting segment of media, such as a point during a sporting event during which a player scored a goal. The client can play a highlight reel after an event has concluded by playing those chunks of the media with associated with highlight markers. If the client did not receive the live event, the client can request the manifest for the media and then request only those chunks corresponding to the highlights. If a user wants to see more of the media before and after the highlight (e.g., as indicated by the user fast-forwarding or rewinding), then the client can request additional chunks to play the requested portions of the media.","In some embodiments, the adaptive streaming system supports inline advertising and other non-audiovisual data (e.g., captions, comments, and so forth). For a live event, it may be unknown at the start of the event when commercial breaks will occur. An event coordinator may press a button during production when it is time for a commercial, causing the system to insert an advertising marker in the media stream metadata. When the client receives the advertising marker, the client may request and receive chunks associated with a previously identified advertisement. For example, the server may provide a list of potential advertisements in an initial manifest. The advertisement may be provided in chunks similar to other media, and may not be stored at the same server that provides the live event. Upon encountering an advertisement marker, the client pauses playback of the main stream, retrieves and displays the advertisement, and then resumes playback of the main stream.","In some embodiments, the adaptive streaming system determines which encodings are available based on a subscription or other payment model. For example, a content provider may charge more for a high definition (HD) version of a live event than a standard definition (SD) version of the event. In this case, the client may enable or disable switching to particular bit rates based on whether the conditions of the payment model have been met (e.g., the user's account is current). The content provider may offer some encodings free, such as a low bit rate or highlight only media, while charging for others.","The adaptive streaming system may request and receive media content in a variety of encodings. In some embodiments, the adaptive streaming system uses custom MP4 boxes. The Motion Picture Experts Group (MPEG) version 4 standard provides for boxes within the format that can contain custom data. The MP4 extension is the file format commonly associated with this version of content. The system may leverage boxes to include the custom metadata and media content chunks. Other media formats provide similar customization of content within a container and may be used by the system.","In some embodiments, the adaptive streaming system conforms to the guidelines of the Representational State Transfer (REST) style of software architecture for distributed hypermedia systems. One concept in REST is that an application can interact with a resource by knowing only the identifier of the resource (e.g., a URI) and the action requested (e.g., retrieval), and without knowing whether there are caches, proxies, gateways, firewalls, tunnels, or anything else between the application and the server actually holding the information. Following REST guidelines allows the system to benefit from existing Internet infrastructure and pre-existing resource conserving techniques such as caching. Some example RESTful principles that the system implements in some embodiments include: each URI identifies exactly one response, each URI points to a server resource that is stateless and cacheable, and each URI is intuitive and uses nouns (verbs are HTTP verbs). In particular, the system may avoid making requests using query strings and may use substantially unique keys for start times that are requested via URLs.","From the foregoing, it will be appreciated that specific embodiments of the adaptive streaming system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly, the invention is not limited except as by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
