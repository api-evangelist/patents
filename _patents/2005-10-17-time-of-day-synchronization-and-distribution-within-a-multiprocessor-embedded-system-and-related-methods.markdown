---
title: Time of day synchronization and distribution within a multiprocessor embedded system and related methods
abstract: A software-defined radio includes a pair of radio subsystems such as a red (command) and black (data) radio subsystem having an operating environment conforming to the Software Communications Architecture (SCA) specification, for example, as used for Joint Tactical Radio System (JTRS). A clock is read by at least one of the radio subsystems for determining time of day. A processor of the radio subsystem is operative for distributing the time of day to the radio subsystems using a global hardware timing pulse. Each processor can include a free-running timer to which any time sources within the pair of radio subsystems are set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689207&OS=07689207&RS=07689207
owner: Harris Corporation
number: 07689207
owner_city: Melbourne
owner_country: US
publication_date: 20051017
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates to a software communications architecture (SCA) for radios and other applications having embedded processors.","With advances in processing capabilities and programming technologies, software defined mobile wireless communications devices (e.g., radios) continue to increase in popularity. Rather than relying upon hardware and circuitry components to perform tasks such as frequency, modulation, bandwidth, security functions, and waveform requirements, these functions are performed by software modules or components in a software radio. That is, with a software radio analog signals are converted into the digital domain where the above-noted functions may be performed using digital signal processing.","Because most of the functions of the radio are controlled by software, software radios may typically be implemented with relatively standard processor and hardware components. This may not only reduce device hardware costs, but is also provides greater flexibility in upgrading the device since new communications waveform modules can be uploaded to the device relatively easily and without the need to interchange new hardware components.","One particular class of software radio, which takes advantage of the above-described advantages features is the Joint Tactical Radio (JTR). The JTR radio includes relatively standard radio and processing hardware along with the appropriate waveform software modules for the communication waveforms the radio will use. JTR's also utilize operating system software that conforms with the Software Communications Architecture (SCA) Specification (see www.JTRS.saalt.mil), which is hereby incorporated by reference in its entirety. The SCA is an open architecture framework that specifies how hardware and software components are to interoperate so that different manufacturers and developers can readily integrate their respective components into a single device.","Still another class of mobile wireless communications devices that increasingly use software components for communicating with different waveforms or protocols are cellular communication devices. That is, many cellular devices are now designed to operate with more than one of the numerous cellular standards that are used throughout the world, such as the Global System for Mobile Communications (GSM) and Personal Communications Services (PCS), for example.","The Joint Tactical Radio System (JTRS) Software Component Architecture (SCA) defines a set of interfaces and protocols, often based on the Common Object Request Broker Architecture (CORBA), for implementing a Software Defined Radio (SDR). In part, JTRS and its SCA are used with a family of software re-programmable radios. As such, the SCA is a specific set of rules, methods, and design criteria for implementing software re-programmable digital radios.","The JTRS SCA specification is published by the JTRS Joint Program Office (JPO). The JTRS SCA has been structured to provide for portability of applications software between different JTRS SCA implementations, leverage commercial standards to reduce development cost, reduce development time of new waveforms through the ability to reuse design modules, and build on evolving commercial frameworks and architectures.","The JTRS SCA is not a system specification, as it is intended to be implementation independent, but a set of rules that constrain the design of systems to achieve desired JTRS objectives. The software framework of the JTRS SCA defines the Operating Environment (OE) and specifies the services and interfaces that applications use from that environment. The SCA OE comprises a Core Framework (CF), a CORBA middleware, and an Operating System (OS) based on the Portable Operating System Interface (POSIX) with associated board support packages. The JTRS SCA also provides a building block structure (defined in the API Supplement) for defining application programming interfaces (APIs) between application software components.","The JTRS SCA Core Framework (CF) is an architectural concept defining the essential, \u201ccore\u201d set of open software Interfaces and Profiles that provide for the deployment, management, interconnection, and intercommunication of software application components in embedded, distributed-computing communication systems. Interfaces may be defined in the JTRS SCA Specification. However, developers may implement some of them; some may be implemented by non-core applications (i.e., waveforms, etc.), and some may be implemented by hardware device providers.","The specifications for the JTRS radio and SCA typically require an interface for command and data (red and black) processing systems. A radio platform may include multiprocessor embedded systems, including Field Programmable Gate Arrays (FPGA's). In some current systems, the timing synchronization between processing elements is often orchestrated in the software. This scheme uses a series of message exchanges between the processing elements, where one of the elements provides the definitive time reference in the messaging that is sent. This current technique has limits on the accuracy that can be achieved because of the interrupt latency and timing variability in the message exchange. It would be desirable to determine a way to accurately synchronize the time of day between multiple processors and processes within these embedded systems operative typically as a software radio, such that the synchronization can be accurately determined with less than one microsecond of inaccuracy.","In view of the foregoing background, it is therefore an object of the present invention to provide a time of day synchronization and distribution within a software defined radio having multiple radio subsystems without using a series of time inaccurate message exchanges.","In accordance with a non-limiting example of the present invention, a software-defined radio includes a pair of radio subsystems each having a processor. A real time clock is operative to be read by at least one of the radio subsystems for determining time of day. The processor is operative for distributing the time of day to radio subsystems using a global hardware timing pulse. The pair of radio subsystems can be formed as a red (command) and black (data) radio subsystem that are conformable to the Software Communications Architecture (SCA) specification.","In one aspect, each processor can be formed as a Field Programmable Gate Array (FPGA), each including a free running timer to which any time sources within the pair of radio subsystems are set. Each processor can include registers in which the time of day is stored, which are incremented in unison to each other using a common clock to create a free-running system time. At least one processor can be operative for computing time of day offsets to the free-running system time when the time of day has changed and distributing the time of day offsets to the free-running system time for the radio subsystems.","In another aspect, a waveform source can be instantiated to the radio subsystems, wherein the time of day can be obtained from a waveform. Time of day offsets can be distributed using a Common Object Request Broker Architecture (CORBA).","A method aspect is also disclosed.","Different embodiments will now be described more fully hereinafter with reference to the accompanying drawings, in which preferred embodiments are shown. Many different forms can be set forth and described embodiments should not be construed as limited to the embodiments set forth herein. Rather, these embodiments are provided so that this disclosure will be thorough and complete, and will fully convey the scope to those skilled in the art. Like numbers refer to like elements throughout, and prime notation is used to indicate similar elements in alternative embodiments.","In one non-limiting embodiment of the present invention, free-running timers are synchronized in counters, for example, in Field Programmable Gate Arrays (FPGA's) and time sources are latched relative to free-running counters. The system captures these offsets and distributes offsets around the system. Time is as accurate as it can be clocked into the FPGA's. This allows a system to use CORBA as a standard SCA communication mechanism to pass time of day offsets around the system. A time of day service code can be responsible for providing these offsets to the rest of the system. Thus, it is possible to keep accurate time to all system components, such as the red processors, e.g., FPGA's or Digital Signal Processor (DSP's), as well as the waveform and operating environment software.","When a radio powers-up, the current time of day is read from a real-time clock (RTC) chip and stored in a pair of FPGA registers on both sides of the radio, i.e., in the radio platform using the SCA architecture, the red and black subsystems. The time is substantially instantiated, e.g., created or loaded in all processing elements using a global hardware timing pulse. Once the registers are loaded, they can begin to increment in lock step using a common clock source. These registers will continue to increment while the radio is powered creating a free running \u201csystem time.\u201d When the radio time is changed, an offset to the radio time relative to the free-running system time will be computed and stored in memory. Radio time of day is distributed as an offset to the free-running system time. By having a set of processing elements synchronized from the same clock pulse, the system can ensure that system times will always be synchronized to within a high degree of accuracy. This can be critical for frequency hopping applications.","By passing radio time changes as an offset to the system time, the system can ensure accurate time transfer. Time can also be updated from any processor and can still be synchronized without worrying about latency when passing messages. Time-dependent waveforms, e.g., SINCGARS or HaveQuickII time, typically need to be synchronized as closely as possible, otherwise communication between radios can be compromised. Thus, a JTRS SCA based radio can now have an SCA based architecture with a predefined mechanism for synchronizing the operating environment and the waveform application components to the degree of accuracy that is required by many frequency hopping waveforms.","The time of day synchronization and distribution within a multiprocessor embedded system and related methods can be used for any type of radio software communications architecture as used on mainframe computers or small computers, including laptops with an added transceiver, such as used by military and civilian applications, or in a portable wireless communications device  as illustrated in . The portable wireless communications device is illustrated as a radio that can include a transceiver as an internal component and handheld housing  with an antenna  and control knobs. A Liquid Crystal Display (LCD) or similar display can be positioned on the housing in an appropriate location for display. The various internal components, including dual processor systems for red and black subsystems and software that is conforming with SCA, is operative with the illustrated radio. Although a portable or handheld radio is disclosed, the architecture as described can be used when any processor system operative with the transceiver using SCA and the time of day synchronization and distribution in accordance with the present invention.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1A","b":["30","32","34","32","34","36","38","40","42","44","46","44","46","46","50","34","32","52","34","54"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6","b":["60","62","64","66","68","66","70","72","74","68","76","78","72","76","82","84","86","72","88","86","86","90","92","70","94"]},"Generally, TOD is used to manage and provide accurate time throughout the radio. TOD is made up of a black-side component, which could be indicated as TOD_B Process , and the red-side component, which could be indicated as TOD_R Process , the TOD Service , and a TOD plugin . TOD_B Process and TOD_R Process are responsible for updating the black and red hardware components of the radio. The TOD service  provides time information and manages the synchronization of various hardware and software time components within the radio. This synchronization includes making calls to TOD_B Process  to update the clock. The TOD Service  will also provide any registered users notification of any pending time adjustments, via a notification server. The TOD plugin  connects to the platform database  and is used to write and receive TOD data.","In one non-limiting example, the time of day can be updated by two sources: the user, for example, via HMI  (ascii, front panel, testable interface), or by a GPS Process  with GPS having the higher priority. A source with a lower priority cannot update the time if the time has already been changed by a source with a higher priority. Because a waveform cannot see a time jump or go backward in time, time changes can only be made when a waveform is not instantiated.","When a time update is requested, the delta time change is computed and a message is sent through a notification server having a notification service that there is a pending update. This message will be used by all plugins that need to track time changes. The time offset can be tracked until there is no waveform instantiated. Once there is no waveform instantiated, the TOD service  can make a call to the TOD_B Process  to update the clock and synchronize the TOD_R Process  to TOD_B Process .","There will typically be one TOD Service  instance running on the radio. This instance will interface with the TOD_B process , as well as the TOD plugin  as part of the system. The TOD_B process  interacts with the Real-Time Clock (RTC) chip and driver  and any black FPGA hardware. It also updates the UTC Time (\u201cNow\u201d object) and the Operating System (OS) clock (on power up). Any time adjustments can be sent to the TOD_R process and are synchronized using a hardware line between TOD_B and TOD_R. Updates to UTC Time (\u201cNow\u201d object) and the OS clock (only on power up) on the red side are then performed by TOD_R. The TOD system plugin  will be used to access the database.","Time adjustments may come from other sources besides the Global Positioning System (GPS). Time adjustments may not be immediate. A policy will typically exist that will determine which time sources can adjust the time. More accurate time sources could be allowed to adjust the time if the current time was set using a less accurate source. Less accurate time sources, however, will not be allowed to adjust the time if the current time was set using a more accurate time source.","The GPS process can send time updates before the GPS one (1) pulse-per-second (PPS) interrupt occurs. The time update can contain the time value at the next pulse. The time obtained from the TOD Service typically may be the most accurate time data in the radio due to CORBA latency. The accuracy of the time on this port is indeterminate. Multiple components in the radio may be interested in obtaining time information through TOD Service.","Time can be obtained through the RTC chip, the \u201cNow\u201d object, or the TOD Service. The TOD Service is used by waveforms to obtain time. Any other components that are interested in obtaining time can use the TOD Service. The components that use the time provided by the TOD Service should be aware that this time will not be the most accurate time in the radio due to CORBA latency.","A state diagram is shown in  at . UPDATE_BLACK  and SYNCH_RED  handle updating black and red time components (respectively). POWER_UP  is start up of all TOD components. UPDATE_TIME  handles time updates that come in from HMI or GPS. SYNCH_MANPACK  handles time synchronization between some channels. WAIT_FOR_NO_WAVEFORM  will monitor system until there is no waveform instantiated.","TOD_B and TOD_R Process , are stand-alone processes that are used to synchronize time between the red and black sides. The TOD Service  contains an instance of a TOD_B Application Programming Interface (API) to command the TOD_B process . The TOD_B process  acts as a slave to the TOD Service  in this regard. No communications channel exists for TOD_B to make calls on the TOD Service. The TOD_B Process is responsible for synchronizing the current time with TOD_R Process.","TOD_B responsibilities include:","1. Read RTC chip at power up;","2. Update black side time components which include:","a. UTC time (\u201cNow\u201d object) which is maintained in a hardware timer on a Black FPGA (BFPGA);","b. POSIX system time (power up only); and","c. RTC chip; and","3. Synchronize time with TOD_R using a hardware synchronization line.","TOD_R responsibilities:","1. Update red side time components which include:","a. UTC time (\u201cNow\u201d object) which is maintained in a HW Timer on a Red FPGA (RFPGA); and","b. POSIX system time (power up only).","The TOD Service  can include different ports for interface and communication. A User TodOp port allows the HMI to make adjustments to the time of day. Since GPS has a higher priority than HMI, the HMI will only be allowed to change the time if GPS has not already updated time. Also, these adjustments are not always made immediately. Since a waveform cannot see a jump in time, the adjustment will be made when there is no instantiated waveform. Once there is no instantiated waveform, the adjustments are made to the underlying time components that exist in TOD_B and TOD_R. A GpsTodOp port allows GPS make adjustments to time of day. The same applies as before because adjustments are not always made immediately. Since a waveform cannot see a jump in time, the adjustment will be made when there is no instantiated waveform. Once there is no instantiated waveform, the adjustments are made to the underlying time components that exist in TOD_B and TOD_R.","A WaveformTodOp port will send the current time information to a waveform when requested.","A TimeAdNotification port is used to send out notifications that a component in the system wants to adjust the time. This notification will be used by all components that need to track the time to keep up to date of the current delta time.","An AccessDatabase port will allow TOD Service to retrieve and update a database configuration as needed. This connection is an internal connection between TOD Service and a TOD system plugin. The data that is included in database configuration includes: UTC time, UTC offset, power up time, time last updated and who last updated.","A NotifyTimeChange port is used to send out the new time offset to any waveform or plugin that is tracking time specific components for a waveform.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 3","b":"74"},"a. TOD_B  updates the \u201cNow\u201d object  on the black side;","b. TOD_B  updates the POSIX system time  on the black side; and","c. TOD_B  synchronizes with TOD_R . The synchronization process involves TOD_B  sending the current time to TOD_R. TOD_R  uses this time to update the \u201cNow\u201d object  and POSIX system time  on the red side.","The System Process connects to plugin ports from TOD Service  to TOD Plugin  ports on the system process. The TOD Service  queries TOD_B  for power-up values (Time Last Written, Time Source, etc.). These values are then written to the database  through the system plugin  port. Database queries will not be allowed until TOD_B  is initialized.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 4","b":"70"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 5"},"Since not all plugins are loaded at startup, there needs to be a way to track a time offset for the waveforms until their plugin is started. This can be accomplished in various ways and, in one non-limiting example, as described.","When a fill command is called, a time from a security service will be sent to the TOD Service. This will be done by creating a port (CORBA) connection between a security service and TOD Service. An offset will be computed between the fill time and the radio time. This offset will be updated during time changes. When a waveform plugin is started, it will make a call through the WaveformTodOpPort (CORBA) to obtain the offset. The plugin can use this offset as a basis for any time offsets that it may need. During the case that a waveform is started and its plugin is already running, the plugin can obtain the offset from the TOD Service to ensure the correct offset is being used. The system will not update the \u201cNow\u201d object when the system is in a FILL mode or in WAVEFORM mode. The system will wait until there are no waveforms instantiated. The waveform will get the Offset using the \u201cWaveformTodOp\u201d port. The system will add a function to retrieve this parameter.","In the system as described, the HMI can send a command to fill, and the security service can send a time message to the TOD Service, which computes offset between \u201cfill time\u201d and radio time, and then the TOD Service stores the offset.","For the Waveform Plugin, the system starts the plugin. On waveform instantiation, a domain manager will make a port connection between the waveform and TOD Service. The waveform will make a call through the WaveformTodOp port and get the offset from TOD Service. The plugin updates its time components based on offset.","The security service can send a time offset to the TOD Service, which can store and track offsets. When a waveform is instantiated, the waveform or the waveform plugin can retrieve the time offset from the TOD service.","Referring again to . The TOD Service  is responsible for taking the time of day requests from GPS, HMI, and a waveform. The TOD Service will go through the TOD plugin  to access the database . The TOD Service  will go through the TOD_B process  to update time components on the black side of the radio. The TOD_B process  will update the black-side POSIX , the \u201cNow\u201d object  and the Real-Time Clock . The TOD_B process  will also send updated time to the TOD_R process , which will update the red-side POSIX  and \u201cNow\u201d object .",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 7","b":["200","202","204","206","208","208","210","212","206","214","202","204","220","202","204","222","224"]},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 8","b":["250","252","254","256","258","260","258","262","254","256","270","272","274","270"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 8A","b":["288","290"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 9","b":["30","302","304","306","308","310","312","306","314","304","320","322","324","304"]},"As indicated, the time of day for the radio can be based off the free-running BFPGA timer that is powered off the 19.2 MHz TCXO . On power up, the black and red timers can be preloaded. The BFPGA and the RFPGA can receive a one (1) Pps that comes out of the RTC. On the pulse, the Clock Signal (CLK) line could trigger and start the timers. When (if) GPS acquires, a GPS pulse could be sent to the RFPGA. When the RFPGA receives the pulse, it can record the current time of day and store that value in a register. It can send an interrupt to GPS (TOD as long as the offset is accounted for somewhere) where GPS will store the offset for use when sending time to TOD. When an MFPGA is configured, the time of day in the BFPGA can be loaded into the MPFGA.","As shown in , the FPGA designer can provide a synchronization line to the BIOP , which can be used to obtain time (POSIX, system time, or \u201cNow\u201d time). The FPGA can have the 19.2 MHz reference from the TCXO. The FPGA timer can be set to any time reference by a waveform providing the delta between that reference and UTC is established.","As shown in , the interaction between red and black subsystems is shown. Time of day on the radio is tracked by the \u201cNow\u201d object and is maintained by the TOD_B (black-side time component). The \u201cNow\u201d object is a software component connected to a BFPGA timer used to track UTC time as number of seconds since the base date (currently Jan. 1, 1970). The TOD_B component is used to update the \u201cNow\u201d object as well as update the TOD_R component (red-side time component). In this paradigm, TOD_B is considered the master, and TOD_R is considered the slave. TOD Service  and the TOD platform plugin  are CORBA components that, together, handle time and date requests from GPS and HMI. The platform plugin  is also used to read and write to the platform database.","HMI  can request a time change via the TOD platform plugin . That request can be sent to TOD Service , where an offset to the radio time can be computed and stored in the database. That offset will be stored until no waveforms are running on the radio. When no waveforms are running on the radio, TOD Service  can make a call to TOD_B to update the radio time and reset the stored offset to zero. TOD_B (black-side TOD) will update the \u201cNow\u201d object to reflect the offset, write the new time to the real time chip (RTC), and send the new time to TOD_R (red-side TOD).","GPS time change can follow the same algorithm as the HMI change with the exception that the initial request will go to the TOD Service, instead of through the platform plugin.","When a new offset is computed by TOD, the new offset will be sent to every waveform plugin. It is expected that the waveform plugin will store the current time offset. This offset should be stored in the waveform database, so it can be kept through power ups. Once the time change is made, TOD will make a call to every waveform plugin to update their time. The waveform will reset their time offset to zero and update any other offsets that the waveform is tracking. It is up to the waveform to implement a function that will perform the updates. A time change request can come from either HMI or GPS. When a time change is requested, a waveform can be in one of three states: 1) The waveform is running, 2) the waveform is not running, but another waveform is running, or 3) the waveform is not running and there are no other waveforms running.","When the waveform is running, a time request comes into TOD, which computes an offset between the new time, and the current \u201cNow\u201d time. The offset is stored in the database. The time change is sent to the waveform. The waveform then decides whether or not to accept the time change. If the waveform accepts the time change, the \u201cNow\u201d object and all other TOD components will be updated to reflect the new time. The stored offset will be reset to zero.","When the waveform is not running, but another waveform is running, a time request comes into TOD, which computes an offset between the new time, and the current \u201cNow\u201d time. The offset is stored in the database. A call is made to the waveform plugin that there is a new offset. The waveform is responsible for tracking the current offset. The waveform can store the new offset into its database. Once there is no waveform running, TOD can update radio time components (including \u201cNow\u201d) to reflect the new time. TOD can reset its offset to zero and make a call to the waveform plugin to reset their offset to zero. The waveform plugin can reset its offset, and update any other offsets the waveform may be tracking to reflect the new time.","When no waveforms are running on the radio, a time request comes into TOD. The TOD updates time components on the radio (including \u201cNow\u201d). TOD can make a call to the waveform plugin to reset its offset to zero. The waveform plugin can reset its offset, and update any other offsets the waveform may be tracking to reflect the new time.","When a time request is made, the TOD can compute an offset between the \u201cNow\u201d time and the new time (cumulative offset). When a time request is made, TOD can compute an offset between the last offset and the new time (current offset). When a time request is made, TOD can send both the current offset as well as the cumulative offset to all waveform plugins. When system time has changed (\u201cNow\u201d object updated) TOD can send a current offset of zero and a cumulative offset of zero to all waveform plugins to indicate the offsets have been reset.","Each waveform that needs to actively track waveform offsets can implement a function called \u201cUpdateOffset\u201d, which can take in the new time offset as well as the cumulative time offset. The \u201cUpdateOffset\u201d function can be used to store the current offset to the waveform's database as well as update any offsets the waveform plugin is maintaining.","Many modifications and other embodiments of the invention will come to the mind of one skilled in the art having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore, it is understood that the invention is not to be limited to the specific embodiments disclosed, and that modifications and embodiments are intended to be included within the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other objects, features and advantages of the present invention will become apparent from the detailed description of the invention which follows, when considered in light of the accompanying drawings in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
