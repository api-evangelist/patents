---
title: Database table comparison
abstract: Techniques are disclosed for comparing database tables. In one embodiment, the database tables are partitioned. Queries are generated for retrieving each partition. For each generated query, a stored procedure is invoked, using the respective generated query as an input parameter to the stored procedure. The stored procedure is configured to generate a checksum based on the partition retrieved from executing the respective query. The application compares the generated checksums to determine if the partitions and/or tables are consistent.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09600513&OS=09600513&RS=09600513
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09600513
owner_city: Armonk
owner_country: US
publication_date: 20110609
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Databases are computerized information storage and retrieval systems. The most prevalent type of database is the relational database, a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways.","Regardless of the particular architecture, in a database management system (DBMS), a requesting entity, such as an application, demands access to a specified database by issuing a database access request. Such requests may include, for instance, simple catalog lookup requests or transactions and combinations of transactions that operate to read, change and add specified records in the database. These requests are made using high-level query languages such as the Structured Query Language (SQL). Illustratively, SQL is used to make interactive queries for getting information from and updating a database such as International Business Machines' (IBM) DB2, Microsoft's SQL Server, and database products from Oracle, Sybase, and Computer Associates. The term \u201cquery\u201d denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language that allows programmers and programs to select, insert, and\/or update the data,","Embodiments of the invention provide a computer-implemented method, computer program product and system for performing an operation that includes identifying a key range for a partition of at least one database table of a plurality of database tables comprising a first database table and a second database table. The operation also includes generating, for each database table and based on the key range identified for the partition, a database query for retrieving the partition from the respective database table. The operation also includes invoking, for each database table, a stored procedure using the database query generated for the respective database table as an input parameter to the stored procedure, where the stored procedure is configured to compute a checksum based on the partition in the respective database table. The operation also includes determining whether the partition is consistent across the first and second database tables, based on a comparison between the checksum computed from the partition in the first database table and the checksum computed from the partition in the second database table.","Embodiments of the invention provide techniques for comparing database tables. One embodiment provides an application that receives a user request to compare the database tables. In some embodiments, the database tables include a first table stored in a first database and a second table stored in a second database, where the first and second databases are operatively connected over the network. Further, a relationship may be maintained between the two tables, the relationship specifying that data in the first table is replicated to the second table. In this regard, the first table may also be referred to as a source replicated table, and the second table may be referred to as a target replicated table. In some embodiments, data in the second table is also replicated back to the first table. The application is configured to communicate with a database management system (DBMS) associated with each of the first and second databases. The communication may occur by way of one or more application programming interfaces (APIs) provided by each DBMS. In other embodiments, however, the database tables may both be stored in a single database, and the application communicates with a single DBMS configured to manage the single database. Additionally or alternatively, in other embodiments, some or all of the functionality of the application may be performed by the DBMS.","In one embodiment, the application divides the first and second tables into partitions based on predefined partitioning criteria. The predefined partitioning criteria may be user-specified. The application then identifies a range of rows for each partition of the source table. For a unique key that includes only a single column of the table, each range of rows is identified based on a minimum and maximum boundary key value. For a key that includes multiple columns, each range of rows is identified based on a minimum and maximum tuple of key values. In some embodiments, the first range of rows need not necessarily be identified by any minimum key value, and\/or the last range of rows need not necessarily be identified by any maximum key value. The minimum boundary key value refers to a minimum value stored in a specified key column of the partition. The maximum boundary key value refers to a maximum value stored in the specified key column of the partition. The application then generates a query for retrieving each partition, where the rows of the respective partition are ordered by the unique key. The generated query may be used to retrieve a given partition from the first and second database tables, respectively, the given partition being characterized by the same boundary key values identified by the application. In some embodiments, to achieve parallelism, query generation may be conducted by respective threads of the application.","In one embodiment, for each partition, the application invokes a stored procedure on each database, passing the generated query for the respective partition as an input parameter to the stored procedure. A stored procedure refers to an application that is executable by and stored in a DBMS. To achieve increased parallelism, the following techniques may be used separately or in combination. A first technique includes invoking, within a stored procedure, other stored procedures in the DBMS. A second technique includes creating, in a given stored procedure, multiple processes and\/or threads to execute sub-routines in parallel, where the sub-routines may be identical or different. A third technique involves creating multiple threads by the application, each of which calls the same stored procedure in the DBMS. For each call, DBMS creates an instance of the stored procedure being executed. Accordingly, each database may include multiple instances of the stored procedure executing in parallel.","In one embodiment, the stored procedure invoked by the application is configured to perform one or more predefined operations to determine a partition checksum based on all rows of the respective partition. Determining the partition checksum is further described below. The partition checksum may also be referred to herein as a checksum. As described above, to achieve parallelism, each stored procedure may be invoked by a respective thread of the application, and\/or each stored procedure may invoke additional threads for performing checksum computation. Depending on the embodiment, the stored procedure may be provided by or with the application or DBMS. At least in some embodiments, the predefined operations are more data-intensive than operations performed by the application. Accordingly, by implementing the predefined operations as a stored procedure rather than in the application, data may be accessed locally by the stored procedure, which executes in the DBMS that manages the database storing the data. In other words, requests for data and responses containing data do not need to be sent over the network. Accordingly, the predefined operations may be performed more efficiently at least in some cases. Further, security may be improved because the application may be assigned fewer privileges than the stored procedures and\/or less potentially sensitive data is exposed over the network.","In one embodiment, for a specific partition, the application determines whether the checksum computed by the stored procedure in the first database matches the checksum computed by the stored procedure in the second database. In some embodiments, to achieve parallelism, the determination may be made by the respective thread that previously invoked the stored procedure. Matching checksums indicate that the partitions are likely consistent with one another, while differing checksums indicate that the partitions are likely not consistent with one another. If the checksum of each partition of the first table matches the checksum of the corresponding partition of the second table, then the application may determine that the tables are consistent with one another. On the other hand, if the checksum of any partition of the first table does not match the checksum of the corresponding partition of the second table, then the application may determine that the tables are not consistent with one another. In some embodiments, the application may also determine which specific rows of the tables do not match, by comparing row checksums and\/or row key values. The application may notify a user of the specific rows that do not match. In some embodiments, the application also provides a user-selectable option to modify the second table such that the second table matches the first table. If the option is selected, then the application also performs one or more inserts, updates, and\/or deletes on the second table, such that the second table matches the first table.","Advantageously, the techniques disclosed herein may be used to compare database tables more conveniently, efficiently, and\/or scalably at least in some cases, whether the database tables are stored in a single database or across multiple databases. The disclosed techniques may be particularly suited to database tables exceeding a predefined threshold storage size or row count and\/or database tables stored in databases that are geographically distant from one another, beyond a predefined threshold distance. Such database tables are increasingly common today, given the exponential growth of data, the advent of business globalization, and the increasing use of data centers, which may often be located across large geographical distances for purposes of high availability, disaster recovery and\/or scalability. For geographically distant databases connected via a network having limited bandwidth and\/or high latency characteristics, the techniques disclosed herein may allow tables to be compared more efficiently by an order of magnitude in some cases, relative to alternative techniques.","Additionally or alternatively, the disclosed techniques may be particularly suited to database tables having certain properties, such as having less than a predefined threshold count of different rows, sharing common character encoding schemes, collating sequences, and\/or endianness, having columns with compatible data types, having a key for a subset of columns common between the database tables, and\/or having a date, time, or timestamp column. To the extent that certain operations of the application are performed in parallel, the execution time of the application may be reduced at least in some cases. By comparing tables based on partition checksums, row checksums, and\/or key values, the network traffic generated by the application may be reduced at least in some cases, compared with other techniques that include considering additional row values to compare the tables. Further, the execution time of and\/or network traffic generated by the application may also be reduced to the extent that certain data-intensive operations, such as checksum computation, are delegated to stored procedures on the database.","In the following, reference is made to embodiments of the invention. However, it should be understood that the invention is not limited to specific described embodiments. Instead, any combination of the following features and elements, whether related to different embodiments or not, is contemplated to implement and practice the invention. Furthermore, although embodiments of the invention may achieve advantages over other possible solutions and\/or over the prior art, whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus, the following aspects, features, embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim(s). Likewise, reference to \u201cthe invention\u201d shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim(s).","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java\u2122, Smalltalk\u2122, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention are described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","Embodiments of the invention may be provided to end users through a cloud computing infrastructure. Cloud computing generally refers to the provision of scalable computing resources as a service over a network. More formally, cloud computing may be defined as a computing capability that provides an abstraction between the computing resource and its underlying technical architecture (e.g., servers, storage, networks), enabling convenient, on-demand network access to a shared pool of configurable computing resources that can be rapidly provisioned and released with minimal management effort or service provider interaction. Thus, cloud computing allows a user to access virtual computing resources (e.g., storage, data, applications, and even complete virtualized computing systems) in \u201cthe cloud,\u201d without regard for the underlying physical systems (or locations of those systems) used to provide the computing resources.","Typically, cloud computing resources are provided to a user on a pay-per-use basis, where users are charged only for the computing resources actually used (e.g., an amount of storage space consumed by a user or a number of virtualized systems instantiated by the user). A user can access any of the resources that reside in the cloud at any time, and from anywhere across the Internet. In context of the present invention, a DBMS may execute in the cloud, the DBMS being configured to manage one or more databases. Having the DBMS in the cloud allows the user to access the databases from any computing system attached to a network connected to the cloud (e.g., the Internet).","The flowchart and block diagrams in the Figures illustrate the architecture, functionality and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1","b":["100","100","102","160","160","130","102","130","130","130"],"sub":["1 ","2 "]},"The computer  generally includes a processor  connected via a bus  to a memory , a network interface device , a storage , an input device , and an output device . The computer  is generally under the control of an operating system. Examples of operating systems include UNIX, versions of the Microsoft Windows\u00ae operating system, and distributions of the Linux\u00ae operating system. (Note: Linux is a trademark of Linus Torvalds in the United States and other countries.) More generally, any operating system supporting the functions disclosed herein may be used. The processor  is included to be representative of a single CPU, multiple CPUs, a single CPU having multiple processing cores, and the like. Similarly, the memory  may be a random access memory. While the memory  is shown as a single identity, it should be understood that the memory  may comprise a plurality of modules, and that the memory  may exist at multiple levels, from high speed registers and caches to lower speed but larger DRAM chips. The network interface device  may be any type of network communications device allowing the computer  to communicate with other computers via the network .","The storage  may be a persistent storage device. Although the storage  is shown as a single unit, the storage  may be a combination of fixed and\/or removable storage devices, such as fixed disc drives, solid state drives, floppy disc drives, tape drives, removable memory cards or optical storage. The memory  and the storage  may be part of one virtual address space spanning multiple primary and secondary storage devices.","The input device  may be any device for providing input to the computer . For example, a keyboard and\/or a mouse may be used. The output device  may be any device for providing output to a user of the computer . For example, the output device  may be any conventional display screen or set of speakers. Although shown separately from the input device , the output device  and input device  may be combined. For example, a display screen with an integrated touch-screen may be used.","As shown, the memory  of the computer  includes an application . The source and target databases , each include a stored procedure  and a table . The table  may be replicated from the source database to the target database . The table at the source database may be referred to as a source table, and the table at the target database may be referred to as a target table. The table  may be replicated to achieve high availability, scalability, disaster recovery, etc. One example use case scenario involves replicating data from an online transaction processing (OLTP) database to a reporting database. Accordingly, applications may query the reporting database without incurring any additional processing overhead or contending for database locks at the OLTP database, which is reserved for transaction processing. In some embodiments, the reporting database may also be configured to handle the transaction processing for the OLTP database in an event that the OLTP database fails or is taken down by an outage or for maintenance.","In some situations, however, the table  may become inconsistent or desynchronized across the databases. For example, an error may occur during a database operation or a replication operation. Alternatively, the table  at one of the databases may have been tampered with by an application or a user, either intentionally or unintentionally. Accordingly, in one embodiment, the application  is configured to determine, responsive to a request, whether the table in the source database is consistent with the table in the target database . In doing so, the application  may communicate with a database management system (DBMS) associated with each database  to carry out the operations described below.","In one embodiment, to determine whether the table is consistent with the table , the application performs the following operations. The application  partitions each table  based on partitioning criteria . The application  may then determine a key range  for the each partition. For each partition, the application  then generates a query  for retrieving the respective partition. The query  may be generated based on the key ranges . For each query , the application may then invoke a stored procedure  on each database , passing the respective query  as an input parameter to the stored procedure . The stored procedure  is configured to determine a checksum  for the partition retrieved by the respective query . The stored procedure  then returns the checksum  to the application .","In one embodiment, for a given partition, if the checksums  match, then the application  may determine that the given partition is consistent across the databases . At least in some embodiments, that the given partition is consistent across the databases  is merely determined to a certain statistical probability. The statistical probability may vary depending on the checksum algorithm used to compute the checksums . In one embodiment, if the given partition is determined not to be consistent, then the application  may determine that the given partition is not consistent across the databases  and proceed to determine which specific rows of the tables do not match, by comparing row checksums and\/or row key values. In some embodiments, the determination of specific rows that do not match is performed by the application . In other embodiments, the determination is performed by another stored procedure invoked by the application .","In one embodiment, if the checksums  match for all partitions, then the application  may determine that the tables are consistent across the databases . Otherwise, the application  may determine that the tables are not consistent across the databases . The application  may notify a user of whether the tables are determined to be consistent. In some embodiments, the application  may provide a user-selectable option to render the table in the target database consistent with the table source database . If the option is selected, the application  may issue one or more commands to the target database  to modify the table in accordance with the table . The commands may be expressed in a Data Manipulation Language (DML) and may include inserts, updates, and\/or deletes. Advantageously, the application  may be used to identify inconsistent rows of the table  and\/or bring the table  to a consistent state across the databases . The differences between the inconsistent rows may be stored in the storage  as differences . Alternatively, the differences  may be stored on the source database and\/or the target database . The differences may subsequently be retrieved based on user input.","In some embodiments, some or all of the functionality of the application may be performed on the source and\/or target databases rather than on the computer . In some embodiments, the application itself may execute on the source and\/or target databases . In other embodiments, some or all of the functionality of the application may be performed by the DBMS of the source and\/or target databases . At least in some cases, executing the functionality on the source and\/or target databases may be more efficient than executing the functionality on a remote computer such as the computer . Further, storing the differences on the source and\/or target databases may result in reduced network traffic and\/or latency, relative to storing the differences on the remote computer. In one embodiment, where execution occurs and\/or where the differences are stored may be tailored to suit the needs of an individual case.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 2","FIG. 1"],"b":["200","150","200","202","150","202","164","160","204","160","208","212","214","160","208","210","164","250","250","250","250","250"],"sub":["1","2","3"]},"In one embodiment, in the preprocessing stage , the application  verifies whether a number of predetermined conditions (or preconditions) are met. The predetermined conditions include a condition specifying that the tables and have identical or compatible column data types and column sizes, for at least a subset of the columns. In other words, column names and column count of the tables , need not necessarily match. In cases where the database replication allows schema mapping, instances of a replicated table may have data types and\/or sizes that are not necessarily identical but that are compatible. In such cases, the application  may use type casting to convert between the data types and\/or sizes. The type casting may be performed using predefined expressions in a query language supported by the DBMS.","In one embodiment, the predetermined conditions also include a condition specifying that the tables and are associated with the same character encoding scheme, collating sequence, and endianness. A character encoding scheme, also referred to as a code page, specifies a mapping between distinct characters being represented to distinct numeric values that are internally stored. The numeric values may also be referred to as code points. A collating sequence refers to a predefined order of distinct characters that is used to sort a collection of character strings having instances of the characters. Endianness, or byte order, specifies whether the least-significant byte or the most-significant byte is stored first. The predetermined conditions also include a condition specifying that the tables and use identical unique constraints. Unique constraints ensure that every value in a specified key is unique.","In one embodiment, if all of the predetermined conditions are met, then the application  determines the partition criteria  for use in partitioning the tables and . In one embodiment, the partition criteria  include a partition size. The partition size may be determined based on an amount of free memory on the computer . Alternatively, the partition size may be predefined by a user of the application . A partition size of sixty-four megabytes (64 MB) has shown to be useful in at least some cases. Then application  may then determine a count of partitions to be created from each table . The count of partitions may be given by the following equation:\n\nNumber_Partitions=(Total_Row_Number*Row_Size)\/Partition_Size.\n\nIn the above equation, Number_Partitions represents the count of partitions to be created in each table. Total_Row_Number represents a row count of the source table or the target table , whichever is smaller in size. Row_Size represents an estimated row size of the source table  or the target table , whichever is smaller in size. The row size estimate is retrieved for the respective table, from a system catalog of the DBMS. Partition_Size represents the partition size. Using the above equation, the count of partitions is set to the row count multiplied by row size and divided by the partition size.\n","In one embodiment, the application  may then determine a count of threads to spawn, based on the determined count of partitions. Each thread is configured to process a respective partition, in parallel with other threads. The count of threads may be given by the following equation:\n\nNumber_Threads=Min(Number_Partitions,Max_Threads)\n\nIn the above equation, Number_Threads represents the count of threads to spawn. Number_Partitions represents the determined count of partitions. Max_Threads represents a user-specified maximum number of threads to spawn. For example, a user may specify the maximum number of threads to conserve resources of the computer  for executing other applications. Using the above equation, the count of threads to spawn is set to the smaller of the count of partitions and the maximum number of threads to spawn. Depending on the embodiment, the operations of the application  during the preprocessing stage may be performed by the main thread  and\/or the validating threads .\n","In one embodiment, in the differencing stage , the application  partitions the tables , , identifies differences between the tables , , and notifies a user of the identified differences. At least in some embodiments, the partitions are created in the application  and are not reflected at all in the databases and are independent from any existing partitions in the database. Put another way, partitioning the tables does not necessarily involve altering the tables stored in the databases in any way. For instance, partitioning the tables does not necessarily involve issuing database commands to the DBMS to create database partitions or table partitions. Instead, partitioning the tables refers to generating partition information by the application, the partition information being resident in the memory  of the computer . In some embodiments, the partition information may also be stored in the storage . The partition information is subsequently used by the application  for generating the queries  to retrieve subsets of table data, the subsets being regarded by the application  as \u201cpartitions\u201d.","To better illustrate embodiments of the invention, the operations performed by the application  in differencing stage may be classified into three sub-stages. The three sub-stages include a partitioning sub-stage, a discovery sub-stage, and a reporting sub-stage. In the partitioning sub-stage, the partitioner thread  determines boundary key values for each partition from the source table . The boundary key values for each partition specify the key range  for the respective partition. The boundary key values include a minimum key value in the respective partition and a maximum key value in the respective partition. In one embodiment, the boundary key values are determined via a single index scan of the source table . Alternatively, the boundary key values are extracted from a database catalog table, without performing any index scan of the source table . Alternatively, partitions are defined by boundary key values that are extracted from sampling the table at a page-level rather than scanning the whole table. For example, the boundary key values may be extracted from the database catalog table for Partition by Range (PBR) table spaces. At least in some embodiments, the boundary key values determined from the source table also apply to the target table . Accordingly, the partitioner thread  need not necessarily access the target table for determining the boundary key values, resulting in reduced processing and\/or network traffic.","In one embodiment, for each partition, the partitioner thread  uses the boundary key values for the respective partition to generate the queries  for retrieving the respective partition from the source table and the target table , respectively. At least in some embodiments, a respective query is generated for retrieving each partition from each table . Each generated query may be stored in a list referred to as a partitioning queue or \u201cpQueue\u201d  for use in the discovery sub-stage. As used herein, a query may also be referred to as a query statement or statement.","In one embodiment, in the discovery sub-stage, the main thread  of the application  spawns a pool of merger threads  based on the count of threads to spawn, Number_Threads. Each merger thread  spawns two worker threads . The two worker threads  include a respective worker thread for each table . The first worker thread of each merger thread  connects to the source database , and the second worker thread of each merger thread  connects to the target database . Each merger thread  then retrieves and removes, from the partitioning queue , the query  for a respective partition to be evaluated. Each merger thread  then assigns the query  to its worker threads via a partitioning statement queue or \u201cPSQueue\u201d  associated with the respective merger thread . Each worker thread then invokes a stored procedure  on the source database or target database , depending on the respective worker thread. When invoking the stored procedure , the respective worker thread passes the query  as an input parameter to the stored procedure .","In one embodiment, when invoked, the stored procedure  retrieves all rows of a given partition using multi-row fetches based on the received query , where the rows of the given partition are sorted based on a unique key. The stored procedure  then computes a row checksum for each retrieved row. The stored procedure  may store, in a temporary table associated with the calling worker thread, the row checksums and key values in the retrieved rows. At least in some embodiments, the temporary table may be a non-logged table.","In one embodiment, the stored procedure may then compute a partition checksum for the given partition, using the row checksums for all rows of the given partition. The partition checksum may be computed recursively using a checksum aggregation function, as given by the following pseudocode:\n\nChk_agg3(Chk_agg2(Chk(row1), Chk(row2)), Chk(row3));\n\nIn the above pseudocode, Chk_agg3 and Chk_agg2 represent calls to the checksum aggregation function. Chk represents calls to the checksum algorithm. row1, row2, and row3 represent rows retrieved from the table .\n","In one embodiment, the partition checksum may also be computed using an alternative approach. In the alternative approach, the stored procedure performs m multi-row fetches. For example, if each fetch retrieves five hundred rows and the stored procedure is operating on a partition having ten thousand rows, then the stored procedure would perform twenty multi-row fetches. In the first multi-row fetch, the stored procedure calculates a row checksum for each row to generate a set of row checksums given by {rc_1, rc_2, . . . , rc_n}. The row checksums may be stored in an array to subsequently be used for multi-row insertions into the temporary table. Further, treating the row checksums are treated as a single, continuous character string, the stored procedure may generate a checksum from the continuous character string. The generated checksum may be referred to as the multi-row checksum.","For each multi-row fetch subsequent to the first multi-row fetch, the stored procedure may use recursive aggregation to generate a multi-row checksum for the respective, subsequent multi-row fetch. For example, the stored procedure may compute the multi-row checksum of a multi-row fetch between row 1 through row 3N in the partition, according to the following pseudocode:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Chk_agg( Chk_agg (Chk_agg(InitialCRC,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Concat(Chk(row1), ..., Chk(rowN)) ),"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Concat( Chk(rowN+1), ..., Chk(row2N)) ),"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Concat (Chk(row2N+1), ..., Chk(row3N)) );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["164","210"]},"In one embodiment, the row checksum, the multi-row checksum, and the partition checksum may each be of any predefined length. In a particular embodiment, the row checksum is four bytes long, the multi-row checksum is eight bytes long, and the partition checksum is eight bytes long. Further, the row checksums and partition checksums may be computed using any predefined checksum algorithm. Examples of checksum algorithms include Fletcher's checksum, Adler-32 and cyclic redundancy checks (CRCs). Using a CRC algorithm to compute the checksums and\/or composite checksums may reduce collision probabilities at least in some cases. A collision occurs when an identical checksum is generated from two distinct input values, respectively. At least in some embodiments, the odds of a collision under a CRC algorithm may be less than one in four billion.","In one embodiment, if, for a given a given partition, the partition checksum from the target table matches the partition checksum from the source table , then the merger thread  determines that the given partition is consistent across the databases  and proceeds to process a next partition by retrieving a next query  from the partitioning queue . Otherwise, the merger thread  queues a merge request to its worker threads . In response to the merge request, each worker thread  fetches keys and corresponding row checksums from the temporary table associated with the respective worker thread . The worker threads  then pass the fetched keys and row checksums to the respective merger thread . The keys and row checksums may be sorted by key order and passed via checksum queues or \u201cCKQueues\u201d  associated with the merger threads . Each merger thread  then joins the result sets by key values to identify differences on a row-by-row basis. Each merger thread  sends each identified difference to the reporter thread  via a difference reporting queue or \u201cdQueue\u201d  associated with the reporter thread . The discovery sub-stage is complete after the differences are identified.","In one embodiment, in the reporting sub-stage, the reporter thread  retrieves all the identified differences from the difference reporting queue . The reporter thread  then inserts a respective key value and a proposed action into a differencing table associated with the reporter thread . The proposed action refers to a command for resolving the identified difference and may include inserts, updates, and\/or deletes. To bring the target database into a state consistent with the source database , the application  may retrieve the commands from the differencing table and issue each command against the DBMS of the target database .","In one embodiment, after completing the differencing stage , the application  proceeds to the cleanup stage . In the cleanup stage , each cleaner thread  performs one or more cleanup operations on the respective databases . The cleanup operations may include deleting, from each database , the temporary tables associated with the worker threads .","In one embodiment, the application  may determine whether the source table is consistent with the target table , even when the source table and\/or the target table are being modified by one or more other applications, and without impacting the other applications. To this end, when extracting data from the databases , the application  opens a cursor with uncommitted read isolation level. However, the differences identified by the application  in such scenarios may not necessarily reflect the latest modifications to the tables .","In one embodiment, to identify differences that reflect the latest modifications to the tables , all applications issuing transactions against the source table are first suspended before the application  performs the consistency determination. For configurations in which both tables , are allowed to accept updates, all applications issuing transactions against the target table are also suspended and all in-flight transactions are first allowed to replicate at the source table , before application  performs the consistency determination. Further, because processed but uncommitted transactions may appear in query results obtained from the source table  and\/or target table, the suspended applications are to remain suspended for the duration of the consistency determination. Otherwise, the consistency determination may include false positives and\/or false negatives.","In some cases, however, it may be unacceptable to suspend certain applications for a prolonged period of time. Accordingly, if the table  includes a date, time, or timestamp column, the application  may be configured to limit the range of rows to compare, as specified by a user. For instance, the table  may include a timestamp column indicating when a row was last modified. The application  may use the timestamp column for setting, based on user input, a lower bound and an upper bound of a range of rows to compare. On the other hand, if the table  does not include any date or time column, the application  may perform two consecutive consistency determinations and compare the results of the consistency determinations. If replicated updates are suspected be occurring at the table , then the second consistency determination may be performed after a replication latency window has elapsed. The application  may select, as output, the identified differences that are common to both consistency determinations. The output reflects the actual differences between the tables , , to the exclusion of any false positives or negatives resulting from the replicated updates.","As described above, one of the preconditions for performing consistency determination is the condition that the tables and are associated with the same character encoding scheme, collating sequence, and endianness. Nevertheless, in some embodiments, even if the tables and are associated with different character encoding schemes, collating sequences, and\/or endianness, the application  may consider the precondition to be satisfied after performing one or more conversion operations. For example, in the collating sequence associated with Extended Binary Coded Decimal Interchange Code (EBCDIC), the uppercase letter \u2018A\u2019 comes after the lowercase letter \u2018a\u2019. In contrast, in the collating sequence associated with American Standard Code for Information Interchange (ASCII), the uppercase letter \u2018A\u2019 comes before the lowercase letter \u2018a\u2019.","In one embodiment, the conversion operations include retrieving, from the source table , the rows to be compared. The retrieved rows may be compressed into a reduced row format (RRF). The compressed rows include the key columns and row checksums of the retrieved rows. The conversion operations include determining the collating sequence used by the source database . To this end, the application  may selecting a character encoding scheme (such as ASCII) and insert all characters defined by the selected character encoding scheme into a temporary table in the source database . The application  may then generate a query to retrieve the inserted characters, the query including an ORDER BY clause on the inserted characters. Results retrieved from the query may be used as a lookup array, where each character is used as an index to a corresponding numeric value specified by the character encoding scheme in effect at the source database . These operations may also be repeated for the target database .","In one embodiment, the lookup arrays may then be used to determine whether the collating sequences are different between the databases . When the collating sequences differ, the application  compares keys in rows retrieved from the databases in a character-by-character manner. Specifically, for each two characters to be compared, the application  does not directly compare the two characters. To be clear, the two characters to be compared include a first character from the source table and a second character from the target table . Rather than comparing the two characters directly, the application  instead retrieves a code point for the first character from the lookup array in the target table . The application  then retrieves a code point for the second character from the lookup array in the target table . The application  then compares the retrieved code points to determine if the two characters match. In other embodiments, rather than the lookup array in the target table to retrieve a code point for the first character, the application  may use the lookup array in the source table to retrieve a code point for the second character. To compare each retrieved row, the application  may calculate a row checksum over non-key columns of the row and use a binary search to look up the key in the compressed rows that are stored in RRF format. If a matching key is found, then the row checksums are compared. The application  may record all differences identified into the difference reporting queue. The identified differences may be recorded by storing the associated keys and proposed actions into the difference reporting queue.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 3","FIG. 4"],"b":["300","300","300","310","150","150","315","150","150","315","320","150","330","150","330","340","150","350","150","350","350","300"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 4","FIG. 3"],"b":["400","400","330","400","410","150","420","150","430","150","440","150","150","410","430","440","400"]},"Advantageously, embodiments of the invention provide techniques for comparing database tables. One embodiment provides an application configured to compare the database tables by partitioning the database tables, generating queries for retrieving each partition, and invoking a stored procedure using the generated queries as an input parameter. The stored procedure is configured to generate a checksum based on the respective partition. The application compares the checksums to determine if the partitions and\/or tables are consistent. Advantageously, the techniques disclosed herein may be used to compare database tables more conveniently, efficiently, and\/or scalably at least in some cases, especially for large table sizes and\/or geographically distant databases.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited aspects are attained and can be understood in detail, a more particular description of embodiments of the invention, briefly summarized above, may be had by reference to the appended drawings.","It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
