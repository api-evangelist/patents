---
title: Method and system for visual linker
abstract: The present invention provides a visual linker. The visual linker includes a link server that implements linking instructions for sections to a memory. The visual linker also includes a graphical user interface that receives said instructions and displays said sections within said memory. The visual linker also includes an application programming interface that receives said instructions and reports the results of said linking instruction and said sections within said memory. The visual linker also includes an incomplete link comprising sections not allocated to said memory. The visual linker also includes a link recipe comprising said instructions implemented by said link server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06883167&OS=06883167&RS=06883167
owner: Texas Instruments Incorporated
number: 06883167
owner_city: Dallas
owner_country: US
publication_date: 20000626
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of Provisional Application Ser. No. 60\/147,242, filed Aug. 4, 1999, and U.S. Provisional Application Ser. No. 60\/158,249, filed Oct. 8, 1999.","The present invention relates to software development tools, and, more particularly, to software program linking and methods.","Software is constructed in pieces. Source code is expressed in a language, such as \u201cC\u201d or assembly, and is organized into multiple text files. Each of these files is processed into a corresponding binary file known as an object file by a compiler and\/or an assembler. A linker combines the object files into a single file. The linked output file may be a complete application, and may be executed on a particular target computer hardware system. Alternatively, the output may be a partial link such that it is used as an ingredient in a subsequent link.","To perform the linking process, the linker is given a list of ingredient object files, a description of the target computer memories and directions on how to combine and place the ingredients into the memories. The ingredient files are composed of \u201csections\u201d. Each section contains code or data to be placed into the memories. During this process, different sections of the compiled application are assigned to various memories of the target hardware system. Embedded systems, such as digital signal processors (\u201cDSPs\u201d), have a plurality of memory types with different sizes, speeds and other characteristics. The allocation of application code and data to the different locations in memory affects the performance of the application after it is embedded onto the hardware system.","Referring to , a software development system  is depicted. As described above, text files  and  are source code written by a programmer. Text files  and  may represent a plurality of text files. Compiler  translates the source code in text files  into assembly language source code. Text files  represent assembly language source code files written manually. Assembler  translates the assembly language source files from compiler  or a programmer. Machine language object files  are outputted from assembler . Object files  may be known as object programs or object modules. As described above, object files  are the corresponding binary files to text files  and , either alone or in combination.","Linker  combines object files  into a single executable object module, or output file . In addition to object files , linker  accepts library files  containing multiple object files. Linker  also allows for the combination of object file sections, binds sections or symbols to addresses within memory ranges, and defines or redefines global symbols. After linking operations are completed, output file  is downloaded to processor . Thus, linker  places object files  in memory on processor  as output file, or output program, .",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2A","b":["200","110","108","108","206"]},"Linker allocation directions in linker commands  are expressed in a custom text-based command language requiring extensive study and documentation. A user inputs and edits linking instructions in text editor . Text editor  writes instructions into command file  to be inputted into linker . The user studies the textual linker output in map file  and errors  for the results of the linking instructions and makes any necessary changes to the command file . This process is repeated until the desired results are obtained. Linker  receives object files  and library files . Using command file , linker  links ingredients  according the linking instructions to separate output file . As described above, output file  may be an executable application.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2B","b":["221","110","222","110","108","112","206","224","110","110","206","225"]},"Step  executes by determining whether all reference symbols have been defined by linker . If no, then step  executes by issuing an error signal or message. If yes, then step  executes by determining whether the sections of code and data fit in the target memories. If no, then step  executes by issuing an error signal or message as a problem has arisen that must be resolved. If yes, then step  executes by relocating symbolic references in the allocated sections of code or data. Step  executes by writing output file  and link map file  for review by a user.","Step  executes by denoting a failure has occurred in the linking operations. Step  may execute subsequent to the error message in step . Step  executes by denoting the linking operations have been successful.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3","b":["110","316","318","300","1","2","3","302","1","2","304","1"]},"Allocation module  inputs linker commands . Linker commands  are a set of instructions that tell allocation module  where to place the sections of object files A, B, and C in the target computer hardware memories. Memories  and  represent memory devices within the target system. Memories  and  have different locations and addresses within the address space of the target system. Using the linking instructions, allocation module  places each section within the ingredients into a memory device. For example, allocation module  places section A of object file A in memory  at a specified location. Allocation module  also places section B of object file B in memory  at another location, different from the location of section A.","Allocation module  also resolves any issues regarding symbolic references within the sections of the object files. Sections may have calls, or branches, to subroutines in other sections within the object files, or even to other object files. These calls are represented by symbol references within the code. As the sections of code are linked within memories  and , the symbolic references to symbols within these sections are replaced by address locations within the memory.","Referring to , a linker symbol resolution system is depicted. Ingredients  include object files having a plurality of sections of code, including sections  and . Section  includes a code block  that contains a definition of a branch label A. Code block  also includes other information. Section  also includes a symbol dictionary block  that lists symbol A as being defined in section , and has an offset of 20 from the origin of code block .","Section  includes a code block  and a symbol dictionary block , similar to section . In code block , a branch instruction lists branch label A as its target. Symbol dictionary block  lists symbol A as being a reference to a definition elsewhere without a known offset as section  has not been allocated to a memory location.","During the allocation phase of allocation module  in , linker allocation decision module  allocates sections  and  of ingredients  to specific addresses in the target computer hardware memory. Linked output file  includes allocated sections  and  that correspond to section  and , respectively. Branch target , or label A, is located within allocated section . Further, branch instruction, or call,  to label A is located within allocated section . Branch instruction  is known as a symbol reference within allocated section .","The base, or beginning, addresses of sections  and  are recorded in table block  inside linker . For example, the base address of section  is memory address . Referring to symbol dictionary block , symbol A has an offset of 20 from the base address. Thus, branch target , or label A, is located at address  within the memory.","During the relocation and output steps of the linking operations, all symbol references  are replaced by actual addresses computed by adding the symbol offsets in the symbol dictionaries to the section base addresses in table block . These addresses are inserted into the linked code, such as symbol reference . Thus, the symbol references are replaced by address locations by linker .","Referring back to , after allocation module  completes the allocation of the sections of object files A, B, and C, then output module  links the sections within the memories to generate output file  that represents an application to be run on a target computer system.","The linking process involves a preparation period for a user to resolve any errors with the linking process, as described in step  of FIG. B. Known linkers report errors and may fail to complete the allocation of the ingredients object files if there are unresolved symbolic references. Thus, if the list of input object files and libraries is not complete, then an error occurs within the linking process. The user then re-edits command file  to improve or adjust the linking instructions. This activity inhibits interactive allocation strategies in which a user attempts to optimize the allocation of only a part of the ingredients of the software program before the remaining parts of the program are available or written. No links may be left incomplete. Therefore, extensive experimentation is prohibited and users are discouraged from finding more optimal ways of linking.","Attempts to reduce development time for the linking instructions include tools that dialogue with the user, and write linker instruction command files for the user. These tools are appropriate for simple applications, but may not be able to adequately optimize complex applications or memories. Another attempt includes a visual link map analyzer that uses visual input to edit a linker instruction command file, and runs the command file through the linker. The analyzer displays the linker map file . These systems, however, include two separate programs, a traditional linker and a visual analyzer. These programs maintain separate models of the link in order to perform their respective tasks.","Further, known linkers are unable to resolve incomplete links. Referring back to , all sections must fit in memories before an output file may be created or the symbol references resolved. This requirement inhibits interactive linking strategies as all links must be complete before an map file is generated for review by the user.","As software applications evolve, the ingredients change as do the sizes and the properties of the individual ingredient object files . The instructions in command file  for allocation of a target system memory may become obsolete periodically and require maintenance. Directions are updated to interface with new hardware target system memories.","In many instances, it is the user's responsibility to understand all component specifications and requirements and to reflect them in text-based linker command file . The user combines these constraints in generating the linking instructions with text editor . For updates, the user manually merges linker command file  into a bigger command file each time.","Linking operations impact performance on embedded processors, such as digital signal processors. Unlike general purpose processors having a single, large memory, embedded processors have many different memories. The layout of the application into various target memories impacts performance. Certain kinds of fast memory, such as on-chip memory, are limited in space and desired for critical application functions. Trade-offs are made depending on the size of the programmer's application plus any third party components and libraries. As the program evolves and grows, the allocation decisions are revised in a time-consuming manner.","New software development tools that build applications from large, predefined components are available. The tools attempt to manage the linking process, but are hindered by having to write commands  and by having to parse map files , and error files , that intended for humans.","From the foregoing it may be appreciated that a need has arisen for a system and method for an interactive, visual linker that may be controlled either by humans or software components. In accordance with one embodiment of the present invention, a method and system for a visual linker is provided that substantially eliminates and reduces the disadvantages and problems associated with conventional linkers in software development systems.","The present invention allows a user, software program, or component via commands, gestures, and application programming interfaces (\u201cAPI\u201d) to specify a link in an incomplete fashion. During such incremental specification, the link may be incomplete. Ingredient object files need not be complete. Nor do all sections from each object file need be placed (allocated) into memory. Symbolic references need not be resolved.","With reference to the incomplete link, the visual linker of the present invention communicates to the user via visual or graphical displays without producing errors or other procedures to prevent further linking operations. This feedback includes the allocated position and size of the sections that are allocated to memory, the values of symbols that are allocated, a list of symbolic references that are not defined, and a list of ingredient object files and sections that are not allocated. Thus, the user receives real-time feedback on the results of the linking operations even if not all object files and sections are allocated to a location in memory. Therefore, the user may experiment with different linking strategies without the need for actually completing the link.","The present invention includes a graphical user interface (GUI) that receives commands or gestures from a user via an input device and translates the commands or gestures into linking instructions or steps. The commands or gestures include drag-and-drop commands, and menu commands using a pointing device such as a mouse.","The present invention also includes a link server API that allows client software programs or program components to participate in the link process. The link server provides continuous feedback to the client programs or components and this enables the programs or components to monitor and react to the incomplete link described above.","Further, the user (via the GUI) or the client program may alter incrementally an incomplete, link by a plurality of commands, either alone or in combination. The commands include adding or removing ingredient object files or code sections to be included in the linking operations. The commands also include specifying the sections from the ingredient files that are to be allocated. The commands also include deallocating or reallocating sections previously allocated. The commands also include specifying a memory area that certain sections or various kinds of sections are to be allocated. The commands also include specifying constraints on the allocation of certain sections and object files, such as specifying absolute addresses for sections or symbols, or specifying alignment constraints on addresses for sections or symbols. The commands also include specifying the order that sections and object files are allocated. The commands also include defining new symbols that are referenced by object files during linking operations.","The link server provides continuous feedback from the linking operations. Feedback is information passed from the linking operations back to the client software program or component so that the program or component may perform additional operations. Via the link server, the client software program or component may determine the address assigned to a section or symbol during linking operations. The program or component may determine the length of a section. The program or component may determine whether any section is not allocated as specified. The program or component may determine whether any control action succeeded or failed. Further, the interface between the link server and other software programs or components allows more than one program or component to simultaneously control and\/or receive feedback during linking operations.","Link instructions (steps) received by the link server are recorded and may be replayed, without user interaction, to obtain a similar effect as the sequence of commands or gestures. The linker also allows the steps of the recipe to be viewed and individually changed. The linker also allows the steps of the recipe to be imported into other recipes to perform part or all of a linking process.","During the process of creating the steps, the link server may generalize the gestures or commands. Thus, a consecutive series of commands or gestures that result in moving each section of a particular kind to a particular memory area is generalized to a single step that moves all sections of the particular kind to the particular memory area. Further, a command or gesture that moves each section currently referenced by a particular section is generalized to a single step that moves any sections referenced by the particular section. Moreover, a command or gesture that moves each section from a particular object file is generalized to a single step that moves all sections from the particular object file.","A technical advantage of the present invention is that a visual linker is provided. Another technical advantage of the present invention is that a visual linker is portable and compatible with multiple target embedded memory systems. Another technical advantage of the present invention is that the visual linker interacts with other software tools and wizards.","Another technical advantage of the present invention is that the visual linker allows a user to view visual and graphical memory layouts while adjusting memory allocations. Another technical advantage of the present invention is that the visual linker may be a stand-alone software tool. Another technical advantage of the present invention is that the time to develop linking process instructions and strategies is reduced. Another technical advantage of the present invention is that unused code and unused data are automatically eliminated from the link through the use of a reachability check done using a cross-reference graph, thus reducing the size of the linked application. Another technical advantage of the present invention is that training requirements are minimized and training time is reduced. Another technical advantage of the present invention is that maintenance time is reduced. Another technical advantage of the present invention is that a visual linker is provided with increased functionality. Another technical advantage of the present invention is that the visual linker allocates blocks of code to embedded memory machines without running confidence check programs and in reduced time.","An embodiment of the present invention and its advantages are best understood by referring now in more detail to  of the drawings, in which like numerals refer to like parts.  illustrate a visual linker in accordance with one embodiment of the present invention.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5A","b":["500","500","501","501","508","504","501","510","512","501","503","508","501","505","116","116"]},"In hardware terms the visual linker  may be as illustrated by  as a programmed computer workstation with a display, keyboard and mouse connected to the processor which performs the server operation and includes a linker program for linking and displaying results through the GUI interface. The GUI provides windows and drag-and-drop operations with the mouse and wizards for setup by step-by-step inquiries. A user developing a linking strategy executes a linking process using visual linker . The user interfaces with visual linker  via GUI . GUI  may utilize a display device, such as a computer monitor, to create a graphical representation of the memory layout within processor . GUI  also may accept input from a keyboard allowing the user to send commands to the visual linker . GUI  also may accept input from a mouse or other pointing device allowing a user to send commands using gestures such as drag-and-drop and point-and-click to visual linker . Using GUI , a user may allocate ingredients  to a layout of the memories for processor . By receiving linking instructions via GUI , visual linker  specifies how code and data sections from object files, library files, and other files within ingredients  are to be allocated to the memories of the processor. After each instruction, the user views the results of the linking instructions using the graphical representation placed on the display device by the GUI . These results include how much memory is allocated to the sections of ingredients , how much memory of processor  is unallocated, etc.","Referring to  there is illustrated a display screen of one embodiment of the present invention. A user may use a pointing device to drag-and-drop icons representing sections and thus specify allocation operations.","GUI  displays the results of the linking operations by showing where sections of code within ingredients  are allocated. GUI  and link server  share the same data structure describing the state of the incomplete link. GUI  may display this information in a variety of ways. Thus, visual linker  via GUI  may display the output grouping of sections, or output groups, a hierarchical visual tree, such that output groups may contain input sections or other output groups. Visual linker  provides a hierarchical, visual tree view of the target memories within processor . Further, visual linker  provides a hierarchical, visual tree view of incomplete link . In addition, visual linker  provides a layered memory picture via GUI  such that the layers correspond to a hierarchical tree view of output sections, including output sections of incomplete link .","Further, client software programs  specify linking instructions or commands. The instructions or commands are received by API  and passed onto link server . Link server  then executes the operation. Thus, visual linker  allows other software programs or program components to participate in the link process. Visual linker  also enables client programs  to accept or modify incomplete link , as described below.","Visual linker  includes incomplete link . Incomplete link  may represent a list of object files within ingredients  that are not complete in that some files are missing. Incomplete link  also may represent object files having sections that have been allocated and sections that have not been allocated. Further, incomplete link  represents the result of the symbolic references not being resolved. The symbolic references are not resolved because not all code sections have been allocated to a location in the target memories represented by memory description .","Visual linker  reports that status of incomplete link  back to the user via GUI  or to client programs  via API . Visual linker  may report the allocated position and size of allocated sections from the object files of incomplete link . Visual linker  also may report the values of symbols that have been allocated to a memory location in incomplete link . Further, visual linker  also may report the list of symbolic references that are not defined by incomplete link  as their location in the target memory has not been specified. Moreover, visual linker  may report the list of object files or sections of ingredients  that have not been allocated by link server .","After the user or client programs  receives the status of incomplete link , further instructions or commands to incrementally complete incomplete link . The user uses gestures via GUI  and client programs  use commands via API  to allocate, deallocate or reallocate additional sections of the object files and libraries within ingredients . The changes to incomplete link  resulting from these actions are reported back through GUI  or API . Symbols within incomplete link  may be defined or redefined as a result of the actions received by visual linker . In addition, commands or gestures received may add or drop ingredient object files or sections from incomplete link . Thus, incomplete link  is modified in an event driven manner by commands or gestures received through API  and GUI . The commands or gestures manipulate link server , which, in turn, modifies incomplete link .","Client programs  or a user control visual linker  with a variety of actions. Specifically, visual linker  is event-driven in that external events are received by GUI  and API . GUI  and API  translate the received events into linking instructions. The events include gestures through GUI , such drag-and-drop, and commands issued by client programs  through API .","The linking instructions control visual linker  and the resulting linking process. Thus, client programs  may control visual linker  by adding or removing object files within ingredients  and by specifying which of the sections from ingredients  are to be included in the link being performed by link server . Further, client programs  may control visual linker  by allocating, deallocating or reallocating sections of ingredients  previously allocated.","Visual linker  also receives input via GUI  and API  that specifies the memory area within processor , and as described in memory description , into which particular sections are to be allocated by link server . Various kinds of sections or object files, such as libraries, also may be allocated by specifying a memory area.","Client programs  controls visual linker  via API  to specify constraints on the allocation of particular sections. These instructions may specify absolute addresses for certain sections or symbols, or specify alignment constraints on addresses for sections or symbols. Further, these instructions may specify a specific order to allocate sections and symbols within ingredients .","Client programs  control the link server  via API  to define new symbols that may be referenced by sections in the link. Client programs  also control link server  through API  to specify characteristics of the allocation strategy.","Link server  provides feedback to client programs  through API  on the status of linking operations or the results of events received. After receiving the information, client programs  may take further action or define further events. Client programs  may use the information from link server  to determine an address assigned to a section or symbol by link server  or to determine the length of an allocated section. Client programs  also may use the information from visual linker  for troubleshooting or optimizing the linking process. For example, client programs  may determine whether any section is not allocated as specified by the received linking instructions or determine whether any control action mentioned above succeeded or failed.","A user may control visual linker  like client programs  via GUI . Thus, visual linker  is controlled according to the operations described above by more than one entity. In addition, the user may use feedback from visual linker  via GUI  to determine the status of the links and other parameters, as described above. With the interfaces of API  and GUI , a multiple entities may control and receive feedback from visual linker .","As visual linker  receives linking instructions from the user or client programs  via API , a linking recipe  is generated. Linking recipe  may be the set of linking instructions or strategies received by API  that describe how visual linker  is to be controlled. Link server  executes the instructions and generates the step to be included in linking recipe .","The link server  can replay the steps of the linking recipe  without user interaction, to obtain the same effect as the sequence of gestures. The link server  may access the steps of the linking recipe  and in conjunction with the GUI allow the steps to be viewed and changed on an individual basis (FIG. ). Linking recipe  may be stored as a file or imported into other recipes to perform all or part of a link.","When creating linking recipe , visual linker  may generalize the events received from the user or client programs . These events may include gestures or commands, and are translated by API  and GUI . A consecutive series of events that moves each section of a particular type is generalized to a step in linking recipe  that moves all sections of that type to the specified memory area. Further, an event that moves each section currently referenced by a particular section is generalized to a step that moves any section referenced by the particular section to that location. An event that moves each section of a particular object file is generalized to a step that moves all sections from the particular object file. Thus, the steps of linking recipe  allow for a strategy that includes control of visual linker  to allocate sections that might exist in a future link and meet a specified criteria to be allocated according to linking recipe  without the need for revisions or updates.","Because the linking strategy is a record of operations requested through API , the functionality is not restricted by the syntax of a command language. Operations may be specified to define policy or other concepts difficult to engineer into a traditional linker's command language. For example, a user or client program may specify an overflow policy to be used whenever a portion of memory fills up during allocation.  illustrates the presentation of this operation by the GUI  of one embodiment of the present invention. Another operation may allow a user or client program to request an optimized stack or heap size by specifying a minimum and maximum size instead of a particular size and letting the allocator pick the best size within this range.  illustrates the presentation of this operation by the GUI  of one embodiment of the present invention. Another operation may allow a user or client program to access across-reference graph in order to perform operations on a list of sections reachable from a particular section.  illustrates the situation where a user interfacing through the GUI  of one embodiment of the present invention, may use this feature to view and allocate (using drag-and-drop) all code sections reachable from a square root function called \u201c_sqrt\u201d held in a particular code section.","A complete, linked output file  is generated after the sections of ingredients  are allocated by visual linker . Output file  is downloaded into the memories on processor . The layout specification, or link strategy, is reflected in linking recipe . This specification or strategy may be used again for similar processors  and memory descriptions , or later modified for different application requirements.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 5B","b":["520","504","506","521","501","508","526","524","510","501","524","505","525"]},"If the instruction received in step  is an information request instruction, then step  executes by determining the status of the links, including incomplete link , in visual linker , and returning that status and other information via API  or GUI .","If the instruction received in step  is a write output instruction, then step  executes by determining whether the link defined by the linking operations within visual linker  is complete. If no, then step  executes by returning the status of the link and other information via API  or GUI . If yes, then step  executes by relocating the symbols defined in ingredients  and allocated by link server . Step  executes by writing output file  and map file . Step  executes by returning the status of the link and other information. Thus, the method is an iterative process that allows visual linker  to receive instructions and review the changes within the link of visual linker  prior to generating output or map files.","Thus, it is apparent that there has been provided, in accordance with an embodiment of the present invention, a visual linker that satisfies the advantages set forth above. Although the present invention has been described in detail, it should be understood that various changes, substitutions, and alterations may be made herein. Other examples are readily ascertainable by one skilled in the art and may be made without departing from the spirit and scope of the present invention as defined by the following claims."],"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in connection with the accompanying drawings, in which:",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
