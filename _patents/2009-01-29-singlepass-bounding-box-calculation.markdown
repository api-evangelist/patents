---
title: Single-pass bounding box calculation
abstract: Embodiments for single-pass bounding box calculation are disclosed. In accordance with one embodiment, the single-pass bounding box calculation includes rendering a first target to a 2-dimensional screen space, whereby the first target includes at least six pixels. The calculation further includes producing transformed vertices in a set of geometry primitives based on an application-specified transformation. The calculation also includes generating six new points for each transformed vertex in the set of geometry primitives. The calculation additionally includes producing an initial third coordinate value for each pixel by rendering the at least six new points generate for each pixel to each corresponding pixel. The calculation further includes producing a post-rasterization value for each pixel by rasterizing the at least six new points rendered to each pixel with each corresponding pixel. Finally, the calculation includes computing bounding box information for the set of geometry primitives based on the produced third coordinate values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08217962&OS=08217962&RS=08217962
owner: Microsoft Corporation
number: 08217962
owner_city: Redmond
owner_country: US
publication_date: 20090129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In 3-dimensional rendering, geometry primitives (e.g., triangles) that make up polygon models may be projected onto a 2-dimensional surface (e.g., display screen area). The projected geometry primitives may be rasterized and rendered into a finished image. Screen Extension Report (SER) is a graphics functionality that uses the 2-dimensional coordinates of projected triangles to compute 2-dimensional bounding boxes for the rendered regions of these triangles. The computed bounding boxes of the triangles may be further used for triangle collision detection, triangle occlusion detection, and the elimination of redundant triangle rendering. The SER graphics functionality may be implemented by a specialized Graphics Processing Unit (GPU) that includes dedicated SER hardware, such as GPUs included in various gaming systems.","While SER is generally implemented using dedicated SER hardware on a GPU, it is also possible to implement the SER functionality without the dedicated SER hardware by performing multiple processing passes or shifting the computation to the central processing unit (CPU) during graphics rendering.","For example, in some multiple pass tile-based rendering processes, the 2-dimensional rendering target (e.g., display screen area) may be first subdivided into a set of rectangular tiles. In an initial processing pass over the rectangles, the GPU may perform the SER functionality by computing the bounding boxes for the triangles in each rectangular tile. In a second processing pass, the GPU may perform tile-based rendering. Tile-based rendering process may use screen extension information, that is, the bounding boxes computed during the initial processing pass to determine triangles that actually contribute to each rectangular tile (e.g., triangles visible on the surface of each rectangular tile). Accordingly, tile-based rendering may render only the contributing triangles rather than all of the triangles encompassed in each rectangle tile during the process.","This Summary is provided to introduce a selection of concepts in a simplified form that is further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Described herein are embodiments for the implementation of a single-pass graphics rendering process that performs 2-dimensional bounding box calculations using a generic graphics processing unit (GPU). As used herein, generic GPU refers to a GPU that does not include dedicated Screen Extension Report (SER) hardware. The 2-dimensional bounding box calculations performed in accordance with the embodiments are equivalent to the calculations performed by the SER functionality executing on a GPU that includes dedicated SER hardware.","The performance of SER-equivalent 2-dimensional bound box calculations as part of a single-pass graphics rendering process, rather than an independent processing pass, may increase processing efficiency by reducing processing overhead. Alternatively, the performance of SER-equivalent 2-dimensional bound box calculations as part of a single-pass graphics rending process may reduce or eliminate the need to burden a central processing unit (CPU) with the SER computations during graphics processing by a generic GPU.","In one embodiment, the single-pass bounding box calculation includes rendering a first target to a 2-dimensional screen space, where the first target includes at least six pixels. The calculation further includes producing transformed vertices in a set of geometry primitives based on an application-specified transformation. The calculation also includes generating six new points for each transformed vertex in the set of geometry primitives. The calculation additionally includes producing an initial third coordinate value for each pixel by rendering the at least six new points generated for each pixel to each corresponding pixel. The calculation further includes producing a post-rasterization value for each pixel by rasterizing the at least six new points rendered to each pixel with each corresponding pixel. Finally, the calculation includes computing bounding box information for the set of geometry primitives based on the produced third coordinate values.","Other embodiments will become more apparent from the following detailed description when taken in conjunction with the accompanying drawings.","This disclosure is directed to a single-pass graphics rendering implementation that performs Screen Extension Report (SER) equivalent 2-dimensional bound box calculation functionality using a generic graphics processing unit (GPU). Screen Extension Report (SER) is a graphics functionality that uses the 2-dimensional coordinates of projected triangles to compute 2-dimensional bounding boxes of rendered regions of these triangles. The computed bounding boxes of the triangles may be further used for triangle collision detection, triangle occlusion detection, and the elimination of redundant triangle rendering. In some computing systems, the SER functionality may be performed during graphics rendering by a GPU that is equipped with dedicated SER hardware.","In other computing systems where the GPU lacks dedicated SER hardware, the GPU of each computing system may perform the SER functionality via multiple-pass processing (e.g., processing a to-be rendered graphic image for SER information prior to actually rendering the graphics image). In alternative computing systems, the performance of the SER functionality in each computing system may be shifted from the GPU that lacks dedicated SER hardware to a central processing unit (CPU) of the computing system. However, both multiple-pass processing and burden shifting to the CPU to perform SER functionality may result in an additional processing burden and\/or processing inefficiency.","Embodiments herein enable the performance of the SER-equivalent 2-dimensional bound box calculation functionality as part of a single-pass graphics rendering process by a generic GPU. As used herein, generic GPU refers to a GPU that does not include dedicated SER hardware. The ability to use a generic GPU to perform the SER functionality in a single pass rendering process may reduce or eliminate the need to burden a central processing unit (CPU) with the SER computations during graphics processing by the generic GPU. Further, the need to perform a dedicated SER processing pass by the generic GPU prior to the actual graphics rendering pass may be eliminated. The elimination of such processing may increase processing efficiency, reduce processing time and\/or burden on the respective processors. Various examples of single pass graphics rendering implementations that perform the SER functionality using a generic GPU in accordance with the embodiments are described below with reference to .","Exemplary Scheme",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1","FIG. 2"],"b":["100","100","102","104","106","108","110"]},"In at least one embodiment, the vertex shader  may receive a set of geometry primitives (e.g., triangles ) from software application. For example, but not as limitations, the software application may be any program, computer readable instructions, or data structures that need to render graphics to a display. The vertex shader  may use a GPU to transform the 3-dimensional position for each vertex of each geometry primitive  in a 3-dimensional virtual space to 2-dimensional coordinates of screen space, such as screen space . Subsequent to processing by the vertex shader , the rasterizer  may use the GPU to fill the geometry primitives  with pixels. Subsequently, the pixel shader  may use the GPU to calculate and provide color to the individual pixels that make up the geometry primitives  to generate rendered targets, e.g., images .","In some embodiments, following processing by the vertex shader , the geometry primitives  may be further processed by the geometry shader  prior to processing by the rasterizer . In such embodiments, the geometry shader  may add to and remove vertices from the geometry primitives, as well as provide volumetric details to the geometry primitives. As further described, the bounding box calculator  may leverage the geometry shader  to facilitate the computation of the 2-dimensional bounding boxes of the rendered regions of the geometry primitives  during image rendering.","In various embodiment, a set of geometry primitives such as triangles , represented by {T, T, . . . T} may include vertices {V, V, V, . . . V, V, V,}, by which each V represents a point in a 3-dimensional world space. The vertex shader  and the pixel shader  may use a GPU to perform application-specified transformations and computations for rendering these triangles  into one or more rendering targets, which includes a rendering target R(image ). In various examples, the application specified transformations and computations may be dictated by screen animation requests of a gaming program, graphics editing software, video editing software, and the like. As described below, the screen extension information of the triangles  may also be computed in the same rendering pass in various embodiments.","In the same rendering pass, the bounding box calculator  may activate the vertex shader  and the pixel shader  to use the GPU to create a new rendering target R, where R={(x,y), (x,y), (x, y), (x, y) . . . (x,y)}. The new rendering target Rmay include six pixels whose screen coordinates, that is, coordinates in a 2-dimensional space, are (x,y) . . . (x,y). The rendering target Rmay be initialized to 0.0. It will be appreciated that in other embodiments, the bounding box calculator  may be configured to create a new rendering target Rthat includes more than six pixels. However, as further described below, since the screen extension information include six different bound values, (i.e., x, x, y, y, z, z), where each bound value may be computed based on a pixel, the bounding box calculator  generally does not use more than six pixels.","Following initialization, the bounding box calculator  may load the triangles  into the GPU for rendering by the vertex shader . In various embodiments, the vertex shader  may perform application-specified transformations and computations during the rendering for all vertices of triangles  {V, V, V, . . . VVV}. In such embodiments, the application-specified transformations may be the same transformations and computations performed for the rendering target R. This rendering by the vertex shader  may produce transformed vertices  {V\u2032, V\u2032, V\u2032, . . . V\u2032V\u2032V\u2032}, for a screen space, such as screen space . For example, the screen coordinates of the transformed vertex V\u2032, may be (x\u2032, y\u2032, z\u2032), whereby x\u2032and y\u2032may be the screen position of vertex V\u2032, and z\u2032may be the depth value of vertex V\u2032within [0.0, 1.0].","To continue the computation of the screen extension of the triangles , the bounding box calculator  may call the geometry shader  to generate six new points from each transformed triangle vertex . In at least one embodiment, for each transformed vertex V\u2032(x\u2032, y\u2032, z\u2032) in {V\u2032, V\u2032, V\u2032, . . . V\u2032V\u2032V\u2032}, the geometry shader  may generate six new points V\u2032(x, y, x\u2032), V\u2032(x, y, x-x\u2032), V\u2032(x, y, y\u2032), V\u2032(x, y, y-y\u2032), V\u2032(x, y, z\u2032), V\u2032(x, y, 1.0-z\u2032). Subsequently, each of the new points for each transformed triangle vertex  may be rendered by the geometry shader  to a corresponding pixel (e.g., a pixel of the six previously generated pixels) in the new rendering target Rin a one-to-one manner. The geometry shader  may accomplish this under the direction of the bounding box calculator .","As used in the generation of the six new points, xand y, may be large constant values. For example, in at least one embodiment, the width measurement of the rendering target Rmay serve as the value for x, while the height measurement of the rendering target Rmay serve as the value for y. The third-coordinate value (i.e., z-value or depth value) of each rendered pixel may be stored in a z-buffer.","Following rendering, each of the new points may be rasterized by the rasterizer  to its corresponding pixel in the rendering target R. Subsequently, the bounding box calculator  may compare a current (i.e., post-rasterization) third coordinate value of each pixel with the pixel's previous (i.e., pre-rasterization) third-coordinate value in the rendering target R. In at least one embodiment, the bounding box calculator  may access the previous third-coordinate value of each pixel from the z-buffer.","For each rendered pixel, if the current third-coordinate value of the pixel is larger than the previous third-coordinate value of the pixel, the bounding box calculator  may store the current third-coordinate value of the pixel in a corresponding array element of a z-buffer. Otherwise, the bounding box calculator  may ignore the current third-coordinate value of the pixel and keep the previous third-coordinate value in the corresponding array element in the z-buffer. In this way, from the final third-coordinate values stored in the array elements of the z-buffer, as represented by r, r, r, r, r, r, the bounding box calculator  may compute the screen extension information  for the triangles  as: x=r, x=x\u2212r, y=r, y=y\u2212r, z=r, and z=1.0\u2212r. In various embodiments, the screen extension information  may be used in a subsequent rendering of the rendering target R(image ), and\/or the rendering of the rendering target R(image ) with additional images (e.g., for collision detection, occlusion detection, and the elimination of redundant rendering).","Thus, by performing screen extension calculations during the rendering the geometry primitives  (e.g., triangles) into a finished image for display on a 2-dimensional screen space, the screen extension information  may be generated with the rendered image (i.e., rendering target R) in one rendering pass.","It will be appreciated the while the performance of a single-pass graphics rendering process that provides substituted Screen Extension Report (SER) functionality is discussed in the context of geometry primitives in the form of triangles, such performance may be further implemented using geometry primitives in the form of other polygons (e.g., rectangles, squares, etc.), as long as such polygons include at least three vertices. Moreover, while the performance of the rendering process is illustrated in  with a set of three geometry primitives (triangles), it will be appreciated that the actual performance of the single-pass graphics rendering process that provide the SER functionality may be implemented in a similar manner on sets that include any number of geometry primitives. Accordingly, the embodiments described herein are not intended to be limitations.","Exemplary Components",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 1"],"b":["200","204","100","200","200","204","200","202","206","206"]},"The graphics processing unit (GPU)  may be a dedicated graphics rendering device for processing 2-dimensional and\/or 3-dimensional graphics for display on a display interface (not shown) of the computer device . In various embodiments, the GPU  may be one of a GPU that includes dedicated hardware for executing the SER functionality, or a generic GPU that does not include the dedicated SER hardware.","The memory  may store program instructions. The program instructions, or modules, may include routines, programs, objects, components, and data structures that perform particular tasks or implement particular abstract data types. The selected program instructions may include the vertex shader module , the rasterizer , the pixel shader , the geometry shader module , the bounding box calculator , a bounding box calculator application program interface (API) module , a user interface module , and a data storage module . In turn, the bounding box calculator  may include a duplicate rendering component , a vertex transformation component , a point generation component , a point rendering component , a comparison component , and a bounding box computation component .","The vertex shader  may execute on the GPU . The vertex shader  may transform the 3-dimensional position for each vertex of geometry primitives in a 3-dimensional virtual space to 2-dimensional coordinates of screen space.","The rasterizer  may execute on the GPU . The rasterizer  may fill the geometry primitives (e.g., triangles) with pixels after the geometry primitives have been processed by a vertex shader.","The pixel shader module pixel shader  may execute on the GPU . The pixel shader may calculate and provide color to the individual pixels that make up the geometry primitives (e.g., triangles) to generate rendered images, such as images  ().","The geometry shader  may execute on the GPU . The geometry shader  may add and remove vertices for the geometry primitives, as well as provide volumetric details to the geometry primitives.","The bounding box calculator module  may execute on the GPU . For example, the duplicate rendering component  of the bounding box calculator module  may command the vertex shader  to render a target, such as target R, which includes at least six pixels. The vertex transformation component  may command the vertex shader  to produce transformed vertices, such as transformed vertices , for the vertices of geometry primitives. The point generation component  may command the geometry shader  to generate points for vertices, such as the transformed vertices . The point rendering component  may command the geometry shader  to render the points generated by the point generation component  with the pixels generated by the duplicate rendering component . The point rendering component  may also store the initial (i.e., pre-rasterization) third coordinate value of each pixel in memory , such as in a z-buffer. Likewise, the point rasterization component  may command the geometry shader  to rasterize the points generated by the point generation component  with the pixels generated by the duplicate rendering component . The point rasterization component  may also store the post-rasterization) third coordinate value of each pixel in memory , such as in the z-buffer.","The comparison module  of the bounding box calculator module  may compare the pre-rasterization third coordinate value of each pixel with its post-rasterization third coordinate value to determine the greater of the two values, and retain or store the value in the memory , such as in the z-buffer. The computation component  may enable the calculation of 2-dimensional bounding box information from the third coordinate values stored in the memory .","The bounding box calculator application program interface (API) module  may be called by a software application to activate the bounding box calculator . In this way, the software application may use the bounding box calculator  to implement the SER-equivalent bounding box calculation functionality during the rendering of the geometry primitives into a 2-dimensional screen space. Thus, the calculation of 2-dimensional bounding boxes of the rendered regions of the geometry primitives may be performed in the same pass as the rendering of an image from the geometry primitives.","In various embodiments, the bounding box calculator API module  may enable software applications to leverage the bounding box calculator  to perform a single-pass image rendering. The single-pass image rendering configured to calculate SER-equivalent bounding box information using a generic GPU . Such single pass image rendering and SER information calculation may take place of multiple-pass processes and\/or shifting the SER calculations to the CPU . In other embodiments where the GPU  includes dedicated SER hardware, the bounding box calculator API module  may enable a software application to selectively perform at least some SER information calculation without using the dedicated SER hardware, such as in instances of hardware malfunction. The bounding box calculator API module  may also serve as an interface to provide software applications with the 2-dimensional bounding box information for a set of geometry primitives.","The user interface module  may interact with a user via a user interface (not shown). The user interface may include a data output device such as a display, and one or more data input devices. The data input devices may include, but are not limited to, combinations of one or more of keypads, keyboards, mouse devices, touch screens, microphones, speech recognition packages, and any other suitable devices or other electronic\/software selection methods.","The user interface module  may be configured to enable a user to activate or disable the bounding box calculator . For example, the user interface module  may enable a user to selectively disable the bounding box calculator  so that the SER calculations are performed in multiple passes by the generic GPU , or by the CPU . Additionally, the user interface module  may be further configured to cause the display to output the current status of the bounding box calculator , (e.g., active, disabled, error, etc.) to the user.","The data storage module  may be configured to store data in a portion of memory  (e.g., a database). In various embodiments, the data storage module  may be configured to store the SER-equivalent bounding box information produced by the bounding box calculator , as well as any intermediary data produced by bounding box calculator  during SER-equivalent bounding box calculations. The data storage module  may also include a z-buffer. It will be appreciated that the z-buffer is generally configured to store the depth of a generated pixel (third-coordinate value). The z-buffer is usually arranged as a two-dimensional array (e.g., x-y) with one element for each pixel, where each element in the array may be continuously updated with a current third-coordinate value of the pixel.","Exemplary Process",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 3","FIG. 3","FIG. 2"],"b":["300","300","200"]},"At block , the vertex shader  and the pixel shader  may use a graphics processing unit (GPU) to perform application-specified transformations and computations for rendering geometry primitives (e.g., triangles) into one or more rendering target images in a 2-dimensional screen space, the one or more rendering target images may include a first rendering target R().","At block , the bounding box calculator  may activate the vertex shader  and the pixel shader  to use the GPU to create a second rendering target image that includes six pixels. The second rendering target image may be the rendering target R(). In various embodiments, the second rendering target image may contain six pixels whose screen coordinates, that is, coordinates in a 2-dimensional space, are (x,y) . . . (x,y). In such embodiments, the second rendering target may be initialized to 0.0.","At block , the bounding box calculator  may activate the vertex shader  to produce transformed vertices for the 2-dimensional screen space based on the geometry primitives. In various embodiments, the vertex shader  may produce the transformed vertices by performing the same transformations and computations as is performed at block .","At block , the bound box calculator  may use the geometry shader  to generate six new points from each transformed vertex of each geometry primitive (e.g. triangle).","At block , the bounding box calculator  may use the geometry shader  to render each of the new points of each transformed vertex to a corresponding pixel (e.g., a pixel of the six previously generated pixels) in the second rendering target image. In various embodiments, the rendering of each of the new points of each transformed vertex to a corresponding pixel may be done in a one-to-one manner. In other words, as illustrated in , for each transformed vertex, each new point is rendered to one unique pixel from the six previously generated pixels. The third-coordinate value (i.e., z-value or depth value) of each rendered pixel may then be stored in an array element of a z-buffer.","At block , the bounding box calculator  may activate the rasterizer  to rasterize the new points (as from all the transformed vertices) rendered to each pixel with each pixel. It will be appreciated that rasterization may result in a change of the third coordinate value of each pixel.","At block , the bounding box calculator  may compare the pre-rasterization third coordinate value of a pixel, as from block , with the post-rasterization third coordinate value of the pixel, as from the block .","At decision block , the bound box calculator  may determine whether the post-rasterization third coordinate value of the pixel is greater than the pre-rasterization third coordinate value. If the post-rasterization third coordinate value of the pixel is greater than the pre-rasterization coordinate value of the pixel, (\u201cyes\u201d at decision block ), the process  may proceed to block .","At block , the bounding box calculator  may store the post-rasterization third coordinate value into the array element in the z-buffer that stored the pre-rasterization third coordinate value for the pixel. In other words, the pre-rasterization third-coordinate value of the pixel in the z-buffer is replaced by the post-rasterization value of the pixel.","Returning to block , if the bounding box calculator  determines that the post-rasterization third coordinate value of the pixel is not greater than the pre-rasterization coordinate value of the pixel, (\u201cno\u201d at decision block ), the process  may proceed to block .","At block , the bounding box calculator  may ignore the post-rasterization third coordinate value of the pixel and retain the pre-rasterization third coordinate value in the z-buffer array element for the pixel.","At decision block , the bounding box calculator  may determine whether the pre-rasterization vs. post-rasterization third coordinate value comparison is to be performed for one or more additional pixels. In other words, the bounding box calculator  may determine whether the comparison has been implemented for all of the at least six pixels. If the bounding box calculator  determines that the comparison may be performed for additional pixels, (\u201cyes\u201d at decision block ), the process  may loop back to block . The loop may be repeated until the pre-rasterization vs. post-rasterization third coordinate value comparison has been implemented for all of the at least pixels.","However, if the bounding box calculator  determines that the pre-rasterization vs. post-rasterization third coordinate value comparisons have been performed for all of the at least six pixels (\u201cno\u201d at decision block ), the process  may proceed to block .","At block , the bounding box calculator  may compute the bound box information based on the third coordinate values of the pixels stored in the z-buffer. As described above, in embodiments where the third coordinate values may be represented by r, r, r, r, r, r, the bounding box calculator  may compute the 2-dimensional bounding box information for the geometry primitives as: x=r, x=x\u2212r, y=r, y=y\u2212r, z=r, and z=1.0\u2212r.","At block , the computed bounding box information may be provided for use (e.g., for collision detection, occlusion detection, and the elimination of redundant rendering). In various embodiments, the computed bounding box information may be at least one of displayed, provide to an application, saved in a data storage, or inputted back into the vertex shader , rasterizer , and\/or the pixel shader  for rendering additional images.","It will be appreciated that blocks  through  may be implemented in the same processing pass as block . Thus, processing overhead may be reduced and processing efficiency increased.","Exemplary Computing Environment",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 4","FIG. 2","FIG. 4"],"b":["400","200","400","400","400"]},"In a very basic configuration, computing system  typically includes at least one processing unit , a graphics process unit (GPU) , and system memory . Depending on the exact configuration and type of computing device, system memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. System memory  typically includes an operating system , one or more program modules , and may include program data . The operating system  includes a component-based framework  that supports components (including properties and events), objects, inheritance, polymorphism, reflection, and provides an object-oriented component-based application programming interface (API), such as, but by no means limited to, that of the .NET\u2122 Framework manufactured by the Microsoft Corporation, Redmond, Wash. The device  is of a very basic configuration demarcated by a dashed line . Again, a terminal may have fewer components but will interact with a computing device that may have such a basic configuration.","Computing system  may have additional features or functionality. For example, computing system  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing system . Any such computer storage media may be part of device . Computing system  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well known in the art and are not discussed at length here.","Computing system  may also contain communication connections  that allow the device to communicate with other computing devices , such as over a network. These networks may include wired networks as well as wireless networks. Communication connections  are some examples of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, etc.","It is appreciated that the illustrated computing system  is only one example of a suitable device and is not intended to suggest any limitation as to the scope of use or functionality of the various embodiments described. Other well-known computing devices, systems, environments and\/or configurations that may be suitable for use with the embodiments include, but are not limited to personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-base systems, set top boxes, game consoles, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and\/or the like.","The performance of the SER-equivalent bounding box calculations as part of a single-pass graphics rendering process on a generic GPU, rather than an independent processing pass, may increase processing efficiency by reducing processing overhead. Alternatively, the performance of the SER-equivalent bounding box calculations as part of a single-pass graphics rending process may reduce or eliminate the need to burden a central processing unit (CPU) with the SER computations during graphics processing by a generic GPU. Thus, embodiments in accordance with this disclosure may improve the efficiency of image processing and rendering on the generic GPU.","Conclusion","In closing, although the various embodiments have been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended representations is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed subject matter."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is includes references to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The use of the same reference number in different figures indicates similar or identical items.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
