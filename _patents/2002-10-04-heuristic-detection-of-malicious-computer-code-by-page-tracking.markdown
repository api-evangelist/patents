---
title: Heuristic detection of malicious computer code by page tracking
abstract: To detect a computer virus in a host file (), an emulating module () emulates the host file () in a virtual machine () having a virtual memory (). While emulating the host file (), the system () tracks the host file's access of the virtual memory (). Responsive to an access in a non-normal address range of the virtual memory () by the host file (), a flag recording module () sets a flag. A virus reporting module () declares a potential virus based on whether the flag is set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07418729&OS=07418729&RS=07418729
owner: Symantec Corporation
number: 07418729
owner_city: Cupertino
owner_country: US
publication_date: 20021004
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND ART","DISCLOSURE OF INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"p":["This application claims the priority benefit under 35 U.S.C. \u00a7 119(e) of commonly owned U.S. Provisional Patent Application Ser. No. 60\/397,159, filed Jul. 19, 2002, which patent application is hereby incorporated in its entirety by reference into the present patent application.","This invention pertains to the field of detecting malicious code in computer systems, and in particular to detecting malicious code using a dynamic heuristic based on tracking access to suspicious pages or portions of a memory.","In May of 2002, the number of known 32-bit Windows viruses and worms exceeded 2000. Computer viruses, worms, and Trojan horses are types of \u201cmalicious code,\u201d which is herein defined as any computer program, module, set of modules, or code that enters a computer system without an authorized user's knowledge and\/or without an authorized user's consent. In particular, a computer worm is malicious code that has the ability to replicate itself from one computer to another, e.g., over a computer network. Although the major problem for today's users is computer worms, simple file infector viruses persist and remain a challenge for anti-virus software. Distinguished from worms, computer viruses are characterized in that they typically attach to and\/or modify a host program, which may be an executable, a dynamically linked library (DLL), or another kind of application. Examples of such viruses include the virus families W32. FunLove, W32. Bolzano, and W32. Coke.","To operate, malicious code usually has to call system APIs (application programming interfaces) from system libraries, such as KERNEL32. DLL in 32-bit WINDOWS systems. Normal computer programs access system APIs by static linking, which builds a proper import address table, or by calling the GetProcAddress( ) API to obtain dynamically the address of a particular API. An application that uses the GetProcAddress( ) API typically needs to have a static import to call that API. The static import for the GetProcAddress( ) API is located in the application's import address table, which thereby allows the application to call by name any APIs that are to be exported. Malicious code cannot typically call APIs like normal applications because malicious code typically does not have its own imports.","Accordingly, calling system APIs can be a challenge for writers of malicious code. For example, the Win95\/Boza virus often failed to infect files as intended because it used hard-coded addresses to call particular system APIs more easily. Because API addresses often vary from one operating system (OS) to the next\u2014and even among different releases of the same OS\u2014malicious code that uses hard-coded API addresses does not spread well on different systems. To solve this problem, writers of malicious code have implemented functions for locating system APIs that are similar in their implementation to GetProcAddress( ). For example, the Win95\/Marburg and Win32\/Cabanas.A viruses both used a trick that has become a new standard in virus development. These viruses have a function that locates the address of each API they need to call under all Win32 systems. While a challenge for virus writers, this need to call system APIs can be exploited by writers of anti-virus tools.","The article, Sz\u00f6r, P\u00e9ter, \u201cAttacks on Win32, October 1998, England, explains how heuristic analysis is helpful for detecting infections by malicious code. Heuristics are usually based on certain characteristics that distinguish malicious code from normal code, such as the malicious code's need to call system APIs as described above. One heuristic suggested in the \u201cAttacks on Win32\u201d article is to search for code in a target file that uses the KERNEL32 address directly and looks for the text string \u201cPE00\u201d. This heuristic is premised on the idea that accessing the KERNEL32 library and searching for \u201cPE00\u201d is one way that malicious code can locate system APIs without having those addresses hard-coded, whereas normal applications do not need to perform this task because they have an import table. This technique is called a static heuristic because it is performed by scanning a particular file for certain structure characteristics common to particular types of malicious code. Static heuristic techniques have been extremely successful against early file viruses and other malicious code, and these heuristics continue to be useful against many species of malicious code today.","But programmers of malicious code are increasingly employing anti-heuristic techniques to hide the identifying features of malicious code infection in a file's structure. Many of these anti-heuristic techniques implement the same suspicious activity in different ways to obscure that activity from static heuristics techniques. For example, the static heuristic explained above could be defeated by encrypting the portion of the malicious code that looks for the text string \u201cPE00\u201d. Sz\u00f6r, P\u00e9ter, \u201cAttacks on Win32\u2014Part II,\u201d , September 2000, England, describes a variety of other anti-heuristic techniques used by malicious code to avoid detection by static heuristics. Accordingly, anti-virus software tools often employ emulation, in which a file is executed in an emulated environment. In this way, the anti-virus software can use heuristics that are based on actions that the executed file takes in the simulation, thus defeating the efforts of writers of malicious code to obscure the structure of their malicious code. Such techniques are referred to as dynamic heuristics. \u201cAttacks on Win32 II\u201d also describes various attacks by malicious code on computer systems, as well as static and dynamic heuristics and other techniques for detecting malicious code.","Apart from heuristics, the \u201cAttacks on Win32 II\u201d article additionally explains some of the incompatibility problems that caused older 32-bit viruses to fail to work on newer WINDOWS 2000 systems. For example, several 32-bit viruses call system APIs by searching for the loaded KERNEL32. DLL (and thus the APIs therein), and looking for the text \u201cMZ\u201d or \u201cPE\u201d within particular process address spaces. Because different versions and releases of WINDOWS use different base addresses for system libraries such as KERNEL32. DLL, viruses written for one release or type of OS will often fail to work on a different one. Viruses such as the WIN32\/Cabana family do not pay attention to the moving DLL base address, and thus fail on some systems when attempting to locate the loaded system libraries. This paper, however, failed to recognize that incompatibility problems such as this one could themselves be used as a heuristic for detecting various types of malicious code.","As writers continue to develop malicious code, the need persists for additional reliable heuristics to detect computer viruses and other malicious code without generating a significant number of false positives.","The present invention comprises methods, apparati, and computer program products for detecting malicious code in a host file (). In an embodiment of the invention, an emulating module () emulates the host file () in a virtual machine () having a virtual memory (). While emulating the host file (), the system () tracks the host file's access of the virtual memory (). Responsive to an access in a non-normal address range of the virtual memory () by the host file (), a flag recording module () sets a flag. A virus reporting module () declares a potential malicious code based on whether the flag is set. This technique can be used with additional heuristics for detecting a computer virus and other malicious code.","Malicious code typically infects a host file by attaching or altering code at or near an \u201centry point\u201d of the file. An entry point is any instruction or set of instructions in the file, a pointer to an instruction or set of instructions, or other data in the file that malicious code can modify to gain control of the computer system at which the file is located. An entry point is typically identified by an offset from some arbitrary point in the file. Certain entry points are located at the beginning of a file or region and, therefore, are always invoked when the file or region is executed. For example, an entry point can be the first instruction executed when the host file is executed or when a function within the file is called. Other possible entry points are single instructions deep within the file that can be modified by malicious code. For example, the entry point can be a CALL or JMP instruction that is modified to invoke the malicious code. Once malicious code seizes control of the computer system through the entry point, the malicious code typically infects other files on the system and\/or other systems networked with the host system.","Although the present invention can be applied to detect any type of malicious code, an embodiment of the invention is described in the context of detecting a computer virus. However, persons skilled in the art can appreciate that the invention can be used to detect any type of malicious code, such as computer worms, that is susceptible to the heuristic described herein.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","100","100"]},"The file  is divided into sections containing either code or data and aligned along four-kilobyte (kB) boundaries. The MS-DOS section  contains the MS-DOS header and is marked by the characters \u201cMZ.\u201d This section  contains a small executable program  designed to display an error message if the executable file is run in an unsupported OS (e.g., MS-DOS). This program  is an entry point for the file . The MS-DOS section  also contains a field  holding the relative offset to the start  of the PE header section . This field  is another entry point for the file .","The PE header section  is marked by the characters \u201cPE\u201d and holds a data structure  containing basic information about the file . The data structure  holds many data fields describing various aspects of the file .","Section  holds the section table , which contains information about each section in the file , including the section's type, size, and location in the file . For example, entries in the section table  indicate whether a section holds code or data, and whether the section is readable, writeable, and\/or executable. Each entry in the section table  describes a section that may have a single entry point, multiple entry points, or no entry points.","The text section  holds executable code produced by the compiler or assembler. The data section  holds global and static variables that are initialized at compile time. There can be more than one text section  and\/or more than one data  in the file .","The export section  contains an export table  that identifies functions exported by the file  for use by other programs. An EXE file might not export any functions, while DLL files typically export some functions. The export table  holds the function names, entry point addresses, and export ordinal values for the exported functions. The entry point addresses typically point to other sections in the file . Each exported function listed in the export table  is an entry point into the file .","The import section  has an import table  that identifies functions that are imported by the file . Each entry in the import table  identifies the external DLL and the imported function by name. When code in the text section  calls a function in another module, such as an external DLL file, the call instruction transfers control to a JMP instruction also in the text section . The JMP instruction, in turn, directs the call to a location within the import table . Both the JMP instruction and the entries in the import table  represent entry points into the file .","To operate, a computer virus typically needs to call certain system API functions, such as FileOpen( ) and FileDelete( ). Unlike the file  itself, a typical virus cannot use the import table  to call these API functions, because the virus infects the file  after the import table  is made. Accordingly, viruses often solve this problem by searching the headers of certain system DLLs\u2014such as the KERNEL32. DLL in WINDOWS95\u2014to obtain the addresses for the API functions that the virus needs to call. This action is suspicious because a normal file  does not need to access these non-normal locations in the memory because the file  has an import table . As used herein, a \u201cnon-normal\u201d memory location is any part of the memory that a normal application does not typically access, such as headers and other sections that do not contain executable code. Accordingly, access to that memory location is suspicious as indicating the presence of malicious code. As used herein, \u201caccess\u201d refers to any read or write operations to a memory. The present invention uses this concept to provide a heuristic for detecting file infector viruses and any other malicious code that accesses suspicious locations in the memory.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2","b":["200","100","400","202","204","204","206","208","210","212","214","216","218","212"]},"The processor  may be any general-purpose processor, such as an INTEL x86, a SUN MICROSYSTEMS SPARC, or a POWERPC-compatible CPU. As is known in the art, the processor  has multiple registers that are used to hold instructions, data, addresses, and other information. The storage device  may be any device capable of holding data, like a hard drive, compact disk read-only memory (CD-ROM), DVD, or a solid-state memory device. As is known in the art, the storage device  typically holds multiple files of different types, including potential virus host files like that described by . The memory  holds instructions and data used by the processor . The pointing device  may be a mouse, track ball, or other type of pointing device, and is used in combination with the keyboard  to input data into the computer system . The graphics adapter  displays images and other information on the display . The network adapter  couples the computer system  to a local or wide area network.","As is known in the art, the computer system  is adapted to execute computer program modules for providing functionality described herein. As used herein, the term \u201cmodule\u201d refers to computer program logic and\/or any hardware or circuitry utilized to provide the specified functionality. Thus, a module can be implemented in hardware, firmware, software, or any combination thereof. Preferably, program modules providing the functionality of the VDS  are stored on the storage device .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["310","200","200"]},"The virus identifies  a new host file  to infect. For example, the virus may search for files matching the string \u201c*.EXE\u201d to identify new host file candidates. The virus then filters the candidate files to identify  a particular new host file . The files may be filtered based for example on the files' sizes, names, types, and\/or whether the files are already infected by the virus.","The virus inserts  its viral code into the new host file . For example, the virus can append the viral body to the slack space at the end of a section or put the viral body within an entirely new section. During this step , the virus uses one or more techniques to modify its current viral code to produce new viral code, which it then inserts into the file . The techniques the virus can use to modify its code include inserting and\/or removing jump (\u201cJMP\u201d) and no-operation (\u201cNOP\u201d) instructions; substituting varying sets of equivalent instructions for performing certain tasks, such as register subtractions or zeroing; and substituting the registers used by certain instructions.","The virus typically modifies  the section table  in the host file  to account for the added viral code. For example, the virus may change the size entry in the section table  to account for the added viral code. Likewise, the virus may add entries for new sections added by the virus. If necessary, the virus may mark an infected section as executable and\/or place a value in a little-used field to discreetly mark the file  as infected and prevent the virus from re-infecting the file .","In addition, the virus typically also alters  an entry point of the host file  to call the viral code. The virus may accomplish this step by, for example, overwriting the value in the field  holding the relative offset to the start  of the PE section , with the relative offset to virus code stored elsewhere in the file. Alternatively, the virus can modify entries in the export table  to point to sections of virus code instead of the exported functions. A virus can also modify the destination of an existing JMP or CALL instruction anywhere in the file  to point to the location of viral code elsewhere in the file , effectively turning the modified instruction into a new entry point for the virus.","A particularly sophisticated virus can use very complex techniques for infecting the host file  that differ in some respects from the ones described above. For example, one sophisticated virus includes a disassembly engine in its viral body and uses it to disassemble the host file  into its smallest elements. Then, the virus infects the dissembled host file  by moving code blocks to clear space for the viral code, inserting its modified viral body, regenerating code and data references, including relocation information, and then rebuilding the file . Another sophisticated virus detects whether a compiler is present on the host computer system . If a compiler is present, the virus uses it to recompile a slightly modified version of the virus's source code and thereby generate a completely new viral body. Then, the virus inserts the new viral body into the host file . Other viruses can use techniques in addition to, or instead of, the ones described herein to modify the viral bodies and insert the bodies into host files.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIG. 4"],"b":["400","100","200","400"]},"The VDS  includes a P-code data module , an engine module , an emulating module , and a virus database module . The P-code data module  preferably holds P-code instruction modules for controlling the operation of the VDS  to detect the presence of a virus. As used herein, \u201cP-code\u201d refers to program code for providing data-driven functionality to the VDS . Preferably, a virus researcher creates the P-code instructions in the data module  by writing instructions in any computer language and then compiling the instructions into P-code. In addition, the functionality of the P-code can be replaced by other data-driven techniques. For example, the program code can be stored in a representation other than P-code or a state machine can be utilized in combination with, or as an alternative to, the P-code to provide deterministic data-driven virus detection.","One embodiment of the present invention uses data-driven techniques to control the operation of the VDS  because such techniques allow the functionality of the VDS to be updated by updating the P-code and\/or other data. For example, the VDS  can be updated to detect new viruses by updating the P-code instead of the other modules. Accordingly, the use of data-driven techniques simplifies the task of updating thousands or millions of VDSs  that are installed on computer systems \u201cin the field.\u201d However, alternate embodiments of the present invention implement the described functionality through non-data-driven techniques.","The engine module  preferably controls the operation of the VDS  in response to the P-code in the P-code data module . The engine  preferably contains a P-code interpreter  for interpreting the P-code, which in turn controls the operation of the engine . In alternative embodiments where the data module  holds instructions in a format other than P-code, the engine  is equipped with a module for interpreting or compiling the instructions in the relevant format.","The P-code interpreter  preferably includes special P-code function calls called \u201cprimitives\u201d . The primitives  can be, for example, written in P-code or a native language, and\/or integrated into the interpreter  itself. Primitives  are essentially functions useful for examining the host file  and virtual machine  that can be called by other P-code. For example, the primitives  perform functions such as opening files for reading, closing files, zeroing out memory locations, truncating memory locations, locating exports in the file, determining the type of the file, and finding the offset of the start of a function. The functions performed by the primitives  can vary depending upon the computer or operating system in which the VDS  is being used. For example, different primitives may be utilized in a computer system running the MACINTOSH operating system than in a computer system running a version of the WINDOWS operating system. In an alternative embodiment, some or all of the primitives can be stored in the P-code data module  instead of the interpreter .","The emulating module  is preferably adapted to execute computer program instructions in the host file  in a virtual machine  under the direction of the engine module . The emulating module  includes a control program (CP) module  for setting up a virtual machine  having a virtual processor , a virtual memory , and a set of virtual registers  (typically part of the virtual processor). The virtual machine  emulates a 32-bit MICROSOFT WINDOWS environment, an APPLE MACINTOSH environment, or any other hardware and\/or software environment for which emulation is desired. The virtual machine  uses the virtual processor  to execute the instructions in the virtual memory  in isolation from the actual hardware and software on the computer system . Therefore, the malicious code executed by the emulating module  cannot contaminate the computer system .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 5","FIG. 5"],"b":["410","410"]},"A file selection module  preferably contains P-code for selecting a potential host file  on the computer system  to examine for the presence of a virus. In general, the file selection module  preferably filters the files on the computer system  to select only files that are susceptible to infection by a virus. In one embodiment, the file selection module  performs one or more tests on each file, and only those files that pass each test are designated \u201csusceptible to infection by a virus.\u201d The tests can include, for example, determining whether the file contains executable instructions (e.g., whether the file has a \u201c.EXE\u201d or \u201c.DLL\u201d extension), whether the file is a PE file, whether the file contains a marker that is consistent with infection by a known virus, whether the size of the file is suspicious, and whether the internal characteristics of the file indicate a possible viral infection.","In one embodiment, other modules in the VDS  are adapted to identify files on the computer system  and use the file selection module  to determine whether the file is susceptible to infection. For example, the other modules may be configured to detect when a file  on the storage device  is accessed and then activate the file selection module  to process the file . In another example, the other modules may be configured to search recursively for files on the storage device  and utilize the file selection module  to examine each encountered file . In another embodiment, the functionality described in these two examples is provided by the file selection module  itself.","The P-code data module  preferably includes an emulation control module . This module  preferably contains code for identifying and selecting potential virus entry points in the file  and emulating instructions in the file  at each selected point. Although one embodiment of the emulation control module  selects only certain locations in the file  as potential entry points, another embodiment of the module  treats every instruction in the file , or every instruction within certain regions of the file , as potential entry points. The emulation control module  accesses the virus database module  to determine the parameters for the emulations and interacts with the control program  in the emulating module  to perform the emulations according to the parameters. In one embodiment, the emulation control module  holds the emulation parameters instead of the virus database .","The P-code data module  also preferably includes a flag recorder module . This module  preferably contains code for setting one or more flags in response to the access of suspicious address ranges in the memory  by the emulated program. The address range or ranges to track are preferably stored in the virus database , although other embodiments of the present invention may use other techniques to specify the address ranges. The VDS  preferably stores the flags in the emulation module  or another location in the computer system  where the flags are accessible to the modules in the VDS . Depending on the desired heuristic, the flag recorder module  may be adapted to set a separate flag associated with different suspicious memory address ranges.","The P-code data module  also preferably includes a breakpoint condition module . This module  preferably specifies breakpoints and other stopping conditions for the emulation. Preferably, the emulation control module  uses the breakpoint condition module  to stop the emulation at certain points. In one embodiment, the breakpoint condition module  specifies a number of instructions that should be emulated before stopping. Preferably, the breakpoints are configured to stop emulation after relatively few instructions. For example, in one embodiment a breakpoint stops emulation after 50 to 500 instructions. In contrast, typical emulation-based virus detection software may emulate over one million instructions before reaching a breakpoint. In another embodiment, the breakpoint condition module  specifies a virtual machine state at which emulation should stop. In yet another embodiment, the module  specifies a combination of factors for determining whether to stop emulation. For example, the breakpoint condition module  can specify that emulation should stop if one or more flags have been set by the flag recorder module . In another example, the breakpoint condition module  can specify that a breakpoint should occur every  instructions, until the total number of emulated instructions exceeds a specified maximum. The breakpoint condition module  may also store separate breakpoint conditions for certain host files and\/or viruses and also a default breakpoint condition.","The P-code data module  also preferably includes a virus reporting module  storing code for detecting the presence of a virus in the file . Preferably, the virus reporting module  whether one or more flags have been set by the flag recorder module . If the virus reporting module  determines that one or more flags were set, the module  preferably reports a probable virus detection to the VDS . In response, other modules in the VDS  preferably perform actions such as notifying the computer user of the virus, quarantining the file , attempting to repair the infected file  and\/or computer system, and performing additional heuristics. If the virus reporting module  determines that no flags or an insufficient number of flags have been set, the module preferably reports this result to the VDS .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6","b":["400","400","410"]},"The VDS  examines the files on the computer system  to identify those files that are susceptible to infection by a virus. Preferably, the VDS  selects  a single file  for further examination. Alternatively, the VDS  receives a reference to a file from another module executing on the computer system  and subjects this file  to further examination.","The VDS  examines the selected file  to identify  potential entry points for a virus. As described above, there are many locations in the file  that viruses can exploit as entry points. The VDS  selects one of the entry points and emulates  the instructions at that entry point according to the specified emulation parameters. While emulating  the selected file , the VDS  tracks  access to suspicious address ranges in the virtual memory . The VDS  continues to emulate  the instructions and track  page access until the emulation reaches a breakpoint. The process of emulating the instructions in the file and tracking page access is referred to herein as \u201ctracing\u201d or \u201cmicro-tracing.\u201d","If  the VDS  detects a virus, as indicated by one or more flags having been set by the flag recorder module , the VDS  preferably responds  to the virus by notifying the computer user, cleaning the file , or continuing to run additional heuristics. Depending upon the breakpoint, the VDS  may resume the micro-trace of the entry point if it does not detect a virus. For example, the VDS  may resume the micro-trace if it has emulated only  instructions and the breakpoint specifies that a break should occur every 100 instructions until a maximum of 1000 instructions are emulated.","If the VDS  finishes emulating  from entry point and it does not detect a virus, the VDS  determines  whether there are more potential entry points in the selected file  to micro-trace. If so, the VDS  begins  a new micro-trace at the next potential entry point. When the VDS  has micro-traced all of the potential entry points without detecting a virus, it determines  whether there are more files to check for viruses. If there are more files, the VDS  selects another file and repeats the virus detection process described above. If there are no more files, the VDS  completes  operation.","In sum, an infected program is likely to attempt to access suspicious, non-normal address ranges in the memory. The present invention uses this property as a dynamic heuristic to detect the presence of such viruses by micro-tracing portions of potential virus host files and tracking their access to certain pages in the virtual memory. As a result, the present invention can detect viruses that may be undetectable with other means, such as pattern matching and other static heuristic techniques.","The above description is included to illustrate the operation of various embodiments of the invention and is not meant to limit the scope of the invention. The scope of the invention is to be limited only by the following claims. From the above discussion, many variations will be apparent to one skilled in the art that would yet be encompassed by the spirit and scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other more detailed and specific objects and features of the present invention are more fully disclosed in the following specification, reference being had to the accompany drawings, in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2","b":["200","400"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3","b":"100"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4","b":"400"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5","b":["410","400"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6","b":"400"}]},"DETDESC":[{},{}]}
