---
title: Modularizing and aspectizing graphical user interface directed test scripts
abstract: A test structure for testing graphical user interface applications (GAPs) modularizes test scripts by separating statements that define GAP test logic from statements that navigate to GAP objects. Composition rules weave the statements together to generate the test scripts that are executed to test the GAP. Because the test structure is modular, test logic can be reused across different GAPs and different versions of the same GAP. Reusing test logic is not only an efficient practice from a test engineer's point of view, but also leads to a reduction in test programming errors. The modular test structure also facilitates the efficient modification of test scripts to account for modifications in the underlying GAPs, greatly reducing the time, cost, and resource expenditures needed to arrive at updated test scripts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08370811&OS=08370811&RS=08370811
owner: Accenture Global Services Limited
number: 08370811
owner_city: Dublin
owner_country: IE
publication_date: 20090716
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Technical Field","This disclosure relates to testing graphical user interface (GUI) applications using test scripts, and in particular relates to systems and methods for creating test scripts that are reusable and\/or adaptable for testing different GUI applications and\/or different versions of GUI applications.","2. Related Art","The relentless pace of advancing technology has given rise to complex computer software applications that help automate almost every aspect of day-to-day existence. Today, applications exist to assist with writing novels to filing income tax returns to analyzing historical trends in baby names. One nearly ubiquitous feature of these applications is that they employ graphical user interfaces (GUIs). GUIs implement graphical windows, pointers, icons, and other features through which users interact with the underlying program. A program implemented with GUIs is referred to as a GUI application (GAP). GAPs require thorough testing prior to release.","In the past it has been easier to implement the GUI to the application than to thoroughly test the GAP. For GAPs of any significant complexity, the permutations and combinations of GUI elements gives rise to an enormous field of potential commands and command sequences that could have bugs of any severity, from insignificant to critical failure. Thus, GAPs must be thoroughly tested to ensure that the GUIs interact with the user as intended. Manually testing large-scale enterprise GAPs is tedious, error prone, and laborious. As an alternative to manual testing, test engineers develop test scripts to automate GAP testing.","Test scripts include navigation statements and logic statements. The navigation statements access and manipulate or retrieve properties of GUI objects, while the logic statements determine whether the GAP is functioning as intended. When executed, these test scripts drive the GAPs through different states by mimicking the activity of users interacting with the GAPs by performing actions on the GUI objects. Test scripts process input data, set values of GUI objects using the data, act on the GUI objects to cause the GAP to perform computations, access other GUI objects to retrieve computation results, and compare the outcome with the expected results. Many different test scripts must be written to test the different GUIs and functions of a GAP. As an example, testing a travel reservation GAP will require different test scripts to test the different GUI objects that are displayed as a user navigates through the GAP to book the departure flight, reserve a hotel and\/or automobile, book the return flight, and make other travel arrangements. One test script may determine whether the GAP displays correct return date options in response to a user selecting a specific departure flight, while another test script may determine whether the hotel reservation dates are correct in response to the same user selection. To thoroughly test the travel reservation GAP, many more test scripts must be written.","Although determining whether correct dates are displayed is a ubiquitous test applicable to many different types of GAPs, test scripts (e.g., the travel reservation test scripts) are not transportable to test other types of GAPs because the logic statements are intertwined with the GAP-dependent navigation statements in order to access and test the GUI objects within the GAP. Also, test scripts are difficult to update when GAPs are modified (i.e., different versions of the same GAP) because the navigation statements that must be rewritten are scattered among many different test scripts. Test engineers have found that test scripts are not easily transportable even between different versions of the same GAP and in most cases prefer writing new test scripts from scratch over modifying existing test scripts.","There are additional obstacles to generating test scripts that are transportable across different GAPs or different versions of the same GAP. In one method of generating test scripts, capture\/replay tools are used to record mouse coordinates and user actions. However, because capture\/replay tools use mouse coordinates, changing the GUI layout, even slightly, will usually render the test scripts ineffective. Another method of generating test scripts, referred to as \u201ctesting with object maps,\u201d captures the values of properties of GUI objects (rather than just the mouse coordinates). Test engineers assign unique names to collections of the values of the properties of the GUI objects, and then use the names in test script statements to reference the objects. In theory, changes to a GUI layout can be accounted for by modifying the values of the properties of the GUI objects, which are usually stored in an object repository. However, updating GUI tests that are based on object maps is difficult, if not prohibitive, when even small changes to a GUI are made because of the interdependencies explained below.","Navigation And Manipulation Expressions (NAMEs) are the expressions used in test scripts to navigate to GUI objects, set or retrieve the values of the GUI objects, or act on them. NAMEs include application programming interface (API) calls having objects that hold the values of the properties of the GUI objects being tested. Different testing frameworks export different API calls to access and manipulate the GUI objects. Thus, NAMEs are dependent on the GUI object type (e.g., list box, text box, etc.), the location of the object on the screen, and the underlying GUI testing framework. Because NAMEs reference GUI objects by their properties, even the slightest change to a GUI object can invalidate all NAMEs within test scripts that reference the GUI object. For example, changing a GUI object from a combo box to a text box will, almost invariably, invalidate all NAMEs in the original test scripts that reference the GUI object. The interdependence between NAMEs and testing logic renders test scripts hardwired to specific GAPs and testing frameworks. Transportability of test scripts is further exasperated because GUI object creation is dependent upon the underlying GUI framework, which may differ between different GAPs. For these reasons, test scripts based on NAMEs, to date, have not been reusable even between GAPs that have the same functionality, thereby obliterating a potential benefit of test automation.","Additional difficulties in testing GAPs exist because three \u201ctype systems\u201d are involved: the type system of the language in which the source code of the GAP is written, the type system of the underlying GUI framework, and the type system of the language in which the test script is written. If the type of the GUI object is modified, the type system of the test script \u201cwill not know\u201d that this modification occurred, which complicates the process of maintaining and evolving test scripts. Test scripts do not contain any typing information in them. They do not use the type system of the GUI framework, which is not a part of the scripting language interpreter, and they do not have access to the type system of the programming language in which the GAPs are written. Because of the absence of type systems within test script languages, programmers cannot detect errors statically, obtain adequate documentation, and maintain and evolve test scripts effectively.","For all of its limitations, test script based testing, as compared to manual testing, results in an overall reduction in labor for testing GAPs. To help further reduce the labor of testing GAPs, test engineers create models of GAPs and generate the test scripts by using tools that process the modeled GAPs. Model-based testing includes building high level models of GAPs and implementing algorithms that construct test cases. However, this modeling process for generating test scripts is not without significant limitations. For example, building high level models of GAPs is laborious and difficult and there are obstacles to building models directly from the source code of the GAPs. For one, the values of variables of GUI objects are known only at runtime, i.e., in conjunction with the execution of the API calls. Thus, GUI models cannot be derived from source code alone. Also, deriving models from the source code would require (a) knowing the semantics of API calls that create and manipulate GUI objects, (b) developing tools that extract GUI models from GUI resource repositories, and (c) knowing the GUI application language. Currently, there are tens of thousands of combinations of (a), (b), and (c), making it difficult to develop a universal approach to deriving GUI models. What's more, the source code of a GAP is usually not made available to the independent testing organizations that are contracted to test proprietary GUI software. Thus, there are significant challenges to model-based-test-script generation.","There are several obstacles that prohibit GAP testing using other techniques. For one, because GUI objects are created dynamically, i.e., only when the GAP is executed, GAPs cannot be tested statically, such as by examining the GAP source code. Also, because a test script is run on a platform that is external to the GAP platform, GUI objects cannot be accessed as programming objects that exist within an integrated program. And because complete specifications of GUI objects are usually not available, it is difficult to analyze statically how GUI objects are accessed and manipulated by NAMEs.","Therefore, a need exists for a GAP testing structure that implements readily modifiable and reusable test scripts.","A test structure for testing graphical user interface applications (GAPs) modularizes test scripts by separating statements that define test logic from statements that navigate to GAP objects. Composition rules weave these two kinds of statements together to generate the test scripts that are executed to test the GAP. Separating the logic statements from the navigation statements provides a modular test structure whereby the same test logic can be reused across different GAPs and different versions of the same GAP. Reusing test logic is not only an efficient practice from a test engineer's point of view, but also leads to a reduction in test programming errors. The modular test structure also facilitates the efficient modification of test scripts to account for modifications in the underlying GAPs, greatly reducing the time, cost, and resource expenditures needed to arrive at updated test scripts.","The test structure implements object oriented navigation code in which GAPs are represented as programming objects and GUI objects are represented as fields within the programming objects. The test structure includes test logic to invoke methods that perform actions on the programming objects. The methods are invoked on the programming objects in the GAP via an accessibility interface that provides access to the GUI objects as they become available in the GAP. Method calls invoke NAMEs to locate the GUI objects and extract their values. The values are passed from the GAP back to the testing logic through the accessibility interface.","Using this test structure, the test logic need not be intertwined with NAMEs to test a specific GAP. Rather, the test logic is applied to a GAP by defining pointcuts in the GAP, using an aspect-oriented type programming language. When the GAP activates a join point, the test logic is activated. Therefore, the same test logic may be applied to different GAPs by defining GAP specific pointcuts in a GAP. If a GAP is modified, the pointcuts are simply redefined to maintain the validity of the testing logic.","Other systems, methods, features and advantages will be, or will become, apparent to one with skill in the art upon examination of the following figures and detailed description. All such additional systems, methods, features and advantages are included within this description, are within the scope of the claimed subject matter, and are protected by the following claims.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","120","150","152","160","150","154","156","156","160","154","156","156","162","156","156","164","166"],"sub":["1","N ","1","N "],"i":["a","f","a","f","a","f"]},"The program elements stored in memory  include a GAP test environment  and a reflective connector . The GAP test environment  includes a test script , test logic , a test script interpreter , programming classes (such as the programming class ), class definitions , an exceptions handler , and a typing dialog . The processor  executes the GAP test environment  to test any desired logic of the GAP . Although only one test script  is shown in , GAP test environment  may include any number of test scripts to partially or completely test the GAP . The test script  may interact as a plug-in to a host application such as Eclipse\u2122 (not shown).","As explained in more detail below, the GAP test environment  generates a programming class  for, by way of example, the specific GUI object  of the GUI objects . The programming class  includes methods to locate GUI objects  and value manipulation methods  that are called by test script statements  within the test script . When executed, the test script statements  reference the GUI objects  as programming objects and the reflective connector  provides access to the GUI objects . In connection with executing the test script statements , one or more of the methods to locate GUI objects  and the value manipulation methods  interact through the reflective connector  to obtain and\/or manipulate one or more values of the programming object . The reflective connector  may be implemented in an accessibility layer, described below.","The program elements for testing the GAP  separate the test script  into two orthogonal concerns: high-level test logic  that tests the GAP computations, and low-level sequences of instructions (test script statements ) that specify how GUI objects are located and manipulated on the GAPs. The test script may be automatically generated by composition rules that weave the high-level test logic  with the test script statements . The high-level test logic  is GAP and test platform independent and may be applied in a modular fashion to test different GUIs and GAPs.","In one implementation, the programming language of the test script  resembles that of aspect-oriented programming paradigm. The programming language supports inter-type declarations, pointcuts, and advice. A version of a format of the test script  is shown as  in . The test logic is declared as the aspect . The pointcut  defines a set of conditions ()-() as join points that must be met before the advice  is executed. Details of each element within the test script  are discussed further below.","An example of a test script that tests the dates displayed in GUIs of travel GAPs is provided in Table 1.",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test Script Example"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GAP Test","1 \u2003public aspect TestTravelReservationLogic {"]},{"entry":"Logic"},{"entry":["GAP","2 \u2003\u2003pointcut TravelDates ( ) :"]},{"entry":["Pointcut","3 \u2003\u2003object (current active GUIObjectDate retDate) &&"]},{"entry":[{},"4 \u2003\u2003object (current active GUIObjectDate depDate) &&"]},{"entry":[{},"5 \u2003\u2003GAP(App1, App2, App3) &&"]},{"entry":[{},"6 \u2003\u2003\u2002! (GAP(App4) ||"]},{"entry":[{},"7 \u2003\u2003\u2003\u2002handler (EventException) ||"]},{"entry":[{},"8 \u2003\u2003\u2003\u2002event (LOADING) );"]},{"entry":["GAP Advice","9 \u2003\u2003before ( ) : \u2003\u2002TravelDates ( ) {"]},{"entry":[{},"10 \u2003\u2002\/\/ verify checkpoints, e. g., no dialogs,"]},{"entry":[{},"11 \u2003\u2002\/\/ no popups. Make sure that selected GUI"]},{"entry":[{},"12 \u2003\u2002\/\/ objects can be used in the testing"]},{"entry":[{},"13 \u2003\u2002\/\/ logic in the around and the after advice }"]},{"entry":[{},"14 \u2003\u2002around ( ) : TravelDates ( ) {"]},{"entry":[{},"15 \u2003\u2003\u2002TestLogic4Dates ( ) ; \u2003\u2002}"]},{"entry":[{},"16 \u2003\u2002after ( ) : TravelDates ( ) \u2003\u2002{"]},{"entry":[{},"17 \u2003\u2003\u2002ButtonSearch.Click ( ) ; } }"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this example, test logic is declared as the aspect TestTravelReservationLogic in line 1. In lines 2-8 the pointcut TravelDates specifies the join points in the GAP that trigger the testing logic defined as an advice (lines 9-17). Lines 3 and 4 specify that the programming objects retDate and depDate that have the type GUIObjectDate are bound to their corresponding GUI objects as qualified by the \u2018current\u2019 and \u2018active\u2019 specifiers. In other words, the corresponding GUI objects must have active binding and current instantiation on the GUI screens of the applicable GAPs (any one of App1, App2, or App3) (line 5). However, the testing logic should not be applied to the GAP App4, as specified in line 6. The GAP must not generate an event exception (line 7), and the GAP should finish loading the GUI screen (line 8) before the test logic is triggered.","In this version of the programming language, there are three types of advice: before, around, and after. The advice \u2018before\u2019 adds code that specifies and verifies checkpoints, e.g., no dialog or popup windows are presently active in the GAP. The advice \u2018before\u2019 also ensures that selected GUI objects can be used in the testing logic in the \u2018around\u2019 and the \u2018after\u2019 advice. In this example, the advice \u2018before\u2019 checks whether the button \u201cSearch\u201d is enabled in order to verify that the GUI screen is in the correct state for the test.","The advice \u2018around\u2019 and \u2018after\u2019 reference the test logic and the action that is to be performed on the GUI objects, such as switching the GAP to a new state. Specifically, when the \u2018around\u2019 advice is triggered, the function TestLogic4Dates ( ), shown in Table 2, executes to test whether the return date is earlier in time than the departure date.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test Logic \u201cTestLogic4Dates\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1 void TestLogic4Dates ( ) {"]},{"entry":[{},"2 \u2003GUIObjectDate retDate , depDate ;"]},{"entry":[{},"3 \u2003depDate . setValue( GetRandomDate( ) );"]},{"entry":[{},"4 \u2003retDate . setValue( GetRandomDate( ) );"]},{"entry":[{},"5 \u2003int diff = retDate . get Value ( ) \u2212"]},{"entry":[{},"6 \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003depDate . getValue ( );"]},{"entry":[{},"7 \u2003if( diff <= 0) \/\/ report test failure;"]},{"entry":[{},"8 \u2003else \/\/ report passed test}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The test logic is encapsulated in the function  TestLogic4Dates (line 1), in which two programming objects  retDate and depDate are declared (line 2). These objects represent GUI objects on travel GAPs that hold values of the return and departure dates. The value of the departure date is set using the method  setValue to a randomly generated date using the function GetRandomDate (line 3). The value of the return date is also set (line 4). The difference between the values of the return and departure dates is computed  (lines 5-6). If the difference is less than or equal to zero, the test logic  reports failure (line 7); otherwise the test logic  reports pass (line 7).","This example illustrates how cross-cutting concerns of GAPs are modularized in the test logic . GUI objects  are represented as programming objects  in the test logic, thereby replacing NAMEs with GUI structure-neutral operations on the programming objects. NAMEs are not tangled with the test logic ; the logic can be universally applied to different GAPs or different versions of the same GAP. The test logic operations are later translated into NAMEs when test methods are invoked and\/or when values of objects are set or retrieved. Once the operations are translated into NAMEs, they are executed by the underlying testing framework. This example demonstrates that test logic may be written without reference to and independent of all NAMEs.","The test logic in Table 2 contains a single concern (verifying dates) that may be applied in a modular fashion to different GAPs. When a requisite GUI screen is activated and its GUI object(s) become available, the test logic that references the available objects is executed. Thus, rather than carrying out the complex, laborious task of writing the test logic directly into the test scripts, the test logic  and test scripts  are written (and may be used) separately and are woven together automatically to test the GAP .","As discussed above, within the test structure of the present disclosure the GUI objects are represented as programming objects. This test structure provides a mechanism for setting and retrieving the values of the properties of the GUI objects in the GAP, and provides access for invoking GUI operations. Another way of characterizing this aspect of the test structure is to regard a GUI object as a class residing inside of a web service. This characterization is represented visually in , which illustrates a schematic state machine  showing transitions between screens (), (), (), () of a GAP . The GUI screens consists of a collection of GUI objects (), (), (), (), (), () and therefore may also be regarded as a class having fields that are instances of the classes of its GUI objects. At a higher level, a GAP may also be regarded as a class having fields that are instances of the classes of its GUI screens. In , the GAP  is regarded as a state machine having its states defined as collections of GUI objects (), (), (), (), (), (), the GUI object properties (e.g., style, read-only status, etc.), and the GUI object values. In a new state, a GUI object may remain the same, but its values and properties may change. A GAP transitions to a new state in response to an action  prompted by a web service. The GAP  is thus a programming object that is transitioned between states by a web service.","The GAP test environment  includes elements that identify a GAP state as either a final state or an intermediate state, and may apply test logic to only final states. An example of a GAP final state is a destination page, such as a web page showing departure flights. An example of a GAP intermediate state is a progress page, such as a an animated hour glass. The GAP test environment  identifies final states by analyzing the structure of the GAP and its GUI objects. The analysis includes traversing GUI trees and comparing them to trees that have been recorded in response to user operations.","An overview of an embodiment of a process for constructing a GAP test environment  will provide a setting for explaining how GUI trees are traversed to identify final states.  shows logic  that may be performed to construct a GAP test. At  the test logic is written using a programming object language that include types and names. The programming objects represent GUI counterpart objects. At  capture\/replay tools capture properties of the GUI objects. At  the types and names of the programming objects are assigned to the corresponding GUI objects. At  methods are invoked on the programming objects, which causes NAMEs to be executed. At , a user (e.g., a test engineer) interacts with the GAP and captures the NAMEs and the structure and states of the GAP. The captured NAMEs are sequences of low-level instructions that specify how to navigate to the GUI objects. The low-level instructions also specify the methods that must be invoked on the NAMEs in order to reproduce the user's actions. At , types and names of GUI objects are specified, to be later used in the test scripts. At , bindings (explained below) are created between the programming objects and the GUI objects. The bindings allow the programming objects to be used in different scripts for different GAPs, because the underlying NAMEs provide the GAP-specific navigation paths to the GUI objects. At  the test script (; Table 1) is written. If the GAP is modified, invalidated NAMEs may be regenerated at .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5","b":["500","502","504","122","506"]},"From a tester's point of view, GUI objects have up to four functions: action producers, input data acceptors, output data retrievers, and state checkpoints. Action producers enable GAPs to switch to different states. A button-type GUI object is an example of an action producer; clicking on a button switches a GAP to a different state. Input data acceptors are GUI objects that receive data from users (e.g., text boxes). Output data retrievers are GUI objects that contain data (e.g., list views or text boxes). These objects serve as data suppliers for generating unit test cases. State checkpoint objects are GUI objects that must exist on a screen in order for a GAP to function correctly. Output GUI objects are also state checkpoint objects, because test scripts cannot retrieve data from output GUI objects that have not been initialized. Some GUI objects may have all four functions, for example, a combo box may be a state checkpoint, may contain output data, may accept input data, and may produce some action when the user makes a selection. The functions of the GUI objects, specifically which GUI objects receive values or serve as inputs and which GUI objects produce output results, are used to define the programming objects in the test scripts. Thus, the functions of the GUI objects must be specified.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6","b":["600","602","604","606","608","610","612","614","616"]},"Within a GUI framework, GUI objects are represented internally as data structures whose records specify values of properties of these objects. As a GAP program is executed, GUI objects are created, activated, and destroyed as the user interacts with the GUI screens.  is a state diagram  that shows the lifecycle of a GUI object. The ovals contain the names of the states of a GUI object. Transitions between states are shown with arrows.","The initial state of a GUI object is the created state . To create a GUI object, a record must be allocated, and the fields of the record initialized to initial values. Once a GUI object is created, its state transitions to a deactivated state  because at this point the GUI object is not accessible to users. As discussed above, GUI objects are accessible to users only when they are activated on or in relation to the execution of some GUI screen. In the activated state , the GUI object is visible and accessible by the user. Until it enters the destroyed state , the GUI object may transition between the activated and deactivated states any number of times. As an example, moving back-and-forth between screens hides (deactivates) one screen and its GUI objects and presents (activates) another screen and its GUI objects. Simply switching between states (without the user entering data or command buttons) does not change the values held by a GUI object. And a user cannot act on a deactivated GUI object. The same restrictions apply between a GAP and a test script; the test script cannot act on (e.g., read or write to) GUI objects that have been deactivated. What's more, a test script (as well as a user) cannot activate and deactivate GUI objects at will because the GAP performs these actions asynchronously as the GAP program is executed. In other words, GAP actions are locked-in the GAP program and are not modifiable by an external programs. As explained below, the GAP test environment  of the present disclosure includes program elements, referred to as bindings, that ensure that the GAP program has initialized and activated GUI objects before attempts are made to access them.","Bindings are defined between programming objects in testing logic and the GUI objects in the GAP. GUI objects exist within the context of the GAP. The programming objects in testing logic represent corresponding GUI objects. Bindings between programming objects and GUI objects dictate which operations can and cannot be performed on programming objects in test scripts, thereby preventing runtime exceptions.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 8","b":["802","804","800","802","806","808","806","808","808","810","812","800"]},"The lifecycle of a programming object in a test script is tightly linked to the lifecycle of the GUI object it represents. A binding in a test script statement defines the status of a GUI object that must be met before the corresponding test script operation is executed. In other words, the operations that can be safely performed on programming objects are a function of the status of corresponding GUI objects at instances of time (e.g., past, current, or future). The status of a GUI object, as it pertains to programming objects, may be referred to as a binding type. Table 3 shows the operations that may be performed on a GUI object as a function of time and binding type.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GUI Object Operations as a Function of Instance and Binding Type"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["GUI Object","Binding Type",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Instance","Active","Passive","Static"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Past","Prohibited","Read","Read\/Write"]},{"entry":["Present","Read\/Write\/Invoke","Prohibited","Read\/Write"]},{"entry":["Future","Prohibited","Write","Write"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The column GUI Object Instance may be one of three points in time with respect to a present instance. First, a GUI object may have been instantiated in the past, that is it may have already been, but is not presently, available to the user. Second, a GUI object may be presently available for a user to act upon it. Third, a GUI object may have not yet been instantiated but will be at some time in the future. It is noted that although it is not possible to predict the values that will be held by a GUI object that is to be instantiated in the future, the values may be set in the test script (via a programming object counterpart) so that when the GUI object is instantiated, its values will be set via the reflective connector.","Table 3 also shows that there are three types of bindings: active, passive, and static. An active binding means that the GUI object that corresponds to the programming object is activated on the GUI screen. A passive binding means that the GUI object is deactivated. A static binding means that a GUI object exists on a screen that is, for example, overshadowed by another screen (e.g., layers in web browsers). Although the overshadowed object is not accessible to the user, test script operations can be performed on it. Static bindings correspond to static variables in Java which are activated when their scopes are reentered.","Table 3 also shows that there are three GUI Object Instance\/Binding Type combinations where operations are prohibited: past\/active, current\/passive, and future\/active. Past\/active operations are prohibited because a GUI object cannot have an active binding if it is no longer available. Current\/passive operations are prohibited simply because a GUI object that is currently available is not passive. Future\/active operations are prohibited because a GUI object cannot have an active binding if it is not yet available.","For the non-prohibited combinations, there are three types of operations that may be performed on the GUI objects: reading values from them, writing values into them, and invoking methods (i.e., acting) on them. For current\/active GUI objects, all three operations may be performed. A passive GUI object may be read from if it has already been instantiated (past\/passive) because although a GUI object is not active its values can be retrieved by testing logic. A passive GUI object that has not yet been instantiated (future\/passive) may be written to by setting the value in the GUI object in testing logic. The set value will be stored, and when the GUI object is created and activated, its value will be set. Deactivated (static binding) GUI objects may be read from or written to if the GUI object previously or presently exist(s). If the GUI object has not yet been instantiated, it cannot be read from; however, it may be written to. Referring again to , the test script statement implements the bindings within the pointcuts  as GAP conditions ()-() for executing the test logic.","As stated above, the system  supports test script statement with aspect-oriented programming features. For example, the system  may implement an underlying AspectJ\u2122-based grammar of pointcuts, but extend the grammar with GAP testing extensions. Examples of the GAP testing extensions are shown below in Table 4 in italics. The GAP testing extensions include the \u2018insttime\u2019 and \u2018binding\u2019 rules, the \u2018past\u2019, \u2018current\u2019, \u2018future\u2019, \u2018active\u2019, \u2018passive\u2019, and \u2018static\u2019 designators for the \u2018insttime\u2019 and \u2018binding\u2019 rules, as well as additional designators \u2018object\u2019, \u2018GAP\u2019, \u2018handler\u2019, and \u2018event\u2019 for the \u2018designator\u2019 rule.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Pointcuts in Test Script Programming Language"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pointcut","accesstype pcname ( {params} ) :"]},{"entry":[{},{},"{designator [([insttime binding type]"]},{"entry":[{},{},"identifier)] [&& | ||]);"]},{"entry":[{},"accesstype","public | private [abstract]"]},{"entry":[{},"insttime","past | current | future"]},{"entry":[{},"binding","active | passive | static"]},{"entry":[{},"pcname","{identifier}"]},{"entry":[{},"params","(type identifier)"]},{"entry":[{},"designator","call | execution | target | args | cflow |"]},{"entry":[{},{},"cflowbelow | staticinitialization | within | if |"]},{"entry":[{},{},"adviceexecution | preinitialization | object |"]},{"entry":[{},{},"GAP | handler | event"]},{"entry":[{},"identifier","letter {letter | digit}"]},{"entry":[{},"type","a valid Java type"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Accordingly, the system  establishes a test script programming language using standard designators (e.g., call and execution) to specify join points where advice is woven. The designators \u2018object\u2019, \u2018GAP\u2019, and \u2018event\u2019 have been added so that the testing logic may be dynamically woven into the execution of the GAP. The designator \u2018object\u2019 specifies programming objects (within the testing logic) that represent GUI object counterparts. The advice is triggered when the specified GUI objects are activated. The \u2018designator\u2019 event specifies events that trigger the execution of advice. The designator \u2018GAP\u2019 specifies GAPs that serve as join points. The designator \u2018GAP\u2019 allows test engineers to specify events and objects that serve as join points for specifically designated GAPs (analogous to specifying packages to which certain advice is applied in Java).","When advice is triggered, the GAP test environment  interacts with the GAP  through an accessibility layer. The reflective connector  in FIG.  may be implemented in the accessibility layer. The accessibility layer allows the GAP test environment  to retrieve attributes of GUI elements, set and retrieve attribute values, and generate and intercept events. The test logic is woven into the GAP where the test script intersects the GAP in response to GAP events. Most computing platforms include accessibility technologies to comply with the Electronic and Information Accessibility Standards set by section  of the U.S. Rehabilitation Act of 1973. For example, Microsoft Active Accessibility (MSAA) improves the way accessibility aids work with applications running on Windows, and Sun Microsystems Accessibility technology assists disabled users who run software on top of Java Virtual Machine (JVM). Accessibility technologies are incorporated into these and other computing platforms as well as libraries and applications in order to expose information about user interface elements. For example, a Windows GUI element implements an interface referred to as \u201cIAccessible\u201d so that the element may be accessed and controlled using MSAA API calls.","The GAP test environment  utilizes the accessibility layer and hooks to inject event listeners into the GAP. Hooks are user-defined libraries that contain callback functions (\u201ccallbacks\u201d) that are written using high-level accessibility API calls in accordance with rules dictated by accessibility technologies. Hooks enable users to extend the functionality of GAPs without changing the GAP source code. Primary functions of hooks are to receive commands to perform actions on GUI elements, to report events that occur within the GAP, and to invoke predefined functions in response to certain commands and events. Writing hooks does not require any knowledge about the GAP source code. Additional details regarding hooks, the accessibility layer, GUI elements, GAPs, and GAP testing are discussed in United States Publication Number 2008\/0250051 A1 (Grechanik et al.), entitled \u201cAutomatic Test Generation for Reference Testing,\u201d hereby incorporated herein by reference in its entirety.","The GAP test environment  includes a hook library that is generic for all GAPs. When a target GAP is started, the accessibility layer loads predefined hook libraries in the process space of the GAP and registers addresses of callbacks that should be invoked in response to specified events. Because hooks \u201clive\u201d in the process spaces of GAPs, their callbacks can affect every aspect of execution of these GAPs. Hooks injected into a GAP listen to events generated by the GAP and execute instructions received from integrated systems. For example, a hook may include an instruction to disable a button until a pre-defined event occurs.","The injected event listeners respond to GAP events. The events are specified at a high level by the pointcuts. For example, the pointcut \u201cobject (static current GUIObjectDate retDate)\u201d states that the GUI object that is mapped to the Java object retDate of the type GUIObjectDate must be currently available for action on some GUI screen (the screen itself does not have to be active). The function of the object is checked against the pointcut specification.","By way of the event listeners, the GAP test environment  captures GUI objects, receives input describing the state of the GAP, and generates programming classes (e.g., 124). The classes include methods that control the GAP by setting and getting values of GUI objects. The methods also initiate actions that enable the GAP to switch to different states. As the GAP switches states, the GAP test environment  records each state. In other words, the GAP test environment  traverses the GUI tree of the GAP in post-order. For each node of the tree, the GAP test environment  emits code that defines a programming class for the node. A format for declaring a programming class of a node is shown in Table 5.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Format for Declaring a Programming Class for a GUI Node"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Modifier","Class Body"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"public class","1 ClassName {"]},{"entry":[{},"private int","2 ElementId = 0x41 ;"]},{"entry":[{},"private void","3 Locate ( int ProcId ) { . . .}"]},{"entry":[{},{},"4 ClassName ( int ProcId ) {"]},{"entry":[{},{},"5 \u2003\u2003Locate ( ProcId ) ; . . . }"]},{"entry":[{},"public void","6 setValue ( type var ) {. . .}"]},{"entry":[{},"public type","7 getValue( ) {. . .}"]},{"entry":[{},"public void","8 Dolt (String act ) {. . .} }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Generated classes are linked to GUI objects and contain methods for locating the objects  in the GAP, setting and getting their values, and performing actions on them . When a GAP starts, the operating system assigns a positive integer number to each window (GUI object), which is the order number in which a GUI object takes focus when tabbing through the GUI. The order number is represented by the private variable ElementId, which is initialized with a negative number as a default value (line 2). The private method \u201cLocate\u201d takes the process identifier of the GAP as its parameter and retrieves the ElementId for a given GUI object for of the GAP (line 3). When the GAP test environment  emits the code for the \u201cLocate\u201d method, it uses the accessibility API functions to obtain information about elements in the GUI tree that lie in the path to the GUI object. When executed in the constructor at lines 4-5, the information is used to navigate to the GUI object and obtain its identifier, which will be used in methods setValue, getvalue, and Dolt to access the GUI object directly.","Methods setValue and getvalue shown in lines 6 and 7 respectively set and retrieve values of GUI objects. The data type is \u201cstring\u201d by default. However it may be specified otherwise, such as \u201cinteger\u201d or \u201cfloat.\u201d The code for these methods uses the accessibility API functions with the ElementId to locate the given object in the GUI and set or retrieve the value of the element. Finally, the method Dolt (line 8) takes an argument that specifies an action taken against the GUI object. If the argument is null, then a default action provided by the accessibility API function is executed. These methods throw exceptions if problems are encountered.","The event listeners detect exceptions. The GAP test environment  includes an exceptions handler  that emits code in response to the exceptions (e.g., code to display a message box that informs the user about incorrectly formatted input).","As discussed above, the test logic includes GUI classes that include programming objects (GUI variables) that are bound to GUI objects. The GUI classes reflect semantic concepts. For example, a GUI class named \u201cGUIObjectDate\u201d may include GUI objects that display dates, such as departure (\u201cdepDate\u201d) and return (\u201cretDate\u201d) dates. Bindings between GUI objects and programming objects are specified by GUI object typing.","Table 6 shows an example of a definition of a GUI class \u201cGUIObjectDate\u201d having class objects that represent GUI objects containing date information.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Definition of a GUI Class"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Name","1 GUIclass GUIObjectDate {"]},{"entry":[{},"Definition","2"]},{"entry":[{},{},"3 Abstract Date getDate ( ) ;"]},{"entry":[{},{},"4"]},{"entry":[{},{},"5 Abstract void setDate (Date) ;"]},{"entry":[{},{},"6"]},{"entry":[{},{},"7 \/\/ . . ."]},{"entry":[{},{},"8 }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Within the definition, a set of \u201cabstract\u201d methods are declared. The abstract methods, which may be referred to as access methods, are the methods that are called by the test logic to access and manipulate GUI objects. The methods are GAP and GUI object dependent and therefore cannot be provided in the test logic. Instead, the methods are automatically generated once bindings are set between the program objects and the GUI objects. Methods associated with programming classes are members of class definitions. The class definitions define the methods that may be invoked on the programming class.","For example, referring to Table 2 \u201cTestLogic4Dates\u201d includes the method call \u201csetValue\u201d (line 3) executed on programming object \u201cdepDate\u201d that corresponds to a GUI object that, for example, displays a departure date. \u201cdepDate\u201d is a member of the GUI class \u201cGUIObjectDate\u201d (line 2). Table 6 declares the methods that may be called on members of the GUI class \u201cGUIObjectDate.\u201d In this example, the methods that may be called are \u201cgetDate\u201d and \u201csetDate.\u201d The \u201csetDate\u201d and \u201cgetDate\u201d methods are programs that are executed through the accessibility layer described above. The programs may be defined in accessibility technology libraries or may be custom designed programs. The programs are associated with programming objects through class definitions. For example, the programming object \u201cdepDate\u201d must be added to the programming class \u201cGUIObjectDate\u201d before it can be referenced as a programming object in Table 2, line 2. Programming objects are added to programming classes by referencing their corresponding GUI objects on GUI screens and opening a typing dialog . The typing dialog  bridges the code between Table 5 and Table 6, and binds GUI objects to GUI parameters specified in the GUI aspects.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 9","FIG. 10"],"b":["172","902","172","904","1000","1000","1002","1004","1002","906","1004","908","172","910"]},"Once the selected GUI object is assigned a class, access methods of the GUI class may be automatically generated so that the test logic can access and manipulate the selected GUI object (). Access methods may be preprogrammed methods that are stored in a typing dialog library  of user defined access methods that define how GUI objects are accessed. Each programming class is associated with one or more selectable access method(s). The association(s) between the programming classes and the access methods may also be stored in the library . In the example shown in , access methods for accessing GUI objects of the class \u201cGUIObjectDate\u201d are \u201cDate getDate( )\u201d and \u201cvoid setDate(Date date).\u201d An access method may be selected based on the action that is to be invoked on the selected GUI object during testing.","As discussed above, GUI objects are represented as corresponding programming objects in a test script. The method for accessing the programming object that corresponds to the selected GUI object may be assigned () in a GUI Object Methods field . As shown in , the typing dialog window  includes a Concept Methods field  for assigning the access method and the GUI Object Methods field  for assigning the method that accesses the programming object (which may be referred to as the \u201cgenerated method\u201d). Generated methods may be preprogrammed methods that are stored in the typing dialog library .","Using the \u201cMapping\u201d button , a user may specify a mapping between the access method and the generated method (), and\/or specify user defined extensions (). For example, a user may map the \u201cgetValue\u201d method from the GUI Object Methods field  to the \u201cgetDate\u201d method in the Concept Methods field . The typing dialog  generates a skeleton of the code for mapping the method fields together (), e.g., \u201cgetvalue\u201d to \u201cgetDate.\u201d Additional details regarding GUI element typing and mapping systems are discussed in commonly owned, co-pending U.S. patent application having Ser. No. 12\/038,665, filed Feb. 27, 2008, (Grechanik et al.), entitled \u201cTest Script Transformation Architecture,\u201d hereby incorporated herein by reference in its entirety.","A user may edit the code to fix a return type mismatch, if any. Table 7 shows an example of mapping code generated by the typing dialog in the left column. The user edited code is shown in the right column.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Typing Dialog Code"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Generated by Typing Dialog","Edited by User"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Date getDate ( ) {","Date getDate ( ) {"]},{"entry":["\u2003Return (objstub.getValue ( ));","\u2003Return new Date (objstub.getValue"]},{"entry":["}","\u2003( ));"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The typing dialog  implants hooks in the GAP to detect when GUI objects appear and disappear on the screen as programming objects are added to programming classes. When a selected GUI object appears on the screen, the GAP test environment  updates its data structure (e.g., marks \u201cretDate\u201d as an active binding). If all of the parameters for a given pointcut are present, the advice on the pointcut call is automatically invoked, achieving automatic weaving of advices. The test script interpreter  evaluates the pointcuts detected by the hook to determine whether all of the pointcuts are present for the GUI object.","The primary operations on GUI objects are (a) navigating to them and (b) invoking methods on them, including setting and getting their values. These operations are executed by applying test script advice to the join points and automatically generating access methods in accord with user input collected by way of the typing dialog window . The semantics of these primary operations are described below.","To apply advice to join points, the test script programming language running in GAP test environment  in the system  uses reduction rules that define operational semantics for performing operations on the programming objects that represent the GUI objects. The reduction rules  are shown in , , and  and include SCRIPTNAVIGATE , GETOBJECT , MCALL , CALLRETURN , EXECGAP , GSNAVIGATE , AND GSGETOBJECT .","The GAP test environment  defines a testing system TS that comprises the GAP G and the test script T, referred to collectively as programs, P. The programs P include a set of locations and a set of values. The state, S, of the testing system, TS, is the union of the state of the GAP and the test script. The state of a program, P, is obtained via the mapping function ProgramState: TSxP\u2192Sp. In the reduction rules, Sp is shorthand for applying the ProgramState function to obtain the state S of some program P, which may be either the test script, T, or the GAP, G. The evaluation relation, defined by the reduction rules, has the form TSTS\u2032, where TS=(T,e,S), (G,a,S), read \u201cThe test script, T, and the GAP, G are members of the testing system, TS.\u201d Executing the expression e with the initial state Sleads to executing the action a with the initial state S, and the system TS transitions to a new system TS\u2032. In these rules T and G are programs and S is a state. Transition(P, e, S)\u00d7(P, e, S), where P is either G or T.","An executed test script expression changes not only the state of the test script, but also changes the state(s) of the GAP(s) to which the script is connected (i.e., the GUI objects accessed and controlled by the test script expression). Statements in test scripts that access and manipulate GUI objects consist of the following operations: (1) navigate to some destination GUI object and (2) invoke methods to perform actions on the GUI object. GSNAVIGATE and GSGETOBJECT show how test scripts manipulate the GAP by initiating user action a on it. These rules are evaluated to reference the GUI object V of type c in the test script. The rule SCRIPTNAVIGATE is executed on the script side and it returns the object v which is contained in the GUI object that is referenced in the test script using the object o. The properties of the returned object v are defined in an object register (OR) under the name p. The rule GETOBJECT is executed on the GAP side and it returns a collection of objects v, which are contained in the GUI object that is referenced in the GAP using the object o. The rule MCALL shows that evaluation of a test script expression that references a GAP object waits for the result of the action performed on the GAP. The rule CALLRETURN returns the result of method execution from the GAP to the test script, while the rule EXECGAP evaluates the action at the GAP. E stands for the context in which a given rule is applied. Helper functions  are shown in  where the function OR  computes the set of properties and their values of a GUI object whose entry in the object repository is labeled p. The function identify  returns a child object whose properties values match given values. The function childOf  returns true if the GUI object of the type \u03b4 is a child object of the parent object of the type \u03c4, otherwise it returns false. The test script interpreter  executes the rules discussed above.","Several different flight reservation GAPs were tested by implementing the test logic shown in Table 8. In the first half of the test, the test logic was implemented using QuickTest\u00ae Professional (QTP) to create a test script for testing dates in a first commercial GAP. The test script was then modified using the QTP script debugger against a second commercial GAP in the following process: The test script was applied to test the second GAP. The change of GAP under test invalidated NAMEs (every single NAME broke in the second GAP test) and generated exceptions, causing the test to terminate. The exceptions were analyzed inside the QTP script debugger, and then the test script was modified, and the test was rerun. The process of analyzing exceptions and modifying test scripts was repeated until the test script ran without throwing any exceptions. The effort of modifying the test script was close to that of a complete rewrite. Over all, the cost of composing each script was approximately 90 minutes, with variation under 5 minutes.","Compared to typical test scripts which often implement multiple test logic, the test script used in the experiment is a relatively simple one. In more complicated test scripts test engineers introduce loops to increase coverage. Consider a test script that contains a loop with code that reads in and analyzes data from files, computes a result from the data, and inserts the result in a GUI object. Computing the result may take hours depending on the size of the files. Each time an exception is thrown, the results must be discarded, the script modified, and then rerun. Although it is possible to comment-out some loops to speed up execution, doing so changes the test logic. As a consequence, the reusability of the test script is diminished further.","In the second half of the test, a GAP test  based on the test logic of Table 8 was developed to test three commercial air-ticket-booking GAPs: GAP A, GAP B, and GAP C. The test logic was easily implemented in Java-like reusable test functions TestLogic4Date( ) (Table 2) and TestLogic4( ). Four GUI classes were defined: GuiObjDate, GuiObjAirport, GuiObjNumber, and GuiObjTrigger. Composition rules were written so that both functions could be applied to test GAP A, GAP B, and GAP C. The tests were applied when the GUI objects representing the required concepts appeared on the GUI screen, namely the starting and ending dates for TestLogic4Date ( ), and, for TestLogic4Flight ( ), the starting and ending dates, the departing and destination airports, the ticket quantity, and the submit button.","The completed commercial GAPs were not needed in the development of the test functions and composition rules for the GAP test  since these parts of the test pertain to high level semantic concepts from software requirements. To specify the mapping from the actual GUI objects to GUI variables in composition rules, the GAPs were run, the GUI objects that map to the pointcut criteria in the composition rules were located, and the mapping was specified. GUI objects representing itinerary information was mapped to high level GUI variables. Multiple GUI objects form a GUI structure: GUI objects representing airline, flight number, departing and arriving times and airport form an \u201citinerary\u201d record which is mapped to the itinerary variable in the composition rule. This is a many-to-one mapping, as there are an unknown number of itinerary item on the screen. Actions performed on the itinerary variables in the reusable testing logic are translated to NAMEs that act on every itinerary record on the result screen. The maps were saved under three different mapping profiles, one for each travel agency site.","During the test session, the individual mapping profiles were loaded when each respective GAP was loaded. When the expected GUI objects appeared on the screen, the pointcuts were recognized and the advice was loaded and executed.","The entire process to test all three GAPs using the structure of the GAP test  disclosed herein was approximately ninety minutes, or the equivalent time to develop a QTP script for a single application. The resulting test script was proven useable on GAPs that share similar functionality.",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Test Logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1 set departure date to a random date"]},{"entry":[{},"2 \u2003\u2003\u2003s . t . random date >= today ;"]},{"entry":[{},"3 set return date to a random date;"]},{"entry":[{},"4 if (return date <= departure date) {"]},{"entry":[{},"5 \u2003\u2003\u2003\u2003raise an exception;"]},{"entry":[{},"6 \u2003}"]},{"entry":[{},"7 set departure city;"]},{"entry":[{},"8 set destination city;"]},{"entry":[{},"9 assertTrue (departure city != destination city);"]},{"entry":[{},"10 click on search button to start search;"]},{"entry":[{},"11 assertTrue (a transition screen with progress bar"]},{"entry":[{},"12 \u2003\u2003\u2003\u2003\u2003appears for <= I min);"]},{"entry":[{},"13 assertTrue (a screen with a list of tickets"]},{"entry":[{},"14 \u2003\u2003\u2003\u2003\u2003satisfying the above criteria appears);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It is also much easier to evolve test logic using the GAP test environment  than it is using other test environments. For example, if GAPs are modified to accept city names instead of airport codes, only the test logic  in the GAP test environment  need be changed to update the GAP test. The updated GAP test may then be used to test any and all GAPs that have been modified to accept city names instead of airport codes. In contrast, in other test environments (e.g., QTP) all test scripts that reference the modified GUI object must be changed because the test logic is tangled in each separate test script (for each GAP). Thus, test scripts within the GAP test environment  are not only reusable, but are also modifiable.","The logic, circuitry, and processing described above may be encoded or stored in a machine-readable or computer-readable medium such as a compact disc read only memory (CDROM), magnetic or optical disk, flash memory, random access memory (RAM) or read only memory (ROM), erasable programmable read only memory (EPROM) or other machine-readable medium as, for examples, instructions for execution by a processor, controller, or other processing device. The medium may be implemented as any device that contains, stores, communicates, propagates, or transports executable instructions for use by or in connection with an instruction executable system, apparatus, or device. Alternatively or additionally, the logic may be implemented as analog or digital logic using hardware, such as one or more integrated circuits, or one or more processors executing instructions; or in software in an application programming interface (API) or in a Dynamic Link Library (DLL), functions available in a shared memory or defined as local or remote procedure calls; or as a combination of hardware and software.","In other implementations, the logic may be represented in a signal or a propagated-signal medium. For example, the instructions that implement the logic of any given program may take the form of an electronic, magnetic, optical, electromagnetic, infrared, or other type of signal. The systems described above may receive such a signal at a communication interface, such as an optical fiber interface, antenna, or other analog or digital signal interface, recover the instructions from the signal, store them in a machine-readable memory, and\/or execute them with a processor.","The systems may include additional or different logic and may be implemented in many different ways. A processor may be implemented as a controller, microprocessor, microcontroller, application specific integrated circuit (ASIC), discrete logic, or a combination of other types of circuits or logic. Similarly, memories may be DRAM, SRAM, Flash, or other types of memory. Parameters (e.g., conditions and thresholds) and other data structures may be separately stored and managed, may be incorporated into a single memory or database, or may be logically and physically organized in many different ways. Programs and instructions may be parts of a single program, separate programs, or distributed across several memories and processors.","While various embodiments of the voice detector have been described, it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the invention. Accordingly, the invention is not to be restricted except in light of the attached claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The system may be better understood with reference to the following drawings and description. The elements in the figures are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the system. In the figures, like-referenced numerals designate corresponding parts throughout the different views.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 11","b":["12","13"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 14","FIGS. 11"],"b":["12","13"]}]},"DETDESC":[{},{}]}
