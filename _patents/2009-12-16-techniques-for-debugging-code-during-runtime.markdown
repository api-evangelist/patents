---
title: Techniques for debugging code during runtime
abstract: A technique for debugging code during runtime includes providing, from an outside process, a trigger to a daemon. In this case, the trigger is associated with a registered callback function. The trigger is then provided, from the daemon, to one or more designated tasks of a job. The registered callback function (that is associated with the trigger) is then executed by the one or more designated tasks. Execution results of the executed registered callback function are then returned (from the one or more designated tasks) to the daemon.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08607199&OS=08607199&RS=08607199
owner: International Business Machines Corporation
number: 08607199
owner_city: Armonk
owner_country: US
publication_date: 20091216
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"p":["This invention was made with United States Government support under Agreement No. HR0011-07-9-0002 awarded by DARPA. The Government has certain rights in the invention.","1. Field","This disclosure relates generally to debugging code and, more specifically, to techniques for debugging code during runtime.","2. Related Art","Low-level application programming interface (LAPI) is a component of the AIX\u00ae operating system implementation of reliable scalable cluster technology (RSCT). LAPI is a message-passing application programming interface (API) that provides a one-sided communication model. In the LAPI communication model, a first task initiates a communication operation to a second task and the completion of the communication does not require the second task to take a complementary action. A LAPI library provides basic operations that facilitate storing data to and retrieving data from one or more virtual addresses of a remote task. LAPI provides a message infrastructure that allows a programmer to install a set of handlers that are called and run in an address space of a target task on behalf of a task originating a message. LAPI may provide flow control and support for: large messages; generic non-contiguous messages; non-blocking calls, interrupt and polling modes, efficient exploitation of network switch functions, and event monitoring (to simulate blocking calls, for example) for various types of completion events.","A programmer may interact with LAPI through an object called a LAPI handle (also referred to as a LAPI instance or a LAPI context). Usually, LAPI function calls take a LAPI handle as a first argument. LAPI provides a number of methods for transferring non-contiguous data (such as multiple buffers), repeating block\/stride descriptions, and implementing data gather\/scatter programs (DGSPs). For LAPI communication operations, origin (or source) denotes a task that initiates a LAPI operation and target (or destination) denotes a task where an address space is accessed during the operation. A push operation transfers data from the origin task to the address space of the target task. A pull operation transfers data from the address space of the target task into the address space of the origin task.","LAPI can be run in either a polling mode or an interrupt mode. In the polling mode, the sending and receiving of messages only happens when a programmer explicitly calls a LAPI function. In the interrupt mode, a receive interrupt is generated for incoming messages. In general, a control thread, which LAPI creates at initialization, handles interrupts. Using the LAPI query function, a programmer can query statistics related to data that is transferred using a user space (US) protocol or a user datagram protocol\/Internet protocol (UDP\/IP), through intra-task local copy or shared memory. LAPI includes a profiling interface that has wrappers (for each LAPI function) that facilitate collecting data about each LAPI call.","Compared to other communication protocols, such as the message passing interface (MPI) and the Internet protocol (IP), LAPI provides a lower level interface to a network switch. As is known, MPI is a specification for an API that allows computers to communicate with one another. The MPI may be, for example, employed in computer clusters and supercomputers. Applications that are written using LAPI can be run over a cluster of processors running, for example, AIX 5L\u00ae or Linux\u2122.","LAPI subroutines provide a wide variety of functions that can be used to obtain most behaviors required from a parallel programming API. LAPI functions also usually provide: C and FORTRAN subroutine bindings; extern \u201cC\u201d declarations for C++ programming; and profiling interfaces for C, C++, and FORTRAN programs. Complementary functions may be implemented to provide for checking completion of operations and for enforcing relative ordering, if desired. Additionally, LAPI functions allow tasks to exchange addresses that will be used in LAPI operations.","LAPI functions (and related subroutines) include: functions to initialize and terminate LAPI; functions to query and set up a runtime environment; and address-related functions. LAPI uses a number of internal structures to enable LAPI to perform message-passing operations on behalf of a user. As one example, the LAPI_Init subroutine is used to allocate memory for LAPI communication structures and to initialize the communication structures. The LAPI_Init subroutine returns a unique handle that represents a single LAPI communication context. The handle is subsequently passed as a parameter to each of the other LAPI functions. The LAPI_Init subroutine reads in various environment variables and sets up various communication channels based on the values of the variables.","As another example, the LAPI_Term subroutine is used to free memory associated with LAPI communication structures. The LAPI_Term subroutine takes a LAPI handle as a parameter and uses the handle to terminate the corresponding communication context. Once the LAPI_Term subroutine is called, no farther LAPI communication can be performed on a handle that has been terminated. Typically, the LAPI_Init subroutine is called once at the beginning of a user program and the LAPI_Term subroutine is called just before the user program terminates.","A number of different variables constitute a LAPI runtime state. Many of the variables can be queried at runtime to affect operation of a user program. For example, it is often useful to know the number of tasks in a given job as well as the identity of a current task and to design a user program to take actions according to the values. Many LAPI runtime state variables can also be set to alter LAPI behavior through job execution and to tune LAPI performance. For example, it may be useful to turn off interrupts to signal incoming packets when a user program explicitly makes a number of calls to various LAPI progress routines.","Various tasks implemented with a LAPI framework may require debugging. Traditionally, debugging code has been difficult without adding traces to an application and shared libraries that the application invokes. Moreover, debugging tasks implemented within a LAPI framework has usually required halting and restarting the task during debugging. While a signal (which is a limited form of inter-process communication used in Unix, Unix-like, and other portable operating system interface for Unix (POSIX) compliant operating systems) may be used to initiate debugging, when a signal is sent to a process an operating system interrupts the normal flow of execution of the process. Furthermore, signal handling is limited in that an invoked function cannot pass arguments (or parameters). Moreover, a signal handler is limited in that only a single signal can be handled by a single registered function. Furthermore, when conventional signal handlers are employed, adding new functions to an application without re-compiling the application is complicated. While the problems associated with using conventional signal handlers may be addressed using environment variables or files, the use of an environment variable requires restarting of an application in order for a new environment variable to take effect. In addition, employing files can cause resource\/lock issues.","In computer programming, a callback function is executable code that is passed as an argument to other code. A callback function allows a lower-level software layer to call a subroutine or function that is defined in a higher-level layer. In general, callback functions have a variety of uses. For example, writing a function that reads a configuration file and associates values with options (which are identified by a hash) as a callback function makes the function more flexible. In this case, a user of the function can use any desired hashing algorithm and the function will continue to work as the function uses the callback to turn option names into hashes. Another use of callbacks is in error signaling. A programmer may register a clean-up function as a callback function when the programmer does not want a program to terminate immediately (to ensure things get taken care of) when the program receives a signal. Callback functions may also be used to control whether a function acts.","According to one aspect of the present disclosure, a technique for debugging code during runtime includes providing, from an outside process, a trigger to a daemon. In this case, the trigger is associated with a registered callback function. The trigger is then provided, from the daemon, to one or more designated tasks of a job. The registered callback function (that is associated with the trigger) is then executed by the one or more designated tasks. Execution results of the executed registered callback function are then returned (from the one or more designated tasks) to the daemon.","As will be appreciated by one of ordinary skill in the art, the present invention may be embodied as a method, system, or computer program product. Accordingly, the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, microcode, etc.), or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule,\u201d or \u201csystem.\u201d Furthermore, the present invention may take the form of a computer program product on a computer-usable storage medium having computer-usable program code embodied in the medium.","Any suitable computer-usable or computer-readable storage medium may be utilized. The computer-usable or computer-readable storage medium may be, for example, but is not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device. More specific examples (a non-exhaustive list) of the computer-readable storage medium include: a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM) or Flash memory, a portable compact disc read-only memory (CD-ROM), an optical storage device, or a magnetic storage device. It should be noted that the computer-usable or computer-readable storage medium could even be paper or another suitable medium upon which the program is printed, as the program can be electronically captured, via, for instance, optical scanning of the paper or other medium, then compiled, interpreted, or otherwise processed in a suitable manner, if necessary, and then stored in a computer memory. In the context of this disclosure, a computer-usable or computer-readable storage medium may be any medium that can store the program for use by or in connection with an instruction execution system, apparatus, or device.","Computer program code for carrying out operations of the present invention may be written in an object oriented programming language, such as Java, Smalltalk, C++, etc. However, the computer program code for carrying out operations of the present invention may also be written in conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages.","The present invention is described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems), and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to one or more processors of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the one or more processors of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be stored in a computer-readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable memory produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operations to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus implement the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","As may be used herein, the term \u201ccoupled\u201d includes both a direct electrical connection between blocks or components and an indirect electrical connection between blocks or components achieved using one or more intervening blocks or components. As used herein, the term \u201ctask\u201d is synonymous with a user application. As may be used herein, a \u2018direct LAPI user\u2019 is a user that codes directly to a low-level application programming interface (LAPI) layer and an \u2018indirect LAPI user\u2019 is a user that codes to a non-LAPI layer (e.g., a message passing interface (MPI) layer). As is used herein, the term \u2018job\u2019 refers to a collection of related tasks. While the discussion herein focuses on implementing the disclosed techniques in conjunction with a LAPI framework, it should be appreciated that the disclosed techniques are not so limited and may be implemented in conjunction with a wide variety of frameworks.","As noted above, traditionally, debugging code has been difficult without adding traces to an application and shared libraries that the application invokes. While signal handling may be employed to invoke a user function (i.e., trigger a predefined behavior from outside an application), signal handling is limited in that an invoked function cannot pass arguments (or parameters). Moreover, a signal handler is limited in that only a single signal can be handled by a single registered function. Furthermore, when conventional signal handlers are employed, adding new functions to an application without re-compiling the application is complicated. While the problems associated with using conventional signal handlers may be addressed using environment variables or files, the use of an environment variable requires restarting an application in order for a new environment variable to take effect. In addition, employing files can cause resource\/lock issues.","According to various aspects of the present disclosure, a plug-in architecture for application and shared library writers is disclosed that facilitates debugging code without having to re-compile the code with tracing enabled. As disclosed herein, the plug-in architecture is implemented in a low-level application programming interface (LAPI) product. While the discussion herein focuses on implementation in conjunction with a LAPI product, is should be appreciated that the techniques disclosed herein are not limited to implementation in conjunction with a LAPI product.","According to the present disclosure, each user application is configured with an established connection to an application monitoring daemon (also referred to as a protocol network services daemon (PNSD)). The daemon acts as an agent to forward commands (e.g., pnsd_trigger) to applications from an outside process (i.e., a process executing outside the applications). According to the present disclosure, a user can register any number of callback\/trigger functions (which can implement debugging or non-debugging functions) using interfaces provided by a LAPI product. In various embodiments, a user issues a command with a name of a callback function and any number (zero or more) of arguments (through the daemon) to a task. A designated task then executes the specified callback function with the provided parameters. Following execution of the callback function, results of the callback function may then be returned to the outside process.","The daemon may also be configured to act as a data\/status gathering and storage device (e.g., to store execution statistics of an application that can be redirected to a user designated file or displayed on a console). For example, a set of application programming interfaces (APIs) may be implemented that allows a user to create and register callback functions. The registered callback functions can be invoked through the LAPI framework at runtime to, for example, alter a behavior of an associated application. A user may, for example, utilize an external command to load a new functional module into an application that is executing. The functional module (e.g., a debug module) may then be invoked by the external command (or by another external command) that caused the functional module to be loaded into the application.","According to one aspect of the present disclosure, two LAPI utility (LAPI_Util) types are employed to allow a user to add (register) or remove (de-register) callback functions with the LAPI framework. The two LAPI_Util types may take the following form:",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"typedef struct {",{}]},{"entry":[{},{},"lapi_util_type_t Util_type; \/\/ LAPI_TRIGGER_ADD",{}]},{"entry":[{},{},"int (*trigger)(lapi_handle_t hndl, int argc, char",{}]},{"entry":[{},{},"*argv[ ]);",{}]},{"entry":[{},{},"char *trigger_name;",{}]},{"entry":[{},{},"} lapi_trigger_util_t;",{}]},{"entry":[{},{},"typedef struct {",{}]},{"entry":[{},{},"lapi_util_type_t Util_type; \/\/ LAPI_TRIGGER_REMOVE",{}]},{"entry":[{},{},"int (*trigger)(lapi_handle_t hndl, int argc, char",{}]},{"entry":[{},{},"*argv[ ]);",{}]},{"entry":[{},{},"char *trigger_name;",{}]},{"entry":[{},{},"} lapi_trigger_util_t;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"A command is also implemented to trigger runtime behavior of the LAPI tasks. For example, a command (pnsd_trigger) may take the following form:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pnsd_trigger -h",{}]},{"entry":[{},"pnsd_trigger [-v] [-d] job_id",{}]},{"entry":[{},"pnsd_trigger [-v] [-l] job_id",{}]},{"entry":[{},"pnsd_trigger [-v] [-t timeout] -j job_id trigger_name [argument ...]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"It should be appreciated that the techniques disclosed herein that are employed to load an external module into an application are different from approaches that load an external module employed in conventional plug-in style applications. For example, in conventional plug-in style applications (e.g., Firefox\u2122), an application decides when and how to load a new module. In contrast, according to the present disclosure, a new module is loaded by an application according to a command sent from an outside process. The command may be, for example, sent from a user generated debug console that interfaces with the LAPI framework.","According to one or more embodiments, when a task terminates, a connection is made to the daemon to save statistics and the information to identify the statistics for later query is displayed. When the daemon receives and saves the statistics from the task, the daemon may also accumulate the statistics for an associated job, user, and node. After a job has finished, a user may query statistics with a command (e.g., pnsd_stat) by specifying a task or a job. The user may also query aggregated user and\/or node statistics.","With reference to , an example node  of an HPC cluster is illustrated that includes one or more chip-level multiprocessors (CMPs) , each of which includes multiple (e.g., two to eight processor cores) processors . The processors  may, for example, operate in a simultaneous multithreading (SMT) mode or a single thread (ST) mode. When the processors  operate in the SMT mode, the processors  may employ multiple separate instruction fetch address registers to store program counters for multiple threads. In at least one embodiment, the processors  each include a first level (L1) cache memory (not separately shown in ) that is coupled to a shared second level (L2) cache memory (cache) , which is coupled to a shared third level (L3) cache  and a fabric controller .","As is illustrated, the fabric controller  is coupled to a memory controller (e.g., included in a Northbridge) , which is coupled to a memory subsystem . In alternative embodiments, the fabric controller  may be omitted and, in this case, the L2 cache  may be directly connected to the main memory controller . The memory subsystem  includes an application appropriate amount of volatile and non-volatile memory. The fabric controller , when implemented, facilitates communication between different CMPs and between the processors  and the memory subsystem  and, in this manner, functions as an interface.","It should be appreciated that the various techniques disclosed herein are equally applicable to systems that employ separate L2 caches for each processor, as well as systems that employ separate L2 and L3 caches for each processor. Each of the L1, L2, and L3 caches may be combined instruction and data caches or correspond to separate instruction and data caches. As is shown in , the main memory controller  is also coupled to an I\/O channel controller (e.g., included in a Southbridge) , which is coupled to a host channel adapter (HCA)\/switch(es) block . The HCA\/switch(es) block  includes an HCA and one or more switches that may be utilized to couple the CMP  to CMPs in other nodes (e.g., I\/O subsystem nodes and processor nodes) of the cluster.","With reference to , an example node  (of an HPC cluster) is configured to execute a daemon (PNSD) , tasks (labeled \u2018Task\u2019 through \u2018Taskn\u2019) , and an outside process  (which is external to the tasks ). The outside process  (which may execute on one or more processors of the node ) communicates with the daemon . As is illustrated, the daemon  communicates with the tasks  (via respective control threads  in the tasks ). In this example, the tasks  correspond to user applications that require debugging. In one or more embodiments, the daemon  is configured to handle triggers for multiple jobs, each of which include multiple tasks.","In various disclosed embodiments, the control threads  are respectively incorporated within each of the tasks  and the daemon  is incorporated within a LAPI framework . The control threads  are created (by the LAPI framework ) at initialization to handle interrupts. The control threads  may be, for example, implemented as helper threads within a LAPI communication library (not separately shown). The control threads  invoke a designated callback function (when a trigger is received from the outside process ) and facilitate communication between one or more designated tasks and the daemon .","With reference to , a process  for debugging code during runtime is initiated in block . Next, in block , an outside process (e.g., the outside process  of ) provides a trigger to a daemon (e.g., the daemon  of ), which is included within a LAPI framework. In this case, the trigger is associated with a registered callback function. Then, in block , the daemon (e.g., the daemon  of ) provides the information of the trigger to be invoked to one or more designated tasks of a job (e.g., the tasks  of ). Next, in block , the registered callback function (that is associated with the trigger) is executed by the one or more designated tasks. Then, in block , the tasks return the execution results to the daemon. Next, in block , the daemon relays the execution results to the outside process (e.g., the outside process  of ). Following block , control transfers to block  where the process  terminates and control returns to a calling routine.","Accordingly, a number of techniques have been disclosed herein that facilitate modifying code during runtime without recompiling the code. The techniques are particularly advantageous when employed to modify code to execute one or more debug modules during runtime.","The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises\u201d and\/or \u201ccomprising,\u201d when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.","The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below, if any, are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.","Having thus described the invention of the present application in detail and by reference to preferred embodiments thereof, it will be apparent that modifications and variations are possible without departing from the scope of the invention defined in the appended claims."],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and is not intended to be limited by the accompanying figures, in which like references indicate similar elements. Elements in the figures are illustrated for simplicity and clarity and have not necessarily been drawn to scale.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
