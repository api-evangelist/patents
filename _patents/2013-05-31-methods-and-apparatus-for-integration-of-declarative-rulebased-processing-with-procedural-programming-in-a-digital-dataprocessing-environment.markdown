---
title: Methods and apparatus for integration of declarative rule-based processing with procedural programming in a digital data-processing environment
abstract: The present invention provides methods and systems for integrating a procedural computational model with a declarative computational model. For example, in one aspect, the present invention provides a method for integrating a plurality of procedural instructions in a procedural computational system with a plurality of declarative rules in a declarative computational system. In such a method, for each of the procedural instructions operating on one or more variables, a hash table indexed by variable names is utilized to determine whether any of these variables participate in at least one of the declarative rules. Upon execution of a procedural instruction that changes a variable participating in a declarative rule, other variables associated with the rule are updated so as to maintain a relationship imposed by the rule among the variables. The updating of the other variables is performed prior to execution of other procedural instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08959480&OS=08959480&RS=08959480
owner: Pegasystems Inc.
number: 08959480
owner_city: Cambridge
owner_country: US
publication_date: 20130531
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of U.S. patent application Ser. No. 12\/649,095, filed Dec. 29, 2009, entitled \u201cMETHODS AND APPARATUS FOR INTEGRATION OF DECLARATIVE RULE-BASED PROCESSING WITH PROCEDURAL PROGRAMMING IN A DIGITAL DATA-PROCESSING ENVIRONMENT,\u201d which is a continuation of U.S. patent application Ser. No. 10\/854,017 filed on May 26, 2004, entitled \u201cMETHODS AND APPARATUS FOR INTEGRATION OF DECLARATIVE RULE-BASED PROCESSING WITH PROCEDURAL PROGRAMMING IN A DIGITAL DATA-PROCESSING ENVIRONMENT,\u201d the teachings of which are incorporated herein by reference.","The invention pertains generally to digital data processing and, more particularly, to methods and apparatus for implementation of declarative rule-based systems, and their integration into mainstream computing environments. The invention has application, by way of non-limiting example, in the design and implementation of workflow applications. Such systems typically have object-oriented architectures, and the invention takes advantage of aspects of such architectures, but it is not limited to these.","The vast majority of data processing systems use a procedural-based programming paradigm. This is exemplified by programming languages like C or Java, where execution is controlled by \u201cprocedures\u201d consisting of sequences of statements (assignments, loops, if, etc.). The programmer of such a system is responsible for specifying, in great detail, what this sequence is, and making sure that it is correct. The sequential nature of such systems, and the resulting exponentially large number of execution paths that a system of even moderate size can take, is the fundamental basis for their complexity. It is also the source of most of the very large number of bugs that typically plague such systems.","Declarative rule-based programming is a fundamentally different programming paradigm. It is characterized by the lack of any sequential statements, and any notion of state of which the programmer has to be aware. Instead, processing is specified in the form of logical rules, where each rule relates one or more output variables to a set of input variables. Such rules can be \u201cchained\u201d together so that the output of one rule becomes an input to other rules.","An important characteristic of such a system is that the rules always hold. In other words, the values of the variables are always such that they are consistent with the rules. For example, if a rule states a relation between variables like z=x+y, then the values of x, y, and z are constrained to be such that this relation is never violated. This implies that changes to input variables (x or y in this example) must be propagated \u201cinstantly\u201d so that the corresponding output variables are updated according to the relation. For example, if x=1, y=2, and z=3, and then x is changed to 2, then z must be updated to 4. In this case, \u201cinstantly\u201d means that the update happens before any user, or any processing element outside the declarative programming system, notices an inconsistency.","The primary advantage of a declarative rule-based system is that it allows the programmer to focus on the required behavior of the application by specifying (declaring) invariant logical and arithmetic relations between variables. The complexity related to sequencing and state is hidden from the programmer.","In many applications, declarative rules can be used for solving significant portions of a problem. However, they are usually not appropriate for every aspect of a typical workflow problem. Some things (a sequence of steps to be executed for a work item, for example) are best expressed procedurally.","In view of the foregoing, an object of this invention is to provide improved methods and apparatus for digital data processing and, more particularly, for integrating declarative and procedural programming systems.","Another object of the invention is to provide such integrated computational systems that are relevant to a wide variety of applications, including, for example, modeling and processing workflows.","A related object of the invention is to provide methods and apparatus for improved integration of declarative and procedural programming systems that are suited for integration with systems having object-oriented data architectures.","A further object is to provide such methods and apparatus as can be implemented in a variety of programming languages and\/or on a variety of platforms.","The foregoing are among the objects attained by the invention which provides, in one aspect, methods for entering, maintaining, and executing declarative rules that allow the programmer to express invariant relations, as defined above. The methods further include facilities for entering, maintaining, and executing procedural statements that allow the programmer to specify sequential activity, as defined above. The methods further provide for integration of the declarative and procedural systems such that changes resulting from procedural actions are immediately propagated within the declarative system so that, for all practical purposes, the data is always consistent with the invariant relations specified by the declarative rules.","In one aspect, the invention provides a method for integrating a plurality of procedural instructions in a procedural computational system with a plurality of declarative rules in a declarative computational system. In such a method, for each of the procedural instructions operating on one or more variables, a hash table indexed by variable names is utilized to determine whether any of these variables participate in at least one of the declarative rules. Upon execution of a procedural instruction that changes a variable participating in a declarative rule, other variables associated with the rule are updated so as to maintain a relationship imposed by the rule among the variables. The updating of the other variables is performed prior to execution of other procedural instructions.","In a related aspect, in a method as described above, for each of the updated values, changes associated with the updated variable are propagated to other rules, if any, in which the updated variable participates. The propagation of the change can be accomplished by modifying values of variables other than the updated variable so as to maintain relationships defined by these other rules.","A related aspect of the invention provides methods for efficiently propagating the effects of the changes, according to relevant declarative rules, so that the data is once again consistent with the invariant relations. This propagation is done in a manner such that neither the procedural system, nor the user, is able to detect the temporary inconsistency.","A further aspect of the invention provides methods for distinguishing variables involved in declarative processing (variables that are mentioned in declarative rules) from ones that are not, and for efficiently associating variables involved in declarative processing with the rules in which they are mentioned. This helps minimize the overhead in the procedural system associated with detection and propagation, and thus maximizes efficiency. It also ensures that variables not involved in declarative processing impose no penalty on execution performance of the procedural system. For such variables, execution of the procedural system is no less efficient than it would be for a purely procedural system (one with no declarative rule capability). The overall effect of these methods is that propagation is limited to computation necessary to repair any rule violations.","Other aspects of the invention facilitate use of object-oriented data architectures in the declarative and procedural programming systems. These aspects include methods for efficiently assigning values to variables that are embedded within (represent attributes of) objects, and for matching such variables (which may be embedded many levels deep within a sub-object hierarchy) with relevant rules. These aspects also include methods that allow declarative rules to refer to objects in sophisticated ways, and that propagate effects of changes between objects.","In a related aspect, the invention provides a method of integrating a procedural computational system, which supports object-oriented representation of data in a plurality of objects, with a declarative computational system, which provides rules for defining relationships among the objects. One step of such a method determines, for each object, whether that object participates in any of the declarative rules. Upon execution of a procedural instruction operating on an object that participates in at least one declarative rule to modify data associated with the object, the data modification is propagated to other data in that object, and\/or to data associated with other objects, so as to render data values associated with the declarative rule consistent with the rule definition.","In yet another aspect, the invention provides a method of integrating a procedural computational system, which supports execution of a plurality of procedural instructions operating on one or more variables, with a declarative computational system, which provides a plurality of rules for defining relationships among these variables. The method calls for compiling each procedural instruction corresponding to assignment of a value to a variable participating in a declarative rule so as to effect, upon assignment of a value to the variable at runtime, updating of other variables associated with the declarative rule so as to maintain consistency of a relationship imposed by the rule among the variables.","In other aspects, the invention provides an integrated procedural and declarative computational system that includes a procedural module for executing procedural instructions operating on one or more variables, and a declarative module that is coupled to the procedural module so as to operate on these variables so as to maintain a set of relationships among the variables defined by one or more declarative rules. The system further includes a tracking module that is in communication with the procedural and declarative modules. Upon execution of each of the procedural instructions, the change tracking module detects changes, if any, in one or more variables participating in at least one of the declarative rules and reports the change to the declarative module. In response, the declarative module updates values of other variables participating in the declarative rule so as to maintain a relationship defined by the rule.","Hence, an integrated computational system of the invention allows both declarative and procedural programming styles in a single system. The declarative system can operate in a background mode to ensure that the rules are always true without the need for a workflow architect to insert explicit update requests in the procedural code. Such a capability provides a programmer with unprecedented flexibility in utilizing these two different programming tools without having to be concerned about the details of their integration.","These and other aspects of the invention are evident in the drawings and in the description that follows.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["27","27","28","30","26","32","27","27"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["27","34"]},"Illustrated processing center  represents a service provider or other entity that utilizes work item routing. Non-limiting examples include retailers, mail order houses, professional service providers, counseling centers, and \u201chelp\u201d bureaus, and so forth. While work item typically refers to tasks processed by the resources or to which resources may be allocated, as used herein the term refers to tasks, products, customer or other things for processing by the resources or to which resources may be allocated.","With continued reference to , the illustrated work items comprise customer requests  that require routing (or assignment) to employee-agents of the processing center . More generally, the illustrated agents represent any resource to which the \u201cwork items\u201d may be allocated. This can include human resources, business resources, environmental resources, energy resources, consumable resources, or otherwise. The illustrated work items\u2014here, customer requests\u2014are processed in the manner described in the aforementioned, incorporated-by-reference application. Thus, for example, requests or other work items received by the processing center  are subject to intake processing, e.g., by intake processing personnel and, then, are passed to digital data processor A for routing to the agents (or other resources).","Architecture for Integrated Declarative\/Procedural System",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3","FIG. 3"],"b":["42","44","46"]},"The declarative rule system  also reads and writes variable values, but the execution is more specialized. Declarative rules are compiled by a rule compiler  into a dependency network  and execution code  for each rule, as described in more detail below. The dependency network is an efficient representation of the rules, which is suitable for interpretation by a rule interpreter . The rule interpreter can utilize the dependency network to determine the correct sequence in which the declarative rules need to be executed. It also uses the dependency network to determine the subset of rules that need to be executed when there is a change (typically, a very small subset of all the rules needs to be executed in response to a change). It may also use the dependency network to determine additional objects that may have to be loaded into virtual memory from persistent storage.","A change tracking system  detects a change of a variable value caused by execution of an assignment statement in the procedural system. Before the next statement is executed, the change tracking system notifies the declarative rule system of the change. An inference engine determines a sub-network, within the dependency network, that is associated with the change. The inference engine uses this sub-network to determine the rules that need to be executed in response to the change, and the correct sorting of these rules. It then executes these rules, thus removing any inconsistency in the data resulting from the change made by the procedural system. The procedural system then executes its next statement.","Operation of the various components shown in  is now explained in more detail. In particular, the procedural and declarative programming systems are described in detail, along with the change-tracking system. Additionally, the widely used object-oriented data representation is discussed. For each of these components, definitions of important terms are given, together with explanatory diagrams and examples. The definitions are primarily for the purpose of describing the invention, and are not intended to be limiting of the scope of the invention. In most cases, the definitions correspond to industry-standard terminology. However, some of the definitions are specific to this invention, and are made primarily for convenience of describing the invention.","Procedural Programming System","For the most part, the definitions introduced in this section are based on standards and conventions used in most popular procedural programming languages (C, for example). Structured data types (arrays, structures, objects, etc.) are not covered in this section as they are not central to this discussion. Object representations are covered separately in a subsequent section.","EXAMPLE 1 below shows an exemplary listing of a typical procedural program which illustrates many important features of procedural programming systems. In this example, the function compute_order takes parameters for product, quantity, store_location, monthly_payment, and number_of_payments. It computes a price before tax based on product and quantity. It then calls compute_order_tax to compute a tax based on the state in which the store where the purchase is made is located. Compute_order then adds this tax to compute total price. Finally, it iterates over number_of_payments to compute the remaining balance after this number of payments, using a fixed monthly interest rate of 0.5%. This remaining balance is returned. Note that prices are in cents, so integer variables can be used to represent prices.","This simple program illustrates many of the key features of procedural programming systems including variables and constants with different data types (price_before_tax and principal, for example), operators, expressions, and assignment statements (price_before_tax=product_price*quantity, for example), control flow statements (the if statements and for iteration), and the use of functions (compute_order calls the function compute_order_tax). These terms are now defined more formally.","Data Type\u2014","A data type specifies the format and memory allocation requirements for a datum. It also constrains the operations that can be performed using that datum. Basic data types include boolean, character, string, integer, and float.","Example: int","Constant\u2014","A constant is an unchanging datum. For example, 5 is an integer constant, \u2018a\u2019 is a character constant, and 3.7 is a float constant.","Example: \u201cflashlight\u201d","Variable\u2014","A variable is a datum of a particular type that may change. The datum is referenced by a variable name. Variables can be any one of the basic data types.","Example: int product_price;","Operator\u2014","Operators produce values based on a set of arguments. Operators can be categorized according to the types of their arguments, and the types of the values they return. For example, arithmetic operators, such as +, \u2212, *, and \/, take arithmetic arguments (integer or float) and return an arithmetic result. Relational operators like >, <, =, and !=take arithmetic arguments and return Boolean values. Logical operators, such as \u201cand\u201d, \u201cor\u201d, and \u201cnot,\u201d take boolean arguments and return boolean values.","Expression\u2014","An expression is a combination of operators with associated variable and\/or constant arguments.","Examples:\n\n5\u2003\u2003(arithmetic expression)\n\nand \u2003\u2003(logical expression)\n\n5\u2003\u2003(relational expression)\n\nproduct_price*quantity\u2003\u2003(arithmetic expression)\n\nStatement\u2014\n","A statement is the most basic building block for procedural processing. There are different kinds of statements. One of the most basic is the assignment statement, which sets the value of a variable to the result of an expression.","Examples:\n\n5;\n\nprice_before_tax=product_price*quantity;\n","The end of a statement is indicated by a semicolon in many languages.","Note that the procedural programming system does no processing between statements. That is; variables can be changed or accessed only within statements. Suppose that the procedural system executes an assignment statement that sets a variable in such a way that one of the declarative rules is no longer consistent. If the declarative system performs necessary update computations immediately after this statement, and before the next procedural statement is executed, then the system is consistent once again. In other words, the consistency of the declarative rules is restored before the procedural system has any chance to notice any inconsistency. Thus, if declarative processing is performed between procedural statements, it is possible to give the illusion to the procedural system that declarative rules are always true.","Control Flow Statements\u2014","A number of different kinds of statements are useful for controlling flow of processing in a procedural language. These statements, when combined with appropriate state variables (counters, for example), update these state variables, and guide processing based on these state variables.","Examples: if statement",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (x > 5)"]},{"entry":[{},"\u2003\u2003\u2003z = 5;"]},{"entry":[{},"else"]},{"entry":[{},"\u2003\u2003\u2003z = x;"]},{"entry":[{},"if (product == \u201cflashlight\u201d)"]},{"entry":[{},"\u2003\u2003\u2003product_price = 500;"]},{"entry":[{},"else if (product == \u201cbattery\u201d)"]},{"entry":[{},"\u2003\u2003\u2003product_price = 100;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"for (x=0; x<x_max; ++x)"},{"entry":"\u2003\u2003\u2003z = z * x;"},{"entry":"for (i=1; i<=number_of_payments; ++i)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003principal = round(principal +"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003principal * monthly_interest \u2212 monthly_payment);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"while (x<x_max)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003y = y * x;"]},{"entry":[{},"\u2003\u2003\u2003x = x + y;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The brackets indicate a set of statements to execute within the body of the while loop.","Functions\u2014","Functions provide a mechanism for re-using code; allowing a useful fragment of code to be invoked from many places in a program. A function has a name, a set of parameters, and a body that consists of a set of statements that do computation based on the parameters. The function is called using the function name, along with a set of values for the parameters.","Examples:\n\n=sqrt();\n\ntax=compute_order_tax(price_before_tax,store_location);\n","By way of example, conventional work flow systems can be viewed as specialized procedural systems in which performance of a step in work flow processing corresponds to execution of a procedural statement.","Object Representation","This invention can be used for programming systems that do not use object representations (that use unstructured variables only). However, the vast majority of practical implementations use some form of structured data, and it is for such systems that the invention provides the most benefit.","Note that, for the most part, the definitions that follow are based on standards and conventions used in most popular object-oriented programming languages (like Java or C++). Note also that these definitions do not imply any particular implementation. They merely specify requirements for the implementation, and thus impose some constraints. However, there is still significant implementation flexibility, and some implementations may be more efficient than others.","Class\u2014","A class is a type specification for a structured data collection called an object. The type specification is represented as a set of elements. A class has a unique name that distinguishes it from other classes and objects.","Element\u2014","An element has a name as well as information associated with that name. There are two types of elements: data elements, and methods. A data element (also known as a property) contains a data type specification, and a data value. For elements that are part of a class specification, this value is the default value (the initial value for the element when an object of the class is instantiated). A method element contains a reference to a function, as well as type specification information for the parameters of the function, and the values returned by the function.","Object\u2014","An object is a structured data collection containing a set of elements, and some other information. An object is created (or instantiated) according to a specification from a particular class. A possible implementation of such an instantiation would be to simply copy the elements of the class to the object. An object maintains a reference to its associated class. An object is also given a unique name. That is; its name is different from that of any other object, regardless of class. An object is given the name when it is instantiated. An object may also be deleted, at which time, its resources (memory used, and unique id) are recycled to pools from which they may be re-used.","Sub-Objects\u2014","A property (data element) of an object may, itself, be an object. An object contained in a property of another object is called a sub-object of the containing object. A property of an object may also contain a set of sub-objects.","Related Objects\u2014","A property of an object may contain a reference to another, related object. This is distinct from the notion of a sub-object in that the property contains a reference to the related object rather than the complete information for the object, as is the case with a sub-object. For example, suppose an object, A1, contains a sub-object, B1, and a reference to a related object C1. The related object C1 can exist independently of A1, but B1 cannot. Thus, if A1 is deleted, B1 will be also deleted because its memory is allocated as part of A1. However, C1 will not be deleted.","Inheritance\u2014","A class may define its own elements. A class may also, optionally, have a superior class, from which it inherits elements. Thus, when an object of the class is instantiated, it will have elements defined by its associated class, as well as elements inherited from the class' superior class, if such a superior class exists. If an element defined for a class has the same name as an element inherited by the class, the element defined for the class is used, and the inherited element is ignored.","Data Access and Set Methods\u2014",{"@attributes":{"id":"p-0071","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["A class can be retrieved by using its name as a key.","An object can be retrieved by using its name as a key.","A data element of an object or class can be retrieved by using the object or class name, followed by the data element name. The two names are separated by the delimiter \u201c.\u201d\n        \n        ","When a data element contains a set of sub-objects, or a set of related objects, elements of the set can be accessed using an index specified in parentheses after the data element name.\n        \n        ","A BNF grammar for data element (property) designation is given in EXAMPLE 4 below. Exemplary object configurations and property designations using this grammar are given in EXAMPLE 5 below.","A data element of an object or class can be set using the \u201c=\u201d operator. The left side must be a property designation using class or object name followed by element name, as described above. The right side must contain a data value that is consistent with the type specification for the data element.\n        \n        ","A method is invoked using the object or class name, followed by the method element name. Parameters are provided within parentheses.\n        \n        ","Values returned by functions can be used to set data elements using the above-described syntax\n        \n        "]}}}},"An object can be created (instantiated) using a global create method that takes, as parameters, the class and the name for the object. Optionally, data element name-value pairs can be included as parameters to this method for the purpose of initializing the named data elements to the values, as long as these values are consistent with the class-specified data types for the data elements. Also, optionally, constructor methods that take zero or more arguments can be specified at the class level. The constructor methods are invoked after memory for the object is allocated, and its data elements are initialized to their default values.","An object can be deleted using a global delete method that takes, as parameter, the name of the object. When an object is deleted, its resources (allocated memory, and unique id) are recycled to pools from which they may be re-used. It is the responsibility of the developer to delete any outstanding references to this object (from other objects, for example).","Object Persistence\u2014","In a typical object-oriented system, object instances exist in the virtual memory space of the computer's operating system. Objects in virtual memory can easily be accessed and modified by application algorithms (declarative or procedural). The virtual memory representation is used for all computations, both declarative and procedural, that modify data elements of objects. Virtual memory is, however, volatile. For example, when the computer's operating system shuts down, virtual memory is reset, and any objects in it are lost. To prevent this, objects must be made persistent. That is; the transient objects residing in virtual memory must be saved to persistent memory. This is typically achieved using a database and a suitable API that supports load and save operations on objects.","Object Load and Save\u2014","A load operation can load an object into virtual memory from a database. The load operation takes the object's name as a parameter and uses the name to find the object in the database. The object's name must be unique within the database. After the object is loaded into virtual memory, it is identified within virtual memory by this same name. A save operation saves the object from virtual memory to a database (to persistent storage). The save operation also takes the object's name as a parameter and uses this to locate the object in virtual memory, and to associate the object with this name in the database.","In typical procedural programs, object loads and saves are performed explicitly, as part of the program. Thus, the programmer is responsible for loading any objects needed in a computation before the computation is performed, and for saving the objects that have changed after the computation has been performed.","The same approach is used for declarative processing systems when it is known that all computations will be restricted to a single, particular object. Consider, for example, the following declarative rule (see also related property designation examples in EXAMPLE 5):\n\nOrder.TotalCost=Sum(Order.OrderItems(*).Cost)\n","This rule can be applied to any object of class Order (it could be applied to the object Order-1 in EXAMPLE 5, for example). The object to which the rule is applied is called the context object. The rule computes the TotalCost property of the Order context object by summing the costs of individual order items. If the OrderItems property contains a set of sub-objects, then all computations performed by this rule are restricted to the context object. If all rules in a dependency network have the same context object, all computations in the declarative system defined by the dependency network are restricted to that context object. This important special case is referred to here as the single object context case. The case where computation is not restricted in this way is referred to here as the multiple object context case. In the previous exemplary rule, if the OrderItems property contains a set of related objects, rather than a set of sub-objects, then computation is not restricted to a single context object. In other words; computation is performed using multiple related objects.","For the single object context case, load and save of the object can be accomplished by using a procedural program that wraps the declarative processing with appropriate loads and saves of the object. In a typical scenario, the procedural program loads the object, and then performs some computations on the object. These computations may result in changes to the object, requiring declarative processing to propagate the changes. After the declarative processing is completed, procedural processing resumes and ultimately saves the object.","The multiple object context case is more complicated. Although procedural processing may begin with one object, the declarative processing, if it uses rules that span related objects, will require other objects to be loaded from the database. In the previous exemplary rule, if the OrderItems property contains a set of related objects, rather than a set of sub-objects, the rule spans multiple objects. Execution of the rule requires a multiple object context.","Suppose that the rule system begins with the goal of computing the TotalCost property of Order-1, and would like to use the above exemplary rule. Suppose that Order-1 is loaded into virtual memory, but that the related objects in the OrderItems property are not. The rule system must then first load these related objects before executing the rule.","Alternatively, suppose that the procedural system has just changed the Cost property of an OrderItem object (let us call this OrderItem-1), and that the declarative rule system is invoked to propagate changes according to rules. The rule system first needs to check whether the above exemplary rule even applies. This is because the OrderItem object that was changed may not fit the pattern required by the rule. The rule states that the OrderItem object in question must be a member of the set of related objects in the OrderItems property of an Order object. If this is not the case, then the rule should not be used. For example, if OrderItem-1 is a free-standing object, i.e., an object not related in any way to any other object, the rule does not apply.","The manner in which the rule pattern is checked can depend on the details of the object relation structure. To check if OrderItem-1 is referred to in the OrderItems property, a relation that is the inverse of OrderItems is used. For example, the OrderItem class can be given an additional property called ParentOrder. OrderItem instances that are referred to in the OrderItems property of an Order would have a reference to that Order in their ParentOrder property. OrderItem instances that are not referred to in this way would have a null reference in their ParentOrder property. With this property, the rule system can easily check whether OrderItem-1 fits the pattern required by the rule.","If OrderItem-1 does fit the pattern, the rule system uses the ParentOrder property to reference the corresponding Order and load it into virtual memory if necessary. It then uses the OrderItems property of the order to load all the other OrderItem instances needed. When this is done, the complete multiple object context is available, and the rule can be executed.","It is difficult for the programmer (of the procedural or declarative system) to determine, explicitly for all possible situations, all objects that may have to be loaded in this way from the database. Therefore, it is preferable to determine this automatically. This can be accomplished by the rule compiler, which parses context information from rules, and generates code that loads required missing objects for any situation that may be encountered. This will be discussed in more detail in the subsequent section on declarative rules.","Databases for Object Persistence\u2014","The illustrated system can utilize the following approaches for persistent object storage: 1) converting the objects into normalized tabular form and storing them in a relational database, and 2) converting them into an XML (Extensible Markup Language) format, and storing them in an XML document. These two approaches can also be combined; XML formatted data can be stored in relational database tables. Databases designed specifically for storing objects are also commercially available, but these do not typically enjoy the immense popularity of relational databases and XML, partly due to their complexity. The most typical representation of objects in a relational database is as \u201cnormalized\u201d tables. In this representation, each object class has its own table within the relational database. Each row of such a table corresponds to an object instance. The first column of such a table is typically the object name. Subsequent columns correspond to scalar properties of the object. Properties containing sets (of sub-objects, or references to related objects) are not represented in the table at all! Instead, the tables corresponding to the sub-object or related object class have columns for \u201cparent\u201d object. Thus, the information about the object\/sub-object relation is stored with the sub-object, not the parent. EXAMPLE 6 below shows the exemplary object configuration from EXAMPLE 5 represented in this normalized form.","Retrieving all the information for a particular object requires the equivalent of a database \u201cjoin\u201d operation. This can be accomplished by using an SQL query that specifies tables to be included. For example, to retrieve all Order-Item instances for an Order, the query must specify that Order-Item.ParentOrder=Order.Name. A database join can combine information from different tables into one new table. For purposes of loading an object from the database into virtual memory, the actual join (creation of the new table) is unnecessary. Typically, the information from the various tables found by the query is used to directly create the object in virtual memory.","Table structure in a relational database can be defined by employing \u201cschemas\u201d, which are analogous to object class definitions.","Conversion to XML is relatively straightforward because XML is designed for storing persistent objects. EXAMPLE 7 shows the exemplary object configuration from EXAMPLE 5 represented in XML form. Note that with the XML representation, sub-object information is stored within the parent object, so there is no need to perform a join.","The structure of XML documents can be defined using a \u201cDocument Type Definition\u201d, which is analogous to an object class definition. XSL (Extensible Style Language) patterns can be used to query XML-structured data. This is useful for loading into virtual memory particular objects that meet certain criteria.","Declarative Programming Systems","Standards for declarative systems are not as well developed as they are for procedural systems. Therefore, the definitions introduced in this section are not necessarily based on any industry standards. The definitions are introduced primarily to help explain the invention, and not to track evolving standards.","Declarative Programming System\u2014","A declarative programming system typically includes a set of declarative rules, a set of associated variables, and a rule interpreter that computes values for the variables based on the rules (see ).","Declarative Rule\u2014","A declarative rule states a relation between a set of variables that is always true. Although a declarative rule can have the same format as an assignment statement, its behavior is very different. Whereas an assignment statement makes the assignment as a procedural step (at one point in time), a declarative rule ensures that the relationship is always true. There is no notion of processing or state; it is \u201ctimeless\u201d. It specifies an invariant relation.","A declarative rule may have many forms. Often, declarative rules are expressed as a formula or equation as in\n\n105\n\nor\n\n\n\nDeclarative rules are also, often, expressed as \u201cif-then\u201d relations, as in\n","if light_switch_on and (not light_broken) then light_on","Note that besides the expression-based rules shown in the above examples, declarative relations can also be expressed by using tables, or even procedures. If the computation is performed by a procedure, it must ensure that the output is always deterministic, based on the input variables. Thus, the procedure must base its computations solely on the input parameters, and is not allowed to access any external variables that may introduce state and non-deterministic behavior.","Note also that object representations can be accommodated by such rules, as in\n\nloan.payment=loan.principal*loan.interest\n\nairplane.weight=airplane.empty_weight+sum(airplane.passangers.weight)\n\nRule Compiler\u2014\n","A rule compiler, such as the rule compiler  shown in , parses rules according to a grammar such as the one shown in EXAMPLE 15 below. The parsing may be accomplished by any standard parser; an ATN parser, for example.","The compiler generates code that performs the computation of the rule. This can include context generation code as well as rule body execution code. Context generation code checks whether the object to which the rule is being applied fits the pattern of objects required by the rule (as specified in the rule's context specification). Context generation code also loads any missing required objects from persistent storage. For example, consider the second exemplary rule shown in EXAMPLE 15. Suppose that the Quantity property of an instance of class OrderItem changes. The rule may, or may not, be applicable. The context generation code begins with the focus object (in this case, the instance of OrderItem) and checks if the ConfiguredProduct property of this object refers to an instance of class ConfiguredProduct. If it does not, then the match fails, and the rule cannot be executed. Otherwise, the rule can be executed, but the ConfiguredProduct instance must be loaded from persistent storage if it is not already resident in memory. Now, suppose that the Cost property of an instance of class ConfiguredProduct changes. Again, the rule may, or may not, be applicable. The focus object is not the instance of ConfiguredProduct. The context generation code begins with this focus object and checks if its ParentOrderItem property (inverse of ConfiguredProduct property) refers to an instance of class OrderItem. If so, the rule may be executed. Again, it may be necessary for the context generation code to load the OrderItem instance from persistent storage.","The rule compiler generates context generation code based on the context specification in the rule (see EXAMPLE 15). The generated code covers all possible focus object situations that may arise. In the second exemplary rule in EXAMPLE 15, the focus object may be an instance of ConfiguredProduct, or an instance of OrderItem. In the former case, the corresponding instance of OrderItem must be loaded to complete the context. In the latter case, the corresponding instance of ConfiguredProduct must be loaded to complete the context. If the context cannot be completed, the pattern match fails, and the rule cannot be executed.","The rule compiler also generates rule body execution code (code corresponding to the rule body). This code assumes all context objects have been loaded, and it performs the actual computation of the rule, computing a new value for a property of one of the context objects based on properties in all the context objects.","The code generated by the rule compiler may be in Java, C, or any other language suitable for processing by the rule interpreter (see below). The rule compiler also generates a dependency network; which is a graph that represents, in an efficient form, the dependencies between variables and rules. The dependency network can be used to determine input and output variables of rules, and rules that compute and use variables. The rule interpreter can utilize this information to determine a subset of rules that need to be executed when a variable changes, and to determine the correct execution sequence for the rules. An exemplary dependency network is shown in .","Rule Interpreter\u2014","A rule interpreter, such as the rule interpreter  shown in , can represent an algorithm that reads the rules in a declarative programming system and uses them to compute values for the variables mentioned in the rules. Such algorithms can include, for example, inference engines, equation solvers, and a large variety of optimizers. A rule interpreter performs computations that ensure that declarative rules are always true. Thus, if a variable is assigned a new value (by a procedural statement, for example), that new value might cause a violation of a declarative rule. The rule interpreter is run by passing it the set of variables that have changed. The rule interpreter employs the declarative rules to propagate the effects of those changes. It performs this processing until all declarative rules are consistent once again.","EXAMPLE 8 below shows a simple exemplary declarative rule set for computing a monthly payment. Rule 1 computes price_before_tax based on product_price and quantity. Rule 2 computes price based on price_before_tax and tax_rate. Rule 3 computes monthly_payment based on price and number_of_payments. The rules in this example all have an important, common characteristic: they all express a mapping from a set of input variables to a single output variable. They are a special case of declarative rule that is defined here as a \u201csimple formula\u201d.","Simple Formula\u2014","A \u201csimple formulat\u201d is a type of declarative rule that expresses a mapping from a set of input variables to one output variable. The output variable cannot be a member of the set of input variables.","Rule systems consisting only of simple formulas are important because they can be used for a wide range of applications, and because rule interpreters can take advantage of their special characteristics in order to simplify and speed up variable value computation. A declarative programming system consisting only of simple formulas is defined in the following way.","Simple Formula Declarative System\u2014","A type of declarative programming system having the following characteristics:",{"@attributes":{"id":"p-0107","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":{"@attributes":{"id":"ul0010-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":["all rules are simple formulas","any variable has, at most, one formula that computes its value","the overall rule system has well-defined input and output variables\n        \n        "]}}}},"EXAMPLE 8 below illustrates a simple formula declarative system. Note that the outputs of some rules can serve as inputs to others. This leads to the notion of a dependency network; a graph that represents the dependency between variables and rules.  depicts the dependency network for the exemplary rule set of EXAMPLE 8. The input variables for this dependency network are product_price, quantity, tax_rate, and number of payments. The output variable is monthly_payment. The arrows indicate input\/output directionality of the rules.","The rules and variables in the network shown in  form a directed acyclic graph (DAG). In a DAG, the arcs are all directed, and there are no loops. The dependency network for a simple formula declarative system is always a DAG. This has important implications for the rule interpreter. In particular, elements of a DAG can always be sorted into a linear list so that order dependencies expressed in the DAG are preserved. This sort operation is an important part of what the rule interpreter must do. When an input variable changes, the rule interpreter must determine which rules (typically a subset of all the rules in the dependency network) must be executed, and what their execution sequence should be. Once this is done, the actual execution of the rules is straightforward. For example, if product_price changes, all 3 rules need to be executed in the following sequence: (Rule1 Rule2 Rule3). If only tax_rate changes, then the execution list is (Rule2 Rule3). If only number_of_payments changes, then the execution list is (Rule3).","The rule interpreter can generate the execution list by using the recursive algorithm shown in EXAMPLE 9 below. With appropriate node pointer implementation, the algorithm is fast. Such pointers allow for the insertion operation (in insert_current_list) to be performed in a single step. The flag, which indicates that a node is in the execution list, allows for a fast check (rather than searching through the list). Thus, the algorithm can be implemented so that its performance is of order N, where N is the number of nodes in the DAG. The speed is therefore roughly linearly proportional to the number of nodes in the DAG. Note that with this algorithm, variable nodes, as well as rule nodes, are inserted into the execution list, but they can easily be pruned or skipped.","For any change in a variable in the dependency network, this algorithm searches forward in the DAG, and extracts the relevant sub-network corresponding to rules that must be executed. EXAMPLE 10 below shows the call sequence, and the execution list, at each step in the algorithm for a change to the variable tax_rate in the exemplary DAG of .",{"@attributes":{"id":"p-0112","num":"0130"},"figref":"FIG. 5"},"The algorithm described above can be applied repeatedly, when more than one variable is changed, to compute an execution list that takes all changes into account. For example, if both variables A and B in  change, the algorithm can be called once for the change in variable A, and then again for the change in variable B. The second call will add appropriately to the execution list. In this case, nothing has to be added (all rules are already being executed). Generally, however, there will be additions.","This approach allows the rule interpreter to generate an execution list, and then, possibly, defer the actual rule execution, which is typically far more computationally intensive than generation of the execution list, until a later time. This can be advantageous for the following reasons. In certain applications, values of variables affected by the changed variable may not immediately be needed (the values may not have to be accessed by other code in the application for some time after the change). In some cases, they may never be needed, or they may not be needed for a long time. In such situations, it is often better to defer rule execution until the time when a variable is actually needed. This allows utilizing algorithms that tailor the rule execution to limit it to only those variables that are needed. Also, this deferral allows changes to accumulate, which can save rule executions. In the dependency network of , each of the changes to variables A and B requires execution of every rule in the network. Thus, waiting for both to change, instead of executing after each individual change, cuts the number of rule executions in half. Of course, it is not always possible to defer execution because deferring execution leaves the system in an inconsistent state, where some rules may be violated. In the previous example, if the effects of the change to variable A are needed immediately after the change, and before the change to variable B, then rule execution must happen after the change to variable A.","Although deferral of rule execution may be possible, deferral of update of the execution list is not. In the previous example, if variable A is changed, it is important to note, immediately, the variables affected by the change, even if rule execution is deferred. The presence of the variables in the execution list at the end of EXAMPLE 11 indicates that they all need to be recomputed in response to the change to variable A.","Propagation for simple formula declarative systems is relatively simple and efficient. Unfortunately, simple formula declarative systems are not adequate for all applications. For such applications, some of the restrictions on simple formula declarative systems have to be lifted. This results in a more complicated system, with more complex rule interpretation. One such type of system is the Multiple-source Directional Declarative System, described below.","Multiple-Source Directional Declarative System\u2014","A type of declarative programming system having the following characteristics:",{"@attributes":{"id":"p-0117","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["Rules are mapping from set of input variables to set of output variables","An output variable cannot appear in the set of input variables","A variable's value may be computed by more than one rule\n        \n        ","Any variable in the system can be set by other means (direct user input, for example)","A variable's value may be \u201cunknown\u201d\n        \n        ","Loops in dependency network can exist, and must be dealt with appropriately."]}}}},"EXAMPLE 12 below shows an exemplary set of rules, and  shows an associated dependency network, for a multiple-source directional declarative system. The example is a diagnostic system, which is a common application for multiple-source directional declarative system. The rules are all \u201cif-then\u201d rules that operate on boolean variables. This is a typical form for this type of application, but more general rule forms and variable types are possible as well.","The fact that zero, one, or possibly more than one rule may produce a value for a variable drastically complicates matters for the rule interpreter.","The fact that rules may fail to produce a value for a variable means that all variables, regardless of type, must include a representation of the value \u201cunknown\u201d in their domains. Thus, for example, boolean variables can have values true or false, or they may have the value unknown. Similarly, integer variables can have an integer value, or the value unknown. This complicates variable value computation. The simple sort and execute algorithm used for simple formula declarative systems is not adequate here. To see why this is so, consider EXAMPLE 12. Suppose that initially, light_on is false, light_switch_on is true, and switch_wire_loose is false, so Rule 1 is used to conclude that light_switch_broken is true. Now, suppose that the variable light_on changes to true. The sort algorithm for simple formula declarative systems would put Rule 1 on the execution list. However, execution of Rule 1 has no effect. Because light_on is now true, the antecedent of Rule 1 fails, and no conclusion is made. The value of light_switch_broken is unchanged; it is still true. This is incorrect. Its value should be unknown.","For this type of system, the correct approach is to first retract values of variables that are affected by a change, and to set their values to unknown. After that, the value of each such variable is recomputed by searching backwards in the dependency network to find all rules that are involved with computing a value for that variable. An exemplary algorithm for performing this task is summarized in EXAMPLE 13. Note that this algorithm uses a combination of forward and backward search of the dependency network. It performs a forward search, similar to that used for simple formula declarative systems, to identify variables that are affected by a particular variable change. For each such affected variable, it performs a backward search to find rules involved with computing its value.","In EXAMPLE 12 (See also ), when light_on becomes true (as discussed above), the algorithm of EXAMPLE 13 first retracts the value of light_switch_broken and sets it to unknown. It then puts Rule 1 and Rule 2 on the execution list, since both of these can compute values for light_switch_broken. It then executes these rules. In the scenario described above, neither rule succeeds, and the value of light_switch_broken remains unknown.","The fact that rules may produce more than one value for a variable also creates complications. If the rules all produce the same value for the variable, then everything is consistent, and there is no problem. However, if they produce different values, then there is an inconsistency (sometimes also called an infeasibility). Suppose Rule 1 in EXAMPLE 12 were modified as follows:","Rule 1:",{"@attributes":{"id":"p-0124","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ( (not light_on) and light_switch_on)"]},{"entry":[{},"\u2003\u2003\u2003then light_switch_broken"]},{"entry":[{},"\u2003\u2003\u2003else (not light_switch_broken)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Now, suppose that light_on is true, light_switch_on is true, and switch_wire_loose is also true. Rule 1 will compute false for light_switch_broken, and Rule 2 will compute true. There is an inconsistency, which typically means there is a bug either in the rule set, or in the inputs. In this case, it would make sense to inspect the switch wire closely to see if it is really loose.","The rule interpreter deals with inconsistencies of this sort by warning the user, and providing information about the rules and input variables that cause the conflict. The user then has the option of changing the variables or rules until the conflict disappears.","Another complication with multiple-source directional declarative systems is that logical loops can occur in the dependency network. This does not necessarily indicate a bug in the rule set. In fact, such loops are sometimes perfectly reasonable and useful. Consider the exemplary rule set shown in EXAMPLE 14 and . This rule set is perfectly logical and reasonable. However, the resulting dependency network is not a DAG. Hence, it will cause problems for the algorithm given in EXAMPLE 13.","The problem is resolved by converting the dependency network to a DAG by utilizing, for example, the notion of a well_founded support. A variable cannot be a well_founded support for itself, but it can be a well_founded support for another variable. Thus, in EXAMPLE 14, light_switch_on and light_on are well_founded supports for light_switch_broken. The algorithm that converts the dependency network of EXAMPLE 14 into a DAG searches backward from each variable, finding its well-founded supports. The search stops when there are no input rules for a variable, or when a loop is detected (when a variable already in the search path is encountered again). This results in the DAG dependency network shown in . This simply represents the fact that, in this example, two of the three variables must be input to the system so that the third can be computed. Note that the output of Rule2 cannot be chained to be used as an input to Rule 1.","Simple formula and multiple-source directional declarative systems cover a wide range of applications. However, there is an important class of applications that can be addressed only by lifting the directionality restriction on the multiple-source directional declarative system. Such a system is called a constrained system.","Constrained System\u2014","A constrained system is a type of declarative programming system having the following characteristics:\n\n","Each of the equations can be considered a rule. For this sort of system, the rule interpreter is an equation solving algorithm (LU decomposition, for example). If there are more variables than equations, and a cost function is provided, a linear programming algorithm can be used as the rule interpreter.","Systems of propositional logic clauses can be considered constrained systems. For example, the propositional sentence\n\n(\n\nconsists of a set of clauses in conjunctive normal form that constrain the values of the boolean variables. The clauses can be thought of as rules, and the rule interpreter is a propositional satisfaction algorithm like WALKSAT or DPLL. Such algorithms compute a set of values for the variables such that all the clauses are satisfied.\n","Constrained systems are not limited to numeric or boolean variables. Variables that have enumerated set types (a discrete set of possible values) are useful in an important class of applications. The domains of such variables can be constrained by rules. For example, in a map-coloring problem, the variables represent the colors of countries on a map, and the rules state that no two adjacent countries can have the same color. Constraint propagation algorithms of various types are used as the rule interpreters here.","Change Tracking System","Change tracking is a facility that automatically, and efficiently, detects when there are variable changes (due to procedural assignment statements), that may cause a declarative rule violation. Change tracking collects such variables, and can be used to automatically invoke the rule interpreter between procedural statements in order to ensure that the declarative rules always appear consistent to the procedural system.","A change tracking system, such as the change tracking system  shown in  above, can be based on a number of fast predicates that indicate whether, and how, a variable participates in declarative processing. These predicates can utilize hash tables generated by the rule compiler (part of the declarative processing system). The rule compiler generates the hash tables by first generating a dependency network, based on the declarative rules. The dependency network indicates input and output variables of rules. The dependency network concisely indicates variables that participate in declarative processing. The rule compiler utilizes these variables to generate the hash tables. The rule compilation process will be explained in more detail in a subsequent section.","The hash tables contain information about variables that are mentioned in rules, and how those variables are embedded within objects. The change tracking predicates use this information to determine whether a variable that has just been changed (by a procedural assignment statement) corresponds to a variable designation mentioned in a declarative rule.","EXAMPLE 2 shows predicates that can be used by the change tracking system. These predicates refer to the dependency network because the dependency network indicates whether and how variables participate in declarative processing. An exemplary dependency network is shown in . This dependency network corresponds to an order processing example problem that has object structure shown in EXAMPLE 5, and rules shown in EXAMPLE 17 (this example will be discussed in more detail in a subsequent section). EXAMPLE 16 provides a table in which variables shown in  are designated by property and class of object that contains the property. EXAMPLE 3 shows hash tables that support these predicates of , filled in with values from the order computation example.","The change tracking system utilizes the predicate VariableDesignationInDependencyNetwork to ensure that the variable is actually in the dependency network, and to determine its location in the dependency network. However, it may first try some of the other predicates, in order to quickly rule out variables that do not match. The reason is that the other predicates are typically faster because their supporting hash tables are smaller. For example, change tracking may try the ContainingClasslnDependencyNetwork predicate first, passing it the containing class for the changed variable. If this predicate returns false, there is no need to try the computationally more expensive predicate VariableDesignationInDependencyNetwork.","These predicates may be used in two ways. They may be used at run time, as part of execution of an assignment statement. For example, the execution mechanism for an assignment statement calls the change tracking system if the variable value has changed. The change tracking system checks the predicates, and if they return true, invokes the declarative rule system.","Alternatively, the compilation mechanism for the procedural system may check these predicates at compile time in order to emit appropriate code depending on the result. If the variable does not participate in declarative processing, a simple version of the assignment statement is generated, namely, one that sets the variable, and does nothing more. If, on the other hand, the variable does participate in declarative processing, a more complex version is generated, namely, one that sets the variable, checks if its value has changed, and if so, notifies the declarative rule system to propagate the change.","Note that any such compilation is invalidated if there are any changes to the rules which result in the predicate giving a different answer regarding the participation of a variable in declarative processing.","The following example involving an order processing problem illustrates an exemplary operation of the system in detail.","Consider the class definitions and instances for an order processing problem shown in EXAMPLE 5. Suppose that the declarative rules that refer to these classes are the ones shown in EXAMPLE 17. The dependency network generated by the rule compiler for this set of rules and class definitions is shown in .","Suppose that the variable Order-1.HandlingCost is changed by an assignment statement in the Procedural System. The Change Tracking System finds the class associated with this variable (Order), and invokes the first-level predicate to see if this class is involved in declarative processing. Since it is, the second-level predicate is invoked with the full variable designation (Order.HandlingCost). This predicate also returns a positive result. Therefore, the Change Tracking System notifies the Declarative Rule System of the change to this variable.","The Declarative Rule System locates the variable designation in the dependency network, and extracts a sub-network consisting only of Rule1 and related variables. This is the only rule that needs to be executed to make the data consistent. The rule is executed, using Order-1 to generate context, and the variable Order-1.TotalCost is updated to be consistent with the new value of Order-1.HandlingCost.","Suppose, instead, that the variable changed by an assignment statement is OrderItem-1.Quantity. Now, the sub-network extracted consists of Rule2, as well as Rule1. Rule2 is executed first, with OrderItem-1 establishing context, followed by execution of Rule1, with Order-1 establishing context.","Suppose, instead, that the changed variable is Component-1.Price. Now, the sub-network is the entire dependency network, and the rules are executed in the following sequence: Rule4, Rule3, Rule2, Rule1, with Embed-FC-Component-1 establishing context for Rule4.","Changes to several variables can be accommodated by this system as well.",{"@attributes":{"id":"p-0149","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Compute_order computes price before tax based on product and"},{"entry":"\/\/ quantity. It then calls compute_order_tax to compute tax based on"},{"entry":"\/\/ which state the store where the purchase is made is in. After adding tax"},{"entry":"\/\/ to compute total price, it computes balance after monthly payments."},{"entry":"int compute_order(String product, int quantity, String store_location,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int monthly_payment, int number_of_payments)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003int price_before_tax, tax, total_price;"},{"entry":"\u2003\u2003\u2003int product_price;"},{"entry":"\u2003\u2003\u2003int principal, i;"},{"entry":"\u2003\u2003\u2003float monthly_interest;"},{"entry":"\u2003\u2003\u2003if (product == \u201cflashlight\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003product_price = 500;"},{"entry":"\u2003\u2003\u2003else if (product == \u201cbattery\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003product_price = 100;"},{"entry":"\u2003\u2003\u2003price_before_tax = product_price * quantity;"},{"entry":"\u2003\u2003\u2003tax = compute_order_tax(price_before_tax, store_location);"},{"entry":"\u2003\u2003\u2003total_price = price_before_tax + tax;"},{"entry":"\u2003\u2003\u2003principal = total_price;"},{"entry":"\u2003\u2003\u2003monthly_interest = 0.005;"},{"entry":"\u2003\u2003\u2003for (i=1; i<=number_of_payments; ++i)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003principal = round(principal +"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003principal * monthly_interest \u2212 monthly_payment);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return principal;"},{"entry":"}"},{"entry":"int compute_order_tax(int price_without_tax, String store_location)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003float tax_rate;"},{"entry":"\u2003\u2003\u2003if (store_location == \u201cMassachusetts\u201d)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003tax_rate = 0.06;"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003tax_rate = 0.05;"},{"entry":"\u2003\u2003\u2003return(round(price_without_tax * tax_rate));"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Boolean PropertyInDependencyNetwork(String propertyName)","Example: PropertyInDependencyNetwork(\u201cPrice\u201d)",{"@attributes":{"id":"p-0150","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":{"@attributes":{"id":"ul0019-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":["returns true (for dependency network in )\n\nBoolean TopLevelClassInDependencyNetwork(String className)\n\nExample: TopLevelClassInDependencyNetwork(\u201cOrder\u201d)\n","returns true (for dependency network in )\n\nBoolean ContainingClassInDependencyNetwork(String className)\n\nExample: ContainingClassInDependencyNetwork(\u201cConfiguredProduct\u201d)\n","returns true (for dependency network in )\n\nDepNetNodeVariableDesignationInDependencyNetwork(String variableDesignation)\n\nExample: VariableDesignationInDependencyNetwork\n","(\u201c.OrderItems( ).ConfiguredProduct.Cost\u201d)","returns node ConfiguredProduct.Cost (for dependency network in )"]}}}},"PropertyInDependencyNetworkHash","This would contain the following values for the order computation example:",{"@attributes":{"id":"p-0151","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":{"@attributes":{"id":"ul0021-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0022","list-style":"none"},"li":["TotalCost","HandlingCost","Cost","Quantity","ShippingCost","Tax","Price\n\nTopLevelClassInDependencyNetworkHash\n\nThis would contain the value \u201cOrder\u201d for the order computation example. It would contain more values if there were other dependency networks.\n\nContainingClassInDependencyNetworkHash\n\nThis would contain the following values for the order computation example:\n","Order","OrderItem","ConfiguredProduct","Component\n\nVariableDesignationInDependencyNetworkHash\n\nThis would have the following structure for the order computation example\n",".TotalCost",".HandlingCost",".OrderItems( )\n        \n        "]}}}},"The following grammar is used to designate a single property value.",{"@attributes":{"id":"p-0152","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PropertyDesignation -> ObjectDesignation \u201d.\u201d PropertyNamePath"]},{"entry":[{},"PropertyNamePath -> PropertyName"]},{"entry":[{},"PropertyNamePath -> PropertyName \u201c.\u201d PropertyNamePath"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},{"@attributes":{"id":"p-0153","num":"0214"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"CollectionPropertyDesignation -> ObjectDesignation \u201c.\u201d"},{"entry":"CollectionPropertyNamePath"},{"entry":"CollectionPropertyNamePath -> PropertyName \u201c.\u201d"},{"entry":"CollectionPropertyNamePath"},{"entry":"CollectionPropertyNamePath -> PropertyNamePath"},{"entry":"CollectionPropertyNamePath -> CollectionPropertyName \u201d(*).\u201d"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CollectionPropertyNamePath"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"CollectionPropertyNamePath -> CollectionPropertyName \u201d(\u201c index \u201c).\u201d"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CollectionPropertyNamePath"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"The \u201c(*)\u201d syntax is used to designate all elements of the set."]}]}}]}}},"Class Definitions:","Order",{"@attributes":{"id":"p-0154","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":[{"@attributes":{"id":"ul0026-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":["HandlingCost (an integer variable)","TotalCost (an integer variable)","OrderItems (a collection of sub-objects of class Order-Item)\n\nOrder-Item\n","Cost (an integer variable)","Quantity (an integer variable)","ConfiguredProduct (a sub-object of class ConfiguredProduct)\n\nConfiguredProduct\n","Cost (an integer variable)","Price (an integer variable)","ShippingCost (an integer variable)","Tax (an integer variable)","Components (a collection of sub-objects of class Component)\n\nComponent\n","Price (an integer variable)","Description (a text variable)\n\nObject instance configuration:\n\nOrder-1\n",".OrderItems(1)\u2014Order-Item-1\n        \n        ",".OrderItems(2)\u2014Order-Item-2\n        \n        ",".OrderItems(3)\u2014Order-Item-3\n        \n        "]}},"Order-1.TotalCost\u2014refers to TotalCost integer variable scalar property of Order-1","Order-1.OrderItems(2).Cost\u2014refers to Cost integer variable scalar property of Order-Item2","Order-1.OrderItems(*).Cost\u2014refers to set of Cost integer variable scalar properties of set of order-item instances (Order-Item-1 Order-Item-2)\n\nOrder-1.OrderItems(2).ConfiguredProduct.Components(2).Price\u2014refers to Price integer variable scalar property of Component\n"]}},"Order",{"@attributes":{"id":"p-0155","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","HandlingCost","TotalCost"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Order-1","10.00","4510.00"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0156","num":"0247"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Name","ParentOrder","Cost","Quantity","ConfiguredProduct"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Order-Item-1","Order-1","1500.00","3","ConfiguredProduct-1"]},{"entry":["Order-Item-2","Order-1","2000.00","1","ConfiguredProduct-2"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0157","num":"0248"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Name","Cost","Price","ShippingCost","Tax"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ConfiguredProduct-1","500.00","400.00","0","25"]},{"entry":["ConfiguredProduct-2","2000.00","1000.00","900.00","10"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0158","num":"0249"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Name","Parent Product","Price","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Component-1","ConfiguredProduct-1","100","500 Mhz CPU"]},{"entry":["Component-2","ConfiguredProduct-1","200","Standard case, 10 Gig"]},{"entry":[{},{},{},"hard drive"]},{"entry":["Component-3","ConfiguredProduct-1","100","Standard sound card,"]},{"entry":[{},{},{},"speakers"]},{"entry":["Component-4","ConfiguredProduct-2","300","3 Ghz CPU"]},{"entry":["Component-5","ConfiguredProduct-2","400","Deluxe case, 120 Gig"]},{"entry":[{},{},{},"hard drive"]},{"entry":["Component-6","ConfiguredProduct-2","300","Deluxe sound card,"]},{"entry":[{},{},{},"speakers"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0159","num":"0250"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<Orders>"},{"entry":"\u2002<Order>"},{"entry":"\u2003<name>Order-1<\/name>"},{"entry":"\u2003<HandlingCost>10.00<\/HandlingCost>"},{"entry":"\u2003<TotalCost>4510.00<\/TotalCost>"},{"entry":"\u2003<OrderItems>"},{"entry":"\u2003\u2002<Order-Item>"},{"entry":"\u2003\u2003\u2002<name>Order-Item-1<\/name>"},{"entry":"\u2003\u2003\u2002<Cost>1500.00<\/Cost>"},{"entry":"\u2003\u2003\u2002<Quantity>3<\/Quantity>"},{"entry":"\u2003\u2003\u2002<ConfiguredProduct>"},{"entry":"\u2003\u2003\u2003<name>ConfiguredProduct-1<\/name>"},{"entry":"\u2003\u2003\u2003<Cost>500.00<\/Cost>"},{"entry":"\u2003\u2003\u2003<Price>400.00<\/Price>"},{"entry":"\u2003\u2003\u2003<ShippingCost>0<\/ ShippingCost>"},{"entry":"\u2003\u2003\u2003<Tax>25<\/Tax>"},{"entry":"\u2003\u2003\u2003<Components>"},{"entry":"\u2003\u2003\u2003\u2009<Component>"},{"entry":"\u2003\u2003\u2003\u2002<name>Component-1<\/name>"},{"entry":"\u2003\u2003\u2003\u2002<Price>100<\/Price>"},{"entry":"\u2003\u2003\u2003\u2002<Description>500 Mhz CPU<\/Description>"},{"entry":"\u2003\u2003\u2003\u2009<\/Component>"},{"entry":"\u2003\u2003\u2003\u2009<Component>"},{"entry":"\u2003\u2003\u2003\u2002<name>Component-2<\/name>"},{"entry":"\u2003\u2003\u2003\u2002<Price>200<\/Price>"},{"entry":"\u2003\u2003\u2003\u2002<Description>Standard case, 10 Gig hard drive<\/Description>"},{"entry":"\u2003\u2003\u2003<\/Component>"},{"entry":"\u2003\u2003\u2003<Component>"},{"entry":"\u2003\u2003\u2003\u2002<name>Component-3<\/name>"},{"entry":"\u2003\u2003\u2003\u2002<Price>100<\/Price>"},{"entry":"\u2003\u2003\u2003\u2002<Description>Standard sound card, speakers<\/Description>"},{"entry":"\u2003\u2003\u2003<\/Component>"},{"entry":"\u2003\u2003\u2002<\/Components>"},{"entry":"\u2003\u2003\u2002<\/ConfiguredProduct>"},{"entry":"\u2003<\/Order-Item>"},{"entry":"\u2003<Order-Item>"},{"entry":"\u2003\u2003\u2002<name>Order-Item-2<\/name>"},{"entry":"\u2003\u2003\u2002<Cost>2000.00<\/Cost>"},{"entry":"\u2003\u2003\u2002<Quantity>1<\/Quantity>"},{"entry":"\u2003\u2003\u2003<ConfiguredProduct>"},{"entry":"\u2003\u2003\u2003<name>ConfiguredProduct-2<\/name>"},{"entry":"\u2003\u2003\u2003<Cost>2000.00<\/Cost>"},{"entry":"\u2003\u2003\u2003<Price>1000.00<\/Price>"},{"entry":"\u2003\u2003\u2003<ShippingCost>900.00<\/ ShippingCost>"},{"entry":"\u2003\u2003\u2003<Tax>10<\/Tax>"},{"entry":"\u2003\u2003\u2003<Components>"},{"entry":"\u2003\u2003\u2003\u2002<Component>"},{"entry":"\u2003\u2003\u2003\u2003<name>Component-4<\/name>"},{"entry":"\u2003\u2003\u2003\u2003<Price>300<\/Price>"},{"entry":"\u2003\u2003\u2003\u2003<Description>3 Ghz CPU<\/Description>"},{"entry":"\u2003\u2003\u2003\u2002<\/Component>"},{"entry":"\u2003\u2003\u2003\u2002<Component>"},{"entry":"\u2003\u2003\u2003\u2003<name>Component-5<\/name>"},{"entry":"\u2003\u2003\u2003\u2003<Price>400<\/Price>"},{"entry":"\u2003\u2003\u2003\u2003<Description>Deluxe case, 120 Gig hard drive<\/Description>"},{"entry":"\u2003\u2003\u2003\u2002<\/Component>"},{"entry":"\u2003\u2003\u2003\u2002<Component>"},{"entry":"\u2003\u2003\u2003\u2003<name>Component-6<\/name>"},{"entry":"\u2003\u2003\u2003\u2003<Price>300<\/Price>"},{"entry":"\u2003\u2003\u2003\u2003<Description>Deluxe sound card, speakers<\/Description>"},{"entry":"\u2003\u2003\u2003\u2002<\/Component>"},{"entry":"\u2003\u2003\u2003<\/Components>"},{"entry":"\u2003\u2003\u2002<\/ConfiguredProduct>"},{"entry":"\u2003\u2002<\/Order-Item>"},{"entry":"\u2003<\/OrderItems>"},{"entry":"\u2002<\/Order>"},{"entry":"<Orders>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Rule 1: price_before_tax=product_price*quantity","Rule 2: price=price_before_tax*tax_rate","Rule 3: monthly_payment=price\/number_of_payments",{"@attributes":{"id":"p-0160","num":"0251"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"List execution_list; \/\/ global variable"},{"entry":"generate_execution_list(changed_variable)"},{"entry":"{"},{"entry":"\u2009execution_list = ( ); \/\/ initialize to empty list"},{"entry":"\u2009for each node in DAG"},{"entry":"\u2002clear flag indicating node is in execution list;"},{"entry":"\u2009find_rules(changed_variable, null, ( ));"},{"entry":"}"},{"entry":"find_rules(variable_node, insertion_node, current_list)"},{"entry":"{"},{"entry":"\u2009if ((variable_node is in execution_list) or"},{"entry":"\u2003(variable_node has no rules it is input to))"},{"entry":"\u2002\/\/ If variable node is already in the execution list, or if it is a leaf in the"},{"entry":"\u2002DAG insert_current_list(current_list, insertion_node);"},{"entry":"\u2009first_time = true;"},{"entry":"\u2009for each rule_node, rule_x, that variable_node is input to"},{"entry":"\u2009{"},{"entry":"\u2002if first_time \/\/ if first time through this loop"},{"entry":"\u2003add rule_x to end of current_list;"},{"entry":"\u2002else"},{"entry":"\u2002{"},{"entry":"\u2003current_list = (rule_x);"},{"entry":"\u2003insertion_node = variable_node;"},{"entry":"\u2002}"},{"entry":"\u2002find_variables(rule_x, insertion_node, current_list);"},{"entry":"\u2009}"},{"entry":"}"},{"entry":"find_variables(rule_node, insertion_node, current_list)"},{"entry":"{"},{"entry":"if (rule_node is in execution_list)"},{"entry":"\u2009{"},{"entry":"\u2002remove rule_node from current_list \/\/ It is the last element"},{"entry":"\u2002insert_current_list(current_list, insertion_node);"},{"entry":"\u2009}"},{"entry":"\u2009first_time = true;"},{"entry":"\u2009for each variable_node, variable_x, that is output of rule_node"},{"entry":"\u2009{"},{"entry":"\u2002if first_time \/\/ if first time through this loop"},{"entry":"\u2003add variable_x to end of current_list;"},{"entry":"\u2002else"},{"entry":"\u2002{"},{"entry":"\u2003current_list = (variable_x);"},{"entry":"\u2003insertion_node = rule_node;"},{"entry":"\u2002}"},{"entry":"\u2002find_rules(variable_x, insertion_node, current_list);"},{"entry":"\u2009}"},{"entry":"}"},{"entry":"insert_current_list(current_list, insertion_node)"},{"entry":"{"},{"entry":"\u2002if execution_list is empty"},{"entry":"\u2003execution_list = current_list"},{"entry":"\u2002else if (insertion_node not in execution_list)"},{"entry":"\u2003insert current_list at beginning of execution_list"},{"entry":"\u2002else"},{"entry":"\u2003insert current_list after insertion_node in execution_list"},{"entry":"\u2003\u2003\/\/ insertion node is in execution list"},{"entry":"\u2002for each node in current_list"},{"entry":"\u2002{"},{"entry":"\u2003\u2009set flag indicating node is in execution list"},{"entry":"\u2002}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0161","num":"0252"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["generate_execution_list(tax_rate)","execution_list = ( )"]},{"entry":"\u2002find_rules(tax_rate, null, ( ))"},{"entry":"\u2003find_variables(Rule_2, null (Rule_2))"},{"entry":"\u2003\u2002find_rules(price, null, (Rule_2 price))"},{"entry":"\u2003\u2003find_variables(Rule_3, null,"},{"entry":"\u2003\u2003(Rule_2 price Rule_3))"},{"entry":"\u2003\u2003\u2002find_rules(monthly_payment, null,"},{"entry":"\u2003\u2003\u2002(Rule_2 price Rule_3 monthly_payment))"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"execution_list = (Rule_2 price"]},{"entry":[{},"Rule_3 monthly_payment)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0162","num":"0253"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["generate_execution_list(A)","execution_list = ( )"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2002find_rules(A, null, ( ))"},{"entry":"\u2003find_variables(R1, null (R1))"},{"entry":"\u2003\u2002find_rules(C, null, (R1 C))"},{"entry":"\u2003\u2003find_variables(R3, null, (R1 C R3))"},{"entry":"\u2003\u2003\u2002find_rules(E, null, (R1 C R3 E))"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"execution_list = (R1 C R3 E)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003find_variables(R4, C, (R4))"},{"entry":"\u2003\u2003\u2002find_rules(F, C, (R4 F))"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"execution_list = (R1 C R4 F R3 E)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2002find_variables(R2, A, (R2))"},{"entry":"\u2003find_rules(D, A, (R2 D))"},{"entry":"\u2003\u2002find_variables(R4, A, (R2 D R4))"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"execution_list = (R2 D R1 C R4 F"]},{"entry":[{},"R3 E)"]},{"entry":[{},"\u2003\u2003\/\/ note how R1 and R2 are"]},{"entry":[{},"\u2003\u2003before R4"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2002find_variables(R5, D, (R5))"},{"entry":"\u2003\u2003find_rules(G, D, (R5 G))"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"execution_list = (R2 D R5 G R1 C"]},{"entry":[{},"R4 F R3 E)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Rule 1: if ((not light_on) and light_switch_on) then light_switch_broken","Rule 2: if switch_wire_loose then light_switch_broken",{"@attributes":{"id":"p-0163","num":"0254"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"List execution_list; \/\/ global variable"},{"entry":"List affected_variables; \/\/ global variable"},{"entry":"propagate_change(variable)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003execution_list = ( ); \/\/ initialize to empty list"},{"entry":"\u2003\u2003\u2003affected_variables = ( ); \/\/ initialize to empty list"},{"entry":"\u2003\u2003\u2003identify_affected_variables(variable);"},{"entry":"\u2003\u2003\u2003for each variable, var_x, in affected variables"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003retract_value(var_x);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003find_rules_that_compute(var_x); \/\/ Add to execution_list"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003execute_rules( ); \/\/ Execute rules in execution_list"},{"entry":"}"},{"entry":"identify_affected_variables(variable)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\/\/ This algorithm is almost identical to that shown in Fig. 6. It searches forward in"},{"entry":"\u2003\u2003\u2003\/\/ the dependency network from variable. The main difference"},{"entry":"\u2003\u2003\u2003\/\/ is that instead of adding to execution_list, this adds to affected_variables."},{"entry":"}"},{"entry":"retract_value(variable) {variable = unknown;}"},{"entry":"find_rules_that_compute(variable)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003\/\/ This algorithm is similar to that shown in Fig. 6 except that it searches"},{"entry":"\u2003\u2003\u2003\/\/ backward, instead of forward, in the dependency network. Rules encountered"},{"entry":"\u2003\u2003\u2003\/\/ are added to execution_list in sorted form, as described in Fig. 6."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Rule 1: if ((not light_on) and light_switch_on) then light_switch_broken","Rule 2: if (light_switch_on and (not light_switch_broken)) then light_on","Rule 3: if (light_on and (not light_switch_broken) then light_switch_on",{"@attributes":{"id":"p-0164","num":"0255"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Rule -> RuleContextDeclarations RuleBody"},{"entry":"RuleContextDeclarations -> RuleContextDeclaration"},{"entry":"RuleContextDeclarations -> RuleContextDeclaration RuleContextDeclarations"},{"entry":"RuleContextDeclaration -> ClassName LocalObjectName"},{"entry":"RuleContextDeclaration -> ClassName LocalObjectName \u201c=\u201d ContextObjectDesignation"},{"entry":"ContextObjectDesignation -> LocalObjectName \u201c.\u201d ObjectPropertyNamePath"},{"entry":"ObjectPropertyNamePath -> ObjectPropertyName"},{"entry":"ObjectPropertyNamePath -> ObjectPropertyName \u201c.\u201dObjectPropertyNamePath"},{"entry":"\/\/ ObjectPropertyName refers to a sub-object property, or to a related object property."},{"entry":"RuleBody -> PropertyDesignation \u201c=\u201d Expression"},{"entry":"Expression -> PropertyDesignation"},{"entry":"Expression -> ArithmeticExpression"},{"entry":"Expression -> LogicalExpression"},{"entry":"Expression -> TextExpression"},{"entry":"Expression -> \u201cif\u201d LogicalExpression \u201cthen\u201d Expression"},{"entry":"Expression -> \u201cif\u201d LogicalExpression \u201cthen\u201d Expression \u201celse\u201d Expression"},{"entry":"ArithmeticExpression -> NumericPropertyDesignation"},{"entry":"ArithmeticExpression -> ArithmeticExpression ArithmeticOperator"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ArithmeticExpression"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ArithmeticExpression -> ArithmeticAggregator \u201c(\u201c CollectionPropertyDesignation \u201c)\u201d"},{"entry":"LogicalExpression -> LogicalPropertyDesignation"},{"entry":"LogicalExpression -> LogicalExpression LogicalOperator LogicalExpression"},{"entry":"LogicalExpression -> ArithmeticExpression ComparisonOperator"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ArithmeticExpression"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"TextExpression -> TextFunction \u201c(\u201c TextExpression \u201c)\u201d"},{"entry":"TextExpression -> TextPropertyDesignation"},{"entry":"ArithmeticOperator -> \u201c+\u201d, \u201c\u2212\u201c, \u201c*\u201d, etc."},{"entry":"ArithmeticAggregator -> \u201csum\u201d, \u201cmax\u201d, \u201cmin\u201d, \u201caverage\u201d, etc."},{"entry":"LogicalOperator -> \u201cand\u201d, \u201cor\u201d, \u201cnot\u201d"},{"entry":"\/\/ See Fig. 7 for grammar for PropertyDesignation, CollectionPropertyDesignation."},{"entry":"\/\/ NumericPropertyDesignation is a PropertyDesignation that refers to a numeric property"},{"entry":"\/\/ (as opposed to a logical or text property). Similarly LogicalPropertyDesignation refers"},{"entry":"\/\/ to a logical property, and TextPropertyDesignation refers to a text property."},{"entry":"Example rule using this grammar (see also Example 17)"},{"entry":"Order Order1"},{"entry":"OrderItem OrderItem1 = Order1.OrderItems(*)"},{"entry":"OrderItem1.Cost = OrderItem1.Quantity * OrderItem1.ConfiguredProduct.Cost"},{"entry":"Local object names Order1 and OrderItem1 are declared in the rule context declarations"},{"entry":"section. This specifies a pattern of an OrderItem object (OrderItem1) that is referred to in"},{"entry":"the OrderItems property of an Order object (Order1). Thus, the rule can be executed only"},{"entry":"if the retrieved context, beginning with the focus object, fits this pattern."},{"entry":"Another example rule"},{"entry":"OrderItem OrderItem1"},{"entry":"ConfiguredProduct ConfiguredProduct1 = OrderItem1.ConfiguredProduct"},{"entry":"Local object names OrderItem1 and ConfiguredProduct1 are declared in the rule context"},{"entry":"declarations section. This specifies a pattern of a ConfiguredProduct object"},{"entry":"(ConfiguredProduct1) that is referred to in the ConfiguredProduct property of an"},{"entry":"OrderItem object (OrderItem1)."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Table below shows variables shown in  designated by property and class of object that contains the property (see also EXAMPLE 4). Full variable designation information is shown in the following table.",{"@attributes":{"id":"p-0166","num":"0257"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Containing class and property","Full variable designation (from top-level object)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Order.TotalCost",".TotalCost"]},{"entry":["Order.HandlingCost",".HandlingCost"]},{"entry":["OrderItem.Cost",".OrderItems( ).Cost"]},{"entry":["OrderItem.Quantity",".OrderItems( ).Quantity"]},{"entry":["ConfiguredProduct.Cost",".OrderItems( ).ConfiguredProduct.Cost"]},{"entry":["ConfiguredProduct.Tax",".OrderItems( ).ConfiguredProduct.Tax"]},{"entry":["ConfiguredProduct.ShippingCost",".OrderItems( ).ConfiguredProduct.ShippingCost"]},{"entry":["Component.Price",".OrderItems( ).ConfiguredProduct.Components( ).Price"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Order",{"@attributes":{"id":"p-0167","num":"0000"},"ul":{"@attributes":{"id":"ul0034","list-style":"none"},"li":{"@attributes":{"id":"ul0034-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":["Rule1",".TotalCost=.HandlingCost+sum(OrderItems( ).Cost)\n\nOrderItem\n","Rule2",".Cost=.Quantity*.ConfiguredProduct.Cost\n\nConfiguredProduct\n","Rule3",".Cost=.Price*(1+.Tax\/100)+.ShippingCost","Rule4",".Price=sum(.Components( ).Price)"]}}}},"Those having ordinary skill in the art will appreciate that various changes can be made to the above embodiments without departing from the scope of the invention."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS","Digital Data Processing and Workflow Systems","Order Computation Example","Example 1","Exemplary Listing of a Typical Procedural Program","Example 2","Predicates Used by Change Tracking System","Example 3","Hash Tables that Support Change Tracking Predicates","Example 4","Property Designation Grammar","Example 5","Exemplary Object Configurations and Property Designations","Example 6","Exemplary Object Configuration in Normalized Form","Example 7","Exemplary Object Configuration in XML Form","Example 8","Simple Declarative Rule Set for Computing Monthly Payments","Example 9","Algorithm for Computing Rule Execution List from DAG Dependency Network","Example 10","Steps of Algorithm for Computing Execution List in Response to Change to the tax_rate Variable in FIG. ","Example 11","Steps of Algorithm for Computing Execution List in Response to Change to the Variable A in FIG. ","Example 12","Rule Set and Dependency Network for Multiple-Source Directional Declarative System (See FIG. )","Example 13","Rule Interpreter Algorithm for Multiple-Source Directional Declarative Systems","Example 14","Rule Set with Loop in Dependency Network (See FIG. )","Example 15","Rule Grammar","Example 16","Example 17","Rules for Order Processing Example"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more complete understanding of the invention may be attained by reference to the drawings, in which",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
