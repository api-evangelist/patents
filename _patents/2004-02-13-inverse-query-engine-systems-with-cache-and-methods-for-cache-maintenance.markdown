---
title: Inverse query engine systems with cache and methods for cache maintenance
abstract: An inverse query engine system having a cache integrated therein and methods for maintaining the cache are described herein. Entities storing filters in the inverse query engine cache thus do not have to maintain an individual cache to maintain the filters. The inverse query engine system cache is maintained within a bounded size by removing expired filters from the cache and trimming the cache to an optimal size when the cache reaches a maximum size. In the event that filter size cannot be determined efficiently, weights may be associated with filters stored in the cache, each weight identifying an estimate of a filter size. The weights are used to determine cache size and to maintain the cache size within particular bounds.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07558917&OS=07558917&RS=07558917
owner: Microsoft Corporation
number: 07558917
owner_city: Redmond
owner_country: US
publication_date: 20040213
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["The systems and methods described herein relate to inverse query engines, and more particularly to inverse query engines with integrated cache and cache maintenance capabilities.","Computing systems\u2014i.e. devices capable of processing electronic data such as computers, telephones, Personal Digital Assistants (PDA), etc.\u2014communicate with other computing systems by exchanging messages according to a communications protocol that is recognizable by the systems. To enforce security and prevent unwanted messages from entering a system, many computing systems implement security filters that screen messages entering (or, in some cases, exiting) the computing systems.","Filters are also utilized to process messages received by a service. (As used herein, different services may be included in the same process, a different process, the same machine or a different machine.) A filter is a query that returns a value of true or a value of false when tested against an input. One type of system that utilizes filters is a messaging service system that receives messages from various sources and routes those messages to different systems. For example, a financial services system can receive multiple stock quotes and route certain stock quotes to particular subscribers to the service by associating a filter with each subscriber. When a message (i.e. stock quote) is received, the message is compared to filters stored the financial services system. The message is forwarded to a subscriber if a filter associated with that subscriber is satisfied by the message. If, say, John Doe has signed up to receive stock quotes for Microsoft, then a filter associated with John Doe will be satisfied when a message containing a Microsoft quote is received. The Microsoft quote will then be forwarded to John Doe.","Multiple filters stored in a system are usually stored together in a filter table. An inverse query engine receives an input (i.e. a message) and tests that input against each of the filters (i.e. queries) in the filter table. Although the terms \u201cfilter table\u201d and \u201cinverse query engine\u201d may be used interchangeably, as used herein a filter table is a data structure containing the filters and the data associated therewith, and an inverse query engine is the logic that uses the filter table to drive the comparison process. Usually, as in the examples used herein, an inverse query engine encompasses a filter table, although that may not always be so since the inverse query engine and the filter table could be stored in separate locations or even be located in separate components.","Frequently, filters are not owned or controlled by a system in which they are stored. A messaging service computer, for example, stores filters that are owned by others. At a basic level, when a subscriber tells a system which message the subscriber will receive, the subscriber has added or modified a filter in the messaging service computer.","This issue can lead to memory management problems for inverse query engine systems such as uncontrolled growth of the filter table, since other computers and users can create and store a virtually unlimited number of filters in a filter table. System efficiency is deteriorated because the inverse query engine must process an enormous amount of filters for each message\u2014many of which are probably out of date.","General computer system processing can also be compromised if the filter table is stored in general memory (i.e. RAM) that can be utilized by other functions in the system. As more and more filters are stored in the filter table, less and less memory is available for other functions in the system. Conversely, if the memory is filled by other functions, then there may not be sufficient memory available for the filter table when it is required.","Another problem is that current inverse query engine systems are not as robust as desired by developers who create and maintain systems to work with the inverse query engine system. If the inverse query engine system does not have an integrated cache or a satisfactory solution for managing its filters, then a burden is placed upon developers of other systems to create their own solutions (e.g. cache creation and management) for maintaining their filters that are stored in the inverse query engine system.","Developers or filter owners may want their filters to remain in an inverse query engine system for limited times only, realizing that their needs will change over time or for security reasons. Some filter owners may also desire that their filters be removed from a system if the filter is not utilized for a certain period of time. The filter owners must then keep track of all other computers that store their filters and devise methods to manage the filters according to their needs, even though the filters are in the possession of other entities.","Accordingly, a more efficient and more robust solution is desirable.","At least one implementation described herein relates to an inverse query engine system that has a dedicated cache and utilizes methods to maintain the cache. The dedicated, or integrated, cache stores a filter table and provides greater stability for the inverse query engine and for any system including the inverse query engine. The cache is bounded and the inverse query engine maintains the bounds of the cache by maintaining the size of the filter table. This is accomplished by expiring and\/or trimming the cache. Expiring the cache entails deleting filters from the filter table that have been in the filter table for a certain period of time. Trimming the cache involves deleting one or more filters from the filter table when the cache meets or exceeds a maximum cache size to result in a cache of an optimal cache size. In at least one implementation wherein an actual filter size is undeterminable or inefficient, each filter is assigned a weight that corresponds to a best estimate of a size of the filter and a cache weight is derived by summing of all filter weights in the filter table. The weight may be assigned by an inverse query engine system or by a filter owner. Trimming is accomplished with reference to the filter weights and the cache weight instead of actual size.","The present disclosure relates to inverse query engine systems, and more particularly to inverse query engines that maintain a filter table in a cache integrated with the inverse query engine. In addition to the integrated cache, this disclosure describes a variety of implementations of effective cache management so that the cache does not grow to an undesirable or unmanageable size.","An inverse query engine accepts an input and tests the input against a group of queries, or filters. If the input satisfies a query, i.e. conditions defined by the query are met by the input, then the inverse query engine processes the input according to instructions associated with the query.","One use of an inverse query engine is in a messaging service, such as a news service, financial service or the like. In such services, a user subscribes to receive information that satisfies a query defined according to the user's subscription.","For example, a user may wish to receive news stories that pertain to a certain stock. The user enters a query, or filter, that is stored by an inverse query engine associated with a subscription service. A user typically does this through a user interface with the subscription service or an intermediary service, such as an Internet service provider. The subscription service receives messages regarding financial news items and the inverse query engine tests the messages against each filter that it stores. If the user's filter returns a true value with respect to a message, then the message is sent to the user.","In this example, if the news item is about the certain stock of interest to the user, the message satisfies the query and the news item of interest to the user will be sent to the user. Since the user's query is stored with the subscription service, messages matching the query are returned on a continued basis as long as the user subscribes to the subscription service.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["102","104","102","104","102","108","110"],"i":["a ","a ","b ","b"]},"The services  also transmit filters , to each other, the filters defining queries that apply to the respective sending services . Note that the filters stored by the first service are associated with the second service , and that the filters stored by the second service are associated with the first service ","Over time, the number of filters contained in the filter table increase, thereby increasing the size of the filter table. Prior art  illustrates how the filter table can grow quickly over a short period of time. A first central service and a second central service communicate with a number of collateral services  over a number of networks . Also, each collateral service  communicates with each of the other collateral services. Each central service  and collateral service  maintains a filter table (not shown) that stores multiple filters for each of the other central services  and collateral services . Although the services shown in  are identified as being resident on different entities, it is noted that services may be resident within a single process or within a single machine.","Even with this small, simplified illustration, it is easy to see how filter tables can grow unmanageably large and can contain filters that become out of date and are no longer used. In practice, this example is multiplied hundreds and thousands of times just over the Internet. Not only is it a burden for services to host unmanageably large filter tables, it is a burden on services to update or remove filters owned by them that are stored in filter tables of other services. This situation also causes problems with memory management for service systems. If the filter table is stored in memory used by other applications, the memory may be drastically reduced by an enormous filter table thus adversely affecting the system.","The inverse query engine systems described herein solve several problems associated with the prior art. For one, an inverse query engine that includes a cache that is used exclusively by the inverse query engine optimizes inverse query engine operations and general system operations, since the cache is of a bounded size and cannot be used by other applications. Also, in such an architecture the inverse query engine does not use memory that is needed by other system applications.","It necessarily follows that providing a cache integrated with an inverse query engine will require that the cache size be maintained at a size less than or equal to the size of the cache. The implementations described herein disclose several ways in which that may be done without requiring services that own filters stored in the cache to maintain their individual filter. These implementations are described in greater detail below with respect to subsequent figures.","Exemplary Computer System",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":["302","324","302","304","306","308","302","302","310","312","314"]},"The computer system  also includes memory , such as Random Access Memory (RAM), in which the inverse query engine  is stored. The memory  also stores an operating system  and other miscellaneous software  that may be required for the computer system  to function properly.","The inverse query engine  includes a control module  and a cache  integrated therewith. The cache  stores a filter table  and miscellaneous module  that includes several program, routines or sub-modules necessary for implementation of the systems and methods described herein. Although the cache  is shown stored in RAM , it is noted that the cache may be stored in any practical memory location, such as in Read Only Memory (ROM) (not shown) or on the mass storage device . An inverse query engine and its components are discussed in greater detail below.","It is noted that although the inverse query engine  is shown as being the only inverse query engine in the computer system , it is noted that the inverse query engine  could be integrated within a discrete service within the computer system . In such an instance, another discrete service having its own inverse query engine could be maintained on the computer system . Any practical number of inverse query engines could be present within the computer system .","Exemplary Inverse Query Engine",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 4","FIG. 3"],"b":["324","324","326","328","326","400","402","404","406"]},"The cache  stores a filter table  that includes multiple filters , a recently used list  that identifies when multiple filters  were last used, and an expiration list  that identifies expiration times of multiple filters .","The add filter module  controls functions necessary to receive and add a filter  to the filter table . The remove filter module  controls functions necessary to remove a filter  from the filter table. The matcher  processes messages received by the inverse query engine  to determine if the messages satisfy any filters  stored in the filter table .","The maintainer  controls cache\/filter table maintenance, i.e. the size of the filter table  using, inter alia, the most recently used list  and the expiration list . As will be discussed in greater detail below, the maintainer  is configured to expire the filter table  by removing one or more filters  that have expired.","The maintainer  is also configured to trim the filter table \u2014hence, the cache \u2014by determining when the cache  has grown to a specified maximum size or capacity. The size of the cache  may be indicated by a size of the filter table , by the cache  usage, or by any other method known in the art. When such a determination is made, the maintainer  is configured to remove one or more filters  until the cache  is reduced to an optimal size.","Elements of the inverse query engine  and their functions are explained in more detail below with respect to subsequent figures. In the following examples, reference is made to elements and reference numerals in previous figures.","Exemplary Filter",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 5","b":["500","400","500","502","508","400","502","500","502","400","500"]},"For instance, in the example given above regarding the stock quote message, the condition field  contains a Boolean expression that includes the stock identified by the user. That expression returns a value of true if the stock identified in the message is the same as the stock identified in the expression. As a result, the message would match\u2014or satisfy\u2014the filter  and the message would then execute instructions included in a data field  of the filter .","The data field  of the filter  includes executable instructions that are executed when the condition(s)  are satisfied. The data field  may include instructions, objects, etc. For example, the data field  may include instructions for the inverse query engine to send a message to User \u201cX\u201d if the message matches expressions in the condition field . The variety of information that may be contained in the data field , however, creates a problem of determining the size of a filter, a problem that is addressed in greater detail below.","The filter  also includes an expiration field , a filter weight field  and a permanent flag . The expiration field  stores an expiration time that identifies a date and\/or time at which the filter expires and may be removed from the filter table. An owner of the filter can set this value based on the needs of the owner's service. For example, a filter may be set to expire in thirty days, in two weeks, at two o'clock p.m., etc. The filter owner may do this to ensure that the owner's filters are kept up to date so that, for example, messages aren't sent to a previous subscriber in error. The expiration field  is explained in more detail with respect to , below.","The permanent flag  is a Boolean field that, when set, indicates that the filter  is not to be removed from the filter table in a cache maintenance operation. Setting the permanent flag  essentially overrides the cache maintenance operations described herein (e.g. expiring, trimming) if the filter owner is certain that it is beneficial for the filter to remain in a system for an indefinite period of time. That notwithstanding, a permanent filter may include an expiration date at which time the permanent filter may be removed from the cache. In such a case, the permanent filter could be removed in an expire cache operation but not in a trim cache operation.","The filter weight field  may be used to store a filter weight value assigned to the filter  by the inverse query engine  in situations wherein the size of the filter  cannot be practically determined (the size of the filter depends directly on the size of the data field , since the difference in the size of the other parts of filters is typically negligible). In cases where processing overhead is too expensive to determine the exact size of a filter (due to the range of data that may be stored in the data field ), the inverse query engine  may be configured to assign a filter weight value to a filter based on an estimate of the size of the filter. There may also be other scenarios in which it is virtually impossible to determine the exact size of the filter.","For example, in at least one implementation, the data field  is a .NET (\u201cdot net\u201d) runtime object. .NET technology is a set of software technologies promulgated by Microsoft Corp. that facilitates network communication between computer systems and is suited for use in messaging service systems. Implementations of .NET technology are known in the art.","In a case where the data field  is a .NET runtime object, the data stored in the data field  could be an object with an arbitrary object hierarchy\/graph subordinate thereto. The .NET object in the data field  references each object in the hierarchy and those objects can reference other objects, and so on. The actual memory usage of the .NET object in the data field  is a sum of all objects referenced by the .NET object and its subordinate objects. To determine the actual memory usage would require a graph traversal solution that may be prohibitively expensive. Also, since .NET code is compiled on a just-in-time basis, memory usage can also depend on the computer system and the operating system being used.","Actual values of in the filter weight field  vary depending on the implementation. The values can be implemented on a simple \u201cSmall, Medium, Large\u201d basis, or the values may be assigned an integer value of, for example, 2 (two) to 64K (sixty-four thousand). In one particular implementation, filters are assigned weights of from one (1) to five (5), with a default weight of one (1).","It is noted that the filter weight may be determined by an inverse query engine system when it receives the filter, or the filter weight may be determined by a filter owner and associated with the filter before the filter is transmitted to the inverse query engine system, since the filter owner is in a better position to estimate the size of the filter. To ensure that all filter weights in a system can be reliably compared to each other, the filter weights may be determined according to a general standard or a standard associated with the inverse query engine system.","Even if the exact size of the filter cannot be determined, an estimation of the size works to prevent a \u201crunaway\u201d cache, wherein the cache size grows too large for efficient practical applications. Efficient estimation methods can be used to estimate a filter size with sufficient accuracy to comport with the objects of the systems and methods described herein.","In at least one implementation, filter weights are not assigned to permanent filters (i.e. a permanent filter is assigned a filter weight of \u201c0\u201d). In some instances, developers may wish to maintain permanent filters separate and apart from non-permanent filters. Other implementations, however, use permanent filter weights in cache maintenance operations.","Further discussion of filter weights will be discussed in greater detail below, with respect to one or more methodological implementations of the systems described herein.","Exemplary Most Recently Used List",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 6","b":["600","600","602","606","602","606","602","606","600"]},"It is noted that although a relative time of usage is used to sort the MRU list , there is no need to store an actual time of usage, since the absolute time is not required in this processing. Once sorted, the relative time of usage of the filters is established. Notwithstanding the foregoing, one or more implementations that include actual usage times may be used in accordance with the systems and methods described herein. The usage times may be used in a list\u2014either sorted or non-sorted\u2014or without a list wherein filters themselves (or some other location) may include a last time of usage.","A filter associated with filter identifier  is the filter that has been most recently used. A filter associated with filter identifier  is has been used less recently that the filter associated with filter identifier , but more recently than a filter associated with filter identifier .","In implementations defined more fully below, the inverse query engine  refers to the MRU list  in reverse order to determine which filters have been least recently used. Such filters may be chosen to be removed from the cache before other filters that have been used more recently. This concept is explained in greater detail below, with respect to flow diagrams depicted in subsequent figures.","In at least one implementation, permanent filters are not added to the MRU list  when the permanent filters are added to the filter table. This prevents a permanent filter from being removed from the filter table during an expire cache or trim cache procedure. In an alternative implementation, a permanent filter could be added to the MRU list  but the status of each filter in the MRU list would have to be verified before a removing step in the expire cache or trim cache process.","Exemplary Expiration List",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 7","FIG. 5"],"b":["700","700","702","704","706","702","706","422","420","422","702","706","700","506"]},"The filter identifiers - may be sorted according to expiration times of the filters identified thereby. If the expiration list  is so sorted, then filter identifier  identifies a filter that has an expiration time that will occur sooner than expiration times in filters identified by the other filter identifiers , . Likewise, filter identifier  identifies a filter having an expiration time that will occur after the expiration times in the filters identified by filter identifier  and filter identifier .","As previously stated, each filter  in the filter table  does not necessarily include an expiration value. But if a filter does include an expiration value, then that filter is identified as one of the filters - in the expiration list . The expiration list  is monitored by the inverse query engine  to determine when a filter identified in the expiration list  has expired and thus should be removed from the filter table .","It is also noted that filters that do not include an expiration value may also be expired (removed) from the filter table  in another manner even though they may not be identified in the expiration list . The expiration process will be described in greater detail below with reference to subsequent flow diagrams.","Exemplary Maintainer",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 8","b":["800","800","802","804","802","804"]},"The maintainer  also includes a cache weight module  that stores a cache weight , an optimal weight  and a maximum weight . The cache weight  is a sum of all filter weights  () included in the filter table  stored in the cache  (see ). The optimal weight  identifies a largest size of the filter table  that is desirable for typical operation. The maximum weight  is a weight that denotes a filter table size that is large enough to trigger a cache trimming operation. In at least one implementation described herein, the expiration module  and the trim module  perform a cache expiration operation and a cache trimming operation, respectively, when the filter table reaches the size corresponding to the maximum weight . The cache trimming operation removes filters from the filter table until the filter table reaches the optimum weight .","Exemplary Methodological Implementation: Cache Maintenance",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 9","b":["900","900"]},"At block , the inverse query engine  receives a filter  to be added to the filter table  in the cache  associated with the inverse query engine . The add filter  module of the control module  receives and adds the filter  to the filter table  at block .","At block , the control module  invokes the expire module  of the maintainer ,  to expire the cache . As used herein, reference to \u201cexpiring the cache\u201d is equivalent to \u201cexpiring the filter table.\u201d Reducing the number of filters in the filter table necessarily reduces the cache\u2014not in a physical sense, but in the sense that less of the cache is utilized. Expiring the cache  entails traversing filters  identified in the expiration list  and removing any filter having an expiration time that has passed. The cache expiring process is discussed in detail below with respect to .","After the cache  has been expired, the maintainer  trims the cache  at block . Trimming the cache  involves reducing the number of filters  that are stored in the filter table . The size of the filter table  is reduced, thereby reducing the amount of the cache  that is utilized. The cache trimming process is discussed in detail below with respect to .","Exemplary Methodological Implementation: Expire Cache Operation",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 10","b":["1000","412","404","422","420","420","420","404","404","404","420"]},"In the following example, it is assumed that the expiration list  is sorted according to expiration times, with filter expiring soonest being identified at the front of the expiration list . It is noted, however, that other implementations may accomplish the same result utilizing an unsorted expiration list. As is shown in the following example, utilizing a sorted expiration list is efficient because once a filter is identified in the expiration list that has not expired, the process may terminate, since no subsequent filter will have an earlier expiration time.","At block , the expiration module  of the maintainer  references the first filter identifier  stored in the expiration list . If an expiration field value  in a filter associated with the first filter identifier  is earlier than a current time (\u201cYes\u201d branch, block ), then the filter  identified by the first filter identifier  is removed from the filter table  (block ). If the expiration field value  has not yet occurred (\u201cNo\u201d branch, block ), the filter  associated with the first filter identifier  is not removed from the filter table  and the process terminates at block .","If there are more filters  in the filter table  (\u201cYes\u201d branch, block ), then the expiration module  references a next filter identifier  stored in the expiration list  at block . The process then repeats from block  with the next filter. If there are no more filter identifiers in the expiration list (\u201cNo\u201d branch, block ), the process terminates at block .","The specific example described above is not meant to exclude other implementations that may be used to expire the cache. In one implementation, the maintainer  is configured to expire the cache by removing any filters that have been stored in the filter table  for longer than a specified period of time. In another implementation, the expiration process terminates when a sufficient number of filters has been removed from the filter table. Other implementations not described herein may also be used within the scope of the claims appended hereto.","Exemplary Methodological Implementation: Trim Cache Operation",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 11","b":["1100","404","804","800","810","810","814","804","422","420","810","812"]},"In the example described in , the concepts of a cache weight and filter weights are implemented. As previously discussed, if it is efficient to determine an actual size of filters in the filter table (i.e. memory used by the filters), then the actual sizes may be used in lieu of weights. The methodology for using the actual sizes is similar to that for using weights. However, it is often impossible to efficiently determine actual sizes of filters and, hence, the filter table. In such cases, using the weights method described herein is beneficial.","When a new filter is added to the filter table (block , ) and the trim cache procedure is invoked (block , ), the maintainer  calculates the cache weight  by summing the filter weights (, ) for all filters  in the filter table  () at block . It is noted that the summing process may merely consist of adding the new filter weight to the cache weight. At block , the cache weight  is compared to the maximum weight , which has been predefined. If the cache weight does not exceed the maximum weight (\u201cNo\u201d branch, block ), then the process terminates. If the cache weight is greater than or equal to the maximum weight (\u201cYes\u201d branch, block ), then the trim module  identifies the least recently used filter (block ) and removes the filter at block . The least recently used filter is identified by determining which filter is associated with a filter identifier that is last in the MRU list  ().","It is noted that if a particular implementation adds references to permanent filters to the MRU list, then a provision would have to be included to prevent the filter removing step from removing a filter that is identified as a permanent filter. However, if the MRU list does not reference permanent filters, then such a step is not required.","After a filter has been removed at block , a new cache weight is calculated at block . The new cache weight  is then compared to the optimal weight  (block ). If the new cache weight  is less than or equal to the optimum weight  (\u201cYes\u201d branch, block ), then the process terminates. If the new cache weight  is greater than the optimal weight  (\u201cNo\u201d branch, block ), then the process reverts to block , where the next least recently used filter is identified for possible removal. This process repeats until the cache weight  is less than or equal to the optimal cache weight .","It is noted that the particular steps outlined in the flow diagram  are but one implementation of a cache trimming operation. Other logic may be utilized or steps described above may be performed in some other order. The specific example depicted in the flow diagram  is not intended to limit the scope of the claims appended hereto.","Exemplary API (Application Programming Interface) Elements","The following exemplary API elements provide examples of constructors, properties and methods that may be used in particular systems to implement the systems and methods described herein. The exemplary API elements described below describe only one of many ways to implement the concepts described herein. The following examples are written in the C# language. Similar elements can be readily derived in other programming languages.","It is noted that the following examples refer to a filter table or filter cache that is arranged in a hierarchical tree structure. The filter hierarchy structure is described in U.S. patent application Ser. No. 10\/781,390 by the present Applicants and assigned to the same Assignee as the present application and filed on Feb. 18, 2004.","A filter table arranged in a hierarchical tree structure (i.e. Class FilterTable or Class FilterHierarchy in Microsoft\u00ae Message Bus\u2122 implementation) provides an efficient way to add and remove filters to or from a filter table and search the filter table for matches against an input. Details of filter hierarchy systems and methods are described in the previously referenced patent application.","Briefly, a filter hierarchy is an in-memory tree of string segments where each node in the tree may contain zero or more filters. Each filter has a segment path that places it at a particular node in the hierarchy. Superior nodes in the tree structure identify common segment paths of nodes that are inferior to them. Traversing the tree to find matches is more efficient because each filter does not have to be individually tried against the input. If, during a matching process, a non-matching segment is found at a node in the hierarchy, the traversal of the remainder of that branch of the tree can be omitted.","The following examples describe how various operations including the expire cache process () and the trim cache process () may be implemented in a system that utilizes a filter hierarchy cache.","(Constructor) public FilterHierarchyCache (int optimalWeight, int maximumWeight);","This constructor may be used to initialize a new instance of the FilterHierarchyCache class (i.e. an inverse query engine cache) with specified maximum and optimal weights as described above, within which the filters contained will be automatically trimmed down to the optimal weight if the maximum weight is exceeded. The parameter optimalWeight: System.Int32 identifies the optimal weight to which the FilterHierarchyCache will be trimmed as a 32-bit integer. The parameter maximumWeight: System.Int32 identifies the maximum weight of the FilterHierarchyCache as a 32-bit integer.","(Constructor) public FilterHierarchyCache (int optimalWeight, int maximumWeight, bool autoPrune, bool autoTrim);","This constructor may be used to initialize a new instance of the FilterHierarchyCache class that specifies whether empty nodes will be pruned off the hierarchy automatically and whether the filters it contains will be trimmed down to a specified optimal weight if a specified maximum weight is exceeded. The optimalWeight and maximumWeight parameters are as described above. The autoPrune: System.Boolean parameter is set to true to automatically remove empty nodes from the FilterHierarchyCache, and false not to remove them automatically.","(Property) public bool AutoTrim {get; set;}\u2014gets or sets a value specifying whether filters will be trimmed automatically from the filter hierarchy. The FilterHierarchyClass will automatically remove filters if true. This trimming behavior is automatic in the sense that whenever a Filter is added to the FilterHierarchyCache using the Add method (shown below), the trim module  of the maintainer  is called. If the MaximumWeight of the FilterHierarchyCache is exceeded, expired filters will be removed first and then the least recently used filters will continue to be removed until the OptimalWeight is reached.","(Property) public int MaximumWeight {get; set;}\u2014gets or sets the weight above which the cached filters in the hierarchy will be trimmed.","(Property) public int OptimalWeight {get; set;}\u2014gets or sets the weight to which the filter table is trimmed after reaching the maximum weight.","(Property) public int Weight {get}\u2014gets the cache weight of a filter table, i.e. a filter hierarchy.","(Method) public override FilterHierarchyNode Add(string[ ] path, Filter filter);","This method can be used to add a filter with a specified name to the filter table in the cache at a specified location within the filter table, with a default weight of 1. The path: System.String[ ] parameter identifies the path to locate the place of the filter within the filter table. The filter:System.MessageBus.Filter parameter identifies the filter to be added to the filter table. The FilterHierarchyNode value returns the location of the filter added to the filter table.","(Method) public virtual FilterHierarchyNode Add (string [ ] path, Filter filter, int weight);","When overridden in a derived class, this method adds a filter to the cached filter table at a specified location and with a specified weight. In addition to the parameters included in the immediately preceding example, the parameter weight: System.Int32 identifies a weight to be assigned to the added filter.","(Method) public virtual FilterHierarchyNode Add (string [ ] path, Filter filter, int weight, DateTime utcExpiresAt);","When overridden in a derived class, this method adds a filter to the cached filter table at a specified location with a specified weight and specifies a time when the filter will expire. In addition to the parameters included in the immediately preceding example, the parameter utcExpiresAt: System.DateTime identifies the time at which the filter will expire.","(Method) public virtual FilterHierarchyNode Add (string [ ] path, Filter filter, int weight, DateTime utcExpiresAt, bool permanent);","This method is similar to the method immediately preceding method but includes a permanent: System.Boolean parameter. When this parameter is set, the filter is not removed in a cache trimming operation unless the filter has expired. If not set, the filter may be removed based on the least recently used criterion described above.","(Method) public void Expire ( );","This method removes expires filters from the cached filter hierarchy (as in the \u201cexpire cache\u201d method described above with regard to ).","(Method) protected virtual void OnFilterRemoved (FilterHierarchyNode node, Filter filter);","When overridden in a derived class, this method is invoked whenever a filter is removed from a cached filter table. Parameters include:\n\n","(Method) public override void Remove (FilterHierarchyNode node);","This method removes a specified node from the cached hierarchy, i.e. removes a specified filter from the filter table. The parameter node: System.MessageBus.FilterHierarchyNode identifies a node to be removed.","(Method) public virtual void Trim (int desiredWeight);","When overridden in a derived class, this method can be used to reduce the filter table cache to a desired weight.","Exemplary Computer Environment","The various components and functionality described herein are implemented with a computing system.  shows components of typical example of such a computing system, i.e. a computer, referred by to reference numeral . The components shown in  are only examples, and are not intended to suggest any limitation as to the scope of the functionality of the invention; the invention is not necessarily dependent on the features shown in .","Generally, various different general purpose or special purpose computing system configurations can be used. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The functionality of the computers is embodied in many cases by computer-executable instructions, such as program modules, that are executed by the computers. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Tasks might also be performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media.","The instructions and\/or program modules are stored at different times in the various computer-readable media that are either part of the computer or that can be read by the computer. Programs are typically distributed, for example, on floppy disks, CD-ROMs, DVD, or some form of communication media such as a modulated signal. From there, they are installed or loaded into the secondary memory of a computer. At execution, they are loaded at least partially into the computer's primary electronic memory. The invention described herein includes these and other various types of computer-readable media when such media contain instructions programs, and\/or modules for implementing the steps described below in conjunction with a microprocessor or other data processors. The invention also includes the computer itself when programmed according to the methods and techniques described below.","For purposes of illustration, programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computer, and are executed by the data processor(s) of the computer.","With reference to , the components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISAA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as the Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. \u201cComputer storage media\u201d includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more if its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as data media interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer-readable instructions, data structures, program modules, and other data for computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball, or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through an input\/output (I\/O) interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , computers may also include other peripheral output devices  (e.g., speakers) and one or more printers , which may be connected through the I\/O interface .","The computer may operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . The remote computing device  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Although the WAN  shown in  is the Internet, the WAN  may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the like.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the Internet . The modem , which may be internal or external, may be connected to the system bus  via the I\/O interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote computing device . By way of example, and not limitation,  illustrates remote application programs  as residing on remote computing device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Although details of specific implementations and embodiments are described above, such details are intended to satisfy statutory disclosure obligations rather than to limit the scope of the following claims. Thus, the invention as defined by the claims is not limited to the specific features described above. Rather, the invention is claimed in any of its forms or modifications that fall within the proper scope of the appended claims, appropriately interpreted in accordance with the doctrine of equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more complete understanding of exemplary systems and methods described herein may be had by reference to the following detailed description when taken in conjunction with the accompanying drawings wherein:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 11","FIG. 9"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
