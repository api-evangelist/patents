---
title: System and method for monitoring software locks
abstract: A system and method for monitoring software locks is presented. Metric data collection is invoked only when thin lock contention arises in a computer system's application layer. Instrumentation in a computer system's middleware layer tracks time-based metric information such as a waiting time for an application to acquire a lock. Instrumentation tracks garbage collection events and removes garbage collection time durations from time-based metric data as to not distort time-based metric data. Instrumentation also tracks quantity-based events such as the number of applications that request a particular lock. An instrumentation user may retrieve metric data for computer system performance analysis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07051026&OS=07051026&RS=07051026
owner: International Business Machines Corporation
number: 07051026
owner_city: Armonk
owner_country: US
publication_date: 20020731
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Technical Field","The present invention relates in general to a system and method for monitoring software locks. More particularly, the present invention relates to a system and method for using instrumentation in a non-obtrusive manner to collect software lock metric data.","2. Description of the Related Art","Computer systems today typically include resources that are shared between multiple applications. For example, a computer system may have a database that many applications, or threads, have the ability to access. Computer systems use software locks to manage access to a shared resource. A software lock is a language-level construct for providing mutually exclusive access to a shared resource in a multi-threaded environment.","The computer system includes three layers which are an operating system layer, a middleware layer, and an application layer. The operating system layer is the operating system which the middleware layer and application layer run on. For example, the operating system may be a UNIX operating system. The middleware layer is an application that runs on top of the operating system and interfaces with the application layer. Using the example described above, the middleware layer may be a Java Virtual Machine (JVM). The application layer is the layer where applications run. Using the example described above, the application layer may be a Java application that runs on top of the JVM.","One type of software lock is a \u201cbimodal\u201d software lock. A bimodal software lock has two states which are \u201cthin locks\u201d and \u201cthick locks.\u201d These states are also called \u201cdeflated\u201d (for thin locks) and \u201cinflated\u201d (for thick locks). Thin locks are located in the computer system's application layer and include characteristics such as speed, small size, and portability. Thick locks are used when contentions arise for a thin lock (i.e. one application requests the thin lock when a different application currently owns the lock). Thick locks are located in the computer system's operating system layer. Thick locks are typically expensive in terms of processing time and should be avoided if possible.","When a first application wishes to use a shared resource, the first application sends a request to a corresponding thin lock. If the thin lock is not owned by another application, the first application acquires the lock without contention. When a second application wishes to use the same shared resource while the first application owns the thin lock, contention arises for the thin lock. A lock manager in the middleware layer is invoked and processes the second application's lock request. The lock manager examines lock data structures to determine if a queue has been established to acquire a thick lock corresponding to the software lock. The lock data structures include information pertaining to thick locks located in the operating system. The lock manager may wait (i.e. spin) for a period of time to see if the first application releases the thin lock before adding the second application to the queue.","Computer systems often include instrumentation to track system performance such as lock management performance. A challenge found with existing instrumentation is the overhead associated with the instrumentation and that the overhead may degrade system performance and distort the data that the instrumentation is measuring. For example, the instrumentation may use extensive processing time which, in turn, may slow down an application that the instrumentation is monitoring.","Additionally, the computer system typically has garbage collection events which may occur during instrumentation data collection times. A garbage collection event is occasionally performed which stops processing from performing other tasks. For example, a garbage collection event may be performed to restructure, or defragment a database in order to allow the computer system to operate efficiently. Garbage collection events may distort time-based metrics, such as the time an application takes to acquire a lock, if garbage collection events occur during instrumentation data collection periods.","What is needed, therefore, is a system and method that monitors software locks with minimal overhead and removes garbage collection events from metric data.","It has been discovered that the aforementioned challenges are resolved by invoking instrumentation only during lock contention of bimodal locks and tracking garbage collection times in order to remove the garbage collection times from metric data. The instrumentation is located in a computer system's middleware layer which tracks metric data corresponding to lock contentions in the computer system's application layer.","The instrumentation initializes and tracks metric data only during bimodal lock contentions in the computer system's application layer (i.e., only when the lock is \u201cinflated\u201d). A lock manager provides metric data to the instrumentation that the instrumentation stores in a memory area for later retrieval by an instrumentation user. The instrumentation also performs time-based metric calculations using the lock manager's metric data. The instrumentation user uses an instrumentation application to configure the instrumentation and examine the metric data. The instrumentation application is located in the computer system's middleware layer.","The instrumentation tracks various metric values corresponding to a particular lock's activity, such as an entry count, a slow count, a recursive count, a queue size count, and a spin count. The entry count tracks the number of lock requests a middleware lock manager receives corresponding to a particular lock. For example, when a second application requests a lock that is in use by a first application (i.e. contention), the second application enters middleware lock manager processing and the entry count is incremented.","The slow count keeps track of the number of times a particular lock is acquired after waiting. Using the example described above, the slow count is incremented when the second application acquires the lock after the first application releases the lock.","The recursive count tracks the number of times that an application requests a lock that the application already owns. This re-requesting event may occur in situations where the application does not know that it already owns the lock. Using the example described above, the first application may request the lock while the first application still owns the lock.","The queue size count tracks the number of applications waiting in a queue to acquire a lock. The queue size count may be configured to track various metrics corresponding to the queue. For example, the queue size count may track a maximum number of applications waiting for a lock between resets. Another example is the queue size count may track the average number of applications waiting for a lock between resets.","The spin loop count is the number of times a requester \u201cspins\u201d before either being put in the queue or acquiring the lock. The middleware lock manager may put the requestor in a \u201cspin loop\u201d for a specified time period before putting a requester in a queue to wait for a contended lock. The middleware lock manager waits for the spin loop time period to see if the current lock owner releases the contended lock. This is performed to avoid putting the requestor in the queue, which may be expensive in terms of processing time.","The instrumentation also monitors garbage collection events invoked by a garbage collector in order to provide accurate time-based metric information to the instrumentation user. The garbage collector occasionally performs a garbage collection event which stops processing from performing other tasks. For example, the garbage collector may perform a garbage collection event to restructure, or defragment a database in order to allow the middleware layer to perform efficiently. The instrumentation removes garbage collection duration periods from time-based metric values in order to not distort time-based metric values. The instrumentation user examines metrics data to analyze the lock management performance of the computer system.","Instrumentation tracks various time-based metrics corresponding to a particular lock such as a hold time, a get time, and a wait time. The hold time is the total time that a particular lock is in use by one or more applications. For example, if a first application uses the lock for twenty clock cycles and a second application uses the lock for thirty clock cycles, the lock's hold time is fifty clock cycles.","The get time is the sum of time that each application spends waiting to acquire the lock. Using the example described above, if the first application waits thirty clock cycles to acquire the lock and the second application waits ten clock cycles to acquire the lock, the get time corresponding to the lock is forty clock cycles.","The wait time is the total time spent by applications waiting for a particular lock. As compared to the get time, the get time may \u201cdouble-count\u201d clock cycles if two applications are waiting for a lock at the same time whereas the wait time just calculates the total, or absolute time, that applications, regardless of quantity, wait for a lock.","The foregoing is a summary and thus contains, by necessity, simplifications, generalizations, and omissions of detail; consequently, those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects, inventive features, and advantages of the present invention, as defined solely by the claims, will become apparent in the non-limiting detailed description set forth below.","The following is intended to provide a detailed description of an example of the invention and should not be taken to be limiting of the invention itself. Rather, any number of variations may fall within the scope of the invention which is defined in the claims following the description.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1","b":["100","180","150","110","180","150","180","150","180","110","150","110","110"]},"Operating system layer  includes operating system locking facilities . Operating system locking facilities  handles lock contentions when they arise in application layer  by providing a \u201cthick lock\u201d for use by requesters. Thick locks are typically expensive in terms of processing time and should be avoided if possible.","Application layer  includes requestor  and requester . Requestor  is the first requestor to request software lock  which is located in shared resource . Software lock  is not currently owned by a requester so requester  acquires the lock without contention. Since no contention exists, lock manager  located in middleware layer  is not invoked. Requestor  sends a request to acquire software lock . Requestor  is still using software lock  in which contention arises with software lock .","Lock manager  is invoked and processes requester 's lock request. Lock manager  examines lock data structures  to determine if a queue has been established to acquire a thick lock corresponding to software lock  in operating system locking facilities . Lock data structures  includes information pertaining to thick locks located in operating system locking facilities . Lock data structures  are typically stored in volatile storage areas, such as RAM, but may also be stored on a non-volatile storage area, such as non-volatile memory. Lock manager  may wait (i.e. spin) for a period of time to determine if software lock  is released before adding requester  to the queue.","Lock manager  provides information to instrumentation  corresponding to contended lock requests. Instrumentation  stores metric information in lock metrics  (see  and corresponding text for further information regarding metric information). Lock metrics  may be stored in a non-volatile storage area, such as non-volatile memory.","Instrumentation user  uses instrumentation application  to interface with instrumentation . Application  communicates with instrumentation  using known techniques, such as sockets or by instrumentation  providing application programming interfaces (APIs) that are called by application  for requesting instrumentation data (stored in lock metrics ) and for instructing instrumentation regarding its operating parameters. Instrumentation application  provides instrumentation user  the ability to configure instrumentation  to track and provide various metric information. Instrumentation  tracks metric information in response to instrumentation 's requests. Instrumentation  monitors garbage collection events invoked by garbage collection  in order to provide accurate time-based metric information to instrumentation user . Garbage collection  occasionally performs a garbage collection event which stops processing from performing other tasks. For example, garbage collection  may perform a garbage collection event to restructure, or defragment a database in order to allow middleware layer  to perform efficiently (see  and corresponding text for further details regarding garbage collection time adjustments).","Instrumentation user  uses instrumentation application  to send a metrics display request to instrumentation . Instrumentation  retrieves metrics data from lock metrics , and provides the metrics data to instrumentation application . Instrumentation user  examines the metrics data to analyze the lock performance of computer system .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 2","FIG. 3"],"b":["200","205","210","210","215","220"]},"On the other hand, if the user's request is not to change metric settings, decision  branches to \u201cNo\u201d branch  whereupon a determination is made as to whether the user's request is a reset request (decision ). For example, the user may choose to reset one or more metric fields to zero. If the user's request is to reset one or more metric fields, decision  branches to \u201cYes\u201d branch  whereupon the user resets one or more metric fields (pre-defined process block , see  and corresponding text for further details).","On the other hand, if the user's request is not to reset one or more metric fields, decision  branches to \u201cNo\u201d branch  whereupon a determination is made as to whether the user's request is a metrics display request (decision ). Metric data is tracked based upon the users metric settings (see  and corresponding text for further details regarding metric settings). If the user's request is to receive metric data, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays metric data to the user (pre-defined process block , see  and corresponding text for further details).","On the other hand, if the user's request is not a metrics display request, decision  branches to \u201cNo\u201d branch  whereupon a determination is made as to whether the user wishes to accumulate metric data (decision ). Instrumentation tracking may halt when the user is analyzing data or resetting data, and resume when the user is finished with his analysis. If the user's request is to start accumulating metric data, decision  branches to \u201cYes\u201d branch  whereupon processing starts metric tracking (see  for further details).","On the other hand, if the user's request is not to start tracking metric data, decision  branches to \u201cNo\u201d branch  whereupon a determination is made as to whether to continue instrumentation application processing (decision ). If instrumentation application processing should continue, decision  branches to \u201cYes\u201d branch  which loops back to receive and process the next request. This looping continues until instrumentation application processing terminates, at which point decision  branches to \u201cNo\u201d branch . Processing ends at .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3"},"Processing commences at , whereupon a determination is made as to whether to track an entry count (decision ). The entry count tracks the number of lock requests a middleware lock manager receives corresponding to a particular lock. For example, when a second application requests a lock that is in use by a first application (i.e. contention), the second application enters middleware lock manager processing and the entry count is incremented (see  and corresponding text for further details regarding entry count tracking). If an instrumentation user wishes to track the entry count, decision  branches to \u201cYes\u201d branch  whereupon an entry count flag is set to \u201ctrue\u201d (step ). On the other hand, if the instrumentation user does not wish to track the entry count, decision  branches to \u201cNo\u201d branch  whereupon the entry count flag is set to \u201cfalse\u201d (step ).","A determination is made as to whether to track a slow count (decision ). The slow count keeps track of the number of times a particular lock is acquired after waiting. Using the example described above, the slow count is incremented when the second application acquires the lock after the first application releases the lock (see  and corresponding text for further details regarding slow count tracking). If the instrumentation user wishes to track the slow count, decision  branches to \u201cYes\u201d branch  whereupon a slow count flag is set to \u201ctrue\u201d (step ). On the other hand, if the instrumentation user does not wish to track the slow count, decision  branches to \u201cNo\u201d branch  whereupon the slow count flag is set to \u201cfalse\u201d (step ).","A determination is made as to whether to track a recursive count (decision ). The recursive count tracks the number of times that an application requests a lock when the application currently owns the lock. This re-requesting event may occur in situations where the application does not know that it already owns the lock. Using the example described above, the first application may request the lock while the first application still owns the lock (see  and corresponding text for further details regarding recursive count tracking). If the instrumentation user wishes to track the recursive count, decision  branches to \u201cYes\u201d branch  whereupon a recursive count flag is set to \u201ctrue\u201d (step ). On the other hand, if the instrumentation user does not wish to track the recursive count, decision  branches to \u201cNo\u201d branch  whereupon the recursive count flag is set to \u201cfalse\u201d (step ).","A determination is made as to whether to track a queue size count (decision ). The queue size count tracks the number of applications waiting in a queue to acquire a lock. The queue size count may be configured to track various metrics corresponding to the queue. For example, the queue size count may track a maximum number of applications waiting for a lock between resets. Another example is the queue size count may track the average number of applications waiting for a lock between resets (see  and corresponding text for further details regarding queue size tracking). If the instrumentation user wishes to track the queue size count, decision  branches to \u201cYes\u201d branch  whereupon a queue size count flag is set to \u201ctrue\u201d (step ). On the other hand, if the instrumentation user does not wish to track the queue size count, decision  branches to \u201cNo\u201d branch  whereupon the queue size count flag is set to \u201cfalse\u201d (step ).","A determination is made as to whether to track spin loops (decision ). Before putting a requester in a queue to wait for a contended lock, the middleware lock manager may put the requester in a \u201cspin loop\u201d for a specified time period. The middleware lock manager waits for the spin loop time period to see if the current lock owner releases the contended lock. This is performed to avoid putting the requester in the queue, which may be expensive in terms of processing time (see  and corresponding text for further details regarding spin loop tracking). If the instrumentation user wishes to track spin loops, decision  branches to \u201cYes\u201d branch  whereupon a spin loops flag is set to \u201ctrue\u201d (step ). On the other hand, if the instrumentation user does not wish track spin loops, decision  branches to \u201cNo\u201d branch  whereupon the spin loops flag is set to \u201cfalse\u201d (step ).","A determination is made as to whether to track a hold time (decision ). The hold time is the total time that a lock is held by one or more requesters (see  and corresponding text for further details regarding hold calculations). If the instrumentation user wishes to track the hold time, decision  branches to \u201cYes\u201d branch  whereupon a hold time flag is set to \u201ctrue\u201d (step ). On the other hand, if the instrumentation user does not wish to track the hold time, decision  branches to \u201cNo\u201d branch  whereupon the hold time flag is set to \u201cfalse\u201d.","A determination is made as to whether to track a get time (decision ). The get time is the sum of time that each thread (i.e. requester) spends waiting to acquire a lock (see  and corresponding text for further details regarding get time calculations). If the instrumentation user wishes to track the get time, decision  branches to \u201cYes\u201d branch  whereupon a get time flag is set to \u201ctrue\u201d (step ). On the other hand, if the instrumentation user does not wish to track the get time, decision  branches to \u201cNo\u201d branch  whereupon the get time flag is set to \u201cfalse\u201d.","A determination is made as to whether to track a wait time (decision ). The wait time is the total time that one or more threads wait for a particular lock (see  and corresponding text for further details regarding wait time calculation). If the instrumentation user wishes to track the wait time, decision  branches to \u201cYes\u201d branch  whereupon a wait time flag is set to \u201ctrue\u201d (decision ). On the other hand, if the instrumentation user does not wish to track the wait time, decision  branches to \u201cNo\u201d branch  whereupon the wait time flag is set to \u201cfalse\u201d. Processing ends at .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 4","FIG. 7"],"b":["400","404","404","406","408","404","410"]},"A determination is made as to whether to reset a slow count field (decision ). The slow count field includes the number of times a particular lock is acquired after waiting. Using the example described above, the slow count is incremented when the second application acquires the lock after the first application releases the lock (see  and corresponding text for further details regarding slow count tracking). If the instrumentation user wishes to reset the slow count field, decision  branches to \u201cYes\u201d branch  whereupon the slow count field is reset to zero (step ). On the other hand, if the instrumentation user does not wish to reset the slow count field, decision  branches to \u201cNo\u201d branch  bypassing slow count field resetting steps.","A determination is made as to whether to reset a recursive count field (decision ). The recursive count field includes the number of times that an application requests a lock when the application currently owns the lock. This re-requesting event may occur in situations where the application does not know that it already owns the lock. Using the example described above, the first application may request the lock while the first application still owns the lock (see  and corresponding text for further details regarding recursive count tracking). If the instrumentation user wishes to reset the recursive count field, decision  branches to \u201cYes\u201d branch  whereupon the recursive count field is reset to zero (step ). On the other hand, if the instrumentation user does not wish to reset the recursive count field, decision  branches to \u201cNo\u201d branch  bypassing recursive count field resetting steps.","A determination is made as to whether to reset a queue size count field (decision ). The queue size count field includes the number of applications waiting in a queue to acquire a particular lock. The queue size count may be configured to track various metrics corresponding to the queue. For example, the queue size count may track a maximum number of applications waiting for a lock between resets. Another example is the queue size count may track the average number of applications waiting for a lock between resets (see  and corresponding text for further details regarding queue size tracking). If the instrumentation user wishes to reset the queue size count field, decision  branches to \u201cYes\u201d branch  whereupon the queue size count field is reset to zero (step ). On the other hand, if the instrumentation user does not wish to reset the queue size count field, decision  branches to \u201cNo\u201d branch  bypassing queue size count field resetting steps.","A determination is made as to whether to reset a spin loops field (decision ). Before putting a requester in a queue to wait for a contended lock, the middleware lock manager may put the requester in a \u201cspin loop\u201d for a specified time period. The spin loop field includes the number of times that the requester spins before a lock is available. This is performed to avoid putting the requester in the queue, which may be expensive in terms of processing time (see  and corresponding text for further details regarding spin loop tracking). If the instrumentation user wishes to reset the spin loops field, decision  branches to \u201cYes\u201d branch  whereupon the spin loops field is reset to zero (step ). On the other hand, if the instrumentation user does not wish reset the spin loops field, decision  branches to \u201cNo\u201d branch  bypassing spin loops field resetting steps.","A determination is made as to whether to reset a hold time field (decision ). The hold time field includes the total time that a lock is held by one or more requesters (see  and corresponding text for further details regarding hold calculations). If the instrumentation user wishes to reset the hold time field, decision  branches to \u201cYes\u201d branch  whereupon the hold time field is reset to zero (step ). On the other hand, if the instrumentation user does not wish to reset the hold time field, decision  branches to \u201cNo\u201d branch  bypassing hold time field resetting steps.","A determination is made as to whether to reset a get time field (decision ). The get time field includes the sum of time that each thread (i.e. requester) spends waiting for a lock (see  and corresponding text for further details regarding get time calculations). If the instrumentation user wishes to reset the get time field, decision  branches to \u201cYes\u201d branch  whereupon the get time field is reset to zero (step ). On the other hand, if the instrumentation user does not wish to reset the get time field, decision  branches to \u201cNo\u201d branch  bypassing get time field resetting steps.","A determination is made as to whether to reset a wait time field (decision ). The wait time field includes the total time that one or more threads wait for a particular lock (see  and corresponding text for further details regarding wait time calculation). If the instrumentation user wishes to reset the wait time field, decision  branches to \u201cYes\u201d branch  whereupon the wait time field is reset to zero (step ). On the other hand, if the instrumentation user does not wish to reset the wait time field, decision  branches to \u201cNo\u201d branch  bypassing wait time field resetting steps. Processing ends at .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 5","FIG. 7"],"b":["500","504","504","506","508","504","510"]},"A determination is made as to whether to retrieve and display slow count information by examining a slow count flag (decision ). The slow count information includes the number of times a particular lock is acquired after waiting. Using the example described above, the slow count is incremented when the second application acquires the lock after the first application releases the lock (see  and corresponding text for further details regarding slow count tracking). If the slow count flag is set to \u201ctrue\u201d, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays slow count information (step ). On the other hand, if the slow count field is set to \u201cfalse\u201d, decision  branches to \u201cNo\u201d branch  bypassing slow count retrieval and displaying steps.","A determination is made as to whether to retrieve and display recursive count information by examining a recursive count flag (decision ). The recursive count information includes the number of times that an application requests a lock with the application currently owns the lock. This re-requesting event may occur in situations where the application does not know that it already owns the lock. Using the example described above, the first application may request the lock while the first application still owns the lock (see  and corresponding text for further details regarding recursive count tracking). If the recursive count flag is set to \u201ctrue\u201d, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays recursive count information (step ). On the other hand, if the recursive count field is set to \u201cfalse\u201d, decision  branches to \u201cNo\u201d branch  bypassing recursive count retrieval and displaying steps.","A determination is made as to whether to retrieve and display queue size count information by examining a queue size count flag (decision ). The queue size count information includes the number of applications waiting in a queue to acquire a lock. The queue size count may be configured to track various metrics corresponding to the queue. For example, the queue size count may track a maximum number of applications waiting for a lock between resets. Another example is the queue size count may track the average number of applications waiting for a lock between resets (see  and corresponding text for further details regarding queue size tracking). If the queue size count flag is set to \u201ctrue\u201d, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays queue size count information (step ). On the other hand, if the queue size count flag is set to \u201cfalse\u201d, decision  branches to \u201cNo\u201d branch  bypassing queue size count retrieval and displaying steps.","A determination is made as to whether to retrieve and display spin loop information by examining a spin loop flag (decision ). Before putting a requester in a queue to wait for a contended lock, the middleware lock manager may put the requester in a \u201cspin loop\u201d for a specified time period. The spin loop field includes the number of times that a requester spins before a lock is available. This is performed to avoid putting the requester in the queue, which may be expensive in terms of processing time (see  and corresponding text for further details regarding spin loop tracking). If the spin loop flag is set to \u201ctrue\u201d, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays spin loop information (step ). On the other hand, if the spin loop flag is set to \u201cfalse\u201d, decision  branches to \u201cNo\u201d branch  bypassing spin loops retrieval and displaying steps.","A determination is made as to whether to retrieve and display hold time information (decision ). The hold time information includes the total time that a lock is acquired by one or more requesters (see  and corresponding text for further details regarding hold calculations). If the hold time flag is set to \u201ctrue\u201d, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays the hold time information (step ). On the other hand, if the hold time flag is set to \u201cfalse\u201d, decision  branches to \u201cNo\u201d branch  bypassing hold time retrieval and displaying steps.","A determination is made as to whether to retrieve and display get time information by examining a get time flag (decision ). The get time information includes the sum of time that each thread (i.e. requester) spends waiting for a lock (see  and corresponding text for further details regarding get time calculations). If the get time flag is set to \u201ctrue\u201d, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays get time information (step ). On the other hand, if the get time flag is set to \u201cfalse\u201d, decision  branches to \u201cNo\u201d branch  bypassing get time retrieval and displaying steps.","A determination is made as to whether to retrieve and display wait time information (decision ). The wait time information includes the total time that one or more threads wait for a particular lock (see  and corresponding text for further details regarding wait time calculation). If the wait time flag is set to \u201ctrue\u201d, decision  branches to \u201cYes\u201d branch  whereupon processing retrieves and displays wait time information (step ). On the other hand, if the wait time flag is set to \u201cfalse\u201d, decision  branches to \u201cNo\u201d branch  bypassing wait time retrieval and displaying steps. Processing ends at .","For the various metrics displayed during the processing shown in , in some implementations not all metrics will be applicable, either due to the application being monitored or due to the metrics that the user wanted tracked (see ). In these instances, the display described above would show that the individual metric is \u201cnot applicable\u201d to inform the user that metrics were not taken or that metric values are not applicable for the particular metric.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 6","b":["600","620","610","620"]},"A determination is made as to whether the corresponding bimodal lock is available (i.e. lock owner=0) (decision ). Middleware lock management is invoked only when the software lock at the application layer is not available for a requesting application (i.e. contended). If the corresponding lock is available, decision  branches to \u201cYes\u201d branch  whereupon processing gives the lock to requestor  (i.e. lock owner=requester 's ID). On the other hand, if the lock is not available, decision  branches to \u201cNo\u201d branch  whereupon middleware lock management is invoked to handle the lock contention (pre-defined process block , see  and corresponding text for further details regarding lock request processing). Processing ends at .",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 7","FIG. 6","FIG. 7","FIG. 2","FIGS. 7","FIG. 3","FIGS. 7"],"b":["270","8","9","8","9"]},"Processing commences at , whereupon processing receives a contended lock request (step ). An entry count corresponding to the requested lock is incremented at step . The entry count tracks the number of times a middleware lock manager is entered by a requester corresponding to a particular lock. In an alternate embodiment, the entry count can be incremented after the requester acquires the lock (see , step ).","A determination is made as to whether the lock request is a recursive request (decision ). A recursive request is a lock request from a requestor when the requester already owns the lock. If the request is a recursive request, decision  branches to \u201cYes\u201d branch  whereupon a recursive count value is incremented corresponding to the lock. The recursive count value tracks the number of times that processing receives a recursive request corresponding to a particular lock. Processing ends at .","On the other hand, if the request is not a recursive request, decision  branches to \u201cNo\u201d branch  whereupon a determination is made as to whether a corresponding thick lock is available. A thick lock is a lock that resides within an operating system (see  and corresponding text for further details regarding thick locks). If the thick lock is available, decision  branches to \u201cYes\u201d branch  whereupon and entry time value corresponding to the thick lock is set equal to the current time (step ). The entry time is used to calculate a requestor's get time and hold time (see  and corresponding text for further details regarding time-based metric calculations). The lock requester attempts to acquire the lock at step .","When the lock becomes available, middleware lock management processing does not give the requester the lock but rather gives the requestor the chance to acquire the lock. A determination is made as to whether the requester acquired the lock (decision ). If the requester did not acquire the lock, decision  branches to \u201cNo\u201d branch  which loops back to determine whether to enter a spin loop. On the other hand, if the requester acquired the lock, decision  branches to \u201cYes\u201d branch  whereupon processing tracks the acquired lock (pre-defined process block , see  and corresponding text for further details). Processing ends at .","On the other hand, if the lock is not available, decision  branches to \u201cNo\u201d branch  whereupon a request time corresponding to the lock is set to the current time (step ). The request time is used to calculate the amount of time it takes a requester to acquire the lock (see  and corresponding text for further details regarding get time calculations).","A determination is made as to whether the lock request is the first waiting requester (decision ). This determination may be made by detecting whether a queue has been configured to manage other requesters waiting for the lock. If the requester is the first waiting requester, decision  branches to \u201cYes\u201d branch  whereupon a wait start time corresponding to the lock is initialized at step . The wait start time is used to calculate a total wait time corresponding to the lock (see  and corresponding text for further details regarding wait time calculations). On the other hand, if the requester is not the first waiting requestor, decision  branches to \u201cNo\u201d branch  bypassing wait start time initialization steps.","A determination is made as to whether to enter a spin loop (decision ). A lock manager may be configured to \u201cspin\u201d a request in order to avoid adding the requester to the queue, which may be expensive in terms of processing time (see  and corresponding text for further details regarding spin loop configuration). If the lock manager is not configured to \u201cspin\u201d a request, decision , branches to \u201cNo\u201d branch  whereupon the requester is added to the queue (step ). Processing increments a queue size value corresponding to the lock at step . The queue size value is used to track the number of requesters that are waiting in the queue for a particular lock. The requester is put to sleep at step  until his turn arises to acquire the lock (step ). Processing ends at .","If processing is configured to \u201cspin\u201d the request, decision  branches to \u201cYes\u201d branch  whereupon a spin count corresponding to the lock is incremented at step . The spin count tracks the number of times a request spins. A determination is made as to whether the lock is available (decision ). If the lock is available, decision  branches to \u201cYes\u201d branch  whereupon the requester attempts to acquire the lock (step ). On the other hand, if the lock is not available, decision  branches to \u201cNo\u201d branch  whereupon a determination is made as to whether to continue spinning (decision ). For example, processing may be configured to spin a request a certain number of times before processing puts the request in the queue. If processing should continue to spin the request, decision  branches to \u201cYes\u201d branch  which loops back to increment the spin count. This looping continues until processing stops spinning the request, at which point decision  branches to \u201cNo\u201d branch  whereupon processing adds the requester to the queue at step .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 8","b":["800","830","800","800","805","810","815","820","850","825","829"]},"Acquire lock processing commences at  whereupon an entry count corresponding to the lock is incremented at step . The entry count tracks the number of times a middleware lock manager is entered by a requester corresponding to a particular lock. In an alternate embodiment, the entry count can be incremented upon receiving the request from the requester (i.e., before the lock is actually acquired, see , step ). A determination is made as to whether the requester had been queued while waiting for the lock (decision ). If the requestor had been queued, decision  branches to \u201cyes\u201d branch  whereupon another counter (LockID.SlowCount) is incremented to count the number of requesters that have been queued waiting for the lock (step ).","The time that the requester receives the lock is stored (step ) and the time that the requester first requested the lock is retrieved (step ) from lock data structures . The requestor's RequestTime may have been altered by a garbage collection event (see steps  through  for details). A determination is made as to whether the requestor's RequestTime is unknown (i.e., set to zero, null, etc.) due to a garbage collection event (decision ). If the request time is known, decision  branches to \u201cno\u201d branch  whereupon the amount of time that elapsed before the requester received the lock is calculated (step ). The calculation is performed by subtracting the request time from the current, or entry, time. On the other hand, if the request time is not known, decision  branches to \u201cyes\u201d branch  bypassing the calculation shown in step .","Processing then waits until the requestor releases the lock (step ). The time that the requester released the lock is stored (step ) and the time that the requester first entered the lock (EntryTime) is retrieved (step ) from lock data structures . The EntryTime retrieved may not be the same as the entry time stored in step  because an intervening garbage collection event may have occurred which altered the requestor's EntryTime.","A determination is made as to whether the retrieved EntryTime is unknown (i.e., set to zero, null, etc.) due to a garbage collection event (decision ). If the entry time is known, decision  branches to \u201cno\u201d branch  whereupon the amount of time that elapsed while the requester held the lock is calculated (step ). The calculation is performed by subtracting the current time (i.e., the exit time) from the entry time. In addition, the same calculation is made to keep track of the amount of time the lock was held (step ), irrespective of the requester that held the lock. On the other hand, if the entry time is not known, decision  branches to \u201cyes\u201d branch  bypassing the calculations shown in steps  and . Acquire lock processing thereafter ends at .",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 9","b":["900","910"]},"A maximum queue size is calculated for the thick lock (step ). The maximum queue size is calculated by determining the largest number of entries that have been queued waiting for the lock. This calculation is made by comparing the current number of queued items with the maximum queue size value. If the number of queued items is greater than the maximum queue size, then the maximum queue size value is updated to be equal to the number of queued items. A determination is made as to whether a queue size snapshot should be taken (decision ). A queue size snapshot captures the number of entries in the queue at various time intervals so that the user can analyze the number of processes waiting for the lock across a time span. For example, the queue size snapshot can be taken every second. If it is not time to take a queue size snapshot, decision  branches to \u201cno\u201d branch  bypassing the snapshot steps. On the other hand, if it is time to take a queue size snapshot, decision  branches to \u201cyes\u201d branch  whereupon a time interval is incremented (i.e., representing snapshot interval , , , etc.) at step . The current queue size for this time interval is saved (step ) for later retrieval and analysis by the user.","A determination is made as to whether there are application threads in a queue waiting to acquire the thick lock (decision ). If there are more threads in the queue waiting to acquire the thick lock, decision  branches to \u201cYes\u201d branch  whereupon a queue size field corresponding to the thick lock (lockid.queuesize) is decremented (step ). The queue size field tracks the number of application threads waiting for a particular lock. The queue size field may be configured to track various metrics of the queue.","On the other hand, if there are no threads in the queue waiting to acquire the thick lock, decision  branches to \u201cNo\u201d branch  whereupon the lockid.queuesize field is set to zero at step  (i.e., reset the lockid.queuesize field). Processing calculates a lockid.waitstop time by subtracting a lastprocessid.holdtime from the current time (step ). The lockid.waitstop time corresponds to the time that the last thread (i.e. process) acquired the lock. The lastprocessid.hold time is the amount of time the last thread (i.e. process) used the lock. Processing calculates a wait time (lockid.waittime) for the thick lock by subtracting a lockid.waitstarttime from the lockid.waitstoptime (step ). The lockid.waittime field corresponds to the total time spent by one or more threads to acquire the thick lock (see  and corresponding text for further details regarding wait time calculations). The lockid.waitstart time corresponds to the starting time that a first started waiting for the thick lock (see  and corresponding text for further details regarding wait start time).","An operating system (OS) releases the thick lock which allows other threads the ability to acquire the lock. When the OS releases the thick lock, middleware lock management halts until contention arises again with the corresponding thin lock (predefined process , see  and corresponding text for further details regarding thin lock processing). Lock queue manager processing ends at .",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 10","b":["1020","1040","1060","1080","1010","1020","1025","1020","1030","1035"]},"Thread  is the second thread to request the lock at . Since thread  owns the lock at the time corresponding to , thread  waits for time  until thread  releases the lock, at which point thread  acquires the lock at . Time  is the time that thread  waits to acquire the lock which is also referred to as 's \u201cget time\u201d. Thread  uses the lock during , and releases the lock at .","Thread  is the third thread to request the lock at . Since thread  owns the lock at the time corresponding to  and since thread  is the next thread to have the chance to acquire the lock, thread  waits for time  until thread  releases the lock, at which point thread  acquires the lock at . Time  is the time that thread  waits to acquire the lock which is also referred to as 's \u201cget time\u201d. Thread  uses the lock during , and releases the lock at .","Thread  is the fourth thread to request the lock at . Since thread  owns the lock at the time corresponding to  and since thread  is the next thread to have the chance to acquire the lock, thread  waits for time  until thread  releases the lock, at which point thread  acquires the lock at . Time  is the time that thread  waits to acquire the lock which is also referred to as 's \u201cget time\u201d. Thread  uses the lock during , and releases the lock at .","Processing tracks various metric values for the lock (see  and corresponding text for further details regarding metric values). Processing tracks hold time  which is the total time that one or more threads use the lock. The example in  shows that hold time  starts at  when thread  acquires the lock, and ends at  when thread  releases the lock. Processing also tracks wait time  which is the total time that one or more threads wait for the lock. The example in  shows that wait time  starts at  when thread  starts to wait for the lock, and ends at  when thread  acquires the lock (i.e. stops waiting for the lock). Processing may also track a total \u201cget time\u201d for a particular lock. The lock's total get time is the summation of each threads time waiting for the lock. In , the get time is calculated by adding , , and . The total get time, along with other metric values, may be used by an instrumentation user to analyze the performance of a computer system.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 11","b":["1101","1101","1100","1105","1110","1105","1115","1120","1125","1100","1110","1120","1105","1125","1130","1135","1125","1140","1145","1150","1155","1160","1162","1164","1166","1168","1170","1172","1140","1140"]},"BIOS  is coupled to ISA bus , and incorporates the necessary processor executable code for a variety of low-level system functions and system boot functions. BIOS  can be stored in any computer readable medium, including magnetic storage media, optical storage media, flash memory, random access memory, read only memory, and communications media conveying signals encoding the instructions (e.g., signals from a network). In order to attach computer system  to another computer system to copy files over a network, LAN card  is coupled to PCI bus  and to PCI-to-ISA bridge . Similarly, to connect computer system  to an ISP to connect to the Internet using a telephone line connection, modem  is connected to serial port  and PCI-to-ISA Bridge .","While the computer system described in  is capable of executing the invention described herein, this computer system is simply one example of a computer system. Those skilled in the art will appreciate that many other computer system designs are capable of performing the invention described herein.","One of the preferred implementations of the invention is an application, namely, a set of instructions (program code) in a code module which may, for example, be resident in the random access memory of the computer. Until required by the computer, the set of instructions may be stored in another computer memory, for example, on a hard disk drive, or in removable storage such as an optical disk (for eventual use in a CD ROM) or floppy disk (for eventual use in a floppy disk drive), or downloaded via the Internet or other computer network. Thus, the present invention may be implemented as a computer program product for use in a computer. In addition, although the various methods described are conveniently implemented in a general purpose computer selectively activated or reconfigured by software, one of ordinary skill in the art would also recognize that such methods may be carried out in hardware, in firmware, or in more specialized apparatus constructed to perform the required method steps.","While particular embodiments of the present invention have been shown and described, it will be obvious to those skilled in the art that, based upon the teachings herein, changes and modifications may be made without departing from this invention and its broader aspects and, therefore, the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore, it is to be understood that the invention is solely defined by the appended claims. It will be understood by those with skill in the art that if a specific number of an introduced claim element is intended, such intent will be explicitly recited in the claim, and in the absence of such recitation no such limitation is present. For a non-limiting example, as an aid to understanding, the following appended claims contain usage of the introductory phrases \u201cat least one\u201d and \u201cone or more\u201d to introduce claim elements. However, the use of such phrases should not be construed to imply that the introduction of a claim element by the indefinite articles \u201ca\u201d or \u201can\u201d limits any particular claim containing such introduced claim element to inventions containing only one such element, even when the same claim includes the introductory phrases \u201cone or more\u201d or \u201cat least one\u201d and indefinite articles such as \u201ca\u201d or \u201can\u201d; the same holds true for the use in the claims of definite articles."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features, and advantages made apparent to those skilled in the art by referencing the accompanying drawings. The use of the same reference symbols in different drawings indicates similar or identical items.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
