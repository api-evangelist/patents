---
title: Accessibility system and method
abstract: A method and system providing a client with user interface information are described. An accessibility system for providing user interface information to a client. The accessibility system comprises an accessibility system core including user interface automation services and APIs. The user interface automation tools filter information based on whether the user interface information is interesting to the client. The accessibility system additionally comprises a client side interface including a logical tree for revealing user interface information that is interesting to the client and for hiding user interface information that is not interesting to the client. The accessibility system also comprises a server side interface for facilitating information transfer from a server side regardless of the server side technology.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07434167&OS=07434167&RS=07434167
owner: Microsoft Corporation
number: 07434167
owner_city: Redmond
owner_country: US
publication_date: 20030214
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention claims the benefit of U.S. Provisional Application Ser. No. 60\/415,339, filed Sep. 30, 2002.","Not Applicable.","The invention relates to the field of assistive technology and automated testing products and the interaction of these products with user interface information.","Assistive technology (AT) products exist to help computer users who have a need for assistance in areas of learning, communication and access to information contained in and presented by computer software. These products have a need for information relevant to the computer interface. Similarly, existing automated testing products and user interface commanding utilities also have a need for information about the user interface. Currently, these products have no sufficient source of user interface (UI) information. These three types of products (clients) are required to have necessary support from elsewhere to enable them to: (1) gather information about an application's user interface; (2) programmatically discover and interrogate UI elements regardless of the technology used to build the UI; (3) generate keyboard and pointer input; and (4) understand what type of behavior or functionality is currently available. No single technology is available currently that gives an AT product all of these capabilities. Furthermore, current AT products are not always compatible with all graphical operating system (OS) technologies and lack the ability to filter and coordinate redundant or misleading notifications in a centralized way. An additional disadvantage is that current automation and accessibility infrastructures are not extensible and therefore require OS level changes to add new functionality.","Furthermore, currently to gather information about an application's user interface, the AT product must write application-specific code to obtain information for the user. The process of writing this application-specific code is time consuming and requires continuous maintenance. Current automation infrastructure also lacks the ability to filter and coordinate redundant or misleading event notifications in a consistent manner. Thus, event consumers are required to independently filter information.","Current systems allow AT products to request event notifications in three levels of granularity: (1) everything on a desktop; (2) in a particular process (such as opening of a word processor); or (3) in a thread in the particular process (multiple objects doing work in the process). Currently, when the client receives an event, it receives a window handle for a specific window in which the event occurred and other bits of information to indicate where the event occurred. A client can make a cross process call to retrieve the UI object that is related to the event. With this object, the client can make additional cross process calls to ask for information about that object. If the client needs five pieces of information, then the client must make five cross process calls. Cross process calls are exceedingly slow, so the performance cost of collecting UI information using current accessibility infrastructure is high. This type of known scenario is shown in . A server application  fires an event . A kernel  determines which clients must be notified and sends an event notification  to an interested client . The client  makes a request  from the server application  across a process boundary  for the object related to the event notification . The server application  returns the object  and then the client  can begin sending requests  for information about the UI control which fired the event. The server application  returns the requested information  across the process boundary  to the client .","Another current option allows client code to be loaded as a dynamic link library (.DLL) within a process. This option has several drawbacks. First, it requires cooperation from the system to load client code into a process. Second, it gives rise to security issues because once in the client code is loaded into an application's process, it is difficult to restrict the information it gathers. Third, to be an effective technique for the client, it must be loaded into every process on the system. Optimally, only trusted clients should be loaded into another application's process.","Furthermore, a system is needed that gives the client the ability to specify what event notifications it wants to receive. In known systems, a client may need to make a number of cross process calls and then analyze the information to determine if it is interested in the event. A mechanism is needed that can perform this event filtering in a more performant manner and that can be easily updated to support new system or application events. Furthermore, a system is needed that uses only trusted components in order to alleviate security concerns.","Currently, when seeking information about a user interface, the AT product is required to access trees that are native to a particular UI framework. Accordingly, multiple trees are required to convey user interface information for multiple UI frameworks. These differing trees may contain information which is not of interest or is not visible to the user, such as hidden container objects which manage the visible UI controls manipulated by the end user. Therefore, a need exists for a single unified tree having only those nodes that are of interest to the user.","A solution is needed that addresses the needs of AT products, automated testing tools, and commanding utilities. The solution should be usable by all graphical OS technologies and should allow all forms of UI and UI components to become accessible.","The present invention is directed to a method and computer application for providing a client with user interface information. In one aspect of the invention, an accessibility system for providing user interface information to a client is provided. The accessibility system includes an accessibility system core including user interface automation services for filtering information based on whether the user interface information is interesting to the client. The accessibility system additionally includes a client side interface including a logical tree for revealing user interface information that is interesting to the client and for hiding user interface information that is not interesting to the client. The accessibility system also includes a server side interface for facilitating information transfer from a server side application regardless of the user interface engine used to build that application.","In yet another aspect of the invention, a computer-implemented method for providing user interface information to a client is provided. The method includes monitoring user interface information with accessibility system automation services and transferring user interface information over a server side interface regardless of server side technology. The method further includes determining specific user interface information that is interesting to the client using a logical element tree that forms a part of the client-side interface.","Additional advantages and novel features of the invention will be set forth in the description which follows, and in part will become apparent to those skilled in the art upon examination of the following, or may be learned from practice of the invention.","Exemplary Operating Environment",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multiprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system  for implementing the invention includes a general purpose computing device in the form of a computer  including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit .","Computer  typically includes a variety of computer readable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/nonremovable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to nonremovable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/nonremovable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through an non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  in the present invention may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user-input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Although many other internal components of the computer  are not shown, those of ordinary skill in the art will appreciate that such components and the interconnection are well known. Accordingly, additional details concerning the internal construction of the computer  need not be disclosed in connection with the present invention.","Accessibility System Structure","As shown in , an accessibility system  interacts with a client environment  and a server environment . The accessibility system  may be implemented in the computer environment  described above with respect to . The accessibility system  includes a client side accessibility interface  for facilitating interaction with the client , a server side accessibility interface  for facilitating interaction with the server side , and an accessibility system core . The accessibility system  of the invention provides new application program interfaces (APIs), interfaces, and metaphors for programmatically accessing a user interface (UI). The accessibility system  allows applications to make themselves and any components they use accessible.","The client environment  preferably includes an assistive technology (AT) product or automated UI testing tool. The server side  may implement a variety of different technologies as shown in . A server system  includes an adapter  and a core , which may be found in a first type of UI. A server system  includes a proxies component  and controls  as may be found in a second type of UI, such as a Win32 UI available in Microsoft Operating System products, from the Microsoft Corporation of Redmond, Wash. The server system  includes an adapter  and internal OM , which may be found in an alternative third type of UI.","As shown in , an event mechanism , which is included in the accessibility system , relies on a UI automation client  and a UI automation server  for facilitating interaction with the client environment  and the server environment . The UI automation client  and the UI automation server  are described in greater detail below with reference to the events mechanism  of the invention. The accessibility system  of the invention gives the client (AT Product)  the capability to: (1) gather information about an application's user interface; (2) programmatically discover and interrogate UI elements regardless of the technology used to build the UI; (3) generate keyboard and pointer input; and (4) understand what type of behavior or functionality is currently available. The accessibility system  allows applications to make themselves and their components accessible. The structure shown in  enables five major aspects of the accessibility system  including: (1) logical UI tree; (2) Control Patterns; (3) Event Mechanism; (4) Input API (not covered in this document); and (5) properties.","UI Access Logical Tree ","An integral component of the accessibility system  is the logical tree , an example of which is shown in . The tree  is included in the client side accessibility interface .","The logical tree  is a filtered view of the underlying structural hierarchy of UI elements, not a separate tree that must be implemented by the control or application developer. Instead, it keys off a few well-defined properties, interesting and uninteresting, which indicate whether a structural element should be exposed in the logical tree . The accessibility system core  consumes this information to produce the filtered UI logical tree  that is, in turn, presented to the AT products or test script.","The logical tree  is a tree of elements, each of which represents a control, an item in a control, or a grouping structure, which may be a dialog, pane, or frame. The structure of the logical tree  should represent the UI of the application as perceived by the user (even if the controls are actually implemented using a different underlying structure). The tree should be stable over time. As long as an application looks the same to a user, the logical tree  representing that application should remain the same, even if implementation details of the application behind the scenes have changed. Native elements that exist for structural and implementation reasons, such as a shell's \u201cShDocView\u201d window in the Microsoft OS products should not appear in this tree, since the user does not perceive them.","The logical tree  is a single tree built from a plurality of fragments that is capable of unifying a plurality of different processes so that they are the same to the client. The logical tree  enables bulk retrieval and is capable of obtaining a value for a list of properties. By the time a user normally would have invoked a cross process call to ask for values, the accessibility system  will have fetched them through the use of the logical tree .","Instead of being constructed in one step as in the known systems, the logical tree  is constructed from fragments that are used to build a raw tree. As shown in , three main procedures build the logical tree . In procedure , the accessibility system  locates native elements of underlying technologies and arrives at the native trees shown in . In procedure , the accessibility system  combines native elements to form the raw tree  as shown in . Finally, in procedure , the logical tree  is obtained by hiding uninteresting components in the raw tree  as shown in .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4(A)","b":["10","14","10","11","12","14","15","16","16"]},"As shown in , the native trees  and  may be combined to form a raw tree . The raw tree  includes a parent node , having two child nodes  and . The child node  has descendants - and the child node  has descendants -. This raw tree  is a combination of the native trees  and , with the nodes of the native tree  forming nodes - and the nodes of the native tree  forming nodes -.","Through a method broadly shown in , the raw tree  is converted into the logical tree . To move from the raw tree  to the logical tree , a developer can insert hints in the raw tree. The developer can mark nodes within the raw tree  as \u201chide self\u201d or \u201chide self and children\u201d or as \u201chide children of node\u201d, etc. The developer can also move nodes sideways or place nodes before children. These \u201chints\u201d and modifications in the raw tree  are used to form the logical tree . For example, in , a developer has marked nodes - and  of the raw tree  as uninteresting as indicated by blocks  and . Typically, nodes that contain elements that will not be visible to the user are marked as uninteresting. Nodes related to the visible UI are typically considered to be interesting and will be included in the logical tree  for use by the AT client . As shown in , the nodes marked as uninteresting are not included in the logical tree .","The accessibility system  uses the logical tree  to find information about events, the state of the system, the location of objects and information about controls. Known systems have not had the capability to scope within their trees. The logical tree  can be navigated based on the preferences of the client  and is capable of providing information regardless of the server side application in use.","In operation, if a client  needs to obtain information for a user about an application, the client  looks for a button to press and observes text on the button. The client  would call an API \u201cfind an element\u201d. The API will return a value that is referenced to a position in the logical tree  of the client side interface . Through the logical tree , the accessibility system  gives the client  an abstract view of the UI regardless of the application in use. The abstract model includes structures, properties, events, and functionality that a list box, button or other UI component can expect to have in common with one another.","The logical tree  is a single unifying tree that is a logical representation of the UI and is formed into a shape that includes only elements of interest to clients . Accordingly, instead of forcing AT products to filter the structural hierarchy of UI elements and guess at the model being presented to the end user, the logical tree  presents a hierarchy that closely maps to the structure being presented to the end user. This greatly simplifies the AT product's task of describing the UI to the user and helps the user interact with the application.","Because this logical UI tree  is a fundamental part of the accessibility system , all of the other components of the accessibility system  are designed to work from the logical tree . For example,  shows a simple dialog box  that appears to have a very simple structure. However, when viewed through the currently available accessibility technology, the structure of this dialog box  is surprisingly complex. It contains  objects that an AT product must filter through to discover those that are meaningful to the end user. With the accessibility system  and its support for the logical UI Tree , the developer who owns this dialog box  can set a few properties to present the following structure shown in  to the AT products .","As shown in , for a \u201cRun\u201d dialog, the developer can indicate as interesting, the flying window graphic  and \u201cType the name of program, folder, document, or internet resource and windows will open it for you\u201d at . The developer can also indicate as interesting the combo box  including notepad, word, calculator, etc., and the OK , cancel  and browse  buttons. This offers developers a low-cost mechanism to tag their element hierarchy and thereby produce a logical representation of their application's UI through the UI accessibility system . Each of the features shown may be represented by a node that has a specified relationship to each other node in the logical tree . This logical representation offers an immediate benefit to a testing team and to AT products or clients .","A set of APIs allows the client  to get to the tree. Functionality includes: (1) logical element from point to point; (2) logical element from event; and (3) currently focused logical element. As set forth above, a logical element represents a UI component, possibly a control, a part of a control, or a container or logical grouping (i.e. dialog, pane, or frame). Controls can vary greatly in terms of their functionality. Accordingly, different interfaces are used to represent functionality associated with particular types of controls. These control-specific interfaces derive from a common base interface that represents functionality common to all controls. The common base interface contains: (1) methods for navigating the logical tree ; (2) a general method for getting property values; and (3) methods for accessing supported control-specific interfaces. In navigating the logical tree , each underlying application UI technology will provide its own technique for navigation.","Although the logical tree  is of ultimate interest to the user, the raw element tree  also serves some important functions. While the logical tree  contains only elements that the user can relate to, the raw element tree  contains nodes, such as , that represent the implementation structure of the underlying framework. For a Win32 UI fragment, for example, this tree would contain nodes that represent HWNDs. In some respects, the raw element tree  is a \u2018half-way house\u2019 between the logical element tree  and the underlying frameworks' own native element trees. The raw element tree  is used as a basis for building the logical element tree , and it is where native elements first plug into the system.","The raw element tree  can also be used for debugging and testing. It is useful for pinpointing or describing where a particular problematic node is. Functionality on a base raw element node includes: methods for navigating the raw element tree; a method for jumping to a corresponding logical element (if one exists); property containing \u2018debug string\u2019 for this element\u2014e.g. \u201cHWND 0x483FE\u201d for HWND nodes; and other \u2018behind the scenes infrastructure\u2019 methods. These other methods enable hit testing and location; events; and exposing properties that frameworks can easily provide (e.g. focused, enabled).","The raw element tree  contains nodes - that represent elements from various rendering engines. The raw element tree is used as a starting point for rendering engines to plug themselves into the accessibility system  and is built from lightweight adapter objects which adapt native elements, such as HWNDs from Win32, into a unified logical tree . It is additionally used for handling hosting transitions, where one technology hosts another. Since the raw element tree  is the base on which the logical tree  is built, it can be used to check that the logical tree  is complete and connected and can be used to check for unaccounted-for elements. The raw element tree  may further be used for other infrastructure-like tasks: such as providing some basic element ID and providing some basic framework-provided element properties, such as focused, enabled, and location.","The raw element tree  is not the primary source of information for AT products or clients , is not used for logical navigation and is not exposed to end-users. The raw element tree  also cannot be used to capture an element's position in tree so that it can be returned to at some future point in time. The logical element tree  performs all these functions.","The raw element tree  can typically be built mechanically from the raw elements of the underlying rendering technology (HWNDs, Elements) without knowledge of the logical elements represented. It can therefore be used to look for raw elements, which have not been accounted for in the logical tree . The raw element tree  is a useful debugging and diagnostic tool, as it allows a \u2018stack dump\u2019-like description of a node's location to be captured. Furthermore, known systems base their trees on code specific criteria and are difficult to implement with diverse technologies. The present approach uses a general abstract \u2018raw element\u2019 type, which can be implemented by or on behalf of any underlying rendering technology.","In order to obtain the raw element tree, calling a raw element root will get a desktop element, verified by making sure that its parent is NULL and all other nodes have it as their ultimate ancestor. To obtain other elements, calling a method to obtain a raw element from a specified point will return the element using valid screen coordinates. After obtaining the raw element tree, it can be checked and verified by checking the elements (parents, siblings and children).","In operation, the client  can navigate the raw element tree  using relationships such as: parent; next sibling, previous sibling, first child, last child, etc. The client  can then jump from the raw element to the corresponding logical element in the logical tree .","Events Mechanism","When a client  wants to keep informed of events, the client  is able to register through the UI automation client  as shown in  to obtain the information. The client  specifies object information it wants to receive, where it wants the information to go, and the list of properties it wants to get back. The client request goes to UI automation client . UI automation client  can monitor any process on the desktop. The UI automation server  keeps track of which clients  are listening and knows how to get back to UI automation client . The UI automation client  advises the UI engine  of client interest, so the UI engine  knows when to tell the UI automation server  of the event. The UI engine does not have to utilize the client advice but may choose instead to always notify the UI automation server  of events or notify the UI automation server only if a client is listening for any events. The advice is useful if the UI engine wants to turn on UI automation server notification only if there is a client listening for events. The UI engine would do this to avoid possible degradation of speed of the UI and to avoid loading code modules it doesn't otherwise need.","The UI Engine  then informs the UI automation server  of a UI event. UI automation server  returns the requested logical element to the client  and sends information to the client  including properties of the event that the client  requested. The UI automation server  decides what information is within the scope of client request and only forms a logical element if the information is of interest. Forming a logical element includes pre-fetching, on the UI automation server side, the set of properties that the client has indicated it will use when handling the event. For example, the UI automation server  can discover a logical element for a combo box. The scope would be the combo box or its children. The client  can request children\/parent\/dependents to define scope during the registration phase.","After the UI automation server  determines whether information is within the requested scope, it builds a logical element. The UI automation client  serves the client  by talking to target applications receiving the requested information from the UI automation server  and routing objects to a proper space on the client .","The UI automation server  is created when the client  registers to receive event notification. As an example, a UI engine  is running the Microsoft Word word processing application. The client  has registered for name property change. The client's registration causes the UI automation server  to be created. The client's registration also advises the UI engine  to start notifying the UI automation server  for the name property. The UI engine  doesn't get scope information. The UI engine  calls one of the APIs for the server side. The UI engine  specifies (1) what property changed; (2) the new value of the property; and (3) perhaps the old value. The UI automation server  is created based on events of interest to the client  and therefore knows events, properties, clients, and scope of interest so it knows if any client  is interested in the created logical element. If more than one client  has registered for events with a particular UI automation server  and the clients  have registered for the same event and have asked for properties to be bulk fetched with the returned logical element, when the UI automation server  sends an event back to the clients , each client  will get the union of the requested bulk fetch properties returned with the logical element.","For each client  listening, the UI automation server  notifies the client  passing the client the logical element associated with the event. The UI automation server  creates only one logical element. This is an improvement over the current technology in which each client  would be required to ask for their own copy of the object that is the source of the event.","If the UI engine  does not utilize the UI automation client's advice when clients register for events, the UI engine  can ask the UI automation server  if there are any accessibility clients  listening and if no one is listening, then can avoid the work of creating the information and sending it to the UI automation server . For example, a screen reader is the client  and specifies where it wants information to go, the focus change object to receive events, and the specific list of properties of interest. The UI engine  is advised and knows it should send events to the UI automation server . Upon detecting focus changes, the UI engine  notifies the UI automation server . The UI automation server  converts to a well-known interface and sends the event and object to the UI automation client . The UI automation client  routes the object to an appropriate space on the client .","The above-described components improve upon the known systems by eliminating the central repository in the kernel for events. Instead, the UI automation server  knows all clients  interested in getting information about the context in which it is running. The elimination of the kernel repository also creates a more peer-to-peer interaction, since the UI automation server  fulfills the function previously performed in the kernel. The accessibility system  of the invention gives client  the ability to specify what it wants to see such that filtering is accomplished on the server side using the UI automation server .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 7","b":["80","300","82","202","204","84","206","86","204","206","88","204","90","204","92","90","204","202","94","96","202","300"]},"The event mechanism  of the accessibility system  allows the client  to register to receive event notifications for property changes in the UI, tree changes in a control's structure, multimedia events, and related information. Without these capabilities, clients  have to continually poll all the UI elements in the system to see if any information, structure, or state has changed. The accessibility system  events mechanism  also allows clients  to receive events out-of-process, request a collection of properties to be returned with the event notification, and to register for events on multiple elements.","The event mechanism  exposes: the interfaces the AT product or test application uses to register for events; interfaces the AT product implements on objects used to receive event notifications; and the interfaces control implementers use to notify the event engine of UI events. The event mechanism  is used to allow AT products and test applications to receive events independently of the UI engines used to render UI and allows AT products and test applications to track top-level application windows and focus without regard to the underlying technology.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 2","b":["300","200","300","400","200","300"]},"A top-level window is a window whose parent is the desktop. The use of the term \u201copened\u201d indicates that a new top-level window has appeared to the user. The use of the term \u201cclosed\u201d indicates that a top-level window has been destroyed.","The accessibility system server side interface  includes two APIs for notifying the accessibility system  of events being added and removed. The UI automation client calls these APIs when clients register and unregister for events. This allows the UI engine  to get information about what accessibility events are being requested in its context.","Where applicable, events are associated with logical elements from the application's logical element tree . Where logical elements are not applicable, events are associated with a human readable string or other well-known object that represents the source of an event. The event mechanism  provides filtering based on user supplied preferences during event registration. By using the client's filtering preferences at the server, before creating the event-related data and sending it cross process to the client, the event mechanism  inherently improves out-of-process performance by reducing the number of cross process calls. The event mechanism  provides a way to specify the properties of a logical element that are interesting for the event during event registration. This further reduces the number of cross-process calls. The event mechanism  is extensible without requiring major operating system (OS) changes. Although the event mechanism  may be implemented using managed code, unmanaged applications can access it through COM interoperability.","There are two tasks the AT client  performs to handle events: (1) event registration; and (2) handling the event in a callback. An important requirement for either task is to be usable in both managed and unmanaged code. In one embodiment of the invention, the client  may pass interfaces when registering for events. The client  passes objects that implement well-known interfaces when registering and the UI engine  calls back on those interfaces to notify the listener. In the cases where there is a source object in the logical element tree , each of the callbacks receives the source element and an additional parameter.","Well-known interfaces implemented by the AT product are used as the way to return events. The following sections show some types of events, what registration looks like and how the event is received.","1. Top-Level Window Events","Top level window events include events related to menus and combo box dropdowns or any feature having the desktop as a parent. In an embodiment of the invention, an AddTopLevelWindowListener method is used to receive notification of top level windows being opened and closed. Calling AddTopLevelWindowListener will get notifications for new top-level windows opening or top-level windows being closed on the current desktop. A RemoveTopLevelWindowListener method provides a mechanism to stop receiving notifications for top-level windows being opened, or closed, on the desktop. This method uses a callback object to identify this listener. Therefore, the object passed in to the RemoveTopLevelWindowListener method is the same as that passed to AddTopLevelWindowListener. An OnTopLevelWindowOpened method is called by the accessibility system  once for each new, top-level window that is opened. Similarly, an OnTopLevelWindowClosed method may be called by the accessibility system  once when a top-level window has closed. To receive these notifications, the client  calls the AddTopLevelWindowListener method.","2. Focus Events","Clients  often require a method for tracking focus. Doing this in the Microsoft Windows OS is difficult. For instance, when a menu is dropped down (e.g. the File menu in Microsoft Word) the items in the menu get focus as the user moves the cursor down each one. When the menu closes (e.g. the user presses the ESC key) today there is no focus event sent. Instead the client interested in focus changes must listen to a number of events and figure out which of those logically represents a focus change. In an embodiment of the invention, an AddFocusChangedListener method may be used to notify the listener of focus change events. The client  may specify a set of properties to be returned. This feature of specifying properties to return with the logical element is part of all event registration APIs. The client  may call a RemoveFocusChangedListener method to stop receiving notifications for focus changes. This method may use the callback object to identify this listener and in this case the objects passed in to the RemoveFocusChangedListener method will be the same as that passed to the AddFocusChangedListener procedure. The accessibility system  calls an OnFocusChanged method when focus has changed. A FocusEventArgs parameter used in the OnFocusChanged method exposes information related to the focus change. If the information about the last focused logical element is available, then that element will be available in the event args parameter used in the OnFocusChanged element. There are cases when no UI element has focus until something explicitly puts focus on an element.","3. Property Change Events","Property change events are fired when properties of logical elements change. In an embodiment of the invention, a client  calls an AddPropertyChangedListener method to receive notifications for property changes. An OnPropertyChanged method is called by the accessibility system  when the value of a property has changed on a logical element within the logical element tree specified in AddPropertyChangedListener. A scope parameter indicates for what elements an event should be fired. For instance, passing the root logical element of a window and a request for descendants limits property change callbacks to that window. If the scope parameter is set to all elements in the tree, then the scope is ignored and any changes to the specified properties that occur on the desktop are sent. A client  may call AddPropertyChangedListener multiple times with different sets of properties and\/or a different callback object. The notification provided by the accessibility system  indicates: the property that changed; the new property value; and the old property value if available.","A client  may call a RemovePropertyChangedListener method to stop receiving notifications for property changes. This method may use the scope element and callback object to identify this listener and in this case the objects passed in must be the same as that passed to AddPropertyChangedListener.","4. Events from Controls Patterns","The events fired from controls patterns need to be extensible and therefore these events are identified by a GUID. Any GUID value is accepted when registering. For any new control pattern, the events it documents need to be unique GUIDs. AT products may need to be modified to listen for new control pattern events. The listener also needs to be able to scope these events. For instance, directed testing may want to limit these events to a particular application or control within an application. The controls patterns define what the source is and event consumers will need to refer to that part of the documentation in order to know how to use a source element and event argument object.","An AddEventListener method will enable the client  to receive events for controls. The scope parameter can be used to indicate for what elements to fire events. For instance, passing the root logical element of a window and requesting descendants will limit events to that window. If all elements in the tree are desired, then all events on the desktop will be sent. A RemoveEventListener method may be used to stop receiving an event for controls. This method may use the scope element, callback object and an event identifier to identify the listener. In this case, the objects passed in must be the same as that passed to AddEventListener.","When an application has invoked the AddEventListener method, an OnEvent method is called by the accessibility system  when a control-specific event is fired and the source of the event is a logical element within the logical element tree specified in AddEventListener. When events for controls are fired there is often event-specific information available.","A RemoveAlIListeners method may be called to stop receiving any events. This is a quick way to clean up before a client application shuts down. The removal method may optimally be used when terminating an application.","5. Logical Structure Change Events","Logical structure change events are fired when the logical element tree structure changes. An AddLogicalStructureChangedListener method may be implemented to receive notifications for structural changes in the logical element tree. When logical elements are added, removed or invalidated, methods on the specified callback object are called. The scope parameter can limit the elements as set forth above. A RemoveLogicalStructureChangedListener method may be called to stop receiving events for logical element tree changes. This method may use a callback object and a scope element to identify this listener and in this case the objects passed in must be the same as those passed to AddEventListener.","An OnChildAdded method may be called by the accessibility system  when a child element is added and the parent is a logical element within the logical element tree  specified in AddLogicalStructureChangedListener. An OnChildRemoved method is called by the accessibility system  when a child element is removed and the old parent is a logical element within the logical element tree specified in AddLogicalStructureChangedListener.","An OnChildrenBulkAdded method is called by the accessibility system when a large number of children are added (e.g. greater than 20 children) within a short period of time. An OnChildrenBulkRemoved method is called by the accessibility system when a large number of children are removed within a short period of time. An OnChildrenlnvalidated method is called by the accessibility system  when a large number of children (e.g. greater than 20 children) are both added and removed within a short period of time.","6. Multimedia Events","Another type of event is the multimedia event. Multimedia may include sound, video, and animation. The methods will support multimedia events and notify a client of actions including \u201cstopped\u201d, \u201cpaused\u201d, \u201cfastforwarded\u201d, \u201crewound\u201d, and \u201cmuted\u201d. Methods similar to those described above may be implemented for adding and removing multimedia listeners.","7. Simple Sound Events","Simple sound events may be handled separately from multimedia events. Simple sound events represent simple, short-duration, sounds that exist to convey to the user some event other than the sound itself. Simple sound events may include: the sound played when new mail has arrived; the sound generated when the battery on a laptop is low; or the sound played when a message box is displayed with the IconExclamation type. An AddSoundListener method can be called to receive notification of simple sounds being played and a RemoveSoundListener method may be implemented to stop receiving notifications for simple sound events.","An OnSound method is called by the accessibility system  when a simple sound has played. To receive this notification, the listening application calls AddSoundListener. The OnSound method retrieves the following information: the name of the sound; the source of the sound; and an alert level value indicating the importance of the sound to the user. Possible alert levels include: \u2018unknown\u2019, indicating that the importance is unknown; \u2018informational\u2019, indicating that information has been presented; \u2018warning\u2019, indicating a warning condition; \u2018question\u2019, indicating that a user response is required; \u2018exclamation\u2019, indicating that the event is non-critical but may be important; and \u2018critical\u2019, indicating the occurrence of a critical event.","8. Soft Focus Events","Soft focus events appear on the desktop but stay in the background. Some examples of soft focus events are: a balloon help window indicating \u201cNew updates are available\u201d in the notification area; a flashing icon in the task bar for a background application that wants to gain focus; and a printer icon appearing and disappearing from the notification tray when printing starts and ends. These events may seem to overlap somewhat with other event categories (multimedia may involve animation events as does soft focus) However, the event will be categorized based on what it conveys to the user rather than how it is conveyed.","An AddSoftFocusListener method may be implemented to receive notification of events that try to get the user's attention without taking the input focus. A RemoveSoftFocusListener method stops the notification. This method may use the callback object to identify this listener and therefore the object passed in should be the same as that passed to AddSoftFocusListener.","An OnSoftFocus method may be called by the accessibility system  when a soft focus event has occurred. To receive this notification, the listening application or client  calls AddSoftFocusListener. A source element, if available, can be used to get more information about the event. An example source element would be the logical root element of a balloon help window used by one of the notification applications in the system tray. The OnSoftFocus method returns: name of the event; source of the event; and the alert level indicating importance to the user.","The following chart illustrates the actions of the client  and the accessibility system  when the client  uses an AddTopLevelWindowListener API to listen to events from a specific process.",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":[{},"Accessibility system"]},{"entry":["Client","and the target UI window"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Calls","Accessibility system client starts a thread"]},{"entry":["AddTopLevelWindowListener","to watch for top-level application windows"]},{"entry":[{},"being created and destroyed."]},{"entry":[{},"New UI appears and the Accessibility"]},{"entry":[{},"system client calls the client's"]},{"entry":[{},"OnTopLevelWindowOpened method."]},{"entry":["From the","Accessibility system client communicates"]},{"entry":["OnTopLevelWindowOpened","the event Id's to the target UI window so"]},{"entry":["method calls other APIs to","it can be selective in notifying of events."]},{"entry":["register for additional events","Accessibility system client communicates"]},{"entry":["happening in the target","the event Id's and filtering information to"]},{"entry":["UI window.","the Accessibility system server so it can"]},{"entry":[{},"further filter events."]},{"entry":[{},"Target UI window uses the accessibility"]},{"entry":[{},"system server API to notify the"]},{"entry":[{},"accessibility system server side of the"]},{"entry":[{},"events of interest."]},{"entry":["Handles events in the","Accessibility system server communicates"]},{"entry":["callback objects","events back to the accessibility system"]},{"entry":[{},"client."]},{"entry":[{},"Accessibility system client calls back on"]},{"entry":[{},"the objects the client application supplied"]},{"entry":[{},"with registration."]},{"entry":["Calls RemoveListener","Accessibility system client communicates"]},{"entry":["APIs to stop receiving events","to the accessibility system server and to"]},{"entry":[{},"the target UI window the events that are"]},{"entry":[{},"no longer of interest."]},{"entry":[{},"The target app stops notifying the"]},{"entry":[{},"accessibility system server of events."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Corresponding event notification methods are used by the server  or underlying UI engine to support the accessibility system events enumerated above. The UI automation server APIs include methods that the server or underlying UI engine may call to accomplish this. For instance, there is a NotifyPropertyChanged method for the server to call to notify when a particular property changes on a logical element. It is up to the server  or underlying UI engine to generate the appropriate parameters and call these notification methods when the UI changes.","Server Methods","An AdviseEventAdded method and an AdviseEventRemoved method are called by the UI automation client to notify the server  when clients  are requesting events. This allows the server  to not propagate events to the accessibility system  when there is no one interested. Servers can use these notifications to make performance dependent on whether there are clients using the events.","Control Patterns","The accessibility model offers a unique approach to categorizing and exposing the functionality supported by a particular UI element or control. Instead of associating functionality with a specific control type, (for example, a button, an edit box, or a list box) as in the prior art, the accessibility model defines a set of common control patterns that each define one aspect of UI behavior. Because these patterns are independent of each other, they can be combined to describe the full set of functionality supported by a particular UI element.","For example, instead of describing an element in terms of its class name, such as Button, the accessibility system  describes it as supporting the invokable control pattern. A control pattern defines the structure, properties, events, and methods supported by an element. Therefore, these patterns not only allow the client to query a control's behavior, they also allow it to programmatically manipulate the control by using interfaces designed for a particular pattern. For example, a SelectionContainer pattern provides methods to query for the selected items, to select or deselect a specific item, or to determine if the control supports single or multiple selection modes.","The control patterns currently defined for the accessibility system  include: (1) Selection Container; (2) Hierarchy; (3) Invokable; (4) Simple Grid; (5) Text; (6) Value; (7) Represents Object; (8) Scrollable; (9) Sortable; (10) Drawing; and (11) Other Container.","This technique enables control developers to implement a new type of control while still having a well-defined approach for exposing its behavior to AT products and test scripts. If a new type of behavior is introduced, a new control pattern can be defined to express the required functionality.","Assistive technology products and test scripts can now be written to understand how to work with each pattern, instead of each UI control. Because there are far fewer control patterns than control classes, this techniques minimizes necessary code. This approach also encourages a more flexible architecture that can effectively interrogate and manipulate new controls (as long as they support known control patterns).","The following table provides some examples of common controls and the patterns they will support.",{"@attributes":{"id":"p-0110","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Control","Relevant Control Patterns"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Button","Invokable"]},{"entry":["Checkbox, Radiobutton","Value"]},{"entry":["Listbox","SelectionContainer, Scrollable"]},{"entry":["Combobox","SelectionContainer, Scrollable, Value"]},{"entry":["Treeview","SelectionContainer, Scrollable, Hierarchy"]},{"entry":["Listview","SelectionContainer, Scrollable, Sortable"]},{"entry":["Textbox, Edit","Value, Text, Scrollable"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"More specific interfaces will be used to expose functionality associated with common control patterns. Examples of these patterns include: (1) selection managing containers; (2) grid layout containers; (3) UI elements that contain values; (4) Icons that represent objects (files, emails, etc); and (5) UI elements that may be invoked. In general, these patterns are not tightly bound to specific controls and different controls may implement the same patterns. For example, listboxes, combo boxes, and treeviews all implement the \u2018selection managing container\u2019 pattern. Some controls may implement multiple patterns if appropriate: a selection grid would implement both the \u2018Grid layout container\u2019 pattern and the \u2018Selection managing container\u2019 pattern.","There is no single \u2018role\u2019 property as in previous applications. Instead, two separate mechanisms are used. Control patterns determine the available functionality of a control and a human-readable localizable property provides a control-type name that the user can understand, such as \u2018button\u2019, \u2018list box\u2019, etc.","Properties","The accessibility system  will feature a general GetProperty method. Properties are preferably represented by GUIDs, with utility methods used to translate to and from a non-localizable mnemonic form (useful for scripting and config files) and also to obtain localized descriptions. The two key advantages of a general GetProperty method instead of individual methods are that (a) it allows for new properties to be added over time without changing the interface, and (b) it allows for implementation techniques-such as array-driven bulk property fetching-that are not possible when using separate methods. Each property must have a clearly defined intent. Whether the property is intended for human or machine consumption, whether the property is to be localized, etc., must be clearly defined.","The present invention has been described in relation to particular embodiments, which are intended in all respects to be illustrative rather than restrictive. Alternative embodiments will become apparent to those skilled in the art to which the present invention pertains without departing from its scope.","From the foregoing, it will be seen that this invention is one well adapted to attain all the ends and objects set forth above, together with other advantages which are obvious and inherent to the system and method. It will be understood that certain features and sub-combinations are of utility and may be employed without reference to other features and sub-combinations. This is contemplated and with the scope of the claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is described in detail below with reference to the attached drawing figures, wherein:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 4(A)-4(D)"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
