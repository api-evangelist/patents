---
title: Compression for co-processing techniques on heterogeneous graphics processing units
abstract: The graphics co-processing technique includes rendering a frame of red, green, blue (RGB) data on a graphics processing unit on an unattached adapter. The frame of RGB data are converted on the graphics processing unit on the unattached adapter to luminance-color difference (YUV) data. The YUV data is copied from frame buffers of the graphics processing unit on the unattached adapter to buffers in system memory. The YUV data is copied from the buffers in the system memory to texture buffers of a graphics processing unit on a primary adapter. A frame of RGB data is recovered from the YUV data in the texture buffer of the graphics processing unit on the primary adapter. The recovered frame of RGB data may then be presented by the graphics processing unit on the primary adapter on the primary display.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08773443&OS=08773443&RS=08773443
owner: NVIDIA Corporation
number: 08773443
owner_city: Santa Clara
owner_country: US
publication_date: 20091230
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This claims the benefit of U.S. Provisional Patent Application No. 61\/243,155 filed Sep. 16, 2009 and U.S. Provisional Patent Application No. 61\/243,164 filed Sep. 17, 2009.","Conventional computing systems may include a discrete graphics processing unit (dGPU) or an integral graphics processing unit (iGPU). The discrete GPU and integral GPU are heterogeneous because of their different designs. The integrated GPU generally has relatively poor processing performance compared to the discrete GPU. However, the integrated GPU generally consumes less power compared to the discrete GPU.","The conventional operating system does not readily support co-processing using such heterogeneous GPUs. Referring to , a graphics processing technique according to the conventional art is shown. When an application  starts, it calls the user mode level runtime application programming interface (e.g., DirectX API d3d9.dll)  to determine what display adapters are available. In response, the runtime API  enumerates the adapters that are attached to the desktop (e.g., the primary display ). A display adapter , , even recognized and initialized by the operating system, will not be enumerated in the adapter list by the runtime API  if it is not attached to the desktop. The runtime API  loads the device driver interface (DDI) (e.g., user mode driver (umd.dll))  for the GPU  attached to the primary display . The runtime API  of the operating system will not load the DDI of the discrete GPU  because the discrete GPU  is not attached to the display adapter. The DDI  configures command buffers of the graphics processor  attached to the primary display . The DDI  will then call back to the runtime API  when the command buffers have been configured.","Thereafter, the application  makes graphics request to the user mode level runtime API (e.g., DirectX API d3d9.dll)  of the operating system. The runtime  sends graphics requests to the DDI  which configures command buffers. The DDI calls to the operating system kernel mode driver (e.g., DirectX driver dxgkrnl.sys) , through the runtime API , to schedule the graphics request. The operating system kernel mode driver then calls to the device specific kernel mode driver (e.g., kmd.sys)  to set the command register of the GPU  attached to the primary display  to execute the graphics requests from the command buffers. The device specific kernel mode driver  controls the GPU  (e.g., integral GPU) attached to the primary display .","Therefore, there is a need to enable co-processing on heterogeneous GPUs. For example, it may be desired to use a first GPU to perform graphics processing for a first class of applications and a second GPU for a second class of applications depending upon processing performance and power consumption parameters.","Embodiments of the present technology are directed toward graphics co-processing. The present technology may best be understood by referring to the following description and accompanying drawings that are used to illustrate embodiment of the present technology.","In one embodiment, a graphics co-processing method includes loading and initializing a device driver interface and a device specific kernel mode driver for a graphics processing unit on a primary adapter. A device driver interface and a device specific kernel mode driver for a graphics processing unit on an unattached adapter are also loaded without the device driver interface talking back to a runtime application programming interface. A frame of red, green, blue (RGB) data is rendered on the graphics processing unit on the unattached adapter. The frame of RGB data is converted to luminance-color difference (YUV) data on the graphics processing unit on the unattached adapter. The YUV data is copied from frame buffers of the graphics processing unit on the unattached adapter to buffers in system memory. The YUV data is copied from the buffers in the system memory to texture buffers of the graphics processing unit on the primary adapter. A frame of RGB data is recovered from the YUV data in the texture buffer of the graphics processing unit on the primary adapter. The recovered frame of RGB data may then be presented, by the graphics processing unit on the primary adapter, on the primary display.","In another embodiment, a graphics co-processing method includes loading a device specific kernel mode driver of a graphics processing unit tagged as a non-graphics device. A device driver interface and a device specific kernel mode driver are loaded and initialized for a graphics processing unit on a primary adapter. A device driver interface for the graphics processing unit on a non-graphics device tagged adapter is loaded and initialized without the device driver interface talking back to a runtime application programming interface. A frame of red, green, blue (RGB) data is rendered on the graphics processing unit on the non-graphics device tagged adapter. The frame of RGB data is converted to luminance-color difference (YUV) data on the graphics processing unit on the non-graphics device tagged adapter. The YUV data from frame buffers of the graphics processing unit on the non-graphics device tagged adapter is copied to buffers in system memory. The YUV data is copied from the buffers in the system memory to texture buffers of the graphics processing unit on the primary adapter. A frame of RGB data is recovered from the YUV data in the texture buffer of the graphics processing unit on the primary adapter. Thereafter, the recovered frame of RGB data may be presented, by the graphics processing unit on the primary adapter, on the primary display.","Reference will now be made in detail to the embodiments of the present technology, examples of which are illustrated in the accompanying drawings. While the present technology will be described in conjunction with these embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of the present technology, numerous specific details are set forth in order to provide a thorough understanding of the present technology. However, it is understood that the present technology may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the present technology.","Embodiments of the present technology introduce a shim layer between the runtime API (e.g., DirectX) and the device driver interface (DDI) (e.g., user mode driver (UMD)) to separate the display commands from the rendering commands, allowing retargeting of rendering commands to an adapter other than the adapter the application is displaying on. In one implementation, the shim layer allows the DDI layer to redirect a runtime (e.g., Direct3D (D3D)) default adapter creation to an off-screen graphics processing unit (GPU), such as a discrete GPU, not attached to the desktop. The shim layer effectively layers the device driver interface, and therefore does not hook a system component.","Referring to , a graphics co-processing computing platform, in accordance with one embodiment of the present technology is shown. The exemplary computing platform may include one or more central processing units (CPUs) , a plurality of graphics processing units (GPUs) , , volatile and\/or non-volatile memory (e.g., computer readable media) , , one or more chip sets , , and one or more peripheral devices , - communicatively coupled by one or more busses. The GPUs include heterogeneous designs. In one implementation, a first GPU may be an integral graphics processing unit (iGPU) and a second GPU may be a discrete graphics processing unit (dGPU). The chipset ,  acts as a simple input\/output hub for communicating data and instructions between the CPU , the GPUs , , the computing device-readable media , , and peripheral devices , -. In one implementation, the chipset includes a northbridge  and southbridge . The northbridge  provides for communication between the CPU , system memory  and the southbridge . In one implementation, the northbridge  includes an integral GPU. The southbridge  provides for input\/output functions. The peripheral devices , - may include a display device , a network adapter (e.g., Ethernet card) , CD drive, DVD drive, a keyboard, a pointing device, a speaker, a printer, and\/or the like. In one implementation, the second graphics processing unit is coupled as a discrete GPU peripheral device  by a bus such as a Peripheral Component Interconnect Express (PCIe) bus.","The computing device-readable media ,  may be characterized as primary memory and secondary memory. Generally, the secondary memory, such as a magnetic and\/or optical storage, provides for non-volatile storage of computer-readable instructions and data for use by the computing device. For instance, the disk drive  may store the operating system (OS), applications and data. The primary memory, such as the system memory  and\/or graphics memory, provides for volatile storage of computer-readable instructions and data for use by the computing device. For instance, the system memory  may temporarily store a portion of the operating system, a portion of one or more applications and associated data that are currently used by the CPU , GPU  and the like. In addition, the GPUs ,  may include integral or discrete frame buffers , .","Referring to , a graphics co-processing technique, in accordance with one embodiment of the present technology, is shown. When an application  starts, it calls the user mode level runtime application programming interface (e.g., DirectX API d3d9.dll)  to determine what display adapters are available. In addition, an application initialization routine is injected when the application starts. In one implementation, the application initialization routine is a short dynamic link library (e.g., appin.dll). The application initialization routine injected in the application includes some entry points, one of which includes a call (e.g., set_dll_searchpath( )) to change the search path for the display device driver interface. During initialization, the search path for the device driver interface (e.g., c:\\windows\\system32\\ . . . \\umd.dll) is changed to the search path of a shim layer library (e.g., c:\\ . . . \\coproc\\ . . . \\umd.dll). Therefore the runtime API  will search for the same DDI name but in a different path, which will result in the runtime API  loading the shim layer .","The shim layer library  has the same entry points as a conventional display driver interface (DDI). The runtime API  passes one or more function pointers to the shim layer  when calling into the applicable entry point (e.g., OpenAdapter( )) in the shim layer . The function pointers passed to the shim layer  are call backs into the runtime API . The shim layer  stores the function pointers. The shim layer  loads and initializes the DDI on the primary adapter . The DDI on the primary adapter  returns a data structure pointer to the shim layer  representing the attached adapter. The shim layer  also loads and initializes the device driver interface on the unattached adapter  by passing two function pointers which are call backs into local functions of the shim layer . The DDI on the unattached adapter  also returns a data structure pointer to the shim layer  representing the unattached adapter. The data structure pointers returned by the DDI on the primary adapter  and unattached adapter  are stored by the shim layer . The shim layer  returns to the runtime API  a pointer to a composite data structure that contains the two handles. Accordingly, the DDI on the unattached adapter  is able to initialize without talking back to the runtime API .","In one implementation, the shim layer  is an independent library. The independent shim layer may be utilized when the primary GPU\/display and the secondary GPU are provided by different vendors. In another implementation, the shim layer  may be integral to the display device interface on the unattached adapter. The shim layer integral to the display device driver may be utilized when the primary GPU\/display and secondary GPU are from the same vendor.","The application initialization routine (e.g., appin.dll) injected in the application also includes other entry points, one of which includes an application identifier. In one implementation, the application identifier may be the name of the application. The shim layer  application makes a call to the injected application initialization routine (e.g., appin.dll) to determine the application identifier when a graphics command is received. The application identifier is compared with the applications in a white list (e.g., a text file). The white list indicates an affinity between one or more applications and the second graphics processing unit. In one implementation, the white list includes one or more applications that would perform better if executed on the second graphics processing unit.","If the application identifier is not on the white list, the shim layer  calls the device driver interface on the primary adapter . The device driver interface on the primary adapter  sets the command buffers. The device driver interface on the primary adapter then calls, through the runtime  and a thunk layer , to the operating system kernel mode driver (e.g., DirectX driver dxgkrnl.sys) . The operating system kernel mode driver  in turn schedules the graphics command with the device specific kernel mode driver (e.g., kmd.sys)  for the GPU  attached to the primary display . The GPU  attached to the primary display  is also referred to hereinafter as the first GPU. The device specific kernel mode driver  sets command register of the GPU  to execute the graphics command on the GPU  (e.g., integral GPU) attached to the primary display .","If the application identifier is a match to one or more identifiers on the white list, the handle from the runtime API  is swapped by the shim layer  with functions local to the shim layer . For a rendering command, the local function stored in the shim layer  will call into the DDI on the unattached adapter  to set command buffer. In response, the DDI on the unattached adapter  will call local functions in the shim layer  that route the call through the thunk layer  to the operating system kernel mode driver  to schedule the rendering command. The operating system kernel mode driver  calls the device specific kernel mode driver (e.g., dkmd.sys)  for the GPU on the unattached adapter  to set the command registers. The GPU on the unattached adapter  (e.g., discrete GPU) is also referred to hereinafter as the second GPU. Alternatively, the DDI on the unattached adapter  can call local functions in the thunk layer . The thunk layer  routes the graphics request to the operating system kernel mode driver (e.g., DirectX driver dxgkrnl.sys) . The operating system kernel mode driver  schedules the graphics command with the device specific kernel mode driver (e.g., dkmd.sys)  on the unattached adapter. The device specific kernel mode driver  controls the GPU on the unattached adapter .","For a display related command (e.g., Present( )), the shim layer  splits the display related command received from the application  into a set of commands for execution by the GPU on the unattached adapter  and another set of commands for execution by the GPU on the primary adapter . In one implementation, when the shim layer  receives a present call from the runtime , the shim layer  calls to the DDI on the unattached adapter  to cause a copy the frame buffer  of the GPU on the unattached adapter  to a corresponding buffer in system memory . The shim layer  will also call the DDI on the primary adapter  to cause a copy from the corresponding buffer in system memory  to the frame buffer  of the GPU on the attached adapter  and then a present by the GPU on the attached adapter . The memory accesses between the frame buffers ,  and system memory  may be direct memory accesses (DMA). To synchronize the copy and presents on the GPUs , , a display thread is created, that is notified when the copy to system memory by the second GPU  is done. The display thread will then queue the copy from system memory  and the present call into the GPU on the attached adapter .","In another implementation, the operating system (e.g., Window7Starter) will not load a second graphics driver . Referring now to , a graphics co-processing technique, in accordance with another embodiment of the present technology, is shown. When the operation system will not load a second graphics driver, the second GPU  is tagged as a non-graphics device adapter that has its own driver . Therefore the second GPU  and its device specific kernel mode driver  are not seen by the operating system as a graphics adapter. In one implementation, the second GPU  and its driver  are tagged as a memory controller. The shim layer  loads and configures the DDI  for the first GPU  on the primary adapter and the DDI  for the second GPU  If there is a specified affinity for executing rendering commands from the application  on the second GPU , the shim layer  intercepts the rendering commands sent by the runtime API  to the DDI on the primary adapter , calls the DDI on the unattached adapter to sets the commands buffers for the second GPU , and routes them to the driver  for the second GPU . The shim layer  also intercepts the callbacks from the driver  for the second GPU  to the runtime . In another implementation, the shim layer  implements the DDI  for the second GPU . Accordingly, the shim layer  splits graphics command and redirects them to the two DDIs , .","Accordingly, the embodiments described with reference to , enables the application to run on a second GPU instead of a first GPU when the particular version of the operating system will allow the driver for the second GPU to be loaded but the runtime API will not allow a second device driver interface to be initialized. The embodiments described with reference to  enables an application to run on a second GPU, such as a discrete GPU, instead of a first GPU, such as an integrated GPU, when the particular version of the operation system (e.g., Win7Starter) will not allow the driver for the second GPU to be loaded. The DDI  for the second GPU  cannot talkback through the runtime  or the thunk layer  to a graphics adapter handled by an OS specific kernel mode driver.","Referring now to , a method of synchronizing the copy and present operations on the first and second GPUs is shown. The method is illustrated in  with reference to an exemplary set of render and display operations, in accordance with one embodiment of the present technology. At , the shim layer  receives a plurality of rendering - and display operations for execution by the GPU on the unattached adapter . At , the shim layer  splits each display operation into a set of commands including 1) a copy - from a frame buffer  of the GPU on the unattached adapter  to a corresponding buffer in system memory  having shared access with the GPU on the attached adapter , 2) a copy ,  from the buffer in shared system memory  to a frame buffer of the GPU on the primary adapter , and 3) a present ,  on the primary display  by the GPU on the primary adapter . At , the copy and present operations on the first and second GPUs ,  are synchronized.","The frame buffers ,  and shared system memory  may be double or ring buffered. In a double buffered implementation, the current rendering operations is stored in a given one of the double buffers  and the other one of the double buffers is blitted to a corresponding given one of the double buffers of the system memory. When the rendering operation is complete, the next rendering operation is stored in the other one of the double buffers and the content of the given one of the double buffers is blitted  to the corresponding other one of the double buffers of the system memory. The rendering and blitting alternate back and forth between the buffers of the frame buffer of the second GPU . The blit to system memory is executed asynchronously. In another implementation, the frame buffer of the second GPU  is double buffered and the corresponding buffer in system memory  is a three buffer ring buffer.","After the corresponding one of the double buffers of the frame buffer  in the second GPU  is blitted  to the system memory , the second GPU  generates an interrupt to the OS. In one implementation, the OS is programmed to signal an event to the shim layer  in response to the interrupt and the shim layer  is programmed to wait on the event before sending a copy command  and a present command  to the first GPU . In a thread separate from the application thread, referred to hereinafter as the display thread, the shim layer waits for receipt of the event indicating that the copy from the frame buffer to system memory is done, referred to herein after as the copy event interrupt. A separate thread is used so that the rendering commands on the first and second GPUs ,  are not stalled in the application thread while waiting for the copy event interrupt. The display thread may also have a higher priority than the application thread.","A race condition may occur where the next rendering to a given one of the double buffers for the second GPU  begins before the previous copy from the given buffer is complete. In such case, a plurality of copy event interrupts may be utilized. In one implementation, a ring buffer and four events are utilized.","Upon receipt of the copy event interrupt, the display thread queues the blit from system memory  and the present call into the first GPU . The first GPU  blits the given one of the system memory  buffers to a corresponding given one of the frame buffers of the first GPU . When the blit operation is complete, the content of the given one of the frame buffers of the first GPU  is presented on the primary display . When the next copy and present commands are received by the first GPU , the corresponding other of the system memory  buffers is blitted into the other one of the frame buffer of the first GPU  and then the content is presented on the primary display . The blit and present alternate back and forth between the double buffered frame buffer of the first GPU . The copy event interrupt is used to delay programming, thereby effectively delaying the scheduling of the copy from system memory  to the frame buffer of the first GPU  and presenting on the primary display .","In one implementation, a notification on the display side indicates that the frame has been present on the display  by the first GPU . The OS is programmed to signal an event when the command buffer causing the first GPU  to present its frame buffer on the display is done executing. The notification maintains synchronization where an application runs with vertical blank (vblank) synchronization.","Referring now to , an exemplary set of render and display operations, in accordance with another embodiment of the present technology, is shown. The rendering and copy operations executed on the second GPU  may be performed by different engines. Therefore, the rendering and copy operations may be performed substantially simultaneously in the second GPU .","Generally, the second GPU  is coupled to the system memory  by a bus having a relatively high bandwidth. However, in some systems the bus coupling the second GPU  may not provide sufficient bandwidth for blitting the frame buffer  of the second GPU  to system memory . For example, an application may be rendered at a resolution of 1280\u00d71024 pixels. Therefore, approximately 5 MB\/frame of RGB data is rendered. If the application renders at  frame\/s, than the second GPU needs approximately 500 MB\/s for blitting upstream to the system memory . However, a Peripheral Component Interconnect Express (PCIe) 1\u00d7 bus typically used to couple the second GPU  system memory  has a bandwidth of approximately 250 MB\/s in each direction. Referring now to , a method of compressing rendered data, in accordance with one embodiment of the present technology is shown. The second GPU  renders frames of RGB data, at . At , the frames of RGB data are converted using a pixel shader in the second GPU  to YUV sub-sample data. The RGB data is processed as texture data by the pixel shader in three passes to generate YUV sub-sample data. In one implementation, the U and V components are sub-sampled spatially, however, the Y is not sub-sampled. The RGB data may be converted to YUV data using the 4.2.0 color space conversion algorithm. At , the YUV sub-sample data is blitted to the corresponding buffers in the system memory with an asynchronous copy engine of the second GPU. The YUV sub-sample data is blitted from the system memory to buffers of the first GPU, at . The YUV data is blitted to corresponding texture buffers in the second GPU. The Y, U, and V sub-sample data are buffered in three corresponding buffers, and therefore the copy from frame buffer of the second GPU  to the system memory  and the copy from system memory  to the texture buffers of first GPU  are each implemented by sets of three copies. The YUV sub-sample data is converted using a pixel shader in the first GPU  to recreate the RGB frame data, at . The device driver interface on the attached adapter is programmed to render a full screened aligned quad from the corresponding texture buffers holding the YUV data. At , the recreated RGB frame data is then presented on the primary display  by the first GPU . Accordingly, the shaders are utilized to provide YUV compression and decompression.","In one implementation, each buffer of Y, U and V samples is double buffered in the frame buffer of the second GPU  and the system memory . In addition, the Y, U and V samples copied into the first GPU  are double buffered as textures. In another implementation, the Y, U and V sample buffers in the second GPU  and corresponding texture buffers in the first GPU  are each double buffered. The Y, U and V sample buffered in the system memory  may each be triple buffered.","In one implementation, the shim layer  tracks the bandwidth needed for blitting and the efficiency of transfers on the bus to enable the compression or not. In another implementation, the shim layer  enables the YUV compression or not based on the type of application. For example, the shim layer  may enable compression for game application but not for technical applications such as a Computer Aided Drawing (CAD) application.","In one embodiment the white list accessed by the shim layer  to determine if graphics requests should be executed on the first GPU  or the second GPU  is loaded and updated by the a vendor and\/or system administrator. In another embodiment, a graphical user interface can be provided to allow the user to specific the use of the second GPU (e.g., discrete GPU)  for rendering a given application. The user may right click on the icon for the given application. In response to the user selection, a graphical user interface may be generated that allows the user to specify the second GPU for use when rendering image for the given application. In one implementation, the operating system is programmed to populate the graphical interface with a choice to run the given application on the GPU on the unattached adapter. A routine (e.g., dynamic linked library) registered to handle this context menu item will scan the shortcut link to the application, gather up the options and argument, and then call an application launcher that will spawn a process to launch the application as well as setting an environment variable that will be read by the shim layer . In response, the shim layer  will run the graphics context for the given application on the second GPU . Therefore, the user can override, update, or the like, the white list loaded on the computing device.","Referring now to , an exemplary desktop  including an exemplary graphical user interface for selection of the GPU to run a given application on is shown. The desktop includes icons - for one or more applications. When the user right clicks on a given application,  a pull-down menu  is generated. The pull-down menu  is populated with an additional item of \u2018run on dGPU\u2019 or the like. The menu item for the second GPU  may provide for product branding by identifying the manufacturer and\/or model of the second GPU. If the user selects the \u2018run\u2019 item or double left clicks on the icon, the graphics requests from the given application will run on the GPU on the primary adapter (e.g., the default iGPU) . If the user selects the \u2018run on dGPU\u2019 item, the graphics requests from the given application will run on the GPU on the unattached adapter (e.g., dGPU) .","In another implementation, the second graphics processing unit may support a set of rendering application programming interfaces and the first graphics processing unit may support a limited subset of the same application programming interfaces. An application programming interface is implemented by a different runtime API  and a matching driver interface . Referring now to , a graphics co-processing technique, in accordance with another embodiment of the present technology, is shown. The runtime API  loads a shim layer  that will support all device driver interfaces. The shim layer  loads and configures the DDI  for the first GPU  using a device driver interface that this one supports on the primary adapter and the DDI  for the second GPU  of a second device driver interface that can talk with the runtime API . For example, in one implementation, the second GPU  may be a DirectX10 class device and the first GPU  may be a DirectX9 class device that does not support DirectX10. The shim layer  appears to the DDI  for the first GPU  as a first application programming class runtime API (e.g., D3D9.dll), translates command between the two device driver interface classes and may also convert between display formats.","The shim layer  includes a translation layer  that translates calls between the runtime API  device driver interface and the device driver interface class. In one implementation, the shim layer  translates display commands between the DirectX10 runtime API  and the DirectX9 DDI on the primary adapter . The shim layer, therefore, creates a Dx9 compatible context on the first GPU , which is the recipient of frames rendered by the Dx10 class second GPU . The shim layer  advantageously splits graphics commands into rendering and display commands, redirects the rendering commands to the DDI on the unattached adapter  and the display commands to the DDI on the primary adapter . The shim layer also translates between the commands for the Dx9 DDI on the primary adapter , the Dx10 DDI on the unattached adapter , the Dx10 runtime API  and Dx10 thunk layer , and provides for format conversion of necessary. The shim layer , in one implementation, intercepts commands from the Dx10 runtime  and translates these into the DX9 DDI on the primary adapter (e.g., iUMD.dll). The commands may include: CreateResource, OpenResource, DestroyResource, DxgiPresent\u2014which triggers the surface transfer mechanism that ends up with the surface displayed on the iGPU, DxgiRotateResourceIdentities, DxgiBlt\u2014present blits are translated, and DxgiSetDisplayMode.","The Dx9 DDI  for the first GPU  cannot talkback directly through the runtime  to talk to a graphics adapter handled by an OS specific kernel mode driver because the runtime  expects the call to come from a Dx10 device. The shim layer  intercepts callbacks from the Dx9 DDI and exchanges device handles, before forwarding the callback to the Dx10 runtime API , which expects the calls to come from a Dx10 device. Dx10 and Dx11 runtime APIs  use a layer for presentation called DXGI, which has its own present callback, not existing in the Dx9 callback interface. Therefore, when the display side DDI on the primary adapter calls the present callback, the shim layer translates it to a DXGI callback. For example:","PFND3DDDI_PRESENTCB->PFNDDXGIDDI_PRESENTCB","The shim layer  may also include a data structure  for converting display formats between the first graphics processing unit DDI and the second graphics processing unit DDI. For example, the shim layer  may include a lookup table to convert a 10 bit rendering format in Dx10 to an 8 bit format supported by the Dx9 class integrated GPU . The rendered frame may be copied to a staging surface, a two-dimensional (2D) engine of the discrete GPU  utilizes the lookup table to convert the rendered frame to a Dx9 format. The Dx9 format frame is then copied to the frame buffer of the integrated GPU  and then presented on the primary display . For example, the following format conversions may be performed:","DXGI_FORMAT_R16G16B16A16_FLOAT(render)->D3DDDIFMT_A8R8G8B8(display),","DXGI_FORMAT_R10G10B10A2_UNORM(render)->D3DDDIFMT_A8R8G8B8(display).","In one implementation, the copying and conversion can happen as an atomic operation.","The foregoing descriptions of specific embodiments of the present technology have been presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, and obviously many modifications and variations are possible in light of the above teaching. The embodiments were chosen and described in order to best explain the principles of the present technology and its practical application, to thereby enable others skilled in the art to best utilize the present technology and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present technology are illustrated by way of example and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9","b":"910"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
