---
title: Test script transformation architecture
abstract: A test script transformation architecture helps generate accurate test scripts for evolving applications. Applications often have complex graphical user interfaces for which the permutations and combinations of GUI elements give rise to an enormous field of potential commands and command sequences to be tested. Furthermore, these applications change over time, rendering prior test scripts unworkable. The architecture facilitates the automatic generation of new test scripts to reliably test subsequent application versions, while greatly reducing the time, cost, and resource expenditures needed to arrive at new test scripts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08365147&OS=08365147&RS=08365147
owner: Accenture Global Services Limited
number: 08365147
owner_city: Dublin
owner_country: IE
publication_date: 20080227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is related to following applications, all filed on the same day:\n\n","1. Technical Field","This disclosure relates to analysis and generation of test scripts for testing graphical user interface applications, and in particular relates to transforming a prior test script for use with a new application version.","2. Related Art","The relentless pace of advancing technology has given rise to complex computer software applications to help automate almost every aspect of day-to-day existence. Today applications exist to assist with writing novels to filing income tax returns to analyzing historical trends in baby names. One nearly ubiquitous feature of these applications is that they employ graphical user interfaces (GUIs). Another nearly ubiquitous aspect is that the GUI applications (GAPs) require thorough testing prior to release.","Nevertheless, in the past it has been easier to implement the GUI to the application than to thoroughly test the GAP. For GAPs of any significant complexity, the permutations and combinations of GUI elements gives rise to an enormous field of potential commands and command sequences that could have bugs of any severity, from insignificant to critical failure. Exacerbating the problem is that application developers are under pressure to continually add new features, update the GUI, and release new versions of applications. As a result, even if a test script for a prior version of a GAP were adequate, it is rarely the case that the original test script can adequately test the subsequent revised application.","Manually testing large-scale enterprise GAPs is tedious, error prone, and laborious. Nontrivial GAPs contain hundreds of GUI screens that in turn contain thousands of GUI objects. In order to automate testing of GAPs, test engineers write programs using scripting languages (e.g., JavaScript and VBScript), and these testing scripts drive GAPs through different states by mimicking users who interact with these GAPs by performing actions on their GUI objects. Often test scripts simulate users of GAPs, and their statements access and manipulate GUI objects of these GAPs. For example, the statement:","VbWindow(\u201cLogin\u201d).VbEdit(\u201ctxtAgentsName\u201d).Set \u201cShawn\u201d","locates a window whose caption is Login and that is created by a Visual Basic-based control, then it locates a text box whose name is txtAgentsName that is a GUI object whose parent is the login window. By calling the method Set with the parameter \u201cShawn\u201d, the value of the text box is set to \u201cShawn\u201d.","Commercial tools such as QTP and Rational Robot help generate test scripts by tracking pointing of a cursor at GUI objects and performing desired actions. These tools generate scripting code that can replay captured user actions. The generated code serves as a skeleton for creating scripts to automate script testing. Test engineers add code to the generated scripts so that these scripts can replay using different input values thereby exercising the functionality of the GAP.","Expanding test scripts with manually written code to automate tests makes the test script more complex, difficult to understand, maintain, and evolve. Although it is known in advance that the test scripts access and manipulate GUI elements, it is not clear how to detect operations at compile time that lead to runtime errors. Using API calls exported by testing platforms remains a primary mode of accessing and manipulating GUI objects of GAPs, and these API calls lead to various run-time errors in the test scripts. For example, test personnel may use platform API calls incorrectly in the test script source code thereby accessing GUI elements that they did not intend to access.","It is a difficult technical challenge to check test scripts for potential flaws caused by third party API calls that lead to incorrect tests and runtime errors in the test scripts. Furthermore, there are fundamental problems with using API calls to access and manipulate GUI objects. First, the API calls take names and property values of GUI objects as string input parameter variables. The values of these input parameters are often known only at runtime, making it impossible to apply sound checking algorithms. Second, testing platforms export dozens of different API calls, and high complexity of these API calls makes it difficult for programmers to understand which API calls to use and how to combine them to access and manipulate GUI objects. These problems lead to a wide range of bugs in the test scripts, many of which are difficult to detect during the inspection of the test script source code.","A further problem arises because application requirement specifications include high-level concepts that describe GAPs, specifically its GUI objects. Unfortunately, tracing GUI objects of GAPs to these high-level concepts is a difficult problem because programmers do not document these traces. Accordingly, when test personnel create GAPs, they spend considerable time to understand how to use these GAPs by reading documentation and talking to subject matter experts. This crucial knowledge is often lost after test personnel are reassigned to other tasks or quit the company.","One of the perceived benefits of existing approaches to creating test scripts is that type checking is not required since the script code is generated directly from GUIs. For example, given certain GUI objects in a GAP, a testing tool can produce corresponding statements that navigate to these objects using API calls with string parameters describing their properties. However, this perceived benefit in fact gives rise to difficult technical challenges due to semantic inconsistencies between the test script and the GAP. Suppose, for example, that during the maintenance phase the GUI of the GAP changed. The scripting interpreter is not aware of the change and it would run the generated script without producing any compile-time warnings. However, the resulting script either fails at run time or produces incorrect test results because its code attempts to access GUI objects that are either changed or do not exist anymore.","Therefore, a need exists for a test script generation architecture with supporting analysis and evaluation logic that addresses the problems noted above and other previously encountered.","A test script transformation architecture generates accurate test scripts for applications with graphical user interfaces that change over time. As the applications change, prior test scripts are rendered unworkable. The architecture facilitates the automatic generation of new test scripts to reliably test subsequent application versions and may greatly reduce the time, cost, and resource expenditures needed to arrive at the new test scripts.","The test script transformation architecture (\u201carchitecture\u201d) may include a graphical user interface (GUI) type model and GUI model builder logic. The GUI model builder logic accepts as input the GUI type model, a current GAP version, and a subsequent GAP version. The GUI model builder logic generates as output a current GAP GUI model, and a subsequent GAP GUI model.","In addition, the architecture includes GUI comparator logic. The GUI comparator logic accepts as input the current GAP GUI model, the subsequent GAP GUI model, and generates as output a GUI difference model. The GUI difference model includes GUI element difference entries that identify a specific GUI element that matches between the current GAP version and the subsequent GAP version, but that differs in character between the current GAP version and the subsequent GAP version. The architecture further includes a script analyzer. Based on an abstract syntax tree representation of a current test script, the script analyzer generates a change guide, a transformed test script, or both. The change guide may include, for example, script transformation information for transforming the current test script for use against the subsequent GAP version. The transformed test script (for use against the subsequent GAP version) may include, for example, modified script entries generated from current test script entries in the current test script.","Other systems, methods, features and advantages will be, or will become, apparent to one with skill in the art upon examination of the following figures and detailed description. All such additional systems, methods, features and advantages are included within this description, are within the scope of the claimed subject matter, and are protected by the following claims.",{"@attributes":{"id":"p-0078","num":"0082"},"figref":"FIG. 1","b":["100","100","100","102","104","106","100","108","110"]},"The GUI element typing and mapping system  (\u201csystem \u201d). The system  facilitates application of a formal type model to GUI elements in GAPs, as well as establishing relations between GUI elements from one version of a GAP to another. The system  includes a processor , a memory , and a GUI element data repository (\u201crepository\u201d) . The system  exchanges information with the other systems , , , and  in the architecture  through the communication logic .","The memory  holds GUI typing and mapping logic  and a reference GUI type model . The repository  stores graphical user interface application (GAP) GUI element mappings (\u201cmappings\u201d) . The repository  also stores a current GAP version GUI type model  and a subsequent GAP version GUI type model . The system  communicates GUI element type specification messages and GUI element mapping specification messages to the metadata migration and repository system  (\u201csystem \u201d).","The system  facilitates the perpetuation of useful metadata for GAPs, particularly as GAPs evolve between versions. The system  includes a processor , a memory  that holds metadata processing logic  and a database management system , and communication logic . The system  also includes a metadata repository . The metadata repository  maintains GUI element metadata , such as GUI element identifiers , GUI element notations , GUI element types , and GUI element mappings . The system  may communicate the GUI element metadata  to the other systems , , , and  to assist the other systems , , , and  in the execution of their logic.","The GAP comparator system  (\u201csystem \u201d) analyzes a current GAP version  and a subsequent GAP version  to determine GUI element differences between the versions  and . To that end, the system  may include GUI model builder logic  that accepts as input the current GAP version  and the subsequent GAP version . The GUI model builder logic  generates a GUI element model  of the current GAP version  and a GUI element model  of the subsequent GAP version . The models  and  may be tree models or other types of representations.","A GUI comparator  processes the representations  and . A GUI difference model  results. The GUI difference model  includes GUI element difference entries that identify a specific GUI element that matches between the current GAP version and the subsequent GAP version, but that differs in character between the current GAP version and the subsequent GAP version. For example, a difference entry may identify that a textbox in the current GAP version matches a drop down list in the subsequent GAP version, and may note the different GUI element characteristics between the two versions.","The test script analysis system  (\u201csystem \u201d) provides a test script transformation analyzer with a change guide engine. In particular, the system  starts with a current test script  and initiates execution of a script parser  to obtain an abstract syntax tree representation  (\u201cAST \u201d) of the current test script . The current test script  may be suitable for testing any amount of functionality in the current GAP version . The system  helps transform the current test script  into a transformed test script suitable for testing any amount of functionality in the subsequent GAP version .","The script analyzer  accepts the AST , the GUI difference model , and GUI element metadata  through the communication logic . Object repository lookup logic  retrieves object data from the object repository  as an aid in analyzing the GUI difference model . As a result of its analysis, the script analyzer  generates a transformed test script , a change guide , or both. The analysis may take into consideration a change guide message repository  and GUI element script change rules . A further aspect of the system  is the constraint satisfaction engine . In conjunction with GUI element type information obtained from the systems  and , the constraint satisfaction engine determines whether script statements are compatible with the GUI element type assigned to any given GUI element.","The test script economic analysis system  (\u201csystem \u201d) provides a test script transformation analyzer with an economic cost engine. The system  includes an economic engine  that consults economic models  to generate cost reports . The economic models  may be pre-defined economic models of test script transformation cost relationships. The cost reports  may include test script transformation cost information, e.g., the estimated cost for transforming the current test script  into the transformed test script . The cost reports  may be based on an analysis of the change guide , specifically input GAP change specifiers , or other information.",{"@attributes":{"id":"p-0087","num":"0091"},"figref":"FIG. 2","b":["200","100","102","202","102","104","204","104","138","206"]},"The system  initiates execution of GUI comparator logic (). The GUI comparator logic  accepts as input a current GAP GUI model  for the current GAP version  and a subsequent GAP GUI model  for the subsequent GAP version  (). The GUI comparator logic  may further accept as input GUI element mappings from the systems  or . The GUI comparator logic  produces as output a GUI difference model  that includes a GUI element difference entries that identify specific GUI elements that match between the current GAP version  and the subsequent GAP version , but that differ in character between the current GAP version  and the subsequent GAP version  ().","The test script analysis system  initiates execution of a script analyzer  (). The script analyzer  accepts as input the GUI difference model  and the AST  of the current test script . The script analyzer  may generate a change guide  that includes script transformation information for transforming the current test script  for use against the subsequent GAP version  (). Additionally or alternatively, the script analyzer  may generate a transformed test script  for use against the subsequent GAP version  (). The transformed test script  includes transformed script entries generated from current test script entries in the current test script","Furthermore, the economic analysis system  may initiate execution of an economic engine  operable to analyze the change guide  (). The system  takes into consideration test script transformation cost relationships defined in the economic models . The result is a cost report  comprising test script transformation cost information ().",{"@attributes":{"id":"p-0091","num":"0095"},"figref":"FIG. 1","b":["102","102","112","114","116","102","118","118"]},"The memory  holds GUI typing and mapping logic  and a reference GUI type model . As will be explained in more detail below, the GUI typing and mapping logic  assists the GAP designer to specify GUI element types for individual GUI elements of a GAP. The GUI typing and mapping logic  also assists the GAP designer to define links from GUI elements in a current GAP version to GUI elements in a subsequent GAP version. The types and mapping information may be provided to other GAP analysis systems, such as test script analysis systems and metadata repositories, through the communication logic .","The system  may operate on any particular GUI element. Examples of GUI elements include text boxes, menus, menu items, radio buttons, check boxes, and command buttons. Other examples include list boxes, combo boxes, toggle buttons, spin buttons, scroll bars, labels, tool bars, widgets, images, windows, calendar and tab strips. The reference GUI type model  may establish a formalized set of type names (e.g., identifiers) and qualities common to individual GUI elements that distinguish the GUI elements of the same type as members of an identifiable class. The GUI type model , in conjunction with specifying types for individual GUI elements, helps to provide a tractable syntactic technique for establishing that the GUI does not exhibit certain behaviors (e.g., storing an alphabetic character in a text box meant to hold a social security number), as opposed to free form adhoc annotation of GUI elements.","The repository  stores graphical user interface application (GAP) GUI element mappings (\u201cmappings\u201d) . The repository  also stores a current GAP version GUI type model  and a subsequent GAP version GUI type model . The system  may prepare the mappings  in response to operator input that links GUI elements from any current GAP version to any subsequent GAP version. Thus, for example, if a textbox changes to a drop down list, the operator may document the change by explicitly linking the two GUI elements together. The system  responsively prepares an element version mapping and stores the element version mapping in the repository .","Similarly, the system  may build the type models  and  from operator specified assignments of GUI element types to specific GUI elements in the current GAP version and the subsequent GAP version. To that end, the system  may prompt the operator for a selection from a GUI element type list established by the reference GUI type model . Each type model  and  may include GUI element type specifiers for one or more elements in the current GAP and subsequent GAP. The system  may interact with the operator using the display , and may also accept command line, script, batch file, and other types of input.",{"@attributes":{"id":"p-0096","num":"0100"},"figref":["FIG. 3","FIG. 3"],"b":["102","118","202","304","102","202"]},"Additional detail of the reference GUI type model  is shown in . The reference GUI type model  includes GUI type model entries (e.g., the GUI type model entries  and ). The GUI type model entries formally define a type system for a GUI, and may provide a finite set of pre-established identifiers for tagging to GUI elements. Each GUI type model entry may specify a GUI element type specifier , GUI element modification constraints , and GUI element content constraints . In other implementations, the reference GUI type model  may include additional, different, or less information. The GUI element type specifier establishes an identifier (e.g., a unique string or number) that may be assigned to a GUI element to specify a GUI element type for the GUI element. The GUI element modification constraints  specify how, and if, a GUI element of the type specified may be modified. Similarly, the GUI element content and formatting constraints  specify what content a GUI element of the type specified may hold, and how the content, or the GUI element itself may be formatted. The constraints  and  may be expressed in many ways, such as by rules that dictate desired behavior or constraints on a GUI element of a given type.","Examples of GUI element types are given below in Table 1.",{"@attributes":{"id":"p-0099","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["GUI Element Type","GUI Element Modification","GUI Element Content and"]},{"entry":["Specifier","Constraints","Formatting Constraints"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SSNEntryBox","none","Nine digits,"]},{"entry":[{},{},"or 11 characters of the"]},{"entry":[{},{},"form:"]},{"entry":[{},{},"###-##-####"]},{"entry":[{},{},"where # is a digit and \u2018-\u2019 is"]},{"entry":[{},{},"the dash symbol."]},{"entry":["SSNDisplayBox","ReadOnly","Nine digits,"]},{"entry":[{},{},"or 11 characters of the"]},{"entry":[{},{},"form:"]},{"entry":[{},{},"###-##-####"]},{"entry":[{},{},"where # is a digit and \u2018-\u2019 is"]},{"entry":[{},{},"the dash symbol."]},{"entry":["StaticWindowLabel","Read Only","0-50 Alphanumeric"]},{"entry":[{},{},"characters"]},{"entry":["3DButton","none","Foreground Color Range:"]},{"entry":[{},{},"FStart-FEnd"]},{"entry":[{},{},"Background Color Range:"]},{"entry":[{},{},"BStart-BEnd"]},{"entry":["HelpTextEntryBox","none","X position range:"]},{"entry":[{},{},"XMin:XMax"]},{"entry":[{},{},"Y position range:"]},{"entry":[{},{},"YMin:YMax"]},{"entry":[{},{},"FontSize:"]},{"entry":[{},{},"10 point minimum"]},{"entry":[{},{},"16 point maximum"]},{"entry":["MenuWidget","X, Y location fixed","Minimum Size = SMin"]},{"entry":[{},{},"Maximum Size = SMax"]},{"entry":["US-StateTextBox","none","Only the names of the"]},{"entry":[{},{},"States of the United States are permitted."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In Table 1, the SSNEntryBox specifier may be attached, for example, to a GUI element (e.g., a textbox) in a GAP that is intended for entry of social security numbers. The SSNEntryBox type places no constraints on the modifications that may be performed on the textbox. However, the SSNEntryBox type constrains the content of the textbox to nine digits, or to 3 digits followed by a dash, followed by 2 digits, followed by a dash, followed by 4 digits. The SSNDisplayBox type specifies similar constraints, but also makes the GUI element read only.","The StaticWindowLabel type provides a read only label for its attached GUI element. The label may be between 0 and 50 alphanumeric characters. Because StaticWindowLabel is read only type of GUI element, the label may not be changed.","The 3DButton type limits the foreground colors that may be set for the GUI element to between FStart and FEnd. Similarly, the 3DButton type limits the background colors that may be set for the GUI element to between BStart and BEnd. The HelpTextEntryBox constrains the X and Y position of the attached GUI element, and further constrains the font sized used for the text in the GUI element to between 10 and 16 points. The MenuWidget type may be applied to a graphical button element, for example, to establish the element as a widget for a menu bar. The MenuWidget type fixes the X and Y location of the GUI element, and further establishes a minimum size of SMin and a maximum size of SMax. The US-StateTextBox limits the contents of a GUI element to only the names of the States of the United States (e.g., \u201cAlaska, Maine, Nevada, . . . \u201d).","The system  may implement any formal GUI type model  useful for assisting a designer to create a GAP. The GUI type model may vary depending on the type of GAP being designed, and the system may choose from multiple GUI type models  for the GAP under analysis, or may accept operator input to select which GUI type model is applicable. For example, the operator may specify a healthcare GUI type model when building a pharmacy GAP, and specify a video game GUI type model when building a user interface for an online role playing game. The healthcare GUI type model may include element types useful for building a healthcare related GAP, such as the SSNEntryBox type, while the video game GUI type model may include element types useful for building the user interface, such as 3DButton.",{"@attributes":{"id":"p-0104","num":"0108"},"figref":"FIG. 3","b":["102","316","114","316","120","316","318","320","322","316","324","326","316","328"]},"Turning briefly to , an example of a GUI element type mapping  is shown. The type mapping  includes a GAP alias , a GUI element identifier , and a GUI type identifier . Additional, fewer, or different fields may be included in the type mapping .","The GAP alias  specifies an identifier for the GAP which includes the GUI element to which a type is being applied. The GAP alias  may be a unique identifier that distinguishes between GAPs, including a current GAP version and a subsequent version of the same GAP. The GUI element identifier  provides a unique identifier for the GUI element which is being typed. The GUI type identifier  specifies the GUI element type being assigned to the GUI element (e.g., SSNEntryBox).",{"@attributes":{"id":"p-0107","num":"0111"},"figref":"FIG. 4","b":["408","410","408","412","0","414"]},"The GUI type identifier  for the Window GUI element is \u201cUS-StateTextBox\u201dThe type mapping  is a mapping for a Menu Item GUI element. The GAP alias  is \u201cUniversity Directory\u201d, signifying the subsequent version of the university directory GAP. The GUI element being typed has the unique element identifier  \u201cOpenFile\u201d as specified by the Name field. The GUI type identifier  for the Window GUI element is \u201cFileOpen\u201d.",{"@attributes":{"id":"p-0109","num":"0113"},"figref":"FIG. 4","b":["424","424","426","428","426","428","424","430","432","434"]},{"@attributes":{"id":"p-0110","num":"0114"},"figref":["FIG. 5","FIG. 4"],"b":["500","502","316","316","504"]},"In response to selecting a GUI element, the typing logic  displays a type requestor . The type requestor  provides a drop down list  which lists the available GUI element types defined in the reference GUI type model . The operator selects an element type to assign to the selected GUI element , in this case \u201cUS-StateTextBox\u201d. Clicking the \u2018OK\u2019 button directs the typing logic  to create the mapping of the US-StateTextBox type to the textbox . Clicking \u2018Cancel\u2019 directs the typing logic  to take no action.",{"@attributes":{"id":"p-0112","num":"0116"},"figref":"FIG. 6","b":["600","316","316","602","316","604"]},"The type retrieval logic  retrieves a GUI element type selection list () from the selected reference GUI type model. Continuing the example given above in Table 1, the type retrieval logic  retrieves the list {SSNEntryBox, SSNDisplayBox, StaticWindowLabel, 3DButton, HelpTextEntryBox, MenuWidget, and US-StateTextBox} from the reference GUI type model. The list contains the permissible GUI element types that the operator may assign to any given GUI element.","The typing logic  may also display the selected GAP (). In one implementation, the typing logic  initiates execution of the GAP. The element selection logic  then monitors for operator input (). In particular, the element selection logic  monitors for mouse clicks, keyboard input, or other input to determine a selected GUI element (). The element selection logic  highlights the selected GUI element (). As examples, the element selection logic  may draw a border around the element, change the element color, flash the element, or otherwise highlight the selected GUI element.","The type selection logic  displays the GUI element type selection list (). For example, the type selection logic  may display the type requestor . The type selection logic  monitors for operator input (), such as a drop down list selection of an element type from the GUI element type selection list. In particular, the type selection logic  obtains a GUI element type selection that specifies a selected GUI element type from the displayed GUI element type selection list ().","If the operator accepts the selection, the type association logic  creates a GUI element type mapping (). Specifically, the type association logic  creates a mapping that links the selected GUI element type to the selected GUI element. To that end, the type association logic  may create a type mapping entry in the GUI type model corresponding to the selected GAP in the repository  that specifies a GAP alias field, a GUI element identifier  for the selected GUI element, and a GUI type identifier  according to the operator selected element type.  gives examples of GUI element type mappings.","In addition, the typing logic  may communicate the GUI element type mapping to external systems. To that end, the message creation logic  may build a GUI element type specification message (). The type specification message may include the mapping, a type specification message header, and a type specification message terminator. The message creation logic  may also communicate the GUI element type specification message to the metadata repository  ().",{"@attributes":{"id":"p-0118","num":"0122"},"figref":"FIG. 7","b":["102","702","114","702","120","702","704","706","708","702","710"]},{"@attributes":{"id":"p-0119","num":"0123"},"figref":"FIG. 8","b":["802","802","804","806","808","810","802"]},"The source GAP alias  specifies an identifier for a GAP (the \u201csource GAP\u201d) that includes a first selected GUI element, while the destination GAP alias  specifies an identifier for a GAP (the \u201cdestination GAP\u201d) that includes a second selected GUI element that should be linked to the first selected GUI element. The GAP aliases  and  may be unique identifiers that distinguish between GAPs, such as identifiers that differentiate the current GAP version and the subsequent GAP version. The source GUI element identifier  provides a unique identifier for the selected GUI element in the source GAP, while the destination GUI element identifier  provides a unique identifier for the selected GUI element in the destination GAP.",{"@attributes":{"id":"p-0121","num":"0125"},"figref":"FIG. 8","b":["812","812","814","1","816","812","818","0","820","812"]},{"@attributes":{"id":"p-0122","num":"0126"},"figref":"FIG. 8","b":["822","822","824","826","824","826","822","828","830","832","834"]},"An optional extension to the GUI element version mapping  is the confidence level field . The confidence level field  may specify a degree of reliability for the GUI element version mapping. When the version mapping arises from the efforts of a human operator, for example, the mapping logic  may set the confidence level relatively high (e.g., 90-100%). When the version mapping arises from an automated analysis, the version mapping logic  may set the confidence level at a specified level (e.g., a predefined level for automated matching), or may set a threshold that depends on the strength of the automated analysis.","For example, the automated analysis may determine a normalized score for any given attempt to match one GUI element to another GUI element. The confidence level field  may then specify the normalized score. The confidence level field  may further specify why the confidence level is set to any particular value. Furthermore, an explanation field (e.g., a character such as \u201cM\u201d or \u201cA\u201d) may be included in the confidence level field  to denote that the confidence level arises from Manual or Automated analysis. An example is the confidence level , set to \u201c88A\u201d to denote an automated analysis and a normalized score of 88, while the confidence level  shows a confidence value of 100 without specifying an explanation.",{"@attributes":{"id":"p-0125","num":"0129"},"figref":"FIG. 9","b":["902","904","906","702","902","904","121"]},"Upon selection, the mapping logic  highlights the selected GUI elements. In the example shown in , the selected GUI element in the current GAP version  is the list box . The selected GUI element in the subsequent GAP version  is the drop down list . Upon selection of an element in each GAP, the mapping logic  displays the mapping user interface . Clicking the \u2018OK\u2019 button directs the mapping logic  to create the element mapping between the list box  and the drop down list . Clicking \u2018Cancel\u2019 directs the mapping logic  to take no action.",{"@attributes":{"id":"p-0127","num":"0131"},"figref":"FIG. 10","b":["1000","702","702","1002","1004","1006","702","1008"]},"The element selection logic  then monitors for operator input (). In particular, the element selection logic  detects mouse, keyboard, and other types of input to determine when an operator has selected GUI elements in the GAPs (). The element selection logic  highlights each selected GUI element (). When a GUI element from each GAP has been selected, the element selection logic  displays a GUI element mapping user interface (). If the operator clicks \u2018Cancel\u2019, the mapping logic  need not take any action, but may continue to watch for additional GUI element selections.","If the operator clicks \u2018OK\u2019, the mapping creation logic  creates a GUI element version mapping that specifies that a relation exists between the selected GUI elements (). To that end, the mapping creation logic  may store a source GAP alias, a source GUI element identifier corresponding to the selected GUI element in the source GAP, a destination GAP alias, and a destination GUI element identifier corresponding to the selected GUI element in the destination GAP.","Additionally, the message creation logic  may build a GUI element mapping specification message (). To that end, the message creation logic  may store a GUI element mapping specification message header and a GUI element mapping specification message terminator. The header and terminator signify that the data within the message specifies a GUI element mapping between GUI elements in different GAPs. The GUI element type specification message may further include a source GAP alias, a source GUI element identifier, a destination GAP alias, and a destination GUI element identifier. The message creation logic  may then communication the GUI element mapping specification message to other systems, such as a metadata repository ().",{"@attributes":{"id":"p-0131","num":"0135"},"figref":["FIG. 11","FIG. 11"],"b":["1100","1100","1102","114","1104","1106","1108","1110","1112","1114"]},"The proxy  includes logic that inserts the hooks  and  into the process space of the GAPs  and . The proxy  communicates with the hooks  and . In particular, the proxy  may exchange messages with the hooks  and  to obtain the state of any or all of the GUI elements in the GAPs  and . The hooks  and  are programs that respond to messages from the proxy , and that may interact through an accessibility layer to discover and report information about the GUI elements in the GAPs  and  to the proxy. The operating system generally provides the accessibility layer. The accessibility layer exposes an accessibility interface through which the proxy  and hooks  and  may invoke methods and set and retrieve GUI element values and characteristics, and thereby select, highlight, control, modify, assign identifiers for, or otherwise interact with the GUI elements in the GAPs.","The Microsoft\u2122 Active Accessibility (MSAA) layer is one example of a suitable accessibility layer. In this regard, the GAPs  and  expose the accessibility interfaces that export methods for accessing and manipulating the properties and behavior of GUI elements. For example, the GAPs  and  may employ the IAccessible interface to allow access and control over the GUI element using MSAA API calls. The IAccessible interface further facilitates applications to expose a tree of data nodes that make up each window in the user interface currently being interacted with. The driver logic  and proxy  may then include program statements to access and control the GUI element as if the GUI element was a conventional programming object. Accessibility API calls may include: perform action on object, get value from object, set value on object, navigate to object, and set property on object, and other calls.","The proxy  may be a daemon program and may start prior to the driver logic . The proxy  may be aware of one or more GAPs. When the proxy  starts, it loads the GAP table , which may include a predefined set of GAP entries for which the proxy  is aware. A GAP entry may take the form:",{"@attributes":{"id":"p-0135","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003<Alias, <File0, Path0, Dir0, CommnadLine0>, <File1, Path1, Dir1,"]},{"entry":[{},"CommandLine1>>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"where Alias is a unique pre-defined name for the GAP (e.g., a name generic to both the current GAP version  and the subsequent GAP version ), File is the name of the executable program for the current GAP version , Path is the absolute path to File, Dir is the absolute path to the directory from which File should execute, and CommandLine specifies command line arguments for File. File, Path, Dir, and CommandLine provide similar parameters for the subsequent GAP version .","When the driver logic  starts, it connects to the Proxy locally or remotely (e.g., through a Transmission Control Protocol (TCP) port). Once connected, the driver logic  requests the GAP table  by sending a GAP table request message to the proxy . The proxy  responds by sending a GAP table response message including the GAP table  to the driver logic . An example message exchange is shown in Table 2:",{"@attributes":{"id":"p-0138","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"GAP table request message"},{"entry":"<GetGapTable\/>"},{"entry":"GAP table response message"},{"entry":"<GapTable>"},{"entry":"\u2003<GAP Alias = \u201cname\u201d"},{"entry":"\u2003\u2003<V_N File=\u201cgap.exe\u201d Path=\u201cc:\\path\\N\u201d CommandLine=\u201c-c1\u201d\/>"},{"entry":"\u2003\u2003<V_N1 File=\u201cgap.exe\u201d Path=\u201cc:\\path\\N1\u201d CommandLine=\u201c-c1\u201d\/>"},{"entry":"\u2003\u2002<\/GAP>"},{"entry":"\u2003<\/GapTable>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The driver logic  may then provide a list of GAPs to choose from to the operator either for typing the GAP (, (), ()) or performing GUI element mapping (, (), (), ()). The driver logic  may then create a GAP load message, e.g., <LoadGap Alias=\u201cname\u201d\/> and send the GAP load message to the proxy  to start any selected GAP (which will then display its user interface) (, (), ()). When the operator is performing element mapping, one GAP load message may cause the proxy  to start multiple versions of a GAP identified together in the GAP table  in the <GAP> section.","After starting the GAPs, the proxy  injects hooks into the GAPs' process space. The hook connects to the proxy  and sends a confirmation message (e.g., <GAP File=\u201cgap.exe\u201d Instance=\u201c192\u201d\/>). The proxy  sends a success message (e.g., <Loaded Alias=\u201cname\u201d VN=\u201c192\u201d VN1=\u201c193\u201d\/>) to the driver logic , thereby acknowledging that the GAPs are started successfully.","The operator may request the current state of each started GAP from the driver logic . In response, the driver logic  sends a state request message (e.g., <GetState Alias=\u201cname\u201d\/>) to the proxy . In turn, the proxy  locates the connection to the corresponding hooks of the GAPs and sends a state request message (e.g., <GetState\/>) to the hooks. The hooks create a GAP state (including unique identifiers for GUI elements), such as a state tree, encode it (e.g., in XML format), and send it to the proxy . The proxy  forwards the GAP state to the driver logic . An example GAP state message sent by the proxy  is shown in Table 3.",{"@attributes":{"id":"p-0142","num":"0146"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GAP state message"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<State SeqNumber=\u201d1\u201d Name=\u201dname\u201d Alias=\u201dname\u201d ProcessID=\u201d972\u201d>"},{"entry":"\u2003\u2003<GUIElement Alias=\u201dname\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<Location x=\u201d15\u201d y=\u201d200\u201d width=\u201d23\u201d height=\u201d98\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<Description>Action<\/ Description>"},{"entry":"\u2003\u2003\u2003\u2003<DefAction>Action<\/DefAction>"},{"entry":"\u2003\u2003\u2003\u2003<UniqueID>0xcafebabe<\/UniqueID>"},{"entry":"\u2003\u2003\u2003\u2003<Class>LISTBOX<\/Class>"},{"entry":"\u2003\u2003\u2003\u2003<Values>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<Value SeqNumber=\u201d1\u201d>someval<\/Value>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003..........................."},{"entry":"\u2003\u2003\u2003\u2003<\/Values>"},{"entry":"\u2003\u2003<\/GUIElement>"},{"entry":"\u2003\u2003..............."},{"entry":"<\/State>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The GAP state contains information about the GUI elements composing a given screen, as well as the values of these elements and their assigned identifiers. The GAP state specifies the GAP GUI elements and the values of the GUI elements. In one implementation the GAP state is reflected in an eXtensible Markup Language (XML) structure where the element \u2018State\u2019 has one or more children elements \u2018GAP\u2019 whose children elements are in turn \u2018GUIElement\u2019s. For example, GUI elements may be either containers or basic. Container GUI elements contain other elements, while basic elements do not contain other elements. The XML structure reflects the containment hierarchy by allowing GUIElements to contain other GUIElements.","In the XML structure, the attribute SeqNumber may designate a unique sequence number of the state within the GAP. Since states are mapped to GUI screens, each state may be given a name which is specified by the optional attribute \u2018Name\u2019. The attributes Alias and ProcessID may denote the alias of the GAP and its instance process identifier respectively. The instance process identifier may differentiate between the current GAP version and the subsequent GAP version.","The typing and mapping logic  may accept operator input (e.g., mouse input) through which the operator identifies a GUI object by pointing the cursor to it (, () and ()). The typing and mapping logic  may then draw a frame around the element ( () and ()). The typing and mapping logic  may then display a GUI element type selection list (, ()) or a GUI element mapping user interface (, ()). The operator selects the appropriate type for the object (, ()) or verifies whether a mapping should be created between two selected objects. In either case, the proxy  sends a GUI element type mapping or a GUI element version mapping to the driver logic . In turn, the driver logic  may store the mappings in the repository , and may create and communicate a GUI element mapping specification message or a GUI element type specification message to the metadata repository  (, () and , ()).",{"@attributes":{"id":"p-0146","num":"0150"},"figref":["FIG. 11","FIG. 11"],"b":["1116","1100","122","1116","1118","1120","1122","1124"]},{"@attributes":{"id":"p-0147","num":"0151"},"figref":"FIG. 12","b":["1200","1200","136","129","130","138","1200","136","1200","136","1200","136","136","129","1236","129","130","138","129"]},"The memory  may include metadata processing logic , database and file management logic , and messages . The metadata processing logic  may instruct the processor  to perform process flows for maintaining and migrating metadata. The database and file management logic  may instruct the processor  to perform processes relevant to data storage, retrieval, and manipulation to and from the metadata repository . The messages  may be stored in the memory when received from the interface  and manipulated by the processor  according to instructions from the metadata processing logic .","The metadata processing logic  includes metadata message handling logic , type processing logic , mapping processing logic , notation processing logic , and metadata migration logic . The metadata message handling logic  may instruct the processor  to store messages  received from the interface  in the memory  and process the messages  as described below. The metadata message handling logic  may include communication logic  and parsing logic . The communication logic  may instruct the processor  to send and receive messages  through the interface . The communication logic  may also instruct the processor  to store the messages  in the memory . Alternatively or additionally, the communication logic  may send instructions to the interface  to display a prompt to a non-local terminal and may instruct the processor  to process instructions received by the interface  in response to the prompt. Alternatively or additionally, the communication logic  may instruct the processor  to send instructions to the display  to display a prompt, and the processor  may process instructions received in response to the prompt. The parsing logic  may instruct the processor  to parse the messages . For example, the parsing logic  may instruct the processor  to extract metadata identification information from the messages.","The type processing logic , mapping processing logic , and notation processing logic  may instruct the processor  to process metadata messages, such as type specification message , mapping specification message , and notation message . For example, the type processing logic , mapping processing logic , or notation processing logic  may instruct the processor  to maintain a metadata record stored in the metadata repository . In that regard, the processor  may direct reading, writing, storing, copying, updating, moving, deleting, overwriting, appending, or otherwise manipulating data stored within a metadata record in the metadata repository . The type processing logic , mapping processing logic , or notation processing logic  may be performed in conjunction with processes from the database and file management logic . The messages  include as examples type specification messages , mapping specification messages , and notation messages , but may include other messages related to metadata. The type specification messages , the mapping specification messages , and the notation messages  are discussed in more detail with regard to , , and , respectively.",{"@attributes":{"id":"p-0151","num":"0155"},"figref":"FIG. 13","b":["138","138","138","0","1302","1","1304","1306","1308","1302","1304","1306","1308"]},"Each GAP metadata record may include a GAP identifier. The GAP identifiers , , and  may serve to identify either a GAP, a version of a GAP, or both. For example, GAP  metadata record  contains a GAP  identifier  of \u201cUniversity Directory\u201d and GAP  metadata record  contains a GAP  identifier  of \u201cUniversity Directory.\u201d In this case, \u201cUniversity Directory\u201d may serve to identify the whole GAP as \u201cUniversity Directory.\u201d Alternatively or additionally, \u201cUniversity Directory\u201d may serve to identify the version of the GAP as version  (e.g., the current version) of the GAP \u201cUniversity Directory.\u201d The metadata repository  may store metadata records for multiple GAPs, as well as multiple metadata records for each of the multiple versions of each GAP.","The GAP  metadata record  additionally may include GUI element  metadata record  through GUI element \u2018n\u2019 metadata record . The total number \u2018n\u2019 of GUI element metadata records stored within each GAP metadata record may vary depending on the complexity of the GAP. Each GUI element metadata record may correspond to a GUI element within a GAP or a version of a GAP, and each GUI element within a GAP may have a corresponding GUI element metadata record within the GAP metadata record. For example, GAP  metadata record  contains GUI element \u2018n\u2019 metadata record  indicating that GAP  may be composed of \u2018n\u2019 or more identifiable GUI elements. Alternatively or additionally, GUI element \u2018n\u2019 metadata record  may indicate that GAP  metadata record  currently contains \u2018n\u2019 GUI element metadata records, where \u2018n\u2019 may be an integer value from 0 up to the total number of GUI elements in GAP . Every GUI element in a GAP may not have a corresponding GUI element metadata record. Similarly, GAP  metadata record  may contain GUI element \u2018k\u2019 metadata record , and GAP \u2018j\u2019 metadata record may contain GUI element \u2018m\u2019 metadata record .","Each of the GUI element metadata records , , , and  may include a GUI element identifier , a type identifier , a notation , a GUI element mapping , and other metadata . A GUI element identifier  may serve to identify a GUI element within the GAP or GAP version, using a unique number, character string, or other indicia. For example, one element ID may be \u201c0x30fb0.\u201d A type identifier  may be a classification of a GUI element that defines high level semantics, annotations and properties, permitted or restricted behaviors, and values associated with the GUI element. For example, one type identifier may be \u201cUS-StateTextBox\u201d which may specify a type of text box GUI element that only accepts strings corresponding to the names of the states of the United States. This information may come from the knowledge of a testing engineer when he or she tries to understand the semantics of each GUI element in the GAP under test.","A notation  may include text, notes, informal comments, constraints, or information derived from a technical specification that one programmer may wish to convey to another programmer about a particular GUI element. For example, a notation  may include the text \u201cState Names Only,\u201d as an informal method of conveying to another programmer that only strings corresponding to the names of states of the United States should be included. A GUI element mapping  may identify a GUI element in another GAP or GAP version corresponding to the GUI element associated with the GUI element metadata record. For example, a GUI element mapping  may include the values \u201cUniversity Directory\u201d and \u201c0x30fc8\u201d to indicate that the GUI element associated with this GUI element metadata record corresponds to GUI element 0x30fc8 in the GAP University Directory, version . Additionally, other metadata  may be stored in association with a GUI element metadata record.","The metadata repository  may include any number of GUI element version mapping records, such as the record . The number of GUI element version mapping records  may vary according to the number of GAPs or GAP versions. For example, each GUI element version mapping record  may include mappings from one specific GAP version to another specific GAP version. Alternatively or additionally, each GUI element version mapping record  may include all of the mappings between all of the versions of a single GAP. The example of  shows that the GUI element version mapping record  includes GUI element version mappings  and . The number of GUI element version mappings  and  in a GUI element version mapping record  may vary according to the number of mappings made between GUI elements of different GAPs or GAP versions.","Each GUI element version mapping  or  may include a source GAP alias identifier , a source GUI element identifier , a destination GAP alias identifier , a destination GUI element identifier , and a confidence level value . The GUI element version mapping  provides an example of a GUI element version mapping using extensible markup language (XML). The GUI element version mapping  includes a source GAP alias identifier , a source GUI element identifier , a destination GAP alias identifier , a destination GUI element identifier , and a confidence level value . In this example, the mapping indicates a correspondence between GUI element 0x30fc8 of GAP University Directory, version  (e.g. a subsequent version), to GUI element 0x80fc0 of GAP University Directory, version  (e.g. a current version), with a confidence level of 1200. The confidence level values may use decimal values between 0 and 1, integer values between 0 and 100, or any other scale, to indicate the strength of the certainty to which the mapping between the GUI elements is a correct mapping. For example, a mapping provided by a human user may have a high or absolute confidence of 1 or 1200 percent, where a mapping provided by a mapping evaluation program using GUI element property comparison may have a lower or no confidence. Alternatively or additionally, a mapping provided by a mapping evaluation program using GUI element property comparison may have a high or absolute confidence, where a mapping provided by a human user may have a lower or no confidence.","The processor  uses the database and file management logic  to access and manipulate any of the GAP metadata records , , or , GUI element metadata records , , , or , and\/or GUI element version mapping records stored in the metadata repository . The access and manipulation of the data in the metadata repository  may include reading, writing, storing, copying, updating, moving, deleting, overwriting, appending, or any other function performed on data.",{"@attributes":{"id":"p-0159","num":"0163"},"figref":"FIG. 14","b":["1400","1234","1400","1402","1404","1406","1400"]},"The GAP alias  specifies an identifier for the GAP which includes the GUI element to which a notation is being applied. The GAP alias  may be a unique identifier that distinguishes between GAPs or GAP versions, including a current GAP version and a subsequent version of the same GAP. The GUI element identifier  provides a unique identifier for the GUI element which is being notated. The GUI notation  specifies the notation being assigned to the GUI element (e.g., the text \u201cState names only\u201d).",{"@attributes":{"id":"p-0161","num":"0165"},"figref":"FIG. 14","b":["1408","1410","1408","1412","0","1414","1416"]},"The notation mapping  is a mapping for a Menu Item GUI element. The GAP alias  is \u201cUniversity Directory\u201d, signifying the subsequent version of the university directory GAP. The GUI element being annotated has the unique element identifier  \u201cOpenFile\u201d as specified by the Name field. The GUI notation  for the Window GUI element is the text \u201cOpens to Default Directory\u201d as specified by the Annotation field.",{"@attributes":{"id":"p-0163","num":"0167"},"figref":"FIG. 14","b":["1424","1424","1426","1428","1426","1428","1424","1430","1432","1434"]},{"@attributes":{"id":"p-0164","num":"0168"},"figref":"FIG. 15","b":["1500","132","132","1502","136","130","132","129","1504","132","132","1506","132","1508","132","1502","132"]},{"@attributes":{"id":"p-0165","num":"0169"},"figref":"FIG. 1600","b":["700","1218","1218","1602","424","1218","1604","430","1218","1606","432","1218","1608","434"]},"The type processing logic  may then determine whether a type metadata record corresponding to the GAP alias and GUI element identifier already exists (). If a type metadata record already does exist for the GAP alias and GUI element identifier, then the type processing logic  stores the GUI type identifier in the type metadata record (). The type processing logic  may store the GUI type identifier by overwriting an already existing GUI type identifier or storing the GUI type identifier in a blank GUI type identifier field. In addition, the type processing logic  may display a confirmation request prompt before overwriting an existing identifier, or may employ any other conflict resolution technique before storing or overwriting data. If a type metadata record does not already exist for the GAP alias and the GUI element identifier, then the type processing logic  may create a type metadata record for the GAP alias and the GUI element identifier (). The type processing logic  may then store the GUI type identifier in the type metadata record ().",{"@attributes":{"id":"p-0167","num":"0171"},"figref":"FIG. 17","b":["800","1220","1220","1702","822","1220","1704","828","1220","1706","832","1220","1708","830","1220","1710","834","1220","1712","836"]},{"@attributes":{"id":"p-0168","num":"0172"},"figref":"FIG. 18","b":["1800","1220","1220","1802","1220","1804","812","1220","1806","1308"]},"If the mapping instruction specifies updating the GUI element metadata records, then the mapping processing logic  may locate a source GAP metadata record in a metadata repository (). The metadata repository may be the metadata repository . The source GAP metadata record may be in the example format shown for the GAP  metadata record . The source GAP metadata record may be located by comparing the source GAP alias extracted from the mapping specification message () with a GAP identifier, such as GAP  identifier . The mapping processing logic  may then store the destination GUI element identifier (). For example, the destination GUI element identifier may be stored in the GUI element mapping field . Alternatively or additionally, the confidence level may be stored. For example, the confidence level may be stored in the other metadata field . The mapping processing logic  may then locate a destination GUI record (). The destination GAP metadata record may be similar to GAP  metadata record . The destination GAP metadata record may be located by comparing the destination GAP alias extracted from the mapping specification message () with a GAP identifier, such as GAP  identifier . The mapping processing logic  may then store the source GUI element identifier (). For example, the source GUI element identifier may be stored in the GUI element mapping field . Alternatively or additionally, the confidence level may be stored. For example, the confidence level may be stored in the other metadata field . The mapping processing logic  may then terminate. These steps need not be performed in any particular order. Some steps may be added or removed without affecting the aims of the process.","If the mapping instruction specifies updating both the GUI element metadata records and the GUI version mapping records, then the mapping processing logic  may first locate a source GAP metadata record in a metadata repository (). The mapping processing logic  may then store the destination GUI element identifier and\/or the confidence level (). The mapping processing logic  may then locate a destination GUI metadata record (). The mapping processing logic  may then store the source GUI element identifier and\/or the confidence level (). The mapping processing logic  may then create a GUI version mapping (). The mapping processing logic  may then store the GUI version mapping in the GUI version mapping records (). The mapping processing logic  may then terminate. These steps need not be performed in any particular order. Some steps may be added or removed without affecting the aims of the process.",{"@attributes":{"id":"p-0171","num":"0175"},"figref":"FIG. 19","b":["1900","1222","1222","1902","1424","1222","1904","1430","1222","1906","1432","1222","1908","1434"]},"The notation processing logic  may then determine whether there already exists a notation metadata record corresponding to the GAP alias and GUI element identifier extracted from the notation message (). If a notation metadata record already does exist for the GAP alias and GUI element identifier, then the notation processing logic  can store the GUI notation in the notation metadata record () before terminating. The notation processing logic  may store the GUI notation by overwriting an already existing GUI notation, storing the GUI notation in a blank GUI notation field, displaying a prompt before overwriting an existing notation, appending the notation with an existing notation, or using any other suitable form of resolving conflicts before storing data. If a notation metadata record does not already exist for the GAP alias and the GUI element identifier, then the notation processing logic  may create a notation metadata record for the GAP alias and the GUI element identifier (). The notation processing logic  may then store the GUI notation in the notation metadata record () before terminating.",{"@attributes":{"id":"p-0173","num":"0177"},"figref":"FIG. 20","b":["2000","1224","1224","2002","1224","2004","1224","2006","1224","2008","2010","1224","2002","2010","1224"]},{"@attributes":{"id":"p-0174","num":"0178"},"figref":"FIG. 21","b":["2100","1224","1224","800","1800"]},"The metadata migration logic  may first determine whether the source GUI element has metadata associated with it (). For example, the metadata migration logic  may use a source GAP alias and a source GUI element identifier to locate a source GUI element metadata record. Then the metadata migration logic  may search within that source GUI element metadata record for any relevant metadata fields, such as a type field , notation field , or other metadata field . If the metadata migration logic  determines that the source GUI element does not have relevant metadata associated with it, the metadata migration logic  may then determine whether the destination GUI element has metadata associated with it (). This determination may be performed in a manner similar to determining whether the source GUI element had metadata associated with it (). If the metadata migration logic  determines that the destination GUI element does not have relevant metadata associated with it, the logic may terminate.","If the metadata migration logic  determines that a source GUI element has metadata associated with it, the metadata migration logic  determines whether a destination GUI element has metadata associated with it (). This determination may be performed in a manner similar to determining whether the source GUI element had metadata associated with it (). If the metadata migration logic  determines that the destination GUI element does not have metadata associated with it, the metadata migration logic  may provide a prompt for further processing instructions (). The prompt may ask for instructions on whether to copy metadata from the GUI element with the metadata to the GUI element record without the metadata (). If the response to the prompt is \u2018no\u2019, then the logic may terminate. If the response to the prompt is \u2018yes\u2019, then the logic may perform the copy process () before terminating. A similar process occurs where a source GUI element does not have metadata, but a destination GUI element does.","If the metadata migration logic  determines that both a source GUI element and a destination GUI element each have metadata associated with them, the metadata migration logic  may provide a prompt for further processing instructions (). For example, the prompt may include options for Overwriting one of the sets of metadata with the other, Appending one set of metadata with the other (or optionally, append each set of metadata to the other), or Moving one set of metadata to a completely different GUI element metadata record (). If the response to the prompt includes Overwriting one of the sets of metadata with the other, then the metadata migration logic  may perform the overwrite process () before terminating. If the response to the prompt includes Appending one set of metadata to the other, then the metadata migration logic  may perform the appending process () before terminating. If the response to the prompt includes Moving one set of metadata, the metadata migration logic  may perform the move process () before terminating. Alternatively or additionally, the metadata migration logic  may perform the move process () and then provide another prompt for a continued action, such as copying one set of metadata into the metadata record vacated by the move process, similar to the copy prompt ().",{"@attributes":{"id":"p-0178","num":"0182"},"figref":"FIG. 22","b":["2200","1224","1224","2202","1224","1224","1224","2102"]},"Once the metadata migration logic  has identified a GUI element with metadata associated with it, the metadata logic  may determine whether the GUI element has a mapping associated with it (). For example, this determination may include looking at a GUI element mapping field  within the GUI element metadata record. Alternatively or additionally, the determination may have been made by another logic process with the result from the metadata migration logic  passed along with the identification of the GUI element.","If the metadata migration logic  determines that the GUI element has a an associated mapping, the metadata migration logic  may assume that another metadata migration logic process, such as the logic process , has already migrated any relevant metadata, and thus next determine whether that GUI element was the last element that needed to be checked for metadata migration (). This determination may include looking at the next GAP or GAP version and associated GUI element identifier in a list. Alternatively or additionally, the determination may include looking at the next GUI element metadata record brought up in a depth-first, breadth-first, or other appropriate search algorithm. If the metadata migration logic  determines that the GUI element was the last GUI element to process, then the metadata migration logic  may terminate.","If the metadata migration logic  determines that the GUI element was not the last GUI element to be processed, the metadata migration logic  may move to the next GUI element (). This move may include accessing the next GAP or GAP version and associated GUI element identifier in a list. Alternatively or additionally, the move may include accessing the next GUI element metadata record brought up in a depth-first, breadth-first, or other appropriate search algorithm. After the move, the metadata migration logic  may cycle back and determine whether the new GUI element has a mapping associated with it ().","If the metadata migration logic  determines that a GUI element does not have a mapping associated with it, then the metadata migration logic  may provide a prompt for further instructions (). The prompt may request further instructions as to whether to map the GUI element to another GUI element (). If the response to the prompt includes a \u2018yes\u2019, then the metadata migration logic  may activate a mapping processing logic  and terminate (). Alternatively or additionally, the metadata migration logic  may activate a mapping processing logic  and a metadata migration processing  before terminating.","If the response to the prompt  includes a \u2018no\u2019, then the metadata migration logic  may determine whether that GUI element was the last element that needed to be checked for metadata migration (), similar to the check . If the metadata migration logic  determines that the GUI element was the last GUI element to process, then the metadata migration logic  may terminate. If the metadata migration logic  determines that the GUI element was not the last GUI element to be processed, the metadata migration logic  may move to the next GUI element ().",{"@attributes":{"id":"p-0184","num":"0188"},"figref":"FIG. 1","b":["106","106","154","160","154","150","156","154","152","158","160","156","158","163","162","162","163","156","158","150","152","156","158"]},{"@attributes":{"id":"p-0185","num":"0189"},"figref":"FIG. 23","b":["106","106","2302","2304","2306","106","138","170","2314","163","163","138","1308","2314","2318","106","106"]},"The memory  may include GUI model builder logic . The GUI model builder logic  may communicate with a proxy . The proxy  may be stored in the memory  and access a GAP table . The proxy  may communicate with GAPs, such as a current GAP version  and a subsequent GAP version . The current GAP version  and subsequent GAP version  may already reside in the memory . Alternatively or additionally, the system  may request and receive the current GAP version  and the subsequent GAP version  through the communication logic , whereupon the current GAP version  and the subsequent GAP version may be stored in the memory .","The proxy  may include logic that inserts the hooks  and  into a process space of the GAPs  and . The proxy  may communicate with the hooks  and . In particular, the proxy  may exchange messages with the hooks  and  to obtain the state of any or all of the GUI elements in the GAPs  and . The hooks  and  may be programs that respond to messages from the proxy  and may interact through an accessibility layer  of an operating system  to discover and report information about the GUI elements in the GAPs  and  to the proxy. The accessibility layer  may expose an accessibility interface through which the proxy  and hooks  and  may invoke methods and set and retrieve GUI element values and characteristics, and thereby select, highlight, control, modify, assign identifiers for, or otherwise interact with the GUI elements in the GAPs.","The Microsoft\u2122 Active Accessibility (MSAA) layer is one example of a suitable accessibility layer. In this regard, the GAPs  and  expose the accessibility interfaces that export methods for accessing and manipulating the properties and behavior of GUI elements. For example, the GAPs  and  may employ the IAccessible interface to allow access and control over the GUI element using MSAA application programming interface (API) calls. The IAccessible interface further facilitates applications to expose a tree of data nodes that make up each window in the user interface currently being interacted with. The GUI model builder logic  and proxy  may then include program statements to access and control the GUI element as if the GUI element was a conventional programming object. Accessibility API calls may include: perform actions on objects, get values from objects, set values on objects, navigate to objects, and set properties on objects, and other calls.","The proxy  may be a daemon program and may start prior to the GUI model builder logic . The proxy  may be aware of one or more GAPs. When the proxy  starts, it may load the GAP table , which may include a predefined set of GAP entries for which the proxy  is aware. A GAP entry may take the form:",{"@attributes":{"id":"p-0190","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003<Alias, <File0, Path0, Dir0, CommandLine0>, <File1, Path1, Dir1,"},{"entry":"CommandLine1>>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"where Alias may be a unique pre-defined name for the GAP (e.g., a name generic to both the current GAP version  and the subsequent GAP version ), File may be the name of the executable program for the current GAP version , Path may be the absolute path to File, Dir may be the absolute path to the directory from which File should execute, and CommandLine may specify command line arguments for File. File, Path, Dir, and CommandLine provide similar parameters for the subsequent GAP version .","When the GUI model builder logic  starts, it may connect to the proxy . Once connected, the GUI model builder logic  may request the GAP table  by sending a GAP table request message to the proxy . The proxy  may respond by sending a GAP table response message including the GAP table  to the GUI model builder logic . An example message exchange is shown in Table 4:",{"@attributes":{"id":"p-0193","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"GAP table request message"},{"entry":"<GetGapTable\/>"},{"entry":"GAP table response message"},{"entry":"<GapTable>"},{"entry":"<GAP Alias = \u201cname\u201d"},{"entry":"\u2003\u2003<V_N File=\u201cgap.exe\u201d Path=\u201cc:\\path\\N\u201d CommandLine=\u201c-c1\u201d\/>"},{"entry":"\u2003\u2003<V_N1 File=\u201cgap.exe\u201d Path=\u201cc:\\path\\N1\u201d CommandLine=\u201c-c1\u201d\/>"},{"entry":"\u2003<\/GAP>"},{"entry":"<\/GapTable>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The GUI model builder logic  may then provide a list of GAPs from which an operator may choose. The operator may access the system  either locally through the display  or remotely, e.g. through the terminal . The GUI model builder logic  may then create a GAP load message, e.g., <LoadGap Alias=\u201cname\u201d\/> and send the GAP load message to the proxy  to start any selected GAP (which may then display its user interface). One GAP load message may cause the proxy  to start multiple versions of a GAP identified together in the GAP table  in the <GAP> section.","After starting the GAPs, the proxy  may inject hooks into the GAPs' process space. The hook may connect to the proxy  and send a confirmation message (e.g., <GAP File=\u201cgap.exe\u201d Instance=\u201c192\u201d\/>). The proxy  may send a success message (e.g., <Loaded Alias=\u201cname\u201d VN=\u201c192\u201d VN=\u201c193\u201d\/>) to the GUI model builder logic , thereby acknowledging that the GAPs are started successfully.","The GUI model builder logic  may request the current state of each started GAP. In that regard, the GUI model builder logic  may send a state request message (e.g., <GetState Alias=\u201cname\u201d\/>) to the proxy . In turn, the proxy  may locate the connection to the corresponding hooks of the GAPs and send a state request message (e.g., <GetState\/>) to the hooks. The hooks may create a GAP state (including unique identifiers for GUI elements), such as a state tree, encode it (e.g., in XML format), and send it to the proxy . The proxy  may forward the GAP state to the GUI model builder logic . An example GAP state message sent by the proxy  is shown in Table 5.",{"@attributes":{"id":"p-0197","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GAP state message"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<State SeqNumber=\u201d1\u201d Name=\u201dname\u201d Alias=\u201dname\u201d ProcessID=\u201d972\u201d>"},{"entry":"\u2003\u2003<GUIElement Alias=\u201dname\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<Location x=\u201d15\u201d y=\u201d200\u201d width=\u201d23\u201d height=\u201d98\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<Description>Action<\/ Description>"},{"entry":"\u2003\u2003\u2003\u2003<DefAction>Action<\/DefAction>"},{"entry":"\u2003\u2003\u2003\u2003<UniqueID>0xcafebabe<\/UniqueID>"},{"entry":"\u2003\u2003\u2003\u2003<Class>LISTBOX<\/Class>"},{"entry":"\u2003\u2003\u2003\u2003<Values>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<Value SeqNumber=\u201d1\u201d>someval<\/Value>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003..........................."},{"entry":"\u2003\u2003\u2003\u2003<\/Values>"},{"entry":"\u2003\u2003<\/GUIElement>"},{"entry":"\u2003\u2003..............."},{"entry":"<\/State>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The GAP state contains information about the GUI elements composing a given screen, as well as the values of these elements and their assigned identifiers. The GAP state specifies the GAP GUI elements and the values of the GUI elements. In one implementation the GAP state is reflected in an eXtensible Markup Language (XML) structure where the element \u2018State\u2019 has one or more children elements \u2018GAP\u2019 whose children elements are in turn \u2018GUIElement\u2019s. For example, GUI elements may be either containers or basic. Container GUI elements contain other elements, while basic elements do not contain other elements. The XML structure reflects the containment hierarchy by allowing GUIElements to contain other GUIElements.","In the XML structure, the attribute SeqNumber may designate a unique sequence number of the state within the GAP. Since states are mapped to GUI screens, each state may be given a name which is specified by the optional attribute \u2018Name\u2019. The attributes Alias and ProcessID may denote the alias of the GAP and its instance process identifier respectively. The instance process identifier may differentiate between the current GAP version and the subsequent GAP version.","The GUI model builder logic  may construct GAP GUI models based on the GAP state messages received from the proxy . For example, the GUI model builder logic  may construct a GAP Vn GUI model  from GAP state messages regarding the current GAP version . Similarly, the GUI model builder logic  may construct a GAP Vn+1 GUI model  from GAP state messages regarding the subsequent GAP version .","The processor  may invoke GAP comparison logic  stored in the memory . The GAP comparison logic  may compare two GAP GUI models, such as GAP GUI models  and , and produce a GUI difference model . The GAP comparison logic  may include mapping retrieval logic , representation traversal logic , weighted analysis logic , and match building logic .","The mapping retrieval logic  may request particular GAP GUI element mappings from the GAP GUI element mappings  in a GUI element data repository  and store the particular GAP GUI element mappings in the memory  as GUI element version mappings .","The representation traversal logic  may traverse a GAP GUI model, such as GAP Vn GUI model . For example, the representation traversal logic  may determine the next node to visit in either of the GAP GUI models  and . Alternatively or additionally, the representation traversal logic  may traverse all or parts of a GUI difference model, such as GUI difference model . The next node to visit may be determined, as examples, in depth-first or breadth-first fashion.","The weighted analysis logic  may use GUI characteristic weights  obtained from a weight table  to determine a similarity value between a GUI element within a first GAP GUI model, such as the GAP Vn GUI model , and each GUI element within a second GAP GUI model, such as the GAP Vn+1 GUI model . Different GUI characteristic weights  may be assigned to the similarities or differences between different GUI element characteristics  or properties that may be present or absent between the GUI elements in the two GAP GUI models. The GUI element characteristics  may include GUI element characteristics such as size, XY position, color, window position, font type, font size, border style, background color, foreground color, Read-only\/Read-Write, or any other GUI element characteristic. Alternatively or additionally, the GUI element characteristics  may include an accessibility layer Role, Class, Style, Extended Style, number of Children, Level within a tree or hierarchy, Name of the GUI element, or other accessibility layer-assigned properties. The weight table may also include notes  associated with the weights  assigned to the GUI characteristics  that may explain the rationale behind each weight value.","The weighted analysis logic  may store a score  in a score table  based on each similarity value generated by the weighted analysis logic . Each score  in the score table  may correspond with a source identifier  and a destination identifier . The source identifier  and destination identifier  may be a unique value or combination of values (e.g., including GAP aliases) identifying the GAPs and GUI elements that the weighted analysis logic  compared to calculate each score .","The match building logic  may compare the similarity values generated by the weighted analysis logic  and\/or the scores  stored in the score table  against a similarity threshold . This comparison may determine whether two GUI elements are sufficiently similar to be considered a match from the current GAP version to the subsequent GAP version. The match building logic  may create a link between matching GUI elements in the GUI difference model . The link may be stored in the GUI element representation within the GUI difference model  as a GUI element link  with an optional corresponding matching score . The GUI element link may comprise an identifier of a second GUI element . The identifier may be the source identifier , the destination identifier , or both.","In operation, the GAP comparison logic  may obtain the GAP GUI models  and  by retrieving them from the memory , by calling the GUI model builder logic , or in another manner. The GAP comparison logic  may create a base GUI difference model as a root node from which the GAP GUI models  and  descend in different branches from the root. The GAP comparison logic  may then determine the next node to visit in each of the GAP GUI models using the representation traversal logic .","The GAP comparison logic  may initiate execution of the mapping retrieval logic  to obtain GUI element version mappings available from external sources, such as the metadata repository . The GAP comparison logic  may request all available GUI element version mappings, or may specifically request GUI element version mappings for the next node in the current GAP GUI model. If a GUI element version mapping is available for the next node in the current GAP GUI model, the GAP comparison logic  may forgo execution of the weighted analysis logic . Instead, the GAP comparison logic  may employ the match building logic to write a GUI element link into the base GUI difference model. As another alternative, when a GUI element version mapping is available, the GAP comparison logic  may create a corresponding entry in the score table  based on the information available in the GUI element version mapping.","However, the GUI comparison logic  need not forgo the weighted analysis when a GUI element version mapping exists. Instead, the GAP comparison logic  may decide whether to proceed with the weighted mapping based on the confidence level provided in the GUI element version mapping. For example, when the confidence level exceeds a confidence threshold, the GAP comparison logic  may forgo execution of the weighted analysis. As another example, when the confidence level specifies manual mapping, the GAP comparison logic  may forgo execution of the weighted analysis.","The GAP comparison logic  uses the weighed analysis logic  to determine similarity values between each GUI element in the current GAP GUI model  and each element in the subsequent GAP GUI model . The weighted analysis logic  is described in more detail below. The weighted analysis logic records the similarity values in the weight table  as scores. The scores may be the similarity values, normalized similarity values, or based in some other way on the similarity values.","Having determined the similarity values, the GAP comparison logic  may use the match building logic  to determine whether GUI elements match between GAP versions. To that end, the match building logic  may compare the scores in the score table against the similarity threshold . GUI elements with scores that exceed the similarity threshold  may be considered matches under the assumption that the higher the similarity score, the more likely they refer to corresponding GUI elements. The match building logic  may create GUI element links in the base GUI difference model when matches are determined.",{"@attributes":{"id":"p-0212","num":"0216"},"figref":"FIG. 24","b":["2400","2400","2400","2402","0","2404","2406","2406","2406"]},{"@attributes":{"id":"p-0213","num":"0217"},"figref":"FIG. 25","b":["2500","2500","2502","1","2504","2506","2506","2506"]},"The GUI element with identifier  is a modified version of the GUI element with identifier . In other words, when the programmer designed the subsequent GAP version, the programmer modified the GUI element with identifier  to obtain the GUI element with identifier . In particular,  show that the following changes have been made: the style changed from \u201c0x560100c1\u201d to \u201c0x560100242\u201d and the extended style changed from \u201c0xc0000a00\u201d to \u201c0xc0000800\u201d. These differences in GUI element characteristics are not readily discernible to test script writers. However, other changes may be discernable to a programmer, such as the class change from \u201cWindowsForms10.LISTBOX.app4\u201d to \u201cWindowsForms10.COMBOBOX.app.0.378734a\u201d.",{"@attributes":{"id":"p-0215","num":"0219"},"figref":"FIG. 26","b":["2600","2600","2602","2400","2604","2500","2602","2604","2606","2608","2606","2608"]},"The GUI difference model  may be in a flat configuration, where the GUI difference model  includes a single section  and a single corresponding section . Alternatively or additionally, the GUI difference model  may be in a tree, hierarchical, or nested configuration, where the GUI difference model  includes multiple sections  and multiple corresponding sections . In the tree, hierarchical, or nested configuration, similar GUI elements may be represented by a single node. Alternatively or additionally, similar GUI elements may be represented in separate nodes. The GUI difference model  may include all of the GUI elements of both of the GAP GUI models. Alternatively, the GUI difference model  may include only the elements of the second GAP GUI model and the corresponding portions of the first GAP GUI model. The GUI difference model  may be formed based on a bi-simulation algorithm as described in more detail below.","The GAP comparison logic  may create the difference portion  in the format presented in  when it combines the source GAP GUI model with the destination GAP GUI model under a root node. Alternatively or additionally, the GAP comparison logic  may create the difference portion  after the mapping retrieval logic  obtains a relevant mapping between the GUI element represented in the current version section  and the subsequent version section . Alternatively or additionally, the GAP comparison logic  may create the difference portion  after the match building logic  creates a link between the current version section  and subsequent version section .",{"@attributes":{"id":"p-0218","num":"0222"},"figref":"FIG. 27","b":["2700","2320","2320","2324","2320","2702","2320","2704"]},"The GUI model builder logic  may then create a GAP load message, e.g., <LoadGap Alias=\u201cname\u201d\/> and send the GAP load message to the proxy  to start the selected GAP version, which may then display its GUI (). After starting the GAP, the proxy  may inject a hook into the GAP's process space (). The hook may connect to the proxy  and send a confirmation message (e.g., <GAP File=\u201cgap.exe\u201d Instance=\u201c192\u201d\/>). The proxy  may send a success message (e.g., <Loaded Alias=\u201cname\u201d VN=\u201c192\u201d VN=\u201c193\u201d\/>) to the GUI model builder logic , thereby acknowledging that the GAP is started successfully.","The accessibility layer, proxy, hook, and GUI model builder logic  monitor operator interaction with GUI elements in the selected GAP version (). The GUI model builder logic  may send a state request message (e.g., <GetState Alias=\u201cname\u201d\/>) to the proxy  to obtain GUI element information from the hook (). In turn, the proxy  may locate the connection to the corresponding hook in the selected GAP version and send a state request message (e.g., <GetState\/>) to the hook. The hook may create a GAP state (including unique identifiers for GUI elements), such as a state tree, encode it (e.g., in XML format), and send it to the proxy . The proxy  may forward the GAP state to the GUI model builder logic . The GUI element information may be returned to the GUI model builder logic  one screen at a time, one GUI element at a time, an entire application at a time, or at some other discrete segmentation of the GAP.","The purpose of monitoring operating interaction with the GAP is to allow the GUI model builder logic  to record the structures of the screens and operator actions on the GAPs. The GUI model builder logic  intercepts operator events using the accessibility layer. Through these events, the GUI model builder logic  records the sequence of screens that the operator navigates through, as well as the actions that the operator performs on GUI elements. When recording the sequence of screens, the GUI model builder logic  obtains information about the structure of the GAP and the properties of the individual GUI elements using the accessibility-enabled interfaces. Accordingly, the GUI model builder logic  extracts GUI element structural data () and GUI element characteristics () from the information returned by the accessibility layer. The GUI model builder logic  uses the GUI element structural data and GUI element characteristics to add GUI element information into a GAP GUI model (), e.g., on an element by element, screen by screen, or other incremental basis. The GUI model builder logic  may continue to build the GAP GUI model until the operator stops interacting with the selected GAP ().","The GAP GUI model that results may be a full or partial capture of the entire GAP GUI structure. Thus, when the operator is interested in comparing specific pieces of a GUI between two GAPs, the operator may exercise only those pieces of interest. The GUI model builder logic  captures the specific pieces in a GAP GUI model specific to the pieces that the operator exercised, rather than every aspect of every GUI element in the entire selected GAP. The operator may run both the current GAP version  and subsequent GAP version  with the GUI model builder logic  to create the GAP Vn GUI model  and the GAP Vn+1 GUI model , respectively.",{"@attributes":{"id":"p-0223","num":"0227"},"figref":"FIG. 28","b":["2800","2342","2342","2802","2342","2338","2304","2342","2804","2342","2340","2304","2342","163"]},"The GAP comparison logic  may then combine the first GAP GUI model and the second GAP GUI model to create a base GUI difference model (). The first and second GAP GUI models may be combined in a flat configuration. Alternatively or additionally, the first and second GAP GUI models may be combined in a tree, hierarchical, or nested configuration.","The GAP comparison logic  may then invoke the mapping retrieval logic . The mapping retrieval logic  may determine whether GUI element version mappings are available for the first GAP GUI model and the second GAP GUI model (). This determination may be performed by querying a local source, such as the memory , for the GUI element version mappings. Alternatively or additionally, the mapping retrieval logic  may query a GUI element data repository  via the communication logic .","If the mapping retrieval logic  determines that GUI element version mappings are available, then the mapping retrieval logic  may request those GUI element version mappings (). The request may be made to a local source, such as the memory . Alternatively or additionally, the request may be made to a GUI element data repository  via the communication logic . The request may be for specific mappings, such as for GUI element version mappings relevant for the next node. Alternatively, the request may be for all available GUI element version mappings. The mapping retrieval logic  may receive the GUI element version mappings in response to the request ().","Alternatively or additionally, the determination of whether GUI element version mappings are available, the request, and the response may be combined into fewer actions. For example, the mapping retrieval logic  may just request the mappings. A response of GUI element version mappings may confirm that the mappings are available, while a negative or null response may confirm that the mappings are not available.","The mapping retrieval logic  may then return, and the GAP comparison logic  may then invoke the representation traversal logic . The representation traversal logic  may traverse to the next GUI element, i.e. a source GUI element, from the first GAP GUI model (). In the case where the base GUI difference model is newly created, the traversal may be to the first GUI element. The traversal may be performed based on the first GAP GUI model. Alternatively or additionally, the traversal may be performed based on the representation of the first GAP GUI model within the base GUI difference model. The next node to visit may be determined, as examples, in depth-first or breadth-first fashion.","The GAP comparison logic  may then determine whether a GUI version mapping exists for the GUI element (). The GAP comparison logic  may search within the retrieved GUI element version mappings to determine whether the mapping exists. If a mapping exists, then the GAP comparison logic  may create a link field in the base GUI difference model (). The link field may include a GUI element identifier, such as a source GUI element identifier or a destination GUI element identifier. The link field may also include a GAP alias. The GAP comparison logic  may create a link field for just the source GUI element. Alternatively or additionally, the GAP comparison logic may create a link field for the destination GUI element.","The representation traversal logic  may then determine whether more source GUI elements are available (). If more source GUI elements have not yet been traversed, then the representation traversal logic  cycles back and traverses to the next available source GUI element (). If no source GUI elements are available, the GAP comparison logic  may terminate.","If either no GUI element version mappings exist or the mappings exist, but no mappings exist for the source GUI element, then the GAP comparison logic  may invoke the weighted analysis logic . The weighted analysis logic  may retrieve weights from a weight table (). For example, the weighted analysis logic  may retrieve the weights from a weight table in the memory . Alternatively or additionally, the weighted analysis logic  may request and receive a weight table from the communication logic .","The representation traversal logic  may then traverse to the next GUI element, i.e. a destination GUI element, in the second GAP GUI model (). In the case where no previous traversals in the second GAP GUI model have been made for a given source GUI element, then the representation traversal logic  may traverse to the first GUI element in the second GAP GUI model. The traversal may be performed based on the second GAP GUI model. Alternatively or additionally, the traversal may be performed based on the representation of the second GAP GUI model within the base GUI difference model. The traversal may be performed using a depth-first, breadth-first, or other traversal technique.","The weighted analysis logic  may then obtain GUI element characteristics for the source GUI element and the destination GUI element (). The GUI element characteristics may include GUI element characteristics such as size, XY position, color, window position, font type, font size, border style, background color, foreground color, Read-only\/Read-Write, or any other GUI element characteristic. Alternatively or additionally, the GUI element characteristics may include an accessibility layer Role, HWND, Class, Style, Extended Style, number of Children, Level within a tree or hierarchy, Name of the GUI element, or other accessibility layer-assigned properties. These GUI element characteristics may be obtained from the first and second GAP GUI model. Alternatively or additionally, the GUI element characteristics may be obtained from the base GUI difference model.","The weighed analysis logic  may then determine a GUI element similarity value for the source GUI element and the destination GUI element (). The similarity value may be determined according to the following formula:",{"@attributes":{"id":"p-0235","num":"0239"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["V","s"]},"mo":"=","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"msub":[{"mi":["W","i"]},{"mi":["P","i"]}],"mo":"\u00b7"}}}}}},"where Vis the similarity value, N is the number of characteristics or properties against which the similarity is being measured, Pis a value assigned to the differences between each property or characteristic, and Wis the corresponding weight for each property P. As one example:\n\n\u00b7Role\n","where Role may be either 0 or 1 depending on whether the Role characteristics between the two GUI elements are different or the same, respectively, and Wmay be the corresponding weight for the Role. The weight for the Role may be assigned a value indicative of the importance of the Role matching between GUI elements. For example, the weight of the Role may be very large in relation to the weight for other characteristics.","As another example:\n\n\u00b7Role+\u00b7Class\n","where Class may be a count of how many terms in the Class property match, divided by the total number of terms in the Class property, and Wmay be the corresponding weight for the Class. For example, a Class characteristic for a GUI element may be \u201cWindowsForms10.LISTBOX.app4\u201d. If the Class characteristic for a corresponding GUI element is \u201cWindowsForms10.COMBOBOX.app.0.378734a\u201d, then because the characteristics only match to a single place out of three or five places, the Class value may be either \u201c\u2153\u201d or \u201c\u2155\u201d.","The GAP comparison logic  may then store in a score table a score based on the similarity value (). Alternatively or additionally, the GAP comparison logic  may store the GUI element identifiers for the source GUI element and the destination GUI element along with the score in the score table. The score table may reside in the memory .","The GAP comparison logic  may then determine whether the representation traversal logic  has completed traversing the second GAP GUI model (). If the representation traversal logic  still has more destination GUI elements to traverse, then the representation traversal logic  cycles back to traversing to the next destination element (). If the representation traversal logic  has completed traversing the destination GUI elements, the GAP comparison logic  may invoke the match building logic .","The match building logic  may analyze either the similarity values determined by the weighted analysis logic  or the scores stored in the score table (). The match building logic  may compare the values or scores against a similarity threshold to determine whether values or scores meet and\/or exceed the similarity threshold. Alternatively or additionally, the values or scores may be compared against a difference threshold to determine whether the values or scores are at and\/or below a difference threshold.","The match building logic  may determine whether the GUI elements match (). This determination may occur when the values or scores exceed the similarity threshold. Alternatively or additionally, this determination may occur when the values or scores are not below a difference threshold.","If a match exists, then the GAP comparison logic  may create a link field in the base GUI difference model (). The link field may include a GUI element identifier, such as a source GUI element identifier or a destination GUI element identifier. The link field may also include a GAP alias. The GAP comparison logic  may create a link field for just the source GUI element. Alternatively or additionally, the GAP comparison logic may create a link field for the destination GUI element.","After the GAP comparison logic  creates a link field, or if no match exists, then the match building logic  may determine whether more scores or similarity values need to be analyzed (). This determination may depend on whether the score table still includes scores that have not been analyzed. If the GAP comparison logic  determines that more scores need to be analyzed, the match building logic  cycles back to analyzing the next score in the score table (). If no unanalyzed scores exist in the score table, the match building logic  may return, and the GAP comparison logic  may cycle back to determining whether any more source GUI elements remain (). Alternatively or additionally, the GAP comparison logic  may communicate any link fields created by the match building logic  to the GUI element data repository for storage as a GAP GUI element version mapping. The communication may use a GUI element version mapping message format as described in .","In another implementation, the GAP comparison logic  may execute a schema comparison to determine differences between the current GAP GUI and the subsequent GAP GUI. Given a schema representation (e.g., an XML schema representation) of the current GAP GUI and the subsequent GAP GUI, the GAP comparison logic  may compare the respective schemas. If these schemas are \u201cequal\u201d, then the current GAP version and subsequent GAP version are the same. Otherwise, the current GAP version and the subsequent GAP version are different, and the GAP comparison logic  finds the differences.","For example, the XML schemas may be recorded in the XML format and each schema may have the root specified with the <schema> element. Data elements may be specified with the <element> and with the <attribute> tags. Each data element may be defined by its name and its type. Elements may be either of simple or complex types. Complex element types support nested elements while simple types are attributes and elements of basic types.","Extending the example, elements may have two kinds of constraints. First, values of elements may be constrained. The second kind of constraints specifies bounds on the number of times that a specific element may occur as a child of an element. These bounds are specified with the minOccurs and maxOccurs attributes of the <element> tag to represent the minimum and maximum number of occurrences. Elements may be grouped in a sequence if they are children of the same parent element. Attributes of the same element may also be grouped in a sequence. Each element or attribute in a sequence may be assigned a unique positive integer sequence number. This number may be used to access elements or attributes instead of using their names.","Schemas may be represented using graphs. Let T be finite sets of type names and F of element and attribute names (labels), and distinct symbols \u03b1\u03b5F and \u03b2\u03b5T. Schemas graphs are directed graphs G=(V, E, L) such that:","1) VT, the nodes are type names or \u03b2 if the type name of data is not known;","2) LF, edges are labeled by element or attribute names or a if the name is not known;","3) EL X V X V, edges are cross-products of labels and nodes. If <l, vk, vm>\u03b5E, then vk->(l)->vm. Nodes vm are called children of the node vk. If an element has no children, then its corresponding node in a schema graph has an empty collection of children nodes;","4) Bounds for elements are specified with subscripts and superscripts to labels designating these elements. Subscripts are used to specify bounds defined by the minOccurs attribute, and superscripts designate the bounds specified by the maxOccurs attribute;","5) Each graph has the special node labeled root \u03b5V, where root represents a collection of the root elements. An empty schema has a single root node and no edges;","6) The XML tag <complexType> specifies that an element is a complex type, and it is not represented in the graph.","A path in a schema graph may be a sequence of labels PG=<l, l, . . . ln>, where vk->(ln)->vm for vm in V and 1<=u<=n. The symbol \u03b2 may be used instead of a label in a path if an element is navigated by its sequence number. Function type:v->s returns the type s\u03b5T of the node v\u03b5V. Function max:label(u, l)->u returns the upper bound u, or \u221e if the upper bound is not specified, and function min:label(u, l)->l returns the lower bound l, or zero if the lower bound is not specified.","Once GAPs are modeled using XML schemas, these schemas can be compared using simulation to compute changes between the corresponding GAPs. That is, if the schema of the new GAP is the same as the schema of the previous release of the GAP, or the types of its GUI objects are subsumed by the types of the corresponding GUI object of the previous GAP, then these schemas may be considered identical. Otherwise, the GAP comparison logic  may issue a warning and GUI objects with the associated modification types are reported.","To that end, the GAP comparison logic  may implement a bi-simulation technique to compare schemas.  shows an example of the bi-simulation properties  that the GAP comparison logic  may employ, including a first bi-simulation property , a second bi-simulation property , a third bi-simulation property , and a fourth bi-simulation property .","The bi-simulation may be a binary relation between the nodes of two graphs g, g\u03b5G, written as x{tilde over ( )}y, x, y\u03b5V, satisfying the bi-simulation properties -.","The GAP comparison logic  may consider two finite graphs g, g\u03b5G equal if there exists a bi-simulation from g to g. A graph is bi-similar to its infinite unfolding. The GAP comparison logic  may compute the bi-simulation of two graphs starts with selecting the root nodes and applying the bi-simulation properties -. The GAP comparison logic  search for a relation (x, y) between nodes x and y in a graph that fails to satisfy the bi-simulation properties -. When such a relation (x, y) is found, then the GAP comparison logic  determines that the graphs are not equal and the bi-simulation may stop.","For example, consider the current schema  and the subsequent schema  in . The GAP comparison logic  applies bi-simulation to determine whether two schemas  and  are equivalent. The schema  describes XML data that models a current GUI screen, and the schema  models a modified version of the current GUI screen. The comparator logic  may determine that If the schema  is equivalent to the schema , then the GUI screens are the same.","The GUI comparison logic  selects the root nodes  and  in both schemas  and  that satisfy the first bi-simulation property  and the second bi-simulation property . The GAP comparison logic  may then select the relation root(book)->\u03b1  from the schema  and check to see that the third bi-simulation property  holds for the relation root(root)->\u03b1  in the schema .","Since it does, the GAP comparison logic  determines whether the fourth bi-simulation property  holds for both relations. Since it does, the GAP comparison logic  proceeds to the relation \u03b1->(author)->\u03b1  for the schema  and the relation \u03b1->(author)->\u03b1  for the schema . The GAP comparison logic  determines that the third bi-simulation property  and the fourth bi-simulation property  are violated. In particular, the GAP comparison logic  determines that the offending relation \u2018author\u2019 is tagged as potentially deleted in the schema , a difference from the schema . Thus, the schemas  and  are not equal.",{"@attributes":{"id":"p-0264","num":"0268"},"figref":"FIG. 29","b":["2900","2902","2380","2902","2380","2380","2902","2306","2318"]},"In the example shown in , the interface  includes a slider  that selects a value between 0 and 1. Any other interface or value range may be provided to the operator. The GUI difference model logic  may set the difference threshold based on the value of the slider . The value 0 represents that essentially no or limited similarity is needed to find a match between GUI elements. The value 1 represents that very close or exact similarity is needed to find a match between GUI elements. Such similarity may be found in manual mappings, for example, as specified in a high confidence level field  (e.g., \u201c100 M\u201d) as received from the metadata repository. However, a very high level of confidence may also be obtained through the automated weighting analysis described above, and the GUI difference model logic  may, in some implementations, accept a manual version mapping as correct regardless of the associated confidence level.",{"@attributes":{"id":"p-0266","num":"0270"},"figref":"FIG. 29","b":["2906","2326","2908","2328","2902","2380","2378","2378"]},"In , the visualization logic  highlights matching GUI elements based on the similarity threshold set through the interface . The similarity threshold is relatively high. In the example shown in , the visualization logic  highlights the textbox elements , , , , and  in the portion  of the current GAP version , that match, respectively, to the textbox elements , , , , and  in the portion  of the subsequent GAP version . The textbox elements - have little or no changes in their characteristics between the subsequent GAP versions. The textbox element  and the combo box element  remain un-highlighted, however, because their characteristics differ to a greater extent, and the weighted comparison analysis does not determine a GUI element similarity value that exceeds the similarity threshold.","In , the display  shows that the slider  has been adjusted to a lower similarity threshold. The visualization logic  highlights the matching GUI elements based on the lower similarity threshold set through the interface . In the example shown in , the visualization logic  highlights, as before, the textbox elements , , , , and  in the portion  of the current GAP version , that match, respectively, to the textbox elements , , , , and  in the portion  of the subsequent GAP version .","However, the visualization logic  also highlights the textbox element  and the combo box element . Although the characteristics of the textbox element  and the combo box element  differ to a certain extent, the weighted comparison analysis does obtain a GUI element similarity value that exceeds the similarity threshold. Accordingly, the visualization logic  highlights the elements  and .",{"@attributes":{"id":"p-0270","num":"0274"},"figref":"FIG. 31","b":["3100","2378","2378","2326","3102","2328","3104","2378","2322","2326","2328"]},"The visualization logic  also may display a GUI comparator threshold interface  (). The visualization logic  may set the similarity threshold based on the value chosen through the GUI comparator threshold interface  (). Given the similarity threshold, the visualization logic  may call the GUI difference model logic to determine a matching GUI element between the current GAP version  and the subsequent GAP version  (). Alternatively, the visualization logic  may execute a comparison analysis (e.g., the weighted comparison analysis described above) to determine one or more GUI elements in the subsequent GAP version  that match any particular element in the current GAP version. The visualization logic  may accept an element selection from the operator that specifies one or more particular GUI elements of interest in either GAP version, and find the matching GUI elements in the other GAP version. Alternatively, the visualization logic  may consider each GUI element in the current GAP version  and find the matching GUI elements in the subsequent GAP version .","The visualization logic  highlights matching GUI elements in the current GAP version  and in the subsequent GAP version  (). To that end, the visualization logic  may issue commands to the proxy to highlight any particular GUI elements. If there are more GUI elements to consider, the visualization logic  attempts to find additional matches.","At any time, the visualization logic  may check to determine whether the GUI comparator threshold interface  has changed (e.g., the operator changed the slider position to select a new threshold value). The visualization logic  may also check, at any time, whether the operator desired to review different GAPs. If so, the visualization logic  obtains new GAP selections (). The visualization logic then displays the GAPs and the GUI comparator threshold interface and proceeds as noted above.",{"@attributes":{"id":"p-0274","num":"0278"},"figref":"FIG. 1","b":["108","108","108","108","162","150","152","162","162","108","190","138","138","162","150","152","108","166","164","164","168","164","108","170","168","172","174","168","170","138","174","188","194","170","170","178","180","184","162","168"]},{"@attributes":{"id":"p-0275","num":"0279"},"figref":["FIG. 33","FIG. 33","FIG. 33"],"b":["150","150","150","3302","11","11","18","21","59","3304","3306","3308","3310","3316","162"]},"A GAP, the GUI elements of the GAP and the values of the GUI elements define states for the GAP. The current and subsequent GAP tree models capture the states of the current and subsequent GAP versions (e.g.,  and ), respectively. In one implementation, GAP states are identified by sequent numbers and alias, as well as other attributes. For example, line  of Table 6 illustrates a \u2018state\u2019 that has a SeqNumber with a value of 0. The SeqNumber represents a unique sequence number of the current GAP version. The state is given the name State__. The attributes Alias and ProcessId represent the alias of the current GAP version  and the instance process identifier for the current GAP version , respectively. Recall that Table 6 and Table 8 illustrate that the current and subsequent GAP tree models support GUI elements that include nested GUI elements. Although multiple GUI elements may use an identical Alias (e.g., StateList as illustrated in Table 6 at lines  and ) the GUI elements are further distinguished by the UniqueID attribute (e.g., 0x0 and 0x12 as shown at lines  and  of Table 6).",{"@attributes":{"id":"p-0277","num":"0281"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Current GAP tree model"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2212 <State SeqNumber=\u201c0\u201d Name=\u201cState_0_3556\u201d"]},{"entry":[{},"Alias=\u201cUniversity Directory0\u201d ProcessId=\u201c3556\u201d>"]},{"entry":[{},"\u2003\u2212 <GUIElement Alias=\u201cStateList\u201d>"]},{"entry":[{},"\u2003\u2003<UniqueID>0x0<\/UniqueID>"]},{"entry":[{},"\u2003\u2003<HWND>0x170a64<\/HWND>"]},{"entry":[{},"\u2003\u2003<Location x=\u201c87\u201d y=\u201c66\u201d width=\u201c792\u201d height=\u201c672\u201d \/>"]},{"entry":[{},"\u2003\u2003<Class>WindowsForms10.Window.8.app4<\/Class>"]},{"entry":[{},"\u2003\u2003<Style>0x16cf0000<\/Style>"]},{"entry":[{},"\u2003\u2003<ExStyle>0xc0050900<\/ExStyle>"]},{"entry":[{},"\u2003\u2002+ <GUIElement Alias=\u201cSystem\u201d>"]},{"entry":[{},"\u2003\u2002+ <GUIElement Alias=\u201cNAMELESS\u201d>"]},{"entry":[{},"L11 \u2212 <GUIElement Alias=\u201cStateList\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<UniqueID>0x12<\/UniqueID> fs"]},{"entry":[{},"\u2003\u2003\u2003<HWND>0x170a64<\/HWND>"]},{"entry":[{},"\u2003\u2003\u2003<Location x=\u201c117\u201d y=\u201c70\u201d width=\u201c784\u201d height=\u201c638\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003<Class>WindowsForms10.Window.8.app4<\/Class>"]},{"entry":[{},"\u2003\u2003\u2003<Style>0x16cf0000<\/Style>"]},{"entry":[{},"\u2003\u2003\u2003<ExStyle>0xc0050900<\/ExStyle>"]},{"entry":[{},"L18 + <GUIElement Alias=\u201cSaveFile\u201d>"]},{"entry":[{},"L19 + <GUIElement Alias=\u201cExit\u201d>"]},{"entry":[{},"L20 + <GUIElement Alias=\u201cSaveChange\u201d>"]},{"entry":[{},"L21 + <GUIElement Alias=\u201cFileOpen\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cLocation\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cAcademicEmph\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cQolScale\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSocialScale\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cAcadScale\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cEnrolledPerc\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cAdmittancePerc\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cNumApps\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cFinancialAid\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cExpense\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSATMath\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSATVerbal\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSFRatio\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cMFRatio\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cNumStudents\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cControl\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cState\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSchool\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cLocation\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cAcademic Emphasis\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cQuality of Life Scale (1-5)\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSocial Scale (1-5)\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cAcademics Scale (1-5)\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cEnrolled %\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cAdmittance %\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201c# Applicants (1000)\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cFinancial Aid %\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cExpenses (1000$)\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSAT:math\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cStudent\/Faculty Ratio\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSAT:verbal\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cMale\/Female Ratio\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cNumber of Students (1000)\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cControl\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cState\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSelectSchoolBtn\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSchool List\u201d>"]},{"entry":[{},"L59 + <GUIElement Alias=\u201cSchoolListbox\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cSelectStateBtn\u201d>"]},{"entry":[{},"\u2003\u2003+ <GUIElement Alias=\u201cState List\u201d>"]},{"entry":[{},"L62 + <GUIElement Alias=\u201cStateListbox\u201d>"]},{"entry":[{},"\u2003\u2003<\/GUIElement>"]},{"entry":[{},"\u2003<\/GUIElement>"]},{"entry":[{},"<\/State>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The StateListBox GUI element shown in Table 6 at line  corresponds to the State listbox  shown in .  shows a horizontal navigation bar  as a feature of the State listbox . Table 7 shows some of the attributes of State listbox  that may be reflected in the GUI difference model  as a result of a comparison between the current GAP tree model and the subsequent GAP tree model shown in Table 8.",{"@attributes":{"id":"p-0279","num":"0283"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Current GAP StateListbox GUI element schema"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2212 <GUIElement Alias=\u201cStateListbox\u201d>"]},{"entry":[{},"\u2003<UniqueID>0x407<\/UniqueID>"]},{"entry":[{},"\u2003<HWND>0x90b58<\/HWND>"]},{"entry":[{},"\u2003<Location x=\u201c173\u201d y=\u201c86\u201d width=\u201c368\u201d height=\u201c274\u201d \/>"]},{"entry":[{},"\u2003<Class>WindowsForms10.LISTBOX.app4<\/Class>"]},{"entry":[{},"\u2003<Style>0x56110ac1<\/Style>"]},{"entry":[{},"\u2002<ExStyle>0xc0000a00<\/ExStyle>"]},{"entry":[{},"\u2009\u2212 <GUIElement Alias=\u201cStateListbox\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<UniqueID>0x410<\/UniqueID>"]},{"entry":[{},"\u2003\u2003\u2003<HWND>0x90b58<\/HWND>"]},{"entry":[{},"\u2003\u2003<Location x=\u201c175\u201d y=\u201c88\u201d width=\u201c364\u201d height=\u201c253\u201d \/>"]},{"entry":[{},"\u2003\u2003<Class>WindowsForms10.LISTBOX.app4<\/Class>"]},{"entry":[{},"\u2003\u2003<Style>0x56110ac1<\/Style>"]},{"entry":[{},"\u2003\u2003<ExStyle>0xc0000a00<\/ExStyle>"]},{"entry":[{},"\u2003\u2212 <Values>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c0\u201d>Alabama<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c1\u201d>Alaska<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c2\u201d>Arizona<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c3\u201d>Arkansas<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c4\u201d>California<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c5\u201d>Colorado<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c6\u201d>Connecticut<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c7\u201d>Delaware<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c8\u201d>District of Columbia<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c9\u201d>Florida<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c10\u201d>Georgia<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c11\u201d>Hawaii<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c12\u201d>Idaho<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c13\u201d>Illinois<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c14\u201d>Indiana<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c15\u201d>Iowa<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c16\u201d>Kansas<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c17\u201d>Kentucky<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c18\u201d>Louisiana<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c19\u201d>Maine<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c20\u201d>Maryland<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c21\u201d>Massachusetts<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c22\u201d>Michigan<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c23\u201d>Minnesota<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c24\u201d>Mississippi<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c25\u201d>Missouri<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c26\u201d>Montana<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c27\u201d>Nebraska<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c28\u201d>Nevada<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c29\u201d>New Hampshire<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c30\u201d>New Jersey<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c31\u201d>New Mexico<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c32\u201d>New York<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c33\u201d>North Carolina<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c34\u201d>North Dakota<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c35\u201d>Ohio<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c36\u201d>Oklahoma<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c37\u201d>Oregon<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c38\u201d>Pennsylvania<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c39\u201d>Rhode Island<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c40\u201d>South Carolina<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c41\u201d>South Dakota<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c42\u201d>Tennessee<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c43\u201d>Texas<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c44\u201d>Utah<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c45\u201d>Vermont<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c46\u201d>Virginia<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c47\u201d>Washington<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c48\u201d>West Virginia<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c49\u201d>Wisconsin<\/Value>"]},{"entry":[{},"\u2003\u2003\u2003<Value SeqNumber=\u201c50\u201d>Wyoming<\/Value>"]},{"entry":[{},"\u2003\u2003<\/Values>"]},{"entry":[{},"\u2003<\/GUIElement>"]},{"entry":[{},"\u2002+ <GUIElement Alias=\u201cHorizontal\u201d>"]},{"entry":[{},"<\/GUIElement>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0280","num":"0284"},"figref":["FIG. 34","FIG. 34","FIG. 34"],"b":["152","152","3402","11","11","23","24","3404","3406","162"]},{"@attributes":{"id":"p-0281","num":"0285"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Subsequent GAP tree model"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2212 <State SeqNumber=\u201c0\u201d Name=\u201cState_0_3068\u201d"},{"entry":"Alias=\u201cUniversity Directory1\u201d ProcessId=\u201c3068\u201d>"},{"entry":"\u2003\u2212 <GUIElement Alias=\u201cSchool\u201d>"},{"entry":"\u2003\u2003\u2003<UniqueID>0x0<\/UniqueID>"},{"entry":"\u2003\u2003\u2003<HWND>0x80b8<\/HWND>"},{"entry":"\u2003\u2003<Location x=\u201c116\u201d y=\u201c88\u201d width=\u201c915\u201d height=\u201c594\u201d \/>"},{"entry":"\u2003\u2003\u2003<Class>WindowsForms10.Window.8.app.0.378734a<\/Class>"},{"entry":"\u2003\u2003\u2003<Style>0x16cf0000<\/Style>"},{"entry":"\u2003\u2003\u2003<ExStyle>0xc0050900<\/ExStyle>"},{"entry":"\u2003\u2003+ <GUIElement Alias=\u201cSystem\u201d>"},{"entry":"\u2003\u2003+ <GUIElement Alias=\u201cNAMELESS\u201d>"},{"entry":"L11 \u2212 <GUIElement Alias=\u201cSchool\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<UniqueID>0x12<\/UniqueID>"},{"entry":"\u2003\u2003\u2003\u2003<HWND>0x80b8<\/HWND>"},{"entry":"\u2003\u2003\u2003\u2003<Location x=\u201c146\u201d y=\u201c92\u201d width=\u201c907\u201d height=\u201c560\u201d \/>"},{"entry":"\u2003\u2003\u2003\u2003<Class>WindowsForms10.Window.8.app.0.378734a<\/Class>"},{"entry":"\u2003\u2003\u2003\u2003<Style>0x16cf0000<\/Style>"},{"entry":"\u2003\u2003\u2003\u2003<ExStyle>0xc0050900<\/ExStyle>"},{"entry":"L18 + <GUIElement Alias=\u201cmenuStrip1\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cStates List\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSchool List\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSelectStateIButton\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSelectSchoolButton\u201d>"},{"entry":"L23 + <GUIElement Alias=\u201cStateListbox\u201d>"},{"entry":"L24 + <GUIElement Alias=\u201cSchoolCombobox\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSchool\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cstate\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cState\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201clocation\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cLocation\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201ccontrol\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cControl\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cNumber of Students (1000)\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cNumStudents\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cMale\/Female Ratio\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cGenderRatio\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cStudent\/Faculty Ratio\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSFRatio\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSAT Verbal\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSATVerbal\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSAT Math\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSATMath\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cNumber of Applicants\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cNumApps\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cPercent of Admittance\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cPercAdmit\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cPercent Enrolled\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cPercent Enrolled\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cAcademics (1-5)\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cAcademics\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSocial (1-5)\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cSocial\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cQuality of Life (1-5)\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cQoLife\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cAcademic Emphasis\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cAcadEmphasis\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cExpenses\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cExpense\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cFinancial Aid\u201d>"},{"entry":"\u2003\u2003\u2003\u2003+ <GUIElement Alias=\u201cFinancialAid\u201d>"},{"entry":"\u2003\u2003\u2003<\/GUIElement>"},{"entry":"\u2003\u2003<\/GUIElement>"},{"entry":"\u2003<\/State>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The subsequent GAP menuStrip GUI element schema shown in Table 8 at line  corresponds to the WinObject GUI object \u2018menu strip\u2019  shown in . The subsequent GAP menuStrip GUI element schema shown in Table 9 illustrates the full entry at line  in Table 8 and indicates that the menu strip  includes a nested GUI element File menu that includes nest GUI elements OpenFile, SaveFile, SaveAs, and Exit, shown at lines  of Table 9, and -, respectively.",{"@attributes":{"id":"p-0283","num":"0287"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Subsequent GAP menuStrip1 GUI element schema"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2212 <GUIElement Alias=\u201cmenuStrip1\u201d>"]},{"entry":[{},"\u2002<UniqueID>0x13<\/UniqueID>"]},{"entry":[{},"\u2003<HWND>0xa0e62<\/HWND>"]},{"entry":[{},"\u2003<Location x=\u201c146\u201d y=\u201c92\u201d width=\u201c907\u201d height=\u201c24\u201d \/>"]},{"entry":[{},"\u2003<Class>WindowsForms10.Window.8.app.0.378734a<\/Class>"]},{"entry":[{},"\u2003<Style>0x56000000<\/Style>"]},{"entry":[{},"\u2003<ExStyle>0xc0010800<\/ExStyle>"]},{"entry":[{},"\u2003\u2212 <GUIElement Alias=\u201cmenuStrip1\u201d>"]},{"entry":[{},"\u2003\u2003<UniqueID>0x1c<\/UniqueID>"]},{"entry":[{},"\u2003\u2003<HWND>0xa0e62<\/HWND>"]},{"entry":[{},"\u2003\u2003<Location x=\u201c146\u201d y=\u201c92\u201d width=\u201c907\u201d height=\u201c24\u201d \/>"]},{"entry":[{},"\u2003\u2003<Class>WindowsForms10.Window.8.app.0.378734a<\/Class>"]},{"entry":[{},"\u2003\u2003<Style>0x56000000<\/Style>"]},{"entry":[{},"\u2003\u2003<ExStyle>0xc0010800<\/ExStyle>"]},{"entry":[{},"L15 \u2212 <GUIElement Alias=\u201cFileMenu\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<UniqueID>0x1d<\/UniqueID>"]},{"entry":[{},"\u2003\u2003\u2003<HWND>0xa0e62<\/HWND>"]},{"entry":[{},"\u2003\u2003\u2003<Location x=\u201c148\u201d y=\u201c98\u201d width=\u201c35\u201d height=\u201c20\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003<Class>WindowsForms10.Window.8.app.0.378734a<\/Class>"]},{"entry":[{},"\u2003\u2003\u2003<Style>0x56000000<\/Style>"]},{"entry":[{},"\u2003\u2003\u2003<ExStyle>0xc0010800<\/ExStyle>"]},{"entry":[{},"L22 \u2003+ <GUIElement Alias=\u201cOpenFile\u201d>"]},{"entry":[{},"L23 \u2003+ <GUIElement Alias=\u201cSaveFile\u201d>"]},{"entry":[{},"L24 \u2003+ <GUIElement Alias=\u201cSaveAsFile\u201d>"]},{"entry":[{},"L25 \u2003+ <GUIElement Alias=\u201cExit\u201d>"]},{"entry":[{},"\u2003\u2003<\/GUIElement>"]},{"entry":[{},"\u2003<\/GUIElement>"]},{"entry":[{},"<\/GUIElement>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0284","num":"0288"},"figref":"FIG. 35","b":["3500","3500"]},"For example, referring to , differences between the current GAP version  and subsequent GAP version  include that the window StateList , listbox State , field Academic Emphasis , and field Quality of Life Scale (-)  in the current GAP version  are respectively represented by window School , listbox State , field Academic Emphasis , and field Quality of Life (-)  in the subsequent GAP version . In another example, consider the Save File , Close Form , Save Change  and Open File  GUI objects implemented in the current GAP version  that have been implemented in the subsequent GAP version  as child GUI objects of the File , which is a child GUI object of the menu strip  GUI object.","It can be challenging to locate differences between GUI elements of GAPs. For example, it is not readily evident that the listbox School  and the combobox School  are meant to have the same or similar functionality between successive GAP versions. As another example, the WinObject \u201cSelect School\u201d  in the current GAP version  has been removed at location  from the subsequent GAP version . The GUI difference model  include GUI element difference entries that list characteristics of GUI elements, for those GUI elements that match between the current GAP version and the subsequent GAP version, but that differ in character between the current GAP version and the subsequent GAP version. The GUI element difference entries will guide the script analysis as described in more detail below.",{"@attributes":{"id":"p-0287","num":"0291"},"figref":["FIG. 36","FIG. 36"],"b":["3604","162","162","162"]},"In one implementation, the GUI difference model  omits a GUI element difference entry for GUI objects that have been deleted between successive GAP versions. Each GUI element difference entry representing a GUI object that has been modified or added between successive GAP versions includes a tag \u2018Version\u2019 that has a value of, as examples, either 0 or 1. In other words, a GUI element difference entry that does not include a Version tag indicates that the GUI object has not been modified between successive GAP versions. The Version values of 0 and 1 indicate whether the children elements of the Version represent the properties of the GUI object in the current GAP version  or the subsequent GAP version , respectively. For example, the GUI difference entry  shown in  indicates at line  that the listbox StateListbox value for SeqNumber=\u201c8\u201d implemented in the current GAP version  is \u201cDistrict of Columbia\u201d, while the value in the subsequent GAP version  is \u201cFlorida\u201d as indicated at line . In one implementation, the GUI difference entry  includes a ParentChildIdentifier element at line  that identifies the relationship between two GUI objects in a given GAP version, so that GUI class and inheritance constraints can be validated (discussed in detail further below).","Referring briefly to , the GUI difference entry  indicates at line  that the window StateList in the current GAP version  corresponds to the window School in the subsequent GAP version  indicated at line  by the Version value equal to 0 and 1, respectively. The StateList and School GUI objects are of the WindowsForm10.Window.8 class, as shown at lines  and . The sub-class identifier for the StateList and School GUI object distinguish the GUI objects (e.g., app4 and app.0.0378734a, respectively). The GUI difference entry  indicates that the Location element of the StateList and School windows are different, as shown at lines  and , respectively. However, the GUI difference entry  also indicates that the Style and ExStyle elements are identical, as shown at lines - and -, respectively.","Referring briefly to , the GUI difference entry  indicates at line  that the listbox SchoolListbox in the current GAP version  corresponds to the combobox SchoolCombobox in the subsequent GAP version  indicated at line . The GUI difference entry  indicates that the Location element of the SchoolListbox and SchoolCombobox are different, as shown at lines  and , respectively. The GUI difference entry  also indicates that the Class, Style and ExStyle elements are different, as shown at lines - and -, respectively. In particular, one or more of the properties of a WindowsForms10.LISTBOX and a WindowsForms10.COMBOBOX are different, incompatible with the properties of the other class, and child GUI elements of GUI objects of these two classes may have one or more incompatible properties.",{"@attributes":{"id":"p-0291","num":"0295"},"figref":"FIG. 37","b":["164","164","1","6","1","164","164","2","3","164","4","7","164","8","10","11","14"]},{"@attributes":{"id":"p-0292","num":"0296"},"figref":"FIG. 38","b":["3800","166","164","108","168","3800","164","164","3800","166","3800"]},{"@attributes":{"id":"p-0293","num":"0297"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Script Parser Grammar"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"navstmt ::= func(arg) | navstmt . Navstmt | navstmt action arg"]},{"entry":[{},"fullnavstmt ::= var = navstmt | navstmt action arg"]},{"entry":[{},"arg ::= expr | \u201c,\u201d arg |"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The script parser  represents the test script statement vectors as an ordered sequence of nodes that contain function names and the arguments of those functions that navigate to GUI objects. The nodes of a test script statement vector include a source node and a destination. For example, the script parser  may represent the test script statement vector corresponding to line  of the current test script  as source node StateList  and a destination node \u2018Open File\u2019 . The nodes of a test script statement vector may also include intermediate nodes positioned between a source node and a destination node. For example, the script parser  may represent the test script statement vector corresponding to line  of the current test script  as source node StateList , intermediate node \u2018Save a Data Record\u2019  and destination node \u2018File name\u2019 . In one implementation, the script analyzer  uses the test script statement vectors to analyze plausible navigation paths to GUI objects identified in the GUI difference model  by GUI element difference entries, described in further detail below. The script analyzer  may use the test script statement vectors to also analyze plausible GUI objects identified in the object repository , also discussed in further detail below.","The script parser  evaluates arguments of navigation and action functions as expressions, variables and constants. The arguments express the physical properties of GUI objects to which the test script statement vectors navigate and values used to perform actions on those GUI objects. For example, the \u201886,12\u2019 coordinates  identify the location for a pointing device to perform an action \u2018Click\u2019  on the \u2018Open File\u2019  GUI object, which is a child GUI Object of the window StateList . The script analyzer  uses the names of the GUI objects (e.g., StateList  and \u2018Open File\u2019 ) navigated to by the test script statement vectors to locate the corresponding physical properties of the GUI objects stored in an Object Repository (OR) .","In one implementation, the script analyzer  uses the OR Lookup logic  to return from the object repository  the physical properties of the GUI objects navigated to by a test script statement vector. In one implementation, the OR Lookup logic  is divided into two sub-functions: 1) lookup logic adapted to locate and retrieve the physical properties of the GUI objects navigated to by the test script statement vector (e.g., -, --, and -); and 2) locator logic that finds and returns a GUI element difference entry (node) in the GUI difference model  that corresponds to the GUI object with the given physical properties. The OR Lookup logic  may include path traversal logic, discussed in further detail below, to identify possible navigation paths of the test script statement vector between a source node GUI object and destination node GUI object to which a test script statement vector navigates.","Table 11 illustrates one implementation of an object repository , in the form of an XML schema. The object repository  includes a GUI object entry for each GUI Object of the current GAP version  identified in the current test script . The object repository  may be generated by a script writing tool, such as Quick Test Pro (QTP), Rational Robot, and Compuware Test Partner. The script analyzer  may query the object repository  to identify the physical properties of the GUI objects navigated to by the test script statement vectors represented by the current test script representation . Physical properties of a GUI object may indicate whether the GUI object is hidden, read-only, a number and default values, as shown in Table 12.","For example, the script analyzer  analyzes the GUI objects - in the test script statement vector. The \u201819,22\u2019 coordinate  identifies the location for a pointing device to perform an action \u2018Click\u2019  on the GUI object SchooListbox , which is a child GUI Object of the window StateList . The script analyzer  invokes the OR Lookup logic  to locate the physical properties of the GUI objects  and . The OR Lookup logic  locates the physical properties of the window StateList  and the WinObject SchoolListbox , as shown in Table 11 at lines  and . The script analyzer  uses the physical properties retrieved from the object repository  to locate corresponding GUI difference entries (e.g.,  and ) in the GUI difference model . The GUI difference entries  and  indicate that the window StateList  and the WinObject SchoolListbox  in the current GAP version  correspond to the window School  and the WinObject SchoolCombobox  in the subsequent GAP version , respectively. In one implementation, the script analyzer  employs the OR Lookup logic  to traverse the GUI difference model  using the physical properties of the GUI objects navigated to by the test script statement vector. The OR Lookup  function returns a GUI element difference entry (e.g., ,  and ) from the GUI difference model  that represents the GUI object navigated to by the test script statement vector (e.g., ---, ----, and ---).",{"@attributes":{"id":"p-0299","num":"0303"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Object Repository"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2212 <XYZRep:ObjectRepository"},{"entry":"\u2003\u2003\u2003\u2003xmlns:XYZRep="},{"entry":"\u2003\u2003\u2003\u2003\u201chttp:\/\/www.vendorXYZ.com\/XYZ\/ObjectRepository\u201d>"},{"entry":"\u2212 <XYZRep:Objects>"},{"entry":"L3 \u2212 <XYZRep:Object Class=\u201cWindow\u201d Name=\u201cStateList\u201d>"},{"entry":"+ <XYZRep:Properties>"},{"entry":"+ <XYZRep:BasicIdentification>"},{"entry":"+ <XYZRep:CustomReplay>"},{"entry":"L7 \u2212 <XYZRep:ChildObjects>"},{"entry":"\u2003\u2003+ <XYZRep:Object Class=\u201cWinObject\u201d Name=\u201cOpen File\u201d>"},{"entry":"\u2003\u2003+ <XYZRep:Object Class=\u201cWinObject\u201d Name=\u201cStateListbox\u201d>"},{"entry":"\u2003\u2003+ <XYZRep:Object Class=\u201cWinObject\u201d Name=\u201cSelect State\u201d>"},{"entry":"\u2003\u2003+ <XYZRep:Object Class=\u201cWinObject\u201d Name=\u201cSelect School\u201d>"},{"entry":"\u2003\u2003+ <XYZRep:Object Class=\u201cWinObject\u201d Name=\u201cSchoolListbox\u201d>"},{"entry":"\u2003<\/XYZRep:ChildObjects>"},{"entry":"\u2002<\/XYZRep:Object>"},{"entry":"\u2002<\/XYZRep:Objects>"},{"entry":"\u2002<XYZRep:Parameters \/>"},{"entry":"\u2002<XYZRep:Metadata \/>"},{"entry":"\u2002<\/XYZRep:ObjectRepository>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Table 12 illustrates the physical properties that may be located in the object repository for the GUI object entry corresponding to the SchoolListbox .",{"@attributes":{"id":"p-0301","num":"0305"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GUI object entry WinObject (\u201cSchoolListbox\u201d)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2212 <XYZRep:Object Class=\u201cWinObject\u201d Name=\u201cSchoolListbox\u201d>"},{"entry":"L2 \u2212 <XYZRep:Properties>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cy\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cNUMBER\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>86<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cx\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cNUMBER\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>420<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cwindowstyle\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cNUMBER\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>1442906305<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cwindowextendedstyle\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cNUMBER\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>512<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cwindow id\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cNUMBER\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>1182924<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cwidth\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cNUMBER\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>336<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cvisible\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cBOOL\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>\u22121<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cregexpwndclass\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cSTRING\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>WindowsForms10.LISTBOX.app4<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cobject class\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cSTRING\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>WindowsForms10.LISTBOX.app4<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cnativeclass\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cSTRING\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>WindowsForms10.LISTBOX.app4<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cheight\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cNUMBER\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>260<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"\u2003\u2212 <XYZRep:Property Name=\u201cenabled\u201d Hidden=\u201c0\u201d ReadOnly=\u201c0\u201d Type=\u201cBOOL\u201d>"},{"entry":"\u2003\u2003<XYZRep:Value RegularExpression=\u201c0\u201d>\u22121<\/XYZRep:Value>"},{"entry":"\u2003\u2003<\/XYZRep:Property>"},{"entry":"L39 <\/XYZRep:Properties>"},{"entry":"\u2003\u2212 <XYZRep:BasicIdentification>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>y<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>x<\/XYZRep:PropertyRef>"},{"entry":"\u2002\u2003<XYZRep:PropertyRef>windowstyle<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>windowextendedstyle<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>width<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2002<XYZRep:PropertyRef>visible<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>regexpwndclass<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>object class<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>nativeclass<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2002<XYZRep:PropertyRef>height<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<XYZRep:PropertyRef>enabled<\/XYZRep:PropertyRef>"},{"entry":"\u2003\u2003<\/XYZRep:BasicIdentification>"},{"entry":"\u2003\u2212 <XYZRep:CustomReplay>"},{"entry":"\u2003\u2003<XYZRep:Behavior Name=\u201csimclass\u201d"},{"entry":"\u2003\u2003\u2003\u2003Type=\u201cSTRING\u201d>WindowsForms10.LISTBOX.app4<\/XYZRep:Behavior>"},{"entry":"\u2003\u2003<\/XYZRep:CustomReplay>"},{"entry":"\u2003\u2212 <XYZRep:Comments>"},{"entry":"\u2003\u2003<XYZRep:Comment Name=\u201cmiccommentproperty\u201d \/>"},{"entry":"\u2003\u2003<\/XYZRep:Comments>"},{"entry":"\u2003\u2002<XYZRep:ChildObjects \/>"},{"entry":"\u2003\u2002<\/XYZRep:Object>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0302","num":"0306"},"figref":"FIG. 39","b":["3900","170","3900","3902","3904","190","190","138","160","140","162","190","3906","3902","140","3908","162","3910","3902","3912","164","168","168","3914","3916","3802","3804","3810","3812","3802","3806","3808","3820","3822","3802","3814","3826","3818"]},"The memory  further includes script analysis logic  that receives the GUI difference model , and the current test script representation  for the current test script , including a test script statement vector . In one implementation, the script analysis logic  invokes the OR Lookup logic  to locate, in the object repository , a GUI object entry  matching the test script statement vector . In one implementation, the script analyzer  invokes the OR Lookup logic  to locate, in various external sources, a GUI object entry  matching the test script statement vector . When the test script statement vector  (e.g., ---, ----, and ---) employs constants to identify GUI object names, rather than expressions whose values can only be determined at runtime, the OR Lookup  function may use the GUI object name and properties of the GUI object to efficiently locate the correct GUI object entry  and locate, in the GUI difference model , a GUI element difference entry  matching the GUI object entry .","For example, the test script statement vector represented by --- identifies the window GUI object StateList  and the listbox GUI object SchoolListbox , shown in the current test script  navigation statement shown at line  of :","Window(\u201cStateList\u201d).WinObject(\u201cSchoolListbox\u201d).Click ,.","The OR Lookup  function locates the GUI object entry  for each GUI object  and , using the known names of the GUI objects, StateList and SchoolListbox, respectively. The OR Lookup  function locates the corresponding GUI element difference entries  and , in the GUI difference model . The script analysis logic  outputs a transformed test script statement  that corresponds to  and :","Window(\u201cSchool\u201d).WinObject(\u201cSchoolCombobox\u201d).Click ,.","The GUI class rule logic  may use the GUI object names to locate the properties used to validate that the transformed test script statement  does not violate GUI element script change rules  and constraints. In one implementation, the script analyzer  uses the GUI class rules logic  in conjunction with the constraint satisfaction engine  to determine violations of GUI element script change rules  and constraints.","For example, when the transformed test script statement  accesses GUI objects that do not exist in the subsequent GAP version , and\/or the transformed test script statement  attempts to set a value of a GUI object that is not compatible with the GUI class of that GUI object, then the transformed test script statement  violates constraints imposed on the GUI object. The constraint satisfaction engine  validates the transformed test script statement  to help verify that incorrect operations will be identified in the transformed test script statement  for a programmer to resolve. In one implementation, the constraint satisfaction engine  receives a compatibility inquiry message (e.g., from an external system such as the GUI element metadata repository ) that specifies two GUI element types. The CSE  analyzes the two types and returns a compatibility verification message that indicates whether the two types are compatible. In the event the GUI object change violates a constraint satisfaction rule  then the compatibility verification message provides detailed information regarding the violation.","The constraint satisfaction engine  and the GUI class rules logic  may infer GUI class information regarding GUI objects that are present in a navigation path of test script statement vectors  and transformed test script statements , and whose presence is not explicitly defined. In one implementation, the constraint satisfaction engine  and\/or GUI class rules logic  use a combination of compile time type validation and GUI class inference validation, in order to validate the correctness of test script statement vectors  and transformed test script statements . For example, when the test script statement vector  employs expressions that identify GUI objects whose values can only be determined at runtime, the OR Lookup  function may use path traversal logic  to identify the possible corresponding GUI object entries  and GUI element difference entries  in the object repository  and GUI difference model , respectively. The GUI class rules logic  and constraint satisfaction engine  then identify the valid GUI object entries  that may substitute for the expressions and GUI element difference entries  that satisfy valid test script statement vectors  and transformed test script statements . Similarly, when the transformed test script statement  employs expressions that identify GUI objects whose values can only be determined at runtime, the OR Lookup  function uses path traversal logic  to identify all possible corresponding GUI element difference entries  that identify GUI objects that may substitute for the expressions, and the GUI class rules logic  and constraint satisfaction engine  validate each GUI object substitution for the expressions used to form the transformed test script statement .","For example, consider the transformed test script statement : VBWindow(\u201cs\u201d).VBWindow(e1).VBWindow(e2).VBWindow(\u201cd\u201d), where the source node GUI object is named \u201cs\u201d, the destination node GUI object is named \u201cd\u201d, but expressions e1 and e2 compute values of intermediate nodes in the navigation path at runtime. The traversal logic  determines intermediate nodes (GUI objects) that may be included in the possible navigation paths identified by the source node \u201cs\u201d and destination node \u201cd\u201d. The path traversal logic  analyzes the GUI difference model  to identify possible constant substitutions for e1 and e2, for example, \u201ca\u201d and \u201cf\u201d, so that the transformed test script statement  formed by the substitute GUI objects in the navigation path expression \u201cs.a.f.d\u201d can be validated by the GUI class rules logic  and\/or constraint satisfaction engine . By identifying the possible navigation paths leading to the destination node d starting with the source node s the GUI class rules logic  and constraint satisfaction engine  can conclude whether the transformed test script statement  is valid. In the event the traversal logic  does not identify at least one navigation path, then the transformed test script statement  is invalid. Alternatively, in the event the traversal logic  identifies navigation paths leading from s to d by traversing two objects (e.g., e1 and e2), then the transformed test script statement  may be valid provided that expressions e1 and e2 evaluate to the names of the nodes in the discovered navigation paths. The traversal logic  infers the possible names computed by expressions e1 and e2 at compile time.","A formal description of the traversal logic  is provided with reference to . Expressions e1 and e2 may be replaced with the object name variables \u03b1 and \u03b2 correspondingly, and the original expression is converted into traversal strategy S=s\u2192\u03b1\u2192\u03b2\u2192d. The function \u2018first(s)\u2019 computes a set of edges that can be traversed from node s. These edges lead to a set of objects designated by the variable \u03b1. Function \u2018first(s)\u2019 may be computed using a graph reachability algorithm, included in the path traversal logic , and the path traversal logic  returns edges that may navigate to the destination node. According to , \u03b1={a, b, c}. Then for each element of \u03b1, function \u2018first\u2019 may be computed. As a result, \u03b2={e, f, g} are obtained, where \u2018first(a)\u2019={e, g}, \u2018first(b)\u2019={e}, and \u2018first(c)\u2019={f}, and \u2018first(e)\u2019={\u00d8}, \u2018first(f)\u2019={d}, and \u2018first(g)\u2019={d}. From the computed node values the path traversal logic  forms a work-list W that includes a set of all computed paths, W={(s, a, e), (s, a, g, d), (s, b, e), (s, c, f, d)}. The path traversal logic  analyzes each navigation path of W to determine whether the navigation path contains nodes s and d. Navigation paths identified by the path traversal logic  to include nodes s and d, as source and destination nodes, are considered as valid navigation paths. In the event no navigation paths are identified by the traversal logic , then the transformed test script statement  is invalid because the target GUI element cannot be reached starting from the specified beginning GUI element. The traversal logic  similarly validates test script statement vectors .","Referring again to , an example of an invalid expression is VBWindow(\u201cs\u201d).VBWindow(e1). VBWindow(e2).VBWindow(e3).VBWindow(\u201cd\u201d). All navigation paths between nodes s and d have at most two objects. Therefore, no matter what values are computed at runtime for expressions e1, e2, and e3 the expressions cannot represent objects in a valid navigation path between the source and the destination objects. Another example of an invalid expression is VBWindow(\u201cs\u201d).VBWindow(\u201cb\u201d).VBWindow(e1).VBWindow(\u201cd\u201d), because no value for the expression e1 exists that makes the navigation path valid (i.e. that forms a complete path from \u2018s\u2019 to \u2018d\u2019).","The constraint satisfaction engine  and the GUI class rules logic  may infer GUI class information regarding GUI objects that are present in the navigation path of test script statement vectors  and transformed test script statements . One feature of the SAA  is to maintain the compatibility of operations on GUI objects between successive test scripts. When a transformed test script statement  attempts to access GUI objects that do not exist in a subsequent GAP version  and\/or attempts to set a value of a GUI object that is not compatible with the type of the GUI object, the transformed test script statement  violates GUI element script change rules entries  and\/or constraints satisfaction rules  imposed on the GUI object. The constraint satisfaction engine  and the GUI class rules logic  type check each potential transformed test script statement  before including the vector in the transformed test script , so that invalid operations may be identified and corresponding change guide messages  may be output.","The constraint satisfaction engine  and the GUI class rules logic  use inheritance and sub-typing relations between classes of GUI objects. The concept of class includes hierarchical containments (e.g., GUI scopes and system hierarchies). The object repository  and the GUI difference model  include GUI class information (e.g., annotating the classes of GUI objects) for each GUI object entry  and GUI element difference entry . For example, referring to line  of Table 12, the SchoolListBox is a WinObject class with properties listed at lines -. In another example, referring to ,  and , at line  of each GUI difference entry (e.g., ,  and ) the GUIElement Type is indicated. The class of each GUI object is indicated as shown in ,  and  at lines ,  and , respectively. The class of a GUI object indicates that the GUI object includes particular attributes, properties and\/or traits in common with other GUI objects of the same class that may be extended to and\/or inherited by child GUI objects. For example,  at line  indicates that the StateListbox GUI object is of a WindowsForms10.ListBox.app4 class that includes values, as indicated at line  of . In other words, one property of GUI objects of WindowsForms10.ListBox.app4 is that these GUI objects are expected to have values. Class is a concept that a GUI framework uses to classify GUI objects. For example, class ListBox defines shape, functionality, and the rules of interactivity for GUI objects of this class. Assigning classes to GUI objects facilitates the constraint satisfaction engine  and the GUI class rules logic  to trace changes between successive GAP versions (e.g.,  and ) and perform extended checking on the correctness of operations on GUI objects.","Referring again to , in one implementation, the GUI class rules logic  and constraint satisfaction engine  determine whether a GUI object has changed and sets the GUI element change status . For example, the GUI element change status  may use a numerical indicator of 0, 1, and 2, respectively, to indicate that a GUI object was not changed, changed with, and changed without violations of GUI element script change rules  and\/or constraint satisfaction rules . The script analysis logic  may use the GUI element change status , GUI element script change rule entries  and constraint satisfaction rules  to search the change guide message repository  and identify the appropriate change specifier  and change guide message identifiers . The GUI element script change rules  may indicate whether an element of a GUI object can be changed in a particular way. For example, the GUI element script change rules  may indicate that an element of a particular GUI object cannot be changed from a read-only to editable. In another example, a change to the class of a GUI object may result in a child GUI object violating a GUI element script change rule , because one or more attributes of the child GUI object conflict with class change of the parent GUI element. In addition, a button may be replaced with a menu items, and actions that are correct for accessing and manipulating buttons will not work for menus.","In another implementation, the GUI element change status  is a message that provides a detail description of the change. The GUI element change status  may also indicate with a numerical indicator (e.g., \u22121) that the GUI object has been deleted from the subsequent GAP version . When a GUI object has been deleted from the subsequent GAP version  and a transformed test script statement  includes a reference to the GUI object, the script analysis logic  outputs a change guide message  that indicates that the GUI object has been deleted.","In one implementation, the script analysis logic  outputs a change specifier  that includes a transformed test script statement  that violates a GUI element script change rule  and\/or constraint satisfaction rule , so that a programmer may evaluate whether to modify the transformed test script statement  and\/or the subsequent GAP version  to obtain a desired result and\/or meet a desired requirement that otherwise may not have been apparent. In another implementation, the script analysis logic  prohibits the output of transformed test script statements  that violate certain GUI element script change rules  and constraint satisfaction rules . Each of the GUI element script change rules  and constraint satisfaction rules  may include indicators that indicate the level or severity of violation and whether the script analysis logic  may output a transformed test script statement , even though a violation has occurred. Regardless of whether the script analysis logic  outputs a transformed test script statement , the script analysis logic  may output a change guide  that includes change guide messages  corresponding to each of the violations.","For each corresponding GUI element change status  that indicates a change in violation of GUI element script change rules  and\/or constraint satisfaction rules , the script analysis logic  outputs a set of change guide message identifiers  and corresponding change guide messages . The change guide messages  may include wrong-path delete type (WP-1) , wrong-path same (WP-2) type  and changed element (CE-1 and CE-2) type . The change guide  and the change guide messages , including ,  and , are described in further detail below.",{"@attributes":{"id":"p-0320","num":"0324"},"figref":"FIG. 40","b":["900","3922","174","3912","3916","4002","3912","4004","4006","3912","4008","4010","3912"]},"The script parser logic  identifies the last node in the ordered sequence as the destination node and assigns a sequence identifier to the destination node that indicates the position of the destination node in the ordered sequence (). The OR Lookup  performs an object repository lookup for each GUI object corresponding to the ordered sequence of nodes to which the test script statement vector navigates so that each GUI object entry  is identified (). In one implementation, the ordered sequence of nodes is used by the path traversal logic , GUI class rules logic  and\/or constraint satisfaction engine  to validate the statements of the current test script . In one implementation, the script analyzer  uses the ordered sequence of nodes to infer GUI class and inheritance (subclass) information for GUI objects. Where at least one of the source, destination and\/or the intermediate nodes are expressions that can only be identified at run-time, the path traversal logic may identify possible GUI object entries , and the GUI class rules logic  and\/or constraint satisfaction engine  determine the GUI object entries  that satisfy the test script statement vector  without violating the GUI class rules logic  and the constraint satisfaction rules . The OR Lookup  retrieves the properties of the GUI object entries  to which the test script statement vector navigates ().",{"@attributes":{"id":"p-0322","num":"0326"},"figref":"FIG. 41","b":["4100","3910","3922","172","3916","172","3924","3910","4102","3910","3924","3910","4104","3924","3910","3910","4106","3928","188","3910","3928","4108","3932","4110"]},"The GUI class rules logic  and\/or constraint satisfaction engine  indicate the GUI element difference entries  that correspond to each of the GUI object entries  forming a valid navigation path (). The script analysis logic  determines the output change specifier based on the type of GUI element change (e.g., GUI element change status ) indicated by the GUI class rules logic  and constraint satisfaction engine  results, based on the GUI element difference entry  ().","When the path traversal logic  identifies a navigation path that traverses an invalid number of GUI element difference entries  between corresponding source and destination node GUI difference entries , the path traversal logic  indicates that the navigation path is invalid (). In one implementation, invalid navigation paths are not analyzed by the GUI class rules logic  and constraint satisfaction engine , and a transformed test script statement  is not output as a result. In one implementation, the path traversal logic  outputs a warning message identifying the invalid navigation paths. In another implementation, the change guide includes a warning message indicating the invalid navigation paths. The change guide  may include various warning messages that reflect any number of conditions identified during processing by the script analyzer . The change guide  may include warning and\/or informational messages corresponding to conditions encountered by script analyzer  and\/or any of the logic of the script analyzer  (e.g., the script parser logic , script analysis logic , OR Lookup logic , path traversal logic , and GUI class rules logic ) and\/or the constraint satisfaction engine . The script analysis logic  may output a change guide  with change guide messages  (e.g., ,  and ) corresponding to the recorded GUI class rules logic  and constraint satisfaction rules  violations ().",{"@attributes":{"id":"p-0325","num":"0329"},"figref":["FIG. 42","FIG. 42"],"b":["178","152","178","3920","178","180","3920","178","1","6","11","14","19","21","22","2","4","3920","3926","178","3928","194","3928","194","162","178","3920"]},"For example, the script analysis logic  transforms lines - of the current test script , shown in , into transformed test script statements  lines , -, shown in . A programmer may input lines - of the transformed test script , because those lines include new GUI objects (e.g., \u201cToolbarWindow\u201d and values \u201cMy Computer\u201d) for which the GUI difference model  may not include information that identifies a corresponding GUI object in the current GAP version . In one implementation, the GUI difference model  and the GUI element metadata provide the GUI class, GUI typing and mapping information necessary for the script analysis logic  to infer lines - of the transformed test script , given that the \u201cuniversity.data\u201d in line  represents a destination in a path traversal from which the intermediate test script statements may be determined. In another example, the GUI difference model  and\/or the GUI element metadata include GUI class and mapping information that the script analyzer  uses to transform line  of the current test script  that refers to WinObject \u201cSave File\u201d into transformed test script statements  lines - that refer to a \u201cSave File\u201d child GUI object of the WinObject \u201cmenuStrip\u201d.",{"@attributes":{"id":"p-0327","num":"0331"},"figref":"FIG. 43","b":["180","180","3920","184","3928","194","3928","188","170","184","3926","170","3928","3928","184","164","152","170","184","3938","3926","170","184","3930","3926"]},"Some of the types of changes to GUI objects between successive releases of GAPs that the script analyzer  may identify in a change guide message  include: (A) a new GUI object added to a subsequent GAP version ; (B) a GUI object is deleted from a subsequent GAP version ; (C) the values of one or more attributes of a GUI object are modified; (D) the values of a GUI object are different; and (E) the type of a GUI object is different. GUI object changes of types A and B occur when GUI objects are added and removed correspondingly from current GAP version  and subsequent GAP version . For example, adding the WinObject menustrip  to the subsequent GAP version  is a type A change, while removing the WinObject \u201cSelect School\u201d  is a type B GUI object change. Referring to , notice that the \u201cSelect School\u201d has been removed at .","An example of a type C change is the change of the window name from StateList  to School . Adding or removing values from GUI objects such as list and combo boxes are examples of modifications of the type D change. For example, the listbox StateListbox  in current GAP version  is identified in the subsequent GAP version  as StateListbox , and referring to the GUI difference entry  the values for SeqNumber=\u201c8\u201d are \u201cDistrict of Columbia\u201d and \u201cFlorida\u201d for successive GAP versions, respectively. Changing the \u201ctype\u201d of a GUI object may include replacing a class of the window that is used to represent the object and\/or changing the high-level concept that describes the values that the GUI object takes. For example, changing the type of the static label to a read-only combo box is a modification of the type E. Another example of a type E change includes the change of the listbox \u201cSchooListbox\u201d  to a combobox \u201cSchoolCombobox\u201d .","The script analyzer  classifies the types of changes that the GUI class rules logic  and\/or the constraint satisfaction engine  identify, including: Wrong-Path type 1 (WP-1) errors that occur when a script accesses GUI objects that may be deleted in the subsequent GAP version  (e.g., see \u201cSelect School\u201d  and  as shown in ). WP type 2 (WP-2) errors occur in scripts that read or write to the wrong GUI objects. WP-2 errors occur when transformed test script statements  navigate to wrong GUI objects and read the values of the wrong GUI object and\/or invoke methods on the wrong GUI object.","For example, consider the statement in lines  and  of the current test script  and transformed test script , respectively:",{"@attributes":{"id":"p-0332","num":"0336"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Window(\u201cStateList\u201d).Dialog(\u201cOpen\u201d).-"]},{"entry":[{},"\u2003\u2003WinListView(\u201cSysListView32\u201d).Select"]},{"entry":[{},"\u201cuniversity.data\u201d."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The statement selects \u201cuniversity.data\u201d from a WinListView \u201cSysListView\u201d. However, lines - of the transformed test script  may navigate to and invoke the Select method on the wrong GUI object \u201cuniversity.data\u201d, because the GUI objects referenced in lines - of the transformed test script  are new GUI objects that are not referenced in the current test script . Thus, when the properties of existing GUI objects are modified and\/or other GUI objects are added into a subsequent GAP version , the result of interference of these operations is that the transformed test script statement  may access and read values of objects that are different from those as originally intended.","Changed-Element (CE) errors occur when statements attempt to access GUI objects whose types, properties, or default values are changed in the subsequent GAP version  (CE-1). For example, the GUI difference entry  indicates that there are different values for SeqNumber=\u201c8\u201d are \u201cDistrict of Columbia\u201d and \u201cFlorida\u201d for successive GAP versions, and the script analysis logic  may consequently issue a change guide message  indicating that a CE-1 type error has occurred.","The script analysis logic  may issues a change guide message  corresponding to a CE-2 type error, when a transformed test script statement  attempts an operation on a GUI object that does not take into consideration new constraints imposed on the elements, for example, attempting to write data to a read-only text box. Referring to the GUI element difference entry shown in Table 13, the WinObject \u201cAcadScale\u201d referred to in the current test script  at line  is an editable object that has been transformed into the WinObject \u201cAcademics (1-5)\u201d in the subsequent GAP version  where the object is read-only. In one implementation, the script analysis logic  outputs a change guide message  to indicate a CE-2 type change has occurred.",{"@attributes":{"id":"p-0336","num":"0340"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GUI Element Difference entry for AcadScale"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<GUIElement Type = \u201cAcadScale Textbox\u201d>"]},{"entry":[{},"<Version> 0"]},{"entry":[{},"\u2003\u2212 <GUIElement Alias=\u201cAcadScale\u201d>"]},{"entry":[{},"\u2003\u2003<UniqueID>0xcb<\/UniqueID>"]},{"entry":[{},"\u2003\u2003<HWND>0x1a0b3c<\/HWND>"]},{"entry":[{},"\u2003\u2003<Location x=\u201c573\u201d y=\u201c790\u201d width=\u201c32\u201d height=\u201c23\u201d \/>"]},{"entry":[{},"\u2003\u2003<Class>WindowsForms10.EDIT.app4<\/Class>"]},{"entry":[{},"\u2003\u2003<Style>0x560100c0<\/Style>"]},{"entry":[{},"\u2003\u2003<ExStyle>0xc0000a00<\/ExStyle>"]},{"entry":[{},"\u2003\u2212 <GUIElement Alias=\u201cAcadScale\u201d>"]},{"entry":[{},"\u2003\u2003<UniqueID>0x4<\/UniqueID>"]},{"entry":[{},"\u2003\u2002<HWND>0x1a0b3c<\/HWND>"]},{"entry":[{},"\u2003\u2003<Location x=\u201c575\u201d y=\u201c792\u201d width=\u201c28\u201d height=\u201c19\u201d \/>"]},{"entry":[{},"\u2003\u2002<Class>WindowsForms10.EDIT.app4<\/Class>"]},{"entry":[{},"\u2003\u2003<Style>0x560100c0<\/Style>"]},{"entry":[{},"\u2003\u2003<ExStyle>0xc0000a00<\/ExStyle>"]},{"entry":[{},"\u2003\u2003\u2002\u2212 <Values>"]},{"entry":[{},"\u2003\u2003<Value SeqNumber=\u201c3\u201d \/>"]},{"entry":[{},"\u2003\u2003<\/Values>"]},{"entry":[{},"\u2003\u2003<\/GUIElement>"]},{"entry":[{},"\u2003<\/GUIElement>"]},{"entry":[{},"<\/Version>"]},{"entry":[{},"<Version> 1"]},{"entry":[{},"\u2212 <GUIElement Alias=\u201cAcademics (1-5)\u201d>"]},{"entry":[{},"\u2003<UniqueID>0x2ff<\/UniqueID>"]},{"entry":[{},"\u2003<HWND>0x70d0e<\/HWND>"]},{"entry":[{},"\u2003<Location x=\u201c597\u201d y=\u201c388\u201d width=\u201c111\u201d height=\u201c17\u201d \/>"]},{"entry":[{},"\u2003<Class>WindowsForms10.STATIC.app.0.378734a<\/Class>"]},{"entry":[{},"\u2003<Style>0x5600000d<\/Style>"]},{"entry":[{},"\u2003<ExStyle>0xc0000800<\/ExStyle>"]},{"entry":[{},"\u2212 <GUIElement Alias=\u201cAcademics (1-5)\u201d>"]},{"entry":[{},"\u2003<UniqueID>0x308<\/UniqueID>"]},{"entry":[{},"\u2003<HWND>0x70d0e<\/HWND>"]},{"entry":[{},"\u2003<Location x=\u201c597\u201d y=\u201c388\u201d width=\u201c111\u201d height=\u201c17\u201d \/>"]},{"entry":[{},"\u2003<Class>WindowsForms10.STATIC.app.0.378734a<\/Class>"]},{"entry":[{},"\u2003<Style>0x5600000d<\/Style>"]},{"entry":[{},"\u2003\u2003<ExStyle>0xc0000800<\/ExStyle>"]},{"entry":[{},"\u2003\u2003\u2212 <Values>"]},{"entry":[{},"\u2003\u2003\u2002<Value SeqNumber=\u201c3\u201d>Academics (1-5)<\/Value>"]},{"entry":[{},"\u2003\u2003\u2002<\/Values>"]},{"entry":[{},"\u2003\u2003\u2002<\/GUIElement>"]},{"entry":[{},"\u2003\u2003<\/GUIElement>"]},{"entry":[{},"\u2003<\/Version>"]},{"entry":[{},"<\/GUIElement>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Knowing the modification type for a GUI object facilitates the script analysis logic  to determine the appropriate change guide message  and transformed test script statements  to output. For example, when a transformed test script statement  attempts to set values in a text box object, although the type of the object has changed to a read-only combo box, the script analysis logic  outputs change guide messages  that suggests how to modify the transformed test script statement  to select values in the combo box using appropriate interfaces.",{"@attributes":{"id":"p-0338","num":"0342"},"figref":"FIG. 44","b":["3926","3920","3934","178","150","3926","4402","3920","152","4404","3928","188","3926","4406","3926","178","3938","4408"]},"When the script analysis logic  determines that GUI objects have been removed from a current GAP version  (). The script analysis logic  locates the statements that reference these removed objects in the current test script . The script analyzer  refers to these statements as first-reference statements (FRS) (). The variables used in these statements are obtained, and the statements that use the variables whose values are defined in the FRSs are referred to as secondary reference statements (SRS) (). The GUI class rules logic  and\/or constraint satisfaction engine  may analyze the GUI objects to determine whether WP-1 errors have occurred based on the script statements attempting to access GUI objects that have been deleted in a subsequent GAP version  (). When a statement of the current test script  refers to a variable whose value points to a removed GUI object, the statement of the current test script  is considered an SRS. In one implementation, the script analyzer  outputs the identified SRSs as transformed test script statements  and corresponding change guide messages , so that test personnel can review and decide how to modify the SRSs ().","When the values of one or more attributes of a GUI object are modified, a type C modification is performed (). FRSs and SRSs are identified in transformed test script statements  for the GUI object with the modified attributes and change guide messages  are output. When the values of GUI objects are added or removed, modifications of the type D occur (). After locating FRSs that reference GUI objects whose values have been changed, SRSs are found and the script analyzer determines the impact due to the SRSs. When the type of a GUI object is modified then a modification of the type E occurs that involves locating FRSs, checking the new types of the GUI object, invoking corresponding type sub-sumption rules (e.g., rules the GUI class rules logic  may apply) (). The GUI class rules logic  and\/or constraint satisfaction engine  may analyze the modified GUI objects to determine whether CE-1 and CE-1 errors have occurred as a result of the transformed test script statement  attempting to access GUI objects whose types, properties, or default values are changed in a subsequent GAP version , and\/or attempting an operation on a GUI object that does not take into consideration new constraints imposed on the elements of the GUI object (). In one implementation, the script analyzer  outputs the identified SRSs as transformed test script statements  and corresponding change guide messages , so that test personnel can review and decide how to modify the SRSs ().",{"@attributes":{"id":"p-0341","num":"0345"},"figref":"FIG. 48","b":["184","162","4802","170","162","140","4804","170","3914","3916","4806","3912","3916","3916","4808","3914","172","3916","174","4810","3924","3910","3916","4812","3928","3910","3928","3930","3910","4814","188","3910","3932","3926","3938","4816","3920","3928","3932","4818"]},"In one implementation, the SAA  uses adaptive programming including class and object graphs and an abstraction that treats all objects uniformly. The traversal logic , constraint satisfaction engine  and the GUI class rules logic  may distinguish complex and simple types of GUI objects. Complex types contain fields while simple types do not. Let T be finite sets of type names and F of field names or labels, and two distinct symbols this \u03b5F and \u22c4\u03b5F. Type graphs are directed graphs G=(V, E, L) such that:","VT, the nodes are type names;","LF, edges are labeled by field names, or \u201c\u22c4\u201d where fields do not have names. Edges that are labeled by \u201c\u22c4\u201d are called aggregation edges, and edges that are labeled by field names reference edges. The difference between aggregation and reference edges becomes clear with the following example. Fields of classes in object-oriented languages designate instances of some classes, and these fields have names that are used to reference the fields. Each field of a class is defined by the name of the field and the name of the class (type) that this field is an instance of. The name of a field is the label of the corresponding reference edge in the type graph.","When a class designates a GUI object oand the other class designates a GUI object othat is contained in the object o, the type graph has two nodes, one for the object oand the other for the object othat the object ocontains. The names of the corresponding classes serve as their types. The relation between two nameless objects is represented using the edge labeled with the \u201c\u22c4\u201d in the type graph.","EL\u00d7V\u00d7V, edges are cross-products of labels and nodes;","for each v\u03b5V, the labels of all outgoing edges with the exception of \u201c\u22c4\u201d are distinct;","for each v\u03b5V, where v represents a concrete type,",{"@attributes":{"id":"p-0349","num":"0353"},"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"3.98mm","wi":"19.05mm","file":"US08365147-20130129-C00001.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"An object graph is a labeled directed graph O=(V\u2032, E\u2032, L\u2032) that is an instance of a type graph G=(V, E, L) under a given function Class that maps objects to their classes, if the following conditions are satisfied:","for all objects o\u03b5V\u2032, o is an instance of the concrete type given by function Class(o);","for each object o\u03b5V\u2032, the labels of its outgoing reference edges are exactly those of the set of labels of references of Class(o) including edges and their labels inherited from parent classes;","for each edge",{"@attributes":{"id":"p-0354","num":"0358"},"chemistry":{"@attributes":{"id":"CHEM-US-00002","num":"00002"},"img":{"@attributes":{"id":"EMI-C00002","he":"4.32mm","wi":"19.81mm","file":"US08365147-20130129-C00002.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},{"@attributes":{"id":"p-0355","num":"0359"},"chemistry":{"@attributes":{"id":"CHEM-US-00003","num":"00003"},"img":{"@attributes":{"id":"EMI-C00003","he":"3.98mm","wi":"14.05mm","file":"US08365147-20130129-C00003.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{}},"An object graph is a model of the objects, represented in GAPs, and their references to each other. A collection of fields in an object graph is a set of edges labeled by field names. A collection of aggregated objects in an object graph is a set of edges labeled by \u201c\u22c4\u201d. A path in a type graph G=(V, E, L) is a sequence of nodes and labels p=(ve, ve, . . . ev), where v\u03b5V and",{"@attributes":{"id":"p-0357","num":"0361"},"chemistry":{"@attributes":{"id":"CHEM-US-00004","num":"00004"},"img":{"@attributes":{"id":"EMI-C00004","he":"4.23mm","wi":"19.64mm","file":"US08365147-20130129-C00004.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}},"br":{},"sub":["c ","G","c","G"],"u":"\u2282"},"An object graph has the special object o\u03b5V\u2032, ois a collection of root objects oV\u2032 in the object graph O given by function root: O\u2192o. This object has type Class(o)=root and its relation with objects in its collection is expressed via o\u2192\u22c4\u2192o\u2032\u03b5E\u2032.","Given an object o of some type the traversal logic , constraint satisfaction engine  and the GUI class rules logic  work together to identify one or more reachable objects that satisfy certain criteria. The task performed is equivalent to determining whether test script statement vectors  and\/or transformed test script statements  that describe navigation paths are valid. Navigation paths specified in transformed test script statements  can be thought of as specification of constraints for the object reach-ability problem. Finding reachable objects is done via traversals. The traversal of an edge labeled e corresponds to retrieving the value of the e field. Every edge in the object graph is an image of a has-part edge in the type graph: there is an edge e(o, o) in O only when there exist types vand vsuch that object ois of type v, vhas an e-part of type v, and ois of type v.","The first node of a path p is called the source of p and the last node is called the destination of p. A traversal of an object graph O started with an object vand guided by paths from a set of paths p is done by performing depth-first search on O with p used to prune the search. The resulting traversal history is a depth-first traversal of the object graph along object paths agreeing with the given concrete path set.","The problem of identifying all reachable objects from a given object o that satisfy certain criteria is formalized as follows. For each pair of classes c and c\u2032, a set of edges e may be identified by computing FIRST(c, c\u2032) iff it is possible for an object of type c to reach an object of type c\u2032 by a path beginning with an edge e. More precisely, FIRST(c, c\u2032)=e\u03b5E, such that there exists an object graph O of C and objects o and o\u2032 such that: 1) Class(o)=c; 2) Class(o\u2032)=c\u2032; and 3) o e*o\u2032.","The last condition, o e*o\u2032 indicates that there is (\u2203) a path from o to o\u2032 in the object graph, consisting of an edge labeled e, followed by any sequence of edges in the graph. The lack of information about the actual graph is represented by the existential operator \u2203.","The task of static checking of test scripts (e.g., transformed test scripts ) is greatly simplified when the names of foreign components names are defined as string constants. When the names of GUI objects are specified using expressions, the values of these expressions may not be determined until run-time. Type graphs facilitate the script analyzer system  to infer types of expressions and variables that hold the names of GUI objects. The script analyzer system  applies concepts based on the Traversal Graph Analysis (TGA) defined in adaptive programming to infer types of expressions and variables.","An adaptive strategy S=(R, \u03c0, \u03b4) represents paths in an object graph, where R={s, d}, where s and d are the source and destination GUI objects of a path in an object graph, and RO, where O is the set of objects in a type graph, \u03c0={e, \u03b1}, where e is a set of fields and \u03b1 is a set of variables that designate a set of some edges \u03b1e, and \u03b4={} is a set of transition edges representing objects and attributes respectively. Each element in a strategy S is either the name of some object or a variable designating an object and\/or attributes.","The expression \u03c0(o, o\u2032) designates a set of objects {o\u2032}, such that each object o\u2032 of the set is a part of the object o expressed by some edge e\u03b5\u03c0 such that e(o, o\u2032). For example, test script statements may be considered strategies that define strategy graph edges ab and ab for test script statements Window(\u201ca\u201d).VBWindow(\u201cb\u201d) and Window(\u201ca\u201d).VBWindow(\u201cb\u201d).property(\u201cReadOnly\u201d), respectively. Thus, a strategy is an abstraction of test script statements (e.g., transformed test script statements ), as well as an abstraction of a set of paths in a type graph.","For example, a type graph of an organizational structure of a company may include: a CEO as a root type of some GUI object that contains the GUI object stock of type integer and aggregates type CTO. CTO is a type that has GUI objects salary of type Check and boss of type CEO. Type Check has in turn fields amount of type float and issuer of type CEO. A strategy CEO\u03b11\u03b12 amount for the test script statement:","Window(\u201cCEO\u201d).Window(strexp1).Window(strexp2).property(\u201camount\u201d) for the type graph described above designates strategy S, where s=CEO, d=amount, \u03b1 is a variable designating objects computed via string expression strexp, and \u03b1 is a variable designating attribute object computed via string expression strexp. Computing \u03c0(CEO, o\u2032) the type {CTO} is obtained, and computing \u03c0(CTO, o\u2032) the types {CEO,check} are obtained.","Each node in a strategy is assigned a distinct sequence number, and nodes are expressed as pairs (i, \u03c0). Given functions \u0394i: N\u00d7N\u2192\u03b4 and \u0394\u03c0: \u03c0\u00d7\u03c0\u2192\u03b4 and two sequential natural numbers k and k+1, the function \u0394i computes the tran-sition edge between nodes that are assigned these numbers in S, and \u00d8 if there is no transition edge. Correspondingly, given two nodes \u03c0and \u03c0in some type graph, function \u0394\u03c0 computes the transition edge between nodes, and \u00d8 if there is no transition edge.","When the values of string expressions in test scripts statements cannot be computed until run-time, the string expressions may be inferred. The path traversal logic , constraint satisfaction engine  and the GUI class rules logic  work together to analyze transformed test script statements, using type graphs by transforming transformed test script statements  into an adaptive strategy with variables replacing string expressions. The constraint satisfaction engine  and\/or the GUI class rules logic  computes possible values for each variable and generates traversal paths for each strategy. Where no path is identified between the source and the destination objects, then a type GUI element script change rule entry , change guide message  and change specifier  may be reported. Where at least one path is identified, then a corresponding change guide message  and change specifier  are generated, since values of expressions that compute names of objects may not be in the computed paths. In one implementation, the path traversal logic , constraint satisfaction engine  and the GUI class rules logic  may be similarly applied to validate test script statements in the current test script .","The path traversal logic  identifies one or more possible paths, while the constraint satisfaction engine  and the GUI class rules logic  validate paths for the expressions and statements. The constraint satisfaction engine  and the GUI class rules logic  compute the set of edges e for each pair of classes c and c\u2032, by computing FIRST(c, c\u2032) where an object of type c exists that can reach an object of type c\u2032 by a path beginning with an edge e. Recall from above that FIRST(c, c\u2032)=e\u03b5E, such that there exists an object graph O of C and objects and o\u2032 such that: 1) Class(o)=c; 2) Class(o\u2032)=c\u2032; and 3) o e*o\u2032.","The last condition, o e*o\u2032 says that there is (\u2203) a path from o to o\u2032 in the object graph, consisting of an edge labeled e, followed by any sequence of edges in the graph. In one implementation, the method FIRST is implemented using two sets of logic: path traversal logic  and GUI class rules logic . Table 14 illustrates the path traversal logic  and GUI class rules logic .","The path traversal logic  takes the set R of source and destination components in S and set \u03c0 as input parameters. The path traversal logic  outputs a tree of valid paths in a type graph that satisfy a given strategy. Some of the input components may not make it into the path tree because they do not start any valid paths.","In one implementation, the path traversal logic  invokes the GUI class rules logic , which in turn recursively calls itself. The GUI class rules logic  uses three parameters: a component o that is a potential current node in the path, sequence number i of the node in the strategy S, and the transition edge \u03b4 between nodes in S that are assigned two sequential natural numbers i and i+1. The goal of the GUI class rules logic  is to color the potential current node o in the path as either red or blue. Where colored red object o is considered a dead end on the path in the type graph that does not lead to the designated destination nodes. Otherwise, the node is colored blue and this color is propagated up to the source nodes which are subsequently included in the path tree.","The GUI class rules logic  completes when the sequence number i is equal to or the greater of the number of nodes in the strategy, |\u03c0|, and\/or where there is no transition edge from the current node. When the GUI class rules logic  completes, the GUI class rules logic  colors the current node blue. In the calling procedure the color of the node is checked, and where the node is blue, then node is attached to its parent node in the path tree.","In one implementation, the constraint satisfaction engine  and the GUI class rules logic  work together to compute the set of edges e for each pair of classes c and c\u2032, where an object of type c is identified that can reach an object of type c\u2032 by a path beginning with an edge e. The logic is applied individually to each transformed test script statement  in which foreign GAP objects are specified using string expressions whose values are not known before the transformed test script  is executed. The constraint satisfaction engine  and the GUI class rules logic  work together to infer possible names of foreign objects that string expressions may evaluate to at runtime.",{"@attributes":{"id":"p-0376","num":"0380"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Path Traversal and GUI class rules logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Path Traversal Logic (R \u03b5 S, \u03c0 \u03b5 S)"]},{"entry":[{},"for all s \u03b5 R do"]},{"entry":[{},"\u2003GUI class rules logic (s, 0, \u0394i(0,1))"]},{"entry":[{},"\u2003if color(s) = red then"]},{"entry":[{},"\u2003\u2003remove s from R"]},{"entry":[{},"\u2003end if"]},{"entry":[{},"end for"]},{"entry":[{},"GUI class rules logic (o \u03b5 O, i \u03b5 N, \u2202 \u03b5 \u03b4)"]},{"entry":[{},"if i \u2267|\u03c0| or \u2202 = \u00d8 then"]},{"entry":[{},"\u2003color(o)  \u2009blue"]},{"entry":[{},"else"]},{"entry":[{},"\u2002for all o\u2032 \u03b5 \u03c0i(o, o\u2032) do"]},{"entry":[{},"\u2003\u2003if \u0394\u03c0(o,o\u2032) = \u2202 then"]},{"entry":[{},"\u2003\u2003\u2003GUI class rules logic (o\u2032, i + 1, \u0394i(i, i + 1))"]},{"entry":[{},"\u2003\u2003\u2003if color(o\u2032) = blue then"]},{"entry":[{},"\u2003\u2003\u2003\u2003AddChildToTree(o, o\u2032)"]},{"entry":[{},"\u2003\u2003\u2003end if"]},{"entry":[{},"\u2003\u2003\u2002end if"]},{"entry":[{},"\u2003end for"]},{"entry":[{},"\u2003if children(o) = \u00d8 then"]},{"entry":[{},"\u2003\u2003color(o)  \u2009red"]},{"entry":[{},"\u2003else"]},{"entry":[{},"\u2003\u2003color(o)  \u2009blue"]},{"entry":[{},"\u2003end if"]},{"entry":[{},"end if"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Often the same string expressions are used in different statements in the same scripting scope. The same expressions compute the same values, where the expressions are located in the same scope, provided that the values of the variables used in these expressions are not changed. Using program analysis techniques the path traversal logic , constraint satisfaction engine  and GUI class rules logic  work together to detect expressions at compile time whose variables are not changed at run-time. The path traversal logic  identifies one or more possible names of foreign GUI objects that may be substituted for string expressions in test script statements. While the constraint satisfaction engine  and the GUI class rules logic  identifies from among the possible names of foreign GUI objects, those GUI objects that do not violate constraint satisfaction rules  and\/or GUI element script change rules . Given the same expression used in different test script statements in the same script scope, and provided that the values of the variables used in these expressions are not changed by other expressions executed between these statements, the constraint satisfaction engine  and\/or the GUI class rules logic  identify a set of names of foreign GUI objects computed by these string expressions. This set of GUI objects is obtained by taking the intersection of the sets of names computed by the path traversal logic .","For example, consider the strategy graph S CEO\u03b1\u03b1 amount for the type graph discussed above for the transformed test script statement  expression: Window(\u201cCEO\u201d).Window(strexp).Window(strexp).property(\u201camount\u201d). The constraint satisfaction engine  and\/or the GUI class rules logic  computes values for type scheme variables \u03b1={CTO} and \u03b1={boss, salary}.","Suppose a different strategy graph S exists, where Programmer\u03b1bonus for y[\u201cProgrammer\u201d][strexp].attribute(\u201cbonus\u201d) for some other type graph. Notice that the string expression variable strexp is the same in both statements, and because of that the string expression variable strexp is designated by the same type scheme variables in both the strategy graphs. Suppose that by applying the path traversal logic  that values for type scheme variable \u03b1={salary} are computed. In one implementation, in order to determine the value of variable \u03b1 that satisfies both S and S, the GUI class rules logic  identifies the intersection of the sets of values of \u03b1 computed for these two strategies. The resulting set \u03b1={salary} is the result of pruning the navigation paths.","This example illustrates the idea of pruning navigation paths using context-sensitive dataflow analysis that may be used by the constraint satisfaction engine  and\/or the GUI class rules logic . By determining definitions and uses of a variable that designate names of GUI objects in a given scope, sets of values are computed for each transformed test script statement in which a variable is used. Then the intersection of these sets is taken to determine common values that this variable can take in the scope considered.","The script analyzer system  provides modularization integrity as a mechanism for ensuring maintainability of transformed test scripts . Modularization integrity specifies that each statement in a transformed test scripts  may only communicate directly with the objects that belong to GUIs for which the transformed test scripts  is created. Compositions of transformed test scripts  in which GUI objects are accessed by calling functions exported by transformed test scripts  should not violate modularization integrity. The script analyzer system  ensures the modularization integrity of transformed test scripts  by analyzing compositions of transformed test script statements  to build the transitive relations between the current test script  and the transformed test script .","For example, a statement Func(\u201cy\u201d, \u201cz\u201d), found in a suite of related test scripts, navigates to the field z of foreign GUI object y in some test scripts that export function Func. Thus, the some test scripts in the suite of related test scripts may violate the modularization integrity by implicitly interoperating the test scripts via the function Func even though this communication may be prohibited by the constraints of a given test suite. In one implementation, the script analyzer system  encodes modularization constraints when defining test scripts using the keyword constraints as part of a global comment in each test script. These constraints define GAPs and their GUI screens as well as other test scripts with which a given test script may communicate. An example is a statement that specifies a constraint is constraints screen(\u201cQ\u201d) test_scripts(\u201cP, S\u201d). This constraint effectively prohibits a given test script from communicating with other GAPs, GUI screens, and test scripts, except the screen Q and test scripts P and S, explicitly or implicitly. In one implementation, the constraint satisfaction engine  ensures that such constraints are not violated by maintaining constraint satisfaction rules  imposed on test scripts and GAPs, and the constraint satisfaction engine  issues change guide messages  when these constraints are violated.","The time complexity of the path traversal logic , constraint satisfaction engine  and GUI class rules logic  is exponential to the size of the type graph for each transformed test script . Because the path traversal logic , constraint satisfaction engine  and GUI class rules logic  involve the search of one or more nodes and edges in the type graph that contains cycles for each node in the strategy, the time complexity is O((V+E)) where V is the number of nodes, E is the number of edges in the type graph, and max(|\u03c0|) is the maximum number of nodes in strategies. The operations of storing successors in the table of variables take O(1). In general, the number of nodes max(|\u03c0|) in strategies is much smaller than the number of nodes in type graphs. All graph nodes may not need to be explored for each node in a strategy. The theoretical limit on computational complexity of the path traversal logic , constraint satisfaction engine  and GUI class rules logic  is exponential. However, experimental evaluation shown that in practice the running time of is small for large schemas because typically path expressions are short.",{"@attributes":{"id":"p-0384","num":"0388"},"figref":"FIG. 49","b":["110","110","110","110","162","150","152","162","162","150","152","182","162","162","110","190","138","138","162","150","152"]},"The economic cost engine architecture  includes a script parser  that parses a current test script  to obtain an intermediate representation of the current test script . The intermediate representation may be an abstract syntax tree (AST)  or other representation of the current test script . In one implementation, the economic cost engine architecture  employs an economic cost engine  that analyzes the AST  and the GUI difference model . The economic cost engine  may invoke object repository (OR) lookup logic  to search an object repository  and the GUI difference model  to locate, in the GUI difference model , the GUI elements identified by the AST . The economic cost engine  includes economic cost model logic  that uses the GUI elements identified by the AST  and GUI difference model  to generate synthetic GAP change specifiers  that are used to search an economic models  repository for corresponding GUI element change cost rule. In one implementation, the economic cost model logic  uses GAP change specifiers  and synthetic GAP change specifiers  to search an economic models  repository for corresponding GUI element change cost rule. The economic cost engine  applies each GUI element change cost rule to obtain corresponding GUI transformation costs from which a test script transformation cost report  is generated, discussed further below. The economic cost engine  may also use historical testing metrics from a performance metrics repository  and cost reports repository  to facilitate obtaining the GUI transformation costs, discussed below.","The economic cost engine  may generate test script transformation cost reports  based on different combinations of available information, including: 1) GAP change specifiers  and\/or synthetic GAP change specifiers ; 2) GAP change specifiers and a current test script ; 3) GAP change specifiers , a current test script  and a current GAP version  (e.g., a current GAP tree model); 4) a current test script  and a GUI difference model  with GUI element difference entries; and 5) GAP change specifiers , a current test script , and a GUI difference model . Other combinations of the same or different information may also be employed. The various combinations of available information are used by the economic cost engine  to analyze received and\/or generate synthetic GAP change specifiers  that are used by the economic cost model logic  to locate and retrieve GUI transformation costs and generate test script transformation cost reports.","The accuracy of the GUI transformation costs may depend in part on how narrow the variance is between the actual costs and the costs indicated by the GUI transformation costs. A large variance corresponds to a lower accuracy, while a narrow variance corresponds to a higher accuracy. In other words, the accuracy of the GUI transformation costs may correspond to the predictability and\/or confidence that the actual costs will reflect the GUI transformation costs. In one implementation, the accuracy of the GUI transformation costs varies due to the granularity of the information received by the economic cost engine . For example, the GUI transformation costs generated as a result of the economic cost engine  receiving GAP change specifiers , a current test script , and a GUI difference model  may have a higher level of accuracy than the GUI transformation costs generated based solely on GAP change specifiers . The economic cost engine  may employ various economic models that compensate for the lack of granularity of information provided to the economic cost engine , discussed in further detail below.","In one implementation, the economic cost engine  receives GAP change specifiers , a current test script  and a current GAP version , and generates a GUI difference model . In other words, the economic cost engine  may generate the test script transformation cost report  based on the AST , the current GAP version  and GAP change specifiers , discussed further below, without relying on an actual subsequent GAP version . For example, the economic cost engine  analyzes the GAP change specifiers  and the current GAP version  (e.g., a current GAP tree model received from the GUI difference model ), and generates synthetic GAP change specifiers . In another implementation, the economic cost engine  generates the test script transformation cost report  based on the GAP change specifiers , without analyzing either the GUI difference model  and\/or the AST . The economic cost engine  may generate the test script transformation cost reports  with change guide messages retrieved from a change guide message repository . The change guide messages may provide information regarding the various changes corresponding to the GAP change specifiers , GUI element change cost rules and\/or GUI difference entries.",{"@attributes":{"id":"p-0389","num":"0393"},"figref":"FIG. 34","b":["152","162","182","184","182","4984","152","150","184","182","184","4984","182","4984","184","110","4984","150"]},{"@attributes":{"id":"p-0390","num":"0394"},"figref":"FIG. 50","b":["5000","5000","1","6","1","5000","5000","2","3","4","6","5000","7","17","8","5000","11","15","16","5000","18","20"]},{"@attributes":{"id":"p-0391","num":"0395"},"figref":"FIG. 51","b":["5100","166","5000","110","168","5100","5000","5000","5100"]},"The script parser  represents the test script statement vectors as an ordered sequence of nodes that contain function names and the arguments of those functions that navigate to GUI objects. The nodes of a test script statement vector include a source node and a destination. For example, the script parser  may represent the test script statement vector corresponding to line  of the current test script  as source node StateList  and a destination node \u2018Open File\u2019 . The nodes of a test script statement vector may also include intermediate nodes positioned between a source node and a destination node. For example, the script parser  may represent the test script statement vector corresponding to line  of the current test script  as source node StateList , intermediate node \u2018Save a Data Record\u2019  and destination node \u2018File name\u2019 . The test script statement vector corresponding to line  of the current test script  may be further expressed as (----), including the method \u2018Set\u2019  and value \u2018university_revise.data\u2019 .","The test script statement vectors may include looping and conditional branching nodes (e.g., loop  and branch , respectively). In one implementation, the loop  node is followed by a loop variable (e.g., school_constant ) for which a range of values, from a lower to an upper bound (e.g., J  and K ), are evaluated and used in expressions within the scope of the loop  (e.g., 67, school_constant coordinates ). The branch  may be followed by one or more conditions (e.g., condition-  and condition- ). The economic cost engine  may use the loop  and branch  nodes, and range values and conditions (e.g., J , K , condition-  and condition- ) to recursively evaluate the current test script representation .","In one implementation, the GAP change specifiers  includes a model specifier (discussed in further detail below) that identifies the GUI element change cost rule to use to obtain a GUI transformation cost corresponding to a loop . The GUI element change cost rule for a loop  may result in the economic cost model logic  obtaining a GUI transformation cost that represents a multiplier equal to the number of values in the range from a lower to an upper bound (e.g., J  and K ) that is applied to the GUI transformation costs for the test script statements within the scope of the loop  (e.g., lines - in ). For example, the GUI transformation cost corresponding to loop , based on the lower to the upper bound (e.g., J  and K ), may equal 10 and the GUI transformation costs corresponding to the test script statements within the scope of the loop  (e.g., lines - in ) may equal 500, resulting in a total GUI transformation cost of 5,000 for the test script statements including loop  (e.g., lines -). In another example, the GUI transformation cost obtained by applying the GUI element change cost rule for a loop  may represent a single weighted valued (e.g., 50) that the economic cost model logic  adds to the GUI transformation costs corresponding to the test script statements within the scope of loop  so that the total GUI transformation cost of 550 results for the test script statements including loop  (e.g., lines -).","The GUI element change cost rule for a branch  may result in obtaining a GUI transformation cost that is based on the number of conditions (e.g., condition-  and condition- ) within the scope of the branch , and the GUI transformation costs for the branch  and the test script statements within the scope of the branch  are added to obtain the total GUI transformation costs.","In another implementation, the GUI transformation cost corresponding to the branch  is a multiplier that is applied to the GUI transformation costs corresponding to the test script statements within the scope of the branch . For example, two conditions (e.g., condition-  and condition- ) exist within the scope of the branch , corresponding to a GUI transformation costs of 2 for the branch  and the GUI transformation costs of the lines within the scope of the branch  are 100 resulting in a total GUI transformation cost of 200 for the test script statements including branch  (e.g., lines -).","The script parser  evaluates arguments of navigation and action functions as expressions, variables and constants. The arguments express the physical properties of GUI objects to which the test script statement vectors navigate and values used to perform actions on those GUI objects. For example, the \u201886,12\u2019 coordinates  identify the location for a pointing device to perform an action \u2018Click\u2019  on the \u2018Open File\u2019  GUI object, which is a child GUI Object of the window StateList . The economic cost engine  uses the names of the GUI objects (e.g., StateList  and \u2018Open File\u2019 ) navigated to by the test script statement vectors to locate the corresponding physical properties of the GUI objects stored in an object repository , identify corresponding GUI difference entries and generate synthetic GAP change specifiers .","In one implementation, the economic cost engine  uses the OR lookup logic  to locate, in the object repository , the physical properties of the GUI objects navigated to by a test script statement vector, and locate, in the GUI difference model , corresponding GUI difference entries. The economic cost engine  generates synthetic GAP change specifiers  and invokes the economic cost model logic  to locate corresponding GUI element change cost rules in the economic models  repository using GAP change specifiers  and synthetic GAP change specifiers . In one implementation, the OR lookup logic  is divided into two sub-functions: 1) lookup logic adapted to locate and retrieve the physical properties of the GUI objects navigated to by the test script statement vector (e.g., -, --, and -); and 2) locator logic that finds and returns a GUI element difference entry (node) in the GUI difference model  that corresponds to the GUI object with the given physical properties. The economic cost model logic  generates synthetic GAP change specifiers  that are used to locate applicable GUI element change cost rules, based on the lookup logic and locator logic results from the OR lookup logic . The OR lookup logic  may include path traversal logic, discussed in further detail below, to identify possible navigation paths of a test script statement vector between a source node GUI object and destination node GUI object to which a test script statement vector navigates.","The economic cost engine  may query the object repository  to identify the physical properties of the GUI objects navigated to by the test script statement vectors represented by the current test script representation . Physical properties of a GUI object may indicate whether the GUI object is hidden, read-only, a number and default values, as shown in Table 12.","For example, the economic cost engine  analyzes the GUI objects - in the test script statement vector. The \u2018,\u2019 coordinate  identifies the location for a pointing device to perform an action \u2018Click\u2019  on the GUI object SchooListbox , which is a child GUI Object of the window StateList . The economic cost engine  invokes the OR lookup logic  to locate the physical properties of the GUI objects  and . The OR lookup logic  locates the physical properties of the window StateList  and the WinObject SchoolListbox , as shown in Table 11 at lines  and . The economic cost engine  uses the physical properties retrieved from the object repository  to locate corresponding GUI difference entries (e.g.,  and ) in the GUI difference model . The GUI difference entries  and  indicate that the window StateList  and the WinObject SchoolListbox  in the current GAP version  correspond to the window School  and the WinObject SchoolCombobox  in the subsequent GAP version , respectively. In one implementation, the economic cost engine  employs the OR lookup logic  to traverse the GUI difference model  using the physical properties of the GUI objects navigated to by the test script statement vector. The OR lookup logic  function returns a GUI element difference entry (e.g., ,  and ) from the GUI difference model  that represents the GUI object navigated to by the test script statement vector (e.g., ---, ----, and ---), and the economic cost model logic  generates corresponding synthetic GAP change specifiers . Table 12 illustrates the physical properties that may be located in the object repository for the GUI object entry corresponding to the SchoolListbox .",{"@attributes":{"id":"p-0401","num":"0405"},"figref":"FIG. 52","b":["5200","182","182","5202","5204","190","190","138","162","140","3910","190","3906","5202","140","5290","162","3910","5202","3912","164","168","168","3914","3916","5102","5104","5110","5112","5102","5106","5108","5120","5122","5102","5114","5126","5118"]},"The memory  further includes economic cost model logic  that, in one implementation, invokes the OR lookup logic  to locate, in the object repository , a GUI object entry  referred to by the test script statement vector . In another implementation, the economic cost engine  invokes the OR lookup logic  to locate, in various external sources, a GUI object entry  matching the test script statement vector . When the test script statement vector  (e.g., ---, ----, and ---) employs constants to identify GUI object names, rather than expressions whose values can only be determined at runtime, the OR lookup logic  function may use the GUI object name and properties of the GUI object to efficiently locate the correct GUI object entry  and locate, in the GUI difference model , a GUI element difference entry  matching the GUI object entry .","For example, the test script statement vector represented by --- identifies the window GUI object StateList  and the listbox GUI object SchoolListbox , shown in the current test script  navigation statement shown at line  of :","Window(\u201cStateList\u201d).WinObject(\u201cSchoolListbox\u201d).Click ,.","The OR lookup logic  locates each GUI object entry  for GUI objects  and , using the known names of the GUI objects, StateList and SchoolListbox, respectively. The OR lookup logic  locates the corresponding GUI element difference entries  and , in the GUI difference model . In one implementation, the economic cost model logic  analyzes the GUI element difference entries  and  and generates one or more corresponding synthetic GAP change specifiers . Using the GAP change specifiers , the economic cost model logic  locates, in the economic models  repository, one or more corresponding GUI element change cost rules  and applies the cost rules to obtain GUI transformation costs . The GUI transformation costs  may include costs corresponding to changing the current test script  and testing the subsequent GAP version . In other words, the economic cost model logic  determines the costs to generate a transformed test script statement that corresponds to GUI objects School  and SchoolCombobox  and the costs to test the subsequent GAP version  using the transformed test script statement:","Window(\u201cSchool\u201d).WinObject(\u201cSchoolCombobox\u201d).Click ,.","Each GUI element change cost rule  may include various attributes, including: a change specifier identifier , system resource utilization identifiers , a GUI change cost estimate  that indicates the estimated time and\/or resources needed to test a corresponding GUI element change, dependent change specifier identifiers , dependency ranking , quality ranking , complexity ranking , and dependent GUI element change costs . Each economic model, residing in the economic models  repository and\/or external to the economic models  repository that is available to the economic cost model logic  through the interface , may include more, fewer, or different GUI element change cost rule  attributes.","The economic cost model logic  uses GAP change specifiers  and synthetic GAP change specifiers  to locate applicable GUI element change cost rules , in the economic models  repository, corresponding to change specifier identifiers . The system resource utilization identifiers  indicate the resources used to test a particular GUI element change. In one implementation, the system resource utilization identifiers  have values from 1 to 10 that identify the amount of a test environment's processing and infrastructure capacity needed to test a corresponding GAP change. For example, a system resource utilization identifier  with a value of 3, corresponding to the test environment's processing capacity, may indicate that one-third of the available processing capacity is needed to test a corresponding GAP change. A system resource utilization identifier  with a value of 10, corresponding to the test environment's processing capacity, may indicate that most of the available computing resources (e.g., processing capacity) will be needed to test a corresponding GAP change.","In another implementation, the system resource utilization identifiers  provide descriptions of the resources needed to test a corresponding GAP change. For example, the system resource utilization identifiers  may itemize the skills of testers, system components (e.g., input and output devices, and network bandwidth) and the priority settings to be assigned to system processes used to test a corresponding GUI element change. In one implementation, the system resource utilization identifiers  provide a combination of discrete values that indicate the test environment's processing capacity and the itemized descriptions of the various resources needed to test the corresponding GUI element change.","The economic cost model logic  may locate other applicable GUI element change cost rules  that depend from a particular GUI element change cost rule  identified by a change specifier identifier , using dependent change specifier identifiers . The dependent change specifier identifiers  may identify one or more corresponding GUI element change cost rules  that depend from the GUI element change corresponding to the change specifier identifier . For example, a change in the class of a parent GUI object from a listbox to a combobox (e.g., SchoolListbox  and SchoolCombobox ) may impose GUI element changes to children GUI objects of the parent GUI object, so that a change specifier identifier  corresponding to a particular GAP change specifier  and\/or synthetic GAP change specifier  identifies one or more dependent change specifiers identifiers .","In one implementation, the dependency ranking  is a value from 0 to 10 that indicates the level of dependency a GAP may have on a particular GUI element. The dependency ranking  may correspond to the visibility and scope of a GUI element. For example, the change of the window Statelist  in the current GAP  to School  in the subsequent GAP , as shown in , may correspond to a dependency ranking  of 10, while the change of a value in the StateListbox  to a value in the StateListbox , as shown in , may correspond to a dependency ranking  of 4. The economic cost model logic  uses the dependency ranking  to facilitate obtaining the GUI transformation costs . In one implementation, the economic cost model logic  uses the dependency ranking  to determine how and\/or whether to use the GUI change efficiency factor , discussed in further detail below.","In one implementation, the quality ranking  is a value from 1 to 10 that indicates the contribution to the quality of the subsequent GAP version  made by the GUI element change. For example, a particular GUI element change that enforces integrity checking on a GUI element corresponding to a high dependency ranking  value may correspond to a quality ranking  of 10. In another example, a GUI element change that is unperceivable and\/or corresponds to a low dependency ranking  value may correspond to a quality ranking  of 0. In one implementation, the economic cost model logic  uses a user selectable quality preference identifier to generate the test script transformation cost report  with GUI transformation costs  corresponding to quality rankings  meeting or exceeding the quality preference identifier, so that test plans may be evaluated based on quality factors.","In one implementation, the complexity ranking  is a value from 1 to 10 that indicates the difficulty level of testing the corresponding GUI element change, where a complexity level of 10 is a high level of complexity and a level of 0 is a low level of complexity. In another implementation, the complexity ranking  indicates the contribution to the level of complexity of the subsequent GAP version  made by the GUI element change. For example, a particular GUI element change that enforces integrity checking on a GUI element corresponding to a high dependency ranking  value may correspond to a complexity ranking  of 10. In another example, a GUI element change that is unperceivable and\/or corresponds to a low dependency ranking  value may correspond to a complexity ranking  of 0. In one implementation, the economic cost model logic  uses a user selectable complexity preference identifier to generate the test script transformation cost report  with GUI transformation costs  to complexity rankings  meeting or exceeding the complexity preference identifier, so that test plans may be evaluated based on complexity.","The dependent GUI element change costs  may represent an aggregated GUI transformation cost  corresponding to the dependent change specifier identifiers . In one implementation, the economic cost model logic  uses the dependent GUI element change costs , rather than retrieving each GUI element change cost rule  corresponding to the one or more dependent change specifier identifiers , to generate the test script transformation cost report .","In one implementation, the economic cost model logic  uses user selectable preference identifiers  to locate GUI element change cost rules  based on discrete values and\/or ranges of values for one or more of the system resource utilization identifiers , GUI change cost estimate , dependency ranking , quality ranking , complexity ranking  and dependent GUI element change costs . The preference identifiers  identify the GUI transformation costs  used to generate the test script transformation cost report , based on one or more of the change specifier identifier , a system resource utilization identifier , a GUI change cost estimate  that indicates the estimated time and\/or resources (e.g., money and labor) to test a corresponding GUI element change, dependent change specifier identifiers , dependency ranking , quality ranking , complexity ranking , and dependent GUI element change costs .","The GUI transformation cost  may include a time component and resource component. The time component of the GUI transformation cost  may indicate the elapsed time needed to change a test script statement and\/or test a corresponding GUI element change. The resource component of the GUI transformation cost  may indicate the money, areas of skill and\/or system infrastructure (e.g., human and technological units) needed to change a test script statement and\/or test a corresponding GUI element change.","Recall that the economic cost engine  may generate test script transformation cost reports  based on multiple combinations of available information, including: 1) GAP change specifiers ; 2) GAP change specifiers  and a current test script ; 3) GAP change specifiers , a current test script  and a current GAP version  (e.g., a current GAP tree model); 4) a current test script , and a GUI difference model  with GUI element difference entries; and 5) GAP change specifiers , a current test script , and a GUI difference model . The various combinations of available information are used by the economic cost engine  to analyze received GAP change specifiers  and\/or generated synthetic GAP change specifiers  that are used by the economic cost model logic  to locate and retrieve GUI transformation costs  and generate test script transformation cost reports .","In one implementation, the economic cost engine  receives GAP change specifiers  that the economic cost engine  uses to locate and retrieve GUI element change cost rules  from the economic models  repository. The received GAP change specifiers  may have resulted from prior analysis of a current GAP version , a current test script  and\/or a GUI difference model . In one implementation, the economic cost engine  may receive GAP change specifiers  and a current test script . The script parser logic  produces the test script statement vectors  based on the current test script . The economic cost model logic  analyzes the test script statement vectors  to generate synthetic GAP change specifiers . The economic cost model logic  uses the received GAP change specifiers  and generated synthetic GAP change specifiers  to locate and retrieve GUI element change cost rules  from the economic models  repository. In one implementation, the received GAP change specifiers  and generated synthetic GAP change specifiers  are indistinguishable as to their origin such that the economic cost model logic  processes the received GAP change specifiers  and generated synthetic GAP change specifiers  uniformly, regardless of their origin.","In another implementation, the economic cost engine  receives GAP change specifiers , a current test script  and a current GAP version . The economic cost engine  analyzes the GAP change specifiers  and the current GAP version  (e.g., current GAP tree model) to generate synthetic GAP change specifiers . The economic cost engine  analyzes the test script statement vectors  corresponding to the current test script  and the GUI difference model  to generate synthetic GAP change specifiers . The economic cost model logic  uses the received GAP change specifiers  and generated synthetic GAP change specifiers  to locate and retrieve GUI element change cost rules  from the economic models  repository and generate the test script transformation cost report .","In one implementation, the economic cost engine  receives a current test script  and a GUI difference model , without GAP change specifiers . The economic cost engine  analyzes the test script statement vectors  corresponding to the current test script  and the GUI difference model  to generate synthetic GAP change specifiers .","In one implementation, the economic cost engine  receives GAP change specifiers , a current test script , a GUI difference model  corresponding to the GAP version  and a subsequent GAP version . The economic cost engine  analyzes the test script statement vectors  corresponding to the current test script  and the GUI difference model  to generate synthetic GAP change specifiers . The economic cost engine  uses the received GAP change specifiers  and generated synthetic GAP change specifiers  to locate and retrieve GUI element change cost rules  from the economic models  repository and generate the test script transformation cost report .","In one implementation, the accuracy of the GUI transformation costs  varies due to the granularity of the information received by the economic cost engine . For example, the GUI transformation costs  generated as a result of the economic cost engine  receiving GAP change specifiers , a current test script , and a GUI difference model  may have a higher level of accuracy than the GUI transformation costs  generated based solely on received GAP change specifiers . The economic cost engine  may employ various economic models to preserve the accuracy of the GUI transformation costs  and compensate for the varying granularities of information provided to the economic cost engine .","In one implementation, GAP change specifiers  and\/or synthetic GAP change specifiers  include a model specifier , a GUI change frequency , skill coefficients , complexity identifier , quality identifier , percent of change , wrong path-delete type , wrong path-same type  and changed element type  specifiers. The model specifier  specifies one or more economic models to use from among multiple economic models accessible by the economic model logic . In one implementation, the model specifier  specifies one or more economic models for the economic cost model logic  to use corresponding to the varying granularities of information provided to the economic cost engine , so that the accuracy of the GUI transformation costs  are preserved. For example, the model specifier  may specify models corresponding to one or more of the multiple combinations of available information received by the economic cost engine , including: 1) model- for GAP change specifiers ; 2) model- for GAP change specifiers  and a current test script ; 3) model- for GAP change specifiers , a current test script  and a current GAP version ; 4) model- for a current test script  and a GUI difference model  with GUI difference entries ; and 5) model- for GAP change specifiers , a current test script , and a GUI difference model  with GUI difference entries .","The GUI change frequency  indicates the number of occurrences of a particular GUI element change. In one implementation, the economic cost model logic  includes a user adjustable GUI change efficiency factor  that indicates whether a GUI change frequency  above a particular threshold results in a lower GUI transformation cost . For example, a GUI change efficiency factor  of 0.50 indicates that the GUI transformation cost  for each change above a threshold of 100 occurrences for a given GUI element change are adjusted by 50 percent. In other words, where a particular GUI element change is identified to have 120 occurrences, the economic cost model logic  applies the GUI change efficiency factor  of 0.50 to the GUI transformation cost  for the 20 changes above the threshold of 100. In another example, a GUI change efficiency factor  of 0.00 may indicate that no efficiency is realized regardless of the GUI change frequency  value.","In one implementation, the skills coefficients  include one or more coefficients that are used to describe the level of experience of the testers who are expected to test the subsequent GAP version . The skills coefficients  may include individual coefficients for specific areas of testing experience. For example, the skills coefficients  may correspond to the skill and experience level of testers according to particular phases of testing such as unit, integration, system and final test phase so that each phase is represented by one or more coefficients. In another example, the skills coefficients  may correspond to skills and experience corresponding to testing particular aspects of the subsequent GAP version , such as security and user authentication, numerical computations specific to the GAP, and network and infrastructure.","In another implementation, the skills coefficients  are calibrated based on performance metrics located in a performance metrics repository  and\/or cost reports repository . GAP change specifiers  and\/or synthetic GAP change specifiers  may be constructed and\/or generated from historical performance metrics found in a performance metrics repository  and\/or cost reports repository . The skills coefficients  of the constructed GAP change specifiers  and\/or synthetic GAP change specifiers  may be adjusted over multiple iterations to obtain GUI transformation costs  and test script transformation cost reports  that are within acceptable margins of variance to the actual costs reflected in the performance metrics repository . The accuracy of the GUI transformation costs  obtained by the economic cost model logic  may be based on how well the skills coefficients  are calibrated to reflect the testing resources available to test the subsequent GAP version . In one implementation, the skills coefficients  influence the complexity identifier , discussed in further detail below.","The economic cost model logic  uses the skills coefficients  to obtain the GUI transformation costs . For example, a skills coefficient  value of 1.0 may indicate that testers with little experience are expected to be used to test the subsequent GAP version  and higher GUI transformation costs  may result to reflect the low experience. In another example, a skills coefficient  value of 8.0 may indicate testers with higher than average testing experience and lower GUI transformation costs  may result that reflect the higher than average experience. The economic cost model logic  may analyze whether the skills coefficients  and complexity ranking  correlate, and obtain correspondingly higher or lower GUI transformation costs . For example, the skills coefficients  may indicate that the testers are capable of testing a GAP with a particular level of complexity, as indicated by the complexity ranking , so that lower GUI transformation costs  are obtained. In another example, the skills coefficients  may indicate that the testers lack a skill and experience level for testing a GAP with a particular level of complexity corresponding to the complexity ranking , so that higher GUI transformation costs  are obtained to reflect the lack of skills and experience of the testers and the expected time and resources to test the subsequent GAP version .","In one implementation, the complexity identifier  numerically identifies the level of complexity of a GUI element change (e.g., values 0 to 10), determined by the economic cost model logic , corresponding to a generated synthetic GAP change specifier . In another implementation, the complexity identifier  identifies the level of complexity determined by a tester and received by the economic cost model logic  with the GAP change specifier . Distinguishing the complexity identifier  of the GAP change specifier  and\/or synthetic GAP change specifier  from the complexity ranking  of the GUI element change cost rule , the complexity identifier  represents analysis that is external to the economic models  repository. The economic cost model logic  may analyze the complexity ranking  and complexity identifier  to assess the accuracy of the GUI transformation costs  obtained by applying the GUI element change cost rule .","For example, the economic cost model logic  may determine that the complexity ranking  and complexity identifier  corresponding to a particular GUI element change are within an acceptable margin of variance such that the GUI transformation cost  is not adjusted as a result. In another example, the economic cost model logic  may determine that the complexity ranking  and complexity identifier  corresponding to a particular GUI element change are outside of an acceptable margin of variance and the GUI transformation costs  are adjusted upward by a multiplier. The margin of variance and the multiplier, determined by analyzing the complexity ranking  and complexity identifier , may be user selectable and\/or adjustable. In one implementation, the complexity identifier  is based on the skills coefficients  such that the complexity of a GUI element change is assessed relative to the skills and experience of the available testers. The skills coefficients  may be calibrated so that the complexity ranking  and the complexity identifier  generated by the economic cost model logic  are within an acceptable margin of variance.","In one implementation, the quality identifier  numerically identifies the level of quality contributed to by a GUI element change (e.g., values 0 to 10), determined by the economic cost model logic , corresponding to a generated synthetic GAP change specifier . In another implementation, the quality identifier  identifies the level of quality determined by a tester and received by the economic cost model logic  with the GAP change specifier . Distinguishing the quality identifier  of the GAP change specifier  and\/or synthetic GAP change specifiers  from the quality ranking  of the GUI element change cost rule , the quality identifier  represents analysis that is external to the economic models  repository. The economic cost model logic  may analyze the quality ranking  and quality identifier  to assess the accuracy of the GUI transformation costs  obtained by applying the GUI element change cost rule . For example, the economic cost model logic  may determine that the quality ranking  and quality identifier  corresponding to a particular GUI element change are within an acceptable margin of variance such that the GUI transformation cost  is not adjusted as a result. In another example, the economic cost model logic  may determine that the quality ranking  and quality identifier  corresponding to a particular GUI element change are outside of an acceptable margin of variance and the GUI transformation costs  are adjusted upward by a multiplier. The margin of variance and the multiplier, determined by analyzing the quality ranking  and quality identifier , may be user selectable and\/or adjustable.","In one implementation, the economic cost engine  receives a GAP change specifier  that includes a percent of change  value, a current test script  and a current GAP tree model corresponding to a current GAP version  that the economic cost engine  uses to generate synthetic GAP change specifiers , and locate and retrieve GUI element change cost rules  from the economic models  repository. For example, the economic cost model logic  analyzes the current GAP version  (e.g., represented by a current GAP tree model) and generates synthetic GAP change specifiers  that reflect a percentage of change to the current GAP version  corresponding to the percent of change  value (e.g., ranging from 1 to 100). The economic cost model logic  analyzes the current GAP version  and identifies a set of proposed GUI elements changes that correspond to the percent of change  value. The economic cost model logic  may identify the proposed GUI elements by analyzing the GUI elements in the GAP tree model of the current GAP version  in a random order, the order in which the GUI elements are presented in the tree model from top to bottom or from bottom to top.","In one implementation, the proposed GUI element changes may be determined based on the complexity identifier  and\/or quality identifier  included in the received GAP change specifier . For example, the economic cost model logic  receives a GAP change specifier  that includes a complexity identifier  value of 1 and quality identifier  value of 2, and for each of the proposed GUI elements to be changed, determines proposed changes corresponding to the complexity identifier  value of 1 and the quality identifier  value of 2. The economic cost model logic  may locate, in the performance metrics repository  and\/or cost reports repository , proposed GUI element changes corresponding to the complexity identifier  values and the quality identifier  values. In one implementation, the economic cost model logic  generates synthetic GAP change specifiers , as a result of analyzing the proposed GUI element changes. In another implementation, the economic cost model logic  identifies proposed GUI element changes corresponding to the complexity identifier , the quality identifier  and skill coefficients .","The economic cost model logic  analyzes the current test script  and GUI difference model  to generate synthetic GAP change specifiers  based on validated GUI element changes (e.g., GUI element difference entries). For example, the economic cost model logic  determines test script statement vectors  that need modification because GUI objects that are referenced in the current test script  and exist in the current GAP version  that do not exist in the subsequent GAP version , and the economic cost model logic  generates synthetic GAP change specifiers  that reflect the needed changes to the current test script . The economic cost model logic  identifies changes to test script statement vectors  that set the values of GUI objects that are compatible with the class of that GUI objects, so that constraints imposed on the GUI objects as a result of a change are not violated. In one implementation, the economic cost model logic  verifies that incorrect operations are not specified by GAP change specifiers  and\/or synthetic GAP change specifiers  used to obtain GUI transformation costs .","The economic cost model logic  may infer GUI class information regarding a GUI object that is present in a navigation path of test script statement vectors , and whose presence is not explicitly defined. For example, when the test script statement vector  employs expressions that identify GUI objects whose values can only be determined at runtime, the OR lookup logic  may use path traversal logic  to identify the possible corresponding GUI object entries  and GUI element difference entries  in the object repository  and GUI difference model , respectively. The economic cost model logic  then identifies the valid GUI object entries  that may substitute for the expressions and GUI element difference entries  that satisfy valid test script statement vectors , and the economic cost model logic  generates corresponding synthetic GAP change specifiers .","For example, consider the test script statement vector : VBWindow(\u201cs\u201d).VBWindow(e1).VBWindow(e2).VBWindow(\u201cd\u201d), where the source node GUI object is named \u201cs\u201d, the destination node GUI object is named \u201cd\u201d, but expressions e1 and e2 compute values of intermediate nodes in the navigation path at runtime. The traversal logic  determines intermediate nodes (GUI objects) that may be included in the possible navigation paths identified by the source node \u201cs\u201d and destination node \u201cd\u201d. The path traversal logic  analyzes the GUI difference model  to identify possible constant substitutions for e1 and e2, for example, \u201ca\u201d and \u201cf\u201d, so that the test script statement vector  formed by the substitute GUI objects in the navigation path expression \u201cs.a.f.d\u201d can be validated by economic cost model logic . By identifying the possible navigation paths leading to the destination node d starting with the source node \u2018s\u2019 the economic cost model logic  can conclude whether to generate a synthetic GAP change specifier  based on the substitute GUI objects. In the event the traversal logic  does not identify at least one navigation path, then the transformed test script statement  is invalid. Alternatively, in the event the traversal logic  identifies navigation paths leading from \u2018s\u2019 to \u2018d\u2019 by traversing two objects (e.g., e1 and e2), then the transformed test script statement  may be valid provided that expressions e1 and e2 evaluate to the names of the nodes in the discovered navigation paths. The traversal logic  infers the possible names computed by expressions e1 and e2 at compile time. In other words, there is a direct correlation between the complexity of test scripts and the economic cost to transform test scripts and use those test scripts to test subsequent GAP versions . The complexity is a function of the number of referenced GUI objects and operations on the GUI objects, as well as the amount of logic needed to process the data that is extracted and placed into those GUI objects.","Referring to , the economic cost model logic  may infer GUI class information regarding GUI objects that are present in the navigation path of test script statement vectors . The economic cost model logic  identifies GAP change specifiers  and\/or synthetic GAP change specifiers  that resolve test script statement vectors  that attempt to access GUI objects that do not exist in a subsequent GAP version  and\/or attempt to set a value of a GUI object that is not compatible with the type of the GUI object. The economic cost model logic  type checks test script statement vectors  against the GUI difference model  before generating corresponding GAP change specifiers .","The economic cost model logic  uses inheritance and sub-typing relations between classes of GUI objects to validate received GAP change specifiers  and generate valid synthetic GAP change specifiers . The concept of class includes hierarchical containments (e.g., GUI scopes and system hierarchies). The object repository  and the GUI difference model  include GUI class information (e.g., annotating the classes of GUI objects) for each GUI object entry  and GUI element difference entry . For example, referring to line  of Table 12, the SchoolListBox is a WinObject class with properties listed at lines -. In another example, referring to ,  and , at line  of each GUI difference entry (e.g., ,  and ) the GUIElement Type is indicated. The class of each GUI object is indicated as shown in ,  and  at lines ,  and , respectively. The class of a GUI object indicates that the GUI object includes particular attributes, properties and\/or traits in common with other GUI objects of the same class that may be extended to and\/or inherited by child GUI objects. For example,  at line  indicates that the StateListbox GUI object is of a WindowsForms10.ListBox.app4 class that includes values, as indicated at line  of .","Referring again to , in one implementation, the economic cost model logic  determines whether a GUI object has changed and sets the GUI element change status . For example, the GUI element change status  may use a numerical indicator of 0, 1, and 2, respectively, to indicate no change, and a change with and without a particular constraint violation. The economic cost model logic  may use the GUI element change status  to facilitate identifying the appropriate GAP change specifiers  and\/or synthetic GAP change specifiers .","In another implementation, the GUI element change status  is a message that provides a detail description of a change. The GUI element change status  may also indicate with a numerical indicator (e.g., \u22121) that the GUI object has been deleted from the subsequent GAP version . When a GUI object has been deleted from the subsequent GAP version , the economic cost model logic  generates one or more synthetic GAP change specifiers  that specify corresponding changes to the current test script  and the current GAP version . In one implementation, the economic cost model logic  generates synthetic GAP change specifiers  that correspond to different, but programmatically equivalent, approaches to changing the current test script  and the current GAP version , so that a programmer may evaluate the GUI transformation costs  and test script transformation cost report.",{"@attributes":{"id":"p-0440","num":"0444"},"figref":"FIG. 40","b":["4000","3922","174","3912","3916","4002","3912","4004","4006","3912","4008","4010","3912"]},"The script parser logic  identifies the last node in the ordered sequence as the destination node and assigns a sequence identifier to the destination node that indicates the position of the destination node in the ordered sequence (). The OR lookup logic  performs an object repository lookup for each GUI object corresponding to the ordered sequence of nodes to which the test script statement vector navigates so that each GUI object entry  is identified (). In one implementation, the ordered sequence of nodes is used by the path traversal logic  and economic cost model logic  to validate the statements of the current test script , and\/or validate received GAP change specifiers  and generate valid synthetic GAP change specifiers . In one implementation, the economic cost engine  uses the ordered sequence of nodes to infer GUI class and inheritance (subclass) information for GUI objects. Where at least one of the source, destination and\/or the intermediate nodes are expressions that can only be identified at run-time, the path traversal logic may identify possible GUI object entries , and the economic cost model logic  determines the GUI object entries  that satisfy the test script statement vector . The OR lookup logic  retrieves the properties of the GUI object entries  to which the test script statement vector navigates ().",{"@attributes":{"id":"p-0442","num":"0446"},"figref":"FIG. 53","b":["5300","3910","3922","172","3916","172","3924","3910","5302","3910","3924","3910","5304","3924","3910","3910","5306","4996","3910","5308"]},"The economic cost model logic  identifies the GUI element difference entries  that correspond to each of the GUI object entries  forming a valid navigation path (). The economic cost model logic  determines the synthetic GAP change specifiers  to generate and\/or validates the GAP change specifiers  based on the type of GUI element change (e.g., , ,  and\/or GUI element change status ), based on analyzing the GUI object entry  and GUI element difference entry  (). The economic cost model logic  generates valid synthetic GAP change specifiers  corresponding to the type of GUI element change identified. When the path traversal logic  identifies a navigation path that traverses an invalid number of GUI element difference entries  between corresponding source and destination node GUI difference entries , the path traversal logic  indicates that the navigation path is invalid ().",{"@attributes":{"id":"p-0444","num":"0448"},"figref":["FIG. 54","FIG. 50","FIG. 54","FIG. 50"],"b":["5400","152","4996","4984","5400","4996","4984","1","3","5000","1","5","7","162","4996","2","4","5400","6","184","4984","162","182","4984","16","5000","24","25","1"]},{"@attributes":{"id":"p-0445","num":"0449"},"figref":"FIG. 55","b":["5500","4984","4996","184","4984","152","152","182","5000","150","184","5502","182","3922","174","3910","162","5504","182","150","162","184","4984","5290","4996","5506"]},"GUI object changes of types A () and B () occur when GUI objects are added and removed correspondingly from current GAP version  and subsequent GAP version . For example, adding the WinObject menustrip  to the subsequent GAP version  is a type A change, while removing the WinObject \u201cSelect School\u201d  is a type B GUI object change. Referring to , notice that the \u201cSelect School\u201d has been removed at .","An example of a type C change () is the change of the window name from StateList  to School . Adding or removing values from GUI objects such as list and combo boxes are examples of modifications of the type D change (). For example, the listbox StateListbox  in current GAP version  is identified in the subsequent GAP version  as StateListbox , and referring to the GUI difference entry  the values for SeqNumber=\u201c8\u201d are \u201cDistrict of Columbia\u201d and \u201cFlorida\u201d for successive GAP versions, respectively. Changing the \u201ctype\u201d of a GUI object may include replacing a class of the window that is used to represent the object and\/or changing the high-level concept that describes the values that the GUI object takes. For example, changing the type of the static label to a read-only combo box is a modification of the type E (). Another example of a type E change includes the change of the listbox \u201cSchooListbox\u201d  to a combobox \u201cSchoolCombobox\u201d .","The economic cost model logic  receives GAP change specifiers  and generates synthetic GAP change specifiers  that include wrong path-delete type  wrong path-same type  and changed element type  specifiers. Wrong path-delete type  specifies that a GUI object in the current GAP version  may have been deleted in the subsequent GAP version  (e.g., see \u201cSelect School\u201d  and  as shown in ), although the current test script  refers to the GUI object (). Wrong path-same type  specifies that a GAP change may result in a read and\/or write to the wrong GUI object. For example, a method may be invoked on the wrong GUI object based on a particular GAP change. Wrong path-same type  specifies that a GUI object in a current GAP version  has been modified and\/or another GUI object has been added to the subsequent GAP version  that may result in the wrong GUI object being navigated to by a test script statement ().","For example, consider the statement in lines  and  of the current test script  and transformed test script , respectively:",{"@attributes":{"id":"p-0450","num":"0454"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003Window(\u201cStateList\u201d).Dialog(\u201cOpen\u201d).-"]},{"entry":[{},"\u2003\u2003WinListView(\u201cSysListView32\u201d).Select"]},{"entry":[{},"\u201cuniversity.data\u201d."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The statement selects \u201cuniversity.data\u201d from a WinListView \u201cSysListView32\u201d. However, lines - of the transformed test script  may navigate to and invoke the Select method on the wrong GUI object \u201cuniversity.data\u201d, because the GUI objects referenced in lines - of the transformed test script  are new GUI objects that are not referenced in the current test script . Thus, when the properties of existing GUI objects are modified and\/or other GUI objects are added into a subsequent GAP version , the result of interference of these operations is that transformed test script statements that result from applying GAP change specifiers  and\/or synthetic GAP change specifiers  to current test script statement vectors  may access and read values of objects that are different from those as originally intended.","Changed-element  specifies that the type, properties, and\/or default values of a GUI object referenced by a test script statement vector  have changed in the subsequent GAP version  (). For example, the GUI difference entry  indicates that there are different values for SeqNumber=\u201c8\u201d are \u201cDistrict of Columbia\u201d and \u201cFlorida\u201d for successive GAP versions, and the economic cost model logic  may generate a synthetic GAP specifier  that includes a change-element  correspondingly. Change-element  may also specify that new constraints have been imposed on a GUI object that conflict with test script statement vectors , for example, attempting to write data to a previously writable text box that has been changed to a read-only text box.","Referring to the GUI element difference entry shown in Table 13, the WinObject \u201cAcadScale\u201d referred to in the current test script  at line  is an editable object that has been transformed into the WinObject \u201cAcademics (1-5)\u201d in the subsequent GAP version  where the object is read-only. The economic cost model logic  validates GAP change specifiers  and\/or generates the synthetic GAP change specifier  with the GAP change type specified (), and the GUI element change status  is updated (). In one implementation, the economic cost model logic  does not generate synthetic GAP change specifiers  for GUI objects that have not changed between successive GAP versions ().","Knowing the modification type for a GUI object facilitates the economic cost model logic  to determine the appropriate synthetic GAP change specifiers  to generate and\/or validate received GAP change specifiers . For example, the economic cost model logic  may validate GAP change specifiers  and\/or generate one or more synthetic GAP change specifiers  that specify changes to test script statement vectors  that attempt to set values in a text box object that has been changed to a read-only combo box. GAP change specifiers  and\/or synthetic GAP change specifiers  may specify that the test script statement vector  be modified (transformed) to select values in the combo box using appropriate interfaces rather than attempting to set values in the text box.","The economic cost model logic  determines whether GUI objects have been removed from a current GAP version  and locates the test script statement vectors  that reference these removed objects in the current test script . The economic cost engine  refers to these statements as first-reference statements (FRS). The variables used in these statements are obtained, and the statements that use the variables whose values are defined in the FRSs are referred to as secondary reference statements (SRS). The economic cost model logic  determines whether GUI objects may have been deleted in the subsequent GAP version , and validates received GAP change specifiers  and generates one or more corresponding synthetic GAP change specifiers  with a wrong path-delete . When a statement of the current test script  refers to a variable whose value points to a removed GUI object, the statement of the current test script  is considered an SRS. In one implementation, the economic cost engine  generates one or more synthetic GAP change specifiers  and\/or validates received GAP change specifiers  corresponding to the identified SRSs.","When the values of one or more attributes of a GUI object are modified, a type C modification is performed. FRSs and SRSs are identified for the GUI object with the modified attributes, and corresponding synthetic GAP change specifiers  are generated and\/or received GAP change specifiers  are validated. When the values of GUI objects are added or removed, modifications of the type D occur. After locating FRSs that reference GUI objects whose values have been changed, SRSs are found and the economic engine  determines the impact due to the SRSs. When the type of a GUI object is modified then a modification of the type E occurs that involves locating FRSs, checking the new types of the GUI object, invoking corresponding type sub-sumption rules. The economic cost model logic  may analyze the modified GUI objects to determine whether to generate synthetic GAP change specifiers  with change-element type  where GUI objects whose types, properties, or default values are changed in a subsequent GAP version , and\/or attempting an operation on a GUI object that does not take into consideration new constraints imposed on the elements of the GUI object.","The economic cost model logic  analyzes each GUI object referred to in the current test script  and\/or current test script , the current GAP version , received GAP change specifiers , generated synthetic GAP change specifier , and\/or GUI element change status . The economic cost model logic  locates, in the economic models  repository, the economic model specified by the model specifier , and retrieves a GUI element change cost rule  with a change specifier identifier  corresponding to the GAP change specifier  and\/or synthetic GAP change specifier . In one implementation, the economic cost model logic  combines one or more attributes of a GUI object (e.g., type and\/or class) with the GUI element change status , the model specifier , the wrong path-delete type , wrong path-same type  and\/or changed element type  to form a unique identifier used to locate a corresponding change specifier identifier  in the economic model specified by the model specifier .","The economic model logic  analyzes the GUI element change cost rule  components, GAP change specifier  and\/or synthetic GAP change specifier  components, preference identifiers  and GUI change efficiency factor  to determine whether to adjust the GUI change cost estimate . For example, the economic cost model logic  adjusts the GUI change cost estimate  based on whether the skills coefficients , complexity identify , quality identifier , system resource utilization identifiers , quality ranking , and\/or complexity ranking  are within an acceptable variance as specified by the preference identifiers . The economic cost model logic  obtains the GUI transformation cost  based on the adjusted GUI change cost estimate . In other words, the GUI change cost estimate  is adjusted to obtain the GUI transformation cost for the GAP change specifier  and\/or synthetic GAP change specifier . The economic cost model logic  processes each received GAP change specifier  and\/or generated synthetic GAP change specifier  to obtain the corresponding GUI transformation costs  and generates the test script transformation cost report  with the GUI transformation costs .",{"@attributes":{"id":"p-0459","num":"0463"},"figref":"FIG. 56","b":["186","162","182","162","140","5604","182","3914","3916","5606","3912","3916","3916","5608","182","172","3916","174","5610","3924","3910","3916","5612","4996","184","4984","5614","4996","4984","164","150","162","5616","4996","5268","5246","184","4984","5246","5248","5618","4996","186","5248","5620"]},"In one implementation, the economic cost engine architecture  uses adaptive programming including class and object graphs and an abstraction that treats all objects uniformly. The path traversal logic  and the economic cost model logic  may distinguish complex and simple types of GUI objects. Given a GUI object of some type, the traversal logic  and the economic cost model logic  work together to identify one or more reachable objects that satisfy certain criteria. The task performed is equivalent to determining whether test script statement vectors  that describe navigation paths are valid. The task of static checking of test scripts (e.g., transformed test scripts ) is greatly simplified when the names of foreign components names are defined as string constants. When the names of GUI objects are specified using expressions, the values of these expressions may not be determined until run-time. Type graphs facilitate the economic engine system  to infer types of expressions and variables that hold the names of GUI objects. The economic engine system  applies concepts based on the Traversal Graph Analysis (TGA) defined in adaptive programming to infer types of expressions and variables.","When the values of string expressions in test scripts statements cannot be computed until run-time, the string expressions may be inferred. The path traversal logic  and the economic cost model logic  work together to analyze test script statements vectors , using type graphs by transforming test script statements vectors  into an adaptive strategy with variables replacing string expressions. The economic cost model logic  computes possible values for each variable and generates traversal paths for each strategy. Where at least one path is identified, then a corresponding GAP change specifier  is validated and\/or a synthetic GAP change specifier  is generated, since values of expressions that compute names of objects may not be in the computed paths. The path traversal logic  identifies one or more possible paths, while the economic cost model logic  validates paths for the expressions and statements.","The economic engine system  provides modularization integrity as a mechanism for ensuring the validity of GAP change specifiers  and\/or synthetic GAP change specifiers . Modularization integrity specifies that each current test script statement identified by a GAP change specifier  and\/or a synthetic GAP change specifier  to be changed may only communicate directly with the objects that belong to GUIs for which the current test script statement, as changed by the GAP change specifier  and\/or a synthetic GAP change specifier , is created. Compositions of current test script statements changed as specified by GAP change specifiers  and\/or synthetic GAP change specifiers , in which GUI objects are accessed by calling functions exported by the current test script statements changed as specified, should not violate modularization integrity. The economic engine system  ensures the modularization integrity of GAP change specifiers  and\/or synthetic GAP change specifiers  by analyzing compositions of current test script statements changed as specified by GAP change specifiers  and\/or synthetic GAP change specifiers  to build the transitive relations between the current test script  and the current test script  changed as specified by the GAP change specifiers  and\/or synthetic GAP change specifiers  (e.g., transformed test script  and ).","For example, a statement Func(\u201cy\u201d, \u201cz\u201d), found in a suite of related test scripts, navigates to the field z of foreign GUI object y in some test scripts that export function Func. Thus, the some test scripts in the suite of related test scripts may violate the modularization integrity by implicitly interoperating the test scripts via the function Func even though this communication may be prohibited by the constraints of a given test suite. In one implementation, the economic engine system  encodes modularization constraints when defining test scripts using the keyword constraints as part of a global comment in each test script. These constraints define GAPs and their GUI screens as well as other test scripts with which a given test script may communicate. An example is a statement that specifies a constraint is constraints screen(\u201cQ\u201d) test_scripts(\u201cP, S\u201d). This constraint effectively prohibits a given test script from communicating with other GAPs, GUI screens, and test scripts, except the screen Q and test scripts P and S, explicitly or implicitly.","The time complexity of the path traversal logic  and the economic cost model logic  is exponential to the size of the type graph for each test script . Because the path traversal logic  and the economic cost model logic  involve the search of one or more nodes and edges in the type graph that contains cycles for each node in the strategy, the time complexity is O((V+E)) where V is the number of nodes, E is the number of edges in the type graph, and max(|\u03c0|) is the maximum number of nodes in strategies. The operations of storing successors in the table of variables take O(1). In general, the number of nodes max(|\u03c0|) in strategies is much smaller than the number of nodes in type graphs. All graph nodes may not need to be explored for each node in a strategy.","The systems may be implemented in many different ways. For example, although some features are shown stored in computer-readable memories (e.g., as logic implemented as computer-executable instructions or as data structures in memory), all or part of the systems, logic, and data structures may be stored on, distributed across, or read from other machine-readable media. The media may include hard disks, floppy disks, CD-ROMs, a signal, such as a signal received from a network or partitioned into sections and received in multiple packets communicated across a network. The systems may be implemented in software, hardware, or a combination of software and hardware.","Furthermore, the systems may be implemented with additional, different, or fewer components. As one example, a processor or any other logic may be implemented with a microprocessor, a microcontroller, a DSP, an application specific integrated circuit (ASIC), program instructions, discrete analog or digital logic, or a combination of other types of circuits or logic. As another example, memories may be DRAM, SRAM, Flash or any other type of memory. The systems may be distributed among multiple components, such as among multiple processors and memories, optionally including multiple distributed processing systems. Logic, such as programs or circuitry, may be combined or split among multiple programs, distributed across several memories and processors, and may be implemented in or as a function library, such as a dynamic link library (DLL) or other shared library.","While various embodiments have been described, it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the invention. Accordingly, the invention is not to be restricted except in light of the attached claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The system may be better understood with reference to the following drawings and description. The elements in the figures are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the system. In the figures, like-referenced numerals designate corresponding parts throughout the different views.",{"@attributes":{"id":"p-0022","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0028","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0029","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0030","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0031","num":"0035"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0032","num":"0036"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0033","num":"0037"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0034","num":"0038"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0035","num":"0039"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0036","num":"0040"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0037","num":"0041"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0038","num":"0042"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0039","num":"0043"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0040","num":"0044"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0041","num":"0045"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0042","num":"0046"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0043","num":"0047"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0044","num":"0048"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0045","num":"0049"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0046","num":"0050"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0047","num":"0051"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0048","num":"0052"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0049","num":"0053"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0050","num":"0054"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0051","num":"0055"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0052","num":"0056"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0053","num":"0057"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0054","num":"0058"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0055","num":"0059"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0056","num":"0060"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0057","num":"0061"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0058","num":"0062"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0059","num":"0063"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0060","num":"0064"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0061","num":"0065"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0062","num":"0066"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0063","num":"0067"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0064","num":"0068"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0065","num":"0069"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0066","num":"0070"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0067","num":"0071"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0068","num":"0072"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0069","num":"0073"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0070","num":"0074"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0071","num":"0075"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0072","num":"0076"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0073","num":"0077"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0074","num":"0078"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0075","num":"0079"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0076","num":"0080"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0077","num":"0081"},"figref":"FIG. 56"}]},"DETDESC":[{},{}]}
