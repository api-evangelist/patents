---
title: Bindless texture and image API
abstract: One embodiment of the present invention sets for a method for accessing data objects stored in a memory that is accessible by a graphics processing unit (GPU). The method comprises the steps of creating a data object in the memory based on a command received from an application program, wherein the data object is organized non-linearly in the memory, transmitting a first handle associated with the data object to the application program such that data associated with different draw commands can be accessed by the GPU, wherein the first handle includes an address related to the location of the data object in the memory, receiving a first draw command as well as the first handle from the application program, and transmitting the first draw command and the first handle to the GPU for processing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09349154&OS=09349154&RS=09349154
owner: NVIDIA Corporation
number: 09349154
owner_city: Santa Clara
owner_country: US
publication_date: 20110331
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","BINDLESS TEXTURES AND IMAGES"],"p":["This application claims benefit of United States provisional patent application entitled \u201cBindless Memory Access\u201d, filed on Apr. 5, 2010 and having Ser. No. 61\/321,090.","1. Field of the Invention","The present invention relates generally to accessing texture objects and image objects in GPU memory and, more specifically, to a bindless texture and image application programming interface (API) for OpenGL\u00ae.","2. Description of the Related Art","OpenGL\u00ae treats graphics concepts like textures, vertex buffers, shaders, constant buffers, and the like as opaque \u201cobjects\u201d without exposing, to an application that references the objects, address details of the objects within a memory. Typically, the application binds such objects together and into a fixed set of hardware \u201cunits,\u201d e.g., texture units, vertex streams, constant buffer slots, or the like, through, e.g., API calls, without ever being aware of or having access to a physical address of the objects within the memory. Between the execution of graphics commands, e.g., Draw( ) commands, application programs frequently require access to different objects. In turn, the API is required to bind such new objects to the set of hardware units, which is costly. For example, significant processing overhead is introduced by requiring a driver to iterate a plurality of pointers per object to validate that the objects are properly located within the memory. As a result, a substantial bottleneck has developed in modern 3D graphics processing.","As the foregoing illustrates, what is needed in the art is a mechanism for accessing data objects without causing a graphics driver bottleneck.","One embodiment of the present invention sets forth a method for accessing data objects stored in a memory that is accessible by a graphics processing unit (GPU). The method comprises the steps of creating a data object in the memory based on a command received from an application program, wherein the data object is organized non-linearly in the memory, transmitting a first handle associated with the data object to the application program such that data associated with different draw commands can be accessed by the GPU, wherein the first handle includes an address related to the location of the data object in the memory, receiving a first draw command as well as the first handle from the application program, and transmitting the first draw command and the first handle to the GPU for processing.","One advantage of the disclosed method is that the GPU driver does not have to operate on the data objects each time they are used.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["100","100","102","104","110","150","160","170","102","110","104","102","110","110","150","104","102","150","102","150","104","150","110","102","110","102","104","150","102","160","160","150","150","160","170"]},"The system memory  includes an application program , application data , a GPU driver  and GPU driver data . The application program  generates calls to a graphics API in order to produce a desired set of results, typically in the form of a sequence of graphics images. The application program  also transmits one or more shading programs to the graphics API for processing within the GPU driver . The high-level shading programs are typically source code text of high-level programming instructions that are designed to operate on one or more shaders within the GPU . The graphics API functionality is typically implemented within the GPU driver .","The GPU local memory  includes a set of machine code shader programs , a buffer object memory , texture  and frame buffer . The machine code shader programs  are transmitted from the GPU driver  to GPU local memory . The machine code shader programs  may include, without limitation, the machine code vertex shader program, the machine code geometry shader program, the machine code fragment shader program, or any number of variations of each. The buffer object memory  includes a uniform storage buffer , a texture buffer  and a vertex buffer . The uniform storage buffer  stores one or more uniform variables, also called \u201cuniforms.\u201d A uniform variable is held constant during a given invocation of the associated shader but may be altered between invocations. The texture buffer  stores data elements typically organized in one-dimensional arrays. The vertex buffer  stores data elements describing the position and other attributes of vertices provided as inputs to the vertex shader .","The GPU local memory  includes texture  and frame buffer . The frame buffer  includes at least one two-dimensional surface that is used to drive the display . The frame buffer  may include more than one two-dimensional surface so that the GPU  can render to one two-dimensional surface while a second two-dimensional surface is used to drive the display . Data stored within the texture  and the frame buffer  is typically accessed with the assistance of application specific hardware that provides for a dimensional access view of the data. For example a two-dimensional surface may be addressed with the assistance of a hardware unit that transposes a horizontal and vertical surface location into a physical memory address that corresponds to the location.","The GPU  includes a vertex shader , a geometry shader  and a fragment shader  and a memory management unit (MMU) . As is well-known, the vertex shader  receives a sequence of one or more sets of vertex attributes, where each set of vertex attributes is typically associated with one vertex and one or more vertices are associated with a geometric primitive. The vertex shader  processes the vertex attributes, performing such operations as evaluating the vertex's position relative to the viewer and evaluating lighting equations to determine each vertex color. The vertex shader  may also use data from the buffer object memory  in the GPU local memory . For example, the vertex shader  may use data from the uniform storage buffer  or the texture buffer . The machine code vertex shader program executes on the vertex shader , imparting specific processing behavior according to specific requirements and specifications of the application program . The geometry shader  receives sets of processed vertices from the vertex shader . The geometry shader  performs per-primitive operations on vertices grouped into primitives such as triangles, lines, strips and points emitted by the vertex shader , enabling functionality such as shadow volume generation and procedural synthesis. The machine code geometry shader program executes on the geometry shader , imparting specific processing behavior according to specific requirements and specifications of the application program . A fixed-function rasterizer (not shown) that is situated between the geometry shader  and the fragment shader  scan converts an individual geometric primitive into a set of fragments with interpolated vertex attributes. The fragment shader  processes the fragments, each containing fragment data, which may include raster position, depth or interpolated vertex attributes, such as texture coordinates, opacity, and other relevant per-pixel data, to produce final pixel values. The final pixel values are stored in the frame buffer  by a fixed-function raster operations unit (not shown) that also performs operations such as depth and stencil tests as well as any blending of the final pixel values with values currently stored in the frame buffer. The machine code fragment shader program executes on the fragment shader , resulting in specific processing behavior according to specific requirements and specifications of the application program .","The display  is an output device capable of emitting a visual image corresponding to an input data signal. For example, the display may be built using a cathode ray tube (CRT) monitor, a liquid crystal display, or any other suitable display system. The input data signal to the display  is typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":["200","200","112","118","118","150","150"]},"The high-level shader programs transmitted by the application program  may include a high-level vertex shader program, a high-level geometry shader program and a high-level fragment shader program. Each of the high-level shader programs is transmitted through an API to the compiler\/linker  within the GPU driver . The compiler\/linker  compiles the high-level shader programs  into assembly language program objects.","Under shader programming model , domain-specific shader programs, such as high-level vertex shader program, high-level geometry shader program, and high-level fragment shader program, are compiled using a common instruction set target, supported by unified instruction set architecture (ISA) library . With the common instruction set, application developers can compile high-level shader programs in different domains using a core set of instructions having the same syntax and consequently should expect faster compile times for such shader programs. One example of this common ISA is supported by the Unified Instruction Set Architecture (\u201cISA\u201d) developed by NVIDIA Corporation, Santa Clara, U.S.A.","Compiler\/linker , which includes code generator  and unified ISA library , provides cross-domain linking capabilities. Specifically, compiler\/linker  translates the high-level shader programs designated for different domains (e.g., the high-level vertex shader program, the high-level geometry shader program, and the high-level fragment shader program), which are written in high-level shading language, into distinct compiled software objects in the form of assembly code. Further, instead of sending these compiled objects of assembly code individually to separate GPU microcode assemblers (not shown), compiler\/linker  also \u201clinks\u201d the compiled assembly code to generate a single compiled\/linked program object, also in the form of either assembly code or machine code. To link multiple compiled objects from different domains (also referred to as to \u201crendezvous\u201d), compiler\/linker  needs to reconcile the use of symbols across the domains. Specifically, there are generally two types of symbols, the first type being defined or exported symbols, and the second type being undefined or imported symbols. The first type of symbols broadly refers to functions or variables that are present in one compiled object (e.g., vertex shader assembly code) and should be made available for use by other compiled objects (e.g., geometry shader assembly code and\/or fragment shader assembly code). The second type of symbols broadly refers to functions or variables that are called or referenced by one compiled object (e.g., vertex shader assembly code) but are not internally defined within this compiled object.","The program objects are transmitted to the GPU microcode assembler , which generates machine code programs, including a machine code vertex shader program, a machine code geometry shader program and a machine code fragment shader program. The machine code vertex shader program is transmitted to a vertex processing unit  for execution. Similarly, the machine code geometry shader program is transmitted to a primitive processing unit  for execution and the machine code fragment shader program is transmitted to a fragment processing unit  for execution.","Shader programs can also be transmitted by the application program  via assembly instructions . The assembly instructions  are transmitted directly to the GPU microcode assembler  which then generates machine code programs, including a machine code vertex shader program, a machine code geometry shader program and a machine code fragment shader program, as previously described herein.","A data assembler  and the vertex processing unit  function as the vertex shader  of . The data assembler  is a fixed-function unit that collects vertex data for high-order surfaces, primitives, and the like, and outputs the vertex data to vertex processing unit . The data assembler  may gather data from buffers stored within system memory  and GPU local memory  as well as from API calls from the application program  used to specify vertex attributes. The vertex processing unit  is a programmable execution unit that is configured to execute a machine code vertex shader program, transforming vertex data as specified by the vertex shader programs. For example, vertex processing unit  may be programmed to transform the vertex data from an object-based coordinate representation (object space) to an alternatively based coordinate system such as world space or normalized device coordinates (NDC) space. The vertex processing unit  may read vertex attribute data directly from the GPU local memory  via the buffer load mechanism described below. The vertex processing unit  may read texture map data as well as uniform data that is stored in GPU local memory  through an interface (not shown) for use in processing the vertex data. The vertex shader  represents the vertex processing domain of the GPU .","A primitive assembler  and the primitive processing unit  function as the geometry shader . A second primitive assembler (not shown) may be included subsequent to the primitive processing unit  in the data flow through the GPU . The primitive assembler  is fixed-function unit that receives processed vertex data from vertex processing unit  and constructs graphics primitives, e.g., points, lines, triangles, or the like, for processing by primitive processing unit . The primitive processing unit performs well-known, fixed-function viewport operations such as clipping, projection and related transformations on the incoming vertex data. In the GPU , the primitive processing unit  is a programmable execution unit that is configured to execute machine code geometry shader program to process graphics primitives received from the primitive assembler  as specified by the geometry shader program. For example, in addition to well-known viewport operations, the primitive processing unit  may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters, such as plane equation coefficients, that are used to rasterize the new graphics primitives. The primitive processing unit  may read data directly from the GPU local memory  via the buffer load mechanism described below. Additionally, the primitive processing unit  may read texture map data that is stored in GPU local memory  through an interface (not shown) for use in processing the geometry data. The geometry shader  represents the geometry processing domain of the GPU . The primitive processing unit  outputs the parameters and new graphics primitives to a rasterizer . The rasterizer  is a fixed-function unit that scan-converts the new graphics primitives and outputs fragments and coverage data to the fragment processing unit .","The fragment processing unit  performs the functions of the fragment shader  of . The fragment processing unit  is a programmable execution unit that is configured to execute machine code fragment shader programs to transform fragments received from rasterizer  as specified by the machine code fragment shader program . For example, the fragment processing unit  may be programmed to perform operations such as perspective correction, texture mapping, shading, blending, and the like, to produce shaded fragments that are output to a raster operations unit . The primitive processing unit  may read data directly from the GPU local memory  via the buffer load mechanism described below. Additionally, the fragment processing unit  may read texture map data as well as uniform data that is stored in local memory  through an interface (not shown) for use in processing the fragment data. The raster operations unit  optionally performs fixed-function computations such as near and far plane clipping and raster operations, such as stencil, z test and the like, and outputs pixel data as processed graphics data for storage in a buffer in the GPU local memory , such as the frame buffer .",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 3","FIG. 1","FIG. 1","FIG. 2"],"b":["152","154","156","200"]},"The vertex shader  executes the machine code vertex shader program in order to process a stream of vertex attributes  received from the vertex buffer  or a vertex buffer unified memory  via the data assembler . The vertex attributes  received from the vertex buffer unified memory  are attached to a vertex state set in an application context of the application program . The vertex shader  may access data from additional sources, such as uniform data  from the uniform storage buffer  and texture data  from the texture buffer  or texture . The vertex shader results  are transmitted to the geometry shader , which processes the vertex shader results  according to the machine code geometry shader program. The geometry shader  may access data from additional sources, such as uniform data  from the uniform storage buffer  and texture data  from the texture buffer  or texture . The geometry shader results  are transmitted to the fragment shader . The fragment shader  executes the machine code fragment shader program in order to process the geometry shader results . The fragment shader  may access data from additional sources, such as uniform data  from the uniform storage buffer  and texture data  from the texture buffer  or texture . The output of the fragment shader  includes a stream of shaded pixels  that are written to the frame buffer .","In addition, each of the vertex shader , the geometry shader  and the fragment shader  may retrieve data from and write data to buffer objects (illustrated as shader load\/stores ) stored within the buffer object memory  via the buffer load\/store mechanism . Similarly, each of the vertex shader , the geometry shader  and the fragment shader  may retrieve texture data and write texture data to image units stored within texture memory  via the image load\/store mechanism .","The present invention provides a technique for directly referencing texture objects and image objects. By allowing the GPU  to refer to the objects directly rather than through, e.g., texture units\u2014as required in previous approaches\u2014the need for binding is eliminated. This avoids overhead on the CPU , since the GPU driver  does not have to repeatedly validate the objects being bound and does not have to manage its collection of binding points. As a result, the application program is able to rapidly switch between the objects by fetching different constants\u2014hereinafter referred to as \u201chandles.\u201d Additionally, this mechanism gives the application access to an effectively unlimited number of texture objects and image objects. Moreover, the present invention provides a technique wherein the objects can be made \u201cresident,\u201d where such objects are \u201clocked\u201d within GPU local memory  and require only a single initialization operation to be made available to the application program for the duration of its execution.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIGS. 1-3"],"b":"160"},"The method  begins at step , where the GPU driver  receives a request from the application program  to create a data object, e.g., a texture object, an image object, or the like, in the GPU local memory . At step , the GPU driver  creates the data object based on the request received from the application program . At step , based on a request received from the application program , the GPU driver  returns a handle associated with the data object created in the GPU local memory . At step , the GPU driver  receives a request from the application program  to make the data object resident such that it is guaranteed to be accessible to the GPU . In response, at step , the GPU driver  locks the data object in the buffer object memory  or texture buffer .","At step , a shader engine in the GPU , such as the vertex shader , performs one or more graphics commands on the resident data object, e.g., a graphics draw command that references a texture object. At step , the GPU driver  receives a request from the application program  to make the data object non-resident. In response, at step , the GPU driver  unlocks the data object in the GPU local memory . When the data object is made non-resident, the data object can no longer be accessed by a shader engine in the GPU .","In one embodiment, the GPU driver  locks data objects by first referencing the data objects to the context of the application program  and storing a list of all the data objects. A second list of all data objects that have been locked since a last command buffer submission, including those that were locked at the time of the last submission, is also maintained. When a user-mode driver fills out the command buffer with the commands received from the application program , the allocation list of the command buffer is populated with each data object in the first list of bound data objects and each data object in this second list of data objects stored in the GPU driver . In combination, these two lists identify the complete set of data objects required to be present in memory accessible to the GPU . If the set of data objects required by a plurality of command buffers exceeds the total amount of GPU local memory , memory management software in the GPU driver  can move the contents of data objects between GPU local memory  and system memory . Importantly, a handle associated with a data object is valid in all contexts to which the data object belongs. An alternate embodiment would only store a list of currently bound data objects, and their memory would always be accessible to the GPU .","In an alternate embodiment of the present invention, the handle associated with a data object is also a CPU address within a CPU address space. In another alternate embodiment, the handle is a 64-bit unsigned integer. In yet another alternate embodiment, the handle is a high-level language pointer that points to the corresponding data object in the GPU local memory .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 5","FIGS. 1-3"]},"The method  begins at step , where the GPU driver  transmits handles of data objects received from the application program  to the GPU . Importantly, the GPU driver  does not have to access the data objects within the driver data  to transmit the handles to the GPU . At step , the GPU driver  receives a draw command from the application  and, in response, at step , transmits the draw command to the GPU  for further processing.","At step , the GPU  retrieves the data object associated with the handle from the GPU local memory . Note that, in some cases, the handle may not refer to a data object but to a different handle, thereby providing an indirection technique that can be used to easily reference groups of data objects. At step , the GPU  processes the draw command received from the GPU driver  based on the data retrieved from the GPU local memory .","Extensions to the OpenGL\u00ae 3D graphics API and the OpenGL\u00ae Shading Language (GLSL) to support accessing texture and image objects via handles are discussed below. Persons skilled in the art will appreciate that the information in this section should be considered in conjunction with the current OpenGL\u00ae 4.0 specification. The extension presented herein is a GL_NV_bindless_texture extension.","As described above, the GL_NV_bindless_texture extension allows reading texture objects via handles, and, also, reading from, writing to, and performing atomic operations on image objects via handles.","To obtain a handle on a texture object, the commands \u201cunit64 GetTextureHandleNV(uint texture)\u201d and \u201cunit64 GetTextureSamplerHandleNV(uint texture, unit sampler)\u201d may be used. The command GetTextureHandleNV creates a texture object handle using the current state of the texture object named <texture>, including any embedded sampler state. The command GetTextureSamplerHandleNV creates a texture object handle using the current non-sampler state from the texture object named <texture> and the sampler state from the sampler object <sampler>. With both commands, a 64-bit unsigned integer handle is returned. The error INVALID_VALUE is generated if the <texture> parameter is not the name of an existing texture object or if the <sampler> parameter is not the name of an existing sampler object. The error INVALID_OPERATION is generated if the texture object <texture> is not \u201ccomplete.\u201d If either error occurs, a handle of zero is returned.","To make a texture object handle accessible to shaders for texture mapping operations, a texture object handle must be made resident by calling the command \u201cvoid MakeTextureHandleResidentNV(uint64 handle).\u201d While the texture object identified by handle is resident, it may be used in texture mapping operations. If a shader attempts to perform a texture mapping operation using a handle that is not resident, the results of that operation are undefined and may lead to application termination. When a texture object handle is resident, the texture it references is also considered resident for the purposes of an \u201cAreTexturesResident\u201d command.","A texture object handle may be made inaccessible to shaders by calling the command \u201cvoid MakeTextureHandleNonResidentNV(uint64 handle).\u201d While it is not necessary for an application to call the command MakeTextureHandleNonResidentNV when a texture object handle will not be accessed for a period of time, doing so permits the memory manager in the GPU driver  to move the texture out of GPU local memory  thereby creating room for other data objects.","Turning now to image objects, texture object levels of detail may be made available to the application program via image object handles. Image object handles are 64-bit integers that identify a level of a texture object, as well as layer information for array and cube map texture objects, and an associated image format. The handle zero is reserved and will never be assigned to a valid image object handle. An image object handle is obtainable by calling the command \u201cunit64 GetlmageHandleNV(uint texture, int level, boolean layered, int layer, int format).\u201d","The GetlmageHandleNV command creates an image object handle from level <level> of the texture <texture>. If the <layered> parameter is FALSE, an image object handle is created for the entire texture object level. If the <layered> parameter is TRUE, an image object handle is created for only the layer <layer> of the texture object level. The <format> parameter specifies a format used to interpret the texels of the image object when used for image loads, stores, and atomic operations. A 64-bit unsigned integer handle is returned if the command succeeds, and zero is returned when an error occurs.","The error INVALID_VALUE is generated by the GetlmageHandleNV command if the <texture> parameter is not the name of an existing texture object, if an image object for the texture level <level> does not exist (i.e., has a size of zero in <texture>), or if <layered> is TRUE and the <layer> parameter is greater than or equal to the number of layers in the image object at level <level>. The error INVALID_OPERATION is generated by the GetlmageHandleNV command if the texture object <texture> is not complete, or if the <layered> parameter is TRUE and the texture object is not a three-dimensional, one-dimensional array, two dimensional array, cube map, or cube map array texture. As with GetTextureHandleNV, if any error occurs, a handle of zero is returned.","To make an image object handle accessible to shaders for texture mapping operations, a image object handle must be made resident by calling the command \u201cvoid MakeImageHandleResidentNV(uint64 handle, enum access).\u201d Here, the <access> parameter specifies whether the texture object bound to the image object handle will be treated as READ_ONLY, WRITE_ONLY, or READ_WRITE. If a shader reads from an image object handle made resident as WRITE_ONLY, or writes to an image object handle made resident as READ_ONLY, the results of that shader operation are undefined and may lead to application termination.","If an image object handle is resident, it may be used in image object load, store, and atomic operations. If a shader attempts to perform an operation on an image via an image object handle that is not resident, the results of that operation are undefined and may lead to application termination. When an image object handle is resident, the texture object it references is also considered resident for the purposes of the \u201cAreTexturesResident\u201d command.","An image object handle may be made inaccessible to shaders by calling the command \u201cvoid MakeImageHandleNonResidentNV(uint64 handle).\u201d","In addition to providing interfaces for extracting texture and image handles\u2014along with making them resident and non-resident\u2014the NV_bindless_texture extension additionally extends the OpenGL\u00ae Shading Language (GLSL) to facilitate access to bindless textures and images in shader programs. In prior-art implementations of GLSL, applications access textures in a shader by first binding them to an image unit in application code, reference them with a sampler variable declared in shader code, and then make an API call to set the value of the sampler variable to an integer specifying the number of the image unit where the texture is bound. The method for accessing image objects in GLSL shaders in prior-art implementations is performed in a similar manner. Unfortunately, these mechanisms involve CPU overhead both in the binding of the texture or image object and in updating the value of sampler or image variables.","The NV_bindless_texture extension provides a new mechanism that allows GLSL shaders to access sampler or image variables by assigning them the values of a texture or image handle using the command \u201cvoid UniformHandleui64NV(int location, unit64 handle)\u201d. In this command, the variable to be updated is identified by the value <location>, and the texture or image handle to assign to the variable is identified by <handle>. Additionally, the NV_bindlesstexture extension continues to permit applications to update sampler or image variables using the prior-art method of binding a texture to a texture or image unit and then specifying the unit number with the command \u201cvoid Uniform1i(int location, int value)\u201d. The value of sampler or image uniform values is interpreted according to the API used to specify the value. Alternatively, values loaded using UniformHandleui64NV will be interpreted as handles and values loaded using Uniform1i will be interpreted as unit numbers. This method advantageously allows concurrent use of bound textures and texture handles. Moreover, applications are permitted to use texture handles without making any modifications to existing shaders. For example, Uniform1i may be replaced with UniformHandleui64NV in application code. In one embodiment of the invention, the GPU driver  internally generate handles for textures bound to texture and image units and use handles in GPU microcode assembler  when accessing either bound textures or handles.","One embodiment of the invention may be implemented as a program product for use with a computer system. The program(s) of the program product define functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive, flash memory, ROM chips or any type of solid-state non-volatile semiconductor memory) on which information is permanently stored; and (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or any type of solid-state random-access semiconductor memory) on which alterable information is stored.","Another embodiment of the invention may be implemented as a program product deployed for use over a network. In such an embodiment, the program product may be accessed via a web browser.","The invention has been described above with reference to specific embodiments. Persons skilled in the art, however, will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
