---
title: Integration of a run-time parameterizable core with a static circuit design
abstract: Method and apparatus for integrating a run-time parameterizable logic core with a static circuit design. A configuration bitstream is generated from a main circuit design that is specified in a hardware description language. The main circuit design includes a first sub-circuit design that specifies a selected subset of resources of the PLD needed by the RTP core and an interface between the RTP core and other parts of the main circuit design. Via execution of a run-time reconfiguration control program, the configuration data that correspond to the first sub-circuit design are replaced with configuration data that implement the RTP core. The run-time reconfiguration program then configures the PLD with the updated configuration bitstream.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07139995&OS=07139995&RS=07139995
owner: Xilinx, Inc.
number: 07139995
owner_city: San Jose
owner_country: US
publication_date: 20020319
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["GOVERNMENT CONTRACT","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The U.S. Government has a paid-up license in this invention and the right in limited circumstances to require the patent owner to license others on reasonable terms as provided for by the terms of DABT63-99-3-0004 awarded by DARPA.","The present invention generally relates to creating circuit designs, and more particularly to integrating a run-time parameterizable core with a static circuit design.","Logic cores are generally used as building blocks in creating electronic circuit designs. A logic core is a design that when implemented in hardware performs a predetermined function and which has input and output signal lines that can be connected to other logic. Example logic cores include digital filters and multipliers.","The traditional tools for creating logic cores generally support design entry via schematics or a hardware description language such as Verilog or VHDL. In addition, there are a multitude of proprietary languages for creating logic cores that are specifically suitable for a particular family of devices. These types of designs are sometimes termed \u201cstatic\u201d designs because once a device is configured and power is applied, the circuit remains the same until power is removed.","Circuit designs, including run-time parameterizable (RTP) logic core generators, can be created in the JBits\u2122environment from Xilinx. The JBits environment is a Java-based tool that includes an application programming interface (API) that allows designers to develop logic and write a configuration bitstream directly to a Xilinx FPGA. The JBits API permits the FPGA bitstream to be modified quickly, allowing for fast reconfiguration of the FPGA. In a run-time reconfiguration system, circuits are configured and then reconfigured based on information supplied in real-time by user software, user data, or sensor data. With Virtex\u2122FPGAs, the JBits API can be used to partially or fully reconfigure the internal logic of the hardware device. The JBits environment also supports run-time reconfiguration of FPGAs and also configuration of FPGAs over a communications network, for example, an intranet or the Internet.","Run-time reconfigurable systems are generally co-processor systems. A host processor executes a run-time reconfiguration program, and the run-time reconfiguration program implements application functions on the host processor, defines a circuit design, creates configuration data, and configures the FPGA.","The different design flows for static versus run-time reconfigurable designs has limited the extent to which RTP cores are used in conjunction with static designs. Without a way to easily combine static and RTP cores, designers are left to create designs in one form or the other. Thus, designers may be left to choose between the many static-design logic cores that are commercially available and the benefits of run-time parameterizable logic cores.","A system and method that address the aforementioned problems, as well as other related problems, are therefore desirable.","In various embodiments, the invention provides a method and apparatus for integrating a run-time parameterizable logic core with a static circuit design. A configuration bitstream is generated from a main circuit design that is specified in a hardware description language. The main circuit design includes a sub-circuit design that uses a selected subset of resources of the PLD. Via execution of a run-time reconfiguration control program, the data that correspond to the sub-circuit design are replaced with configuration data that implement a function defined by the run-time reconfiguration control program. The PLD is then configured with the configuration bitstream after replacement of the selected data.","It will be appreciated that various other embodiments are set forth in the Detailed Description and Claims, which follow.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","102"]},"Integration of an RTP core  with a high-level static circuit design  involves including a reserved-resources template  in the static design (e.g., HDL or schematic capture). The reserved-resources template reserves the PLD resources that are used by, and defines the interface for the RTP core to be implemented later in the process. Through analysis of the RTP core definition, the resources that are used by the RTP core are determined, and a reserved-resources netlist  is generated by reserved resource netlist generator .","Generator  initially examines the interface of the RTP core and generates a number of components, each of which implements one part of the interface. Together, the components implement the whole of the interface. Then a further series of components are generated between the interface components. These additional components reserve space on the device and reserve some routing resources.","In one embodiment, the reserved-resources template is an HDL \u201ccomponent\u201d that has the same interface as the netlist . The component in the template  has the same name as the top level component in the netlist . The component is treated as a black-box during synthesis. When the circuit is implemented, the software is directed to the location of the netlist  to create the configuration data for the PLD to reserve the resources. By producing a netlist  that is separate from the template  and that is in a standard netlist format, the netlist can be used in a variety of present and future environments.","The static design  is then passed through implementation tools . Tools  perform the functions of synthesis, device mapping, and place-and-route functions. The output data from tools  is an initial bitstream .","The initial bitstream is read by run-time reconfiguration program  via run-time reconfiguration API . In one embodiment, the run-time reconfiguration API is the JBits Software Development Kit from Xilinx. Data from the initial bitstream are formatted and stored as configuration data .","Runtime reconfiguration program  then removes the reserved-resources template and the associated internal signal paths. RTP core  is then called via API  to implement the functions of the RTP core. RTP core  replaces the portions of configuration data  that were reserved by the reserved-resources template  with data that implement the functions of the RTP core . In one embodiment, RTP core  is part of a core library .","At a time determined by the run-time reconfiguration program, the PLD  is configured with configuration data via hardware interface . Hardware interface  includes a portable layer of software and accompanying hardware to couple the run-time reconfiguration program to PLD . An example hardware interface  is the Xilinx Hardware Interface (XHWIF) which is available from Xilinx.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":"302"},"In a specific application of the invention, the reserved-resources netlist defines a rectangular array of interconnected PLD resources. For example, the Virtex field programmable gate array (FPGA) from Xilinx has look-up tables (LUTS) that are configurable as shift registers. The shift register configuration consumes resources such that additional logic can not be implemented in the slice of the LUT (a \u201cslice\u201d includes two LUTs along with additional configurable resources of a Virtex FPGA, e.g., flip-flops).","For correct implementation of the interface to the RTP core, the reserved-resources netlist duplicates the interface to the RTP core. The same tool that determines the RTP core footprint also determines which physical pins are required by the RTP core and specifies these pins in the reserved-resources netlist.","Three issues arise in generating the reserved-resources netlist for the Virtex FPGA. The first issue relates to the way in which the Xilinx implementation tools assign address pins to the lookup tables, the second issue relates to the inability to constrain logic elements (e.g., a shift register) to a particular area of a Virtex slice through Xilinx implementation tools, and the third issue relates to trimming of logic by the implementation tools. With respect to the first issue, Xilinx implementation tools may swap address lines to LUTs and accordingly modify the initialization value. The behavior is addressed in one embodiment by configuring the LUT as a variable length shift register.","In regards to the inability to constrain logic elements to a particular area of a Virtex slice, an example is that while logic elements can be constrained to a particular slice there is no constraint available in the Xilinx implementation tools to constrain the logic elements to one of the two LUTs (\u201cF-LUT\u201d and \u201cG-LUT\u201d) in a slice. This is addressed by identifying the asymmetry between the LUTS. For example, the F multiplexer is used to switch between the outputs of the F-LUT or the G-LUT based on a selection signal on the BX input port. Because the BX input signal also drives the data input to a shift register implemented on the F-LUT, the BX input signal cannot be inverted. Thus, by connecting the output ports of the shift registers implemented on the F-LUT and G-LUT to the F multiplexer, a lookup table can be constrained to a particular LUT within the slice.","The third issue of logic trimming that is performed by the implementation tools is addressed by observing the rules that are used by the implementation tools to determine which logic can be trimmed. In observing the rules, generator  does not generate logic in the reserved-resources netlist that would be susceptible to trimming.","After the reserved-resources netlist is created, a reserved-resources template is created for the static high-level circuit design (step ). In an example embodiment, the template corresponds to the reserved-resources netlist. In a VHDL design, for example, the template includes a declaration of a component type in the VHDL architecture header and the instantiation of a component of the declared type in the VHDL architecture body. The VHDL code below sets forth the VHDL declaration of an example reserved-resources template.","COMP_TAG","component filter\n\n","end component;","The VHDL code below sets forth the VHDL instantiation of an example reserved-resources template.","INST_TAG","your_instance_name : filter\n\n","An initial configuration bitstream is created from the static high-level design (step ) using selected implementation tools. It will be appreciated that prior to generating the initial bitstream, it may be desirable to simulate the design (including the RTP core). To simulate the RTP core in the design the run-time reconfiguration API is used to generate a netlist from the RTP core (\u201cRTP-core netlist\u201d). The RTP-core netlist is then instantiated in the HDL or schematic environment and the entire circuit is simulated. Once the designer is satisfied with the circuit behavior, the reserved-resources netlist is substituted for the RTP-core netlist and the initial configuration bitstream is generated.","The next phase of the process is to replace the configuration data corresponding to the reserved resources with configuration data to implement the RTP core. First, the configuration data for logic resources in the reserved area of the PLD are cleared by writing 0 bits to the configuration data (step ). Next, the routing resources within the reserved area of the PLD are selectively cleared (step ).","The routing resources that are cleared are those associated with the internal signal paths produced from the reserved-resources template. Paths that form the interface of the reserved-resources template to the rest of the design are not removed, and paths that pass through the reserved area and resulting from static logic outside the template may be selectively removed as explained below.","Because the configuration data for routing resources within the reserved area may be used by the circuitry implemented outside the reserved area, the configuration data for the routing resources cannot be cleared without first considering the implications. For example, changing a route might increase the delay of a signal path beyond that which is acceptable. There are three options for processing signal paths that are routed through the reserved area of the PLD. The first option is to leave the signal paths in the reserved area, the second option is to reroute all the paths around the reserved area, and the third option is to reroute selected paths around the reserved area.",{"@attributes":{"id":"p-0042","num":"0050"},"figref":"FIG. 3A","b":["400","402","404","406","402","406","404","408","410","412"]},"Leaving the paths routed through the reserved area may be feasible if there are sufficient routing resources within the reserved area to construct the RTP core. Therefore, whether all the paths are left in the reserved area will depend on the routing resource requirements of the RTP core within the reserved area and the routing requirements of the remaining circuitry (e.g., maximum delay).",{"@attributes":{"id":"p-0044","num":"0052"},"figref":["FIG. 3B","FIG. 3A","FIG. 3A"],"b":["400","402","406","420","404","408","412","422","424","118"]},{"@attributes":{"id":"p-0045","num":"0053"},"figref":["FIG. 3C","FIG. 3A"],"b":["400","402","404","406","408","412","422","424"]},"It will be appreciated that if all the parameters for the RTP core are known at design time, then it is desirable to route the RTP core at design time. For example, the JRoute utility in the run-time reconfiguration API  produces paths at design time in terms of the settings of the routing resources that define the paths. This saves routing paths at run-time.","Returning now to , the final phase of integrating the RTP core with the static design is inserting the configuration data for the RTP core in the configuration data (, ). If run-time parameterization of the RTP core is not required and the RTP core has been routed at design time, the core is invoked to write the RTP core configuration data to the configuration data for the entire circuit. Because the routes from the other parts of the circuit to the RTP core part of the circuit were established when the reserved-resource netlist was merged with the design, these routes remain and provide the paths for communication between the RTP core and the rest of the circuit.","If parameterization of the RTP core is required, then the RTP core is inserted when the parameters are known. The run-time reconfiguration API is used to determine the routing resources that are in use within the reserved area, and these routing resources are marked as used. The RTP core is called with the run-time parameters, and the routing tool constructs signal paths without interfering with the rest of the design.","Various embodiments of the present invention have been described in terms of FPGAs and the JBits environment from Xilinx. Those skilled in the art will appreciate, however, that the invention could be applied to programmable logic devices (PLDs) other than FPGAs and implemented in other run-time reconfiguration environments. Other aspects and embodiments of the present invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and illustrated embodiments be considered as examples only, with a true scope and spirit of the invention being indicated by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various aspects and advantages of the invention will become apparent upon review of the following detailed description and upon reference to the drawings in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3B","FIG. 3A"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3C","FIG. 3A"]}]},"DETDESC":[{},{}]}
