---
title: Operations manager infrastructure for dynamically updating software operational policy
abstract: An Operations Manager subsystem decouples the generation of operational events from an associated behavior triggered by those events. The Operations Manager subsystem allows changing the associated behavior without requiring rebuilds or recompilations of the source code. In addition, changes to policies are possible even at runtime in order to enable more agile debugging and better application supportability. The Operations Manger subsystem includes separate reporting and subscription services. The reporting services provide an API defining operational code for the generation of operational events. The subscription services include a file system and an API that support multiple user subscriptions to the various code operational events defining the behavior associated with those events.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07765525&OS=07765525&RS=07765525
owner: Intuit Inc.
number: 07765525
owner_city: Mountain View
owner_country: US
publication_date: 20040901
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","System Architecture","Operations Manager"],"p":["1. Field of the Invention","The present invention is related to programming techniques for operational policies in software applications, and more particularly to improved operational policy management infrastructure and related applications for dynamically updatable operational policies.","2. Description of the Background Art","The software development process typically involves various levels of debugging. The code in a software application is analyzed to find and eliminate programming errors or \u201cbugs.\u201d The debugging process takes place during the development process and typically continues throughout the life of the program through customer support. Initially, developers debug their assigned code modules until an executable version of the program is ready for testing. Then, alpha and beta builds are debugged based on interactions with a select few users. Ultimately, some level of debugging is generally involved with the various released builds of the software application, typically in the form of technical support teams dealing directly with customer problems. Often, this interaction leads up to updates and upgrades of the application itself.","To facilitate this complex debugging process during all the stages of the program, developers include special event-generating code in the application software that is not related to the business purpose of the program, i.e., the business logic or client code. The event generating code is related to the internal operation of the program and its main purpose is to provide information to that effect. This operational code helps the programmer identify sources of errors or warnings that may arise when the code is executed and to log important activities that can be useful in problem solving. Operational code is also used for testing and other purposes related to the maintenance of the code. For example, quality assurance processes involve regression testing as part of the software verification process. Such verification and testing functions also benefit from operational activities or events. Typically, operational code defines operational activities or events, e.g., logging, assertions, verifications, traces, and the like, and corresponding operational policy dictating a behavior for the program associated with the generated information, e.g., writing to output log files, breaking the debugger if in debug mode, beeping, displaying pop-up windows, and the like. In general terms, the operational policy is what defines a behavior associated with the information generated by the coded operational action or event.","Conventionally, the operational policy for each operational action is hard coded with the event-generating operational code. However, the operational policies often change throughout the development process. Initially, at early stages, developers embed in the code multiple operational events with detailed output policy to provide extensive information about the state of the system for debugging purposes. As errors are corrected and the code is revised, some of the operational behaviors are changed to reduce the level of detail reported, the intrusiveness of the output, and the overall performance of the code. In some cases, the operational code is removed if it is deemed no longer necessary. These operational policy changes are typically most significant between code builds: alpha builds, beta builds, and ultimately the release builds. However, it is difficult and time consuming to find all operational code and change it consistently when policies change.","A conventional approach to simplify the management of operational policies as requirements change between development stages and\/or builds is to use the C\/C++ notion of a macro. A developer places aliases for actual policy code in the source code, and then uses a preprocessor to replace the alias at compile time with the current policy code. This approach does not require the editing of multiple files but it does require recompiling after every change. With the same effect but with the additional requirement of editing every file when the policies change, another approach is to use source code editing scripts or macros. As new requirements arise or existing requirements change, the hard coded operational policies are automatically edited using pre-defined rules in scripts or macros, e.g., a find\/replace-type script. Similarly, instead of editing every instance of operational code, a script can be used to edit in the source code certain parameter or variable values that are use in conditional statements in the code as part of the various operational events. For example, every operational event associated with a particular debugging purpose can include a condition for their execution that a certain variable be true. This way, in effect, the script can turn on or off the operational code for a particular debugging purpose by editing the variable value in the source code between true and false.","However, these conventional approaches to operational policy management based on editing scripts and macros require changes to the source code itself and\/or subsequently the compiling of the new source code after the changes in order for the new operational policy to take effect. These approaches can be time consuming and inefficient when the source code is complex and requires lengthy compile times. Further, since they require editing and\/or compiling the source code, these approaches cannot support dynamic updates to the operational policy, for example during runtime. Further, the code editing process itself can potentially become an additional source of errors, for example, by changing the wrong code. Another problem with conventional approaches is that people with different roles in the software development process (e.g. developers, QA, support, or the like), having differing needs policy-wise, either have to settle on policies that awkwardly try to meet the needs of many roles, or each role needs to compile a different version of the code with different policies defined.","Accordingly, what is needed is an operational policy management infrastructure that supports the ability to dynamically change the operational policies without having to change or recompile the client source code. What is further needed is an operational policy management infrastructure that decouples the operational policies from the source code authorship and compilation processes.","A typical software application system includes several concerns, i.e., particular goals, concepts, or areas of interest. For example, a software business application includes business logic concerns (e.g., accounting rules, inventory, purchase transactions, and the like), system-level concerns (e.g., security, data integrity, logging, or the like), and possibly many other concerns. Some concerns are very specific and can be implemented in a single software module. However, other concerns are application-wide; code regarding these \u201ccrosscutting\u201d concerns is included in multiple functional modules within an application system.","An approach adopted in one embodiment described herein decouples operational policy management concern from the general business rules code in the software application. This approach solves the deficiencies in conventional approaches to operational policy management. The operational policy \u201cconcern\u201d of a software application system is designed independently of other software modules. Operational policy aspects are defined to implement the operational policy for the entire application; the aspects provide tools to developers for the weaving of operational activities in the code. Further, changes to operation policy can be dynamically updated to maintain consistency throughout the application code.","In one embodiment, a computer-implemented method provides a dynamically updatable operational policy associated with operational events in the design of a computer application. The operational events are programmed in the code of the software application. According to this method, operational code is embedded in a client software application to produce at least one operational event without specifying a corresponding operational behavior. A subscription configuration file is provided that specifies at least one subscription to information associated with the operational event and an associated behavior. The software application monitors the subscription configuration file. The subscription configuration file is configured to cause the software application to trigger the operational behavior associated with the occurrence of the operational event. The operational behavior is triggered with respect to the input provided by the information generated by the operational event.","According to another embodiment, an operations manager system in a software development platform provides programming tools to handle operational policy concerns in software applications.","The operations manager subsystem includes a reporting service programming tool for programming operational events in the software applications. The reporting service programming tool includes a reporting API that includes definitions for a set of programming elements. The programming elements, when programmed into a software application and executed in a computer system, produce operational events.","The operations manager subsystem also includes a subscription service programming tool. The subscription service programming tool is intended for specifying operational behavioral policies associated with the operational events programmed in the software applications. The operational behavioral Policies are based on subscriptions to those operational events. For this purpose, the subscription service programming tool includes a subscription configuration file definition that comprises a set of tags for defining subscriptions. The subscriptions are configured to specify a behavior when parsed by an executing software application that includes the programmed operational events.","According to another embodiment, a method for debugging executable computer software programs is provided. The method includes creating a subscription configuration file that indicates a behavior associated with an operational event. The operational event is embedded in the executable computer software program. The subscription configuration file is transmitted over a computer network so it can be placed in a computer system directory. Data output according to the operational behavior indicated in the subscription configuration file is collected.","According to yet another embodiment, a computer-implemented system provides a dynamically updatable operational policy associated with operational events programmed in a software application. The system includes means for embedding operational code to produce at least one operational event in a client software application without specifying a corresponding operational behavior. The system also includes means for providing a subscription configuration file including a subscription to trigger a behavior associated with the operational event. The subscription configuration file is configured to be monitored by the software application during execution. It is also configured for causing the software application to trigger the behavior associated with the operational event as specified in the subscription configuration file.","In another embodiment, a computer-implemented method provides a dynamically updatable operational policy associated with a software application. The method includes providing an add-on interface in an operations manager system. The add-on interface is intended for registering custom tags, each associated with one or more operational subscription actions. These operational subscription actions are associated with computer programmed functions that when executed by a computer processor implement a custom operational behavior with respect to the software application.","A subscription configuration file is also provided. The subscription configuration file includes filter tags associated with one or more operational filters. The operational filters define one or more conditions with respect to the software application. Further, according to this method, a parsing function in the operations manager system is provided. The parsing function is configured to parse subscription configuration files. The parsing function is also configured to invoke the execution of the computer programmed functions. The computer programmed functions are associated with at least one operational subscription action. The execution is invoked in response to parsing at least one custom action tag associated with the operational subscription action and determining that the software application meets the one or more conditions specified in the associated one or more operational filters.","According to another embodiment, a computer-implemented method provides a dynamically updatable operational policy associated with a software application. The method includes providing an add-on interface in an operations manager system. In this embodiment, the add-on interface registers custom operational filter tags associated with operational filters. The operational filters are associated with conditions in the software application.","A subscription configuration file is also provided. The subscription configuration file includes action tags and at least one custom filter tag. From those action tags, at least one is associated with at least one of the custom operational filter tags. The action tags are also associated with computer program functions that when executed by a computer processor produce operational behaviors associated with the software application.","According to this embodiment, a parsing function is also provided in the operations manager system. The parsing function is configured to parse subscription configuration files. The parsing function is also configured to invoke the execution of at least one of the computer-programmed functions associated with the action tag. This execution is invoked in response to parsing the operational action tag associated with the custom operational filter tag and determining that the software application meets the conditions specified in the custom operational filters associated with the custom operational filter tags.","These features are not the only features of the invention. In view of the drawings, specification, and claims, many additional features and advantages will be apparent. The specification describes the invention for readability and instructional purposes. It does not limit the invention. A review of the claims is necessary to determine the invention.","The figures depict a preferred embodiment of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.","The following description of system components and operation is merely exemplary of embodiments of the present invention. One skilled in the art will recognize that the various designs, implementations, and techniques described herein may be used alone or in any combination, and that many modifications and equivalent arrangements can be used. Accordingly, the following description is presented for purposes of illustration, and is not intended to limit the invention to the precise forms disclosed.","Now referring to , a software application system architecture is shown. In a preferred embodiment, these functional block elements are implemented using one or more conventionally programmed general-purpose computers to function as described below. The architecture  includes several high level modules for implementing application concerns. Some of these modules include self-contained core concerns. For example, the application business logic engine  includes programs implementing the core functions of the system with respect to the ultimate purpose of the application. Other modules are application-wide features for the execution of the application. For example, the Application Infrastructure module  includes features required by several other modules of the application such as Data Management , Connectivity , Utilities , User interface , and possibly others. The Application Infrastructure  provides functional features that are used by the Business Logic Engine , the Licensing Engine , the Software Development Kit , and other system components. In a preferred embodiment, these components are implemented in a conventional, programmable, general-purpose computer system typically including one or more microprocessors, memory, data storage devices, and networking components to operate over a data network, either wired or wireless.","Now referring to , a block diagram of the Utilities Module  is shown. The Utilities Module  includes several utility subsystems that are shared among all the modules in the application system. For example, in one embodiment, the Utilities Module  includes an Operations Manager  to handle operational policy concerns; a Memory Manager  to assist with memory access transactions with the operating system; and a File System  to interact with the underlying system file structure for accessing files in storage devices. Other function-specific utility subsystems can also be included in a Utilities Module .","Now referring to , a block diagram for one embodiment of an Operations Manager subsystem  is shown. The Operations Manager subsystem  (\u201cOperations Manager\u201d) provides application-wide tools for handling different aspects of the operational policy concern. The Operations Manager subsystem  is designed for general usability in any component and in any layer of the software system architecture. In a preferred embodiment, the Operations Manager  is implemented across a network of conventional, programmable, general-purpose computer systems, including client and\/or server systems, used in the development of software application systems. Some features of the Operations Manager  are also implemented, in conjunction with other software application components, in the conventional general-purpose or process specific computer systems of the ultimate users for which the software applications are intended.","The Operations Manager subsystem  includes two application programming interfaces (\u201cAPIs\u201d). The APIs provide developers with an interface to reporting and subscription services offered by of the Operations Manager subsystem . A Reporting API  provides developers with operational code that can be used in programming any of the modules of the application. A Subscription API  provides a mechanism to handle and output information generated by the operational code but independently from the code itself. Accordingly, specification of output mechanisms is decoupled from the client code, thereby allowing policies to shift over time without affecting the client code. In this manner, the present invention facilitates policy changes, without requiring recompilation.","Reporting Services","The Reporting API  defines the operational code that a developer can use to produce operational events, such as assertions, verifications, logging, checkpoints, data dumps, or the like. For example, in one embodiment, C++ functions are defined for developers to use in setting operational activities within the code for any module of the application. A library called \u201cOps.h\u201d is provided and developers \u201cinclude\u201d it in their individual programs (for example, by including a \u201c#include Ops.h\u201d line in their code). Table 1 shows a sample set of operational event functions.",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Function Name","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Assertion","OPS_DBG_ASSERT( )","Sets a debugging assertion."]},{"entry":[{},"OPS_DBG_ASSERT_MSG(string)","Provides a string message."]},{"entry":["Verification","OPS_VERIFY( )","Provides a standard verification."]},{"entry":["Logging","OPS_FATAL_ERROR_MSG(string)","Provides a string"]},{"entry":[{},{},"describing a fatal error."]},{"entry":[{},"OPS_ERROR_MSG(string)","Provides a string"]},{"entry":[{},{},"describing an error."]},{"entry":[{},"OPS_WARNING_MSG(string)","Provides a string"]},{"entry":[{},{},"describing a warning."]},{"entry":[{},"OPS_INFO_SUMMARY_MSG(string)","Provides a summarized"]},{"entry":[{},{},"informational message."]},{"entry":[{},"OPS_INFO_DETAIL_MSG(string)","Provides a detailed"]},{"entry":[{},{},"informational message."]},{"entry":["Checkpoints","OPS_CHECKPOINT_MSG(string)","Marks a significant"]},{"entry":[{},{},"step, event, and progress in"]},{"entry":[{},{},"a process in business logic."]},{"entry":["Data Dumps","OPS_DUMP_MSG(string)","Dumps a set of data to an"]},{"entry":[{},{},"output for debugging purposes."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, the operational events are specified for two modes of operation, general mode and debug-only mode. For example, a set of functions can be defined for general operation, e.g., functions beginning with \u201cOPS_\u201d, and a second set of functions can be defined for debug-only mode, e.g., functions beginning with \u201cOPS_DBG_\u201d with the remainder of the function name being the same for both modes. By way of illustration, the functions in Table 1 for logging are also be specified with the \u201cOPS_DBG_\u201d prefix as shown in Table 2. This second set includes functions that provide similar operational functionality but only take effect in debug mode.",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Function Name","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Logging","OPS_DBG_FATAL_ERROR_MSG(string)","Provides a string describing a fatal"]},{"entry":[{},{},"error during debug mode."]},{"entry":[{},"OPS_DBG_ERROR_MSG(string)","Provides a string describing an error"]},{"entry":[{},{},"during debug mode."]},{"entry":[{},"OPS_DBG_WARNING_MSG(string)","Provides a string describing a"]},{"entry":[{},{},"warning during debug mode."]},{"entry":[{},"OPS_DBG_INFO_SUMMARY_MSG(string)","Provides a summarized"]},{"entry":[{},{},"informational message during"]},{"entry":[{},{},"debug mode."]},{"entry":[{},"OPS_DBG_INFO_DETAIL_MSG(string)","Provides a detailed informational"]},{"entry":[{},{},"message during debug mode."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In order to minimize the impact on the overall system performance, the generation of operational events should be very fast. In one embodiment, debug-only alternatives for the different event types are provided so that they can be used to suppress computationally intensive operational events from release builds. In one embodiment, debug-only alternatives are only used for such significant performance impacting events. Additionally, since the operation code will remain in the release builds, developers are cautioned not to embed messaging events that may produce private or confidential information, even in debug mode. Although it would be possible to check for the content of these messages, generally, the Operations Manager  is not required to detect or prevent when this happens.","Additionally, in one embodiment, operational events contain a time stamp so that, if threads contending for the same operational behavior cause events to be output in the wrong order, the timestamp can be used to show the true order of events and resolve any threading contentions.","According to one embodiment, a Reporting API  is designed to resemble familiar operational tools, such as assertions, tracing and logging, using the C++ programming language. In this embodiment, the Reporting API  includes the following C++ class definitions and corresponding functional aspects. It should be noted that in one embodiment, the C++ library extension \u201cBoost\u201d (boost.org) is available for the code development. Among the Boost libraries of particular importance are the boost::any type, the boost::shared_ptr and the boost::weak_ptr smart pointers, and the boost::regex. Alternative conventional C++ libraries can also be used with respect to this embodiment, for example, for regular expression matching the Henry Spencer regular expression library can be used instead of the boost::regex library.","Reporting API Classes","According to one embodiment, there are two main classes in the Reporting API , the \u201cOps\u201d class and the \u201cLocalOps\u201d class. Both provide functions for performing the various operational tasks. In this embodiment, the Reporting API  classes are associated according to the class diagram shown in .","The Ops class  is a singleton; it houses functionality that does not keep state from call to call. Generally, these are the logging and assertion functions, e.g., Assert( ) , Verify( ) , Message( ) , and ReportEvent( ) . In one embodiment, the Ops class  ultimately is the receiver of all operational events. LocalOps class , for instance, will forward its events to Ops  for processing.","The LocalOps class  is used for the function tracing part of the Reporting API . The LocalOps class  keeps states from call to call. When it is constructed, the LocalOps class  reports that the called function was entered. When it is destroyed, e.g., as the function exits, it reports that the function is exiting. LocalOps  ultimately forwards all of its calls to the Ops  singleton class.","Both classes, Ops  and LocalOps , define member classes named \u201cxxxxxFunctor.\u201d The LocalOps class  also provides member functions for reporting the \u201cstatus\u201d to be returned from the function, e.g., ReprotStatusCodeFunctor class  and ThrowStatusCodeFunctor class . Similarly, the Ops class  provides member classes MessageFunctor  and AssertFunctor .","These member classes are used in the implementation of various macros to provide the illusion that the macros take variable \u201cprintf-style\u201d parameters. Essentially, when the user sees a macro it may appear that what follows the macro name is a parameter list for the macro, but this is not the case. For example, consider the macro OPS_MESSAGE ( )  in the following statement:","OPS_MESSAGE (_T(\u201cError could not open file % s\u201d), fileName);","it may appear that what follows OPS_MESSAGE  is a parameter list for the OPS_MESSAGE macro . However, in actual operation the OPS_MESSAGE  part of the statement is a macro that simply creates an instance of one of the \u201cFunctor\u201d classes, e.g., MessageFunctor , passing information about the source code context, such as the file name, line number, function signature, and the like to the constructor. The parameter list, or the part between the parentheses (including the parentheses) is not a parameter list for the OPS_MESSAGE macro , but is a call to the function call operator, \u201coperator ( ) ,\u201d of the Functor class MessageFunctor , which has a variable-length argument list for the printf-style parameters. Similarly, OPS_Assert( )  performs a macro function call to the AssertFunctor class  with its corresponding operator( ) .","In one embodiment, the Reporting API  is designed to provide all the operational events an application developer may require. In one embodiment, the operational events provided are tracing, logging (or messaging), assert and verify. Alternative embodiments provide additional and different sets of operational events.","Tracing\u2014In this embodiment, function tracing is carried out automatically when the user creates an instance of LocalOps  at the beginning of a function in a local variable. A \u201ctrace in\u201d message is immediately sent upon creation of the LocalOps . The scope of the local variable will determine when the \u201ctrace out\u201d message is sent. When the LocalOps  variable goes out of scope, the destructor of LocalOps  is called and it sends the \u201ctrace out\u201d message. A third trace message, \u201ctrace status\u201d, is sent before the \u201ctrace out\u201d message, when the system reports the status at the end of the function, before returning or throwing and exception. LocalOps  provides several ways to report this status, allowing the program to pass a \u201cStatus\u201d object, or pass a \u201cStatusCode\u201d value with a string type message (which uses the LocalOps::ReportStatusCodeFunctor  as shown in ). The Reporting API  defines convenience macros for throwing an exception that wraps a Status object, and several other macros for reporting common errors.","Messaging (Logging)\u2014In one embodiment, the Operations Manager subsystem  defines the logging events it provides in terms of messaging functions. In the Operations Manager  design, the output medium or other operational behavior is decoupled from the Reporting API  and left to the Subscription API .","With respect to the Messaging operational event, the developer specifies a \u201clevel\u201d characteristic for a message. As described below, the Subscription API  provides the ability to filter based on message levels. In this embodiment, the Messaging levels defined are in Table 3.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Level","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Info Detail","verbose output that other users would usually not want to"]},{"entry":[{},"see"]},{"entry":["Info Summary","useful but terse information"]},{"entry":["Warning","information that indicates a possible problem"]},{"entry":["Error","reports a recoverable error"]},{"entry":["Fatal Error","reports an unrecoverable error, likely requiring the"]},{"entry":[{},"application to abort"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"202"},"At each specified level, printf-style macros are provided for logging any of the messages the developer may want to specify in his program. In addition, as described above, a debug-only version of each messaging macro is also provided. The debug-only macros are removed from the code at compile time when the application is not being operated in debug mode. In one embodiment, the debug-only versions are used when performance is a concern, i.e., when the operational event would cause significant performance degradation beyond what would be acceptable for a release quality build. Otherwise, general mode operational code can be used. The Subscription API  is generally responsible for turning logging on and off at runtime rather than using the compiler.","Assert and Verify\u2014Assert and Verify are similar operational actions, both reporting an event when a specified condition evaluates to false or an equivalent numeric value (e.g., zero). In one embodiment, as a default policy, an assertion is only evaluated in debug builds, while a verify event is evaluated in debug and release builds. Because generally an assert event is not evaluated in a release build, assert events are designed so that they do not return a value that can be used in an expression, e.g., the control expression of an \u201cif\u201d statement. Verify events, on the other hand, are always evaluated, both in debug and release builds, so that they are designed to evaluate to a Boolean expression, and can be used in Boolean expressions such as an \u201cif\u201d statement. These design restrictions are particular to one embodiment described and are not required in alternative embodiments that lack these default evaluation rules for assert and verify events.","In alternative embodiments, further operational events can be provided in the Reporting API , e.g., check-pointing, data dumps, and the like. It is up to the designer of the Operations Manager  implementation to define the operational tools that will be available to application developers of the software.","With some exceptions, the operational code infrastructure can remain enabled in release builds. Unlike prior art approaches, the compiled release build of the software application includes the operational code since the output mechanisms and\/or operational policy are decoupled from the client code itself. Accordingly, the operational code infrastructure can subsequently be used through the Operations Manager  subscription services, not only by developers during the application development cycle but also by others who are able to provide customized subscriptions to access the output of the embedded operational code. For example, customer support representatives can turn on logging in release builds at a customer site for diagnostic purposes. As another example, quality assurance (\u201cQA\u201d) engineers can turn on logging for specific features and provide meaningful information to developers as they encounter problems. As yet another example, QA engineers can compare output of information in successive runs of the application to check for accidental loss of functionality as the program is developed.","Subscription Services","The Operations Manager subsystem  decouples the generation of operational events, such as logging, assertions, tracing, and the like, from the operational behavior for which the information associated with the operational event is used, e.g., logging to file, displaying in the screen, beeping, breaking the execution, or the like. The subscription services handle the operational policy aspects that dictate the operational behavior to trigger for the events generated by the reporting services. This separation between the events and the output policy allows the definitions of what should be output, at what times, and to what media, to change dynamically and over time without having to rebuild the code. Further, the decoupling of the operational policy from the operational code enables the Operations Manager  to dynamically update the policies even during runtime without impacting the application code.","The Operations Manager subsystem  can provide subscription services as a software API, as configuration files, or as combination of these two. The configuration files can be edited to add, change, and delete subscriptions to operational events defined through the Reporting API . Once the operational events are included in the application through operational code as described above, subscriptions to those events can be made selectively by filtering the events, for example based on fully-qualified function names, verbosity or severity levels, and types of event, and the like.","Subscription Configuration Files","According to one embodiment, the Subscriptions services are provided in subscription configuration files. During execution of an application, the Operations Manager  constantly monitors the subscription configuration files to detect any changes and modifies the operational policy accordingly. The changes of the operational policy are made dynamically without interruption of the application execution.","Any number of subscription configuration files can be used to specify the operational policy. In one embodiment, a single subscription file includes all the subscriptions for a particular application. The file is monitored and the policy updated upon changes in this file. In multi-file embodiments, files with particular names or placed in a particular directory are monitored by the Operations Manager  and their contents parsed and combined according to the particular design of the Operations Manager .","In one embodiment, a two-file subscription configuration file system is used. This embodiment is intended for a distributed and cooperative application development environment. In this embodiment, a \u201cmandatory\u201d subscription configuration file is provided with a minimum set of subscriptions for critical operational events. A second subscription configuration file is allowed to indicate customized subscriptions by developers and others in the development environment. Both of these files are located in the main executable directory of the particular application, e.g., \u201cAPPexe\u201d directory. The Operations Manager  monitors these two files to detect any changes in operational policy. In another embodiment, for security reasons the application's subscription information is encoded so that the casual end user can't find the subscription information by simple inspection of files. It should be noted that although some embodiments may require one or more mandatory subscription configuration files, the mandatory nature of the file is not a requirement to implement the described functionality. For example, in one embodiment, those doing development, QA, and Support roles create as many policy files as they require and add them to the encoded application policies. In this embodiment, subscription information is not mandatory but simply optional.","In one embodiment, the mandatory subscription configuration file is unique for the application, for example, the release configuration management team may specify this file for a given application release. This unique mandatory file can be changed for each release level of the code (i.e., debug, beta, release, or the like). In one embodiment, the mandatory subscription configuration file is called \u201cAPPOps.cfg\u201d but other names or naming conventions are equally possible, e.g., .ops files, or the like.","For a typical cooperative development environment, this file should be owned and configured by one entity, e.g., the Operations Manager  designer, a quality assurance team, the release configuration management team, or the like. In order to serve its purpose all the application code developers must use the mandatory subscription configuration file. The use of the mandatory file is a convenient approach for cooperative development but not a functional requirement of the system.","In an alternative embodiment, the use of configuration files is optional. Instead of a configuration file, a software API is used to set the minimum subscription policies for a code release. Configuration files are then optional and generally used by developers, QA, support teams, and the like. For example, the release configuration management team sets the minimum subscription policies through the API and the developers, QA, and support teams are free to optionally provide .ops configuration files. Thus, this approach does not require a mandatory subscription file.","The operational policy requirements for an application often change depending on where the application is in its lifecycle. Pre-beta versions will generally require more logging by default than beta versions. Earlier releases will pop up invasive notifications when assertions fail. Conversely, these notifications are quietly logged to files in release builds. As a general practice, fatal errors are always logged. These basic policies differences are specified by the mandatory configuration subscription file.","In one embodiment, a mandatory subscription configuration file is generally only concerned with the minimum required operational policy and many available operational events in the code are ignored to minimize any effect on system performance. For example, in one embodiment, the assert and verify events are suppressed unless a subscriber declares an interest in the event through a user-specific subscription configuration file.","In addition, it is desirable to provide flexibility in the operational behaviors triggered by operational events. For some specific purposes or in certain situations, it is desirable to output additional information from operational events that is normally ignored or output in a less conspicuous manner. For example, a developer may want to get all the information generated by operational events in his or her software module for debugging purposes; a quality assurance technician may want additional information related to a particular function or a particular level of message; a technical support technician may want more detailed reports dealing with a failure at a customer site. For these and similar purposes, user-specific subscription configuration files are offered as part of the subscription services of the Operations Manager subsystem .","User-specific subscription configuration files are allowed for individual developers or others in the development and support team wanting to subscribe to operational events for their any particular purpose. The user-specific configuration file is optional and owned and configured by each individual user, i.e., developer, groups of developers, QA engineer, or anyone interested in testing and debugging the code. In one embodiment, this optional file is for example called \u201cUserOps.cfg\u201d while in another embodiment consisting of entirely optional files, the configuration files can have any name followed by the .ops extension to be identified as an operational policy configuration file.","For example, in one embodiment, the UserOps.cfg, is included in the APPexe directory. This file is checked for at runtime; if it exists, it is parsed after the mandatory configuration file, e.g., APPOps.cfg, having the effect of being appended to the bottom of the mandatory file. Subscriptions in the user-defined configuration file do not override the policies in the mandatory configuration file; each \u201csubscription\u201d is additive over existing ones. In one embodiment, no provision is made to turn off or divert previous subscription output. Where more than one subscription would cause the same event to be output to the same medium, duplicates are suppressed. Further, when changes are detected during the execution of the application, existing subscriptions originating from the changed file are cancelled and replaced with the new subscriptions made in their place. Similarly, an alternative embodiment includes an API to specify the minimum required subscriptions and .ops files are used to provide user-defined subscriptions to be added. The application periodically checks for .ops files and parses as described above.","Although any suitable format may be used, in a preferred embodiment, the subscription configuration files are in Extensible Markup Language (\u201cXML\u201d) format. For example, the subscription configuration files conform to the following document type definition (\u201cDTD\u201d):\n\n","This DTD describes the syntax of one embodiment of an Operations Manager  subscription configuration file. In this embodiment, the DTD defines the following tags:","OpsConfiguration\u2014This is the root element of the configuration file. The file contains one OpsConfiguration tag at the root level. This element provides the basic filtering mechanism. This tag contains zero or more Subscription tags.","Subscription\u2014This element enters a subscription for events that match a set of conditions enumerated in child Condition tags. Events matching all of the Conditions trigger the actions specified in the attributes of a Subscription. Table 4 shows a sample set of attributes. All of the attributes are optional, but unless one is specified, nothing will happen with the events matching this subscription. Each attribute represents an action that may be taken and is given all of the information about an operational event, but each attribute uses the information differently.",{"@attributes":{"id":"p-0077","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Attribute",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Filename","File name","When this attribute is specified, events"]},{"entry":[{},{},"matching the conditions in this subscription will"]},{"entry":[{},{},"be output to the file specified by the file name"]},{"entry":[{},{},"provided. Note that if the same file is specified"]},{"entry":[{},{},"in other subscriptions, the filename should be"]},{"entry":[{},{},"specified in the same way to avoid"]},{"entry":[{},{},"unpredictable behavior. Although a consistency"]},{"entry":[{},{},"check could be added, in this embodiment it is"]},{"entry":[{},{},"up to the user to specify files consistently."]},{"entry":["debugout","True\/False","If this value is \u201ctrue\u201d, matching events will be"]},{"entry":[{},{},"logged to the platform's default debug output."]},{"entry":["Break","True\/False","If this value is \u201ctrue\u201d, the program will break on"]},{"entry":[{},{},"matching events, close to the point where the"]},{"entry":[{},{},"event occurred."]},{"entry":["alert","True\/False","If this value is \u201ctrue\u201d, the program will alert the"]},{"entry":[{},{},"user with a message when an event matches this"]},{"entry":[{},{},"Subscription."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Condition\u2014A condition tag is a child of a Subscription. There may be one or more Condition tags in a Subscription. When there are multiple Condition tags, a logic AND operator is applied to the Conditions (i.e., the Conditions are logically \u201cANDed\u201d together), making a filter that is potentially more restrictive. Each Condition tag may contain any or all of the attributes listed in Table 5. Each attribute is actually a separate condition; when multiple attributes are specified, each is logically ANDed as if they were specified in separate Condition tags. Preferably, in one embodiment, at least one attribute should be specified in each Condition tag.",{"@attributes":{"id":"p-0079","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Attribute",{},{}]},{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["level","info-","This attribute represents the levels of interest an event might"]},{"entry":[{},"detail\/","have. When a level is specified, all of the levels with a higher"]},{"entry":[{},"info-","degree of interest are included implicitly. For instance, if a"]},{"entry":[{},"summary\/","level of \u201cwarning\u201d is specified, \u201cerror\u201d and \u201cfatal\u201d are"]},{"entry":[{},"warning\/","included as well. The level attribute can be omitted."]},{"entry":[{},"error\/"]},{"entry":[{},"fatal"]},{"entry":["type","All\/","This attribute limits a Subscription to events of a specific type."]},{"entry":[{},"Message\/","The type attribute can be omitted."]},{"entry":[{},"Trace\/"]},{"entry":[{},"Assert\/"]},{"entry":[{},"Verify"]},{"entry":["functionMask","Not","This attribute limits a Subscription to only those events"]},{"entry":[{},"Applicable","originating in functions whose fully qualified name matches"]},{"entry":[{},{},"the regular expression specified in the value. The value is a"]},{"entry":[{},{},"regular expression as defined by the Henry Spencer regular"]},{"entry":[{},{},"expression library. The regular expression specified here will"]},{"entry":[{},{},"be treated as case insensitive. It does not need to match"]},{"entry":[{},{},"completely the fully qualified function name; the expression"]},{"entry":[{},{},"merely needs to match a substring of the fully qualified name."]},{"entry":[{},{},"The fully qualified name will be of the form"]},{"entry":[{},{},"\u201cNamespace1::NamespaceN::Class1::ClassN::FunctionName\u201d."]},{"entry":[{},{},"If the regular expression is not well formed, the Operations"]},{"entry":[{},{},"Manager 200 will send notification via the \u201cdebugout\u201d and"]},{"entry":[{},{},"the \u201calert\u201d actions."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, with respect to the level attribute, each of the possible values that indicate the degree of interest is further described in Table 6. These values correspond to the levels of the Reporting API  shown in Table 3.",{"@attributes":{"id":"p-0081","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value Tag","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["info-detail","This value is the most verbose, and if developers have"]},{"entry":[{},"categorized their messages properly, is the only level that"]},{"entry":[{},"will be verbose. This value matches all events, and is"]},{"entry":[{},"equivalent to leaving it out altogether."]},{"entry":["info-","This value specifies interest only in \u201cinteresting\u201d"]},{"entry":["summary","information. Items with a level of \u201cinfo detail\u201d will be"]},{"entry":[{},"excluded."]},{"entry":["warning","This value specifies interest only in warnings and errors"]},{"entry":["error","This value specifies interest in errors only."]},{"entry":["fatal","This value specifies that a fatal error has occurred. Usually,"]},{"entry":[{},"if this level of event is received, the application will shortly"]},{"entry":[{},"terminate. However, Operations Manager 200 will not"]},{"entry":[{},"cause the application to terminate. It is up to the code"]},{"entry":[{},"handling the error to make that happen."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, with respect to the type attribute, each of the possible values that indicate the type of event is further described in Table 7.",{"@attributes":{"id":"p-0083","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value",{}]},{"entry":["Tag","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["all","This gets all events of all types, and is the same as omitting the"]},{"entry":[{},"type attribute."]},{"entry":["message","This limits the Subscription to only message (log) events, which"]},{"entry":[{},"originate in the Ops class"]},{"entry":["trace","This limits the Subscription to only trace messages, which"]},{"entry":[{},"originate in the LocalOps class."]},{"entry":["assert","This limits the Subscription to only assertion failures, which"]},{"entry":[{},"originate in the Ops class."]},{"entry":["verify","This limits the Subscription to only verify failures, which"]},{"entry":[{},"originate in the Ops class."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following is a sample \u201cmandatory\u201d subscription configuration file for Pre-release builds according to one embodiment:",{"@attributes":{"id":"p-0085","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d?>"]},{"entry":[{},"<OpsConfiguration>"]},{"entry":[{},"\u2003\u2003<!-- log all warnings and errors -->"]},{"entry":[{},"\u2003\u2003<Subscription filename=\u201cdebug.log\u201d debugout=\u201ctrue\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Condition level=\u201cwarning\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/Subscription>"]},{"entry":[{},"\u2003\u2003<!-- pop up a message when an assertion fails -->"]},{"entry":[{},"\u2003\u2003<Subscription alert=\u201ctrue\u201d filename=\u201cdebug.log\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003debugout=\u201ctrue\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Condition type=\u201cassert\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/Subscription>"]},{"entry":[{},"\u2003\u2003<!-- show verify failures in debug output -->"]},{"entry":[{},"\u2003\u2003<Subscription debugout=\u201ctrue\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Condition type=\u201cverify\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/Subscription>"]},{"entry":[{},"<\/OpsConfiguration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following is a sample \u201cmandatory\u201d subscription configuration file for Beta builds according to one embodiment:",{"@attributes":{"id":"p-0087","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d?>"]},{"entry":[{},"<OpsConfiguration>"]},{"entry":[{},"\u2003\u2003<!-- log all warnings and errors -->"]},{"entry":[{},"\u2003\u2003<Subscription filename=\u201cdebug.log\u201d debugout=\u201ctrue\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Condition level=\u201cerror\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/Subscription>"]},{"entry":[{},"\u2003\u2003<!-- pop up a message when an assertion fails -->"]},{"entry":[{},"\u2003\u2003<Subscription alert=\u201ctrue\u201d filename=\u201cdebug.log\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003debugout=\u201ctrue\u201d>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Condition type=\u201cassert\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/Subscription>"]},{"entry":[{},"<\/OpsConfiguration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following is a sample user-defined subscription configuration file according to one embodiment. For example, a developer while working on a database module code may use this sample file. This sample file logs all events where the originating function's fully qualified name contains \u201cDB\u201d or \u201cDatabase\u201d in a namespace or class name.",{"@attributes":{"id":"p-0089","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d?>"]},{"entry":[{},"<OpsConfiguration>"]},{"entry":[{},"\u2003\u2003<!-- log all database stuff -->"]},{"entry":[{},"\u2003\u2003<Subscription filename=\u201cdebug.log\u201d debugout=\u201ctrue\u201d >"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Condition functionMask=\u201c(DB | Database).*\\:\\:\u201d\/>"]},{"entry":[{},"\u2003\u2003<\/Subscription>"]},{"entry":[{},"<\/OpsConfiguration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The following is another sample user-defined subscription configuration file according to one embodiment. For example, a QA engineer working on the database module code might add an additional constraint that only warnings and errors should be logged, and they might turn off \u201cdebugout\u201d if they don't have access to a debugger.",{"@attributes":{"id":"p-0091","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<?xml version=\u201c1.0\u201d?>"]},{"entry":[{},"<OpsConfiguration>"]},{"entry":[{},"\u2003\u2003<!-- log all database stuff -->"]},{"entry":[{},"\u2003\u2003<Subscription filename=\u201cdebug.log\u201d >"]},{"entry":[{},"\u2003\u2003\u2003\u2003<Condition functionMask=\u201c(DB | Database).*\\:\\:\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003level=\u201cwarning\u201d \/>"]},{"entry":[{},"\u2003\u2003<\/Subscription>"]},{"entry":[{},"<\/OpsConfiguration>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In a preferred embodiment, another suitable format for the subscription configuration files are in Extensible Markup Language (\u201cXML\u201d) format. However, in this embodiment, a DTD is not required because there is no fixed grammar for the subscription configuration files. It should be noted that an XML file without a fixed schema is still considered a well-formed XML, however it is not a \u201cvalidatable\u201d XML. In this embodiment, .ops files include custom tags that may have previously not existed. An add-on interface further described below provides a mechanism to increase the number of tags and defining new tags as new operational behaviors and conditional filters are added.","In the grammar of these XML .ops subscription configuration files, there are action tags and filter tags. Action tags specify behavior and contain child tags called Filter tags that specify under what conditions the behaviors are manifest. For example, in one embodiment, the filter tags correspond roughly to the attributes in the DTD of the subscription configuration files described above.","According to this embodiment, the filter\/child tags are specified with a set of attributes of their own. For example, in one embodiment an action called ACTION_A is registered through the add-on interface. A filter called FILTER1 is also registered through the add-on interface and a policy file that uses the newly registered action and filter is specified as follows:\n\n","In this embodiment, filters can be combined so that conditions in each of the filters can be logically related. For example, two filters can be combined with a Boolean AND function to require that both filters must evaluate to logical true for the action to take place. Using the example above, a Boolean AND in a subscription configuration file is specified as follows:\n\n","Similarly, to effectuate a Boolean OR relationship between filters a mechanism is provided. In each .ops file, more than one action can be specified. For example:\n\n","Using the possibility to specify the same action with a different combination of filters provides the ability to OR the filters. For example, if the same action is mentioned more than once with different filters, the action will occur if either set of filters matches the action to take place. Similarly, in this embodiment, many .ops files can exist and none is necessarily required. All files ending with .OPS are parsed and their policies are combined resulting in similar logical relationships between .ops files.","In one embodiment, the following action tags shown in Table 8 are implemented. However, it should be noted that other tags can be dynamically added through the add-on interface.",{"@attributes":{"id":"p-0099","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Action Tag","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<LOG_TO_FILE","causes information from the"]},{"entry":["filename=\u201cfile name\u201d>","originating OPS macro to be output"]},{"entry":[{},"to the specified file"]},{"entry":["<LOG_TO_DEBUG_OUTPUT>","causes information from the"]},{"entry":[{},"originating OPS macro to be output"]},{"entry":[{},"to a debugger output window, if any"]},{"entry":["<ALERT_USER message =","causes information from the"]},{"entry":["\u201coptional message text\u201d>","originating OPS macro to be output"]},{"entry":[{},"to a pop-up window, along with the"]},{"entry":[{},"contents of the message attribute if it"]},{"entry":[{},"exists"]},{"entry":["<FAIL>","causes the application to terminate"]},{"entry":["<BEEP>","causes a speaker tone to be emitted"]},{"entry":["<BREAK>","breaks program execution and enters"]},{"entry":[{},"the debugger"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Each of the above actions, if they don't have any filters, will happen on every OPS macro. Filters limit the actions to specific OPS macros. The following filter tags shown in Table 9 can be placed as child tags of the above action tags in any combination. More can be added through the add-on interface.",{"@attributes":{"id":"p-0101","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Filter Tag","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<EVENT_TYPE_FILTER type = \u201cevent","only allow events of the specified type"]},{"entry":["type\u201d\/>","to be output. Types correspond to the"]},{"entry":[{},"different macros. Types are"]},{"entry":[{},"\u201cMESSAGE\u201d, \u201cASSERT\u201d, \u201cVERIFY\u201d,"]},{"entry":[{},"\u201cFUNC_ENTER\u201d, \u201cFUNG_EXIT\u201d,"]},{"entry":[{},"\u201cFUNC_STATUS\u201d, \u201cCHECKPOINT\u201d,"]},{"entry":[{},"\u201cDUMP\u201d"]},{"entry":["<LEVEL_FILTER level = \u201clevel\u201d\/>","for events of type \u201cMESSAGE\u201d, this can"]},{"entry":[{},"be used to further limit the events to"]},{"entry":[{},"only those of a certain level. Levels are"]},{"entry":[{},"\u201cLVL_INFO_DETAIL\u201d,"]},{"entry":[{},"\u201cLVL_INFO_SUMMARY\u201d,"]},{"entry":[{},"\u201cLVL_WARNING\u201d, \u201cLVL_ERROR\u201d,"]},{"entry":[{},"and \u201cLVL_FATAL_ERROR\u201d. A"]},{"entry":[{},"specified level matches messages of"]},{"entry":[{},"that level and above, so"]},{"entry":[{},"\u201cLVL_WARNING\u201d will match"]},{"entry":[{},"OPS_WARNING_MSG,"]},{"entry":[{},"OPS_ERROR_MSG, and"]},{"entry":[{},"OPS_FATAL_ERROR_MSG macros."]},{"entry":["<MESSAGE_FILTER regexp=\u201cregular","only allows OPS events whose"]},{"entry":["expression\u201d \/>","messages match the regular expression."]},{"entry":[{},"So, a MESSAGE_FILTER with regexp = \u201ce.*tion\u201d"]},{"entry":[{},"will match"]},{"entry":[{},"OPS_ERROR_MSG(\u201ceducation\u201d) and"]},{"entry":[{},"OPS_WARNING_MSG(\u201celation\u201d) but"]},{"entry":[{},"not OPS_WARNING_MSG(\u201cerudite\u201d)."]},{"entry":["<FILE_NAME_FILTER","only allows OPS events found inside of"]},{"entry":["regexp=\u201cregular expression\u201d \/>","source code files whose file name"]},{"entry":[{},"matches the regular expression"]},{"entry":["<FUNC_NAME_FILTER","only allows OPS events found inside of"]},{"entry":["regexp=\u201cregular expression\u201d \/>","functions whose function name"]},{"entry":[{},"matches the regular expression"]},{"entry":["<FUNC_SIG_FILTER regexp=\u201cregular","only allows OPS events found inside of"]},{"entry":["expression\u201d \/>","functions whose function signature"]},{"entry":[{},"(which includes the name of the"]},{"entry":[{},"function, its return type and its"]},{"entry":[{},"parameter types) matches the regular"]},{"entry":[{},"expression"]},{"entry":["<NUM_LOCK_FILTER\/>","only allows OPS events that happen"]},{"entry":[{},"while the NUM LOCK key on the"]},{"entry":[{},"keyboard is pressed."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following is a sample user-defined subscription configuration file (.ops) according to one embodiment. For example, this .ops file would capture all error messages that occur in the source code file MyFeature.cpp, and logs them to a file called MyFeatureErrors.log.\n\n","In another embodiment, the subscription services are provided in a programmatic interface useful for creating custom tools. This programmatic interface is the Subscriptions API . Alternatively, in another embodiment, a combination of both, a Subscription API  and an XML file-based mechanism for configuring subscriptions to events is provided. Under this approach, the XML file-based mechanism generally follows the subscription configuration file approach described above.","The Subscription API  provides a programmatic interface with equivalent functionality to that provided by the configuration file mechanism described above. This is provided to allow the Operations Manager subsystem  to be extended across multiple design platforms.","Subscription System Classes","The Subscription API  includes several new program classes.  shows a class association diagram for a sample set of Subscription API classes according to one embodiment using the C++ programming language. Although the same functionality can be provided in any other programming language, a description of this preferred embodiment based on C++ is provided below for illustrative purposes.","The SubscriptionManager  parses subscription configuration files at startup time and when the configuration files change. This class creates new Subscription  objects based on each configuration file. If the files change, the SubscriptionManager  creates new Subscription  objects based on the changed file and deletes the old Subscription  objects from the file. It is done in that order so that OpsActions  remain open if they are specified in the original and changed versions of the configuration file. The SubscriptionManager  generally provides the top level for the Subscription API .","The OpsConfigFileMonitor  monitors a single configuration file and alerts the SubscriptionManager  when it detects a change to a configuration file. In a two-file embodiment, e.g., APPOps.cfg and UserOps.cfg, there are two instances of this class. In other embodiments using one or multiple configuration files, this module is modified accordingly. Having one instance per configuration file allows the flexibility of designing the Operations Manger  with one or more configuration files.","The SubscriptionManager  initiates and owns each OpsConfigFileMonitor object  and holds references for them, one for each configuration file. When a signal is received indicating that a configuration file has changed, the corresponding OpsConfigFileMonitor  object notifies the SubscriptionManager , which handles the changes.","The Subscription  object represents the unique combination of a configuration file, an OpsAction , and a set of Conditions . The Subscription  class corresponds to the Subscription element described with respect to the configuration files above. Its lifetime is managed by the SubscriptionManager . It holds a collection of Condition objects .","Subscription  owns and manages the life cycle of Condition objects . The Condition  object class is similar to the Condition element in the configuration files described above, except that an instance of this class is created for every attribute of every Condition tag in the configuration files. Multiple Conditions are logically ANDed together. To get the effect of an OR condition, a subscriber can create separate subscriptions to the same resource. For the condition object , multiplicity is one or more per Subscription object  (i.e., \u201c*\u201d) because subscription filters can be composed of multiple conditions, e.g. funcNameFilter=\u201cDatabase\u201d, Level=\u201cWarning\u201d.","The OpsActionManager  assures that only one instance of each action specified in the various subscriptions of the configuration file is created using the special pointer features of the \u201cBoost\u201d library. In one embodiment, the OpsActionManager  is not included.","Each created action is an instance of OpsAction object . OpsActions  are abstractions for behaviors that are invoked for operational events. An OpsAction object  can be associated with one or more Subscription objects . The OpsActionManager  creates all OpsAction objects  and keeps a master list of them via a collection of special weak pointers, boost::weak_ptrs. The OpsActionManager  does not delete any of the OpsAction objects . The lifetime of each OpsAction  is managed through Boost shared pointers, boost::shared_ptrs, which are held by the Subscription objects . The OpsAction  has a list of the Subscription objects  that subscribe to it. When all Subscriptions  to an OpsAction  are discontinued, the reference count of the shared pointer goes to zero and the OpsAction  is destroyed.","The OpsActionManager  keeps a weak_ptr to each created OpsAction , whether it still exists or not. When a new Subscription  is created, the SubscriptionManager  asks the OpsActionManager  for a shared_ptr to whatever OpsAction  is specified. The OpsActionManager  first checks to see if it has a weak_ptr to the specified action in its list. If it does, it tries to resolve it to a shared_ptr. If there is such an OpsAction  in use, the weak pointer is successfully resolved, allowing the OpsAction  to be reused. If the reference count to that OpsAction  has gone to zero, however, the resolve fails because the object has been destroyed.","In that case or when the request is for an action not previously created, the OpsActionManager  creates a new instance of the OpsAction object  requested, returns to the SubscriptionManager  a shared_ptr to the new instance, and refreshes or creates a weak_ptr to it in its list.","This use of Boost library pointers allows the lifetime of the OpsAction object  to be managed by the Subscriptions  that share it, and allows a way for the shared OpsActions  to be located and reused with other Subscriptions  that need to share it. This feature also allows the OpsActionManager  to assure that no two OpsActions  control the same output resource. For instance, in one embodiment there can only be one instance of DebugOutputAction , and there can only be one instance of FileLogAction for a given path name or file.","When an operational event occurs, the event is forwarded by the Ops singleton  to the OpsActionManager , which in turn locates the OpsActions  in its list and forwards the event to each of them. When SubscriptionMgr  needs to request a reference to an OpsAction , it calls the GetOpsActionManager( )  in the global OpsManagerGlobals class . Each OpsAction  will query the Subscriptions  in its list to see if any of them has a set of Conditions  that matches the event. If a Subscription  is found that does match the event, the associated action is triggered.","Notifying the OpsAction  first rather than the Subscription  prevents duplication of event handling caused by multiple Subscriptions  pointing to the same OpsAction . That is, an action is triggered for an event only once, regardless of how many Subscriptions  there are to that action. Since the OpsAction  association to Subscription  has a multiplicity of 1, there will not be more than one OpsAction  for a given Subscription . If there is a desire to have a single set of conditions trigger multiple operational behaviors, they can create separate subscriptions  with the same conditions, or they can create a new operational behavior that combines them. OpsAction  includes several subclasses , which dictate the output mechanisms available to subscribers. In alternative embodiments, in addition to the subclasses discussed below Operations Manager  designers can include additional subclasses as desired.","DebugOutputAction outputs OpsEvent information to the Debugger output window. The information is output beginning with the file name and line number so that the reader can double-click on the line to go to the place in the source code that the event occurred. Generally, in single debugger output window environments, there is no need to have more than one instance of this subclass, since there is are no parameters that can differentiate one instance from another.","FileLogAction logs operational event information to a file specified by the \u201cFileName\u201d parameter . As discussed above, the OpsActionManager  assures that each unique path name specified in the subscription configuration files gets its own instance of this OpsAction subclass . It should be noted that it is possible to have two FileLogActions that write to the same file if two different paths to the same file are specified in the configuration file. As mentioned above, it is preferable for subscribers to take care to avoid this. Although possible, in a preferred embodiment the OpsActionManager  will not normalize the paths to assure only one object per log file.","DebugBreakAction does not output any information, but triggers a breakpoint in the source code.","AlertUserAction outputs operational event information to a dialog box (e.g., pop-up window). By default, the dialog box has an \u201cOK\u201d button, but the subscriber can add \u201cAbort\u201d and \u201cBreak\u201d buttons in the subscription file using the ButtonList parameter .","Now referring to , a class diagram of an alternative embodiment of a Subscription application-programming interface is shown. According to this embodiment, the operation policies are open-ended. An add-on interface is provided for the user to specify custom actions or behaviors not originally provided at the time that the ops manager system was built. According to this embodiment, for each new action, the user provides an object called \u201cFactory\u201d whose purpose is to create an instance of the new action object.","The users register the Factory object with the OpsMessageHandlerManager . In this embodiment, the OpsMessageHandlerManager  performs the functions of the OpsActionManager  described with respect to . In addition, the OpsMessageHandlerManager  registers Factory objects  to create new operational actions .","As the SubscriptionManager  parses a subscription configuration file (.ops), if an action tag is not recognized, the SubscriptionManager  checks with the OpsMessageHandlerManager  to look up the if the action tag registered under the unrecognized tag name. If the OpsMessageHandlerManager  finds the tag in its tag registry, it calls the custom Factory  associated with that tag to create an instance of the new custom Action Object ","Both the custom Factory  and the custom Action Object are created by the user ahead of time and registered with the OpsMessageHandlerManager  through its API. Then, the user includes the newly created tag in a configuration file (.ops) with any of the available filters. Accordingly, events that match the filter criteria specified in the .ops file associated with the newly created Action tag are associated with the Action Object and the associated operational policy behavior  defined by the user is performed. This add-on interface allows user to specify custom behaviors  not previously provided by the operations manager system.","For example, to create a custom action that checks the system's memory for errors on every function call a user creates a custom subclass of OpsMessageHandler , MemoryCheckMessageHandler . The user programs the MemoryCheckMessageHandler to call a custom MemoryCheck( ) function  each time that message handler is invoked. Then the user creates a Factory object  called MemoryCheckMessageHandlerFactory  that creates instances of MemoryCheckMessageHandler . Using the API in OpsMessageHandlerManager , the user registers that new action's factory under a custom Action tag name, e.g., \u201cCHECK_MEMORY\u201d.","The user then creates a subscription configuration file (.ops) that uses the tag name CHECK_MEMORY with a set of existing filters to specify when to invoke the new custom behavior. For example, the .ops file with a customized action tag is specified as follows:\n\n","Similarly, add-on interface allows custom creation of new filters. The user creates new custom Filter Objects custom filters are subclasses of OpsMessageFilter . Filter Factory objects  are registered through the API in OpsSubscriptionManager . When OpsSubscriptionManager  parses a subscription configuration file (e.g., .ops) and finds an unrecognized filter, it checks for new filter tags. If a new filter tag is registered, the corresponding FilterFactory  is called. The factory object  creates an instance of the OpsMessageFilter for the custom filter which is evaluated against the events in the main program. The custom filters and custom actions are therefore similarly created with the add-on interface.","The algorithms and displays presented herein are not inherently related to any particular computer, network of computers, or other apparatus. Various general-purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems appears from the description. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","As will be understood by those familiar with the art, the invention may be embodied in other specific forms without departing from the spirit or essential characteristics thereof. For example, the particular architectures depicted above are merely exemplary of one implementation of the present invention. The functional elements and method steps described above are provided as illustrative examples of one technique for implementing the invention; one skilled in the art will recognize that many other implementations are possible without departing from the present invention as recited in the claims. Likewise, the particular capitalization or naming of the modules, protocols, features, attributes, or any other aspect is not mandatory or significant, and the mechanisms that implement the invention or its features may have different names or formats. In addition, the present invention may be implemented as a method, process, user interface, computer program product, system, apparatus, or any combination thereof. Accordingly, the disclosure of the present invention is intended to be illustrative, but not limiting, of the scope of the invention, which is set forth in the following claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
