---
title: Method for path selection in a network
abstract: A method for finding a path in a network is disclosed. The network includes a plurality of nodes and a plurality of links and each one of the plurality of nodes is coupled to at least one other of the plurality of nodes by at least one of the plurality of links. Such a method generates at least one path cost data set and accessing the path cost data set to provide the requisite path information. The path cost data set represents a path cost between a root node of the nodes and destination node of the nodes. The path begins at the root node and ends at the destination node. The generation and accessing operations are performed in such a manner that a minimum-hop path and a minimum-cost path can be determined from the at least one path cost data set. The minimum-hop path represents a path between the root node and the destination node having a minimum number of hops. The minimum-cost path represents a path between the root node and the destination node having a minimum cost.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07002917&OS=07002917&RS=07002917
owner: Cisco Technology, Inc.
number: 07002917
owner_city: San Jose
owner_country: US
publication_date: 20000104
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation-in-part of patent application Ser. No. 09\/232,397, filed Jan. 15, 1999 now U.S. Pat. No. 6,856,627 and entitled \u201cA METHOD FOR ROUTING INFORMATION OVER A NETWORK,\u201d having A. N. Saleh, H. M. Zadikian, Z. Baghdasarian, and V. Parsi as inventors. This application is hereby incorporated by reference, in its entirety and for all purposes.","This application is related to patent application Ser. No. 09\/232,395, filed Jan. 15, 1999, now U.S. Pat. No. 6,724,757 and entitled \u201cA CONFIGURABLE NETWORK ROUTER,\u201d having H. M. Zadikian, A. N. Saleh, J. C. Adler, Z. Baghdasarian, and V. Parsi as inventors; patent application Ser. No. 09\/232,396, filed Jan. 15, 1999 now U.S. Pat. No. 6,631,134 and entitled \u201cMETHOD OF ALLOCATING BANDWIDTH IN AN OPTICAL NETWORK,\u201d having H. M. Zadikian, A. Saleh, J. C. Adler, Z. Baghdasarian, and V. Parsi as inventors; Patent Application No. 60\/174,323, filed Jan. 4, 2000, filed herewith, and entitled \u201cA RESOURCE MANAGEMENT PROTOCOL FOR A CONFIGURABLE NETWORK ROUTER\u201d having H. M. Zadikian, A. Saleh, J. C. Adler, Z. Baghdasarian and Vahid Parsi as inventors; patent application Ser. No. 09\/477,166, filed Jan. 4, 2000, filed herewith, and entitled \u201cMETHOD AND APPARATUS FOR A REARRANGEABLY NON-BLOCKING SWITCHING MATRIX,\u201d having Ali Najib Saleh, Douglas Duschatko, Lane Byron Quihodeaux as inventors; patent application Ser. No. 09\/477,217, filed Jan. 4, 2000, now U.S. Pat. No. 6,856,600, filed herewith, and entitled \u201cFAULT ISOLATION IN A SWITCHING MATRIX,\u201d having R. A. Russell and M. K. Anthony as inventors; patent application Ser. No. 09\/389,302, filed Sep. 2, 1999, now U.S. Pat. No. 6,801,496, and entitled \u201cNETWORK ADDRESSING SCHEME FOR REDUCING PROTOCOL OVERHEAD IN AN OPTICAL NETWORK,\u201d having A. Saleh and S. E. Plote as inventors; patent application Ser. No. 09\/477,498, filed Jan. 4, 2000, filed herewith, and entitled \u201cMETHOD OF PROVIDING NETWORK SERVICES,\u201d having H. M. Zadikian, S. E. Plote, J. C. Adler, D. P. Autry, and A. Saleh as inventors. These related applications are hereby incorporated by reference, in their entirety and for all purposes.","1. Field of the Invention","This invention relates to the field of information networks, and more particularly relates to a method for discovering preferable routes between two nodes in a network.","2. Description of the Related Art","Today's networks carry vast amounts of information. High bandwidth applications supported by these networks include streaming video, streaming audio, and large aggregations of voice traffic. In the future, these demands are certain to increase. To meet such demands, an increasingly popular alternative is the use of lightwave communications carried over fiber optic cables. The use of lightwave communications provides several benefits, including high bandwidth, ease of installation and capacity for future growth.","The synchronous optical network (SONET) protocol is among those protocols designed to employ an optical infrastructure and is widely employed in voice and data communications networks. SONET is a physical transmission vehicle capable of transmission speeds in the multi-gigabit range, and is defined by a set of electrical as well as optical standards. SONET networks have traditionally been protected from failures by using topologies that support fast restoration in the event of network failures. Their fast restoration time makes most failures transparent to the end-user, which is important in applications such as telephony and other voice communications. Existing schemes rely on techniques such as 1-plus-1 and 1-for-1 topologies that carry active traffic over two separate fibers (line switched) or signals (path switched), and use a protocol (Automatic Protection Switching or APS), or hardware (diverse protection) to detect, propagate and restore failures.","In routing the large amounts of information between the nodes of an optical network, a fast, efficient method for finding the most preferable path through that network is desirable. For example, in the case of voice communications, the failure of a link or node can disrupt a large number of voice circuits. The detection of such faults and the restoration of information flow must often occur very quickly to avoid noticeable interruption of such services. For most telephony implementations, for example, failures must be detected within about 10 ms and restoration must occur within about 50 ms. The short restoration time is critical in supporting applications, such as current telephone networks, that are sensitive to quality of service (QoS) because such detection and restoration times prevent old digital terminals and switches from generating alarms (e.g., initiating Carrier Group Alarms (CGAs)). Such alarms are undesirable because they usually result in dropped calls, causing users down time and aggravation. Restoration times exceeding 10 seconds can lead to timeouts at higher protocol layers, while those that exceed 1 minute can lead to disastrous results for the entire network.","In a SONET network, a failure of a given link results in a loss of signal (LOS) condition at the nodes connected by that link (per Bellcore's recommendations in GR-253 (GR-253() , Common Generic Criteria, Issue 2 [Bellcore, December 1995], included herein by reference, in its entirety and for all purposes)). The LOS condition propagated an Alarm Indication Signal (AIS) downstream, and Remote Defect Indication (RDI) upstream (if the path still exists), and an LOS defect locally. The defect is upgraded to a failure 2.5 seconds later, which causes an alarm to be sent to the Operations System (OS) (per GR-253). When using SONET, the handling of the LOS condition should follow Bellcore's recommendations in GR-253 (e.g., 3 ms following a failure, an LOS defect is detected and restoration should be initiated). This allows nodes to inter-operate, and co-exist, with other network equipment (NE) in the same network. The arrival of the AIS at a node causes the node to send a similar alarm to its neighbor and for that node to send an AIS to its own neighbor, and so on. Under GR-253, each node is allowed a maximum time in which to forward the AIS in order to quickly propagate the indication of a failure.","Thus, the ability to quickly restore network connections is an important requirement in today's networks, especially with regard to providing end-users with acceptable service (e.g., providing telecommunications subscribers with uninterrupted connections). In turn, a method for finding an alternate route with sufficient quality-of-service characteristics in the event of a network failure that is fast and efficient must be provided to enable such quick restoration.","The present invention improves the speed and efficiency with which a failed circuit is restored (or a new circuit is provisioned) in a network by allowing the identification of one or more desirable paths through a network, based on criteria such as the number of hops between two nodes, physical distance between two nodes, bandwidth requirements, other quality of service metrics, and the like. A quality-of serviced-based shortest path first (QSPF) method according to the present invention selects a path by analyzing a database containing information regarding the links within the network being analyzed. The database may be pre-processed by pruning links that, for one reason or another, fail to meet the requirements of the path being routed as an initial matter. This requirement might be, for example, bandwidth, with all links having insufficient bandwidth. This might be additionally limited to bandwidth for a given class of service. The method then successively determines the most desirable path to certain nodes in the network, re-calculating the path as nodes increasingly farther from the node calculating the path (the root node) are considered, filling the entries in a path table as the method proceeds. This process continues until an end condition is reached, such as when all nodes in the network are processed, the second of the two end nodes (the destination node) is reached, a maximum number of hops has been reached, or some other criteria is met. The method then back-tracks from the destination node to the root node in order to read the path from the path table. As will be apparent to one of skill in the art, this method may be modified in a number of ways and still achieve the same ends in a similar manner.","In one embodiment of the present invention, a method for finding a path in a network is disclosed. The network includes a plurality of nodes and a plurality of links and each one of the plurality of nodes is coupled to at least one other of the plurality of nodes by at least one of the plurality of links. Such a method generates at least one path cost data set and accessing the path cost data set to provide the requisite path information. The path cost data set represents a path cost between a root node of the nodes and destination node of the nodes. The path begins at the root node and ends at the destination node. The generation and accessing operations are performed in such a manner that a minimum-hop path and a minimum-cost path can be determined from the at least one path cost data set. The minimum-hop path represents a path between the root node and the destination node having a minimum number of hops. The minimum-cost path represents a path between the root node and the destination node having a minimum cost.","In one aspect of this embodiment, the path cost data set is stored in a path storage area such that the at least one path cost data set can be accessed to determine the minimum-hop path and the minimum-cost path. In this aspect, the path storage area may be allocated in a data structure that facilitates the access to determine the minimum-hop path and the minimum-cost path.","In another aspect of this embodiment, the at least one path cost data set is stored in a data structure that is a two-dimensional array of entries arranged in a plurality of rows and a plurality of columns. In this aspect, each one of the rows in the data structure corresponds to one of the plurality of nodes, and each one of the columns in the data structure corresponds to a given hop count.","This aspect may be extended in at least two ways. First, the minimum-hop path to the destination node may be determined. This may be accomplished by performing the following actions, for example. One of the rows corresponding to the destination node can be traversed from a first column of the columns to a second column of the columns. Path information representing the minimum-hop path may then be stored while traversing the data structure from the second column to the first column. In this aspect, the second column is a first one of the columns encountered when traversing the row from the first column to the second column having non-default cost entry. The first column can correspond, for example, to the root node.","This aspect may also be extended to determine the minimum-cost path to the destination node. This may be accomplished by performing the following actions, for example. A minimum-cost column of the columns can be identified, where the minimum-cost column has a lowest cost entry of all of the columns in a one of the rows corresponding to the destination node. Path information representing the minimum-cost path can then be stored while traversing the data structure from the minimum-cost column to a first column of the columns. The first column can correspond, for example, to the root node.","The foregoing is a summary and thus contains, by necessity, simplifications, generalizations and omissions of detail; consequently, those of ordinary skill in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects, inventive features, and advantages of the present invention, as defined solely by the claims, will become apparent in the non-limiting detailed description set forth below.","The use of the same reference symbols in different drawings indicates similar or identical items.","The following is intended to provide a detailed description of an example of the invention and should not be taken to be limiting of the invention itself. Rather, any number of variations may fall within the scope of the invention which is defined in the claims following the description.","In one embodiment, a method of finding a preferable path through a network is provided, which is capable, for example, of supporting a routing protocol capable of providing restoration times on the order of about 50 ms or less using a physical network layer for communications between network nodes (e.g., SONET). This is achieved by using a priority (or quality-of-service (QoS)) metric for connections (referred to herein as virtual paths or VPs) and links. The QoS parameter, which may include parameters such as bandwidth, physical distance, availability, and the like, makes possible the further reduction of protection bandwidth, while maintaining the same quality of service for those connections that need and, more importantly, can afford such treatment. Thus, availability can be mapped into a cost metric and only made available to users who can justify the cost of a given level of service.","Network Architecture","To limit the size of the topology database maintained by each node and the scope of broadcast packets distributed in a network employing a method according to the present invention, such a network can be divided into smaller logical groups called \u201czones.\u201d Each zone runs a separate copy of the topology distribution algorithm, and nodes within each zone are only required to maintain information about their own zone. There is no need for a zone's topology to be known outside its boundaries, and nodes within a zone need not be aware of the network's topology external to their respective zones.","Nodes that attach to multiple zones are referred to herein as border nodes. Border nodes are required to maintain a separate topological database, also called a link-state or connectivity database, for each of the zones they attach to. Border nodes use the connectivity database(s) for intra-zone routing. Border nodes are also required to maintain a separate database that describes the connectivity of the zones themselves. This database, which is called the network database, is used for inter-zone routing. The database describes the topology of a special zone, referred to herein as the backbone, which is normally assigned an ID of 0. The backbone has all the characteristics of a zone. There is no need for a backbone's topology to be known outside the backbone, and its border nodes need not be aware of the topologies of other zones.","A network is referred to herein as flat if the network consists of a single zone (i.e., zone  or the backbone zone). Conversely, a network is referred to herein as hierarchical if the network contains two or more zones, not including the backbone. The resulting multi-level hierarchy (i.e., nodes and one or more zones) provides the following benefits:\n\n","As noted, the protocol routes information at two different levels: inter-zone and intra-zone. The former is only used when the source and destination nodes of a virtual path are located in different zones. Inter-zone routing supports path restoration on an end-to-end basis from the source of the virtual path to the destination by isolating failures between zones. In the latter case, the border nodes in each transit zone originate and terminate the path-restoration request on behalf of the virtual path's source and destination nodes. A border node that assumes the role of a source (or destination) node during the path restoration activity is referred to herein as a proxy source (destination) node. Such nodes are responsible for originating (terminating) the RPR request with their own zones. Proxy nodes are also required to communicate with border nodes in other zones to establish an inter-zone path for the VP.","In one embodiment, every node in a network employing the protocol is assigned a globally unique 16-bit ID referred to herein as the node ID. A node ID is divided into two parts, zone ID and node address. Logically, each node ID is a pair (zone ID, node address), where the zone ID identifies a zone within the network, and the node address identifies a node within that zone. To minimize overhead, the protocol defines three types of node IDs, each with a different size zone ID field, although a different number of zone types can be employed. The network provider selects which packet type to use based on the desired network architecture.",{"@attributes":{"id":"p-0046","num":"0051"},"figref":["FIG. 1","FIG. 1","FIG. 1","FIG. 1"],"b":["100","110","120","130","0","1","2"],"sup":["13 ","10 "]},"Type  IDs work well for networks that contain a small number of large zones (e.g., less than about 4 zones). Type  IDs are well suited for networks that contain a large number of small zones (e.g., more than about 15). Type  IDs provide a good compromise between zone size and number of available zones, which makes a type  node ID a good choice for networks that contain an average number of medium size zones (e.g., between about 4 and about 15). When zones being described herein are in a network, the node IDs of the nodes in a zone may be delineated as two decimal numbers separated by a period (e.g., ZoneID.NodeAddress).",{"@attributes":{"id":"p-0048","num":"0053"},"figref":["FIG. 2","FIG. 2"],"b":["200","201","204","0","211","217","221","226","231","236","241","247","1","4","0","1","3","1","7","2","2","2","4","3","4","3","5","4","1","4","2","213","217","222","224","234","235","241","242","200","201","204","0","1","0","2","0","3","0","4"]},"Once a network topology has been defined, the protocol allows the user to configure one or more end-to-end connections that can span multiple nodes and zones. This operation is referred to herein as provisioning. Each set of physical connections that are provisioned creates an end-to-end connection between the two end nodes that supports a virtual point-to-point link (referred to herein as a virtual path or VP). The resulting VP has an associated capacity and an operational state, among other attributes. The end points of a VP can be configured to have a master\/slave relationship. The terms source and destination are also used herein in referring to the two end-nodes. In such a relationship, the node with a numerically lower node ID assumes the role of the master (or source) node, while the other assumes the role of the slave (or destination) node. The protocol defines a convention in which the source node assumes all recovery responsibilities and that the destination node simply waits for a message from the source node informing the destination node of the VP's new path, although the opposite convention could easily be employed.","VPs are also assigned a priority level, which determines their relative priority within the network. This quality of service (QoS) parameter is used during failure recovery procedures to determine which VPs are first to be restored. Four QoS levels (0\u20133) are nominally defined in the protocol, with 0 being the lowest, although a larger or smaller number of QoS levels can be used. Provisioning is discussed in greater detail subsequently herein.","Initialization of Network Nodes","In one embodiment, network nodes use a protocol such as that referred to herein as the Hello Protocol in order to establish and maintain neighbor relationships, and to learn and distribute link-state information throughout the network. The protocol relies on the periodic exchange of bi-directional packets (Hello packets) between neighbors. During the adjacency establishment phase of the protocol, which involves the exchange of INIT packets, nodes learn information about their neighbors, such as that listed in Table 1.",{"@attributes":{"id":"p-0052","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Information regarding neighbors stored by a node."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameter","Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Node ID","Node ID of the sending node, which is preferably,"]},{"entry":[{},"from 8 bits to 32 bits."]},{"entry":["HelloInterval","How often Hello packets should be sent by the"]},{"entry":[{},"receiving node"]},{"entry":["HelloDeadInterval","The time interval, in seconds, after which the"]},{"entry":[{},"sending node will consider its neighbor dead if a"]},{"entry":[{},"valid Hello packets is not received."]},{"entry":["LinkCost","Cost of the link between the two neighbors. This"]},{"entry":[{},"may represent distance, delay or any other metric."]},{"entry":["LinkCapacity","Total link capacity"]},{"entry":["QoS3Capacity","Link capacity reserved for QoS 3 connections"]},{"entry":["QoSnCapacity","Link capacity reserved for QoS 0\u20132 connections"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"During normal protocol operation, each node constructs a structure known as a Link State Advertisement (LSA), which contains a list of the node's neighbors, links, the capacity of those links, the quality of service available on over links, one or more costs associated with each of the links, and other pertinent information. The node that constructs the LSA is called the originating node. Normally, the originating node is the only node allowed to modify its contents (except for the HOP_COUNT field, which is not included in the checksum and so may be modified by other nodes). The originating node retransmits the LSA when the LSA's contents change. The LSA is sent in a special Hello packet that contains not only the node's own LSA in its advertisement, but also ones received from other nodes. The structure, field definitions, and related information are illustrated subsequently in  and described in the corresponding discussion. Each node stores the most recently generated instance of an LSA in its database. The list of stored LSAs gives the node a complete topological map of the network. The topology database maintained by a given node is, therefore, nothing more than a list of the most recent LSAs generated by its peers and received in Hello packets.","In the case of a stable network, the majority of transmitted Hello packets are empty (i.e., contain no topology information) because only altered LSAs are included in the Hello messages. Packets containing no changes (no LSAs) are referred to herein as null Hello packets. The Hello protocol requires neighbors to exchange null Hello packets periodically. The HelloInterval parameter defines the duration of this period. Such packets ensure that the two neighbors are alive, and that the link that connects them is operational.","Initialization Message","An INIT message is the first protocol transaction conducted between adjacent nodes, and is performed upon network startup or when a node is added to a pre-existing network. An INIT message is used by adjacent nodes to initialize and exchange adjacency parameters. The packet contains parameters that identify the neighbor (the node ID of the sending node), its link bandwidth (both total and available, on a QoS3\/QoSn basis), and its configured Hello protocol parameters. The structure, field definitions, and related information are illustrated subsequently in  and described in the text corresponding thereto.","In systems that provide two or more QoS levels, varying amounts of link bandwidth may be set aside for the exclusive use of services requiring a given QoS. For example, a certain amount of link bandwidth may be reserved for QoS3 connections. This guarantees that a given amount of link bandwidth will be available for use by these high-priority services. The remaining link bandwidth would then be available for use by all QoS levels (0\u20133). The Hello parameters include the HelloInterval and HelloDeadInterval parameters. The HelloInterval is the number of seconds between transmissions of Hello packets. A zero in this field indicates that this parameter hasn't been configured on the sending node and that the neighbor should use its own configured interval. If both nodes send a zero in this field then a default value (e.g., 5 seconds) should be used. The HelloDeadInterval is the number of seconds the sending node will wait before declaring a silent neighbor down. A zero in this field indicates that this parameter hasn't been configured on the sending node and that the neighbor should use its own configured value. If both nodes send a zero in this field then a default value (e.g., 30 seconds) should be used. The successful receipt and processing of an INIT packet causes a START event to be sent to the Hello State machine, as is described subsequently.","Hello Message","Once adjacency between two neighbors has been established, the nodes periodically exchange Hello packets. The interval between these transmissions is a configurable parameter that can be different for each link, and for each direction. Nodes are expected to use the HelloInterval parameters specified in their neighbor's Hello message. A neighbor is considered dead if no Hello message is received from the neighbor within the HelloDeadInterval period (also a configurable parameter that can be link-blank and direction-specific).","In one embodiment, nodes in a network continuously receive Hello messages on each of their links and save the most recent LSAs from each message. Each LSA contains, among other things, an LSID (indicating which instance of the given LSA has been received) and a HOP_COUNT. The HOP_COUNT specifies the distance, as a number of hops, between the originating node and the receiving node. The originating node always sets this field of 0 when the LSA is created. The HOP_COUNT field is incremented by one for each hop (from node to node) traversed by the LSA instance. The HOP_COUNT field is set to zero by the originating node and is incremented by one on every hop of the flooding procedure. The ID field is initialized to FIRST_LSID during node start-up and is incremented every time a new instance of the LSA is created by the originating node. The initial ID is only used once by each originating node. Preferably, an LSA carrying such an ID is always accepted as most recent. This approach allows old instances of an LSA to be quickly flushed from the network when the originating node is restarted.","During normal network operation, the originating node of an LSA transmits LS update messages when the node detects activity that results in a change in its LSA. The node sets the HOP_COUNT field of the LSA to 0 and the LSID field to the LSID of the previous instance plus 1. Wraparound may be avoided by using a sufficiently-large LSID (e.g., 32 bits). When another node receives the update message, the LSA is recorded in the node's database and schedules the LSA for transmission to its own neighbors. The HOP_COUNT field is incremented by one and transmitted to the neighboring nodes. Likewise, when the nodes downstream of the current node receive an update message with a HOP_COUNT of H, they transmit their own update message to all of their neighbors with a HOP_COUNT of H+1, which represents the distance (in hops) to the originating node. This continues until the update message either reaches a node that has a newer instance of the LSA in its database or the hop-count field reaches MAX_HOPS.",{"@attributes":{"id":"p-0062","num":"0067"},"figref":"FIG. 3","b":["300","310","300","320","330","340","350","360","370","380","390"]},"It should be noted that those of ordinary skill in the art will recognize the boundaries between and order of operations in this and the other flow diagrams described herein are merely illustrative and alternative embodiments may merge operations, impose an alternative decomposition of functionality of operations, or re-order the operations presented therein. For example, the operations discussed herein may be decomposed into sub-operations to be executed as multiple computer processes. Moreover, alternative embodiments may combine multiple instances of particular operation or sub-operations. Furthermore, those of ordinary skill in the art will recognize that the operations described in this exemplary embodiment are for illustration only. Operations may be combined or the functionality of the operations may be distributed in additional operations in accordance with the invention.",{"@attributes":{"id":"p-0064","num":"0069"},"figref":"FIG. 4","b":["400","410","420","430","430","450","460","450"]},"The LSA of the inactive node propagates throughout the network until the hop-count reaches MAX_HOPS. Various versions of the GET_LSA request are generated by nodes along the path, each with a varying number of requested LSA entries. An entry is removed from the request when the request reaches a node that has an instance of the requested LSA that meets the criteria of list B.","All database exchanges are expected to be reliable using the above method because received LSA's must be individually acknowledged. The acknowledgment packet contains a mask that has a \u201c1\u201d in all bit positions that correspond to LSA's that were received without any errors. The low-order bit corresponds to the first LSA received in the request, while the high-order bit corresponds to the last LSA. Upon receiving the response, the sender verifies the checksum of all LSA's in its database that have a corresponding \u201c0\u201d bit in the response. The sender then retransmits all LSA's with a valid checksum and ages out all others. An incorrect checksum indicates that the contents of the given LSA has changed while being held in the node's database. This is usually the result of a memory problem. Each node is thus required to verify the checksum of all LSA's in its database periodically.","The LS checksum is provided to ensure the integrity of LSA contents. As noted, the LS checksum is used to detect data corruption of an LSA. This corruption can occur while the advertisement is being transmitted, while the advertisement is being held in a node's database, or at other points in the networking equipment. The checksum can be formed by any one of a number of methods known to those of ordinary skill in the art, such as by treating the LSA as a sequence of 16-bit integers, adding them together using one's complement arithmetic, and then taking the one's complement of the result. Preferably, the checksum doesn't include the LSA's HOP_COUNT field, in order to allow other nodes to modify the HOP_COUNT without having to update the checksum field. In such a scenario, only the originating node is allowed to modify the contents of an LSA except for those two fields, including its checksum. This simplifies the detection and tracking of data corruption.","Specific instances of an LSA are identified by the LSA's ID field, the LSID. The LSID makes possible the detection of old and duplicate LSAs. Similar to sequence numbers, the space created by the ID is circular: the ID starts at some value (FIRST_LSID), increases to some maximum value (FIRST_LSID-1), and then goes back to FIRST_LSID+1. Preferably, the initial value is only used once during the lifetime of the LSA, which helps flush old instances of the LSA quickly from the network when the originating node is restarted. Given a large enough LSID, wrap-around will never occur, in a practical sense. For example, using a 32 bit LSID and a MinLSInterval of 5 seconds, wrap-around takes on the order of 680 years.","LSIDs must be such that two LSIDs can be compared and the greater (or lesser) of the two identified, or a failure of the comparison indicated. Given two LSIDs x and y, x is considered to be less than y if either\n\n|2and \n\nor\n\n|2and \n\nis true. The comparison fails if the two LSIDs differ by more than 2.\n","Sending, Receiving, and Verifying LSAs",{"@attributes":{"id":"p-0071","num":"0076"},"figref":["FIG. 5","FIG. 5"]},"For each new LSA in the link state database (step ), then, the following steps are taken. If the LSA is new, several actions are performed. For each node in the neighbor list (step ), the state of the neighboring node is determined. If the state of the neighboring node is set to a value of less than ACTIVE, that node is skipped (steps  and ). If the state of the neighboring node is set to a value of at least ACTIVE and if the LSA was received from this neighbor (step ), the given neighbor is again skipped (step ). If the LSA was not received from this neighbor (step ), the LSA is added to the list of LSAs that are waiting to be sent by adding the LSA to this neighbor's LSAsToBeSent list (step ). Once all LSAs have been processed (step ), requests are sent out. This is accomplished by stepping through the list of LSAs to be sent (steps  and ). Once all the LSAs have been sent, the process is complete.",{"@attributes":{"id":"p-0073","num":"0078"},"figref":"FIG. 6","b":["600","610","620","630","435"]},"Otherwise, the node's link state database is searched to find the current LSA (step ), and if not found, the current LSA is written into the database (step ). If the current LSA is found in the link state database, the current LSA and the LSA in the database are compared to determine if they were sent from the same node (step ). If the LSAs were from the same node, the LSA is installed in the database (step ). If the LSAs were not from the same node, the current LSA is compared to the existing LSA to determine which of the two is more recent (step ). The process for determining which of the two LSAs is more recent is discussed in detail below in reference to . If the LSA stored in the database is the more recent of the two, the LSA received is simply discarded (step ). If the LSA in the database is less recent than the received LSA, the new LSA is installed in the database, overwriting the existing LSA (step ). Regardless of the outcome of this analysis, the LSA is then acknowledged by sending back an appropriate response to the node having transmitted the Hello message (step ).","The operations referred to herein may be modules or portions of modules (e.g., software, firmware, or hardware modules). For example, although the described embodiment includes software modules and\/or includes manually entered user commands, the various exemplary modules may be application specific hardware modules. The software modules discussed herein may include script, batch, or other executable files, or combinations and\/or portions of such files. The software modules may include a computer program or subroutines thereof encoded on computer-readable media.","Additionally, those skilled in the art will recognize that the boundaries between modules are merely illustrative and alternative embodiments may merge modules or impose an alternative decomposition of functionality of modules. For example, the modules discussed herein may be decomposed into sub-modules to be executed as multiple computer processes. Moreover, alternative embodiments may combine multiple instances of a particular module or sub-module. Furthermore, those skilled in the art will recognize that the operations described in exemplary embodiment are for illustration only. Operations may be combined or the functionality of the operations may be distributed in additional operations in accordance with the invention. The preceding discussion applies to the flow diagram depicted in , as well as to all other flow diagrams and software descriptions provided herein.","The software modules described herein may be received, for example, by the various hardware modules of a network node, such as that contemplated herein, from one or more computer readable media. The computer readable media may be permanently, removably or remotely coupled to the given hardware module. The computer readable media may non-exclusively include, for example, any number of the following: magnetic storage media including disk and tape storage media; optical storage media such as compact disk media (e.g., CD-ROM, CD-R, etc.) and digital video disk storage media; nonvolatile memory storage memory including semiconductor-based memory units such as FLASH memory, EEPROM, EPROM, ROM or application specific integrated circuits; volatile storage media including registers, buffers or caches, main memory, RAM, etc.; and data transmission media including computer network, point-to-point telecommunication, and carrier wave transmission media. In a UNIX-based embodiment, the software modules may be embodied in a file which may be a device, a terminal, a local or remote file, a socket, a network connection, a signal, or other expedient of communication or state change. Other new and various types of computer-readable media may be used to store and\/or transmit the software modules discussed herein.",{"@attributes":{"id":"p-0078","num":"0083"},"figref":"FIG. 7","b":["700","710","720","730","740"]},"The basic flooding mechanism in which each packet is sent to all active neighbors except the one from which the packet was received can result in a relatively large number of copies of each packet. This is referred to herein as a broadcast storm. The severity of broadcast storms can be limited by one or more of the following optimizations:\n\n","Every node establishes adjacency with all of its neighbors. The adjacencies are used to exchange Hello packets with, and to determine the status of the neighbors. Each adjacency is represented by a neighbor data structure that contains information pertinent to the relationship with that neighbor. The following fields support such a relationship:",{"@attributes":{"id":"p-0081","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Fields in the neighbor data structure."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["State","The state of the adjacency"]},{"entry":["NodeID","Node ID of the neighbor"]},{"entry":["Inactivity Timer","A one-shot timer, the expiration of which indicates"]},{"entry":[{},"that no Hello packet has been seen from this"]},{"entry":[{},"neighbor since the last HelloDeadInterval seconds."]},{"entry":["HelloInterval","This is how often the neighbor wants us to send"]},{"entry":[{},"Hello packets."]},{"entry":["HelloDeadInterval","This is the length of time to wait before declaring"]},{"entry":[{},"the neighbor dead when the neighbor stops sending"]},{"entry":[{},"Hello packets"]},{"entry":["LinkControlBlocks","A list of all links that exist between the two"]},{"entry":[{},"neighbors."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Preferably, a node maintains a list of neighbors and their respective states locally. A node can detect the states of is neighbors using a set of \u201cneighbor states,\u201d such as the following:\n\n","2. INIT-SENT. This state indicates that the local node has sent an INIT request to the neighbor, and that an INIT response is expected.\n\n",{"@attributes":{"id":"p-0084","num":"0099"},"figref":"FIG. 8","b":["800","800","800","800"],"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":{"@attributes":{"id":"ul0010-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":"1. Cause a transition into a new state."}}}},"2. Invoke zero or more actions.","3. Have no effect on the adjacency or its state.","HSM  includes a Down state , an INIT-Sent state , a ONE-WAY state , an EXCHANGE state , an ACTIVE state , and an INIT-Received state . HSM  transitions between these states in response to a START transition , IACK_RECEIVED transitions  and , INIT_RECEIVED transitions , , and , and an EXCHANGE DONE transition  in the manner described in Table 3. It should be noted that the Disabled state mentioned in Table 3 is merely a fictional state representing a non-existent neighbor and, so, is not shown in  for the sake of clarity. Table 3 shows state changes, their causing events, and resulting actions.",{"@attributes":{"id":"p-0088","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"HSM transitions."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Current",{},"New",{}]},{"entry":["State","Event","State","Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Disabled","all","Disabled","None"]},{"entry":[{},{},"(no"]},{"entry":[{},{},"change)"]},{"entry":["Down","START - Initiate the","Init-Sent","Format and send an"]},{"entry":[{},"adjacency establishment",{},"INIT request, and start"]},{"entry":[{},"process",{},"the retransmission"]},{"entry":[{},{},{},"timer."]},{"entry":["Down","INIT_RECEIVED - The","Init-","Format and send an"]},{"entry":[{},"local node has received","Received","INIT reply and an"]},{"entry":[{},"an INIT request from its",{},"INIT request; start"]},{"entry":[{},"neighbor",{},"the retransmission"]},{"entry":[{},{},{},"timer"]},{"entry":["Init-Sent","INIT_RECEIVED -","Init-","Format and send an"]},{"entry":[{},"local node has received","Received","INIT reply"]},{"entry":[{},"INIT request from"]},{"entry":[{},"neighbor"]},{"entry":["Init-Sent","IACK_RECEIVED -","One-Way","None"]},{"entry":[{},"The local node has"]},{"entry":[{},"received a valid positive"]},{"entry":[{},"response to the INIT"]},{"entry":[{},"request"]},{"entry":["Init-","IACK_RECEIVED -","Exchange","Format and send a"]},{"entry":["Received","The local node has",{},"Hello request."]},{"entry":[{},"received a valid positive"]},{"entry":[{},"response to the INIT"]},{"entry":[{},"request."]},{"entry":["One-Way","INIT_RECEIVED - The","Exchange","Format and send an"]},{"entry":[{},"local node has received",{},"INIT reply"]},{"entry":[{},"an INIT request from the"]},{"entry":[{},"neighbor"]},{"entry":["Exchange","EXCHANGE_DONE -","Active","Start the keep-alive"]},{"entry":[{},"The local node has",{},"and inactivity timers."]},{"entry":[{},"successfully completed"]},{"entry":[{},"the database"]},{"entry":[{},"synchronization phase of"]},{"entry":[{},"the adjacency"]},{"entry":[{},"establishment process."]},{"entry":["All states,","HELLO_RECEIVED -","No","Restart Inactivity timer"]},{"entry":["except","The local node has","change"]},{"entry":["Down","received a valid Hello"]},{"entry":[{},"packet from its neighbor."]},{"entry":["Init-Sent,","TIMER_EXPIRED -","Depends","Change state to Down"]},{"entry":["Init-","The retransmission timer","on the","if MaxRetries has been"]},{"entry":["Received,","has expired","action","reached. Otherwise,"]},{"entry":["Exchange",{},"taken","increment the retry"]},{"entry":[{},{},{},"counter and re-send"]},{"entry":[{},{},{},"the request (INIT if"]},{"entry":[{},{},{},"current state is Init-"]},{"entry":[{},{},{},"Sent or Init-Received."]},{"entry":[{},{},{},"Hello otherwise)."]},{"entry":["Active","TIMER_EXPIRED -","Depends","Increment inactivity"]},{"entry":[{},"The keep-alive timer has","on the","counter by Hello-"]},{"entry":[{},"expired.","action","Interval and if the new"]},{"entry":[{},{},"taken.","value exceeds Hello-"]},{"entry":[{},{},{},"DeadInterval, then"]},{"entry":[{},{},{},"general a"]},{"entry":[{},{},{},"LINK_DOWN event."]},{"entry":["All states,","LINK_DOWN - All","Down","Timeout all database"]},{"entry":["except","links between the two",{},"entries previously"]},{"entry":["Down","nodes have failed and",{},"received from this"]},{"entry":[{},"the neighbor is now",{},"neighbor."]},{"entry":[{},"unreachable."]},{"entry":["All states,","PROTOCOL_ERROR -","Down","Timeout all database"]},{"entry":["except","An unrecoverable",{},"entries previously"]},{"entry":["Down","protocol error has been",{},"received from this"]},{"entry":[{},"detected on this",{},"neighbor."]},{"entry":[{},"adjacency."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"After the successful exchange of INIT packets, the two neighbors enter the Exchange State. Exchange is a transitional state that allows both nodes to synchronize their databases before entering the Active State. Database synchronization involves exchange of one or more Hello packets that transfer the contents of one node's database to the other. A node should not send a Hello request while its awaiting the acknowledgment of another. The exchange may be made more reliable by causing each request to be transmitted repeatedly until a valid acknowledgment is received from the adjacent node.","When a Hello packet arrives at a node, the Hello packet is processed as previously described. Specifically, the node compares each LSA contained in the packet to the copy the node currently has in its own database. If the received copy is more recent then the node's own or advertises a better hop-count, the received copy is written into the database, possibly replacing the current copy. The exchange process is normally considered completed when each node has received, and acknowledged, a null Hello request from its neighbor. The nodes then enter the Active State with fully synchronized databases which contain the most recent copies of all LSAs known to both neighbors.","A sample exchange using the Hello protocol is described in Table 4. In the following exchange, node  has four LSAs in its database, while node  has none.",{"@attributes":{"id":"p-0092","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sample exchange."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Node 1","Node 2"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Send Hello Request","Send Hello Request"]},{"entry":["Sequence: 1","Sequence: 1"]},{"entry":["Contents: LSA1, LSA2, LSA2, LSA4","Contents: null"]},{"entry":["Send Hello Response","Send Hello Response"]},{"entry":["Sequence: 1","Sequence: 1"]},{"entry":["Contents: null","Contents: 0x000f (acknowledges"]},{"entry":[{},"all four LSAs)"]},{"entry":["Send Hello Request","Send Hello Response"]},{"entry":["Sequence: 2","Sequence: 2"]},{"entry":["Contents: null (no more entries)","Contents: null"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Another example is the exchange described in table 5. In the following exchange, node  has four LSAs (1 through 4) in its database, and node  has 7 (3 and 5 through 10). Additionally, node  has a more recent copy of LSA3 in its database than node .",{"@attributes":{"id":"p-0094","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sample exchange."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Node 1","Node 2"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Send Hello Request","Send Hello Request"]},{"entry":["Sequence: 1","Sequence: 1"]},{"entry":["Contents: LSA1, LSA2, LSA2,","Contents: LSA3, LSA5, LSA6,"]},{"entry":["LSA4","LSA7"]},{"entry":["Send Hello Response","Send Hello Response"]},{"entry":["Sequence: 1","Sequence: 1"]},{"entry":["Contents: null","Contents: 0x000f (acknowledges"]},{"entry":[{},"all four LSAs)"]},{"entry":["Send Hello Request","Send Hello Response"]},{"entry":["Sequence: 2","Sequence: 2"]},{"entry":["Contents: null (no more entries)","Contents: LSA8, LSA9, LSA10"]},{"entry":["Send Hello Response","Send Hello Response"]},{"entry":["Sequence: 2","Sequence: 2"]},{"entry":["Contents: 0x0007 (acknowledges all","Contents: null"]},{"entry":"three LSAs)"},{"entry":["Send Hello Response","Send Hello Request"]},{"entry":["Sequence: 3","Sequence: 3"]},{"entry":["Contents: null","Contents: null (no more entries)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"At the end of the exchange, both nodes will have the most recent copy of all 10 LSAs (1 through 10) in their databases.","Provisioning","For each VP that is to be configured (or, as also referred to herein, provisioned), a physical path must be selected and configured. VPs may be provisioned statically or dynamically. For example, a user can identify the nodes through which the VP will pass and manually configure each node to support the given VP. The selection of nodes may be based on any number of criteria, such as QoS, latency, cost, and the like. Alternatively, the VP may be provisioned dynamically using any one of a number of methods, such as a shortest path first technique or a distributed technique. A shortest path first technique might, for example, employ an embodiment of the present invention. An example of a distributed technique is the restoration method described subsequently herein.","Failure Detection, Propagation, and Restoration","Failure Detection and Propagation","In one embodiment of networks herein, failures are detected using the mechanisms provided by the underlying physical network. For example, when using a SONET network, a fiber cut on a given link results in a loss of signal (LOS) condition at the nodes connected by that link. The LOS condition propagated an Alarm Indication Signal (AIS) downstream, and Remote Defect Indication (RDI) upstream (if the path still exists), and an LOS defect locally. Later, the defect is upgraded to a failure 2.5 seconds later, which causes an alarm to be sent to the Operations System (OS) (per Bellcore's recommendations in GR-253 (GR-253(T) , Common Generic Criteria, Issue 2 [Bellcore, December 1995], included herein by reference, in its entirety and for all purposes)). Preferably when using SONET, the handling of the LOS condition follows Bellcore's recommendations in GR-253, which allows nodes to inter-operate, and co-exist, with other network equipment (NE) in the same network. The mesh restoration protocol is invoked as soon as the LOS defect is detected by the line card, which occurs 3 ms following the failure (a requirement under GR-253).","The arrival of the AIS at the downstream node causes a similar alarm to be sent to the downstream node's downstream neighbor and for that node to send an AIS to its own downstream neighbor. This continues from node to node until the AIS finally reaches the source node of the affected VP, or a proxy border node if the source node is located in a different zone. In the latter case, the border node restores the VP on behalf of the source node. Under GR-253, each node is allowed a maximum of 125 microseconds to forward the AIS downstream, which quickly propagates failures toward the source node.","Once a node has detected a failure on one of its links, either through a local LOS defect or a received AIS indication, the node scans its VP table looking for entries that have the failed link in their path. When the node finds one, the node releases all link bandwidth used by the VP. Then, if the node is a VP's source node or a proxy border node, the VP's state is changed to RESTORING and the VP placed on a list of VPs to be restored. Otherwise (if the node isn't the source node or a proxy border node), the state of the VP is changed to DOWN, and a timer is started to delete the VP from the database if a corresponding restore-path request isn't received from the origin node within a certain timeout period. The VP list that was created in the previous step is ordered by quality of service (QoS), which ensures that VPs with a higher QoS setting are restored first. Each entry in the list contains, among other things, the ID of the VP, its source and destination nodes, configured QoS level, and required bandwidth.",{"@attributes":{"id":"p-0101","num":"0117"},"figref":"FIG. 9","b":["900","910","920","930","940","950","960","970","980","990"]},"Failure Restoration","For each VP on the list, the node then sends an RPR to all eligible neighbors in order to restore the given VP. The network will, of course, attempt to restore all failed VPs. Neighbor eligibility is determined by the state of the neighbor, available link bandwidth, current zone topology, location of the Target node, and other parameters. One method for determining the eligibility of a particular neighbor follows:\n\n","Due to the way RPR messages are forwarded by tandem nodes and the unconditional and periodic retransmission of such messages by origin nodes, multiple instances of the same request are not uncommon, even multiple copies of each instance, circulating the network at any given time. To minimize the amount of broadcast traffic generated by the protocol and aid tandem nodes in allocating bandwidth fairly for competing RPRs, tandem nodes preferably execute a sequence such as that described subsequently.","The term \u201csame instance,\u201d as used below, refers to messages that carry the same VP ID, origin node ID, and hop-count, and are received from the same tandem node (usually, the same input link, assuming only one link between nodes). Any two messages that meet the above criteria are guaranteed to have been sent by the same origin node, over the same link, to restore the same VP, and to have traversed the same path. The terms \u201ccopy of an instance,\u201d or more simply \u201ccopy\u201d are used herein to refer to a retransmission of a given instance. Normally, tandem nodes select the first instance they receive since in most, but not all cases, as the first RPR received normally represents the quickest path to the origin node. A method for making such a determination was described in reference to . Because such information must be stored for numerous RPRs, a standard data structure is defined under a protocol of the present invention.","The Restore-Path Request Entry (RPRE) is a data structure that maintains information about a specific instance of a RPRE packet. Tandem nodes use the structure to store information about the request, which helps them identify and reject other instances of the request, and allows them to correlate received responses with forwarded requests. Table 6 lists an example of the fields that are preferably present in an RPRE.",{"@attributes":{"id":"p-0107","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"RPR Fields"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Origin Node","The Node ID of the node that originated this"]},{"entry":[{},"request. This is either the source node of the"]},{"entry":[{},"VP or a proxy border node."]},{"entry":["Target Node","Node ID of the target node of the restore path"]},{"entry":[{},"request. This is either the destination node of"]},{"entry":[{},"the VP or a proxy border node."]},{"entry":["Received From","The neighbor from which we received this"]},{"entry":[{},"message."]},{"entry":["First Sequence Number","Sequence number of the first received copy of"]},{"entry":[{},"the corresponding restore-path request."]},{"entry":["Last Sequence Number","Sequence number of the last received copy of"]},{"entry":[{},"the corresponding restore-path request."]},{"entry":["Bandwidth","Requested bandwidth"]},{"entry":["QoS","Requested QoS"]},{"entry":["Timer","Used by the node to timeout the RPR"]},{"entry":["T-Bit","Set to 1 when a Terminate indicator is received"]},{"entry":[{},"from any of the neighbors."]},{"entry":["Pending Replies","Number of the neighbors that haven't"]},{"entry":[{},"acknowledged this message yet."]},{"entry":["Sent To","A list of all neighbors that received a copy of"]},{"entry":[{},"this message. Each entry contains the following"]},{"entry":[{},"information about the neighbor:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AckReceived:","Indicates if a response has"]},{"entry":[{},{},"been received from this"]},{"entry":[{},{},"neighbor."]},{"entry":[{},"F-Bit:","Set to 1 when Flush indicator"]},{"entry":[{},{},"from this neighbor."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"When an RPR packet arrives at a tandem node, a decision is made as to which neighbor should receive a copy of the request. The choice of neighbors is related to variables such as link capacity and distance. Specifically, a particular neighbor is selected to receive a copy of the packet if:\n\n","The Processing of Received RPRs",{"@attributes":{"id":"p-0110","num":"0136"},"figref":"FIG. 10"},"Processing of RPRs begins at step , in which the target node's ID is compared to the local node's ID. If the local node's ID is equal to the target node's ID, the local node is the target of the RPR and must process the RPR as such. This is illustrated in  as step  and is the subject of the flow diagram illustrated in . If the local node is not the target node, the RPR's HOP_COUNT is compared to MAX_HOPS in order to determine if the HOP_COUNT has exceed or will exceed the maximum number of hops allowable (step ). If this is the case, a negative acknowledgment (NAK) with a Flush indicator is then sent back to the originating node (step ). If the HOP_COUNT is still within acceptable limits, the node then determines whether this is the first instance of the RPR having been received (step ). If this is the case, a Restore-Path Request Entry (RPRE) is created for the request (step ). This is done by creating the RPRE and setting the RPRE's fields, including starting a time-to-live (TTL) or deletion timer, in the following manner:\n\n","The ID of the input link is then added to the path in the RPRE (e.g., Path[PathIndex++]=LinkID) (step ). Next, the local node determines whether the target node is a direct neighbor (step ). If the target node is not a direct neighbor of the local node, a copy of the (modified) RPR is sent to all eligible neighbors (step ). The PendingReplies and SentTo Fields of the corresponding RPRE are also updated accordingly at this time. If the target node is a direct neighbor of the local node, the RPR is sent only to the target node (step ). In either case, the RPRE corresponding to the given RPR is then updated (step ).","If this is not the first instance of the RPR received by the local node, the local node then attempts to determine whether this might be a different instance of the RPR (step ). A request is considered to be a different instance if the RPR:\n\n","If this is simply a different instance of the RPR, and another instance of the same RPR has been processed, and accepted, by this node, a NAK Wrong Instance is sent to the originating neighbor (step ). The response follows the reverse of the path carried in the request. No broadcasting is therefore necessary in such a case. If a similar instance of the RPR has been processed and accepted by this node (step ), the local node determines whether a Terminate NAK has been received for this RPR (step ). If a Terminate NAK has been received for this RPR, the RPR is rejected by sending a Terminate response to the originating neighbor (step ). If a Terminate NAK was not received for this RPR, the new sequence number is recorded (step ) and a copy of the RPR is forwarded to all eligible neighbors that have not sent a Flush response to the local node for the same instance of this RPR (step ). This may include nodes that weren't previously considered by this node due to conflicts with other VPs, but does not include nodes from which a Flush response has already been received for the same instance of this RPR. The local node should then save the number of sent requests in the PendingReplies field of the corresponding RPRE. The term \u201celigible neighbors\u201d refers to all adjacent nodes that are connected through links that meet the link-eligibility requirements previously described. Preferably, bandwidth is allocated only once for each request so that subsequent transmissions of the request do not consume any bandwidth.","Note that the bandwidth allocated for a given RPR is released differently depending on the type of response received by the node and the setting of the Flush and Terminate indicators in its header. Table 7 shows the action taken by a tandem node when a restore path response is received from one of its neighbors.",{"@attributes":{"id":"p-0116","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Actions taken by a tandem node upon receiving an RPR."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"Received",{}]},{"entry":["Response","Flush","Terminate","Sequence"]},{"entry":["Type","Indicator?","Indicator?","Number","Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["X","X","X","Not Valid","Ignore response"]},{"entry":["Negative","No","No","1 = Last","Ignore response"]},{"entry":["Negative","X","No","=Last","Release bandwidth"]},{"entry":[{},{},{},{},"allocated for the VP on"]},{"entry":[{},{},{},{},"the link the response was"]},{"entry":[{},{},{},{},"received on"]},{"entry":["Negative","Yes","No","Valid","Release bandwidth"]},{"entry":[{},{},{},{},"allocated for the VP on"]},{"entry":[{},{},{},{},"the link that the response"]},{"entry":[{},{},{},{},"was received on"]},{"entry":["Negative","X","Yes","Valid","Release all bandwidth"]},{"entry":[{},{},{},{},"allocated for the VP"]},{"entry":["Positive","X","X","Valid","Commit bandwidth"]},{"entry":[{},{},{},{},"allocated for the VP on"]},{"entry":[{},{},{},{},"the link the response was"]},{"entry":[{},{},{},{},"received on; release all"]},{"entry":[{},{},{},{},"other bandwidth."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0117","num":"0154"},"figref":"FIG. 11","b":["1110","1105","1110","1105"]},"If the VP specified in the RPR terminates at this node (i.e. this node is indeed the target node), the target node determines whether an RPRE exists for the RPR received (step ). If an RPRE already exists for this RPR, the existing RPRE is updated (e.g., the RPRE's LastSequenceNumber field is updated) (step ) and the RPRE deletion timer is restarted (step ). If no RPRE exists for this RPR in the target node (i.e., if this is the first copy of the instance received), an RPRE is created (step ), pertinent information from the RPR is copied into the RPRE (step ), the bandwidth requested in the RPR is allocated on the input link by the target node (step ) and an RPRE deletion timer is started (step ). In either case, once the RPRE is either updated or created, a checksum is computed for the RPR (step ) and written into the checksum field of the RPR (step ). The RPR is then returned as a positive response to the origin node (step ). The local (target) node then starts its own matrix configuration. It will be noted that the RPRE created is not strictly necessary, but makes the processing of RPRs consistent across nodes.","The Processing of Received RPR Responses",{"@attributes":{"id":"p-0120","num":"0157"},"figref":["FIGS. 12 and 13","FIG. 12"],"b":["1200","1205","1210","1205"]},"If the sending node is listed in the RPRE, the RPR sequence number is analyzed for validity (step ). As with the previous steps, if the RPR contains an invalid sequence number (e.g., doesn't fall between FirstSequenceNumber and LastSequence Number, inclusive), the RPR response is ignored (step ). If the RPR sequence number is valid, the receiving node determines whether Flush or Terminate in the RPR response (step ). If neither of these is specified, the RPR response sequence number is compared to that stored in the last sequence field of the RPR (step ). If the RPR response sequence number does not match that found in the last sequence field of the RPRE, the RPR response is again ignored (step ). If the RPR response sequence number matches that found in the RPRE, or a Flush or Terminate was specified in the RPR, the input link on which the RPR response was received is compared to that listed in the RPR response path field (e.g., Response.Path[Response.PathIndex]==InputLinkID) (step ). If the input link is consistent with information in the RPR, the next hop information in the RPR is checked for consistency (e.g., Response.Path [Response.PathIndex+1]==RPRE.ReceivedFrom) (step ). If either of the proceeding two tests are failed the RPR response is again ignored (step ).","If a Terminate was specified in the RPR response (step ), the bandwidth on all links over which the RPR was forwarded is freed (step ) and the Terminate and Flush bits from the RPR response are saved in the RPRE (step ). If a Terminate was not specified in the RPR response, bandwidth is freed only on the input link (i.e., the link from which the response was received) (step ), the Terminate and Flush bits are saved in the RPRE (step ), and the Flush bit of the RPR is cleared (step ). If a Terminate was not specified in the RPR, the Pending Replies field in the RPRE is decremented (step ). If this field remains non-zero after being decremented, the process completes. If Pending Replies is equal to zero at this point, or a Terminate was not specified in the RPR, the RPR is sent to the node specified in the RPR's Received From field (i.e. the node that sent the corresponding request) (step ). Next, the bandwidth allocated on the link to the node specified in the RPR's Received From field is released (step ) and an RPR deletion timer is started (step ).",{"@attributes":{"id":"p-0123","num":"0160"},"figref":"FIG. 13","b":["1300","1310","1320","1310","1330","1310","1340","1350","1360","1370","1380"]},"With regard to matrix configuration, the protocol pipelines such activity with the forwarding of RPRs in order to minimize the impact of matrix configuration overhead on the time required for restoration. While the response is making its way from node N to node N, node N is configuring its matrix. In most cases, by the time the response reaches the origin node, all nodes along the path have already configured their matrices.","The Terminate indicator prevents \u201cbad\u201d instances of an RPR from circulating around the network for extended periods of time. The indicator is propagated all the way back to the originating node and prevents the originating node, and all other nodes along the path, from sending or forwarding other copies of the corresponding RPR instance.","Terminating RPR Packets are processed as follows. The RPR continues along the path until any one of the following four conditions is encountered:\n\n","Further optimizations of the protocol can easily be envisioned by one of ordinary skill in the art, and are intended to be within the scope of this specification. For example, in one embodiment, a mechanism is defined to further reduce the amount of broadcast traffic generated for any given VP. In order to prevent an upstream neighbor from sending the same instance of an RPR every T milliseconds, a tandem node can immediately return a no-commit positive response to that neighbor, which prevents the neighbor from sending further copies of the instance. The response simply acknowledges the receipt of the request, and doesn't commit the sender to any of the requested resources. Preferably, however, the sender (of the positive response) periodically transmits the acknowledged request until a valid response is received from its downstream neighbor(s). This mechanism implements a piece-wise, or hop-by-hop, acknowledgment strategy that limits the scope of retransmitted packets to a region that gets progressively smaller as the request gets closer to its target node.","Optimizations","However, it is prudent to provide some optimizations for efficiently handling errors. Communication protocols often handle link errors by starting a timer after every transmission and, if a valid response isn't received within the timeout period, the message is retransmitted. If a response isn't received after a certain number of retransmission, the sender generates a local error and disables the connection. The timeout period is usually a configurable parameter, but in some cases the timeout period is computed dynamically, and continuously, by the two end points. The simplest form of this uses some multiple of the average round trip time as a timeout period, while others use complex mathematical formulas to determine this value. Depending on the distance between the two nodes, the speed of link that connects them, and the latency of the equipment along the path, the timeout period can range anywhere from millisecond to seconds.","The above strategy, is not the preferred method of handling link errors in the present invention. This is because the fast restoration times required dictates that 2-way, end-to-end communication be carried out in less than 50 ms. A drawback of the above-described solution is the time wasted while waiting for an acknowledgment to come back from the receiving node. A safe timeout period for a 2000 mile span, for instance, is over 35 ms, which doesn't leave enough time for a retransmission in case of an error.","This problem is addressed in one embodiment by taking advantage of the multiple communication channels, i.e. OC-48's that exist between nodes to:\n\n",{"@attributes":{"id":"p-0132","num":"0175"},"figref":"FIG. 14","b":["1400","1400","1405","1410","1415","1455","1415","0","1445","6"]},"Network  is flat, meaning that all nodes belong to the same zone, zone  or the backbone zone. This also implies that Node IDs and Node Addresses are one and the same, and that the upper three bits of the Node ID (address) are always zeroes using the aforementioned node ID configuration. Tables 8A, 8B and 8C show link information for network . Source nodes are listed in the first column, and the destination nodes are listed in the first row of Tables 8A, 8B and 8C. The second row of Table 8A lists the link ID. The second row of Table 8B lists the available bandwidth over the corresponding link. The second row of Table 8C lists distance associated with each of the links. In this example, no other metrics (e.g., QoS) are used in provisioning the VPs listed subsequently.",{"@attributes":{"id":"p-0134","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8A"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Link IDs for network 1400."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","1","2","3","4","5","6","7","8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"9","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","*","0","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","1"]},{"entry":["1","0","*","2","3","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["2","\u2014","2","*","\u2014","4","\u2014","\u2014","\u2014","\u2014"]},{"entry":["3","\u2014","3","\u2014","*","5","\u2014","6","\u2014","7"]},{"entry":["4","\u2014","\u2014","4","5","*","8","\u2014","\u2014","\u2014"]},{"entry":["5","\u2014","\u2014","\u2014","\u2014","8","*","9","\u2014","\u2014"]},{"entry":["6","\u2014","\u2014","\u2014","6","\u2014","9","*","10","\u2014"]},{"entry":["7","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","10","*","11"]},{"entry":["8","1","\u2014","\u2014","7","\u2014","\u2014","\u2014","11","*"]},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0135","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8B"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Link bandwidth for network 1400."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","1","2","3","4","5","6","7","8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"9","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"8","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","*","18","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","19"]},{"entry":["1","18","*","12","17","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["2","\u2014","12","*","\u2014","13","\u2014","\u2014","\u2014","\u2014"]},{"entry":["3","\u2014","17","\u2014","*","16","\u2014","22","\u2014","10"]},{"entry":["4","\u2014","\u2014","13","16","*","14","\u2014","\u2014","\u2014"]},{"entry":["5","\u2014","\u2014","\u2014","\u2014","14","*","6","\u2014","\u2014"]},{"entry":["6","\u2014","\u2014","\u2014","22","\u2014","6","*","39","\u2014"]},{"entry":["7","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","39","*","15"]},{"entry":["8","19","\u2014","\u2014","10","\u2014","\u2014","\u2014","15","*"]},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0136","num":"0179"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8C"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Link distances for network 1400."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","1","2","3","4","5","6","7","8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"9","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"10"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","*","10","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","8"]},{"entry":["1","10","*","6","14","\u2014","\u2014","\u2014","\u2014","\u2014"]},{"entry":["2","\u2014","6","*","\u2014","11","\u2014","\u2014","\u2014","\u2014"]},{"entry":["3","\u2014","14","\u2014","*","7","\u2014","8","\u2014","15"]},{"entry":["4","\u2014","\u2014","11","7","*","13","\u2014","\u2014","\u2014"]},{"entry":["5","\u2014","\u2014","\u2014","\u2014","13","*","9","\u2014","\u2014"]},{"entry":["6","\u2014","\u2014","\u2014","8","\u2014","9","*","20","\u2014"]},{"entry":["7","\u2014","\u2014","\u2014","\u2014","\u2014","\u2014","20","*","19"]},{"entry":["8","8","\u2014","\u2014","15","\u2014","\u2014","\u2014","19","*"]},{"entry":{"@attributes":{"namest":"1","nameend":"10","align":"center","rowsep":"1"}}}]}}]}}},"Table 9A shows a list of exemplary configured VPs, and Table 9B shows the path selected for each VP by a shortest-path algorithm according to the present invention. The algorithm allows a number of metrics, e.g. distance, cost, delay, and the like to be considered during the path selection process, which makes possible the routing of VPs based on user preference. Here, the QOS metric is used to determine which VP has priority.",{"@attributes":{"id":"p-0138","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9A"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Configured VPs."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VP ID","Source Node","Destination Node","Bandwidth","QoS"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["0","0","6","1","3"]},{"entry":["1","0","5","2","0"]},{"entry":["2","1","7","1","1"]},{"entry":["3","4","6","2","2"]},{"entry":["4","3","5","1","3"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0139","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9B"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Initial routes."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VP ID","Path (Numbers represent node IDs)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["0","0\u21921\u21923\u21926"]},{"entry":["1","0\u21921\u21923\u21924\u21925"]},{"entry":["2","1\u21923\u21926\u21927"]},{"entry":["3","4\u21923\u21926"]},{"entry":["4","3\u21924\u21925"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Path Selection","Paths are computed using what is referred to herein as a QoS-based shortest-path first (QSPF) technique. This may be done, for example, during the provisioning or the restoration of VPs. The path selection process relies on configured metrics and an up-to-date view of network topology to find the shortest paths for configured VPs. The topology database stored by each node contains information about all available network nodes, their links, and other metrics, such as the links' available capacity. Node IDs may be assigned by the user, for example, and should be globally unique. This gives the user control over the master\/slave relationship between nodes. Duplicate IDs are detected by the network during adjacency establishment. All nodes found with a duplicate ID are preferably disabled by the protocol, and an appropriate alarm is generated to notify the network operations center of the problem so that appropriate action can be taken.","In the example of a QSPF technique described herein, the following variables are employed:\n\n","Two of the many embodiments of this method are now described. The first of these two methods allows for the determination of a path from the root node to another node using criteria such as a minimum number of hops or a path between the root node and the other node having the lowest cost based on connectivity information stored by the method in a path table. For this purpose, cost is discussed in terms of quality of service, and so can subsume physical distance, availability, cost of service, and other such characteristics. Another embodiment provides only the cost associated with the minimum cost path for each destination node reachable from the root node, again based on connectivity information stored in a path table or vector. This embodiment is useful for quickly determining the minimum cost possible between the root node and another node, and may be used in determining if any path exists with an acceptably low cost, for example. The first of these two approaches proceeds as follows (once again, R is the root node, i.e. the one computing the path(s)):",{"@attributes":{"id":"p-0144","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For each node n known to R:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If (n neighbor R):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Path [n][1].Cost = Neighbors[n].LinkCost"]},{"entry":[{},"Path [n][1].NextNode = n"]},{"entry":[{},"Path [n][1].PrevNode = R"]},{"entry":[{},"Place n in Ready"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Path [n][1].Cost = MAX_COST"]},{"entry":[{},"Path [n][1].NextNode = NULL_NODE"]},{"entry":[{},"Path [n][1].PrevNode = NULL_NODE"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For ( h = 2 through H):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If (Ready != empty):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For each node k, where k = 0 to N:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Path[k][h].Cost = Path[k][h\u22121].Cost"]},{"entry":[{},"Path[k][h].NextNode = Path[k][h\u22121].NextNode"]},{"entry":[{},"Path[k][h].PrevNode = Path[k][h\u22121].PrevNode"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For each node n already in Ready (not including nodes added this iteration):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For each neighbor m of n (as listed in n's LSA):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If((Path[n][h\u22121].Cost + LinkCost (n\u2013m)) < Path[m][h].Cost):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Path[m][h].Cost = Path[n][h\u22121].Cost + LinkCost (n\u2013m)"]},{"entry":[{},"Path[m][h].NextNode = Path[n][h\u22121].NextNode"]},{"entry":[{},"Path[m][h].PrevNode = n"]},{"entry":[{},"Place m in Ready"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(processed on next iteration of outermost for-loop)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Go to DONE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"DONE:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LastHop = h"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0145","num":"0192"},"figref":"FIG. 15A","b":["1500","1502","1504","1506","1508"]},"The root node then goes on to fill other columns of the array (step ) until the Ready queue, which holds a list of nodes waiting to be processed, is empty (step ). Assuming that nodes remain to be processed (step ), entries of the column preceding the current column are copied into entries of the current column (steps  and ). It will be noted that this step could simply be performed for all columns (including or not including the first column) in a separate loop, in which costs would be initialized to MAX_COST and next\/previous node entries would be initialized to NULL_NODE. The next node in the Ready queue is then selected (step ). It is noted that only nodes in the Ready queue at the beginning of the current iteration of the outer-most loop illustrated in  are processed in the current iteration. Nodes added to the Ready queue during the current iteration are not processed until the following iteration.","For each neighbor of the node selected from the Ready queue (the selected node) (step ), the cost of the path from the root node to the selected node is added to the cost of the link between the selected node and its neighbor, and the result compared to the current minimum path cost (step ). If the result is smaller than the current minimum path cost (step ), the current path cost is set to the result, the next node entry is set to the selected node's next node value, and the previous node is set to identify the selected node. An identifier identifying the neighbor is then placed on the Ready queue (step ). The process loops if neighbors of the selected node have not been processed (step ). If more nodes await processing in the Ready queue, they are processed in order (step ), but if all nodes have been processed, the process jumps out of the loop and saves the last value of h in LastHop (step ). LastHop allows the minimum-cost path retrieval procedure to process only the columns necessary to determining the minimum-cost path. The QSPF process is then at an end.","The path table now holds information that allows the determination of both the lowest-cost path from the root node to a given destination node, and the path from the root node to a given destination node having the minimum number of hops. It will be noted that the process now described assumes that the path table is ordered with columns corresponding to the number of hops from the root (source) node, although it will be apparent to one of ordinary skill in the art that a different ordering could be employed with minor modifications to the process. To determine the minimum-hop path from the root node (source node) to another node (destination node) using the information in the path table, row n of the array is searched until an entry with a cost not equal to MAX_COST is found. The following procedure may be employed to achieve this end:",{"@attributes":{"id":"p-0149","num":"0196"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"CurrRow = DestinationNode"},{"entry":"CurrColumn = 1"},{"entry":"NumHops = 1"},{"entry":"While (Path[CurrRow][CurrColumn].Cost == MAX_COST)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NumHops = NumHops + 1"]},{"entry":[{},"CurrColumn = CurrColumn + 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NewPath[CurrColumn + 1] = DestinationNode"},{"entry":"While (Path[CurrRow][CurrColumn].PrevNode != R)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NewPath[CurrColumn] = Path[CurrRow][CurrColumn].PrevNode"]},{"entry":[{},"CurrRow = Path[CurrRow][CurrColumn].PrevNode"]},{"entry":[{},"CurrColumn = CurrColumn \u2212 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NewPath[CurrColumn] = R"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0150","num":"0197"},"figref":"FIG. 15B","b":["1530","1532","1534","1536","1532"]},"The path is stored in NewPath by traversing the path from the destination node to the root node using the path table's previous node entries. The path from the destination node is thus traversed in the reverse order from that taken in generating the table. First, the destination node is placed in NewPath at location (CurrColumn+1) (step ). Next, the previous node entry of the current path table entry is examined to determine if the root node has been reached (step ). If the root node has not yet been reached, the previous node entry is placed in NewPath (step ). The current row is then set to the row corresponding to the previous node entry in the current path table entry (step ), and the column counter decremented (step ). This continues until the root node is reached (step ). The root node is then the root node is placed in NewPath (step ). The process is then complete, whereupon NewPath contains the minimum-hop path between the root node and the destination node.","To determine the minimum-cost path from the root node (source node) to another node (destination node), regardless of the hop-count, the entries of the row corresponding to the destination node are scanned, and the entry with the lowest cost selected. This may be done, for example, by employing the following procedure:",{"@attributes":{"id":"p-0153","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"CurrRow = DestinationNode"},{"entry":"CurrNumHops = 1"},{"entry":"MinCost = MAX_COST"},{"entry":"For CurrColumn = 1 to LastHop"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (Path[CurrRow][CurrColumn].Cost < MinCost)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MinCostNumHops = CurrNumHops"]},{"entry":[{},"MinCostColumn = CurrColumn"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CurrNumHops = CurrNumHops + 1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"CurrColumn = MinCostColumn"},{"entry":"NewPath[CurrColumn + 1] = DestinationNode"},{"entry":"While (Path[CurrRow][CurrColumn].PrevNode != R)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NewPath[CurrColumn] = Path[CurrRow][CurrColumn].PrevNode"]},{"entry":[{},"CurrRow = Path[CurrRow][CurrColumn].PrevNode"]},{"entry":[{},"CurrColumn = CurrColumn \u2212 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"NewPath[CurrColumn] = R"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0154","num":"0201"},"figref":"FIG. 15C","b":["1550","1552","1554","1556","1558","1560","1552"]},"The path is stored in NewPath by traversing the path from the destination node to the root node using the path table's previous node entries. The path from the destination node is thus traversed in the reverse order from that taken in generating the table. First, the current column is set to the column having the lowest cost (step ) and the destination node is placed in NewPath at location (CurrColumn+1) (step ). Next, the previous node entry of the current path table entry is examined to determine if the root node has been reached (step ). If the root node has not yet been reached, the previous node entry is placed in NewPath (step ). The current row is then set to the row corresponding to the previous node entry in the current path table entry (step ), and the column counter decremented (step ). This continues until the root node is reached (step ). The root node is then the root node is placed in NewPath (step ). The process is then complete, whereupon NewPath contains the minimum-cost path between the root node and the destination node. In this scenario, MinCostNumHops contains the number of hops in the minimum-cost path.","Several alternative ways of implementing the method of the present invention will be apparent to one of ordinary skill in the art, and are intended to come within the scope of the claims appended hereto. For example, the minimum number of hops for the minimum-cost path may be determined at the time the path is stored. Additionally, the method could be modified to continue copying one column to the next, whether or not the Ready queue was empty, and simply begin storing the path using the last column of the path table, as the last column would contain an entry corresponding to the minimum cost path to the destination node. Other modifications and alterations will be apparent to one of ordinary skill in the art, and are also intended to come within the scope of the claims appended hereto. Moreover, it will be noted that the information held in each entry in the path table includes a \u201cnext node\u201d entry. This indicates the \u201cgateway\u201d node for the path (i.e., the node nearest the root node through which the minimum hop\/lowest cost path must pass).","The second embodiment, based on the preceding embodiment, generates a path table that stores the cost associated with the minimum cost path from the root node to a given destination node. As noted, this embodiment may be used in determining if any path exists with an acceptably low cost, for example. In this embodiment, the path table (Path) may be an nx1 (or 1xn) array (or vector), for example. The second embodiment proceeds as follows:",{"@attributes":{"id":"p-0158","num":"0205"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"For each node n known to R:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If (n neighbor R):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Path[n].Cost = Neighbors[n].LinkCost"]},{"entry":[{},"Place n in Ready"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Path[n].Cost = MAX_COST"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"For ( h = 2 through MAX_HOPS):"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If (Ready != empty):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For each node n already in Ready (not including nodes added this iteration):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For each neighbor m of n (as listed in n's LSA):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If((Path[n].Cost + LinkCost (n\u2013m)) < Path[m].Cost):"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Path[m].Cost = Path[n].Cost + LinkCost (n\u2013m)"]},{"entry":[{},"Place m in Ready"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(processed on next iteration of outermost for-loop)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Done Creating Path Table",{"@attributes":{"id":"p-0160","num":"0207"},"figref":"FIG. 15D","b":["1570","1572","1574","1506","1508"]},"The root node then goes on to complete the path table (step ) until the Ready queue, which holds a list of nodes waiting to be processed, is empty (step ). Assuming that nodes remain to be processed (step ), the next node in the Ready queue is selected (step ). It is noted that only nodes in the Ready queue at the beginning of the current iteration of the outer-most loop illustrated in  are processed in the current iteration. Nodes added to the Ready queue during the current iteration are not processed until the following iteration.","For each neighbor of the node selected from the Ready queue (the selected node) (step ), the cost of the path from the root node to the selected node is added to the cost of the link between the selected node and its neighbor, and the result compared to the current minimum path cost (step ). If the result is smaller than the current minimum path cost (step ), the current path cost is set to the result (step ) and an identifier identifying the neighbor is placed on the Ready queue (step ). The process loops if neighbors of the selected node have not been processed (step ). If more nodes await processing in the Ready queue, they are processed in order (step ), but if all nodes have been processed, the process is at an end.","Each entry in Path now contains the cost of minimum-cost path from the root node to each destination node. Because this embodiment neither stores nor provides any information regarding the specific nodes in any of the minimum-cost paths, no procedures for retrieving such paths from a path table thus created need be provided.","Format and Usage of Protocol Messages","Protocol messages (or packets) preferably begin with a standard header to facilitate their processing. Such a header preferably contains the information necessary to determine the type, origin, destination, and identity of the packet. Normally, the header is then followed by some sort of command-specific data (e.g., zero or more bytes of information).","Such a header may include, for example, a request response indicator (RRI), a negative response indicator (NRI), a terminate\/commit path indicator (TPI), a flush path indicator (FPI), a command field, a sequence number, an origin node ID () and a target node ID. A description of these fields is provided below in Table 10. It will be noted that although the terms \u201corigin\u201d and \u201ctarget\u201d are used in describing header , their counterparts (source and destination, respectively) can be used in their stead. Preferably, packets sent using a protocol according to the present invention employ a header layout such as that shown as header . The header is then followed by zero or more bytes of command specific data.",{"@attributes":{"id":"p-0166","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"The layout of exemplary header 1600."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["R-bit","This bit indicates whether the packet is a request (0) or"]},{"entry":[{},"a response (1). The bit also known as the request\/"]},{"entry":[{},"response indicator or RRI for short."]},{"entry":["N-bit","This bit, which is only valid in response packets"]},{"entry":[{},"(RRI = 1), indicates whether response is positive (0) or"]},{"entry":[{},"negative (1). The bit is also known as the Negative"]},{"entry":[{},"Response Indicator or NRI."]},{"entry":["T\/C Bit","In a negative response (NRI = 1), this bit is called a"]},{"entry":[{},"Terminate Path Indicator or TPI. When set, TPI"]},{"entry":[{},"indicates that the path along the receiving link"]},{"entry":[{},"should be terminated and never used again for this or"]},{"entry":[{},"any other instance of the corresponding request. The"]},{"entry":[{},"response also releases all bandwidth allocated for the"]},{"entry":[{},"request along all paths, and makes that bandwidth"]},{"entry":[{},"available for use by other requests. A negative"]},{"entry":[{},"response that has a \u201c1\u201d in its T-Bit is called a"]},{"entry":[{},"Terminate response. Conversely, a negative response"]},{"entry":[{},"with a \u201c0\u201d in its T-Bit is called a no-Terminate"]},{"entry":[{},"response. In a positive response (NRI = 0), this bit"]},{"entry":[{},"indicates whether the specified path has been"]},{"entry":[{},"committed to by all nodes (1) or not (0). The purpose"]},{"entry":[{},"of a positive response that has a \u201c0\u201d in its C-Bit is to"]},{"entry":[{},"simply acknowledge the receipt of a particular request"]},{"entry":[{},"and to prevent the upstream neighbor from sending"]},{"entry":[{},"further copies of the request. Such a response is called"]},{"entry":[{},"a no-Commit response."]},{"entry":["F-bit","Flush Indicator. When set, this bit causes the resources"]},{"entry":[{},"allocated on the input link for the corresponding"]},{"entry":[{},"request to be freed, even if the received sequence"]},{"entry":[{},"number doesn't match the last one sent. However, the"]},{"entry":[{},"sequence number has to be valid, i.e., the sequence"]},{"entry":[{},"number has to fall between FirstReceived and"]},{"entry":[{},"LastSent, inclusive. This bit also prevents the node"]},{"entry":[{},"from sending other copies of the failed request over"]},{"entry":[{},"the input link. This bit is reserved and must be set to"]},{"entry":[{},"\u201c0\u201d in all positive responses (NRI = 0)."]},{"entry":["Command","This 4-bit field indicates the type of packet being"]},{"entry":[{},"carried with the header."]},{"entry":["SequenceNumber","A node and VP unique number that, along with the"]},{"entry":[{},"node and VP IDs, helps identify specific instances of a"]},{"entry":[{},"particular command."]},{"entry":["Origin","The node ID of the node that originated this packet."]},{"entry":["Target","The node ID of the node that this packet is destined"]},{"entry":[{},"for."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The protocol can be configured to use a number of different commands. For example, seven commands may be used with room in the header for 9 more. Table 11 lists those commands and provides a brief description of each, with detailed description of the individual commands following.",{"@attributes":{"id":"p-0168","num":"0215"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary protocol commands."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Command Name","Command Code","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["INIT","0","Initialize Adjacency"]},{"entry":["HELLO","1","Used to implement the Hello"]},{"entry":[{},{},"protocol (see Section 3 for more"]},{"entry":[{},{},"details)."]},{"entry":["RESTORE_PATH","2","Restore Virtual Path or VP"]},{"entry":["DELETE_PATH","3","Delete and existing Virtual Path"]},{"entry":["TEST_PATH","4","Test the specified Virtual Path"]},{"entry":["LINK_DOWN","5","Used by slave nodes to inform"]},{"entry":[{},{},"their master(s) of local link"]},{"entry":[{},{},"failures"]},{"entry":["CONFIGURE","6","Used by master notes to"]},{"entry":[{},{},"configure slave nodes."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The Initialization Packet","An initialization packet causes a START event to be sent to the Hello State Machine of the receiving node, and includes a node ID field, a link cost field, one or more QoS capacity fields (e.g., a QoS3 capacity (Q3C) field and a QoSn capacity (QnC) field), a Hello interval field and a time-out interval field.","The initialization (or NIT) packet is used by adjacent nodes to initialize and exchange adjacency parameters. The packet contains parameters that identify the neighbor, its link bandwidth (both total and available), and its configured Hello protocol parameters. The NIT packet is normally the first protocol packet exchanged by adjacent nodes. As noted previously, the successful receipt and processing of the INIT packet causes a START event to be sent to the Hello State machine. The field definitions appear in Table 12.",{"@attributes":{"id":"p-0172","num":"0219"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field definitions for an initialization packet."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NodeID","Node ID of the sending node."]},{"entry":["LinkCost","Cost of the link between the two neighbors. This"]},{"entry":[{},"may represent distance, delay or any other additive"]},{"entry":[{},"metric."]},{"entry":["QoS3Capacity","Link bandwidth that has been reserved for QoS3"]},{"entry":[{},"connection."]},{"entry":["QoSnCapacity","Link bandwidth that is available for use by all QoS"]},{"entry":[{},"levels (0\u20133)."]},{"entry":["HelloInterval","The number of seconds between Hello packets. A"]},{"entry":[{},"zero in this field indicates that this parameter hasn't"]},{"entry":[{},"been configured on the sending node and that the"]},{"entry":[{},"neighbor should use its own configured interval. If"]},{"entry":[{},"both nodes send a zero in this field then the default"]},{"entry":[{},"value should be used."]},{"entry":["HelloDeadInterval","The number of seconds the sending node will wait"]},{"entry":[{},"before declaring a silent neighbor down. A zero in"]},{"entry":[{},"this field indicates that this parameter hasn't been"]},{"entry":[{},"configured on the sending node and that the"]},{"entry":[{},"neighbor should use its own configured value. If"]},{"entry":[{},"both nodes send a zero in this field then the default"]},{"entry":[{},"value should be used."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The Hello Packet","A Hello packet includes a node ID field, an LS count field, an advertising node field, a checksum field, an LSID field, a HOP_COUNT field, a neighbor count field, a neighbor node ID field, a link ID field, a link cost field, a Q3C field, and a QnC field. Hello packets are sent periodically by nodes in order to maintain neighbor relationships, and to acquire and propagate topology information throughout the network. The interval between Hello packets is agreed upon during adjacency initialization. Link state information is included in the packet in several situations, such as when the database at the sending nodes changes, either due to provisioning activity, port failure, or recent updates received from one or more originating nodes. Preferably, only modified LS entries are included in the advertisement. A null Hello packet, also sent periodically, is one that has a zero in its LSCount field and contains no LSAs. Furthermore, it should be noted that a QoSn VP is allowed to use any bandwidth reserved for QoS levels 0 through n. Table 13 describes the fields that appear first in the Hello packet. These fields appear only once.",{"@attributes":{"id":"p-0175","num":"0222"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field definitions for the first two fields of a Hello packet."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NodeID","Node ID of the node that sent this packet, i.e. our neighbor"]},{"entry":["LSCount","Number of link state advertisements contained in this packet"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0176","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field definitions for information carried for each LSA."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["AdvertisingNode","The node that originated this link state entry."]},{"entry":["Checksum","A checksum of the LSAs content, excluding fields that"]},{"entry":[{},"node's other than the originating node can alter."]},{"entry":["LSID","Instance ID. This field is set to FIRST_LSID on the"]},{"entry":[{},"first instance of the LSA, and is incremented for every"]},{"entry":[{},"subsequent instance."]},{"entry":["Hop_Count","This field is set to 0 by the originating node and is"]},{"entry":[{},"incremented at every hop of the flooding procedure."]},{"entry":[{},"An LSA with a Hop_Count of MAX_HOPS is"]},{"entry":[{},"not propagated. LSAs with Hop_Counts equal to or"]},{"entry":[{},"greater than MAX_HOPS are silently discarded."]},{"entry":["NeighborCount","Number of neighbors known to the originating node."]},{"entry":[{},"This is also the number of neighbor entries contained"]},{"entry":[{},"in this advertisement."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0177","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field definitions for information carried for each neighbor."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Neighbor","Node ID of the neighbor being described."]},{"entry":["LinkCost","Cost metric for this link. This could represent distance,"]},{"entry":[{},"delay or any other metric."]},{"entry":["QoS3Capacity","Link bandwidth reserved for the exclusive use of QoS3"]},{"entry":[{},"connections."]},{"entry":["QoSnCapacity","Link bandwidth available for use by all QoS levels (0\u20133)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The GET_LSA Packet","A GET_LSA packet has its first byte set to zero, and includes an LSA count that indicates the number of LSAs being sought and a node ID list that reflects one or more of the node IDs for which an LSA is being sought. The node ID list includes node IDs. The GET_LSA response contains a mask that contains a \u201c1\u201d in each position for which the target node possesses an LSA. The low-order bit corresponds to the first node ID specified in the request, while the highest-order bit corresponds to the last possible node ID. The response is then followed by one or more Hello messages that contain the actual LSAs requested.","Table 16 provides the definitions for the fields shown in .",{"@attributes":{"id":"p-0181","num":"0228"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field definitions for a GET_LSA packet."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Count","The number of node ID's contained in the packet."]},{"entry":["NodeID0\u2013","The node IDs for which the sender is seeking an LSA. Unused"]},{"entry":["NodeIDn","fields need not be included in the packet and should be"]},{"entry":[{},"ignored by the receiver."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The Restore Path Packet","An RPR packet includes a virtual path identifier (VPID) field, a checksum field, a path length field, a HOP_COUNT field, and an array of path lengths. The path field may be further subdivided into hop fields, which may number up to MAX_HOPS hop fields. The Restore Path packet is sent by source nodes (or proxy border nodes), to obtain an end-to-end path for a VP. The packet is usually sent during failure recovery procedures but can also be used for provisioning new VPs. The node sending the RPR is called the origin or source node. The node that terminates the request is called the target or destination node. A restore path instance is uniquely identified by its origin and target nodes, and VP ID. Multiple copies of the same restore-path instance are identified by the unique sequence number assigned to each of them. Only the sequence number need be unique across multiple copies of the same instance of a restore-path packet. Table 17 provides the appropriate field definitions.",{"@attributes":{"id":"p-0184","num":"0231"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 17"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field definitions for a Restore Path packet."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPID","The ID of the VP being restored."]},{"entry":["Checksum","The checksum of the complete contents of the RPR, not"]},{"entry":[{},"including the header. The checksum is normally computed"]},{"entry":[{},"by a target node and verified by the origin node. Tandem"]},{"entry":[{},"nodes are not required to verify or update this field."]},{"entry":["PathLength","Set to MAX_HOPS on all requests: contains the length of"]},{"entry":[{},"the path (in hops, between the origin and target nodes)."]},{"entry":["PathIndex","Requests: Points to the next available entry in Path [ ]."]},{"entry":[{},"Origin node sets the PathIndex to 0, and nodes along the"]},{"entry":[{},"path store the link ID of the input link in Path[ ] at"]},{"entry":[{},"PathIndex. PathIndex is then incremented to point to the"]},{"entry":[{},"next available entry in Path [ ]\/"]},{"entry":[{},"Responses: Points to the entry in Path[ ] that corresponds to"]},{"entry":[{},"the link the packet was received on . . ."]},{"entry":["Path[ ]","An array of PathLength link IDs that represent the path"]},{"entry":[{},"between the origin and target nodes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The Create Path Packet","A CREATE_PATH (CP) packet includes a virtual path identifier (VPID) field, a checksum field, a path length field, a HOP_COUNT field, and an array of path lengths. The path field may be further subdivided into hop fields, which may number up to MAX_HOPS. The CP packet is sent by source nodes (or proxy border nodes), to obtain an end-to-end path for a VP. The node sending the CP is called the origin or source node. The node that terminates the request is called the target or destination node. A CP instance is uniquely identified by its origin and target nodes, and VP ID. Multiple copies of the same CP instance are identified by the unique sequence number assigned to each of them. Only the sequence number need be unique across multiple copies of the same instance of a restore-path packet. Table 18 provides the appropriate field definitions.",{"@attributes":{"id":"p-0187","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Field definitions for a Create Path packet."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VPID","The ID of the VP being provisioned."]},{"entry":["Checksum","The checksum of the complete contents of the CP, not"]},{"entry":[{},"including the header. The checksum is normally computed"]},{"entry":[{},"by a target node and verified by the origin node. Tandem"]},{"entry":[{},"nodes are not required to verify or update this field."]},{"entry":["PathLength","Set to MAX_HOPS on all requests: contains the length of"]},{"entry":[{},"the path (in hops, between the origin and target nodes)."]},{"entry":["PathIndex","Requests: Points to the next available entry in Path [ ]."]},{"entry":[{},"Origin node sets PathIndex to 0, and nodes along the path"]},{"entry":[{},"store the link ID of the input link in Path[ ] at PathIndex."]},{"entry":[{},"PathIndex is then incremented to point to the next available"]},{"entry":[{},"entry in Path [ ]\/"]},{"entry":[{},"Responses: Points to the entry in Path[ ] that corresponds to"]},{"entry":[{},"the link the packet was received on . . ."]},{"entry":["Path[ ]","An array of PathLength link IDs that represent the path"]},{"entry":[{},"between the origin and target nodes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The Delete Path Packet","The Delete Path packed is used to delete an existing path and releases all of its allocated link resources. This command can use the same packet format as the Restore Path packet. The origin node is responsible for initializing the Path [ ] PathLength, and Checksum fields to the packet, which should include the full path of the VP being deleted. The origin node also sets PathIndex to zero. Tandem nodes should release link resources allocated for the VP after they have received a valid response from the target node. The target node should set the PathIndex field to zero prior to computing the checksum of packet.","The TestPath Packet","The TestPath packet is used to test the integrity of an existing virtual path. This packet uses the same packet format as the RestorePath packet. The originating node is responsible for initializing the Path [ ], PathLength, and Checksum fields of the packet, which should include the full path of the span being tested. The originating node also sets PathIndex to zero. The target node should set the PathIndex field to zero prior to computing the checksum of packet. The TestPath packet may be configured to test functionality, or may test a path based on criteria chosen by the user, such as latency, error rate, and the like.","The Link-Down Packet","The Link-Down packet is used when master nodes are present in the network. This packet is used by slave nodes to inform the master node of link failures. This message is provided for instances in which the alarms associated with such failures (AIS and RDI) do not reach the master node.","While particular embodiments of the present invention have been shown and described, it will be obvious to those of ordinary skill in the art that, based upon the teachings herein, changes and modifications may be made without departing from this invention and its broader aspects and, therefore, the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore, it is to be understood that the invention is solely defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features, and advantages made apparent to those of ordinary skill in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 15A"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 15B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 15C"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 15D"}]},"DETDESC":[{},{}]}
