---
title: Classpath optimization in a Java runtime environment
abstract: A computer implemented method, data processing system, and computer usable program are provided by the aspects of the present invention. Aspects of the present invention identify required classes of a software program in the import statements in the source code. Next, the aspects of the present invention identify an element in a classpath environment variable that contain only the required classes and generate a new classpath environment variable with the identified element. Aspects of the present invention then store the new classpath environment variable in a classpath file that is specific to the software program for subsequent invocation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069582&OS=09069582&RS=09069582
owner: International Business Machines Corporation
number: 09069582
owner_city: Armonk
owner_country: US
publication_date: 20120914
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION(S)","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application is a continuation of and claims the benefit of priority to U.S. application Ser. No. 12\/127,525, filed on May 27, 2008 and entitled \u201cMethod and Apparatus for Classpath Optimization in a Java\u2122 Runtime Environment\u201d, which is a continuation of U.S. application Ser. No. 11\/225,572, filed on Sep. 13, 2005 and entitled \u201cMethod and Apparatus for Classpath Optimization in a Java\u2122 Runtime Environment\u201d, the contents of which are hereby incorporated by reference.","1. Field of the Invention","The present invention relates generally to a data processing system. In particular, the present invention relates to a Java\u2122 runtime environment in a data processing system. Still more particularly, the present invention relates to optimizing a classpath environment variable in the Java\u2122 runtime environment by generating a new classpath environment variable that only includes directories containing classes that are required by a current Java\u2122 program.","2. Description of the Related Art","In the Java\u2122 runtime environment, when a user invokes a Java\u2122 program, the Java\u2122 class loader loads bootstrap classes, extension classes, and user classes. Java\u2122 runtime environment (JRE) is a product available from Sun Microsystems, Inc. Bootstrap classes are classes of the basic Java\u2122 platform. Extension classes are Java\u2122 archive (JAR) files that are required by the Java\u2122 platform. User classes are classes that are defined by program developers. Currently, the location of the user classes is identified by the classpath environment variable, which lists directories and JAR files containing class files. The classpath environment variable is typically set on a user login to be used for all of the Java\u2122 programs.","When Java\u2122 programs are installed, Java\u2122 class loader loads packages containing classes that are required by the Java\u2122 program by traversing the classpath environment variable as defined by the user. In this way, the required classes may be identified by the Java\u2122 class loader. However, as the number of directories or JAR files defined in the classpath environment variable increases or as the number of Java\u2122 programs increases, searching through the classpath environment variable becomes very time consuming. The number of classes or JAR files in a directory also is a factor. Thus, the number of classes, directories, and JAR files may increase as additional Java\u2122 programs are installed.","Furthermore, some Java\u2122 programs may be executed repeatedly with different input data. These programs include programs that process a file of credit card transactions, cumulative rainfall amounts, seismic data, images, or other types of information. These repeatedly executed programs are either time sensitive or run on resources that are constrained by usage or time. If all directories and JAR files in the classpath environment variable are searched each time one of these programs is executed, performance of the program may suffer.","Since the required classes must be loaded before the Java\u2122 program can be executed, it would be advantageous to have the classpath environment variable only contain relevant classes for the current Java\u2122 program, such that the time spent searching for the required classes in the classpath environment variable may be minimized.","A computer implemented method, a data processing system, and computer usable program code are provided for classpath optimization in a platform independent runtime environment. A required class is identified in an import statement in source code for a software program, wherein the software program requires the required class. In a classpath environment variable, an element containing the required class is identified to form an identified element. Using the identified element, a new classpath environment variable is generated.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIGS. 1-2","FIGS. 1-2"]},"With reference now to the figures,  depicts a pictorial representation of a network of data processing systems in which aspects of the present invention may be implemented. Network data processing system  is a network of computers in which embodiments of the present invention may be implemented. Network data processing system  contains network , which is the medium used to provide communication links between various devices and computers connected together within network data processing system . Network  may include connections, such as wire, wireless communication links, or fiber optic cables.","In the depicted example, server  and server  connect to network  along with storage . In addition, clients , , and  connect to network . These clients , , and  may be, for example, personal computers or network computers. In the depicted example, server  provides data, such as boot files, operating system images, and applications to clients , , and . Clients , , and  are clients to server  in this example. Network data processing system  may include additional servers, clients, and other devices not shown.","In the depicted example, network data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the Transmission Control Protocol\/Internet Protocol (TCP\/IP) suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, governmental, educational, and other computer systems that route data and messages. Of course, network data processing system  also may be implemented as a number of different types of networks, such as for example, an intranet, a local area network (LAN), or a wide area network (WAN).  is intended as an example, and not as an architectural limitation for different embodiments of the present invention.","With reference now to , a block diagram of a data processing system is shown in which aspects of the present invention may be implemented. Data processing system  is an example of a computer, such as server  or client  in , in which computer usable code or instructions implementing the processes for embodiments of the present invention may be located.","In the depicted example, data processing system  employs a hub architecture including north bridge and memory controller hub (NB\/MCH)  and south bridge and input\/output (I\/O) controller hub (SB\/ICH) . Processing unit , main memory , and graphics processor  are connected to NB\/MCH . Graphics processor  may be connected to NB\/MCH  through an accelerated graphics port (AGP).","In the depicted example, network adapter  connects to SB\/ICH . Audio adapter , keyboard and mouse adapter , modem , read only memory (ROM) , universal serial bus (USB) ports and other ports , and PCI\/PCIe devices  connect to SB\/ICH  through bus . PCI\/PCIe devices may include, for example, Ethernet adapters, add-in cards, and PC cards for notebook computers. PCI uses a card bus controller, while PCIe does not. ROM  may be, for example, a flash binary input\/output system (BIOS).","HDD  and CD-ROM drive  connect to SB\/ICH  through bus . HDD  and CD-ROM drive  may use, for example, an integrated drive electronics (IDE) or serial advanced technology attachment (SATA) interface. Super I\/O (SIO) device  may be connected to SB\/ICH .","An operating system runs on processing unit  and coordinates and provides control of various components within data processing system  in . As a client, the operating system may be a commercially available operating system such as Microsoft\u00ae Windows\u00ae XP (Microsoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or both). An object-oriented programming system, such as, the Java\u2122 programming system, may run in conjunction with the operating system and provides calls to the operating system from Java\u2122 programs or applications executing on data processing system  (Java\u2122 is a trademark of Sun Microsystems, Inc. in the United States, other countries, or both).","As a server, data processing system  may be, for example, an IBM eServer\u2122 pSeries\u00ae computer system, running the Advanced Interactive Executive (AIX\u00ae) operating system or the LINUX operating system (eServer, pSeries and AIX are trademarks of International Business Machines Corporation in the United States, other countries, or both while LINUX is a trademark of Linus Torvalds in the United States, other countries, or both). Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors in processing unit . Alternatively, a single processor system may be employed. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as HDD , and may be loaded into main memory  for execution by processing unit . The processes for embodiments of the present invention are performed by processing unit  using computer usable program code, which may be located in a memory such as, for example, main memory , ROM , or in one or more peripheral devices  and .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash memory, equivalent non-volatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the present invention may be applied to a multiprocessor data processing system.","In some illustrative examples, data processing system  may be a personal digital assistant (PDA), which is configured with flash memory to provide non-volatile memory for storing operating system files and\/or user-generated data.","A bus system may be comprised of one or more buses, such as bus  or bus  as shown in . Of course, the bus system may be implemented using any type of communication fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communication unit may include one or more devices used to transmit and receive data, such as modem  or network adapter  as shown in . A memory may be, for example, main memory , ROM , or a cache such as found in NB\/MCH  as shown in . The depicted examples in  and above-described examples are not meant to imply architectural limitations. For example, data processing system  also may be a tablet computer, laptop computer, or telephone device in addition to taking the form of a PDA.","With reference now to , a block diagram illustrating the relationship of software components operating within a computer system that may implement the present invention. Java\u2122-based system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. Java\u2122 Virtual Machine (JVM\u2122)  is one software application that may execute in conjunction with the operating system. JVM\u2122  provides a Java\u2122 run-time environment with the ability to execute Java\u2122 application or applet , which is a program, servlet, or software component written in Java\u2122 programming language. The computer system in which JVM\u2122  operates may be similar to data processing system  or network data processing system , as described above. However, JVM\u2122  may be implemented in dedicated hardware on a so-called Java\u2122 chip, Java\u2122-on-silicon, or Java\u2122 processor with an embedded pico Java\u2122 core.","At the center of a Java\u2122 run-time environment is the JVM\u2122 which supports all aspects of Java\u2122's environment, including its architecture, security features, mobility across networks, and platform independence. The JVM\u2122 is a virtual computer component that actually executes Java\u2122 programs. Java\u2122 programs are not run directly by the central processor but instead by the JVM\u2122, which is itself a piece of software running on the processor. The JVM\u2122 allows Java\u2122 programs to be executed on a different platform as opposed to only one platform for which the code was compiled. Java\u2122 programs are compiled for the JVM\u2122. In this manner, Java\u2122 is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating system architectures.","To enable a Java\u2122 application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java\u2122 run-time system. The Java\u2122 compiler generates bytecode instructions that are nonspecific to a particular computer architecture.","A bytecode is a machine independent code generated by the Java\u2122 compiler and executed by a Java\u2122 interpreter. A Java\u2122 interpreter is part of the JVM\u2122 that alternately decodes and interprets the bytecode or bytecodes. The bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecodes may be translated into native machine code by a just-in-time compiler or JIT.","The JVM\u2122 loads the class files and executes the bytecodes within them. The class files are loaded by a class loader in the JVM\u2122. The class loader loads class files from an application and the class files from the Java\u2122 application programming interfaces (APIs) which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.","One type of software-based execution engine is the just-in-time compiler. With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java\u2122 bytecodes are executed natively. JVM\u2122s usually interpret bytecodes but JVM\u2122s may also use other techniques, such as just-in-time compiling, to execute bytecodes.","When an application is executed on the JVM\u2122 that is implemented in software on a platform-specific operating system, a Java\u2122 application may interact with the host operating system by invoking native methods. A Java\u2122 method is written in the Java\u2122 language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","With reference now to , a block diagram of a JVM\u2122 is depicted in accordance with an illustrative embodiment of the present invention. JVM\u2122  includes class loader subsystem , which is a mechanism for loading types, such as classes and interfaces given fully qualified names. JVM\u2122  also contains runtime data areas , execution engine , native method interface , and memory management . Execution engine  is a mechanism for executing instructions contained in methods of classes loaded by class loader subsystem . Execution engine  may be, for example, Java\u2122 interpreter  or compiler . Native method interface  allows access to resources in the underlying operating system. Native method interface  may be, for example, the Java\u2122 Native Interface (JNI).","Runtime data areas  contain native method stacks , Java\u2122 stacks , PC registers , method area , and heap . These different data areas represent the organization of memory needed by JVM\u2122  to execute a program.","Java\u2122 stacks  are used to store the state of Java\u2122 method invocations. When a new thread is launched, the JVM\u2122 creates a new Java\u2122 stack for the thread. The JVM\u2122 performs only two operations directly on Java\u2122 stacks: it pushes and pops frames. The thread's Java\u2122 stack stores the state of Java\u2122 method invocations for the thread. The state of the Java\u2122 method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations. Java\u2122 stacks are composed of stack frames. A stack frame contains a state of a single Java\u2122 method invocation. When a thread invokes a method, the JVM\u2122 pushes a new frame onto the Java\u2122 stack of the thread. When the method completes, the JVM\u2122 pops the frame for that method and discards it. The JVM\u2122 does not have any registers for holding intermediate values; any Java\u2122 instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java\u2122 instruction set is well defined for a variety of platform architectures.","Program counter (PC) registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java\u2122 stack. If the thread is executing a JVM\u2122 method, the value of the PC register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the PC register are undefined. Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM\u2122 implementations, native method stacks  and Java\u2122 stacks  are combined.","Method area  contains class data while heap  contains all instantiated objects. The constant pool is located in method area  in these examples. The JVM\u2122 specification strictly defines data types and operations. Most JVM\u2122s choose to have one method area and one heap, each of which are shared by all threads running inside the JVM\u2122, such as JVM\u2122 . When JVM\u2122  loads a class file, it parses information about a type from the binary data contained in the class file. JVM\u2122  places this type of information into the method area. Each time a class instance or array is created, the memory for the new object is allocated from heap . JVM\u2122  includes an instruction that allocates memory space within the memory for heap  but does not include instructions for freeing space within the memory. Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a garbage collector, which automatically reclaims memory used by objects that are not referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","Currently, a Java\u2122 class loader in class loader subsystem  loads class files  in order to execute a Java\u2122 program. The Java\u2122 class loader identifies class files  that are required by the Java\u2122 program by traversing classpath environment variable . Classpath environment variable  tells the Java\u2122 class loader in JVM\u2122  where to find class files , including user-defined class files to load. The Java\u2122 class loader traverses the classpath environment variable and examines all of the directories or JAR files in the classpath environment variable to determine if the required class files are present. However, as the number of directories and JAR files to be examined increases in the classpath environment variable, class loading efficiency suffers because there are more and more directories or JAR files to search through. In addition, if the Java\u2122 program is executed repeatedly, the time spent on searching for the required classes may affect performance of the program.","Aspects of the present invention provide a computer implemented method, data processing system, and computer usable program code for classpath optimization by generating a new classpath environment variable that only includes elements containing classes that are required by a current Java\u2122 program. These elements include directories and JAR files. In an illustrative embodiment, aspects of the present invention may be implemented in a Java\u2122 class loader within class loader subsystem  of JVM\u2122  in .","Turning now to , a diagram illustrating a known script for setting the classpath environment variable is depicted. As shown in , script  sets the classpath environment variable  to include every directory and JAR file that is in a user environment. This includes a library in \/home\/utexas\/staff\/mausolf\/mycondor directory , each file in each jar file of the library , and a rt.jar file in the \/usr\/java\/j2sdk1.4.105\/jre\/lib directory . Thus, everything in the user environment, including all of the directories and JAR files, are included in the classpath environment variable regardless of whether it is relevant to a current Java\u2122 program.","Turning now to , a diagram illustrating a known classpath environment variable generated using a known script is depicted. After script  in  is run, classpath environment variable  is generated. Classpath environment variable  includes every directory and JAR file in the user environment including those that are not relevant to the current Java\u2122 program.","To avoid examining all directories or JAR files identified in the classpath environment variable that are irrelevant to the program, the aspects of the present invention generate a new classpath environment variable by including only those directories or JAR files that contain classes that are required by the current Java\u2122 program. The aspects of the present invention generate the new classpath environment variable by examining the import statements in the source code for the current Java\u2122 program and removing directories or JAR files that do not contain classes identified in the import statements. An import statement includes the source code of another file into the source code of the current file.","The import statements in the source code specify classes that are required for the Java\u2122 program. For example, import com.ibm.my_project.* statement indicates all class files within the directory com\/ibm\/my_project are required for the Java\u2122 program. If dependencies exist in the required class files of the import statements, the aspects of the present invention examine the required class files themselves in a recursive manner until all required classes are identified. In order to identify directories or JAR files in the import statements to be removed, aspects of the present invention examine each of the import statements to identify the required class files.","Next, the aspects of the present invention search each directory identified in the classpath environment variable for the required class files. If none of the required class files are present in the directory, the fully qualified name of the JAR file in the directory is removed from the classpath environment variable. If the classpath environment variable includes JAR files, the aspects of the present invention search each JAR file identified in the classpath environment variable for the required class files by utilizing a \u201cjar -tvf\u201d command. The \u201cjar -tvf\u201d command lists the content of a JAR file. If none of the required class files is present in the JAR file, the JAR file is removed from the classpath environment variable.","The aspects of the present invention continue to search for the required class files until the required class files are located. Once all of the required class files in the import statements are located, a new classpath environment variable is generated with the remaining directories or JAR files in the classpath environment variable. In other words, the new classpath environment variable only includes those directories or JAR files that contain the required classes. In this way, the time spent searching for the required classes in the classpath environment variable may be minimized and the Java\u2122 class loader may locate and load the required classes faster.","Turning now to , a diagram illustrating a known classpath environment variable is depicted. As shown in , classpath environment variable  identifies two directories where the JVM\u2122 may find the class files. In this example, the two directories are \/user\/local\/classes  and \/user\/local\/lib . Within each of the two directories, there may be hundreds of class files and libraries. Thus, searching through the two directories for class files at runtime may be time consuming.","Turning now to , a diagram illustrating a known Java\u2122 program source file is depicted. As shown in , Java\u2122 program source code  includes two import statements, which indicate the class files that are required by the current Java\u2122 program. The two import statements are import statements  and . Import statement  indicates that class file com.ibm.my_project.registration is required. Import statement  indicates that class file com.ibm.my_project.utilities is required.","Currently, the Java\u2122 class loader searches through hundreds of class files and libraries in directories  and  in  to find the required class files as indicated in import statements  and  in . In order to avoid searching through all of the files and libraries, aspects of the present invention generate a new classpath environment variable that includes only directories and JAR files that contain the required class files, such that the search time may be reduced.","In order to generate the new classpath environment variable, aspects of the present invention examine each of import statements  and  in  to identify required class files com.ibm.my_project.registration and com.ibm.my_project.utilities. Next, the aspects of the present invention search each directory identified in the classpath environment variable, \/user\/local\/classes  and \/user\/local\/lib  for the required class files. If none of the required class files are present in the directory, the fully qualified name of a JAR file in the directory is removed from the classpath environment variable. For example, if no com.ibm directory exists in \/user\/local\/classes , the fully qualified name of the JAR file in \/user\/local\/classes directory  is removed from the classpath environment variable, such that the directory would not be searched by the Java\u2122 class loader.","On the other hand, \/user\/local\/lib  includes a plurality of JAR files, including my_project.jar. The aspects of the present invention search each JAR file identified in \/user\/local\/lib  for the required class files by utilizing a jar -tvf command. The jar -tvf command lists the contents of a JAR file. For example, a \u201cjar -tvf|grep com.ibm.my_project\u201d command is used to list the contents of the my_project.jar.","Based on the list of contents, the aspects of the present invention determine if the required class files com.ibm.my_project.registration and com.ibm.my_project.utilities are present in my_project.jar. If the required class files are absent, the fully qualified path name of the jar file in the directory is removed from the classpath environment variable. However, if the required class files are present, a new classpath environment variable is generated with only the directories or JAR files that contain the required class files.","Turning now to , a diagram illustrating an exemplary classpath environment variable is depicted in accordance with an illustrative embodiment of the present invention. As shown in , new classpath environment variable  is generated by the aspects of the present invention after traversing classpath environment variable  and removing any directories or JAR files that do not contain the required class files for the current Java\u2122 program , as described above.","New classpath environment variable  includes only two JAR files: \/user\/local\/lib\/runtime.jar  and \/user\/local\/lib\/my_project.jar . In this example, runtime.jar  is needed by the Java\u2122 runtime environment. My_project.jar  is a single JAR file that is required by program . Instead of searching through hundreds of class files and libraries in \/user\/local\/classes  and each JAR file in \/user\/local\/lib  as shown in , the Java\u2122 class loader may simply load runtime.jar  and my_project.jar  to execute program . Once the new classpath environment variable  is generated, it may be stored in a classpath file with a name of the current Java\u2122 program and a .classpath extension. For example, test.classpath.","In one illustrative embodiment, when the user invokes the program, such as program , the program is manually invoked by using a \u201cjava -c\u201d command with the parameter \u201cnew_classpath\u201d program_name. For example, \u201cjava -c test.classpath test\u201d. The \u201cjava -c\u201d command specifies the classpath to be used by the Java\u2122 class loader. In an alternative embodiment, when the user invokes the program, the Java\u2122 runtime environment looks for a classpath file with the program name \u201ctest\u201d followed by the .classpath extension. If the classpath file is found, the new classpath environment variable is set for the program and the program is invoked using the new classpath environment variable. However, if the classpath file is not found, the aspects of the present invention may generate a new classpath file automatically according to the steps as described above. The aspect of the present invention then uses the new classpath file to invoke the program and save the classpath file with a .classpath extension for subsequent use. However, the automatic generation of the optimized classpath environment variable is optional. For programs that are run infrequently, the user may not want the overhead of optimizing the classpath environment variable each time the program is run. On the other hand, if the program is invoked frequently and is time sensitive, the user may want to optimize the classpath environment variable such that each subsequent execution of the program will take less time and be more efficient. This efficiency is achieved because the optimized classpath environment variable is only generated once for the program, but is subsequently used each time the program is run.","Turning now to , a flowchart of an exemplary process for classpath environment variable optimization is depicted in accordance with an illustrative embodiment of the present invention. This process may be implemented within a Java\u2122 class loader within a class loader subsystem, such as class loader subsystem  of JVM\u2122  in .","As shown in , from the perspective of the Java\u2122 class loader, the process begins when aspects of the present invention examine the import statements of the Java\u2122 program to identify class files that are required by the program (step ). Next, aspects of the present invention search the next directory that is identified in the classpath environment variable for the required class files (step ). A determination is made by aspects of the present invention as to whether the directory contains the required class files (step ). If the directory contains the required class files, the directory is included in the new classpath environment variable (step ). If the directory does not contain the required class files, the aspects of the present invention remove the fully qualified name of the JAR file in the directory from the classpath environment variable (step ).","A determination is then made as to whether additional directories are present in the classpath environment variable (step ). If additional directories are present, the process returns to step  to search the next directory for the required class files. However, if additional directories are not present, the aspects of the present invention search the next JAR file identified in the classpath environment variable for the required class files using the \u201cjar -tvf\u201d command (step ). The \u201cjar -tvf\u201d command lists the contents of the JAR file.","A determination is then made as to whether the contents of the JAR file contain the required class files (step ). If the JAR file contains the required class files, the JAR file is included in the new classpath environment variable (step ). If the JAR file does not contain the required class files, the aspects of the present invention remove the JAR file from the classpath environment variable (step ).","Next, a determination is made as to whether additional JAR files are present in the classpath environment variable (step ). If additional directories are present, the process returns to step  to search the next JAR file for the required class files. However, if additional JAR files are not present, the aspects of the present invention generate the new classpath environment variable with the directories and JAR files that contain the required class files (step ). The new classpath environment variable is then stored in a classpath file with the program name and .classpath extension (step ).","Later, when the user invokes the Java\u2122 program (step ), in one embodiment, the Java\u2122 runtime environment looks for a classpath file with a program name followed by a .classpath extension (step ). A determination is made by the Java\u2122 runtime environment as to whether the classpath file exists (step ). If the classpath file exists, the program is invoked by using a \u201cJava\u2122-c \u201cnew_classpath\u201d program_name\u201d command (step ). The new_classpath is the name of the classpath file stored with the new classpath environment variable in step . Thus, the process terminates thereafter. However, if the classpath file does not exist, the process may return to step  and repeat the steps to automatically generate a new classpath environment variable. Instead of having to search through all of the directories and JAR files in the classpath environment variable each time a repeatedly executed program is executed, the new classpath environment variable in the classpath file may be used repeatedly by the Java\u2122 runtime environment.","It is noted that automatic generation of a new classpath environment variable is optional. For programs that are run infrequently, the user may not want the overhead of optimizing the classpath environment variable. On the other hand, if the program is invoked frequently and is time sensitive, the user may want to optimize the classpath environment variable such that each subsequent execution of the program will be more efficient. This efficiency is achieved because the optimized classpath environment variable is only generated once for the program, but is subsequently used each time the program is run. Thus, the optimized classpath environment variable does not have to be generated for a program that is run infrequently or that is not time-sensitive.","In addition to including only directories and JAR files that contain the required classes, other types of classpath optimizations may be performed. For example, the classpath environment variable may be reordered starting from directories or JAR files with the highest number of classes to directories or JAR files with the lowest number of classes. By reordering the classpath environment variable based on the number of classes the directories or JAR files contain, the likelihood that the required class files are found early in the search process is increased because the probability that the required classes are found is higher in a bigger set of directories and JAR files than a smaller set of directories and JAR files. This optimization decreases the search time of the Java\u2122 class loader and the execution time of the program, hence, improves the program performance.","Turning now to , an exemplary implementation of classpath environment variable optimization is depicted in accordance with an illustrative embodiment of the present invention. This exemplary implementation utilizes the process as depicted in . As shown in , the optimization process begins when a user invokes an optimization command \u201cjavaOptCp\u201d to optimize the classpath environment variable for a Java\u2122 program named \u201cmy_program.java\u201d (step ). Java\u2122 source file  includes two import statements, which specify two required class files: com.ibm.my_project.registration  and com.ibm.my_project.utilities .","Upon receiving the \u201cjavaOptCp\u201d command, aspects of the present invention identify the required classes in the import section in source code of Java\u2122 source file  (step ). The aspects of the present invention then locate the required classes in the directories as specified by classpath environment variable  (step ). Classpath environment variable  includes directories and JAR files that are required by different Java\u2122 programs. Once the required classes are located, the aspects of the present invention remove the directories that do not contain required classes from the classpath environment variable (step ), since these directories are not required for this particular program, my_program.java. New classpath environment variable  is generated by aspects of the present invention as a result, which includes only the \u201c\/home\/mausolf\/dev\u201d directory.","Aspects of the present invention then save the new classpath environment variable in an optimized classpath file with the same filename as the Java\u2122 program but with a .classpath extension (step ). In this example implementation, the optimized classpath file is My_program.classpath . Once the new classpath environment variable is saved in the classpath file, the classpath optimization process completes.","Later, the user invokes the Java\u2122 program by using a \u201cjavaOpt\u201d command (step ). The \u201cjavaOpt\u201d command looks for a classpath file with a .classpath extension of the program name. If the classpath file is found, the command sets the program classpath to the new classpath environment variable in the classpath file by calling a \u201cjava -classpath\u201d command. By using the \u201cjavaOpt\u201d command, search time by the Java\u2122 class loader may be minimized. The program then executes and the program invocation process terminates.","It is noted that classpath optimization steps , , , , and  in  are executed only once to optimize the classpath, while program invocation step  in  may be executed multiple times for a program that is executed repeatedly. It is also noted that the classpath file is unique to a program. Thus, each program is associated with a different classpath file.","In summary, the aspects of the present invention optimize Java\u2122 program performance, in particular repeatedly executed Java\u2122 program performances, by dynamically filtering and reordering the classpath. The aspects of the present invention create an optimized classpath that is specific to a particular program in advance of program execution. Furthermore, the aspects of the present invention may be integrated with enterprise development tools, such as Eclipse, to optimize the performance of programs during their development. In this manner, the optimized classpath may be deployed all of the way from the development phase to production phase along with the application such that the optimization is separate from the time-sensitive processing of the production resources.","The invention can take the form of an entirely hardware embodiment, an entirely software embodiment, or an embodiment containing both hardware and software elements. In a preferred embodiment, the invention is implemented in software, which includes but is not limited to firmware, resident software, microcode, etc.","Furthermore, the invention can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer-usable or computer readable medium can be any apparatus that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.","The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk-read only memory (CD-ROM), compact disk-read\/write (CD-R\/W), and digital video disc (DVD).","A data processing system suitable for storing and\/or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.","Input\/output or I\/O devices (including but not limited to keyboards, displays, pointing devices, etc.) can be coupled to the system either directly or through intervening I\/O controllers.","Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modems, and Ethernet cards are just a few of the currently available types of network adapters.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
