---
title: Graph query processing using plurality of engines
abstract: Graph queries are processed using a plurality of independent query execution engines. A graph query submitted to a graph database which is modeled by an attributed graph is received. The graph query is decomposed into a plurality of query components. For each of the query components, a one of the query execution engines that is available to process the query component is identified, a sub-query representing the query component is generated, the sub-query is sent to the identified query execution engine for processing, and results for the sub-query are received from the identified query execution engine. The results received are then combined to generate a response to the graph query.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09053210&OS=09053210&RS=09053210
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09053210
owner_city: Redmond
owner_country: US
publication_date: 20121214
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","1.0 Graph Query Processing Using a Plurality of Engines","2.0 Additional Embodiments","3.0 Exemplary Operating Environments"],"p":["A graph database is a type of data structure where one or more graphs are used to model the structural relationships between data objects in a data set. Each of the graphs employs nodes (also known as vertices), edges and attributes (also known as properties) to represent and store the data objects. Generally speaking, the nodes in a given graph represent entity instances such as people, businesses, accounts, or any other item of interest. The edges in the graph represent the connections that exist between pairs of nodes. The attributes in the graph are pertinent data that relates to the nodes. Depending on the particular type of graph (e.g., the particular type of data model) being implemented, the attributes in the graph may also be pertinent data that relates to the edges. It is becoming increasingly popular to use graph databases to model complicated, large data sets in a variety of application domains such as bioinformatics applications, cheminformatics applications, repositories of business process models, social network applications, bibliographic network applications, and knowledge base applications.","This Summary is provided to introduce a selection of concepts, in a simplified form, that are further described hereafter in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Graph query processing technique embodiments described herein generally involve responding to graph queries. In an exemplary embodiment a graph query submitted to a graph database which is modeled by an attributed graph is received. The graph query is then decomposed into a plurality of query components. Then, for each of the query components, a one of a plurality of independent query execution engines that is available to process the query component is identified, a sub-query representing the query component is generated, the sub-query is sent to the identified query execution engine for processing, and results for the sub-query are received from the identified query execution engine. The results received are then combined to generate a response to the graph query.","In the following description of graph query processing technique embodiments reference is made to the accompanying drawings which form a part hereof, and in which are shown, by way of illustration, specific embodiments in which the graph query processing technique can be practiced. It is understood that other embodiments can be utilized and structural changes can be made without departing from the scope of the graph query processing technique embodiments.","It is also noted that for the sake of clarity specific terminology will be resorted to in describing the graph query processing technique embodiments described herein and it is not intended for these embodiments to be limited to the specific terms so chosen. Furthermore, it is to be understood that each specific term includes all its technical equivalents that operate in a broadly similar manner to achieve a similar purpose. Reference herein to \u201cone embodiment\u201d, or \u201canother embodiment\u201d, or an \u201cexemplary embodiment\u201d, or an \u201calternate embodiment\u201d, or \u201cone implementation\u201d, or \u201canother implementation\u201d, or an \u201cexemplary implementation\u201d, or an \u201calternate implementation\u201d means that a particular feature, a particular structure, or particular characteristics described in connection with the embodiment or implementation can be included in at least one embodiment of the graph query processing technique. The appearances of the phrases \u201cin one embodiment\u201d, \u201cin another embodiment\u201d, \u201cin an exemplary embodiment\u201d, \u201cin an alternate embodiment\u201d, \u201cin one implementation\u201d, \u201cin another implementation\u201d, \u201cin an exemplary implementation\u201d, and \u201cin an alternate implementation\u201d in various places in the specification are not necessarily all referring to the same embodiment or implementation, nor are separate or alternative embodiments\/implementations mutually exclusive of other embodiments\/implementations. Yet furthermore, the order of process flow representing one or more embodiments or implementations of the graph query processing technique does not inherently indicate any particular order not imply any limitations of the graph query processing technique.","The term \u201cpath\u201d is used herein to refer to a sequence of edges in a graph which are interconnected by nodes. The term \u201cattributed graph data model\u201d (herein sometimes simply referred to as an attributed graph) is used herein to refer to a particular type of graph that can include one or more attributes for each of the nodes in the graph, and can also include one or more attributes for each of the edges in the graph. The term \u201csecondary storage device\u201d is used herein to refer to a storage device such as one or more hard disk drives, or the like.","Generally speaking, the graph query processing technique embodiments described herein involve responding to (e.g., evaluating and answering, herein sometimes also referred to as executing) queries that are submitted by an entity to a graph database which is modeled by an attributed graph (such queries are herein sometimes simply referred to as graph queries). This entity can be either an end user, or a computing device, among other things.","The graph query processing technique embodiments described herein are advantageous for various reasons including, but not limited to, the following. As will be appreciated from the more detailed description that follows, the graph query processing technique embodiments provide a scalable indexing mechanism for attributed graphs which optimizes the efficiency of searching\/analyzing large attributed graphs. The graph query processing technique embodiments also accelerate the processing of many different types of graph queries without having to build and maintain different types of indices of the graph database (which would consume a large amount of memory). In other words, the graph query processing technique embodiments optimize the performance of graph query processing and minimize the amount of memory that is consumed during graph query processing. This memory consumption minimization allows the graph query processing technique embodiments to scale and support the querying of larger and more complex graph databases that are modeled by larger and more complex attributed graphs using a given fixed size of memory.","The graph query processing technique embodiments described herein also support querying both the topology of the attributed graph and data objects in the graph (e.g., the attributes of the nodes and edges in the graph). As such, the graph query processing technique embodiments can efficiently evaluate and answer a graph query that combines both predicates which are based on the topology of the attributed graph and predicates which are based on the attributes of the nodes and edges in the graph. Accordingly, the graph query processing technique embodiments support the processing of a complex graph query that can include a combination of two or more different types of graph query components such as, a pattern match component, a reachability component, and a shortest path component, among others. The graph query processing technique embodiments also support interactive, online graph query processing (e.g., these embodiments are not limited to working in just a batch mode).","The graph query processing technique embodiments described herein also make use of the following heuristics. Due to the powerful indexing and sophisticated query optimization techniques that exist for relational database systems, relational database systems are generally very efficient for executing graph queries and query components thereof that represent structural predicates or value-based predicates on the attributes of nodes and\/or edges in an attributed graph. Additionally, relational database systems are generally very efficient for finding graph query execution plans that perform well since they support the consideration of different possible execution plan variants such as different join implementations and different join orderings. In contrast, relational database systems are generally inefficient for executing graph queries and query components thereof that involve operations of a recursive nature (e.g., traversal operations over the topology of the attributed graph). However, and as will be appreciated from the more detailed description that follows, various graph engines exist which are efficient for executing such recursive operations.","1.1 Graph Databases","Graph databases can be classified in various ways. By way of example but not limitation, graph databases can be classified according to the number and size of the graphs that are used therein. More particularly, graph databases that are made up of a large number of small graphs can be assigned to a first category of graph databases. Graph databases that fall into this first category are sometimes referred to as transactional graph databases, and are commonly used to model the aforementioned data sets associated with bioinformatics applications, cheminformatics applications, and repositories of business process models, among others. Graph databases that are made up of either just a single large graph or a very small number of large graphs can be assigned to a second category of graph databases. Graph databases that fall into this second category are commonly used to model the aforementioned data sets associated with social network applications, bibliographic network applications, and knowledge base applications, among others.","There are three common types of graph queries that are commonly used to query the second category of graph databases, namely a pattern match graph query, a reachability graph query, and a shortest path graph query. The pattern match graph query tries to find the existence(s) of a graph pattern (e.g., either a path, or a star, or a sub-graph, among others) in the large graph(s). The reachability graph query verifies if a connection\/path exists between any two nodes in the large graph(s). The shortest path graph query is a variant of the reachability graph query that returns the shortest path distance (in terms of the number of edges) between any two nodes which are connected in the large graph(s). Both the reachability and shortest path queries may return the queried connections\/paths. A given complex graph query that is submitted by an entity to the second category of graph databases can include a plurality of different types of query components. More particularly and by way of example but not limitation, the complex graph query can include either one or more pattern match components, or one or more reachability components, or one or more shortest path components. The complex graph query can also generally include any combination of these different components. More particularly, the complex graph query can include one or more of, one or more pattern match components, or one or more reachability components, or one or more shortest path components.","In many real world applications, each of the nodes in the graph(s) can be labeled with one or more attributes that specify pertinent data relating to the node. Depending on the particular type of graph database that is being implemented, each of the edges in the graph(s) can also be labeled with one or more attributes that specify the type of relationship that exists between the two nodes which are connected by the edge. By way of example but not limitation, in a graph that is used to model a social network, a given node in the graph can represent a given person in the network, this node can be labeled with an attribute that specifies the age of the person, and the topology of the graph can represent different types of relationships (sometime referred to as directed edges) that exist between the person and other people in the network. In the case where the graph is implemented as an attributed graph, each of these relationships can be labeled with a start date attribute. Such a graph that can include attributes for the nodes in the graph, as well as attributes for the edges in the graph, is referred to herein as an attributed graph. It will be appreciated that both the topology of an attributed graph and the attributes of the nodes and edges therein, represent valuable information.","An attributed graph can be formally denoted as (V, E, L, L, F, F, A, A) where V is a set of the nodes in the graph, EV\u00d7V is a set of the edges in the graph that join two distinct nodes, Lis a set of the labels for V, Lis a set of the labels for E, Fis a function V\u2192Lthat assigns labels to each of the nodes, and Fis a function E\u2192Lthat assigns labels to each of the edges. A={a, a, . . . , a} is a set of m attributes that can be associated with any node in V. Each of the nodes v\u03b5V can be labeled with an attribute vector [a(v), . . . , a(v)], where a(v) is the attribute value of node v on attribute a. A={b, b, . . . , b} is a set of n attributes that can be associated with any edge in E. Similarly, each of the edges e\u03b5E can be labeled with an attribute vector [b(e), . . . , b(e)], where b(e) is the attribute value of edge e on attribute b.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 1","FIG. 1"],"b":["102","104","100","106","100","102","104","110","108","106","112","100"]},"Referring again to , a user may submit a graph query that seeks to find the names of two authors, X and Y, where X and Y are connected by a path of any length (e.g., any number of edges), the author X is affiliated at the University of New South Wales (UNSW), the author Y is affiliated at Microsoft, and both of the authors has published a paper at the Very Large Databases 2012 conference (VLDB '12). It will be appreciated that this particular graph query includes both a pattern match component and a reachability component. A user may also submit a graph query that seeks to find the names of two authors, X and Y, where X and Y are connected by a path of any length, the author X is affiliated at UNSW, the author Y is affiliated at Microsoft, both of the authors has published a paper at VLDB '12 as a first author (e.g., ), and both of the authors has an age which is greater than or equal to 35. It will be appreciated that this particular graph query includes both a pattern match component and a reachability component, where the pattern match component has conditions on the attributes of the nodes and edges in the graph snippet .","Referring again to , a user may also submit a graph query that seeks to find the names of two authors, X and Y, and the connecting path(s) there-between, where X and Y are connected by a path having a length which is less than or equal to three edges, the author X is affiliated at UNSW, the author Y is affiliated at Microsoft, and both of the authors has published a paper at VLDB '12 as a first author (e.g., ). It will be appreciated that this particular graph query includes both a pattern match component and a reachability component, where the reachability component is constrained by a path filtering condition and returns data specifying the connecting path(s) as part of the graph query results.","Referring again to , a user may also submit a graph query that seeks to find the names and the ages of two authors, X and Y, and the shortest path there-between, where the author X is affiliated at UNSW, the author Y is affiliated at Microsoft, and both of the authors has published a paper at VLDB '12. It will be appreciated that this particular graph query includes both a pattern match component and a shortest path component. A user may also submit a graph query that seeks to find the titles of two papers, P1 and P2, and the path there-between, where each of the edges in the path represents a \u201ccited by\u201d relationship, the maximum path length is three edges, the first author of P1 is affiliated at UNSW, and the first author of P2 is affiliated at Microsoft. It will be appreciated that this particular graph query includes both a pattern match component and a constrained reachability component, where the pattern match component has conditions on the attributes of the edges in the graph snippet .","It will be appreciated that the foregoing graph query scenarios are exemplary and various other scenarios are also possible.","1.2 G-SPARQL Graph Query Language and Supported Types of Queries","This section describes an exemplary embodiment of a graph query language, herein referred to as graph-SPARQL (G-SPARQL), for querying an attributed graph. G-SPARQL is advantageous for various reasons including, but not limited to, the following. As will be appreciated from the more detailed description that follows, G-SPARQL supports a declarative query programming interface which allows for optimizing the efficiency of graph query processing in situations where the programmer has little or no knowledge about the characteristics of the underlying attributed graphs. G-SPARQL is also able to express graph queries about arbitrary path structures in the attributed graph. As such and as described heretofore, G-SPARQL supports complex graph queries that include a plurality of different types of query components such as the pattern match component, the reachability component, and the shortest path component, among others, and any combination thereof. G-SPARQL is also sufficiently expressive to satisfy a wide variety of user query needs. The syntax expressions in G-SPARQL are also clear and concise.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIG. 2"]},"As is appreciated in the art of graph databases, the conventional Resource Description Framework (RDF) is a family of World Wide Web Consortium (W3C) specifications that define a data format for modeling data objects that are implemented in web resources. In the RDF data model (herein sometimes simply referred to as an RDF graph) an expression that specifies a subject, a predicate and an object can be used to make statements about resources in an RDF graph. Such an expression is known as a triple (or triple pattern) in RDF terminology and will be described in more detail hereafter.","Generally speaking, the RDF graph data model can be considered to be a variant of the attributed graph data model. One difference between the RDF and attributed graph data models is the following. In an RDF graph the edges in the graph cannot be labeled with attributes that describe the edges (just the nodes in an RDF graph can be labeled with attributes). In contrast and as described heretofore, in an attributed graph both the nodes and the edges in the graph can be labeled with an arbitrary set of attributes. Another difference between the RDF and attributed graph data models is the following. In an RDF graph the edges in the graph are used to represent both the data in the graph (e.g., the attributes of the nodes in the RDF graph) and the structural relationships that exist between the nodes in the graph (e.g., the topology of the RDF graph). The edges in an RDF graph represent the data in the graph by connecting the nodes to their attributes. Thus, the data in an RDF graph is represented as part of the graph topology, which results in a significant increase in the size of the graph topology. In contrast and as described heretofore, in an attributed graph the data in the graph (e.g., the attributes of the nodes and edges in the graph) is represented separately from the topology of the graph.","As is appreciated in the art of database query languages, SPARQL (a recursive acronym for SPARQL Protocol and RDF Query Language) is an industry standard query language for querying graph databases that are modeled by one or more RDF graphs. SPARQL was made an industry standard by the W3C.","1.2.1 Querying Attributes of Nodes and Edges Using G-SPARQL","SPARQL employs powerful graph pattern matching facilities that allow the binding of variables to components in the RDF graph that is being queried. A given SPARQL query defines a graph pattern P that is matched against an RDF graph G, where each of the variables in P is replaced by the matching elements of G such that the resulting graph pattern is included in G (e.g., graph pattern matching). The main construct of building P is known as a triple pattern in the art of graph databases. A triple pattern represents the aforementioned RDF triple (subject, predicate, object). The subject of the triple pattern represents an entity instance (e.g., a node) in G. The predicate in the triple pattern represents a connection (e.g., an edge) to an object in G, where this object can represent either another entity instance (e.g., another node) in G or an attribute in G. The subject, predicate and object can each represent either a constant value or a variable (herein denoted as ?var). Hence, a set of different triple patterns concatenated by an AND (.) operator can be used to represent a desired graph pattern of a SPARQL query. The following is an exemplary SPARQL query that seeks to find all persons who are affiliated at UNSW and are at least 42 years old:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT ?X"]},{"entry":[{},"WHERE {?X affiliatedAt UNSW. ?X age ?age."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FILTER (?age >= 42)}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"G-SPARQL is a SPARQL-like graph query language that can be used to query attributed graphs. G-SPARQL employs the general graph pattern matching facilities of SPARQL, but also enhances SPARQL in various ways including, but not limited to, the following. As will be appreciated from the more detailed description that follows, G-SPARQL introduces new constructs that also query the just-described differences between the RDF and attributed graph data models. G-SPARQL supports querying for a defined structural pattern in an attributed graph, and allows filtering conditions to be specified on the attributes of the nodes and\/or edges that are part of this pattern. G-SPARQL also supports querying for a defined path that connects the nodes in an attributed graph, where this defined path can have an unknown length. More particularly, G-SPARQL allows for the expression of reachability and shortest path graph queries between the nodes, where such queries can include filtering conditions on the defined path (e.g., such queries can place constraints on the path length or on the types and properties of edges and nodes). G-SPARQL employs a powerful algebraic compilation and re-writing framework for logical query plans which serve to optimize the graph query processing. As such, G-SPARQL can be efficiently implemented and is able to efficiently query attributed graphs.","G-SPARQL is able to differentiate between the representations of two different types of query predicates, namely structural predicates and value-based predicates. As will be described in more detail hereafter, a structural predicate specifies a condition on the structural relationship between the nodes in an attributed graph, where the subject and object of the triple pattern specify nodes and the predicate of the triple pattern specifies an edge. A value-based predicate specifies a condition on the value of an attribute in the attributed graph, where the subject of the triple pattern specifies either a node or an edge, the predicate of the triple pattern specifies an attribute name, and the object of the triple pattern specifies an attribute value.","The syntax of G-SPARQL differentiates value-based predicates from structural predicates in the following manner. G-SPARQL prepends the predicate part of the triple pattern with the symbol @ when it represents a value-based predicate (structural predicates are not prepended with this symbol). The following are two exemplary triple patterns that illustrate this differentiation between value-based and structural predicates:\n\n","Unlike the RDF graph data model, the attributed graph data model allows each of the edges in an attributed graph to be labeled with an arbitrary set of one or more attributes. Therefore, G-SPARQL is able to differentiate between the representations of two different types of value-based predicates, namely node predicates and edge predicates. A node predicate specifies a condition on the attributes of a node in an attributed graph. An edge predicate specifies a condition on the attributes of an edge in the attributed graph. G-SPARQL uses the standard triple pattern to represent value-based predicates. G-SPARQL can assign a variable to an edge which is to be qualified with more predicates. The following are two exemplary triple patterns that show predicates on node and edge attributes:\n\n","G-SPARQL supports the ability to express arbitrary length paths and path patterns in two main ways. The first way is by using explicit relationships. The following are two exemplary triple patterns that illustrate this use of explicit relationships:\n\n","The second way G-SPARQL supports the ability to express arbitrary length paths and path patterns is by allowing path variables in the predicate part of a triple pattern. More particularly, G-SPARQL supports various options for binding path variables in a path pattern. The following are four exemplary triple patterns that illustrate these options:\n\n","Generally speaking, it will be appreciated that any two nodes in an attributed graph can be connected by a plurality of different paths. Accordingly, G-SPARQL allows for the expression of filtering conditions that can specify Boolean predicates on the nodes and edges of the matching paths which are bound to the path variable. More particularly, G-SPARQL supports various filtering conditions on the nodes and edges of the matching paths including, but not limited to, a Length(PV, P) filtering condition, an AtLeastNode(PV, N, P) filtering condition, an AtMostNode(PV, N, P) filtering condition, an AllNodes(PV, P) filtering condition, an AtLeastEdge(PV, N, P) filtering condition, an AtMostEdge(PV, N, P) filtering condition, and an AllEdges(PV, P) filtering condition. Each of these filtering conditions will now be described in more detail.","The Length(PV, P) filtering condition verifies that the length (e.g., the number of edges) of each of the matching paths which is bound to the variable PV satisfies the predicate P and filters out those paths which do not satisfy the predicate P. By way of example but not limitation, the path filtering condition FilterPath (Length(??X, <4)) ensures that the length of each of the paths which is bound to the path variable ??X is less than four edges. The AtMostNode(PV, N, P) filtering condition ensures that at most N number of nodes on each of the paths which is bound to the variable PV satisfy the structural\/value-based predicate P. The AllNodes(PV, P) filtering condition ensures that every node of each of the paths which is bound to the variable PV satisfies the structural\/value-based predicate P.","The AtLeastNode(PV, N, P) filtering condition verifies if at least N number of nodes on each of the paths which is bound to the variable PV satisfies the predicate P and filters out those paths which do not satisfy the predicate P. It is noted that this predicate can be either a structural predicate or a value-based predicate. By way of example but not limitation, the AtLeastNode(??X, 2, livesIn Sydney) filtering condition ensures that at least two nodes of each of the paths which is bound to the variable ??X satisfy the structural predicate of being connected by the livesIn relationship to a node that is labeled with an attribute having a value of Sydney. The AtLeastNode(??X, 1, @affiliated UNSW) filtering condition ensures that at least one node of each of the paths which is bound to the variable ??X satisfies the value-based predicate of the affiliated attribute having a value of UNSW.","The AtLeastEdge(PV, N, P) filtering condition ensures that at least N number of edges on each of the paths which is bound to the variable PV satisfy the value-based predicate P (it is noted that structural predicates may not be represented for edges). The AtMostEdge(PV, N, P) filtering condition ensures that at most N number of edges on each of the paths which is bound to the variable PV satisfy the value-based predicate P. The AllEdges(PV, P) filtering condition ensures that at every edge of each of the paths which is bound to the variable PV satisfies the value-based predicate P.","It will be appreciated that the foregoing filtering conditions are exemplary and various other filtering conditions are also possible.","1.3 Query Execution Engines","As is appreciated in the art of database systems, relational database systems are generally efficient in executing queries that benefit from indexing (e.g., B-tree) and query optimization techniques (e.g., selectivity estimation and join ordering). By way of example but not limitation, by applying predicates, relational indices can limit the data that needs to be accessed to just those rows that satisfy the predicates. Additionally, index-only access can be used to evaluate and answer relational database queries, thus eliminating the need to access the data pages by providing all the columns that are involved in the query processing. However, relational database systems are inefficient in processing queries that involve looping or recursive access to a large number of records by executing a plurality of performance-expensive join operators which may yield a large intermediate result. Hence, executing traversal operations over a graph (or a portion thereof) that is stored in a relational database system can be time-inefficient due to the large number of potential joins and the performance-cost of having to retrieve the target nodes from the secondary storage device on which the graph (or the portion thereof) is stored.","Generally speaking and as is appreciated in the arts of graph databases and graph query processing, various types of engines exist for executing graph queries, where each different type of engine can be used to execute a certain class of graph queries. By way of example but not limitation, various relational database engines (also known as relational database management systems) exist which can be used to execute pattern matching graph queries. Such relational database engines are commonly implemented in the form of an SQL (Structured Query Language) server. Exemplary relational database engines include the conventional SPARQL engines, Microsoft SQL Server\u00ae (a registered trademark of Microsoft Corporation), International Business Machines DB2, and Oracle database systems, among others. Various graph engines also exist which can be used to execute reachability and shortest path graph queries. Exemplary graph engines include the conventional Neo4j graph database, HyperGraphDB, Virtuoso, DEX, and AllegroGraph, among others.","As will be described in more detail hereafter, the graph query processing technique embodiments described herein can use a plurality of independent query execution engines to respond to a given graph query that is submitted by an entity to a graph database which is modeled by an attributed graph. These query execution engines can include either one or more relational database engines, or one or more graph engines, or one or more hybrid engines (which will be described in more detail hereafter). The query execution engines can also include any combination of relational database engines, graph engines and hybrid engines. More particularly and by way of example but not limitation, the query execution engines can include one or more relational database engines and one or more graph engines. The query execution engines can also include one or more relational database engines and one or more hybrid engines. The query execution engines can also include one or more graph engines and one or more hybrid engines. Generally speaking, different parts of the graph query are sent to different ones of the query execution engines for processing. More particularly, and by way of example but not limitation, in an exemplary embodiment of the graph query processing technique embodiments graph query components that involve relationships in the attributed graph (e.g., pattern match components) are sent to either a relational database engine or a relational database component of a hybrid engine for processing, and graph query components that involve the topology of the attributed graph (e.g., reachability and shortest path components) are sent to either a graph engine or a memory-based component of a hybrid engine for processing.",{"@attributes":{"id":"p-0061","num":"0071"},"figref":["FIG. 3","FIG. 3"],"b":["300","302","304","300","304","300","304","302","302","304"]},"Referring again to  and as is appreciated in the art of database systems, various approaches can be used to relationally store the attributed graph (or the portion thereof) in the relational database component . By way of example but not limitation, the conventional fully decomposed storage model (DSM) can be used to store the attributed graph (or the portion thereof) in the relational database component . This is advantageous for various reasons including, but not limited to, the following. DSM is agnostic to the attributed graph schema and thus can be applied to any attributed graph having any schema. DSM also permits efficient attribute retrieval during the graph query processing by significantly reducing the relational database accesses since just the records of the tables of the particular attributes\/relationships that are involved in the graph query will be processed.",{"@attributes":{"id":"p-0063","num":"0073"},"figref":["FIG. 4","FIG. 1","FIG. 4","FIG. 4"],"b":["406","400","400","406","408","400","400"]},"Referring again to , an edge identifier (eID) is assigned to each of the edges in the snippet of the attributed graph that is illustrated in . The attributes of the edges are stored in N two-column tables , where N is the number of different attributes of the edges in the graph snippet (N is three in the illustrated case). The first column (eID) of a given two-column edge attribute table  stores the identifiers of each of the edges that is labeled with the associated attribute, and the second column (Value) of this table stores the value of this attribute for each of these edges. By way of example but not limitation and as exemplified in , the edge in the graph snippet labeled \u201caffiliated\u201d that connects the node labeled \u201cJohn\u201d to the node labeled \u201cMicrosoft\u201d is assigned an eID of 3, and the title attribute for this edge is stored in row (3, Senior Researcher) of a title table . The edges that are not labeled with a particular attribute will simply not have a representative record in the edge attribute table which is associated with this attribute. An edge attribute that has a plurality of values will be represented with a plurality of rows (each having the same eID value) in the edge attribute table which is associated with this attribute. Each of the N two-column tables  can be sorted as a clustered index on the eID column which enables fast execution for merge joins when more than one attribute of the same edge has to be retrieved. Additionally, a secondary partitioned B-tree index on the Value column can be created for each of the N two-column tables  which enables fast execution for value-based predicates on the attributes by minimizing the performance-cost of accessing the relational database to retrieve those nodes that satisfy a predicate condition.","Referring again to , the edges in the snippet of the attributed graph that is illustrated in  are stored in P three-column tables , where P is the number of different relationships that exist between the nodes in the graph snippet (P is six in the illustrated case). These P three-column tables  store the topology of the graph snippet (e.g., data representing the structure of the nodes and edges in the graph snippet) in the following manner. Each of the P three-column tables  groups the data of all the edges that represent a particular relationship. Each of the edges is described by three pieces of data, namely the edge identifier (eID), the identifier of the source node (sID) that the edge is connected to, and the identifier of the destination node (dID) that the edge is connected to.","Referring again to , it will be appreciated that the memory-based representation of the topology of the attributed graph  can be implemented in various ways. By way of example but not limitation, a native, pointer-based data structure can be employed to represent the topology of the attributed graph in memory . More particularly, the memory-based representation of the topology of the attributed graph  can encode the data in the P three-column tables , which in principle represents the data that is used during the processing of the reachability and shortest path components of a graph query which can involve heavy transversal operations on the topology of the graph. As will be described in more detail hereafter, such traversal operations can be performed using various methods such as the conventional Dijkstra method for obtaining the shortest path between two nodes, and the conventional breadth-first search (BFS) method, among others.","Given the foregoing, it will be appreciated that the hybrid relational representation of an attributed graph that is provided for by the hybrid engine substantially reduces main memory consumption in the following ways. First, the attributes of the nodes and edges in the attributed graph, and the data values of these attributes, do not have to be loaded into the memory unless needed in a query. Second, extra memory indices for these attributes do not have to be built outside the hybrid engine's relational database component since the graph query processing technique embodiments described herein send the evaluation of the graph query predicates to the relational database component for processing, and the relational database component chooses to build its efficient indexes to accelerate the query evaluation.","1.4 Graph Query Processing",{"@attributes":{"id":"p-0068","num":"0078"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":["500","500","502","504","506","508","510","512","502","506","508","510"]},"Referring again to , it will be appreciated that the query compiler  can be implemented in various ways. By way of example but not limitation and as exemplified in , the query compiler  can include a front-end compiler  and a back-end compiler . Generally speaking and as will be described in more detail hereafter, the front-end compiler  translates the G-SPARQL query into an algebraic query plan that includes a plurality of algebraic operators (such as relational operators and reachability operators, among others), and serves as an abstract intermediate language which represents the G-SPARQL query. The front-end compiler  uses a dialect of tuple-based algebra to perform this translation. This tuple-based algebra includes a set of algebraic operators each of which considers tuples as the main unit of information, and each of which manipulates collections of tuples. The set of algebraic operators that is employed by the front-end compiler  includes a collection of different conventional relational operators (e.g., selection, projection, join) and also includes a collection of different non-conventional graph operators that are capable of expressing complex graph query operations that cannot be matched with the semantics of the relational operators (e.g., cannot be expressed by the relational operators).","Referring again to , the back-end compiler  generally translates the algebraic query plan into a plurality of sub-queries that represent the query components of the G-SPARQL query. More particularly and as will be described in more detail hereafter, the back-end compiler  analyzes the algebraic operators of the algebraic query plan and translates these algebraic operators into either SQL sub-queries or non-relational sub-queries. The back-end compiler  generates SQL sub-queries for the algebraic operators of the algebraic query plan that are associated with relational operations in the attributed graph (e.g., the algebraic operators that are associated with the aforementioned pattern match component of the G-SPARQL query). The back-end compiler  generates non-relational sub-queries for the algebraic operators of the algebraic query plan that are associated with traversal operations in the attributed graph (e.g., the algebraic operators that are associated with the aforementioned reachability and shortest path components of the G-SPARQL query). Since the algebraic query plan is based on tuples, the back-end compiler  is able to leverage various conventional and well-established relational query planning and optimization methods during the sub-query generation.","Generally speaking and referring again to , the query execution manager  serves to abstract the independent query execution engines \/\/. More particularly and as will be described in more detail hereafter, the query execution manager uses a knowledge of which of the plurality of independent query execution engines are currently available and the characteristics of each of the available query execution engines (e.g., its application programming interface (API), the type(s) of query it can efficiently execute, the cost to use it, and data availability, among other things), along with one or more engine selection rules, to identify a one of the query execution engines that is to be used to process each of the query components (e.g., the sub-query that represents each of the query components). In one embodiment of the graph query processing technique described herein, for each of the query components the query execution manager then sends the sub-query that represents the query component to the identified query execution engine for processing and receives corresponding results from this identified engine. Assuming the results received are sufficient to answer the graph query, the query execution manager then combines the results received and sends them to the query results presenter . The query results presenter  then uses the combined results received to generate a response to the graph query, and presents the response to the entity that submitted the graph query. A situation where the results for a one or more of the sub-queries are needed to execute another one or more of the sub-queries is described in more detail hereafter.","Generally speaking and referring again to , the architectural framework  can be either implemented on a single computing device, or implemented on a plurality of different computing devices. More particularly, and by way of example but not limitation, in a unified embodiment of the graph query processing technique described herein the entire framework  can be implemented on a single computing device. In a distributed embodiment of the graph query processing technique, each of the different elements - of the framework  can be implemented on a different computing device and these different computing devices can be interconnected via a data communication network. As such, it will be appreciated that the graph query processing technique embodiments support the querying of a large attributed graph where different parts or components of the attributed graph are stored on different computing devices each of which has its own independent query execution engine that processes queries\/sub-queries which are sent thereto.","A more detailed description of the set of algebraic operators, the front-end compiler that uses these operators, the back-end compiler, and the query execution manager will be provided hereafter. As will be appreciated from the more detailed description that follows, the set of algebraic operators, the front-end compiler, the back-end compiler, and the query execution manager are advantageous since they are independent of the specific representation of the attributed graph that is employed in each of the query execution engines.",{"@attributes":{"id":"p-0074","num":"0084"},"figref":["FIG. 6","FIG. 6"],"b":["600","602","604","606","608","610","612","614","616"]},{"@attributes":{"id":"p-0075","num":"0085"},"figref":["FIG. 16","FIG. 16"],"b":["1600","1602","1604","1606","1608","1610","1612","1614"]},"1.4.1 G-SPARQL Algebraic Operators",{"@attributes":{"id":"p-0076","num":"0086"},"figref":["FIG. 7","FIG. 7"]},"Referring again to , the NgetAttVal operator is a unary operator that is used to retrieve the values of a specific attribute for a given set of nodes in an attributed graph. The NgetAttVal operator receives a set of tuples {ID, (attName): ID, value} where the ID column of the input relation identifies the nodes in the attributed graph, and also identifies the name (attName) of the attribute in the graph to be accessed. The schema of the output tuples extends the schema of the input tuples with the value column that represents the values of the accessed attribute. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the NgetAttVal operator when it retrieves the values of a \u201clocation\u201d attribute for an input relation having a three node ID of (\u201cJohn\u201d, \u201cAlice\u201d, \u201cSmith\u201d). As exemplified in , the output relation includes just one record (for the \u201cAlice\u201d node) that has the \u201clocation\u201d attribute, and this attribute has a value of \u201cSydney\u201d. The \u201cJohn\u201d and \u201cSmith\u201d nodes are filtered out because they do not have values for the \u201clocation\u201d attribute.","The EgetAttVal operator is another unary operator that is used to retrieve the values of a specific attribute for a given set of edges in an attributed graph. The EgetAttVal operator receives a set of tuples {eID, (attName): eID, value} where the eID column of the input relation identifies the edges in the attributed graph, and also identifies the name (attName) of the attribute in the graph to be accessed. The schema of the output tuples extends the schema of the input tuples with the value column that represents the values of the accessed attribute. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the EgetAttVal operator when it retrieves the values of a \u201ctitle\u201d attribute for an input relation having an eID of two edges. As exemplified in , the schema of the output relation extends the schema of the input relation with an attribute that stores the value of the accessed attribute.","It is noted that the conventional relational selection operator \u03c3can be used for representing value-based predicates p over the values of the attributes of nodes or edges in an attributed graph. When used in this manner, \u03c3selects just the tuples of an input relation for which the value-based predicate p over a specific column holds. It will thus be appreciated that using \u03c3in this manner is advantageous in that it represents the right match for reflecting the expressivity of the SPARQL FILTER expression.  illustrates an exemplary embodiment, in simplified form, of an extension of the behavior exemplified in  where \u03c3is used to filter the input edges based on the predicate title=\u201cProfessor\u201d for the retrieved values of the \u201ctitle\u201d attribute.","Referring again to , the getEdgeNodes operator is another unary operator that is used to retrieve a set of adjacent nodes in an attributed graph. The getEdgeNodes operator receives a set of tuples {sID, [(eLabel)]: sID, eID, dID} where the sID column of the input relation identifies the nodes in the attributed graph, and can optionally also identify a specified relation for accessing the adjacent nodes (eLabel). The schema of the output tuples extends the schema of the input tuples with the two columns that represent the identifier eID of the connecting edges of the specified relation and the identifier dID of the adjacent node. In the case where the getEdgeNodes operator receives the eLabel parameter, then the getEdgeNodes operator filters out the nodes that do not have adjacent nodes connected with the specified relationship. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the getEdgeNodes operator when it retrieves the adjacent nodes that are connected through a \u201cknow\u201d relationship for an input relation having a two node sID of (\u201cJohn\u201d, \u201cAlice\u201d). As exemplified in , the output relation filters out the \u201cAlice\u201d node since it is not connected to any other node through the \u201cknow\u201d relationship.  illustrates an exemplary embodiment, in simplified form, of the behavior of the getEdgeNodes operator when it retrieves all the adjacent nodes for an input relation having a two node sID of (\u201cJohn\u201d, \u201cAlice\u201d).","Referring again to , the strucPred operator is a unary operator that is used to filter a given set of nodes in an attributed graph based on a specific structural predicate. The strucPred operator receives a set of tuples {sID, (eLabel), (dNLabel): sID, [eID]} where the sID column of the input relation identifies the nodes in the attributed graph, and also identifies a structural predicate that is described by the label of the connecting relation (eLabel), and also identifies a label for the adjacent node (dNLabel) that is to be accessed through this relation. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the strucPred operator when it applies a structural predicate that filters out the nodes that are not connected to an adjacent node having the label \u201cSmith\u201d through a \u201cknow\u201d relationship.  illustrates an exemplary embodiment, in simplified form, of the behavior of the strucPred operator when it projects the data of the connecting edges that represent the structural predicate. In this particular embodiment the schema of the output relation is extended with an additional column that stores the eID of the connecting edges.","Referring again to , the edgeJoin operator is a binary join operator that receives two relations (S and D) where the two columns sID and dID identify the nodes of S and D, respectively, in an attributed graph. For each of the pairs of nodes in the attributed graph, the edgeJoin operator checks whether the pair is connected with any edge in the attributed graph, filters out the unconnected pairs of nodes, and returns the tuples of the connected pairs of nodes as a result. The output of the edgeJoin operator is a single relation where the schema of the output tuples concatenates the columns of S and D. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the edgeJoin operator when it receives two sets of nodes, namely (\u201cJohn\u201d, \u201cAlice\u201d, \u201cSmith\u201d) and (\u201cPaper 2\u201d, \u201cPaper 1\u201d), and returns the pairs of nodes that are connected through any relationship.","As exemplified in , the edgeJoin operator can also receive an optional parameter eLabel which imposes a specific relationship condition on the connecting edge between each of the pairs of nodes in an attributed graph. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the edgeJoin operator when it receives two sets of nodes, namely (\u201cJohn\u201d, \u201cAlice\u201d, \u201cSmith\u201d) and (\u201cMicrosoft\u201d), and returns the pairs of nodes that are connected through an \u201caffiliated\u201d relationship. The edgeJoin operator can also optionally project the data of the connecting edge(s) where it extends the schema of the output relation by an additional column eID that represents the identifiers of the connecting edges between each of the pairs of nodes in the output tuples according to the specified input parameters.  illustrate exemplary embodiments, in simplified form, of this projection feature of the edgeJoin operator. More particularly,  illustrates an exemplary embodiment of the behavior of the edgeJoin operator which is similar to the embodiment illustrated in  except for the fact that the output relations exemplified in  include the eID of the connecting edges between each of the output pairs of nodes. Similarly,  illustrates an exemplary embodiment of the behavior of the edgeJoin operator which is similar to the embodiment illustrated in  except for the fact that the output relations in  include the eID of the connecting edges between each of the output pairs of nodes.","Referring again to , the pathJoin operator is another binary join operator that receives two relations (S and D) where the two columns sID and dID identify the nodes of S and D, respectively, in an attributed graph. For each of the pairs of nodes in the attributed graph, the pathJoin operator checks whether the pair is connected by a sequence of edges in the attributed graph, where this sequence can be of any length, filters out the unconnected pairs of nodes, and returns the tuples of the connected pairs of nodes as a result. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the pathJoin operator when it receives two sets of nodes, namely (\u201cJohn\u201d, \u201cAlice\u201d, \u201cSmith\u201d) and (\u201cJohn\u201d, \u201cAlice\u201d, \u201cSmith\u201d), and returns the pairs of nodes that are connected through a sequence of relationships of any length. The pathJoin operator can also receive an optional parameter eLabel which imposes a specific relationship condition on the edge of the connecting path between each of the pairs of nodes.  illustrates an exemplary embodiment of the pathJoin operator when it receives two sets of nodes, namely (\u201cJohn\u201d, \u201cAlice\u201d, \u201cSmith\u201d) and (\u201cJohn\u201d, \u201cAlice\u201d, \u201cSmith\u201d), and returns the pairs of nodes that are connected through a sequence of \u201cknow\u201d relationships of any length.","As exemplified in , the pathJoin operator can also optionally project the data of the connecting path(s) as follows. First, the pathJoin operator can extend the schema of the input relation by an additional column pID that represents an assigned identifier for the connecting path between each of the pairs of nodes specified in operator input. It is noted that each of the pairs of nodes can be connected with a plurality of different paths and as such, each of the input pairs of nodes can have a plurality of different representing tuples which describe the data of the bound paths. Second, the pathJoin operator can return another output relation pRel that describes the data of the resulting paths, where each of the resulting paths is described by a sequence of tuples which represent the nodes and edges that make up the path in an orderly manner, and each of the tuples in this sequence can be described by a plurality of fields including, but not limited to, a pID field that represents the path identifier, a type field that represents whether the tuple describes a node or an edge, an order field that represents the order of the node or edge that participates in the path, an ID field that represents the identifier of the node or edge, and a label field that represents the Label data of the node or edge. In an exemplary embodiment of the graph query processing technique described herein if the tuple describes a node then the type field has a value of \u2018N\u2019, and if the tuple describes an edge then the type field has a value of \u2018E\u2019. Additionally, the order of each of the paths starts with an edge ordered as one followed by a node ordered as two, and then the order of the path alternates until the last edge of the path is reached. The value of a given path variable in the query output is represented by a serialization of the Label data of the tuples that are associated with the path variable, where this Label data is serialized in ascending order.",{"@attributes":{"id":"p-0086","num":"0096"},"figref":["FIGS. 8M and 8O","FIG. 8M","FIG. 8L","FIG. 8M","FIG. 8O","FIG. 8N","FIG. 8O"]},"Referring again to , the sPathJoin operator works in the same way as the pathJoin operator except for the fact that the sPathJoin operator returns the paths that represent the shortest connection between each of the pairs of nodes in an attributed graph, assuming such connections exist.","As exemplified in , the filterPath operator is a binary operator that receives two relations (R and pRel) where the pID column of the relation R represents the path identifiers that have their associated description data represented by the relation pRel. The filterPath operator returns the relation R, where the tuples that have paths pID with data pRel which does not fulfill a condition cond are filtered out. The cond parameter represents one of the aforementioned path filtering conditions. Based on the snippet of the attributed graph that is illustrated in  and its corresponding relational representation that is illustrated in ,  illustrates an exemplary embodiment, in simplified form, of the behavior of the filterPath operator when it filters a set of paths based on a Length (e.g., number of edges) condition that returns the paths having lengths greater than one, and filters out the rest of the paths.","As indicated in , some of the algebraic operators described heretofore cannot be represented by conventional relational operators. Based on the aforementioned hybrid relational representation of an attributed graph that can be employed by the graph query processing technique embodiments described herein,  illustrates exemplary embodiments of mappings for the algebraic operators that can be translated into a pattern of conventional relational operators. By way of example but not limitation and as exemplified in , the NgetAttVal operator can be mapped to a join operation between the nodeID column of the input relation R and the ID column of the relation that represents the specified node attribute (attName). The NgetAttVal operator extends the schema of the input tuples (R.*) with the value column for the relation of the specified attribute (attName). Since the semantics of the getEdgeNodes and edgeJoin operators can be not restricted by a specified relationship (eLabel), applying these operators using the standard relational operators requires joining the input relation(s) with each of the relation tables, separately, and then performing a union of all the results. Stated more simply, a materialized view (allEdges) can be created that represents a union of all the relation tables.",{"@attributes":{"id":"p-0090","num":"0100"},"figref":["FIGS. 10A and 10B","FIG. 10A"],"smallcaps":"RANS","sub":"nodeID,(attName):value ","ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["SELECT R.*, attName.Value FROM R, attName","WHERE R.nodeID=attName.ID;\n\n1.4.2 Front-End Compiler\n"]}}}},"This section provides a more detailed description of the aforementioned exemplary front-end compiler.",{"@attributes":{"id":"p-0092","num":"0104"},"figref":["FIG. 11","FIG. 11","FIGS. 12A-12D","FIG. 12A","FIGS. 12A-12D"],"b":"1100","smallcaps":["P","AP","P","AP","P","AP"],"sub":"ID,(attName):value "},"Referring again to , once the triple patterns of the G-SPARQL query have been mapped onto the set of algebraic operators (block ), a set of query re-writing rules is applied in order to reduce the execution time of the G-SPARQL query evaluation (block ), where these re-writing rules are specific to the G-SPARQL constructs described herein. Additionally, the triple patterns of the G-SPARQL query are reordered according to their \u201crestrictiveness\u201d, where this reordering is performed using the following set of triple pattern precedence rules (block ). Given that t1, t2\u03b5Triple(q) denotes two triple patterns of a given G-SPARQL query q, triple pattern t1 is defined as being less restrictive than triple pattern t2 (e.g., t1>>t2) whenever t1 has more path variables (?? or ?*) than t2. Triple pattern t1 is defined as being more restrictive than triple pattern t2 (e.g., t1<<t2) whenever t1 has fewer path variables (?? or ?*) than t2. Triple pattern t1 is also defined as being more restrictive than triple pattern t2 (e.g., t1<<t2) whenever t1 has the same number of path variables (?? or ?*) as t2 and the number of filter expressions over t1's path variables is greater than the number of filter expressions over t2's path variables. In other words, a triple pattern of the G-SPARQL query that is more restrictive is given a higher precedence in order to optimize the join order for the SQL sub-queries that are generated for the G-SPARQL query.",{"@attributes":{"id":"p-0094","num":"0106"},"figref":["FIGS. 13A and 13B","FIG. 13A"],"smallcaps":["EWRITE","EWRITE"]},{"@attributes":{"id":"p-0095","num":"0107"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0096","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT ?L1 ?L2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"WHERE { ?X @label ?L1.","?Y @label ?L2."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002?X @age ?age1.","?Y @age ?age2."]},{"entry":[{},"\u2002?X affiliated UNSW.","?X livesIn Sydney."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002?Y ?E(affiliated) Microsoft."]},{"entry":[{},"\u2002?E @title \u201cResearcher\u201d."]},{"entry":[{},"\u2002?X ??P ?Y."]},{"entry":[{},"\u2002FILTER (?age1 >= 40). FILTER(?age2 >= 40).}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This section provides a more detailed description of the aforementioned exemplary back-end compiler.",{"@attributes":{"id":"p-0098","num":"0110"},"figref":["FIG. 15","FIG. 15","FIG. 9"],"b":["1500","1502","1504","1506"]},"As exemplified in , in an exemplary embodiment of the graph query processing technique described herein the algebraic query plan that is generated by the front-end compiler can be formed as a directed acyclic graph. As such, the back-end compiler can translate the algebraic query plan into sub-queries by traversing the algebraic query plan in a bottom-up manner (e.g., starting from the \u201cleaves\u201d and then \u201cclimbing\u201d the different paths back to the \u201croot\u201d) using a conventional set of defined pattern-based translation rules. This \u201cclimbing\u201d of a given path will stop if it reaches an algebraic operator that does not have a conventional relational representation for its semantics, or if it reaches the \u201croot\u201d. By way of example but not limitation, all of the algebraic operators shown in  can be translated into SQL sub-queries except the pathJoin operator. More particularly and as indicated by the dashed boxes in , two SQL sub-queries (namely SQLand SQL) are generated by the back-end compiler, where the following results of these SQL sub-queries can then be sent to either a graph engine or the memory-based component of a hybrid engine using the pathJoin operator:",{"@attributes":{"id":"p-0100","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SQL:","SELECT N1.ID as sID, N1.Value as L1"]},{"entry":[{},"FROM NodeLabel as N1, age, affiliated, livesIn,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"NodeLabel as N2, NodeLabel as N3"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"WHERE N1.ID = age.ID AND N1.ID = affiliated.sID"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AND affiliated.dID = N2.ID AND N2.value ="]},{"entry":[{},"\u201cUNSW\u201d AND N1.ID = livesIn.sID AND"]},{"entry":[{},"livesIn.dID = N3.ID AND N3.Value = \u201cSydney\u201d"]},{"entry":[{},"AND age.Value >= 40;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SQL:","SELECT N1.ID as dID, N1.Value as L2"]},{"entry":[{},"FROM NodeLabel as N1, age, title, affiliated,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"NodeLabel as N2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"WHERE N1.ID = age.ID AND N1.ID = affiliated.sID"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AND affiliated.dID = N2.ID AND N2.value ="]},{"entry":[{},"\u201cMicrosoft\u201d AND affiliated.eID = title.ID AND"]},{"entry":[{},"title.Value = \u201cResearcher\u201d AND age.Value >= 40;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This section provides a more detailed description of several of the aforementioned features of the query execution manager.","As described heretofore, the query execution manager uses a knowledge of which of a plurality of independent query execution engines are currently available and the characteristics of each of the available query execution engines, along with one or more engine selection rules, to identify a one of the query execution engines that is to be used to process each of the query components (e.g., the sub-query that represents each of the query components). In one embodiment of the graph query processing technique described herein performance-based engine selection rules can be used to perform this identification, where these rules specify that a pattern match component of the G-SPARQL query (e.g., the SQL sub-query that represents this component) is to be executed by either a relational database engine or the relational database component of a hybrid engine. The performance-based engine selection rules also specify that a reachability component of the G-SPARQL query (e.g., the non-relational sub-query that represents this component) is to be executed by either a graph engine or the memory-based component of a hybrid engine. The performance-based engine selection rules also specify that a shortest path component of the G-SPARQL query (e.g., the non-relational sub-query that represents this component) is to be executed by either a graph engine or the memory-based component of a hybrid engine.","In another embodiment of the graph query processing technique described herein at least a monetary-cost-based engine selection rule can be used to identify a one of the plurality of independent query execution engines that is to be used to process each of the query components, where this rule specifies that each of the query components is to be executed by a one of the plurality of independent query execution engines that is the least expensive to use. In yet another embodiment of the graph query processing technique a combination of the performance-based engine selection rules and the monetary-cost-based engine selection rule can be used to identify a one of the plurality of independent query execution engines that is to be used to process each of the query components.",{"@attributes":{"id":"p-0104","num":"0116"},"figref":["FIG. 17","FIG. 17"],"b":["1700","1702","1704","1706","1708","1710"]},"While the graph query processing technique has been described by specific reference to embodiments thereof, it is understood that variations and modifications thereof can be made without departing from the true spirit and scope of the graph query processing technique. It is also noted that any or all of the aforementioned embodiments can be used in any combination desired to form additional hybrid embodiments or distributed embodiments. Although the graph query processing technique embodiments have been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described heretofore. Rather, the specific features and acts described heretofore are disclosed as example forms of implementing the claims.","The graph query processing technique embodiments described herein are operational within numerous types of general purpose or special purpose computing system environments or configurations.  illustrates a simplified example of a general-purpose computer system on which various embodiments and elements of the graph query processing technique, as described herein, may be implemented. It is noted that any boxes that are represented by broken or dashed lines in  represent alternate embodiments of the simplified computing device, and that any or all of these alternate embodiments, as described below, may be used in combination with other alternate embodiments that are described throughout this document.","For example,  shows a general system diagram showing a simplified computing device . Such computing devices can be typically be found in devices having at least some minimum computational capability, including, but not limited to, personal computers (PCs), server computers, handheld computing devices, laptop or mobile computers, communications devices such as cell phones and personal digital assistants (PDAs), multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, audio or video media players, and computing resources in a cloud computing environment.","To allow a device to implement the graph query processing technique embodiments described herein, the device should have a sufficient computational capability and system memory to enable basic computational operations. In particular, as illustrated by , the computational capability is generally illustrated by one or more processing unit(s) , and may also include one or more graphics processing units (GPUs) , either or both in communication with system memory . Note that that the processing unit(s)  of the simplified computing device  may be specialized microprocessors (such as a digital signal processor (DSP), a very long instruction word (VLIW) processor, a field-programmable gate array (FPGA), or other micro-controller) or can be conventional central processing units (CPUs) having one or more processing cores including, but not limited to, specialized GPU-based cores in a multi-core CPU.","In addition, the simplified computing device  of  may also include other components, such as, for example, a communications interface . The simplified computing device  of  may also include one or more conventional computer input devices  (e.g., pointing devices, keyboards, audio (e.g., voice) input devices, video input devices, haptic input devices, gesture recognition devices, devices for receiving wired or wireless data transmissions, and the like). The simplified computing device  of  may also include other optional components, such as, for example, one or more conventional computer output devices  (e.g., display device(s) , audio output devices, video output devices, devices for transmitting wired or wireless data transmissions, and the like). Note that typical communications interfaces , input devices , output devices , and storage devices  for general-purpose computers are well known to those skilled in the art, and will not be described in detail herein.","The simplified computing device  of  may also include a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  via storage devices , and can include both volatile and nonvolatile media that is either removable  and\/or non-removable , for storage of information such as computer-readable or computer-executable instructions, data structures, program modules, or other data. By way of example but not limitation, computer-readable media may include computer storage media and communication media. Computer storage media refers to tangible computer-readable or machine-readable media or storage devices such as digital versatile disks (DVDs), compact discs (CDs), floppy disks, tape drives, hard disk drives, optical disk drives, solid state memory devices, random access memory (RAM), read-only memory (ROM), electrically erasable programmable read-only memory (EEPROM), flash memory or other memory technology, magnetic cassettes, magnetic tapes, magnetic disk storage, or other magnetic storage devices, or any other device which can be used to store the desired information and which can be accessed by one or more computing devices.","Retention of information such as computer-readable or computer-executable instructions, data structures, program modules, and the like, can also be accomplished by using any of a variety of the aforementioned communication media to encode one or more modulated data signals or carrier waves, or other transport mechanisms or communications protocols, and can include any wired or wireless information delivery mechanism. Note that the terms \u201cmodulated data signal\u201d or \u201ccarrier wave\u201d generally refer to a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. For example, communication media can include wired media such as a wired network or direct-wired connection carrying one or more modulated data signals, and wireless media such as acoustic, radio frequency (RF), infrared, laser, and other wireless media for transmitting and\/or receiving one or more modulated data signals or carrier waves. Combinations of any of the above should also be included within the scope of communication media.","Furthermore, software, programs, and\/or computer program products embodying some or all of the various graph query processing technique embodiments described herein, or portions thereof, may be stored, received, transmitted, or read from any desired combination of computer-readable or machine-readable media or storage devices and communication media in the form of computer-executable instructions or other data structures.","Finally, the graph query processing technique embodiments described herein may be further described in the general context of computer-executable instructions, such as program modules, being executed by a computing device. Generally, program modules include routines, programs, objects, components, data structures, and the like, that perform particular tasks or implement particular abstract data types. The graph query processing technique embodiments may also be practiced in distributed computing environments where tasks are performed by one or more remote processing devices, or within a cloud of one or more devices, that are linked through one or more communications networks. In a distributed computing environment, program modules may be located in both local and remote computer storage media including media storage devices. Additionally, the aforementioned instructions may be implemented, in part or in whole, as hardware logic circuits, which may or may not include a processor."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["The specific features, aspects, and advantages of the graph query processing technique embodiments described herein will become better understood with regard to the following description, appended claims, and accompanying drawings where:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIGS. 8A-8P","FIG. 7","FIG. 1","FIG. 4"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 10A and 10B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 12A-12D"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 13A and 13B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 18"}]},"DETDESC":[{},{}]}
