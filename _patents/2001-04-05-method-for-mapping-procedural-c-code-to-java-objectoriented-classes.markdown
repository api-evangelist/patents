---
title: Method for mapping procedural C++ code to java object-oriented classes
abstract: A method and apparatus for mapping of procedural code to object-oriented classes is disclosed. A mapping layer in an object-oriented programming language process space that maps procedural method calls to object-oriented class instantiations and remote method invocations according to an embodiment of the present invention is disclosed. The mapping layer preferably is utilized for accomplishing persistent changes to the object-oriented classes. The mapping layer preferably comprises entry-points that are methods, which may be invoked by procedural graphical user interface callback code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06886172&OS=06886172&RS=06886172
owner: Hewlett-Packard Development Company, L.P.
number: 06886172
owner_city: Houston
owner_country: US
publication_date: 20010405
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The invention relates to programming language interactions, and more specifically to legacy C++ GUI interactions with a Java environment.","In many software systems today, the existing or legacy graphical user interfaces (\u201cGUIs\u201d) are coded in C++. Over the past few years, however, Java\u00ae has become the programming language of choice. In order to use Java for providing the functionality of a system, the C++ GUIs must be made useable with Java. One alternative is to rewrite all of the lines of C++ code in Java. Rewriting the C++ code may comprise rewriting many lines of code. In many situations this is impractical. Furthermore, in many situations, it is desirable to maintain the C++ GUIs, instead of replacing them, and to use them to interface Java objects and methods of the Java functional code.","However, although generally an object-oriented language, C++ is a procedural language in that it can implement procedural interfaces while Java is an object-oriented language. Object-oriented programming is a method of programming that pairs programming tasks and data into re-usable chunks known as objects. Each object comprises attributes (i.e., data) that define and describe the object. Java classes are meta-definitions that define the structure of a Java object. Java classes when instantiated create instances of the Java classes and are then considered Java objects. Methods within Java objects are called to get or set attributes of the Java object and to change the state of the Java object. Associated with each method is code that is executed when the method is invoked.","A task that is a sequence of steps in a C++ implementation likely involves the creation and\/or manipulation of multiple objects in a Java implementation. Moreover, some tasks may require a remote method invocation (\u201cRMI\u201d). Unfortunately, coding Java object-creation or RMIs in C++ can be quite cumbersome. If C++ GUIs are maintained for accessing a Java implementation, the cumbersome coding of the tasks involving Java object-creation and RMIs will clutter the C++ GUIs.","A solution to this problem would simplify the C++ GUI code by having Java object creation occur in Java. A solution would simplify access to first-class objects of the Java implementation and provide a simple access to RMIs. A solution would allow simple C++ GUI callback code for creating and accessing Java objects.","The present invention comprises a method and apparatus that maps procedural C++ code to Java object-oriented classes. A software component according to an embodiment of the invention is an Objectifier that is coded to call Java methods and make RMI calls as necessary to create and access Java objects in order to perform certain actions requested by C++ GUIs. The Objectifier is preferably a static Java class comprising a series of pass-through interfaces that may be accessed by executing simple C++ GUI callbacks.","When a C++ GUI executes callback code to access a pass-through interface or entry-point, the Objectifier preferably executes Java method call(s) and\/or RMI(s), associated with the entry-point, in order to perform the requested action. These entry-points thus map the procedural C++ code to the object-oriented Java code necessary to perform the action. The Objectifier preferably consolidates the Java object creations and RMIs that are used to conduct a process in Java. The C++ GUI callbacks may access the Objectifier directly through Java Native Interface (\u201cJNI\u201d) Application Programming Interface (\u201cAPI\u201d) calls or through method calls to a C++ proxy of the Objectifier. The C++ proxy of the Objectifier preferably includes a one-to-one mapping of Objectifier methods as well as the necessary coding to make JNI API calls to the Objectifier.","A method according to an embodiment preferably comprises a user starting a C++ GUI in order to access a Java-based system, initializing a mapping layer (e.g., the Objectifier), executing a C++ GUI callback, the mapping layer receiving a method call through an entry-point, the mapping layer executing an algorithm comprising a class instantiation and\/or a RMI as determined by the entry-point, and if necessary, returning data to a C++ process space.","These and other advantages are achieved by a method for mapping procedural code to object-oriented classes comprising, starting a graphical user interface (\u201cGUI\u201d) in a procedural programming language process space, wherein a user enters a command through the GUI, initializing a mapping layer in an object-oriented programming language process space, wherein the mapping layer comprises entry-points that have corresponding algorithms that invoke object-oriented class instantiation methods and remote method invocations (\u201cRMIs\u201d), executing a GUI callback in response to the command, wherein the GUI callback comprises procedural code and wherein executing a GUI callback in response to the command comprises invoking one of the entry-points, and the mapping layer executing an algorithm corresponding to the invoked entry-point.","Likewise, these and other advantages are achieved by a computer system that enables the mapping of procedural code to object-oriented classes comprising a memory, a processor that runs an application, wherein the application generates a graphical user interface (\u201cGUI\u201d) in a procedural programming language process space, wherein users enter commands through the GUI, and, a mapping layer in an object-oriented programming language process space, wherein the mapping layer comprises entry-points that have corresponding algorithms that invoke object-oriented class instantiation methods and remote method invocations (\u201cRMIs\u201d).","These and other advantages are achieved by a computer readable medium containing instructions for mapping procedural code to object oriented classes, by starting a graphical user interface (\u201cGUI\u201d) in a procedural programming language process space, wherein a user enters a command through the GUI, initializing a mapping layer in an object-oriented programming language process space, wherein the mapping layer comprises entry-points that have corresponding algorithms that invoke object-oriented class instantiation methods and remote method invocations (\u201cRMIs\u201d), executing a GUI callback in response to the command, wherein the GUI callback comprises procedural code and wherein executing a GUI callback in response to the command comprises invoking one of the entry-points, and the mapping layer executing an algorithm corresponding to the invoked entry-point.","The mapping layer may be used with computer systems that utilize C++ graphical user interfaces (\u201cGUIs\u201d) to access Java objects across a Java Native Interface (\u201cJNI\u201d).  illustrates a computer network system  with which the present invention may be used. The network system  comprises a ServiceControl Manager (\u201cSCM\u201d)  running on a Central Management Server (\u201cCMS\u201d)  and one or more nodes  managed by the SCM  on the CMS . Together the one or more nodes  managed by the SCM  make up a SCM cluster . A group of nodes  may be organized as a node group .","The CMS  preferably is an HP-UX 11.x server running the SCM  software. The CMS  includes a memory , a secondary storage device , a processor , an input device (not shown), a display device (not shown), and an output device (not shown). The memory , a computer readable medium, may include, RAM or similar types of memory, and it may store one or more applications for execution by processor , including the SCM  software. The secondary storage device , a computer readable medium, may include a hard disk drive, floppy disk drive, CD-ROM drive, or other types of non-volatile data storage. The processor  executes the SCM  software and other application(s), which are stored in memory  or secondary storage , or received from the Internet or other network , in order to provide the functions and perform the methods described in this specification, and the processing may be implemented in software, such as software modules, for execution by the CMS  and modes . The SCM  is programmed in Java\u00ae and operates in a Java\u00ae environment that is preferably accessed by using legacy C++ GUIs and the present invention. See , HP part number: B8339-90019, which is hereby incorporated by reference and which is accessible at http:\/\/www.software.hp.com\/products\/scmgr, for a more detailed description of the SCM .","Generally, the SCM  supports managing a single SCM cluster  from a single CMS . All tasks performed on the SCM cluster  are initiated on the CMS  either directly or remotely, for example, by reaching the CMS  via a web connection . Therefore, a workstation  at which a user sits only needs a web connection  over the network  to the CMS  in order to perform tasks on the SCM cluster . The workstation  preferably comprises a display, a memory, a processor, a secondary storage, an input device and an output device. In addition to the SCM  software and the HP-UX server described above, the CMS  preferably also comprises a data repository  for the SCM cluster , a web server  that allows web access to the SCM  and a depot  comprising products used in the configuring of nodes, and a I\/UX server .","The nodes  are preferably HP-UX servers or other servers and they may be referred to as \u201cmanaged nodes\u201d or simply as \u201cnodes\u201d. The concept of a node  is that it represents a single instance of HP-UX running on some hardware. The node  may comprise a memory, a secondary storage device, a processor, an input device, a display device, and an output device.","Although the CMS  is depicted with various components, one skilled in the art will appreciated that this server can contain additional or different components. In addition, although aspects of an implementation consistent with the present invention are described as being stored in memory, one skilled in the art will appreciated that these aspects can also be stored on or read from other types of computer program products or computer-readable media, such as secondary storage devices, including hard disks, floppy disks, or CD-ROM; a carrier wave from the Internet or other network; or other forms of RAM or ROM. The computer-readable media may include instructions for controlling the CMS  (and\/or the nodes ) to perform a particular method, such as those described herein.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 2"],"i":["a ","a "],"b":["40","40","42","44","46","40","48","50"]},"In the system , each user, node, node group, role, tool, authorization, user name, node name, and node group name is, for each instance, represented by a single Java object. A role defines the role (e.g., administrator, database manager, web manager, etc.) a user may have on a certain node(s) or node group(s), where each role has one or more tools associated with it that a user with the role may execute. A tool is an executable that performs some process. An authorization defines the node(s) and node group(s) a user is authorized to access and what roles the user has on the authorized node(s) or node group(s).","When the attributes of any of the above (i.e., user, node, node group, etc.) are changed or need to be accessed, the representative Java object is instantiated and a mutator (e.g., set) or accessor (e.g., get) method of the representative Java object is invoked to change the object's attributes. When a new user, node, node group, etc. is added, a new, empty representative Java object is instantiated and then populated with the new user, node, node group, etc. attributes. Accordingly, an action that may be accomplished as simply a process of steps in a C++, may involve numerous object instantiations and method invocations in Java.","The Objectifier  is a mapping layer between procedural C++ GUI  callbacks in the C++ process space  and object-oriented Java implementation in the JVM . C++ GUI  callbacks are the code that a C++ GUI  executes to perform a function requested by a user input to the C++ GUI . Associated with each C++ GUI  input, generally, is one portion of callback code. However, each callback code may comprise a multiple step process.","Preferably, the Objectifier  is a singleton utility class with static methods, and therefore exists as only one instance per JVM . The Objectifier  preferably is a single threaded interface. Preferably, the Objectifier  is used to make persistent changes (e.g., create a new user, delete a user, store a user, store a node, create a node, create an authorization, store an authorization, or execute a tool as an instance of a task, etc.). As such, the Objectifier  static methods preferably execute the class instantiations and RMIs necessary to accomplish these persistent changes.","As a mapping layer between procedural C++ GUI  callbacks and the object-oriented Java implementation, the Objectifier  comprises a series of pass through interfaces or entry-points  for the procedural C++ GUI  callbacks. Each entry-point  is preferably an Objectifier  static method that may be invoked by at least one executed C++ GUI  callback. The entry-points  map to the Java object-oriented coding necessary to perform an action. As depicted in , when a user wants to perform some action (e.g., create a new user object), a callback is executed and a method call (e.g., addUser( )) is issued to the Objectifier . The method call passes to the Objectifier  through an entry-point  corresponding to the invoked method.","As shown above, performing a task (e.g., adding a user) in the JVM  may not simply be a sequence of procedural steps as it would be in a C++ implementation. Rather, one or more classes may need to be instantiated as objects  (e.g., a new user object needs to be created) in order to perform the task. For example, in order to create a new user object in the SCM  described above, the nodes, node groups, tools and roles that the new user is authorized to access may need to be determined. Consequently, certain utility classes (e.g., object managers  that are used to access and manage the objects ) may need to be accessed via a Remote Method Invocation (\u201cRMI\u201d). An RMI is used to access an object in a different JVM \u2032. The object managers  may be housed in a domain manager (not shown) that is a module of the SCM  software that preferably runs on the CMS .","Coding Java class instantiations, let alone a multiple-class instantiating process, is cumbersome in C++. The coding involves cluttering the C++ GUI  callback code with the awkward procedural C++ implementation of an object-oriented process. Moreover, for many steps of the process, the C++ GUI  would have to instantiate a plurality of objects  in the JVM  through the JNI . Further, the C++ GUI  would have to accomplish RMIs through the JNI , a difficult and cumbersome requirement.","Instead, the Objectifier  is coded with the necessary class instantiation(s) and RMIs  for performing the actions that may be requested by the C++ GUI  callback code. Accordingly, associated with each entry-point  is the necessary class instantiation(s) and\/or RMI(s)  for performing the action requested by the C++ GUI  method call corresponding to that entry-point , as depicted in . Therefore, the C++ GUI  callback code is not cluttered with awkward C++ creation of Java objects and awkward Java RMIs. Moreover, the Objectifier  consolidates all of the class instantiations and RMIs in a single Java class so that the C++ GUI  method calls need be made to only a single Java class, the Objectifier .","Consequently, a C++ GUI  method call to the Objectifier  triggers the execution of the object-oriented Java implementation of a requested action. The C++ GUI  method call need only invoke the Objectifier  method for the requested action in order to enter the Objectifier  through the correct entry-point . For example, in order to store a newly-created user, the C++ GUI  may execute a callback that invokes the Objectifier  method addUser( ). This method call \u2018enters\u2019 the Objectifier  through an addUser( ) entry-point , triggering execution of the necessary RMI to store the new user object, as shown in . Since invocation of the Objectifier  method triggers the object-oriented process, the C++ GUI  callback code need not include Java object calls or RMIs .",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 2","FIG. 2"],"i":["b ","b"],"b":["40","43","43","40","40","46","40","46"]},"In the embodiment shown in , the C++ GUI  callbacks execute the C++ proxy object  methods corresponding to the desired Objectifier  methods, and the C++ proxy object  in turn executes the JNI API calls necessary to invoke the desired Objectifier  methods. Consequently, the JNI API calls are transparent to the C++ GUIs  and the C++ GUI  callback code is not cluttered with coding necessary for the JNI API calls. In the methods and sequence diagrams discussed below, the Objectifier  method invocations may be made by executed C++ GUI  callback code or by the C++ proxy object  shown in ","Some of the objects and classes discussed herein are named with a prefix \u201cmx\u201d. The mx prefix is indicative of the application utilizing the objects and classes (e.g., the SCM ) and is merely exemplary. Indeed, the names of classes, objects and methods discussed herein are exemplary, are not intended to be limiting, and are merely used for ease of discussion.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3","b":["60","60","61","40","62","64","66","68"]},"Starting a GUI  preferably comprises a C++ GUI  being started-up so that a user may enter commands through the C++ GUI . For example, the C++ GUI  may be run on a workstation so that the user may access the system  and the functionality of the SCM . When the C++ GUI  is started, it is preferably displayed to the user on a display so that the user may interact with the C++ GUI , making selections and entering commands with an input device such as a mouse or a keyboard.","Initializing the mapping layer  preferably comprises instantiating the Objectifier class so that an instance of the Objectifier  object is present in the JVM  with which the C++ GUI  interacts. A C++ GUI  may initialize the mapping layer  early during the C++ GUI  startup code sequence. A C++ GUI  startup code sequence is run when a user starts a C++ GUI  in order to access the SCM .","Executing a C++ GUI callback  preferably comprises the C++ GUI  executing callback code, in response to a command entered by a user, to issue a method call to the JVM  in which the Objectifier  has been initialized. The method call preferably comprises a requested action and invokes a mapping layer entry-point  (e.g., invokes an Objectifier  method). For example, in the system  described above, the requested action may comprise retrieving, adding, deleting or storing a user, node, node group, tool, role, authorization, determining validity of node, node group, tool or role name, determining if user, node name, etc is defined, etc. Accordingly, in the system , the executed callback may make a method call invoking, for example, Objectifier  methods such as addUser, deleteNode, modifyNodeGroup, runTool, getAuthorization, isValidToolName, etc.","The mapping layer receiving a method call through an entry-point  preferably comprises the Objectifier  receiving the C++ GUI  method call after the method call has passed through the JNI . The Objectifier  method invoked by the method call is the entry-point of the C++ GUI  method call. The Objectifier  methods preferably comprise code comprising class instantiations and\/or a RMI(s). Some Objectifier  methods may comprise code invoking local Java methods (i.e., in Java classes in the same JVM  as the Objectifier ). Accordingly, the mapping layer executing an algorithm (comprising a class instantiation and\/or a RMI) as determined by the entry-point  preferably comprises the Objectifier  executing the invoked method, which in turn executes the code associated with the executed method.","Consequently, as shown in , the mapping layer executing an algorithm associated with the entry-point  may comprise instantiating a class (i.e., Java object  creation) , invoking a local Java method  and\/or making an RMI . If the C++ GUI  requires data to be returned (e.g., the executed callback requires a list of nodes to be displayed to the user for selection), executing an algorithm associated with the entry-point  further comprises returning data to the C++ process space .","Returning data to the C++ process space  may comprise returning a pointer to, or the actual value of, data such as an Integer, Long, String, Boolean, etc. that provides a value requested by the C++ GUI  method call. For example, if the C++ GUI  method call asks for a list of nodes, Node Name Strings may be returned. Returning data to the C++ process space , however, may also comprise returning a Java object  to the C++ process space . Returning a Java object  to the C++ process space  may comprise passing the Java object  name and instance data (i.e., data that describes the Java object ) so that the Java object  can be proxied in the C++ process space . Exemplary execution of steps - is illustrated in , described below. As shown in , step , step , step  and step  may be repeated if the method's algorithm requires a plurality of class instantiations, Java method calls and\/or RMIs.","As noted above, the Objectifier  is coded with the entry-points  (i.e., methods) and corresponding methods as necessary to consolidate the class instantiations, Java method calls, and RMIs for performing the actions that may be requested by executed C++ GUI  callbacks. Consequently, the Objectifier  may be customized according to the system in which it is utilized. In a system different from the computer system  shown in , different methods may be required in the Objectifier . The methods in the Objectifier  may be modified or removed, and new methods may be added, as required.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4","FIG. 4","FIGS. 2"],"b":["80","40","10","1","40","12","80","82","84","401","2"],"i":["a ","b"]},"The Objectifier data  may include, for example, various data that the Objectifier  and external sources (e.g., CLIs and GUIs) may utilize when the Objectifier  is running. For example, the Objectifier data  may include a variable (e.g., ourCurrentlyExecutingUserName) in which the Objectifier  saves the current OS user login name so that the Objectifier  can service requests from, for example, the GUI that require knowledge of the currently logged in OS user. The Objectifier data  may include a variable (e.g., ourObjectifierInitializedFlag) that contains data (e.g., true or false) that indicates whether the Objectifier  is initialized. This variable is preferably set to false during class loading and to true when, for example, the GUI calls the initObjectifier method.","Moreover, the Objectifier data  may include an Objectifier  tracer name (e.g., TRACER_NAME) for which an external CLI can query a base tracer object to modify the Objectifier's tracing level (i.e., the level of monitoring of the Objectifier  for exceptions, etc.). Additionally, the Objectifier data  may include a variable (e.g., DEBUG) that identifies an object used by the Objectifier  to log debug output to the Objectifier  trace file. The Objectifier  trace file name may be contained in another variable (e.g., OBJECTIFIER_DEBUG_FILENAME) that may be included in the Objectifier data .","Further, the Objectifier data  may include a variable (e.g., MxSessionManagerIfc ourSMIfc) that identifies a Session Manager interface object. When the Objectifer  needs to access a SCM  domain manager, the Objectifier  preferably queries the Session Manager interface object for a particular interface for the SCM  domain manager. Likewise, the Objectifier data  may include a cached version (e.g., ourMxProps) of a SCM  properties file from which to obtain IP port numbers, service names, debug flag values, etc.","The entry-points  comprise methods that may be invoked by an executed C++ GUI  callback or by the C++ proxy object . The entry-points  are shown in the following format: +method name (parameter, if any): returned data. For example, +addUser(MxUser userObject):void is a method with the method name addUser, the parameter MxUser userObject, which requires that an addUser invocation include the name of the MxUser object  that is to be added, and a returned data \u201cvoid\u201d (i.e., no data is returned to the C++ process space ). Likewise, +getTool( ): MxTool is a method named getTool with no parameters, and a MxTool Java object  as the returned data (i.e., the MxTool Java object  instance data will be passed to the C++ process space  so that the MxTool Java object  may be proxied in the C++ process space ).","For certain accessor methods (e.g., getTool( )), if a parameter value is absent, the invoked accessor method will return an empty object (e.g., an empty tool object). Such a method invocation is made, for example, in order to create a new tool, user, node, node group or role object. If a parameter value is present (e.g., getTool(String toolName)), the invoked accessor method will return a specific object indicated by the parameter value (e.g., a specific tool indicated by toolName).","Accordingly, a C++ GUI  in the computer system  may issue method calls (e.g., by executing a callback) corresponding to any of the entry-points  shown in the static structure diagram . In order to successfully enter an entry-point  of the embodiment of the Objectifier  shown, the C++ GUI  method call includes one of the method names and associated parameters (if any) shown. When the embodiment of the Objectifier  receives one of the method names and associated parameters (if any) shown in , the Objectifier  executes an algorithm (i.e., code) associated with the method identified by the received method name.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 5"],"b":["100","40","4","12","12","42","40","84","42"]},"The sequence diagram  includes boxes representing the C++ GUI  (or, alternatively the C++ proxy object ), the Objectifier , and a series of implementation and utility Java classes . Time-lines  descend from each of these boxes, representing the continuous running of the C++ GUI , Objectifier  and the Java classes . The Java classes  include an implementation class MxOS (a Java object instantiated in the JVM  for accessing operating system data), remote utility classes NodeManager, UserManager, RoleManager and SecurityManager (object managers  housed in a domain manager and present in remote JVMs \u2032 and accessible with RMI), and MxUser and MxAuthorization implementation classes (first-class Java objects  instantiated in the JVM ).","The sequence diagram  also includes method call-lines  representing Objectifier  methods invoked (with necessary JNI API calls to access the Objectifier  via the JNI  boundary) by executed C++ GUI  callbacks (or, alternatively, by the C++ proxy object  in response invocations by executed C++ GUI  callbacks) and utility and implementation class methods and RMIs invoked by the Objectifier . The relative vertical position of the method call lines  indicates the sequential order in which the Objectifier  or utility and implementation class  methods are invoked; the sequence starts at the top and moves to the bottom of the sequence diagram . Note that \u201cnames\u201d (e.g., user names, node names, etc.) are generally id numbers (id#s) mapped to name strings; the C++ GUI  preferably displays the name strings to the user while the classes use the id#s to identify the Java objects  associated with the \u201cnames\u201d.","As seen in , the first method call-line  represents the invocation of an Objectifier method initObjectifier( ). The initObjectifier( ) method initializes an instance of the Objectifier  in the JVM  with which the C++ GUI  interacts. Preferably, the initObjectifier( ) method is invoked during the C++ GUI  startup code sequence. Indeed, the first four method call-lines  issuing from box representing the C++ GUI , including the initObjectifier( ) method call-line , represent Objectifer  methods preferably invoked during the C++ GUI  startup code sequence.","When initialized, the Objectifier  retrieves, from the operating system (\u201cOS\u201d), the login name (i.e., the userid#) of the user currently using the C++ GUI  to interact with the SCM . This retrieval is represented by a getCurrentLoginName( ) method call-line . The implementation class MxOS  is an implementation class instantiated in the JVM  to facilitate accessing data from the OS. As such, the Objectifier  invokes the MxOS method getCurrentLoginName( ) to retrieve the name of the current user.","A getCurrentUser( ) method call-line  illustrates the C++ GUI  invocation of an Objectifier  method to retrieve the userid # of the current user. A isOSUser( ) method call-line  illustrates the C++ GUI  invocation of an Objectifier  method that determines whether the current user is a registered OS user. If the current user is not a registered OS user, the getCurrentLoginName( ) invoked above will not return a name for the current user and the isOSUser( ) method will return a boolean false. If the isOSUser( ) returns a false, the C++ GUI  will display an error message to the current user and will not continue with the","If the isOSUser( ) returns a true, the process continues. A getUser( ) method call-line  illustrates the invocation of an Objectifier method that returns instance data of a Java user object  (e.g., a MxUser object ) that represents a SCM  user. Here, the getUser( ) method is invoked with the name of the current user. Consequently, if the current user is a SCM  user, the getUser( ) method will return the instance data of the MxUser object  that represents the current user to the C++ process space .","As shown by the read( ) method call-line , the code associated with the getUser( ) method causes the Objectifier  to invoke a UserManager utility class  read( ) method via a RMI, since the UserManager utility class  is in a remote JVM. If the current user is a SCM  user, a populated MxUser object  will already exist for the current user and the UserManager is accessed to retrieve this MxUser object . Accordingly, the read( ) method will return the instance data of the current user's MxUser object . If the current user is not a SCM  user, a MxUser object  will not exist for the current user and the read( ) method (as well as the getUser( ) method above) will generate an exception caught by the Objectifier . If no instance data is returned or if the attributes of the current user's MxUser object  show that the current user is not authorized to add new users (e.g., the current user does not have the SCM privilege (SCM privileges control access to the structure of the SCM itself) that allows adding of SCM  users), the process shown  in  will not continue and an appropriate error message will be displayed by the C++ GUI .","The four methods described above are preferably invoked by the C++ GUI  startup process code. In other words, when a user starts a C++ GUI  in order to access and perform a task (e.g., add a SCM  user) in the SCM , the C++ GUI  initializes the Objectifier , gets the current user's userid#, determines if the current user is a registered OS user, and gets the current user's MxUser Java object  to determine whether the current user is an SCM  user and whether the current user has the SCM privilege to perform the task (e.g., add a SCM  user) on the SCM . If the current user is so privileged, the C++ GUI  will continue to execute callbacks in order to facilitate performance of the task.","Accordingly, the C++ GUI  will prompt the current user to enter the name of the new SCM  user that the current user wants to add. In response to the entered name, the C++ GUI  preferably executes a callback to determine whether the entered name is an existing SCM  user. The executed C++ GUI  callback in turn invokes an Objectifier  method to determine whether the entered name is a defined SCM user name, as shown by the isDefinedUser( ) method call-line  in FIG. . As with all the C++ GUI  method invocations shown in FIG.  and discussed herein, alternatively, the executed callback may invoke a C++ proxy object  method that would in turn invoke the Objectifier  method shown (i.e., isDefinedUser( )) and the necessary JNI API call.","Since the User Manager utility class  (e.g., MxUserManager) maintains the MxUser Java objects  for existing SCM  users, the code associated with the isDefinedUser( ) method invokes a User Manager method (shown by the isNameDefined( ) method call-line ) to determine if the entered name is associated with an existing MxUser object . The isNameDefined( ) method preferably returns a boolean true if the entered name is associated with an existing MxUser object  and a boolean false otherwise. The isDefinedUser( ) method returns the result to the C++ process space .","If the entered name is not associated with an existing MxUser object  (i.e., the name entered in the C++ GUI  by the current user is not an existing SCM  user's name), the C++ GUI  callback invokes an Objectifier  method (shown by the getUser( ) method call-line ) to get an empty MxUser object  with which to construct a new SCM  user. The code associated with the getUser( ) method invokes a constructor method MxUser( ) on the MxUser class . The MxUser( ) method instantiates an instance of the MxUser class, creating an empty MxUser object , and returns the MxUser object  instance data to the Objectifier . The getUser( ) method returns this instance data to the C++ process space  so that it may be proxied.","Referring to , the getUserAttributes( ) method call-line  illustrates the invocation of an Objectifier  method to retrieve the new SCM  user's attributes. In order to be added as a SCM  user, the new SCM  user must be a registered OS user. As such, the getUserAttributes( ) method invokes a MxOS class  method to retrieve OS user data associated with the entered name (passed by the C++ GUI ). The OS user data may include, for example, phone numbers, email addresses and userid#s. If the entered name is a registered OS user, the getOSUserData( ) method returns OS user data associated with the entered name. If the entered name is not a registered OS user, no OS user data will be returned and the entered name will not be added as a new SCM  user.","A getNodeNames( ) method call-line  illustrates invocation of an Objectifier  method to retrieve names for nodes that the current user has selected for the new SCM  user. Preferably, the C++ GUI  presents a list of Nodes for which the current user may select to give the new SCM user  authorizations. The selected node names are passed to the Objectifier  with the getNodeNames( ) invocation. As shown by the list( ) method call-line , the code associated with the getNodeNames( ) method invokes a Node Manager method, via a RMI, to list and return the names for the selected nodes. The Node Manager class  (e.g., MxNodeManager) is a utility class that manages the objects that represent the nodes  of the SCM .","A getRoleNamesAndIDs( ) method call-line  illustrates invocation of an Objectifier  method to retrieve names and id#s for roles that may be selected for the new SCM  user. The code associated with the getRoleNamesAndIDs( ) method invokes a Role Manager method (shown by the second list( ) method in FIG. ), via a RMI, to list and return the names and id#s for the roles. The Role Manager class  (e.g., MxRoleManager) is a utility class that manages the objects that represent the roles of the SCM .","For each SCM  user, there is a user object (e.g., the MxUser object ) and zero or more Java authorization object(s)  (e.g., MxAuthorization Java objects ) that define the nodes and roles that the SCM  user is authorized to access. Accordingly, as shown in , a getAuthorization method call-line illustrates the invocation of an Objectifier  method to create a new authorization (e.g., a role and a node) for the new SCM  user. Preferably, the getAuthorization method is invoked for each authorization created for the new SCM  user (i.e., each role and node, etc.). An MxAuthorization method call-line  illustrates that the code associated with the getAuthorization method invokes a MxAuthorization constructor method on the MxAuthorization class, instantiating an instance of an empty MxAuthorization Java object . The getAuthorization method returns the instance data of the MxAuthorization Java object  to the C++ process space  so that the MxAuthorization Java object  may be proxied.","An addUser( ) method call-line  illustrates the invocation of an Objectifier  method to add the new SCM  user to the User Manager. Instance data for the MxUser object , and user data, such as the new SCM  user's OS user data retrieved above and the userid of the current user, and the identifiers of the authorizations created above, are passed with the addUser( ) method invocation to fill-in the new, empty MxUser object , which was created as described above. Preferably, the C++ GUI  fills in an empty MxUser object  (e.g., by invoking mutator methods via the C++ proxy), with this instance data, user data and the identifiers, and passes a reference to the Java object to the Objectifier  with the addUser( ) invocation. Consequently, the Objectifier  invokes the User Manager add( ) method, via a RMI, to add the filled-in MxUser object  to the User Manager.","As shown in , the saveAuthorizations( ) method call-line  illustrate the invocation of an Objectifier  method, and in turn, a Security Manager method, via a RMI, to save the filled-in MxAuthorization Java objects  created above for each authorization of the new SCM  user. The instance data of the filled-in MxAuthorization Java objects  and the data identifying the authorizations selected are passed with the saveAuthorizations( ) method invocations. The Security Manager (e.g., MxSecurityManager) maintains the MxAuthorization Java objects .","Other processes utilizing the embodiment of the Objectifier  shown in  operate similarly to the process shown in FIG. . I.e., the C++ GUI  callbacks are coded with procedural code for a step-by-step process to add, delete, store, etc. a user, node, role, etc. by invoking Objectifier  methods (directly or through the C++ proxy object ) that execute the Java object creation and RMIs necessary to complete the process in object-oriented Java.","According to this same principal of operation,  depicts another sequence diagram  illustrating an exemplary process utilizing the embodiment of the Objectifier  shown in FIG. . The process shown by  is for adding a new node  to the SCM . The sequence diagram  includes boxes representing the C++ GUI  (or, alternatively the C++ proxy object ), the Objectifier , and a series of implementation and utility Java classes . Some of the method invocations, such as most of the methods discussed above that are invoked during the C++ GUI  startup code process, are omitted from the sequence diagram  of FIG. . Repetitive method invocations, such as initObjectifier( ) and getCurrentUser( ), are not discussed again.","The sequence diagram  in  includes method invocations that may not be invoked every time a new node  is added. For example, the a new node  may be added by invoking getNode( ), isValidNodeName( ), isDefinedNodeName( ) and addNode( ) Objectifier  methods described below. Likewise, if a user creating a new node  wishes to add the node to a node group , getNodeGroupNames( ) and ModifyNodeGroup( ) Objectifier  methods described below may also be invoked. As with , \u201cnames\u201d (e.g., user names, node names, etc.) are generally id numbers (id#s) mapped to name strings; the C++ GUI  preferably displays the name strings to the user while the classes use the id#s to identify the Java objects  associated with the \u201cnames\u201d.","A getNode( ) method call-line  illustrates the invocation of an Objectifier  method that returns an instance of a Java node object  (e.g., a MxNode Java object ) that represents a node . The code associated with the getNode( ) method invokes a constructor method MxNode( ) of the MxNode class . The MxNode( ) method instantiates an instance of the MxNode class, creating an empty MxNode object , and returns the MxNode object  instance data to the Objectifier . The getNode( ) method returns this object to the C++ process space  so that it may be proxied.","An isValidNodeName( ) method call-line  illustrates the invocation of an Objectifier  method to determine if a name, entered by the current user of the C++ GUI , is a valid name for a node . Preferably, the SCM  has certain syntax rules for valid node  names that need to be satisfied. A node  name is preferably represented by a Java node name object  (e.g., a MxNodeName Java object ). As seen by a MxNodeName( ) method call-line, the Objectifier  attempts to determine if the entered name is a valid node  name by invoking a MxNodeName implementation class  constructor method to create a MxNodeName object  with the entered name. The Objectifier  passes the entered name with the MxNodeName( ) invocation and if the entered name is a valid node  name, the MxNodeName implementation class  creates a MxNodeName object  with the entered name. If the MxNodeName object  is created, a Boolean true is returned to the C++ process space . Otherwise, the C++ GUI  preferably displays an error message to the current user and the process ends until a valid node  name is entered.","An isDefinedNodeName( ) method call-line  illustrates the invocation of an Objectifier  method that determines whether a node  already exists. This method may be invoked after the entered name has been determined to be valid, as described above. A name is passed to the Objectifier  with the isDefinedNodeName( ) method invocation. Since the Node Manager utility class  maintains existing MxNode objects , the Objectifier  invokes a Node Manager method, via a RMI, to determine if a MxNode object  with the same name already exists. This Node Manager method invocation is shown by the isDefined( ) method call-line . The isDefined( ) method returns a boolean true or false, which is in turn, passed to the C++ process space  by the isDefinedNodeName( ) Objectifier  method.","A getNodeNames( ) method call-line , seen in , illustrates the invocation of an Objectifier  method to return certain node  names (e.g., a list of all node  names). Associated with the getNodeNames( ) method is code that invokes a Node Manager method, via a RMI, that retrieves a list of specified node  names from the Node Manager utility class . The C++ GUI  may execute callback code to get certain node  names if, for example, the current user indicated that he\/she wants to create a new node group  with the new node  and existing nodes . Instance data describing the MxNodeName object(s)  for the listed node(s)  is preferably returned to the C++ process space .","A getNodeGroupNames( ) method call-line  illustrates the invocation of a similar Objectifier  method to return certain node group  names (e.g., a list of all node group  names). The getNodeGroupNames( ) method functions similarly to the getNodeNames( ) method, only a Node Group Manager utility class  (e.g., a MxNodeGroupManager) method is invoked, via a RMI, to retrieve a list of specified node group  names. The C++ GUI  may execute callback code to get certain node group  names if, for example, the current user indicated that he\/she wants to add the new node  to an existing node group . Instance data describing the MxNodeGroupName object(s)  for the listed nodes group(s)  is preferably returned to the C++ process space .","A getUserNames( ) method call-line , shown in , illustrates the invocation of a Objectifier  method to return certain user names (e.g., a list of all SCM  user names). The getUserNames( ) method functions similarly to the getNodeNames( ) method and getNodeGroupNames( ) method described above, only a User Manager utility class  method is invoked, via a RMI, to retrieve a list of specified SCM  user names. The C++ GUI  may execute callback code to get certain SCM  user names if, for example, the current user indicated that he\/she wants to enable certain users to access the new node . Instance data describing the MxUserName object(s)  for the listed SCM  users is preferably returned to the C++ process space .","A getRoleNamesAndIDs( ) method call-line  illustrates invocation of an Objectifier  method to retrieve names for roles that may be selected as authorized to be utilized on the new node . As discussed above with reference to , the code associated with the getRoleNamesAndIDs( ) method invokes a Role Manager method, via a RMI, to list and return the names for the roles. The read( ) method call-line illustrates that the Objectifier  loops to get the MxRole objects from which it extracts the id#s for the SCM  roles. The C++ GUI  may execute callback code to get certain SCM  role names and ids if, for example, the current user indicated that he\/she wants to enable certain roles to be utilized on the new node . Preferably, the C++ GUI  uses displays the role names to the user and uses the role ids (and userids, node ids and node group ids) to build the authorization objects.","An addNode( ) method call-line  illustrates invocation of an Objectifier  method to store the new node  with the Node Manager utility class . Instance data for the MxNode object , and node data, such as instance data of the MxNodeName object  created as described above and the creating user's userid in a createdBy field of the MxNode object , are passed to the Objectifier  with the addNode( ) method invocation which was created as described above. Consequently, the Objectifier  invokes the Node Manager add( ) method, via a RMI, to add the filled-in MxNode object  to the Node Manager. Subsequently, the new node  may be accessed by accessing the new filled-in MxNode object  from the Node Manager.","A getNodeGroup( ) method call-line  illustrates invocation of an Objectifier  method to create a new node group . As seen in , associated with this method is a constructor method MxNodeGroup that the Objectifier  invokes in the MxNodeGroup implementation class . This constructor method instantiates an empty instance of an MxNodeGroup object  and passes the empty MxNodeGroup object  to the Objectifier . The Objectifier  passes this empty object to the C++ process space  so that the new MxNodeGroup object  may be proxied. If the current user decides to create a new node group , the MxNodeGroup object  is filled in via a C++ proxy with data identifying the nodes  in the new node group . Subsequently, a reference to the MxNodeGroup object  may be passed through an Objectifier  addNodeGroup( ) method invocation (not shown) and stored with the Node Group Manager utility class .","A modifyNodeGroup( ) method call-line  illustrates invocation of an Objectifier  method to modify an existing node group . The associated code in turn invokes a Node Group Manager utility class  method to add the new node  to an existing node group  (shown, in , by the modify( ) method call-line ). Data identifying the new node  (e.g., the new node  name) and the node group  being modified (e.g., the node group  name) is preferably passed to the Node Group Manager.","A getAuthorization( ) method call-line  illustrates invocation of an Objectifier  method to create a new authorization (e.g., if the current user authorized a certain SCM  role to be utilized on or certain SCM  users to access the new node ). As noted above with regard to , this method may be repeated for each new authorization to be created. The associated code in turn invokes a MxAuthorization constructor method on the MxAuthorization implementation class , instantiating an instance of an empty MxAuthorization Java object . The getAuthorization( ) method returns the instance of the MxAuthorization Java object  to the C++ process space  so that the MxAuthorization Java object  may be proxied.","The last method call-line  in the sequence diagram  shown in , a saveAuthorizations( ) method call-line  illustrates the (repeated, if necessary) invocation of an Objectifier  method, and in turn, a Security Manager method, via a RMI, to save the filled-in MxAuthorization objects  for each new authorization created. The instance data of the filled-in MxAuthorization Java objects  and the data identifying the authorizations selected are passed with the saveAuthorizations( ) method invocations.","As illustrated by the exemplary sequence diagrams ,  in , the Objectifier  is a component of the SCM  software that acts as a layer between the C++ process space  and the method invocations and RMIs necessary in the object-oriented JVM . As shown, the Objectifier  consolidates the Java object  creations and RMIs that are used to conduct a process in Java. The Objectifier  maps the procedural C++ code of the C++ GUI  callbacks to the Java object-oriented utility and implementation classes.","While the invention has been described with reference to the exemplary embodiments thereof, those skilled in the art will be able to make various modifications to the described embodiments of the invention without departing from the true spirit and scope of the invention. The terms and descriptions used herein are set forth by way of illustration only and are not meant as limitations. Those skilled in the art will recognize that these and other variations are possible within the spirit and scope of the invention as defined in the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 2","i":["a ","b "],"b":"2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
