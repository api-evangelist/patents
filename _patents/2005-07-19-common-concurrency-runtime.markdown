---
title: Common concurrency runtime
abstract: The common concurrency runtime (CCR) provides a simple and self-consistent set of concurrency primitives that developers can use to more readily split their computation into more discrete chunks that can scale better with additional processors. This set of primitives provides for very scalable applications that are well suited for the coming world of ubiquitous communication and very large scale out for the number of local processors. The CCR may be implemented as a single library in C# that implements channels with input and asynchronous output capabilities, along with an atomic test-and-input primitive. On top of this, richer derived operators (e.g., choice, join, replication, reader-writers, scatter-gather, etc.) may be encoded. Thus, existing C# may be built upon to provide the capability to concurrently issue I/O requests to remote systems while simultaneously performing other functions locally to increase the efficiency of the distributed system. Because it is based on C#, the CCR allows users to take advantage of a well-known programming model to address unique issues in a new programming environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774750&OS=07774750&RS=07774750
owner: Microsoft Corporation
number: 07774750
owner_city: Redmond
owner_country: US
publication_date: 20050719
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["A known problem in computer science involves effective programmability around concurrency. Existing programming paradigms involve such things as threads, mutexes, semaphores, critical sections, and other primitives. Though these have been around for decades, they are hard to use properly without inducing hard-to-find timing bugs, or inadvertently serializing access through code sections via improper locking hierarchies.","Though this has been an issue in the past, developers typically did not worry about it because they could count on their purely sequential code automatically running faster due to ever increasing CPU clock rates. This is changing, however, now that clock rates have hit the thermal barrier and CPU vendors are moving toward multi-core designs. This means that for a software developer to make their code run faster, they will need to split the work into multiple concurrent sections that can run across 2, 4, 32, 64, or even hundreds of local processors in a single machine. This is difficult to do with threads.","Additionally, there are latencies in distributed operating systems. For example, if a user issues a read request from their local disk using traditional local architectures, they are assured to get data back within a few milliseconds. But if the user does the same thing over a network to a remote machine, it may take seconds or minutes or forever to return the data. A new language called C-Omega has been developed and provides an alternative to threading for dealing with local concurrent programming. C-Omega, however, requires an entirely new language, infrastructure and toolchain (debuggers, etc.). Also C-omega takes a declarative approach, where any programming primitives are fixed at compile time and cannot be modified or adjusted based on runtime information. It would be desirable, therefore, if a mechanism were available to address the problem of concurrency and coordination in a concurrent and potentially distributed operating system, without the need for a new language.","The common concurrency runtime (CCR) provides a simple and self-consistent set of concurrency primitives that developers can use to more readily split their computation into more discrete chunks and coordinate results in a concise manner so that the applications can scale better with additional processors and the complexity of software can be kept small relative to programming with threads. This set of primitives provides for very scalable applications that are well suited for the coming world of ubiquitous communication and very large scale-out for the number of local processors.","The CCR may be implemented as a single coordination\/concurrency library in C# that implements channels with input and asynchronous output capabilities, along with an atomic test-and-input primitive. On top of this, richer derived operators (e.g., choice, join, replication, reader-writers, scatter-gather, etc.) may be encoded. Thus, the invention may build upon the existing C# to provide the capability to concurrently issue I\/O requests to concurrent processes while simultaneously performing other functions locally to increase the efficiency of the system. Because it is based on C#, it allows users to take advantage of a well-known programming model to address unique issues in a new programming environment.","The invention provides an implementation of a type safe queue and collection of queues that may be referred to as channels or ports. These ports have First-In-First-Out semantics and are similar to the channels described in many process algebras. They have input and asynchronous output capabilities, and atomic test-and-input primitives. The port architecture allows a lock-free, flexible implementation of message coordination primitives like choice, join, replication, and other higher level operators. Higher levels of abstraction can be built using a small number of primitives. Any number of other concurrent languages including C-Omega, Join-Java, etc., could compile down to the ports and the basic coordination primitives. The scheduling model in particular allows an efficient and simple way to interface with legacy systems, where threading and thread affinity has to be taken into consideration.","All interaction is through the core interaction primitive\u2014i.e., a port. Receivers may be \u201cattached,\u201d i.e., waiting on a port, and messages may be posted. When a message arrives, code executes with the message as a parameter. In a preferred embodiment, everything is asynchronous. The CCR may include a hierarchical arbitration procedure, and arbiters may be nested. Coordination primitives can be nested, and a coordination primitive may, itself, be executed as another work unit. Thus, the invention provides an extensible messaging system with defined coordination primitives. A scheduler, or dispatcher, may be provided to take the union of messages with receivers and activate them. The dispatcher may be decoupled from the port and arbiter implementations.","According to an aspect of the invention, everything may be treated as a task. Because one can determine how long it takes to run a task, one can throttle down the CPU time used according to a desired formula. Such throttling may be based on simple feedback control to effectively control runtime CPU usage.","Thus, the invention provides an extensible coordination and concurrency library that can be embedded in existing languages and be targeted by new languages.","Example Computing Environment",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an application programming interface (API), for use by a developer or tester, and\/or included within the network browsing software which will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers (e.g., client workstations, servers, or other devices). Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. An embodiment of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an example system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, random access memory (RAM), read-only memory (ROM), Electrically-Erasable Programmable Read-Only Memory (EEPROM), flash memory or other memory technology, compact disc read-only memory (CDROM), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, radio frequency (RF), infrared, and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as ROM  and RAM . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data . RAM  may contain other data and\/or program modules.","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the example operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit -through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB).","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to monitor , computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","One of ordinary skill in the art can appreciate that a computer  or other client devices can be deployed as part of a computer network. In this regard, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. The present invention may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.","Common Concurrency Runtime","Common Concurrency Runtime (CCR) may be implemented as a C# library for concurrency. At its core are pi-like channels with input and asynchronous output primitives, along with an atomic test-and-input primitive. On top of this, richer, derived operators (e.g., choice, join, replication, readers-writers) may be implemented.","A CCR application running on a machine may include:\n\n","An application is created by running it from the command line. It creates dispatchers, which in turn create their scheduler-threads. Each scheduler-thread proceeds picking up a task and executing it. This execution may create new ports, or add messages to ports (thus triggering the execution of arbiters), or create arbiters or tasks in the current dispatcher.","Messages are asynchronous, but order-respecting. The CCR is asynchronous in the sense that when a task posts a message it continues immediately rather than waiting for the message to be received. Patterns that may be used include state-as-message and scatter-gather. In state-as-message, the state of a process is represented as an asynchronous message to an internal port. In scatter-gather, a dynamically-determined number of \u201cwork units\u201d are created to do some tasks in parallel. Then a join\/select command waits until they have all finished or one has generated an error. The dynamic, variable nature of the choice and join primitive is a feature of this invention not found in C-omega, join java, or other similar efforts.","A \u201cwork unit\u201d is a linear sequence of commands. The commands are to (1) create a new port, (2) create a new task (delegate) and append it to the dispatcher's list of tasks, (3) post a message to a port, (4) create a new arbiter and register it on the ports it wants to watch.","Rather than registering it immediately on its ports, a new task may be created which will do the registering later, e.g., when it comes to be executed. An \u201cactivate\u201d may be used for creating this task and appending it to the dispatcher's list. To append a task to the dispatcher's task-list, the dispatcher may manage its own port, and an \u201cappend-task\u201d message may be posted to the dispatcher. It should be understood that a language may be developed in which a work unit consisted solely of message-postings: to create a new port, it posts a message to the new port-creating service that is expected to be present, and so on.","The \u201cNew\u201d command allocates a fresh port. The port is indexed by the types it can carry. Within C# programming of the CCR, it is a compile-time error to post an invalid type, or to activate a handler which waits for an invalid type. An example New command is:\n\n",{"@attributes":{"id":"p-0034","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"spawn<int>(5, delegate(int i){...} )."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Instance Method:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"spawn<int>(5,MyIntHandler);"]},{"entry":[{},"void MyIntHandler (int i) { ... }."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The \u201cPost\u201d command posts an asynchronous message. Messages are ordered in CCR. It is a compile-time error to post a message that has the wrong type for the port. An example Post command is:\n\n","Arbiter: Simple Input. Following are two syntaxes for input. The first uses a delegate, so as to write the continuation inline. The second uses a static method, or can use an instance method.\n\n",{"@attributes":{"id":"p-0037","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"activate(p.with(delegate(int i){P1})); P2."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"With method [static or not]:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"activate(p.with(MyIntHandler)); P2"]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"[static] void MyIntHandler(int i) {P1}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(p(i).P) | P."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The activate command creates a task and p.with creates an arbiter. When the task is scheduled, it registers the arbiter on port p. When a message eventually arrives, it executes the arbiter (thus, unregistering the arbiter). The arbiter is a simple one that merely creates a task for subsequent scheduling. When this next task is scheduled, it attempts an atomic test-and-remove operation on the port. If successful, it executes the delegate (first case) or static method (second case). If unsuccessful, the arbiter is re-registered to watch for subsequent messages.","A two-phase form of message reception may be employed. In the first phase, the arbiter watches enough messages arrive until it thinks its continuation may be able to run. In the second phase, an attempt is made to get the necessary message atomically before running the continuation. This two-phase technique becomes more useful with more complicated arbiters, particularly for join and choice.","Arbiter: Choice. Following is an example that uses a choice arbiter.\n\n",{"@attributes":{"id":"p-0041","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"p.with(MyIntHandler)"]},{"entry":[{},"| timeoutport(new Timespan(1000)).with(MyTimeoutHandler)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"); P1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(p(i).IntHandler + p( ).MyTimeoutHandler)|P"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"sub":["i ","to"]},"The following synchronous version of choice waits until the handler has finished executing before it continues:",{"@attributes":{"id":"p-0043","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"select("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"p.with(MyIntHandler)"]},{"entry":[{},"| timeoutport(new Timespan(1000)).with(MyTimeoutHandler)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"); P2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"p(i).(IntHandler; P) + p( ).(MyTimeoutHandler; P)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Arbiter: Join. In CCR, \u201cjoin\u201d is a multi-way version of the pi calculus input command. An example join is:",{"@attributes":{"id":"p-0045","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"activate("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"join<int, string>(p, p).with(MyIntAndStringHandler)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"); P"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(p(i) {circumflex over (\u2009)}p(s).MyIntAndStringHandler) | P."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"sub":["i ","s","i ","s"]},"Note that there are many arbiters looking on the same channels. So, when pand phave arrived, they may schedule continuations in many different dispatchers. Every one of these continuations will attempt to test-and-remove in alphabetical order. Exactly one of the continuations will succeed, and the others will restart their waiting. Therefore, this encoding of join is divergent locally but not globally. Compare this to the encoding of join into pi (which is divergent). The different in expressivity is due to CCR having test-and-remove and alphabetical orderings on ports. Pi-calculus, for example, cannot express these.","The CCR's two-phase implementation of joins (first waking up arbiters, then doing test-and-remove) is more practical than the finite state automata technique used in Join Calculus. That is because it allows extra joins to be added at runtime without recompiling the machine, and the size of the join automata increase non-linearly with number of inputs.","The following is an example of a \u201cdynamic join.\u201d",{"@attributes":{"id":"p-0049","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Port<int,string> p;"]},{"entry":[{},"\/\/ suppose some service will either post N integer messages"]},{"entry":[{},"to p (denoting success of"]},{"entry":[{},"\/\/ each of N sub-services), or at least one string message"]},{"entry":[{},"to p (denoting failure). Then"]},{"entry":[{},"activate("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"joinvariable<int>(p, N, delegate(int[] oks) {...})"]},{"entry":[{},"| p.with(delegate(string failmsg) {...})"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},")."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This dynamic join can be implemented in a conventional process calculus that has no dynamic joins. For example, one could write a multi-way join service that does a 1-way join if the list had one element, a 2-way join if it had two elements, and so on, up to some bound. Such a multi-way join service should be adequate for modeling dynamic joins in many situations.","As the number of messages that are to be sent is unknown at compile time, joinvariable(single port, many messages) and joinarray (many ports, one message each) provide a concise way to gather any number of messages known only at runtime.","Arbiter: replication. The following is an example of a replication arbiter.\n\n","The way CCR makes use of parallelism in the hardware is that it uses one or more scheduler-threads per CPU for executing work units. More concurrency can be provided with an advanced primitive known as an \u201cinterleave.\u201d An example interleave may be:",{"@attributes":{"id":"p-0054","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"activate("]},{"entry":[{},"\u2003\u2003exclusive(p.with(DoneHandler), !p.with(UpdateState))"]},{"entry":[{},"\u2003\u2003{circumflex over (\u2009)}"]},{"entry":[{},"\u2003\u2003concurrent(!p.with(GetState), !p.with(QueryState))"]},{"entry":[{},")."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"At runtime, all APIs create Tasks which can be scheduled by a dispatcher. A resource manager allocates dispatchers, which can all be ion the same resource group. Multiple front-end queues may share \u201cTaskExecutionWorker\u201d threads, which load-balance tasks. Queues are just ports. The ability to associate a dispatcher per task\/arbiter leads to easy interoperability for STA-threaded legacy code, and provides flexibility to the programmer.","\u201cIterators\u201d allow people to write sequential, non blocking code, which may greatly increase readability. The iterator pattern from C# 2.0 may be used according to the invention in a novel way. Loops, for example, now become easy again even if they involve asynchronous messaging. A point of novelty is that since the CCR runtime operates on tasks, user code may be turned into iterators over tasks. That is, they can yield to a choice arbiter, join, etc., because it runs a task to be scheduled. That will eventually make progress and allow the scheduler to \u201citerate\u201d over to the next logical block in the user's code.","Examples of iterators follow:",{"@attributes":{"id":"p-0058","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IEnumerator<ITask> Iterator(int num)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003Port<int,string> p = new Port<int,string>( );"},{"entry":"\u2003\u2003for (int i = 0; i < num; i++)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003p.post(i);"},{"entry":"\u2003\u2003\u2003\/\/ we yield below, when the i\/o arrives on port p, we will execute"},{"entry":"\u2003\u2003\u2003\/\/ the inside of the delegate and call Trigger( )."},{"entry":"\u2003\u2003\u2003\/\/ Then the loop will continue just like in normal C\/C#"},{"entry":"\u2003\u2003\u2003synchronous code."},{"entry":"\u2003\u2003\u2003\/\/ All this without blocking a thread."},{"entry":"\u2003\u2003\u2003yield return p.with(delegate(int j)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Trigger( );"},{"entry":"\u2003\u2003\u2003});"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003IEnumerator<ITask> IteratorOnJoin(int num)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003_pTest = new Port<string, int, float>( );"},{"entry":"\u2003\u2003for (int i = 0; i < num; i++)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003_pTest.post(i);"},{"entry":"\u2003\u2003\u2003_pTest.post(i.ToString( ));"},{"entry":"\u2003\u2003\u2003\/\/ when the join is satisfied, the loop will continue"},{"entry":"\u2003\u2003\u2003yield return join<int, string>(_pTest, _pTest).with(delegate(int j,"},{"entry":"\u2003\u2003\u2003string s)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Trigger( );"},{"entry":"\u2003\u2003\u2003});"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"IEnumerator<ITask> IteratorOnChoiceAndJoin(int num)"},{"entry":"{"},{"entry":"\u2003_pTest = new Port<string, int, float>( );"},{"entry":"\u2003for (int i = 0; i < num; i++)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003_pTest.post(i);"},{"entry":"\u2003\u2003_pTest.post(i.ToString( ));"},{"entry":"\u2003\u2003\/\/ another interesting use of the iterator. When either branch of the"},{"entry":"\u2003\u2003\/\/ choice fires, then the loop continues"},{"entry":"\u2003\u2003yield return"},{"entry":"\u2003\u2003\u2003(_pTest.with(delegate (float f) { })"},{"entry":"\u2003\u2003\u2003|"},{"entry":"\u2003\u2003\u2003join<int, string>(_pTest, _pTest).with(delegate(int j, string s)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Trigger( );"},{"entry":"\u2003\u2003\u2003}));"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"An example programming model for concurrency and distribution is depicted in . The base layer contains the existing programming constructs from the CLR (or from any other acceptable base). This layer supports the ordinary sequential programming model used in systems today. The concurrency layer adds new local constructs for concurrency, replacing the existing Win32\/CLR constructs with new, more modern constructs that are easier to understand, easier to use, easier to check, and altogether easier to get right. The concurrency layer may be separated from the base layer to keep from making ordinary sequential programming as hard as concurrent programming. Where the CCR is implemented in a distributed environment, a distributed layer may provide new constructs for dealing with programming problems unique to distributed systems. It may incorporate a failure model, a security model, etc. The distributed layer may be separated from the concurrency layer to keep from making local programming as hard as distributed programming.","The CCR is a concurrency layer atop the CLR base layer. The Decentralized System Services (DSS) architecture may build upon the CCR to support a distributed layer. It should be understood that the CCR does not itself address problems unique to distributed systems\u2014e.g., marshalling, versioning, failure, security, etc. In particular, a program using the CCR may run on a single machine. It cannot fail in part. That is, if any part of a program fails, the entire program fails. Also, it runs in a single security domain.","A CCR program may execute in a number of asynchronous \u201cactions.\u201d Actions are similar to threads or tasks or work items in other systems. In its current implementation, the CCR sometimes uses Win32\/CLR threads internally, and CCR programs must not bypass the CCR to use Win32\/CLR threads or perform synchronization, either directly or indirectly through a library. The programmer must be careful to avoid such cases, which have no meaning.","A CCR program may have an \u201cinitial\u201d action, and any action can start \u201cnew\u201d actions. Individual actions can terminate, and the entire program terminates once all of its actions have terminated. One way to start a new action is by calling \u201cspawn,\u201d specifying a method for the new action to call, and a list of arguments. For example, a first action might call spawn as follows:","spawn<string>(LogMethod, \u201cProgram initializing\u201d);","to start a new action that calls LogMethod with the string argument \u201cProgram initializing\u201d and then terminates when the method returns. LogMethod may, for example, print the message to the console:","static MsgSuccess LogMethod(string msg) {Console.WriteLine(msg);},","so this call to spawn will log the message asynchronously while other actions proceed with program initialization. An alternative is for the programmer to use an anonymous delegate to specify the method inline:",{"@attributes":{"id":"p-0065","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"spawn<string>(delegate(string msg) { Console.WriteLine(msg); },"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cProgram initializing\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"While spawn is one way to start new actions, another way to start new threads is by sending messages to ports. As described below, the program can register certain types of actions to start when certain messages arrive at certain ports.","The CCR provides a message-passing programming model. Programs can send asynchronous \u201cmessages\u201d to \u201cports,\u201d and these messages can start new asynchronous actions. The simplest kind of port receives messages of some specified type. For example,","Port<string>log=new Port<string>( );","constructs a new port \u201clog\u201d for messages of type \u201cstring.\u201d A program calls \u201cwith\u201d and \u201cactivate\u201d to \u201cbind\u201d a method to a port and to \u201cactivate\u201d the binding:",{"@attributes":{"id":"p-0069","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"activate("]},{"entry":[{},"\u2003!log.with(delegate(string msg) { Console.WriteLine(msg); }));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Once the method is bound, posting a message to \u201clog\u201d (using \u201clog.post\u201d) will start a new action that calls the method with the message as its argument.",{"@attributes":{"id":"p-0071","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"log.post(\u201cHi!\u201d);"]},{"entry":[{},"...;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0072","num":"0090"},"figref":"FIG. 3"},"In this example, posting multiple messages to log will start multiple actions that can run concurrently. In this program:",{"@attributes":{"id":"p-0074","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"log.post(\u201cCopyright\u2009\u00a9\u20092005\u201d);"]},{"entry":[{},"log.post(\u201cAll rights reserved.\u201d);"]},{"entry":[{},"log.post(\u201cProgram initializing\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The CCR features described above can be used to start any number of new actions. Each action may be independent of all others. A join is a new kind of binding that enables actions to synchronize and communicate. It specifies a method for a new action when messages arrive at more than one port.","Consider the example of a cashbox that holds n dollars. We can deposit more dollars when we want, and we can request (i.e., ask to know) the current balance. First we define new ports \u201cdeposit,\u201d \u201cbalanceRequest,\u201d and \u201cbalance.\u201d","Port<int>deposit=new Port<int>( ): The \u201cdeposit\u201d port takes an \u201cint\u201d from the client, and its action increments the balance by the specified amount.","Port<Port<int>>balanceRequest=new Port<Port<int>>( ): The \u201cbalanceRequest\u201d port takes a continuation port (which is called a continuation port by analogy to continuations in programming languages) that takes an \u201cint,\u201d and its action returns the current balance to that port.","Port<int>balance=new Port<int>( ): The \u201cbalance\u201d port takes an \u201cint\u201d as an argument (i.e., as a message), representing the current balance. The client cannot post directly to \u201cbalance;\u201d it is internal to the implementation.","Next, we bind methods to these ports, calling \u201cjoin\u201d to construct a join binding:","activate(!join<int, int>(balance, deposit)\n\n",{"@attributes":{"id":"p-0082","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"activate(!join<int, Port<int>>(balance, balanceRequest)"]},{"entry":[{},"\u2003.with(delegate(int b, Port<int> continuation) {"]},{"entry":[{},"\u2003\u2003\u2003balance.post(b);"]},{"entry":[{},"\u2003\u2003\u2003continuation.post(b);"]},{"entry":[{},"\u2003\u2003}));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"We initialize the current balance by posting it to \u201cbalance.\u201d","balance.post(0);","The client can now deposit various amounts into the cashbox using deposit.post.","deposit.post(100);","deposit.post(50);",". . . ;","These two messages to \u201cdeposit\u201d start two new actions, each of which increments the balance by the specified amount. These two new actions cannot execute concurrently with each other, because starting each action requires a message on \u201cbalance\u201d as well as a message on \u201cdeposit.\u201d As soon as one action starts, the next message on \u201cdeposit\u201d must wait for another message on \u201cbalance.\u201d The same message cannot start more than one action. This eliminates a race condition typical in other programming models. Similarly, there is at most one \u201cint\u201d at \u201cbalance\u201d at any moment, since the old argument is consumed before the new one is posted, and since the client cannot post directly to \u201cbalance.\u201d",{"@attributes":{"id":"p-0090","num":"0109"},"figref":"FIG. 4"},"Retrieving the balance takes a little more code in the client.",{"@attributes":{"id":"p-0092","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Port<int> withBalance = new Port<int>( );"]},{"entry":[{},"activate(withBalance,"]},{"entry":[{},"\u2003delegate(int b) {"]},{"entry":[{},"\u2003\u2003log.post(String.Format(\u201cbalance = {0}\u201d, b));"]},{"entry":[{},"\u2003});"]},{"entry":[{},"balanceRequest.post(withBalance);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Consider a second example of an extended cashbox that allows withdrawals as well as deposits, but does not allow for withdrawing more money than is available. An attempted withdrawal with insufficient funds will wait until more money is deposited. New ports \u201cdeposit,\u201d \u201cwithdraw,\u201d \u201cbalance,\u201d \u201cwithdrawalWaiting,\u201d and \u201cnoWithdrawalWaiting\u201d may be defined.\n\n",{"@attributes":{"id":"p-0094","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Withdrawal {"]},{"entry":[{},"\u2003public int n;"]},{"entry":[{},"\u2003public Port<MsgSuccess> continuation;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":{"@attributes":{"id":"ul0020-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":["Port<Port<MsgSuccess>>withdraw=new Port<Withdrawal>( ).\n\nThe new \u201cwithdraw\u201d port takes a continuation port that takes a \u201cWithdrawal,\u201d and performs the withdrawal. The continuation port in the \u201cWithdrawal\u201d gets a \u201cMsgSuccess\u201d when the withdrawal has completed.\n","Port<int>balance=new Port<int>( ).\n\nAs before, \u201cbalance\u201d takes an \u201cint,\u201d which is the current balance. The current balance for the cashbox is always waiting at balance. As before, the client cannot post directly to \u201cbalance.\u201d It is internal to the implementation.\n","Port<Withdrawal>withdrawalWaiting=new Port<Withdrawal>( )."]}}}},"The new internal withdrawalWaiting port has a Withdrawal waiting when a withdrawal is in progress. At any time, at most one Withdrawal can be waiting on withdrawalWaiting. The client cannot post directly to withdrawalWaiting; it is internal to the implementation.\n\n","Again, methods may be bound to these ports.","activate(!join<int, int, MsgSuccess>(balance, deposit, noWithdrawalWaiting)\n\n",{"@attributes":{"id":"p-0098","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"activate(!join<int, int, MsgSuccess>(balance, deposit, withdrawalWaiting)"},{"entry":"\u2003.with(delegate(int b, int d, Withdrawal w) {"},{"entry":"\u2003\u2003if (b + d < w.n) {"},{"entry":"\u2003\u2003\u2003balance.post(b + d);"},{"entry":"\u2003\u2003\u2003withdrawalWaiting.post(w);"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003balance.post(b + d \u2212 w.n);"},{"entry":"\u2003\u2003\u2003noWithdrawalWaiting.post(new MsgSuccess( ));"},{"entry":"\u2003\u2003\u2003w.continuation.post(new MsgSuccess( ));"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}));"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"If the deposit is for less than the waiting withdrawal amount, then the full amount is deposited. Otherwise, the withdrawal can be completed, posting a message to \u201cnoWithdrawalWaiting.\u201d The current balance can be recomputed, and a \u201cMsgSuccess\u201d posted to the withdrawal's continuation.",{"@attributes":{"id":"p-0100","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"activate(!join<int, Port<MsgSuccess>, MsgSuccess>("]},{"entry":[{},"\u2003\u2003balance, withdraw, noWithdrawalWaiting)"]},{"entry":[{},"\u2003.with(delegate(int b, Withdrawal w, MsgSuccess n) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (w.n <= b) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003balance.post(b \u2212 w.n);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003noWithdrawalWaiting(new MsgSuccess( ));"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003w.continuation.post(new MsgSuccess( ));"]},{"entry":[{},"\u2003\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003balance.post(b);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003withdrawalWaiting.post(w);"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This \u201cactivate\u201d defines the operation of \u201cwithdraw\u201d when no withdrawal is waiting, i.e., when an \u201cint\u201d is at \u201cbalance,\u201d a \u201cWithdrawal\u201d is at \u201cwithdraw,\u201d and a \u201cMsgSuccess\u201d is at \u201cnoWithdrawalWaiting.\u201d The action sends these three messages as arguments to the delegate. If the withdrawal amount does not exceed the current balance, then it may be subtracted from the remaining balance and the client notified. There is still no withdrawal waiting. Otherwise, the \u201cWithdrawal\u201d is sent to \u201cwithdrawalWaiting.\u201d If a \u201cWithdrawal\u201d message arrives at \u201cwithdraw\u201d when another withdrawal is already waiting (i.e., when \u201cwithdrawalWaiting\u201d has a message, so that \u201cnoWithdrawalWaiting\u201d does not), there is no defined action, and the \u201cWithdrawal\u201d message waits at \u201cwithdraw\u201d until its turn.","The initial balance is zero, and there are no withdrawals waiting:",{"@attributes":{"id":"p-0103","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003balance.post(0);"]},{"entry":[{},"\u2003noWithdrawalWaiting(new MsgSuccess( ))."]},{"entry":[{},"As before, the client can deposit money into the cashbox with"]},{"entry":[{},"\u201cdeposit.post.\u201d"]},{"entry":[{},"\u2003deposit.post(100);"]},{"entry":[{},"\u2003deposit.post(50)."]},{"entry":[{},"Performing the withdrawal takes a little more code in the client."]},{"entry":[{},"\u2003Port<MsgSuccess> afterWithdrawal = new Port<MsgSuccess>( );"]},{"entry":[{},"\u2003activate(afterWithdrawal,"]},{"entry":[{},"\u2003\u2003delegate(MsgSuccess v) {"]},{"entry":[{},"\u2003\u2003\u2003log.post(\u201cwithdrawal succeeded\u201d);"]},{"entry":[{},"\u2003\u2003\u2003...( );"]},{"entry":[{},"\u2003\u2003});"]},{"entry":[{},"\u2003withdrawal.post(new Withdrawal(200, afterWithdrawal));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Here, a new port, \u201cafterWithdrawal,\u201d is created, which takes a \u201cMsgSuccess.\u201d It may be bound to a delegate that logs the withdrawal and then does some further work. A new \u201cWithdrawal\u201d for 200 dollars may be sent to it that includes \u201cafterWithdrawal.\u201d This starts the withdrawal. The delegate runs after the withdrawal is complete, which in this case requires 50 more dollars to be deposited.","As described above, ports can take messages of a particular type. The CCR, however, also lets ports take messages of multiple types, with separate bindings for the separate message types. Consider the first cashbox example described above. Instead of three ports, \u201cbalance,\u201d \u201cdeposit,\u201d and \u201cbalanceRequest,\u201d one port, \u201ccashbox.\u201d may be used that takes messages of type \u201cBalance,\u201d \u201cDeposit,\u201d or \u201cBalanceRequest.\u201d","public class Balance {public int n;}","public class Deposit {public int n;}","public class BalanceRequest {public Port<Port<int>>continuation;}","Port<Balance, Deposit, BalanceRequest>\n\n","When methods are bound to \u201ccashbox,\u201d the different types of the messages determine the different uses of the port.",{"@attributes":{"id":"p-0111","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"activate(!join<Balance, Deposit>(cashbox, cashbox)"]},{"entry":[{},"\u2003.with(delegate(Balance b, Deposit d) {"]},{"entry":[{},"\u2003\u2003cashbox.post(new Balance(b.n + d.n));"]},{"entry":[{},"\u2003\u2003}));"]},{"entry":[{},"activate(!join<Balance, BalanceRequest>(cashbox, cashbox)"]},{"entry":[{},"\u2003.with(delegate(Balance b, BalanceRequest req) {"]},{"entry":[{},"\u2003\u2003\u2003cashbox.post(b);"]},{"entry":[{},"\u2003\u2003\u2003req.continuation.post(b.n);"]},{"entry":[{},"\u2003\u2003}));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The current balance may be initialized using \u201ccashbox.post.\u201d","cashbox.post(new Balance(0));","The client can now deposit various amounts into the cashbox using \u201ccashbox.post.\u201d","cashbox.post(new Deposit(100));","cashbox.post(new Deposit(50));","With this change, this example works the same as before.","Another example program, which simulates a disk scheduler, will now be described. A number of concurrent actions generate streams of disk requests. The requests in each stream must be processed in order, while requests in different streams may be interleaved.","A disk with one million blocks may be simulated:","const int DiskSize=1000000;","The port \u201cheadAt\u201d may be created to record the current head position (initially 0). The client cannot post directly to \u201cheadAt.\u201d It is internal to the implementation.","Port<int>headAt=new Port<int>( );","headAt.post(0);","A \u201cRequest\u201d stores a request to seek the head to position \u201cn\u201d and call \u201cop\u201d (e.g., to read a block).","public class Request {int n; Port<MsgSuccess>op;}","\u201cDistance\u201d computes the distance from the current head position to head position n in terms of an elevator algorithm. An elevator policy performs its requested operations in order of non-decreasing block address, for efficiency, then repeats.",{"@attributes":{"id":"p-0126","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public static int Distance(int at, int n) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return (n \u2212 at + DiskSize) % DiskSize;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0127","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public static bool Sooner(int at, int n1, int n2) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return Distance(at, n1) < Distance(at, n2);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A list of pending requests may be maintained, sorted by the results of \u201cSooner.\u201d \u201cInsertionSort\u201d inserts a request into the sorted list.",{"@attributes":{"id":"p-0129","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static List<Request>"]},{"entry":[{},"InsertionSort(int at, List<Request> list, Request req) {"]},{"entry":[{},"\u2003if (list.Count > 0) {"]},{"entry":[{},"\u2003\u2003Request req= list[0];"]},{"entry":[{},"\u2003\u2003list = list.Clone( );"]},{"entry":[{},"\u2003\u2003if (Sooner(at, req.n, req_.n)) {"]},{"entry":[{},"\u2003\u2003\u2003list.Insert(0, req);"]},{"entry":[{},"\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003list.Remove(0);"]},{"entry":[{},"\u2003\u2003\u2003list = InsertionSort(at, list, req);"]},{"entry":[{},"\u2003\u2003\u2003list.Insert(0, req_);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003return list;"]},{"entry":[{},"\u2003} else {"]},{"entry":[{},"\u2003\u2003list = list.Clone( );"]},{"entry":[{},"\u2003\u2003list.Insert(0, insert.req);"]},{"entry":[{},"\u2003\u2003return list;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The \u201cpending\u201d port may be created to hold one or more pending requests; the \u201cnonePending\u201d port if there are none. The client cannot post directly to \u201cpending\u201d and \u201cnonePending.\u201d They are part of the implementation.","Port<List<Request>>pending=new Port<List<Request>>( );","Port<MsgSuccess>nonePending=new Port<MsgSuccess>( ).","We create an \u201caddRequest\u201d port for the client to post new requests.","Port<Request>addRequest=new Port<Request>( );","We create a \u201cservice\u201d port and send it a \u201cMsgSuccess\u201d when requests are pending but no request is in progress. Its action removes the first pending request from the list, seeks the head, performs the operation, and sends another message to \u201cservice\u201d to handle the next request. The client cannot post directly to the \u201cservice\u201d port. It is part of the implementation.","Port<MsgSuccess>service=new Port<MsgSuccess>( ).","Now that the ports have created, their bindings can be created and activated.",{"@attributes":{"id":"p-0138","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"activate(!join<int, List<Request>, Request>("]},{"entry":[{},"\u2003\u2002headAt, pending, addRequest)"]},{"entry":[{},"\u2003.with(delegate(int at, List<Request> 1, Request req) {"]},{"entry":[{},"\u2003\u2003\u2003pending.post(InsertionSort(at, 1, req));"]},{"entry":[{},"\u2003\u2003\u2003headAt.post(at);"]},{"entry":[{},"\u2003\u2003}));"]},{"entry":[{},"activate(!join<MsgSuccess, Request>(nonePending, addRequest)"]},{"entry":[{},"\u2003.with(delegate(MsgSuccess n, Request req) {"]},{"entry":[{},"\u2003\u2003\u2003pending.post(new List<Request>(req));"]},{"entry":[{},"\u2003\u2003}));"]},{"entry":[{},"activate(!join<List<Request>, MsgSuccess>(pending, service)"]},{"entry":[{},"\u2003.with(delegate(List<Request> 1, MsgSuccess s) {"]},{"entry":[{},"\u2003\u2003\u2003Request req = 1[0];"]},{"entry":[{},"\u2003\u2003\u20031 = 1.Clone( );"]},{"entry":[{},"\u2003\u2003\u20031.Remove(0);"]},{"entry":[{},"\u2003\u2003\u2003seekHead.post(req.n);"]},{"entry":[{},"\u2003\u2003\u2003if (1.Length = 0) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003nonePending.post(new MsgSuccess( ));"]},{"entry":[{},"\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003pending.post(1);"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003req.op.post(new MsgSuccess( ));"]},{"entry":[{},"\u2003\u2003\u2003service.post(new MsgSuccess( ));"]},{"entry":[{},"\u2003\u2003}));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Calling \u201cDoBlocks\u201d simulates a sequential computation repeatedly reading random blocks. Its argument is a \u201cBlocksRequest.\u201d",{"@attributes":{"id":"p-0140","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class BlocksRequest { public int actionId; public int count; }"]},{"entry":[{},"static Random random = new Random( );"]},{"entry":[{},"public static void Blocks(BlocksRequest blocks) {"]},{"entry":[{},"\u2003if (blocks.count > 0) {"]},{"entry":[{},"\u2003\u2003int blockNo = random.Next(DiskSize);"]},{"entry":[{},"\u2003\u2003addRequest"]},{"entry":[{},"\u2003\u2003.post(new"]},{"entry":[{},"\u2003\u2003\u2003Request(n,"]},{"entry":[{},"\u2003\u2003\u2003\u2003delegate(MsgSuccess s) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003Console.WriteLine(\u201caction {0}, block {1}\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003blocks.actionId,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003n);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003DoBlocks(new BlocksRequest(blocks.actionId,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003blocks.count \u2212 1));"]},{"entry":[{},"\u2003\u2003\u2003\u2003}));"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The disk head is initially at position 0. There are no pending requests yet, but requests may now be serviced.","headAt.post(0);","nonepending.post(new MsgSuccess( ));","service.post(new MsgSuccess( ));","A few concurrent computations, \u201cDoBlocks,\u201d may be spawned, and the simulation runs.",{"@attributes":{"id":"p-0146","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for (int id = 0; id < 10; id++) {"]},{"entry":[{},"\u2003spawn(delegate(BlocksRequest req) { DoBlocks(req); },"]},{"entry":[{},"\u2003\u2003new BlocksRequest(id, 100));"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Thus, there have been described systems and methods for effective programmability around concurrency that address the problem of latency in a distributed operating system. Though the invention has been described in connection with certain preferred embodiments depicted in the various figures, it should be understood that other similar embodiments may be used, and that modifications or additions may be made to the described embodiments for practicing the invention without deviating therefrom. The invention, therefore, should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
