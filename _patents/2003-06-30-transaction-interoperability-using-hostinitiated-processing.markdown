---
title: Transaction interoperability using host-initiated processing
abstract: Systems and methods are disclosed to support Host Initiated Processing (HIP), in which an application in a first system calls a software object in a second system that is in some respect incompatible with the first system. The calling application resides in a legacy system (e.g., an IBM mainframe), and is written based on a programming model (e.g., CICS). The called software object is based on a WINDOWS-based programming model (e.g., COM or .NET), which is incompatible with the legacy system's programming model. The HIP system converts a call from the legacy system so that the call is usable with the WINDOWS-based system, and also converts the result provided by the WINDOWS-based system into a form usable by the legacy system. Example aspects of incompatibilities between a legacy system and a WINDOWS-based system include: data representation, data types, communications protocol, passing of call parameters and return values, and error handling.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07620958&OS=07620958&RS=07620958
owner: Microsoft Corporation
number: 07620958
owner_city: Redmond
owner_country: US
publication_date: 20030630
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates generally to the field of distributed computing. More particularly, the invention provides a system and method that supports interoperability between incompatible computing environments.","Interoperability of computer systems has become increasingly important for enterprises. It is often the case that enterprises have extremely large legacy data stores that are maintained in propriety storage format. Additionally, enterprise customers often have a substantial investment in application systems that may span a decade or more of development effort. These business applications typically reside in IBM CICS (Customer Information Control System) and IMS (Information Management System) Transaction Manager environments. Even as technology has moved forward, enterprise customers have been reluctant to move their line of critical business application and data to distributed environments, such as those based on the WINDOWS operating systems.","However, in recent years customers have been building more new applications within distributed computing environments such as WINDOWS, COM+, .Net, SQL Server and BizTalk. The problem the enterprise data center manager faces is the ability to bridge the legacy application and data stores maintained in the centralized data center with new applications built on emerging technologies in distributed environments.","In essence, the problem in using legacy systems with new environments is one of interoperability. Legacy systems may employ data types, communication protocols, function-calling mechanisms, programming models, etc., that are not compatible with newer systems. Thus, if an application in a legacy system (e.g., an IBM CICS system) attempts to call a software object in a newer system (e.g., a WINDOWS system), the call may not be understood for a variety of reasons. For example, the legacy system and the newer system may represent data in a different manner (e.g., length specified character strings versus null-terminated character strings), may use different communications protocols to support calls to remote objects (e.g., System Network Architecture (SNA) versus Transport Control Protocol (TCP)), and one system may use a data type (e.g., dependent-sized arrays) that are not supported in the other system. In theory, object-oriented programming allows two objects that know little about each other to interoperate with each other through a known interface. However, incompatibilities such as those described above often thwart this type of interoperability between heterogeneous systems (i.e., systems of different types), such as between an IBM mainframe and a WINDOWS-based system.","In view of the foregoing, there is a need for a system and method that overcomes the drawbacks of the prior art.","The present invention provides a system and method that enables two incompatible systems to interoperate with each other. Typically, this interoperation takes the form of a software object in a first system calling a software object in a second system. Typically, the first system is a non-WINDOWS system, such as a IBM mainframe, and the second system is a system based on the WINDOWS environment. The situation in which a non-WINDOWS system calls upon the functionality of a WINDOWS-based system may be referred to as \u201cHost Initiated Processing\u201d (HIP), where the non-WINDOWS system is referred to as the \u201chost.\u201d","A system to support HIP (also referred to herein as an \u201cHIP system,\u201d or, simply, \u201cHIP\u201d), may take the form of a service that executes on a WINDOWS-based system. The HIP system includes logic to receive requests or calls from the legacy system and to convert those requests or calls into a form that can be used with software in the WINDOWS-based system that has been written according to WINDOWS-based programming models, such as Component Object Model (COM) or .NET. The conversion may include:\n\n","HIP allows an enterprise to benefit from both the legacy system and a newer system in a cost effective manner. The enterprise can continue to use its legacy client line of business applications (e.g., in CICS and IMS), and can interoperate with application servers and data that execute in WINDOWS-based environments by redirecting connections from legacy server environments to HIP-enabled server applications. Thus, HIP allows reuse of existing legacy client application, while enabling the customer to develop new applications systems based on emerging industry technologies.","Other features of the invention are described below.","Overview","The present invention provides an HIP system, which supports interoperability between two incompatible systems. The systems may be incompatible for reasons relating to data representation, data types, communication protocols, programming models, or other reasons (or any combination of the foregoing reasons). In a typical scenario, the HIP system supports a call to a software object in a WINDOWS-based environment (e.g., a COM or .NET object), where the call is made by an application in a legacy system (e.g., an IBM mainframe) based on a non-WINDOWS programming model (e.g., CICS). However, it will be understood that the techniques described herein are not limited to this scenario.","An HIP system preferably includes COBOL and RPG (Report Program Generator) data declaration importers, which create metadata encoding schemes that enable the HIP runtime environment (see below) to transform legacy data (e.g., IBM OS\/390 and OS\/400 data types from COBOL and RPG data constructs) into WINDOWS\/INTEL x86 data types that can be consumed by COM and .NET programming models. Preferably, the metadata is stored in a file with a .TIM extension. (\u201cTIM\u201d stands for \u201ctransaction integrator metadata\u201d.) The .TIM file is independent of the COM Server Object and the .Net Assembly. The .TIM file contains annotation that marry the legacy data (e.g., the COBOL and RPG data types and aggregate constructs) to the full range of automation data types (variant data types) and to the full range of .NET CLS data type and constructs.","The HIP system allows developers to develop client and server application programs in their normal manner without the requirement for knowledge of the \u201cforeign\u201d system. A development tool is provided that aids and integration analyst in merging the two environments. An HIP system further includes a development tool, which allows a user to interactively build the .TIM file by matching and configuring COM or .Net data type to COBOL or RPG data types. An HIP administrative environment uses portions of the .TIM file content to define relationships between a CICS and\/or IMS application program, a listener in the HIP runtime environment (see below, in connection with ), and a method on the server object.","The HIP runtime environment, which is described below in connection with  and is also referred to as an \u201cHIP service,\u201d implements algorithms and uses techniques for translating from legacy data streams (e.g., OS\/390 and OS\/400 data streams) to COM automation and .NET remote server programming models based on the contents of the .TIM file. The HIP runtime environment listens for incoming requests generated from CICS and IMS transaction programs, and receives the data streams based on programming models identified in the .TIM file. When the COM or .NET object completes its processing, the HIP Runtime environment implements algorithms and uses techniques to return the data stream to the CICS or IMS transaction programs in a programming model specific format.","The HIP runtime and administrative environments also implement algorithms and use techniques for mapping port numbers and transaction names to methods on COM and .Net objects in complex and flexible manners to provide a secure, scalable and performant interoperability environment between legacy systems (e.g., OS\/390, OS\/400 systems) and WINDOWS-based platforms.","Exemplary Computing Environment",{"@attributes":{"id":"p-0027","num":"0031"},"figref":"FIG. 1","b":["100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, embedded systems, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules and other data may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit  may represent multiple logical processing units such as those supported on a multi-threaded processor. The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus). The system bus  may also be implemented as a point-to-point connection, switching fabric, or the like, among the communicating devices.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Interoperability Between Heterogeneous Systems in a Distributed Computing Environment","The present invention is directed to the problem of achieving interoperability between heterogeneous computing environment, where certain types of incompatibilities exist between the environments.  exemplifies an interoperability scenario that arises frequently in practical application.  shows a distributed computing environment that comprises two computers  and . In the example of , computer  is a system based on one of the MICROSOFT WINDOWS operating systems, and computer  is a system that based on some environment other than the WINDOWS operating systems. In a typical scenario, computer  is an IBM mainframe, although numerous other types of systems can be envisioned. (As a shorthand, computer  may be referred to as a \u201cnon-WINDOWS\u201d environment or \u201chost\u201d environment, and computer  may be referred to as a \u201cWINDOWS\u201d environment.) Since computers  and  provide different types of environments, these computers may be described as \u201cheterogenous.\u201d","A software object  resides on computer . Software object  may be any type of software, e.g., a business application such as an accounting system, an airline reservation system, etc. Software object  may need to use some functionality that resides on computer . For example, computer  may provide a database or a set of computational functions that software object  needs to access. Software object  resides on computer  and provides the functionality that software object  may need to access. For example, software object  may be a database management system that stores and retrieves information in a database, or may provide a set of accounting functions (or other computational functions) that are useful to software object . Thus, software object  issues a call  to software object . In response to the call, software object  provides some type of results  to software object .","Because software objects  and  operate in different types of environments (e.g., software object  operates in a non-WINDOWS environment, and software object  operates in a WINDOWS environment), there is a potential for various types of incompatibilities in terms of how software objects  communicate with each other. For example, software object  may be a piece of business software written in a dialect or style of COBOL (e.g., LU 6.2 or LINK), and software object  may be a dynamic-link library (DLL) that exposes a typical WINDOWS-style Application Programming Interface (API), for example a Component Object Model (COM) object or a .NET object. Thus, software objects  and  may expect to communicate in different ways, and some type of translation may be necessary in order to permit software object  to call, and receive results from, software object .",{"@attributes":{"id":"p-0040","num":"0044"},"figref":"FIGS. 3-5"},{"@attributes":{"id":"p-0041","num":"0045"},"figref":["FIG. 3","FIG. 3"],"b":["302","304","302","302","304","304","201","202","216","218"]},{"@attributes":{"id":"p-0042","num":"0046"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 4A"],"b":["402","404","412","416","412","414","414","418","412","416"]},{"@attributes":{"id":"p-0043","num":"0047"},"figref":"FIG. 5","b":["502","504","502","512","514","502","502","516","518","518","512","512","504","504","522","504","524","526","502","504"]},{"@attributes":{"id":"p-0044","num":"0048"},"figref":"FIGS. 3-5","ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["In addition to the fact that integers can be represented differently in different systems, other data types (e.g., floating point values, etc.) may have different representations in different systems.","Different languages handle arrays in different ways. For example, in COBOL, arrays are generally fixed-sized, while in most WINDOWS-based programming models (e.g., COM), arrays are variable sized. Thus, in COBOL, an array of length five that has only two (significant) elements is padded with three empty elements at the end, but the same array in the WINDOWS environment need not be padded. When an array in the WINDOWS environment is converted to COBOL, it may be necessary to pad or truncate the array, depending on how many elements the WINDOWS array has and how many elements the non-WINDOWS system is expecting. Rules can be created that define when it is acceptable (or not acceptable) to pad or truncate an array. Additionally, COBOL provides a type of variable-sized arrays called ODO arrays (\u201coccurs depending on\u201d), wherein the array can have a variable size, but the element count is stored. Since variable-sized arrays in a WINDOWS-based environment generally do not have an element count, any conversion between arrays in the WINDOWS environment ODO arrays must take the element count into account.","There may be protocol differences between two systems that affect how a function is called. For example, one system may expect a call to a software object to take the form of a single message that is passed to the object, while another system may expect a call to take the form of an interactive session in which messages are exchanged back and forth between the called object and the calling object. As another example, in some styles of programming (e.g., LU 6.2), when an application calls a remote software object, the handshaking (e.g., connect, send, receive, disconnect, etc.) required to communicate with the remote system is explicitly written into the application program, while in other styles (e.g., LINK), the handshaking is abstracted in the application program and handled by an external component that is called by the application.","There may be incompatibilities in the way that error messages are handled. For example, the SNA protocol includes a field (FMH7) for sending error reports, while the TCP protocol does not. Thus, if the TCP protocol is used for a system that expects to use the SNA protocol, then special provisions must be made for sending the information that would be contained in the SNA error field.\n\nExemplary System for Providing Interoperability\n"]}}}},{"@attributes":{"id":"p-0045","num":"0053"},"figref":"FIG. 6","b":["600","201","202","600","600"],"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["HIP Runtime service ","Listener ","Request queue ","HIP Proxy ","Flow control ","Invoker ","Conversion components  and ","Send\/receive object","Request context \n\nThese components and others are described in detail below.\n"]}}}},"HIP Runtime service . The runtime service is a thin layer that starts up other components in system . HIP runtime service starts components such as listeners  and HIP proxies . HIP runtime service  determines how many listeners and proxies to start based on configuration information that has been set up by an administrator.","Listener . The Listener receives requests from one system (e.g., computer ) and places these requests on the request queue . Preferably, the listener performs its task in a very expeditious manner so that it can quickly queue a request and then resume listening for additional requests.","Request queue . Request queue stores the requests that have been received by listener(s) . In effect, request queue  is where request are stored after they have been picked up by listener(s)  and while the requests are waiting for an HIP proxy  (discussed below) to become available. Request queue , in effect, serves to:\n\n","HIP Proxy . The HIP proxy instantiates the flow control  (described below) that is required to successfully manage a host-Initiated unit of work (i.e., a unit of work initiated by computer ). HIP proxies are generic, in the sense that they are capable of instantiating flow controls for any type of host-initiated work. The particular flow control that an HIP proxy  will use is based on mappings that have been set up by an administrator.","Flow control . Flow control  is responsible for executing the plan that converts requests from computer  into a form suitable for use by applications on computer . This plan is defined at development time. Different flow controls are designed to handle different types of requests, which can be identified by the port on which they come in. For example, it may be defined that any request that comes in on port  is handled by one flow control, and request that comes in on port  is handled by a different flow control, etc. As one example, a flow control may be an \u201cend point resolution\u201d flow control that simply causes a particular method on a particular object (in computer ) to be executed in response to a request received from computer .","Conversion components  and . The conversion components are used to convert data for use in one system into a form that is usable by another system. , , and A above show examples of such data conversion. In a preferred embodiment, two different conversion components are used to handle different aspects of the conversion: conversion component  handles conversion issues related to aggregate data types (e.g., the way that the elements in a matrix are organized in the different systems), while conversion component  handles conversion issues related to primitive data types (e.g., conversion of integer or float formats from one system to another).","Send\/receive component . The send\/receive component is responsible for negotiating the moving of data from one system to another and back. For example, after a request has been picked up by HIP proxy  and a flow control  has been started to handle that request, the nature of how requests are made in computer  may be such that additional parts of the request (e.g., additional parameters) may need to be retrieved from computer . Send\/receive component  may arrange for these additional parameters to be received. Send\/receive component generally operates at a higher level than the transport layer, and communicates with transport component  to manage the transport of the information (e.g., transport component  may manage details of how information is packaged for use with SNA or TCP). A send\/receive component  may have a custom processing component  that handles details relating to particular types of request.","Invoker . The invoker is the component that actually makes a call to a remote software object (e.g., server application program ) on computer . For example, invoker  may be responsible for laying out the inbound automation parameters into an acceptable form for an IDispatch Invoke call. Invoker  also puts outbound automation parameters in a form that the conversion logic (i.e. convert components  and ) can use to pack the data in preparation for return them to the calling application on computer .","Request context . Request context  is a holding place for data that is used or shared by one or more components in system . For example, during the processing of a given request, one component may receive or computer some data that can be used by another component. Request context  is essentially a buffer where this data can be stored and shared between components.","IAdmin object  and IReadlib object . These objects are used by components of system  to access the mapping information that has been set up to enable two systems to interoperate with each other. For example, the information that explains how to translate data types from one system into data types from another system is stored in a .TIM file (i.e., reference numeral ). (The .TIM file is part of data store .) IReadlib object  is used to read the conversion information from a .TIM file so that it can be used (e.g., by conversion components  and ) to convert data from one system to another. IAdmin object  is used to access end-end mapping information  (which is also part of data store ). For example, end-end mapping information  maps, among other things, a particular .TIM file to a particular flow control, and IAdmin object  can be used to obtain this mapping. Once the identity of the particular .TIM file is obtained, IReadlib object  can be used to read the actual metadata inside the .TIM file.","Transport component . The transport component is used to manage issues relating to the particular type of transport protocol that is being used to communicate with computer . For example, computer  may communicate using protocols such as TCP or SNA, and transport component  abstracts the differences between the various protocols, so that high-level interfaces can be exposed to listener  and send\/receive component . To this end, transport component  may include interfaces IListener  and ITransfer . For example, transport component  may accept incoming sockets (in TCP terms), or \u201callocates\u201d (in SNA terms), and may use IListener  to expose a high-level interface to listener  that abstracts the differences between these protocols. Similarly, ITransfer interface  may expose an interface to send\/receive component  that allows send\/receive component  to send and receive data without concern for the differences between the different protocols.","One example aspect of transport that transport component  may need to deal with is error handling, since TCP and SNA handle errors in different ways. At a basic level, handling of errors for SNA implies returning an FMH-7 that contains a descriptive indication of the error. The FMH-7 only addresses the reporting of errors to the transaction monitor and not to the client application program itself. Since the FMH-7 field is not available in TCP, return meaningful error information to a TCP client preferably requires the use of meta data in at least the reply. Transport component  may assist in formatting error information for TCP or SNA, as appropriate.","HIP Administrative Console . The administrative console is where an administrator configures system . An administrator may use administrative console  to specify mappings for particular types of transactions. For example, an administrator may specify that when a request comes in on port , a particular flow control is to be used to process that request. Additionally, the administrator may configure the system with such parameters as how many listeners  should be started, how many HIP proxies  should be started, etc.","Exemplary Development Process for Interoperability",{"@attributes":{"id":"p-0059","num":"0080"},"figref":"FIG. 7","b":["702","702","704","702","706","706"]},"After code has been written for mainframe , at some point in the future developer  undertakes the task of enabling the mainframe code to call a component in a Windows-based system. Developer  uses component builder  in order to create the information that will aid in the conversion of data and programming model from the mainframe environment to the Windows environment. In particular, the component builder  generates an IDL (Interface Definition Language)  description of the portion of the mainframe code that will need to interact with Windows, and also generates Visual Basic class definitions  corresponding to the mainframe code's data declarations . It should be noted that some data types in Visual Basic may correspond very closely to data types in typical mainframe languages (such as COBOL or RPG), and others may not. For example, Visual Basic and COBOL both have integers, but COBOL has dependent-sized arrays and Visual Basic does not.","After the information that will support interoperability has been created, it is stored in a server component  for use by HIP service  described above.",{"@attributes":{"id":"p-0062","num":"0083"},"figref":"FIGS. 8-9","b":["201","201","802","810","201","802","810","706","808","804","806","810","802","201","810","818","812","816","812","814"]},"After the conversion information has been stored in .TIM file , an administrator  may prepare the HIP system to work with the application that developer  analyzed with component builder . Administrator  uses an administrative console  to install the conversion information contained in the .TIM file  into database . Additionally, the administrator specifies end-end mappings (i.e., mappings , shown in ), which will be used for transaction interoperability (blocks ,).","Additionally, a systems programmer  may perform whatever configuration (VTAM, NCP, TCP\/IP, CICS, IMS) may be necessary to enable mainframe  and\/or an application on mainframe  to work with the HIP service. The HIP service is now ready to process a call to a WINDOWS-based software object from an application on mainframe .","User  is a user of a computer , such as an IBM mainframe. At some point during user 's use of the computer, user makes a request  that results in calling a component in a WINDOWS-based environment  on computer . For example, user  may operate a client application , which calls upon some functionality that is available in WINDOWS-based environment . Computer  thus generates an connection request , which is picked up by listener . Listener , informs HIP service  of the connect request, which causes HIP service  to send an accept message  back to computer . Computer  then sends request  to HIP service . Request  is the substantive request to initiate some functionality in the WINDOWS-based environment  (as opposed to the alloc\/connect request , which merely requests a connection to the WINDOWS-based environment for the purpose of making a substantive request). Using components that were described above in connection with , HIP service  causes request  to be converted into a format that can be understood by a WINDOWS-based component, such as server object , which will provide the requested functionality. HIP service  uses invocation component  to invoke server object  in WINDOWS-based environment . (In one example, server object  may be a COM server, although it will be understood that this embodiment is not limiting of the invention.) Server object  then performs whatever processing is specified by the request and provides a reply to invocation component . (Both the actual invocation of server object , and the reply provided by server object , are marked as reference numeral .) The reply is provided to HIP service . HIP service  then packages the reply in a manner that can be understood by the environment and\/or programming model at computer . This \u201cpackaging\u201d may include conversion of data types, conversion of protocols, and the like as described above in connection with . Once the reply has been packaged in this manner, the reply  is provided to computer .","Exemplary Process for Interoperability Using HIP Service",{"@attributes":{"id":"p-0066","num":"0087"},"figref":["FIG. 10","FIG. 6","FIG. 10"],"b":"602"},"Initially, a developer analyzes legacy code, and uses a tool to build conversion information that will enable the legacy code to interoperate with a software object in a WINDOWS-based system (block ). These component may, for example, include type libraries, conversion tables, and custom conversion components. The components that are created are stored in a database (block ), where they can be used by the HIP service.","After the conversion information has been prepared, the legacy system, at some point during its operation, calls a software object in a WINDOWS-based environment (block ). Instead of the call being communicated directly to the software object, it is received by the HIP service. The HIP service then uses the conversion information (i.e., the metadata) to convert the call for use with a WINDOWS-based software object (block ). The various types of incompatibilities that can arise, as well as various conversion techniques and mechanisms, are discussed above.","After the call has been converted, the converted call is used to invoke the software object in a WINDOWS-based environment. That software object then executes (block ). The software object produces some type of results (e.g., a return value). The HIP service then uses the conversion information to convert the results to a form that is usable with the legacy system (block ). The various incompatibilities that can arise in presenting a result, as well as various conversion techniques and mechanisms, are discussed above.","After the results have been converted, the converted results are passed to the legacy system (block ).","It is noted that the foregoing examples have been provided merely for the purpose of explanation and are in no way to be construed as limiting of the present invention. While the invention has been described with reference to various embodiments, it is understood that the words which have been used herein are words of description and illustration, rather than words of limitations. Further, although the invention has been described herein with reference to particular means, materials and embodiments, the invention is not intended to be limited to the particulars disclosed herein; rather, the invention extends to all functionally equivalent structures, methods and uses, such as are within the scope of the appended claims. Those skilled in the art, having the benefit of the teachings of this specification, may effect numerous modifications thereto and changes may be made without departing from the scope and spirit of the invention in its aspects."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0012","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0020"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0017","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0024"},"figref":"FIGS. 8-9"},{"@attributes":{"id":"p-0021","num":"0025"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
