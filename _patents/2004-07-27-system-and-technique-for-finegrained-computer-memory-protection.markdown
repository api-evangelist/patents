---
title: System and technique for fine-grained computer memory protection
abstract: A fine-grained memory protection system and technique provide computer memory protection at least to a word granularity. A permissions table having permission values associated with a computer memory is arranged as protection domains. The permissions table can be cached in a protection lookaside buffer (PLD) and/or in sidecar registers. A software calls across protection domains (a cross-domain call) can be facilitated with a switch gate and a return gate. In some embodiments, a gate table is provided to store the switch gates and return gates, each having gate values. In some embodiments, a stack permission stable allows stack frames to be associated with the cross-domain call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07287140&OS=07287140&RS=07287140
owner: Massachusetts Institute of Technology
number: 07287140
owner_city: Cambridge
owner_country: US
publication_date: 20040727
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims the benefit under 35 U.S.C. \u00a7 119(e) of U.S. Provisional Application No. 60\/490,482 filed Jul. 28, 2003, which application is incorporated herein by reference in its entirety.","This invention was made with government support under Contract No. F30602-00-2-0562 awarded by the Defense Advanced Research Projects Agency (DARPA) and Contract No. CCR-0093354 awarded by the National Science Foundation (NSF). The government has certain rights in the invention.","This invention relates generally to computer memory protection, and, more particularly, to a system and technique that can provide memory protection to a fine granularity of computer memory.","Computers are known to crash and\/or otherwise malfunction. Often, the crash or malfunction is associated with a running computer program that corrupts a memory area in the computer's random access memory (RAM) used by another running program. Such corruption may be caused, for example, by one computer program overwriting a memory area used by another computer program. Such corruption can also be caused by malicious software, for example, a computer virus. In order to reduce the potential for memory conflicts and resulting corruption, certain conventional protection mechanisms described below, can limit the ability of a computer program to corrupt a portion of the RAM used by another computer program.","Even though it may be desirable to protect a memory area used by a computer program from corruption by another computer program, it is often advantageous for computer programs or processes to share data stored in the computer RAM memory. In some conventional computer environments, sharing is provided by copying the contents of a memory region used by a computer program to another region of RAM, which is then used by another computer program. While such copying protects the original memory region from corruption by the other computer program, the copying process is relatively slow, resulting in slow computer operation.","Conventional commercially available computer operating systems (OSs) typically provide protection of memory portions among different program processes, and between all user processes and trusted memory supervisor code. In addition, conventional operating systems typically support flexible sharing of data in computer RAM memory to allow software applications to cooperate efficiently.","Conventional computer architectures and operating systems provide a linear addressing scheme, in which each software process has a separate linear demand-paged virtual address space. Each address space has a single protection domain that defines protections to memory in the address space, shared by all threads that run within the process. With this arrangement, a software thread can only have a different protection domain if it runs in a different address space. With this arrangement, sharing is only possibly at page granularity, where a single physical memory page can be mapped into two or more virtual address spaces. A page in computer memory has a size that is typically on the order of four kilobytes. Therefore, with this arrangement, protected sharing has a relatively coarse granularity of four kilobytes.","Although the above-described addressing scheme is now common in OS designs and hardware implementations, it has significant disadvantages when used for protected sharing of memory spaces. For example, pointer-based data structures can be shared only if the shared memory region resides at the same virtual address for all participating processes. Also, all words within a page must have the same permissions. As described above, a conventional memory page has a size in the vicinity of four kilobytes, which provides memory protection regions having only a coarse memory permission granularity. Furthermore, interpretation of a pointer depends on addressing context, and any transfer of control between software modules requires a time-consuming context switch, for example, with a software call to another software module. The coarse granularity of protection regions, the time consuming overhead of providing protected memory via software calls, and the time consuming overhead of inter-process communication limits the ways in which conventional protected sharing can be used by software applications.","Although software designers are creative in working around the above limitations to implement protected memory sharing for some software applications, each software application requires considerable custom engineering effort to attain high performance.","In some cases, such as web browsers or kernel modules, software designers sacrifice memory protection robustness in favor of performance, e.g., processing speed, by foregoing hardware memory protection and placing all software modules in the same address space. It should be apparent that this arrangement can lead to computer crashes as software modules compete for the same memory space.","In contrast to systems that place all software modules in the same address space, to provide memory protection, some conventional computer architectures and operating systems, e.g., Linux on x86 or Windows XP on x86, associate each software process with its own memory address space. However, such systems can have increased complexity and run-time overhead, as described above, from managing multiple address contexts.","Some software systems benefit from an ability to provide extensibility, wherein new software modules (sometimes referred to as \u201cplug-ins\u201d) can be linked to existing software modules to provide enhanced functionality. Architects of these systems generally do not use conventional operating system protection support, which, as described above, provides a separate address space for each software module. Instead, the plug-in occupies the same memory space as the program to which it is linked, providing good processing speed at the expense of potential memory corruption. For example, the Apache web server has a plug-in for the interpretation of perl code in web pages. For another example, browsers can receive plug-ins to interpret portable document format (PDF) documents, a format provided by software from ADOBE\u00ae Systems Incorporated, San Jose, Calif. Linking a plug-in to an existing computer program makes communication between the computer program and the plug-in fast and flexible, but because there is no protection between the plug-in and the software program to which it is linked in the same address space, the linkage can lead to memory corruption, or open a security hole in a server (e.g., from a buffer overrun).","Embedded systems, e.g., systems having microcontrollers with embedded code, can have similar problems. Embedded systems are often organized having a set of tasks (sometimes including an operating system) that share physically addressed memory. Without inter-task memory protection, an error in part of the embedded system can make the entire embedded system unreliable. Similarly, loadable OS kernel modules (such as in Linux) all run in the kernel's unprotected address space, leading to potential reliability and security problems.","As described above, so-called \u201cdemand-paged virtual memory systems,\u201d in order to provide multiple protection domains, can place each thread in a separate address space and then map physical memory pages to the same virtual address in each address context. These systems have a coarse protection granularity only to the memory page level.","So called \u201cpage-group systems,\u201d such as HP-PA RISC and PowerPC, partition memory protection domains according to which page-groups (collections of memory pages) are accessible. Every protection domain that has access to a page-group sees the same permissions for all pages in the group. Page-group systems have coarse granularity corresponding to a page or multiple pages.","So called \u201cdomain-page systems\u201d have an explicit protection domain identifier, and each protection domain can specify a permission value for each page. Permissions are managed only at page granularity.","So-called \u201ccapability systems\u201d are an extension of segmented architectures where a \u201ccapability\u201d is a special pointer that contains both location and protection information for a segment of memory. Although designed for protected sharing, capability systems do not function well for the common case of shared data structures that contain pointers. Capability systems do not support multiple memory protection domains, since threads sharing the data structure use its pointers (capabilities) and therefore see the same permissions for objects accessed via the shared structure. Also, many capability systems provide a relatively poor ability to revoke protection permissions, and, in order to revoke permissions, require an exhaustive sweep of the memory. Some capability systems perform an indirect lookup on each capability use, which adds considerable run-time overhead.","In accordance with the present invention, a method for providing fine-grained protection of contents of a computer memory used in a computer includes selecting a range of memory addresses within the computer memory and associating each word in the range of memory addresses with a respective metadata value, wherein a selected word in the range of memory addresses is associated with a first metadata value and words adjacent to the selected word are associated with second and third metadata values respectively.","In accordance with another aspect of the present invention, a computer apparatus having a central processing unit (CPU) includes a computer memory having a range of memory addresses addressable by the CPU and a permissions table associated with the computer memory for associating each word in the range of memory addresses with a respective metadata value, wherein a selected word in the range of memory addresses is associated with a first metadata value and words adjacent to the selected word are associated with second and third metadata values respectively.","In one particular embodiment, for both the above method and system, each metadata value is selected from among a read-only value, a write-only value, a read-write value, an execute-read value, an execute-write value, an execute-read-write value, an execute-only value, and a no-permission value, and can further comprise at least one of a cache coherence state value, a not-cached state value, a cached-exclusive state value, a cached-modified state value, and a cached-shared state value.","With these particular arrangements, memory protection can be provided at a granularity of one word.","Before describing the system and technique for fine-grained computer memory protection, some introductory concepts and terminology are explained. The term \u201cblock\u201d is used herein to describe an address range in computer memory that is aligned on a power-of-two address boundary, and which has a size that is a power-of-two.","The term \u201csegment,\u201d as used herein, describes any bounded portion of computer memory, which may or may not align on a power-of-two address boundary, and which may or may not have a size which is a power-of-two.","As is known, a computer has a largest addressable memory space often referred to as a virtual memory. Often, the physical memory associated with the computer has a size less than the virtual memory size. Therefore, the computer often has a mapping or a translation from a virtual memory space to a physical memory space.","As used herein, the term \u201cfunction\u201d or \u201csoftware function\u201d applies to a portion of operational software code that can be called within a software program. In some instances software functions identified below are conventional, e.g., the function malloc used in C code. In other instances non-conventional software functions used in the system and technique of the present invention are identified by name below. It should, however, be appreciated that names given below to particular functions associated with the system and technique of the present invention are illustrative only, and that other names could equally well be used.","The term \u201cframe\u201d or \u201cactivation frame,\u201d as used herein, refers to a portion of a memory stack currently being used.","Referring now to , a system  for computer memory protection includes a central processing unit (CPU)  coupled to a memory . The memory  includes a permissions table  stored in a privileged space of the memory . The permissions table  holds metadata values arranged as \u201cprotection domains.\u201d Protection domains are described more fully in conjunction with  below. Metadata values stored in the permissions table  can each include, but are not limited to, a respective permission value. Exemplary permission values are shown in Table 1 below. Permission values can include, but are not limited to, a read-only value, a write-only value, a read-write value, an execute-read value, an execute-write value, an execute-read-write value, an execute-only value, and a no-permission value. The no-permissions value corresponds to no access rights. The metadata values stored in the permissions table  can also include other respective information, for example, a cache coherence state value, a not-cached state value, a cached-exclusive state value, a cached-modified state value, and a cached-shared state value.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Perm Value","Type"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"00","no perm"]},{"entry":[{},"01","read-only"]},{"entry":[{},"10","read-write"]},{"entry":[{},"11","execute-read"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"As used herein, the term permissions table is used to refer to both the physical portion of the memory  that holds the metadata values, and also to a data structure used to hold the metadata values. There are a variety of alternative data structures in which the metadata values can be stored in the permissions table . The data structure within the permissions table  can be selected to optimize a variety of factors, including but not limited to, memory space overhead, access time, utilization by a permission lookaside buffer (PLB)  more fully described below, and a time required to modify the permissions table  when permissions change. Exemplary data structures that describe the permissions table are shown in  below.","The permissions table  holds addresses associated with the memory  and metadata values (including a permission value) associated with each address, all arranged as protection domains. Each protection domain encompasses a range of memory addresses, which can be a full range of virtual memory addresses, or which can be a full range of physical memory addresses. However, in other embodiments, the protection domains are associated with less than the full range of virtual and\/or physical memory addresses. Each protection domain has one or more segments, each segment spanning a portion of the range of memory addresses, and each segment having particular metadata values including a particular permission value so that each memory address associated with the segment has the same permission value. Each protection domain provides permission values assigned to each word in the range of memory addresses, and the permission values can be different for different protection domains. It should be understood that permission values are associated with individual words in the range of memory addresses, and each word can have a different permission value. Protection domains are discussed in more detail in conjunction with .","In some embodiments of the present invention, all segments are blocks. However, in other embodiments, some or all of the segments are not blocks.","In one particular embodiment, the memory  can be comprised of a variety of types of memory, including but not limited to, one or more of a dynamic random access memory (DRAM), a static random access memory (SRAM), a hard disk, a flash memory, a floppy disk, and a peripheral memory, for example an external digital tape recorder.","A protection lookaside buffer (PLB)  holds information associated with one or more protection domains, (i.e., addresses and associated metadata values) provided by the permissions table . In one particular embodiment, the PLB  is located within static random access memory, for example, within a cache memory having fast access speed to the CPU .","In one particular embodiment, the PLB  holds power-of-two blocks associated with the one or more protection domains. However, in other embodiments, the PLB  holds non-power-of-two segments associated with the one or more protection domains.","The PLB  can cache recently used memory addresses and associated permission values, avoiding long searches through the permissions table . The PLB  can be re-filled from the permissions table  using either hardware or software. Entries in the PLB  include one or more protection domains and can also include protection domain identifiers to identify each of the one or more protection domains stored within the PLB .","The CPU  includes address registers , here shown as three address registers , , , each associated with a respective sidecar register , , . The sidecar registers  are described in more detail in conjunction with . Let is suffice here to say that a sidecar registers holds information obtained from the PLB , and\/or from the permissions table  which can include respective permission values (or, more generally, metadata values) associated with address ranges that can be associated with addresses held in the address registers , , . A sidecar register is also associated with a program counter , allowing an instruction within the program counter , associated with an address in the memory , to have rapid access to associated permission values.","Each sidecar register -can cache a base, a bounds, and permission values for the last segment within a protection domain accessed by a corresponding address register -. When an address within an address register -or within the program counter  results in a sidecar register miss, i.e., an address not found in the range of the corresponding sidecar register, one or more of the sidecar registers -can re re-loaded from the PLB . If the sidecar register cannot be re-loaded from the PLB , the PLB  can be reloaded from the permissions table  and the sidecar registers  can then be re-loaded from the PLB  or directly from the permissions table . Like entries in the PLB , the entries in the sidecar registers  can be tagged with a protection domain identifier.","The sidecar registers  can improve performance since they hold permission values corresponding to a segment along with segment address bounds, unlike the PLB , which, in one particular embodiment, has a segment boundary index limited to a power-of-two, e.g., a block.","A protection domain identifier (ID) register  holds a protection domain identifier value identifying a protection domain currently being used by the CPU . The protection domain identifier (ID) register  points to the protection domain currently being used, and which has corresponding information in the PLB  and in the sidecar registers .","The protection domain identifier (ID) register  can also hold information to distinguish a kernel mode from a user mode. Kernel mode enables access to privileged control registers (not shown) and privileged instructions.","In one particular embodiment, a particular protection domain identified by the protection domain identifier (ID) register , for example, protection domain , can have permission values that allow a software portion using protection domain  to manage other protection domains, e.g., to have full privileges throughout the range of memory addresses.","Base registers  include a permissions table base register holding an address within the permissions table  corresponding to a base of the protection domain currently being used.","The memory  also includes a stack memory  and a stack permissions table . The stack permissions table  holds stack permission values, e.g., permission values as in Table 1, each associated with a particular range of addresses within the stack memory , unlike the permission values held in the permissions table  which are each associated with a segment within the larger full range of memory addresses of the memory . A stack table base register holds an address corresponding to the portion of the stack permissions table  currently being used. With this arrangement, the stack memory  can be managed to have permission values associated with particular ranges of addresses within the stack memory .","Stack permissions within the stack permissions table  must be treated differently from regular memory permissions within the permission table . Stacks are used by threads that move between protection domains, and should not be accessible to other threads in the same protection domain. The stack permissions table  provides fine-grain stack permissions, i.e., which can be different on each word of the stack memory , and can have access permissions only visible to the owning thread, i.e., \u201cthread-local\u201d permissions.","Two forms of thread-local stack permissions can be maintained. In a first type, stack frame registers  designate a current stack frame as read-writeable and previous stack frames as read-only. In a second type, the stack permissions table  allows individual words of the stack frames to be made thread-writeable to support existing calling conventions with parameters that point to stack-allocated data structures.","The stack frame registers  partition the stack memory  into two regions: a read-only region between an addresses held in an sb (stack base) register and in an fb (frame base) register , and a read-write region between addresses held in the fb register and an sl (stack limit) register . Calls from one software portion to another software portion using another protection domain, a so-called \u201ccross-domain call,\u201d grows the read-only region of the stack memory  by saving the current value of the fb register and moving the current stack pointer into the fb register . For example, in an x86 architecture, this operation is equivalent to moving \u201cesp\u201d into the fb register . The cross-domain call is described more fully below in conjunction with .","The stack frame registers  allow fast creation of an activation frame on a cross-domain call and provide an efficient mechanism for read-only stack parameters. To support stack-allocated return parameters, the thread-local stack permissions table  encodes whether a given stack address is read-writable by the thread, for example, using one bit per word. The contents of the stack permissions table  can be cached in the PLB  along with information from the permissions table . A location in the stack memory  is read-writable if it lies between the read-only and read-write register addresses (i.e., between fb and sl ), or if its stack write permissions bit is set as indicated in the stack permissions table .","A memory supervisor , described more fully below in conjunction with , can flush stack permissions information from the PLB  when a thread is de-scheduled. The computer system implementation does not restrict permissions on stack-allocated data structures. Every protection domain has read-write permissions to the kernel stacks.","Program instructions can be associated with \u201cgate information,\u201d including, but not limited to a switch gate, and a return gate. The switch gate can, for example, be associated with a software call instruction and can identify an address and a protection domain identifier (PD-ID) associated with a destination software portion to which the call instruction directs software flow. The return gate can, for example, be associated with a software return instruction and can identify an address and a PD-ID associated with a source software portion to which the return instruction returns software flow. However, in another embodiment, the return gate does not identify the PD-ID associated with the source software portion, since it can be separately stored at the time of the software call. The gate information is described more fully in conjunction with  below, and function of the gates is described more fully in conjunction with .","The memory  can also include a gate table  having the above-described gate information. Entries in the gate table are described in more detail in conjunction with . The entries in the gate table  allow a running software program to switch protection domains upon a software call and return to the original protection domain upon returning from the software call. Base registers  include a gate table base register holding an address within the gate table corresponding to a region of the gate table  currently being used.","A gate lookaside buffer (GLB)  holds a portion of the gate information contained in the gate table . In one particular embodiment, the GLB  is located within static random access memory, for example, in a cache memory having fast access speed to the CPU . If the GLB  does not contain requested gate information, for example, because a requested address is out of the range of the GLB , the GLB  can be re-loaded from the gate table .","It will be apparent that most program instructions are not associated with a switch gate or a return gate. It would not be desirable to check the GLB  and\/or the gate table  each time a program instruction is encountered having no associated gate. Therefore, in one particular embodiment, as program instructions are encountered which have no associated gate, those instruction can be tagged, for example with a single \u201cgate-present\u201d bit; within an instruction cache . When an instruction having a clear gate-present bit, i.e., a no-gate program address, is subsequently retrieved from the instruction cache , it is not necessary to look in the GLB  or in the gate table  to identify a gate associated with the instruction.","A cross-domain call stack  allows an address (i.e., a return address) associated, for example, with a software call instruction to be stored along with an associated protection domain identifier upon a software call from a source software portion. Upon returning from the destination software portion, the protection domain identifier associated with the address can, therefore, be recalled from the cross-domain call stack . This operation is described more fully in conjunction with .","A cross-domain stack top (CDST) register  points to a top of the cross-domain call stack . In one particular embodiment, the cross-domain call stack  can be implemented, for example, with a combination of an on-chip top-of-stack buffer (e.g., within the CPU  of ), along with the cross-domain call stack  within the memory .","In operation, every memory access during a software program is checked to see if the protection domain associated with the memory access has appropriate access permission for the memory access. First, an associated sidecar register, e.g., , can be checked, and, if the address of the memory access cannot be identified in the sidecar register , the PLB  can be checked and the sidecar register, e.g., , can be re-loaded from the PLB . If the address of the memory access cannot be identified in the sidecar register, e.g., , or the PLB , then both the PLB  and the sidecar register, e.g., , can be reloaded from the permissions table .","Each sidecar register  can cache the last permissions table segment accessed by a respective address register  or by the program counter . The information stored in the sidecar registers , which identifies permission values associated with entire segments, can map a wider address range than the PLB  from which it was fetched. The sidecar registers, therefore, can avoid both lookups in the PLB  and also PLB misses.","The permissions, gate, and stack tables , ,  jointly describe protection domain \u201caccess permissions,\u201d i.e., the operations that software associated with the protection domain can perform on the memory  such as execute a return gate or write to a location in the memory . A portion of the memory , is \u201caccessible\u201d if there is some way for software associated with a protection domain to access it without causing a fault, i.e., by reading, writing, or executing. Memory is \u201cshared\u201d when it is accessible by more than one software portion associated with a respective more than one protection domain.","The memory supervisor , which in one particular embodiment, can be software running in the memory , provides a variety of functions to control access permissions to the memory . For example, the memory supervisor  can manage permission values, protection domain ownerships, export permissions, and the creation and deletion of protection domains, each of which is described more fully below.","The memory supervisor  provides a hardware-independent interface to allow higher-level software to request a change in access permissions to the memory . The memory supervisor  can also check memory requests against permissions policy, and can translate valid requests into modifications to the permissions table , the gate table , and\/or the stack permissions table . The memory supervisor  can also be responsible for revoking permissions when required, e.g., when a memory region is freed or when a protection domain is deleted. It may be desirable to use the memory supervisor  to modify or revoke permissions rather than other software because the other software, running in another protection domain, may not revoke or modify permission in the permissions table  correctly. The memory supervisor  can keep track of how memory regions are shared among protection domains, i.e., which protection domains have been given access permissions to particular memory regions.","Memory \u201cownership\u201d is a component of permissions policy that can be implemented entirely within the memory supervisor . A protection domain can have authority on permissions and use of a memory region associated with the protection domain. Every address space is divided into non-overlapping regions, where each region can be owned by exactly one protection domain. The memory supervisor itself owns all of memory initially. An \u201cowner\u201d protection domain can set arbitrary access permissions on memory that it owns, and can grant arbitrary access permissions, or export permissions, on that memory to other protection domains. Memory ownership can have a coarser resolution than memory protection, and can change less frequently.","The memory supervisor  can maintain ownership information using a sorted list of memory regions and their owners, which are protection domains. In one particular embodiment, the only way for a protection domain to cede ownership of memory that it owns is to create a new protection domain using that memory. In another embodiments, the memory supervisor  could provide a change ownership (e.g., chown) call, which would allow a protection domain to give ownership of a memory region to another protection domain.","The memory supervisor  also implements \u201cexport permissions,\u201d which describe how a protection domain can grant permissions to another protection domain. Ownership conveys unlimited export permissions, but non-owner protection domains can have restricted export permissions. With this arrangement, an owner protection domain can give another protection domain (e.g., protection domain X) read-write access permissions on a buffer, but limit it to read-only export permissions. Software associated with protection domain X can read and write the buffer, but cannot grant read-write permissions on the buffer to another software portion associated with a third protection domain Y. The memory supervisor  can implement a limited form of export permissions, based on ownership and access permissions. An owner can export permissions freely, while a non-owner can export only up to its access permissions level.","Dynamic memory allocation can still be managed by a software kernel. This allows main kernel allocators to remain outside the memory supervisor , and lets the kernel retain custom memory allocators, i.e., allocators that manage their own free list such as the Linux \u201cinode\u201d allocator. The memory supervisor  can provide special API calls (e.g., perm alloc and perm free) to support allocators, which provide memory to other protection domains. A protection domain (e.g., protection domain X) can call an allocator protection domain (e.g., protection domain Z), and, in response, the allocator protection domain can determine the start address and length of the memory that X will receive. The allocator protection domain can then call the memory supervisor  to establish permissions for the protection domain X on the memory it has chosen. The memory supervisor  determines that the permissions are for the protection domain X by reading the cross-domain call stack , so it cannot be fooled by a misbehaving allocator. An allocator protection domain can either own the memory it allocates, which is the fast path used by so-called slab and page allocators, or it can have export permissions, which is used by custom allocators because they do not own the memory they allocate; they get it from the slab or page allocator.","The memory supervisor  can also be responsible for managing thread-local stack permissions. Threads can only change control permissions in their active frame, and the memory supervisor  can reject permission change requests for memory between the most recently saved frame base, fb , and the stack base, sb . If a thread grants write permission on a frame, it must revoke permissions on the frame before the frame returns. On scheduling events, the kernel instructs the memory supervisor  to save and reload the thread-local CPU registers (sb , fb , sl , CDST , and the stack table base register )","The memory supervisor  can manage the creation and deletion of protection domains. A protection domain can create a new protection domain by \u201csubdividing,\u201d and passing ownership of a region of its own memory to the new child protection domain. The memory supervisor  can track parental relationships between protection domains. When a protection domain is deleted, ownership of its memory regions can pass to its closest ancestor. The memory supervisor  can also revoke permissions on memory owned by the deleted protection domain from all protection domains.","As described above, the memory supervisor  can provide an API and policies for managing memory ownership and permissions. In one particular embodiment, two calls can be used to set permissions on memory regions. For example, a function \u201cmprot\u201d can set permission values for the current protection domain while a function \u201cmprot export\u201d can set permission values in another protection domain. A function \u201cpd subdivide\u201d can create a new protection domain, while a function \u201cpd free\u201d can delete a protection domain. Memory allocator protection domains can call memory supervisor functions \u201cperm alloc\u201d and \u201cperm free\u201d to give the caller of the allocator access permissions in the memory being allocated.","The memory supervisor policy can follow a few general rules. For example, a non-owner cannot dictate permissions to an owner; a non-owner cannot downgrade the permissions of another protection domain; and a non-owner cannot upgrade its own permissions.","A \u201cgroup\u201d protection domain is a collection of memory regions, each with a specified permission. Group protection domains are useful when multiple protection domains need access to the same set of memory regions, and where the memory segments in that set change over time.","A \u201cregular\u201d protection domain can create a \u201cgroup\u201d protection domain and grant the group access permissions to various memory regions. Another protection domain can then \u201cjoin\u201d the group protection domain to gain the permissions specified by the segments in the group.","Referring now to , protection domains - are each associated with a range of memory addresses . The memory addresses  can be a virtual memory addresses or physical memory addresses. The memory addresses  can include all virtual or physical memory addresses. However, in another embodiment, the memory addresses  include only a portion of the virtual or physical memory addresses.","Crosshatched regions shown in  each represent corresponding segments, each having a respective permission -(i.e., permission value). Permission values -correspond to those shown above in Table 1.","A protection domain, for example, the protection domain , can be associated with more than one software thread. Also, every software thread is associated with exactly one protection domain at any point in its execution. A software program or program portion associated with a protection domain that wants to share data with another software program or program portion must share at least a portion of its address spaces, for example, by having a protection domain with a segment provisioned as read-write.","While permission values -are shown, as described above, the permissions table  () can hold metadata values arranged as the protection domains, where the metadata values each include, but are not limited to, a respective permission value. The metadata values stored in the permissions table  can also include other information, for example, a cache coherence state value, a not-cached state value, a cached-exclusive state value, a cached-modified state value, and a cached-shared state value. Therefore, it will be apparent that, in other embodiments, the protection domains - can be associated with both the permission values -as well as with other information.","Each memory region of a protection domain having a contiguous permission value is a protection domain segment. For example, each of the memory regions - is a segment. Each protection domain can be different, each having permissions set on arbitrary sized memory regions, including memory regions (segments) of one word, or even one byte.","In one particular embodiment, the system and technique for fine-grained computer memory protection uses two-bit permission values, as shown in Table 1 above. In other embodiments, the system and technique can support more than two permission bits or fewer than two permission bits, different permission types, and\/or other information.","Every allocated region of memory, e.g., the memory  of , is owned by one protection domain, and this ownership is maintained by a memory supervisor, e.g., the memory supervisor  of . As described above, to support the construction of protected subsystems, the owner of a region can export protected views of the region to other protection domains.","Some of the protection domains can be generated by the software kernel, while others can be generated, for example, by the memory supervisor  upon request by a software application programs. The memory supervisor , described in conjunction with , manages the protection domains.","Referring now to , an exemplary \u201csorted segment table\u201d (SST) , is but one permissions table structure in which addresses and associated permission values can be arranged (i.e., in the permissions table  of ). One particular embodiment of the SST  includes a linear array of entries, for example, entries , , , each entry a segment ordered by segment start addresses, for example, segment start addresses , , . Segments can be any number of words (or bytes) in length, including, but not limited to, one word (or byte), and start on any word (or byte) boundary, but cannot overlap. In the exemplary embodiment shown, each entry is four bytes wide, and includes a 30-bit start address  (which is word aligned, so only 30 bits are needed) and a 2-bit permission value field . The start address of a next segment is implicitly identified by the end of a current segment, so segments with no permission values can be used to encode gaps and to terminate the list.","In operation, on a PLB miss (PLB , ) associated with a program address , a binary search  is performed in the SST  to locate a segment containing an address for which the search is conducted. The SST  is a compact way of describing and storing addresses  and associated permission values  in the permissions table  (), especially when the number of segments is small. However, when the number of segments is large, the binary search of the SST  can take many steps in order to locate a segment. Also, because the segments are contiguous, they must be copied, i.e., moved, when a new permission value is inserted. Furthermore, the SST  can only be shared between protection domains in its entirety, i.e., two protection domains have to have identical permissions maps.","It should be apparent that entries in the permissions table  () encode both address ranges and permission values associated with each of the address ranges, wherein the address ranges are associated with the memory  of .","Referring now to , a \u201cmulti-level permissions table\u201d (MLPT) provides an alternate permissions table structure in which addresses and associated permission values can be arranged (i.e., in the permissions table  of ). An MLPT address , forming a part of the MLPT entries in the permission table , includes a root index , a mid index , a leaf index , and a leaf offset . An MLPT lookup algorithm, shown below, can be used to perform a lookup within MLPT addresses in the permissions table .","Below is shown pseudo-code for the MLPT lookup algorithm described above.\n\n","}","return e;","}","The exemplary MLPT address  has thirty-two bits. In one particular embodiment, entries in the root index map to 4 MB blocks. Entries in the mid index map to 4 KB blocks. Entries in the leaf index map to sixty-four byte blocks. Entries in the leaf offset map to individual bytes, of which there are sixty-four. The MLPT address  can reduce space usage in the permission stable  by sharing lower level tables across different protection domains that share the same permissions map.","An MLPT structured permissions table (e.g., permissions table ) having an MLPT address  is indexed with an address and returns a permissions table entry, which, in one particular embodiment, is a vector of permission values, also stored in the permissions table . Permission vectors are described below in conjunction with . The base of the root index is held in a dedicated CPU register, e.g., the permissions table base register ().","The MLPT can form a trie structure, for which the root index points to and provides an index into a first level table stored in the permission table . The first level table indexed by the root index can point to a second level table indexed into by the mid index . The second level table indexed by the mid index can point to a third level table indexed into by the leaf index and by the leaf offset . The third level table indexed by the leaf index can provide the permission values, for example, as a permission vector. The leaf offset can index into the permission vector identified by the leaf index in the third level table to provide a permission value associated, for example, with a particular word of the memory  (). However, in an alternate embodiment, an entry in the third level table can instead provide a pointer to a record having permission values, which is held in an area of operating system memory dedicated to such overflow records.","The entries in the first, second, and level third tables can be either pointer entries to another table or a permission value entry. The two types of entries are distinguished more fully in conjunction with . However, let is suffice here to say that any of the first, second, and third level tables can provide permission values, each at different granularity. For example, in one particular embodiment, if a permissions value entry is found in the first level table, the granularity of the permissions value entry can be 4 MB or less, if a permissions value entry is found in the second level table, the granularity of the permissions value entry can be 4 KB or less, if a permissions value entry is found in the third level table, the granularity of the permissions value entry can be sixty-four bytes (sixteen words) or less. However, in other embodiments, the first, second, and third level tables can have more than or less than the granularities described above. In still further embodiments, more than three or fewer than three levels of tables can be provided.","Referring now to , a leaf level MLPT permission entry can be provided, for example, in a permission vector format, each vector having, for example, sixteen two-bit values indicating the permissions for each of sixteen four-byte words.","An exemplary address space  having four-byte words is associated with segments -collectively referred to as segments . Permission vectors , , each contain sixteen permission values, each permission value having two bits (see Table 1), and each permission value associated with a four-byte word in the address space .","Segments , each corresponding to a group of contiguous addresses having the same permission value, are represented with the tuple <base addr, length, permissions>, for example <0xFFC, 0x50, RW>. Addresses and lengths are given in bytes unless otherwise noted, and a word is four bytes long. A user segment <0xFFC, 0x50, RW> is broken up between three permission vectors, only the latter two ,  of which are shown.","An address range \u201cowns\u201d a permissions table vector entry if looking up any address in the range finds that vector. For example, an address range 0x1000-0x103F owns the first permission vector entry .","The permission values \u201c00\u201d in the permission vector , corresponds to the segment , having a no-permission value as identified in Table 1.","Permission vectors ,  are shown to contain permission values, each associated with one word in the address space . However, as described above for the first, second, and third level tables associated with the MLPT address  of , permission vectors can be provided that identify other permission values each associated with more than one word in the address apace . For example, a permission vector pointed to by an address in the mid index () can represent individual permissions for eight 512 byte sub-blocks within the 4 KB block mapped by a mid index address entry ","Referring now to , in one particular embodiment, upper level permissions table entries , for example, a first type of entry  in the MLPT, can include a pointer to a lower level table. However, to reduce space and run-time overhead for large user segments, another type of upper level permissions table entry  can hold a permissions vector for a group of sub-blocks, for example, for eight sub-blocks. The two types of permissions table entries can be identified, for example, with a single bit , ","In one particular embodiment, described in conjunction with  above, entries in the first level table, indexed, for example, by the root index of , and in the second level table, indexed, for example, by the mid index of , include either pointer entries (e.g., ) or permission vectors (e.g., ) and are therefore encoded as shown in . However, in one particular embodiment, entries in the third level table, indexed, for example, by the leaf index of  include only permission vectors (e.g., ), and therefore, the third level table can use a different encoding (not shown) in which all thirty-two bits are used to encode permission values (2-bits each) for sixteen sub-blocks (i.e., words) rather than eight.","Although permission vectors representing permission values for sixteen word portions of an address space as described above provide a simple format for MLPT permissions table entries, they do not take advantage of the fact that most user segments are longer than a single word. Also, the upper level permissions table entries , ,  can be inefficient at representing non-power-of-two sized user segments.","The sorted segment table (SST)  described in conjunction with  demonstrates a more compact encoding for abutting segments, wherein only segment base addresses and associated permission values are needed because the length of one segment is implicit in the base of the next. A mini-sorted-segment table (mini-SST), described below in conjunction with , uses the same technique to increase the encoding density of an MLPT table entry having permissions values.","While two types of permission table entries ,  are shown, other types of permissions table entries are shown and described in conjunction with  and Table 2 below.","Referring now to , a mini-sorted-segment table entry , or mini-SST entry, provides an alternate structure in which addresses and associated permission values can be arranged (i.e., in the permissions table  of ). The mini-SST entry  includes both addresses and permission values. In one particular embodiment, address bit encoding can represent up to four segments, a \u201cfirst\u201d segment , a \u201cmid\u201d segment , a \u201cmid\u201d segment , and a \u201clast\u201d segment , each having an offset value and a permission value with a number of bits as indicated in parentheses. Starting offset addresses and permission values are given for each of four segments, allowing lengths of the first three segments (first , mid , and mid ) to be implicit in the starting offsets of an adjacent segment. Length, \u201clen,\u201d of the last segment is explicitly encoded. In one particular embodiment, three of the offsets have four bits and one of the offsets has five bits as shown. The exemplary mini-SST entry  describes four segments corresponding to a size of heap allocated objects, which is usually greater than 16 bytes. However, in other embodiments, the mini-SST entry can also describe more than four or fewer than four segments.","Mini-SST entries encode permission values for a larger region of memory than sixteen words (or sixteen sub-blocks) described above in conjunction with . The first segment has an offset, which represents its starting point as the number of sub-blocks (-) before the base address of the owning range of the mini-SST entry . Segments mid and mid , , respectively, begin and end within 16 sub-blocks associated with the mini-SST  entry. The last segment can start at any sub-block in the mini-SST entry  except the first (a zero offset means the last segment starts at the end address of the entry). The last segment has an explicit length, \u201clen,\u201d that extends up to 31 sub-blocks from the end of the owning range of the mini-SST entry . The largest address span for the mini-SST entry  is seventy-nine sub-blocks (thirty-one before, sixteen within, thirty-two after).","The mini-SST entry  reserves two bits for a \u201ctype\u201d value . Table 2 below shows four possible type values . A first type value, 00, indicates that an entry is a pointer to a lower level table (e.g., , ). A second type value, 01, indicates that the entry is a mini-SST entry, indicating permission values for four segments as described above. A third type value, 10, indicates that the entry is a permissions vector (e.g., , ). A fourth type value, 11, indicates that the entry is a pointer to a mini-SST entry.",{"@attributes":{"id":"p-0124","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"00","Pointer to next level table."]},{"entry":[{},"11","Mini-SST entry (4 segments spanning 79 sub-blocks)."]},{"entry":[{},"01","Pointer to permission vector (16x2b)."]},{"entry":[{},"10","Pointer to mini-SST+ (e.g., translation (6x32b))."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Upper level tables can contain pointers to lower level tables. Any level table can have a mini-SST entry. Any level can contain a pointer to a vector of permission values, which are described above in conjunction with . This is necessary because mini-SST entries can only represent up to four abutting segments. If a region of memory contains more than four abutting segments, the permission values can be represented using a permission vector held in a separate word of storage, and pointed to by the entry. Also, a pointer can be used to point to a mini-SST entry and also to additional information.","While four types of table entries are shown in Table 2, it will be recognized that, in one particular embodiment described above in conjunction with , the third level table, which is the lowest level table, can also have a different encoding (not shown) in which all thirty-two bits are used to encode permission values (2-bits each) for sixteen sub-blocks (i.e., words).","Table 2 shows but some of the different possible types of entries that can be associated with the permissions table  of . It should be apparent, as described in conjunction with , that leaf tables, i.e., the third, or lowest, level table in the MLPT trie structure, do not have a type 00.","A mini-SST entry, e.g., , in the permissions table  () can be used to increase the encoding density of an individual MLPT entry permission vector entry in the upper levels of the MLPT trie structure containing only eight sub-blocks. The mini-SST entry  allows more sub-blocks to be represented by each mini-SST entry, but only for a limited number of segments. In one particular embodiment, a mini-SST entry  can represent seventy-nine sub-blocks but only four segments, each segment having a respective contiguous permission value. In contrast, the permissions vector entry can represent permission information for only up to sixteen sub-block (i.e., words) at the third, or lowest, level table, and only eight sub-blocks at the first and second level tables, as described above. For example, as described above, each permissions vector associated with a respective mid index address of  can represent individual permissions for eight 512 byte sub-blocks within the 4 KB block mapped by a mid index address entry ","In the mini-SST format, entries in a root table, which is the first level table, can contain permissions for all 4 GB of the 32-bit address space, entries in a mid level table, which is the second level table, can contain permissions information for 79*256 KB=19.75 MB, and entries in a bottom level table, which is the third level table, can contain permissions information for 79 words=316 bytes. While each entry can hold permissions information for a large piece of the address space, the entries will overlap if they hold permissions for more than 4 MB\/4 KB\/64 B of address space (for each level table).","Referring now to , an example of use of a mini-SST entry is shown. Segments , , , collectively referred to as segments , are labeled for illustrative purposes using a tuple, <base, length, permission >. Segment lengths shown in parentheses are represented implicitly as a difference in the base offsets of neighboring table segments, and are therefore redundant in the illustrated labeling.","A segment owned by the address range 0x1000-0x103F has segment information going back to 0xFFC and going forward to 0x104C. The segment mapped by the mini-SST entry at address range 0x1000-0x103F has been split across \u201cfirst,\u201d \u201cmid,\u201d \u201cmid,\u201d and \u201clast\u201d mini-SST segments . Therefore, single segment can be represented by a mini-SST entry . Segments , , , can be represented by the mini-SST entry .","Mini-SST entries in the permissions table  () can contain overlapping address ranges. When an entry owned by one range is changed, any other entries which overlap with that range might also need updating. For example, if part of the user segment starting at 0xFFC is freed by protecting a segment as <0x1040, 0xC, NONE>, it would be necessary to read and write the entries for both 0x1000-0x103F and 0x1040-0x107F even though the segment being written does not overlap the address range 0x100-0x103F. When a memory segment is modified, all entries overlapping the modified segment must also be flushed from the PLB  ().","The protection lookaside buffer (PLB)  () caches entries form the permissions table  (). The PLB  can use a ternary content addressable memory (CAM) structure to hold address ternary tags that have a varying number of significant bits. The PLB tags have to be somewhat wide, for example, 26 bits, to support fine-grain addressing. Entries in the PLB  are also tagged with protection domain identifiers (PD-IDs).","The ternary tags stored in the PLB  can contain additional low-order \u201cdon't care\u201d address bits to allow the tag to match addresses beyond the owning address range. For example, the tag 0x10XX, where XX are don't care bits, will match any address from 0x1000-0x10FF. On a re-fill of the PLB , the tag is set to match addresses within the largest naturally aligned power-of-two sized block for which the entry has complete permissions information. Referring to the example in , a reference to 0x1000 will pull in the entry for the block 0x1000-0x103F and the PLB tag will match any address in that range. A reference to 0x1040 will bring in the entry for the block 0x1040-x107F, but this entry can be stored with a tag that matches the range 0x1000-0x107F because it has complete information for that naturally aligned power-of-two sized block. This technique increases effective PLB capacity by allowing a single PLB entry to cache permissions for a larger range of addresses.","When permissions are changed for a region in the permissions table , it is often necessary to flush out-of-date entries in the PLB . To avoid excessive flushing of the PLB , a ternary search key can be used for the CAM tags to invalidate potentially stale entries within one cycle. The ternary search key has some number of low order \u201cdon't care\u201d bits, to match all entries in the PLB  within the smallest naturally aligned power-of-two sized block that completely encloses the segment being modified (this is a conservative scheme that may invalidate unmodified entries that happen to lie in this range). A similar scheme is used to avoid having two tags hit simultaneously in the PLB CAM structure. On a PLB refill, all entries that are inside the range of a new tag are first searched for and then invalidated using a single search cycle with low-order \u201cdon't care\u201d bits.","Referring now to , a sidecar register  (see also , ), which holds information for one segment, is associated with each address register, for example, the address register  (see also , ). The exemplary sidecar register  includes a validity value having one bit, a base value having thirty-two bits, a bound value having thirty-two bits, and a permission value having two bits. The base value and the bounds value identify a segment having the permission value . Exemplary permission values are identified above in Table 1.","The program counter  () also has its own sidecar register (e.g., , ) used to provide permission values associated with instruction fetches.","On a request to the sidecar register , i.e., with a \u201cdemand address\u201d , that results in a sidecar register miss, i.e., the demand address is not found in the sidecar register , the demand address is looked up in the PLB , and the sidecar register  is loaded with the validity value , the base value , the bounds value , and the permission value associated with the corresponding entry in the PLB .","On a request to the PLB  associated with a \u201cdemand address\u201d that results in a PLB miss, i.e., the demand address is not found in the PLB , the demand address is looked up in the permissions table  (), and a protection domain associated with demand address is returned and entered into the PLB  (). A corresponding validity value , base value , bounds value , and permission value are loaded into the sidecar register .","The address base and bounds , of a memory segment can be extended to maximum length (e.g., thirty-two bits) in the sidecar register  to facilitate fast checking of the base and bounds. For each access to memory  () with a demand address, e.g., , by the CPU  (), the demand address is compared against the base and bounds in the sidecar register . If the demand address lies within the range, the sidecar permission value is used to identify the type of memory access that is available.","As described above, if the above range check fails or if the validity value indicates an invalid condition, the contents of the sidecar register are deemed invalid, the PLB  is searched for the correct permissions information, and the sidecar register  is re-loaded from the PLB . If the request to the PLB  results in a PLB miss, then the PLB  and one of more of the sidecar registers  () are re-loaded from the permissions table  ().","As described above, a segment corresponds to a range of contiguous memory addresses, each of which has the same permission value. Use of the sidecar registers  () increases permissions hit rate because they each hold information associated with an entire segment. Any demand address that is within the range of contiguous memory addresses identified in the sidecar register will return a permission value upon a request the sidecar register.","A request to the PLB  may not be as efficient as a request to one of the sidecar registers . In one particular embodiment, the PLB  can identify permission values for only a part of a segment, because its index range is aligned with a power-of-two sized block. For example, referring to , a reference to 0x1040 will load the segment <0xFFC, 0x50, RW> into the sidecar register . If location 0xFFC is the demand address , the result will be a permission value hit from the sidecar register . However, requesting the address 0xFFC to the PLB  will result in a permissions value miss because it only indexes the range 0x1000-0x107F.","Each of the sidecar registers  () can be invalidated by way of the validity bit , for example, by the memory supervisor  (), when any protection values are changed. Sidecar registers  can also be invalidated on protection domain switches, e.g., during cross-domain calls. However, as described above, the sidecar registers  can be refilled rapidly from the PLB .","If the permissions table  () is modified, any process that caches data from the permissions table  must be notified so it can invalidate its sidecar registers  (e.g., by the validity value ) and so it can also invalidate one or more portions of information held in the PLB .","Referring now to , a cross-domain call includes a source software portion  operating in association with a source protection domain PD-ID A , and a destination software portion  operating in association with a destination protection domain PD-ID B . Upon the cross-domain call, a software thread can move between the source software portion  and the destination software portion . The cross-domain call can be initiated by any control flow instruction, for example, by a subroutine call instruction. An address in the source software portion associated with a source of the call is marked with a switch gate, having switch gate values. Similarly, an address in the destination software portion associated with a return from the call is marked with a return gate, having return gate values. Switch gates having switch gate values and return gates having return gate values are stored in the gate table  (). The switch gate values and return gate values are described in conjunction with .","When the software thread moves between protection domains, a cross-domain call stack  can be used to keep track of the protection domain context to be used during and after a software call. The cross-domain call stack  can be the same as or similar to the cross-domain call stack  of .","During program execution, software instructions are processed to determine if they are associated with a switch gate or with a return gate. When a switch gate is detected on a subroutine call from the source software portion  to the destination software portion , the hardware  () pushes a return address and the source PD-ID onto the cross-domain call stack .","When a return gate is detected in the destination software portion , the cross-domain call stack  is popped, finding the return address and protection domain of the source software portion . The system  checks the return address against the return address being used by the return instruction.","Referring in more detail to the specific example shown in , PC-PC indicate the contents of a program counter, for example the program counter  of , during four parts of a cross-domain call. Each of the  correspond to a respective one of the four parts of the cross-domain call, also identified by the program counter PC-PC. Two different states of the cross-domain call stack  are shown, where first state is the same as first state and second state is the same as second state. The first state , occurs at PC and PC, respectively, and the second state , occurs at PC and PC, respectively. The CDST register  () points to locations , when in the first state and to locations , when in the second state.","As an initial condition shown in , it is assumed that a source software portion  operates in protection domain A  before a \u201ccall foo\u201d instruction at PC. The CDST register at points to a location in the cross-domain call stack associated with an earlier call to the source software portion . It is assumed, but not shown, that the source software portion  operating in protection domain A  was earlier called by some other software portion operating in a protection domain X, identified as PD X. At this initial condition, the cross-domain call stack contains the protection domain identifier, PD X, an address, x_ret, which is a return address to the other software portion, and a frame base pointer, fb X.","Upon reaching the call instruction, \u201ccall foo,\u201d in the source software portion , the program jumps to and identifies a switch gate (indicated by a dark box) within the destination source software portion , while still operating in protection domain A. As shown in , the processor switches to protection domain B in accordance with information associated with and provided by the switch gate , and executes the first instruction of \u201cfoo\u201d (at PC) in the destination software portion  in accordance with the protection domain, PD B. The information associated with the switch gate can be acquired, for example, from the gate table  of  and\/or from the gate lookaside buffer  (). Gate information is described in more detail in conjunction with .","The above described identification of the switch gate causes the processor to store one or more of a return address, foo_ret, a frame base, fb A, and a PD-ID, PD A, each associated with the source software portion , generating the second state of the cross-domain call stack . The identification of the switch gate also causes the processor to update the CDST register to point as indicated at ","In , at PC, a return gate is identified and the processor verifies that it is returning to the caller's protection domain at the proper address (PC). The processor can pop one or more of the return address, foo_ret, the frame base, fb A, and the PD-ID, PD A, to return from the call as shown in , leaving the cross-domain call stack  once again in the first state . After the return, the source software portion  again operates in accordance with protection domain PD A.","As described above, in conjunction with return gate , the processor  () checks that the return address matches the saved address popped from the cross-domain call stack .","Referring now to , gate information  stored in the gate table  () and\/or in the gate lookaside buffer  () can include, but is not limited to an address  corresponding to a switch gate or a return gate address, and a switch\/return gate identifier  to identify the type of gate. If the gate information  corresponds to a switch gate, the gate information  can also include a destination protection domain identifier (PD-ID) .","As should be apparent, both switch and return gates can include more information than regular memory permissions stored in the permissions table  (), and so, can be stored in a separate gate table  () and cached with a separate gate lookaside buffer (GLB)  (). The number of gates, even for a large system, can be relatively low (e.g., less than 1,000), because software modules tend to have many more internal functions than exported entry points. In one particular embodiment, the gates can be stored in an open hash table to allow rapid retrieval on a GLB miss.","The memory supervisor  () saves and restores the CDST register  () on a context switch. Though only one cross-domain call stack  () is shown, for operating systems that maintain a kernel stack per process, each process can have has its own cross-domain call stack.","The cross-domain call stack  () is within the memory  (), and, in one particular embodiment only the memory supervisor  () can access it. During execution, hardware checks the destination PC  () of every instruction fetch for an associated switch or return gate. As described above, if a switch gate is encountered, a call state is saved on the cross-domain call stack  (decrementing the CDST register  ()) and operation resorts to a new protection domain (i.e., the PD-ID is changed, along with the base pointer () to the protection domain's permissions table). If a return gate is encountered, the CPU  () reads (i.e., pops) the cross-domain call stack  () to find the saved return address, then adjusts the CDST register  accordingly. The return address for the return instruction is checked against the saved address. If the address check succeeds, the protection domain is changed to the stored value and execution resumes at the return address. If the address check fails, the hardware generates a protection fault and execution resumes in a memory fault handler (not shown).","As described above, the CPU  () executes return gates in the destination software protection domain, which can cause problems if software running in a protection domain calls a function that it also exports. Consider, for example, a function \u201ckmalloc.\u201d The core kernel exports this routine to modules, so it must place a return gate on its last instruction. If the kernel were to call the \u201ckmalloc\u201d function via a regular function call, the instruction with the return gate would fault because a regular function call does not push the state needed for a cross-domain return onto the cross-domain call stack. Therefore a protection domain must either mark the entry points to exported functions with a switch gate, or it must duplicate exported functions.","In one particular embodiment, the entry point of exported functions are marked with a switch gate as described above, avoiding the task of classifying function calls as protection domain crossing and non-protection domain crossing. With this particular arrangement, the number of cross-domain calls is increased. However, cross-domain calls that do not actually change PD-ID cause less disruption to micro-architectural caches.  shows a switch from the source software portion  running in protection domain A  to the destination software portion  running in protection domain B . Switch gates are read in the caller's protection domain, e.g., the destination software portion switch gate () is only read by calls originating within the source software portion .","In some embodiments, cross-domain calls require modifications to hardware. For example, in a system where each instruction is checked for the presence of a gate, the instruction cache  () can include an additional \u201cgate-present\u201d bit, as described in conjunction with , indicating that an instruction address has a gate. If this bit is clear, indicating that no gate is associated with the present instruction address, then no further action needs to be taken on a GLB miss. If the bit is set, indicating that a gate is associated with the present instruction address, and the GLB  () misses, the GLB  must be re-filled from the gate table  (). If the bit is set and there is a hit in the GLB , gate values stored in the GLB  are retrieved and used.","Cross-domain calls can be fast because the number of on-chip states that needs to be changed is small during the cross-domain calls. CPU designers can also further accelerate cross-domain calls to enable the benefits of protected execution. For example, traditional CPU micro-architectures flush pipelines on a context switch, imposing a large overhead. In one particular embodiment, protection domain switches can be made considerably faster by associating PD-ID values with each instruction in the pipeline, reducing the need to flush the pipeline.","Referring now to , a stack memory has partitions identified by addresses sb, fl, and sl, held in corresponding stack frame registers  (). A stack region between sb and fb addresses is read-only and a stack region between sb and fb addresses is read-write. The above-described source software portion, i.e., the caller, uses the caller frame between sb and fb addresses and the above-described destination software portion, i.e., the callee, uses the callee frame between fb and sl addresses.","Establishing an activation frame, i.e., the stack memory region between addresses, fb and sl, can be fast, and the permissions for reading and writing in frame can be local to the currently executing thread.","When the kernel schedules a process, it calls the memory supervisor  () to activate the stack for that process, i.e., to generate an activation frame between addresses, fb and sl. The memory supervisor  also places the fb and sl addresses, in the corresponding stack frame registers , (). These registers demarcate a read-write region for the currently executing thread. The hardware allows reads and writes to addresses between sl and fb (stacks grow down so sl>fb). The fb address points to the base of the current activation frame. The memory supervisor  manages the save and restore of the stack frame registers . The memory supervisor  allocates the stack for a given thread, so it can initialize the sl register and validate the fb register.","As described above, on a cross-domain call, the CPU  () saves the current value of the fb addresses to the cross-domain call stack  (), and it copies the current stack pointer into the fb register (). The CPU  also checks that the new fb address is smaller than the old fb addresses, insuring that on cross-domain calls, fb grows down, but not below the sl address. The memory supervisor  insures that when a thread starts executing, the fb register points within the stack memory for that thread. Since cross-domain returns can only set the fb register to a value that was checked by either the memory supervisor  or the CPU , these mechanisms ensure that the fb register always points within stack memory.","The memory supervisor  uses the sb register to mark the region between the fb and sb addresses with read-only permissions. The sb register is not necessary, because the fb and sl addresses provide a read-writable frame. However checking a table is more complicated than checking the base and bounds of two registers, so the sb register provides a useful optimization. The memory supervisor  () initializes the sb register using its knowledge of the size and location of the stack. The supervisor saves and restores the sb register along with fb and sl registers specific to a given thread.","The stack permissions table  () is a thread-local table (not a domain-local table), which allows a thread to pass permissions to successive frames of stack memory, independent of the domain in which a thread executes.","If a called function, i.e. the destination, needs an activation frame, it must request permissions for the stack space, and also make sure that permissions for the frame are exclusive to the current thread. Because protection domains take exclusive access to a frame before executing in the frame, a frame's permissions do not need to be revoked at the end of a function for the caller's safety. A callee that is concerned about security could overwrite its activation frame before returning to avoid leaking information.","Calls to establish a stack frame will be frequent and could potentially be expensive. Stack frame registers  described in conjunction with  can make the creation of a frame fast, and can make permissions to read and write the frame thread-local.","When the memory supervisor (e.g., , ) makes a stack frame current, it can fill the frame base register, fb (), and the stack limit register, sl (). As described above, reads and writes are allowed to addresses between sl and fb (stacks grow down). The value in the fb register points to the base of the current activation frame. Its initial value for a given thread's quantum is specified when a thread manager starts the thread. The memory supervisor  verifies the initial value in the fb register to make sure it is within the stack segment that is being activated. On a cross-domain call, in one particular embodiment, the current value of the fb register can be pushed onto the cross-domain call stack  () as shown also in , and the current stack pointer is made the new value of the fb register . The system  () checks that the new value of the fb register is smaller than the old value. Thus the system  assures that the stack grows down, and the memory supervisor  assures that it starts and ends at the correct location, so the fb register and the sl register can only be used to gain permission to read and write stack memory. The registers become part of the thread state, which must be saved and restored.","Heap data is owned by a protection domain, so cross-domain sharing of heap data can be accomplished when the caller exports permissions to the callee. Protection domains can set up shared buffers in advance of a cross-domain call. In a producer-consumer relationship, the producer would maintain read-write access on a buffer and flag value, while the consumer has read-only access on the buffer and read-write access on the flag. Once the permissions are established, they do not need to be modified for every call.","Referring now to , a chart  shows how a kernel address space can be split into multiple protection domains \u2212N+M. The protection domain (PD-ID ) is associated with memory supervisor , which can be same as or similar to the memory supervisor  of . As described above, the memory supervisor  manages the permissions table  () and provides an application programming interface (API) to control memory permissions. Functions of the memory supervisor  and memory supervisor API are described by example below, by showing how it would be used during the boot of a modularized kernel.","At system reset, the CPU (e.g., CPU , ) starts running at an instruction reset vector in PD-ID  and a BIOS loads the memory supervisor  into physical memory (e.g., memory  of ) and transfers control to it, letting it know how much physical memory is present. The memory supervisor  establishes a handler for hardware permission faults.","In operation, the system  () checks all processor memory accesses against permission values stored in the permissions table  associated with the current protection domain (except those associated with protection domain ). The memory supervisor  can enforce additional memory usage policies because all calls for permission changes are made via the memory supervisor . The memory supervisor  can reject requests that violate its policy. Just because the memory supervisor exports an API does not mean that all protection domains have permissions to call into it. It is possible to construct a protection domain, which does not have permission to call into the memory supervisor, forcing memory management to happen via another protection domain.","To this end, the memory supervisor  can track protection domain ownership of memory regions in the memory  (). A protection domain can obtain ownership of a memory region from the memory supervisor  after the memory supervisor  allocates a new memory region, or when another protection domain grants ownership of a region. Only software running in a protection domain, which is the owner of a memory region, can grant ownership or revoke permissions associated with the memory region to another protection domain.","Once initialized, the memory supervisor  can create a new protection domain (PD-ID ) to hold code and data for the core of the kernel . The memory supervisor  does not allow a user protection domain to create a kernel protection domain.","To start the kernel, the memory supervisor  first loads a boot loader, which runs in protection domain PD-ID . Initially, the boot loader has no permissions to access the memory  (). In order for the boot loader to run, it needs to execute permission on its code, read and write permissions on its data, a read-write stack, and possibly a read-write heap. The memory supervisor  can provide a software function to establish proper permissions for boot loader execution. The memory supervisor  can then perform a cross-domain call (described above) to transfer control to the boot loader, which now runs in a protected kernel protection domain (PD-ID ).","The boot loader wants to load the core kernel, and therefore, can make a call to a software function of the memory supervisor  for allocation of additional memory space. The memory supervisor  allocates a region of memory and returns a pointer. The memory supervisor  records PD-ID  as the owner of this memory region. The owner of a region can call yet another software function of the memory supervisor  to release a memory region back to the memory supervisor .","Once the core kernel starts running, it can create child protection domains N+1 to M+1 in which kernel modules can run. The core kernel can export permissions for portions of its address space to its child modules using other called software functions, and it can also pass ownership of memory regions to kernel modules to allow them to manage the permissions of their children. A kernel module can directly request the memory supervisor  to allocate memory regions. Also, the core kernel can manage memory usage of its modules. The core kernel can block kernel modules from calling the memory supervisor  by not exporting call permission on the memory supervisor entry points to the kernel modules.","Destination software running in a destination protection domain can transitively export permissions. This allows software running in a calling protection domain to either enforce a policy of only allowing a particular destination software running in a particular destination protection domain (perhaps one containing cryptographically verified code) to implement a function, or allowing the particular destination software running in a particular destination protection domain to subcontract work to other destination software running in other destination protection domains. Transitive permissions are still distinct from ownership because only the owner can return memory to protection domain , and a protection domain that receives transitive permissions cannot revoke permissions from a protection domain higher on the receiving chain.","Protection domains can be created hierarchically, and they can be destroyed hierarchically. The memory supervisor  tracks the entire protection domain hierarchy.","A special case for sharing data is global read-only access, allowing export of data to all protection domains as read-only. When a piece of the memory  () is exported globally, the memory supervisor  adds the corresponding permissions to all existing protection domains. The memory supervisor  also tracks the global export in the protection domains so it can add permissions for this globally exported memory to new protection domains as they are created.","Code and heap data regions can be associated with a protection domain, and are typically owned by one protection domain and exported to others. The stack  () can be managed differently, however, because stacks are used by threads that move between protection domains. In one particular embodiment, the stack  is owned by the memory supervisor  (). To acquire allocation of space in the stack , a thread manager in a protection domain calls a memory supervisor function.","The memory supervisor  only owns and manages the stack space for each thread. Other details about the thread, like its control block and the scheduling policy that govern it, are determined by the kernel or an arbitrary thread-managing protection domain.","Stack permissions are managed and allocated by the memory supervisor , which can make a permissions change on memory that it owns. Of course, the memory supervisor range checks a requested address and refuses action if the request is inappropriate.","When a stack segment is allocated, the memory supervisor  records the creating protection domain and a stack-ID, which is just the base address of the stack segment. When a thread is scheduled, a thread manager must call to the memory supervisor to tell it that a certain stack is now active. The memory supervisor checks that the thread manager has permission to make the stack segment active. When the memory supervisor receives a call to set stack permissions, it checks that the request is for the active stack.","While the memory supervisor  is shown to be associated with one protection domain, PD-ID , in another embodiment, to provide greater robustness and to reduce the size of the trusted code associated with PD-ID , the memory supervisor  can be associated with two or more protection domains. In this embodiment, protection domain , PD-ID , which provides unfettered access to all of the memory  (), only provides permission portions of the memory supervisor  that manage hardware and write to the permissions tables ,  (). Memory supervisor entry points and complex permissions policy management code can be in protection domain , PD-ID .","It should be appreciated that  show flowcharts corresponding to the below contemplated technique which would be implemented in computer system  (). The rectangular elements (typified by element  in ), herein denoted \u201cprocessing blocks,\u201d represent computer software instructions or groups of instructions. The diamond shaped elements (typified by element  in ) herein denoted \u201cdecision blocks,\u201d represent computer software instructions, or groups of instructions, which affect the execution of the computer software instructions, represented by the processing blocks.","Alternatively, the processing and decision blocks represent steps performed by functionally equivalent circuits such as a digital signal processor circuit or an application specific integrated circuit (ASIC). The flow diagrams do not depict the syntax of any particular programming language. Rather, the flow diagrams illustrate the functional information one of ordinary skill in the art requires to fabricate circuits or to generate computer software to perform the processing required of the particular apparatus. It should be noted that many routine program elements, such as initialization of loops and variables and the use of temporary variables are not shown. It will be appreciated by those of ordinary skill in the art that unless otherwise indicated herein, the particular sequence of blocks described is illustrative only and can be varied without departing from the spirit of the invention. Thus, unless otherwise stated the blocks described below are unordered meaning that, when possible, the steps can be performed in any convenient or desirable order.","Referring now to , a method  for providing a permission table, a protection lookaside buffer, and sidecar registers, begins at block , where a range of memory addresses is selected. The PLB can be the same as or similar to the PLB  of  and the sidecar registers can be the same as or similar to the sidecar registers of  of . In one particular embodiment, the selected address range is the full address range of physical memory. In another particular embodiment, the selected address range is the full address range of virtual memory. In other embodiments, the selected address range is a portion of the address range of virtual or physical memory.","At block , words in the selected range of addresses identified at block  are associated with metadata values. Metadata values and associated permission values are described above in conjunction with . The association provided in block  includes providing a permission table in block  and storing protection domains in the permission table at block , each protection domain having one or more segments. The permissions table can be the same as or similar to the permissions table  of .","At block , a protection lookaside buffer (PLB) is provided, which is filled at block  with entries from the permission table. At block  one or more sidecar registers are provided, which are filled at block  with segment information, including, but not limited to, a segment address base, a segment address range, and a permission value. The PLB can be the same as or similar to the PLB  of  and the sidecar registers can be the same as or similar to the sidecar registers of of .","Referring now to , a process  for associating protection domains with software portions begins at block , where a first protection domain is associated with a source software portion. At block , a second protection domain is associated with a destination software portion. It will be understood from discussion in conjunction with , that the source software portion and the destination software portion can correspond, for example, to a source of a software call and a destination of a software call, respectively.","At block , switch gate values are associated with the source software portion, and in particular, to one or more instructions addresses within the source software portion. At block , return gate values are associated with the destination software portion, and in particular, to one or more instructions addresses within the destination software portion.","Referring now to , a method  for providing a gate table and a gate lookaside buffer begins at block  where a gate table is provided. The gate table, gate lookaside buffer can be the same as or similar to the gate table  and the gate lookaside buffer  of .","At block , switch gate values and return gate values are stored to the gate table. At block , the gate lookaside buffer is provided. At block , a portion of the gate table is stored to the gate lookaside buffer.","At decision block , during program execution, an instruction is examined to identify if the program address associated with the instruction has a gate. This examination is described above in conjunction with , and can involve discovery of the gate-present bit in the instruction cache  ().","If, at block , the gate-present bit is not discovered, then upon a GLB miss, at block , the GLB  is not re-loaded from the gate table . If, however, at block , the gate-present bit is discovered, then upon a GLB miss, at block , the GLB  is re-loaded from the gate table .","Referring now to , a method  for providing a cross-domain call as described above in conjunction with , begins at block , where a cross-domain call stack is provided. The cross-domain call stack can be the same as or similar to the cross-domain call stack  of .","At block , a program proceed to a next instruction, and at decision block , the instruction is examined to identify whether a switch gate having switch gate values is detected in association with the instruction. If at block , switch gate values are detected, then the process proceeds to block , where a variety of data are stored, for example to the cross-domain call stack provided at block . For example, one or more of a source software portion memory address, a PD ID associated with the source software portion, and a stack frame base address (e.g., , ) can be stored. The software then operates at block  in accordance with a destination protection domain associated with the destination software portion, wherein the destination protection domain is identified form the switch gate values detected at block .","If at block , switch gate values are not detected, the process proceeds to decision block , where the instruction reached at block  is examined to identify whether a return gate having return gate values is detected in association with the instruction. If at block , return gate values are detected, then the process proceeds to block , where a variety of data are recalled, for example from the cross-domain call stack provided at block . For example, one or more of a source software portion memory address, the PD ID associated with the source software portion, and the stack frame base address (e.g., , ) can be recalled. The software then operates at block  in accordance with a source protection domain associated with the source software portion.","Referring now to , a process  for providing stack permissions begins at block , where a stack base, sb, register is provided. A frame base, fb, register is provided at block  and a stack limit, sl, register is provided at block . The sb, fb, and sl registers can be the same as or similar to the stack frame registers  of .","At block , a first stack permission value is associated with the stack range provided by addresses in the sb and fb registers. In one particular embodiment, the first stack permission value is read-only.","At block , a second stack permission value is associated with the stack range provided by addresses in the fb and sl registers. In one particular embodiment, the second stack permission value is read-write.","Referring now to , another process  for providing stack permissions begins at block , where a stack permission table is provided. The stack permission table can be the same as or similar to the stack permissions table  of . At block , a third address range of the memory stack is identified and at block , a third stack permission value is assigned to the third address range of the stack.","At block , a fourth address range of the memory stack is identified and at block , a fourth stack permission value is assigned to the fourth address range of the stack. At blocks  and , the third and fourth address ranges and the third and fourth stack permission values are stored, for example to the stack permissions table .","Any address within the stack  () can be associated with the first or second stack permission value as provided in  and also with the third or fourth permission value as provided in . In one particular embodiment, if either of the stack permission values associated with an address within the stack  allows access, then the address can be accessed by the currently running thread.","All references cited herein are hereby incorporated herein by reference in their entirety.","Having described preferred embodiments of the invention, it will now become apparent to one of ordinary skill in the art that other embodiments incorporating their concepts may be used. It is felt therefore that these embodiments should not be limited to disclosed embodiments, but rather should be limited only by the spirit and scope of the appended claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing features of the invention, as well as the invention itself may be more fully understood from the following detailed description of the drawings, in which:",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 7","FIG. 1"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 8","FIG. 1"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 9","FIG. 1"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 10-10C"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 11","FIG. 1"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 12","FIG. 1"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 14","FIG. 1"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 16","FIG. 1"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 17","FIG. 1"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 18","FIG. 1"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 18A","FIG. 1"]}]},"DETDESC":[{},{}]}
