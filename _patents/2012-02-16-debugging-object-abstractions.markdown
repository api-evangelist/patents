---
title: Debugging object abstractions
abstract: The claimed subject matter provides for systems and/or methods for debugging a computer-executable file. The computer-executable file may be executing in a first runtime environment and located in a first process. The file may further comprise on object having a proxy in that first runtime environment. One method embodiment comprises the steps of debugging said computer-executable file; detecting a proxy for an object called by said file; decoding said proxy to obtain physical information regarding said object; returning said physical object information; and transforming said physical object information into logical object information. In addition, one embodiment of a system is provided that comprising a debugger, said debugger debugging client code; a proxy decoder, said proxy decoder providing information to said debugger about the object pointed by said proxy; and an abstraction transformation, said abstraction transformation transforming physical expressions of a proxy into higher level logical expressions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262298&OS=09262298&RS=09262298
owner: Microsoft Technology Licensing, LLC
number: 09262298
owner_city: Redmond
owner_country: US
publication_date: 20120216
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","One Embodiment"],"p":["Modern software runtime environments create abstractions when implementing Application Programming Interfaces (APIs). Such abstractions hide the complexity of the system and provide a logical view of the system to the user.","Debugging objects in such modern software runtime environments presents a challenge\u2014as debugging such objects typically executes the code within the context of the application being debugged. As a result, debugging objects in an environment potentially changes the environment.","The following presents a simplified summary of the innovation in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key or critical elements of the claimed subject matter nor delineate the scope of the subject innovation. Its sole purpose is to present some concepts of the claimed subject matter in a simplified form as a prelude to the more detailed description that is presented later.","Some embodiments of the present application provide for systems and\/or methods for debugging a computer-executable file. The computer-executable file may be executing in a first runtime environment and located in a first process. The file may further comprise on object having a proxy in that first runtime environment.","One method embodiment comprises the steps of debugging said computer-executable file; detecting a proxy for an object called by said file; decoding said proxy to obtain physical information regarding said object; returning said physical object information; and optionally transforming said physical object information into logical object information.","In addition, one embodiment of a system is provided that comprising a debugger, said debugger debugging client code; a proxy decoder, said proxy decoder providing information to said debugger about the object pointed by said proxy; and an optional abstraction transformation, said abstraction transformation transforming physical expressions of a proxy into higher level logical expressions.","Other features and aspects of the present system are presented below in the Detailed Description when read in connection with the drawings presented within this application.","As utilized herein, terms \u201ccomponent,\u201d \u201csystem,\u201d \u201cinterface,\u201d and the like are intended to refer to a computer-related entity, either hardware, software (e.g., in execution), and\/or firmware. For example, a component can be a process running on a processor, a processor, an object, an executable, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and a component can be localized on one computer and\/or distributed between two or more computers.","The claimed subject matter is described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the subject innovation. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the subject innovation.","Introduction","It is common practice for software runtime environments to create abstractions over the implementation of the application programming interface (API) provided by that runtime. These abstractions provide the public surface area of the underlying systems implementation. Such abstractions exist to: (1) hide the complexities of the system to consumer software; (2) allow the implementation of a system to vary from the public surface area and (3) provide a more logical view of the system itself.","These abstractions are created using software interfaces that contain functions or methods to be called from client software code to invoke operations on the system. Software interfaces may also provide access to \u201cproperties\u201d that describe the current state of the system. Often times, these properties are implemented using special functions that can get and set desired values. Sometimes, these properties are backed by a simple data field but need not be. For runtime systems that use a function-based model, the properties may be implemented using arbitrarily complex software code.","Viewing the values of these properties of the system, as exposed through the abstractions provided by the API, is one aspect to developing software running in such an environment. Traditionally, debugging objects using a property-based system meant actually executing the underlying property getter code. This approach to debugging is usually called \u201cfunction evaluation\u201d, or \u201cfunc-eval\u201d. Because the actual code implementing the property is executed within the context of the application being debugged, this approach may not be desirable for several reasons: (1) since the debugger is injecting calls into the \u201cdebuggee\u201d (i.e., the process, code and\/or application being debugged) process at random points within the execution of the debuggee process, the system or debuggee may not be able to execute the call to the property getter. Therefore, values of properties may not be visible in the debugger, or inspecting them may result in debuggee corruption; (2) if the system contains objects that depend on more threads than the one being inspected, func-eval based inspection may not work. For instance, if the property being evaluated has affinity to a specific thread and is inspected from the wrong thread, inspecting that property can lead to deadlocks or debuggee corruption; (3) any side effects in the implementation of the property getter may persist in the application; (4) constraints of the runtime environment may have to be violated in order to make the call to the property getter. For instance, exception unwind information may be incorrect at the time the call is made; and (5) the debuggee process should be in a good enough state to actually evaluate the property getter. For instance, if the debuggee process is near an out-of-memory condition, or is corrupt enough that threads do not run, debugging the system becomes difficult.","Conventional debuggers read values directly from the debuggee application. However, the debuggee may call objects that are not in the debuggee's process. In general, an out-of-process object refers to an object (and\/or an application) that is called or caused to run by a host object in one process; but that runs in a memory space that is different from a host object and its process. The debuggee may contain \u201cproxies\u201d (e.g., an interface) that point to objects that are out-of-process to the debuggee.","In one embodiment, native code debuggers have depended on another model for inspecting debuggee state: out-of-process inspection\u2014e.g., wherein the debuggee is out-of-process to the debugger. When the debuggee is out-of-process to the debugger, data values that represent the state of the application are read out of the debuggee process memory without executing code within the debuggee process. This model may increase the reliability of inspecting debuggee process state because obtaining the values may not depend on executing code within the debuggee process at random points. This model may be desirable as: evaluation may not depend on the stability of the debuggee, side-effects of evaluations may not persist, debuggees may not be corrupted by the debugger, and offline (dump) scenarios may work.","However, the out-of-process inspection model may have several areas for improvement: (1) the abstractions created in the public API (specifically properties) may be lost. Thus, the end-developer debugging code running on such a runtime may have to understand enough of the implementation details of the platform to mentally rebuild the abstraction from the underlying raw data; (2) such rebuilding of the abstraction may not be possible if the value is calculated when the property is called or no underlying data exists; and (3) distributed objects running in another software context or process, may be opaque to the debugger. One example of such opaqueness is proxy objects and\/or interfaces that stand in for real implementations; but route calls across a protocol to another process.","One embodiment of a debugger made in accordance with this present application may comprise a debugging methodology of an application on a system using a property-getter model where such property-getter model may use the out-of-process inspection of objects avoiding the limitations of the func-eval model\u2014while allowing the platform's original abstraction to be accurately modeled, as well as removing the opaqueness of proxied objects being inspected in such a system.","To give perspective,  depicts one aspect to the complexity of the modern software runtime environments. Multiple processes\u2014e.g., Process A () and Process B ()\u2014may be executing on one or more computing processors\u2014e.g., , , . . . , . Each of these computing processors may be in communication with a subset of each other\u2014either directly or indirectly. Each process\u2014such as Process A\u2014may comprise a number of runtime environments (through ). Each such runtime environment may be executing on a number of processors. Each of these runtime environments may comprise client code or other objects, such as proxies, as described further herein. These and other objects should be effectively tracked by any debugger called to debug client code.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2","b":["204","204","206","208","204"],"i":["a","a"]},"Debugger Embodiment","One embodiment of a debugger () may employ a debugger-object inspection model based on out-of-process inspection. Debugger  of the present application may comprise a debugger  (perhaps a native code debugger, a managed debugger, a script debugger or any other suitable debugger); an optional abstraction transformations  and proxy decoder . Debugger  reads memory for values during the course of its debugging the client code. During the course of debugging, debugger  may detect that objects are referenced by the client code that may be in a second (i.e. different) runtime environment than the first runtime environment (but possibly in the same process) that contains the client code. At other times, debugger  may detect that objects are referenced that are not only in a different runtime environment\u2014but may also be out-of-process to the client code. Occasionally, these object references may comprise calls to proxies for implementations that are in a different runtime environment than\u2014and possibly, out-of-process to\u2014the client code.","Abstraction transformation  may optionally be called and used to convert the raw fields of objects within the system into a logical higher level view of the public abstractions provided by that system. Proxy Decoder  may affect a method and\/or mechanism of decoding opaque proxies to objects running within another software context\u2014such as apartment or process. In addition, it may be desired that the debugger display decoded proxy objects within the context of the proxy itself\u2014again perhaps using an out-of-process based debugger inspection model.","Object Abstractions","Out-of-process debugger inspection of an object uses the ability of a debugger to directly read the underlying data for an object out of debuggee memory. The debugger finds the object in question using the state of the debuggee process and the \u201cdebug information\u201d for the type. An example of such debug information is the Program Database file (PDB) created by current compilers. The PDB defines (among other things) the physical structure of the layout of memory for a class as well as source code names for each piece of data contained within the class. However, in practice, the actual data fields backing the object often do not match up with the properties from the public abstraction of a class. Therefore, the developer should understand the details of the object in order to transform the implementation of the object into the logical view. In one embodiment, the debugger may perform an extra step before presenting the view of a property getter based object to the end developer. This transformation uses information provided by the developer that created the object, to transform the physical view of the object into the logical view.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},"At step , the type of the physical object is determined from the debug information. The debugger searches the transforms for one that matches this type taking version information of the type into account at step . In one implementation of this algorithm, the transformations may be contained within a separate file from the debug information or the debuggee binaries, but it should be appreciated that the transformations may be stored in a variety of known manners.","At step , the system checks to see that for each expression contained within the object being viewed, that each physical expression has been mapped into a logical expression. Transformations exist that inform the debugger how to perform the mapping from physical expression into to a logical expression. These transforms may contain very complex debugger expressions.","The logical expressions should be evaluated by the debugger within the context of the debuggee at  and the object being inspected using out-of-process inspection. The logical view of the expression is displayed to the end user of the debugging process and\/or system at . In addition, the debugger may also choose to expose the physical view of the object to the user as well.","Transformation Example","A simple example of the transformation is as follows. Assume a developer has architected an interface ISquid that contains a single property getter \u201cLength\u201d. Now, assume the concrete implementation of ISquid::Length is calculated by obtaining the sub-lengths of the various pieces of the squid. For instance, it would return the length of the tentacles plus the length of the body, plus the length of the fin that sits on top of a squid's head. In C++, the definition of Length might look like this:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","class CSquid : public ISquid"]},{"entry":[{},"{"]},{"entry":[{},"\u2003private: int m_tenticleLen, int m_bodyLength, int m_finLength;"]},{"entry":[{},"\u2003int Length( ) { return m_tenticleLen + m_bodyLength + m_finLength; }"]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In a typical out-of-process debugger, the end developer would see a view of a CSquid that looks something like this:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003","- squid"]},{"entry":[{},{},"m_tenticleLen : 3"]},{"entry":[{},{},"m_bodyLength : 4"]},{"entry":[{},{},"m_finLength : 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The end developer would understand the implementation of the length property well enough to know that the total length is these three values added together. While this is an easy example, this becomes much harder when the end developer is missing information about the implementation of CSquid because the developer lacks source code for it\u2014as is often the case when debugging code owned by an operating system or third party library. Furthermore, as is often the case, the abstraction laid out may not be anything like the actual physical implementation.","Continuing with this example, the debugger transformation for CSquid would map a logical view of the Length property so the user would see this:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","- squid"]},{"entry":[{},"\u2003Length : 12 (logical length rebuilt using transformation)"]},{"entry":[{},"\u2003Physical View"]},{"entry":[{},"\u2003\u2003m_tenticleLen : 3"]},{"entry":[{},"\u2003\u2003m_bodyLength : 4"]},{"entry":[{},"\u2003\u2003m_finLength : 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"As concrete example, the transformation provided by the debugger might look like this:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","CSquid - seafood.dll version 2.3.4-3.0"]},{"entry":[{},"\u201cLength\u201d = this.m_tenticleLen + this.m_bodyLength + this.m_finLength"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The debugger might interpret this as: \u201cAny time a type named CSquid from seafood.dll version 2.3.4 until version 3.0, is encountered by the debugger, show a property named \u201cLength\u201d whose value is calculated by evaluating the three sub values\u201d. Thus, the public abstraction may now be visible in the debugger.","Distributed Object Inspection","In continued reference to , it is common for objects to span multiple runtime environments within the same process or in multiple processes or even across machine boundaries. In such environments, objects from a different runtime environment may be represented by \u201cProxies\u201d (e.g. , ) to client code () rather than clients having direct access to the objects or protocols themselves. Concrete examples of runtime environments that make use of the proxy model are cross apartment objects in Microsoft's Component Object Model (COM) or .Net Remoting. It should be noted that the client object and server objects may be \u201clogically\u201d separated for some purpose such as thread affinity. A boundary such as a process or machine transition may not exist for this model to be in use. Proxies abstract out the underlying transport mechanism of the runtime transition. Their public interfaces may look substantially identical to the real object but the implementation of the methods route calls across a protocol to the actual implementation object. The protocol may route calls to objects across different \u201cruntime environments\u201d within the same process, to objects in different processes on the same machine, or to objects running on another machine.","In an out-of-process debugger model, proxied objects may be opaque to the end developer. The developer may often only see the shape of the public abstraction but may not see any details of the underlying objects. If a func-eval is performed to see such details, such func-eval may be potentially corrupting when actually executed in the context of the debuggee process. In one embodiment of this application these traditionally opaque objects may be unwrapped and displayed to the end developer without the need for func-eval.","The protocol used to route calls from proxy to implementation should contain target information about the object being called. In the case of an intra-process cross-runtime environment call or cross process call, such target information may comprise: (1) the runtime environment or pointer to the concrete object on target side, and (2) the process that the target object resides in. The proxy object may maintain either contain this information directly, or obtain it from the system using some unique identifier for the proxy\/implementation pair. If the underlying runtime can decode this information using a proxy pointer, the debugger may obtain the physical view of the implementation object from the target runtime environment or process and display that to the end-developer. Furthermore, the abstracted view of the implementation may then be re-created using the transformation model described above. The end-result of such an embodiment is that previously opaque objects may be easily diagnosable without the need for corrupting func-evals.","Continuing on with the example from , assume the client for the ISquid interface and the implementation of CSquid live in different logical runtime environments (e.g. and respectively) within the same process. When a developer looks at a proxy to ISquid in the debugger, all that may be seen is the object's v-table. This is because the proxy does not contain any real data. The v-table is not very useful for diagnosing issues. ISquid proxy view in typical debugger may look like:",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","pSquid - ISquid"]},{"entry":[{},"\u2003v-table"]},{"entry":[{},"\u2003\u2003Length (function pointer to function that routes calls across"]},{"entry":[{},"\u2003network, not real length value)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"When a debugger and runtime support the decoding model, the debugger can ask the runtime to decode the proxy pointer and return the suitable information to find the concrete object. The debugger may then use typical type information contained within the debug information to construct a physical view of the object. In this example, this might look like this in the debugger:",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","pSquid - proxy to CSquid"]},{"entry":[{},"\u2003VTable"]},{"entry":[{},"\u2003\u2003v-table"]},{"entry":[{},"\u2003\u2003\u2003Length (function pointer to function that routes calls"]},{"entry":[{},"\u2003\u2003across network, not real length value)"]},{"entry":[{},"\u2003Proxied Implementation Object (processid:676, threadid:300)"]},{"entry":[{},"\u2003CSquid - 0x12345678 (address of physical squid)"]},{"entry":[{},"\u2003\u2003m_tenticleLen : 3"]},{"entry":[{},"\u2003\u2003m_bodyLength : 4"]},{"entry":[{},"\u2003\u2003m_finLength : 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"This may be a desirable view of the ISquid proxy. The end developer may now see the actual physical backing state behind the object that the pSquid proxy represents.","Next, the debugger may apply a logical transformation to the CSquid implementation object in order to show the view of the abstraction as described above. One embodiment might look like this in a debugger:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","pSquid - proxy to CSquid"]},{"entry":[{},"\u2003VTable"]},{"entry":[{},"\u2003\u2003v-table"]},{"entry":[{},"\u2003\u2003\u2003Length (function pointer to function that routes calls"]},{"entry":[{},"\u2003\u2003across network, not real length value)"]},{"entry":[{},"\u2003Proxied Implementation Object (processid:676, threadid:300)"]},{"entry":[{},"\u2003\u2003CSquid - 0x12345678 (address of physical squid)"]},{"entry":[{},"\u2003\u2003\u2003Length : 12 (logical Length property rebuilt using"]},{"entry":[{},"\u2003\u2003transformation)"]},{"entry":[{},"\u2003\u2003\u2003\u2003Physical View"]},{"entry":[{},"\u2003\u2003\u2003\u2003m_tenticleLen : 3"]},{"entry":[{},"\u2003\u2003\u2003\u2003m_bodyLength : 4"]},{"entry":[{},"\u2003\u2003\u2003\u2003m_finLength : 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The end developer may now have the complete view of the implementation backing the pSquid proxy while being able to see the value of the public abstraction as well as the physical values.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 3","FIG. 2"],"b":["204","1","302","201","210","208","208","206"],"i":["a ","b","a ","b","b"]},"At the time the proxies are created, each proxy\/object pair may be registered with the centralized proxy manager service. Each call from client code to proxy is routed across a channel to the correct implementation (). When the end developer debugs () the client code, the debugger  may see, detect and\/or locate Proxy  () and Proxy  () that may be called by the client code. In one embodiment, debugger  may comprise a native code debugger and a proxy decoder that translates the location of a proxy to the location of its implementations. Once the debugger detects and\/or locates a proxy in client code in the course of debugging, the proxy decoder is called to make such a translation.","The debugger  may pass proxy locations to the Proxy Decoder  at  to pass the locations of the implementations for the proxies (at ) and, in one embodiment, return a suitable set of information\u2014e.g., the thread id, process id, and implementation object of the object. The debugger may use that information to read memory data (at ) within the correct context of the object to obtain and\/or return the physical view of the implementation objects (at ). The debugger consults the abstraction transformations (at ) to convert the physical view of the implementation objects into logical views. The logical (and possible physical) views of the implementation object are displayed to the end developer in the debugger along with the proxy at .","What has been described above includes examples of the subject innovation. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter, but one of ordinary skill in the art may recognize that many further combinations and permutations of the subject innovation are possible. Accordingly, the claimed subject matter is intended to embrace all such alterations, modifications, and variations that fall within the spirit and scope of the appended claims.","In particular and in regard to the various functions performed by the above described components, devices, circuits, systems and the like, the terms (including a reference to a \u201cmeans\u201d) used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., a functional equivalent), even though not structurally equivalent to the disclosed structure, which performs the function in the herein illustrated exemplary aspects of the claimed subject matter. In this regard, it will also be recognized that the innovation includes a system as well as a computer-readable medium having computer-executable instructions for performing the acts and\/or events of the various methods of the claimed subject matter.","In addition, while a particular feature of the subject innovation may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes,\u201d and \u201cincluding\u201d and variants thereof are used in either the detailed description or the claims, these terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Exemplary embodiments are illustrated in referenced figures of the drawings. It is intended that the embodiments and figures disclosed herein are to be considered illustrative rather than restrictive.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
