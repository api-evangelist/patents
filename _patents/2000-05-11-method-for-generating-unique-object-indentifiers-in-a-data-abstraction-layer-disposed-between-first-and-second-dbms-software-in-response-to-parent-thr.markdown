---
title: Method for generating unique object indentifiers in a data abstraction layer disposed between first and second DBMS software in response to parent thread performing client application
abstract: A method in a computer system executing a client application and an OODBMS and an RDBMS software, which system has a storage medium accessible by the RDBMS software and the OODBMS software being accessible by the client application. The method generates unique object identifiers in a data abstraction layer disposed between the OODBMS and the RDBMS software in response to a parent thread created by the client application. The method includes the steps of creating a child thread that has access to the RDBMS software, which child thread is used exclusively for generating object identifier numbers and for returning the same to the parent thread. A unique object identifier table is created, which is maintained by the child thread. In response to a request by the parent thread for a unique object identifier, the child thread generates a finite number of the unique object identifiers and communicates their values to the parent thread. After this, a recording is made in the table of the fact that a finite number of unique object identifiers have been generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06947952&OS=06947952&RS=06947952
owner: Unisys Corporation
number: 06947952
owner_city: Blue Bell
owner_country: US
publication_date: 20000511
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever.","The present invention generally relates to object-oriented programming techniques and in particular to a new and improved method for generating unique object identifiers in a data abstraction layer, which provides an interface between an object-oriented database and a relational database. The new method expedites object instantiation on a data abstraction layer.","A data abstraction layer (\u201cDAL\u201d) effects communication between two disparate software modules. In the environment of the present invention, a DAL provides an interface between the application programming interface (\u201cAPI\u201d) of an object-oriented database management system (or \u201cOODBMS\u201d), such as OSMOS, which is available from the assignee hereof and a relational database management system (or \u201cRDBMS\u201d).","Each time a client application instantiates an object in the object-oriented database, a new OID (Object Identifier) must be assigned to the object. An OID is a unique number pair used to identify a particular object. The number pair comprises the class number of the object and an object number. The smallest unassigned object number for each class is stored within a table (OIDGEN) in the relational database. When a request to generate an OID comes in, the smallest unassigned object number for a particular class within the OIDGEN table is incremented by a constant value. This constant value and the new high value are returned to the request task, which then gains rights to all OID's between the previous smallest OID and the new smallest unassigned OID. This insures that every instantiated object is uniquely identified.","As the smallest unassigned object number for a class is incremented, the OIDGEN table entry for that class is locked. While the OIDGEN table entry is locked, any subsequent requests for generating an OID of this class are not permitted. Instead, subsequent requests are queued until the user application commits its current transaction. Since the request to generate an OID is tied with the rest of the user application's transaction, the OIDGEN table entry is not released until the application completes its transaction. Although generating an OID itself does not take long, a request to generate an OID cannot complete until all previous instantiations of the same class are complete, which does take a long time.","The method of the present invention breaks apart an object instantiation request into two distinct transactions. A separate thread is \u201cfired off\u201d from the original thread, or the original instantiation request. The separate thread simply requests generation of an OID.","By breaking the transaction into two threads, the time spent in locking an OIDGEN table entry is greatly reduced. A request for generating an OID no longer has to wait for all previous user application initiated transactions that contain object instantiations of the same class to complete. The OIDGEN table is locked only for the duration of OID generation. The shortened locking time greatly reduces wait time.","An object of the present invention is to provide an improvement in the performance of object instantiation on Data Abstraction Layers.","An advantage of the method of the present invention is that by reducing contention for rows in the table that tracks unassigned OID values, a substantial improvement in aggregate performance of concurrent object creation by multiple clients results.","These and other objects, which will become apparent as the invention is described in detail below, are provided by a method in a computer system executing a client application and an OODBMS and an RDBMS software, which system has a storage medium accessible by the RDBMS software and the OODBMS software being accessible by the client application. The method generates unique object identifiers in a data abstraction layer disposed between the OODBMS and the RDBMS software in response to a parent thread performing the client application. The method includes the steps of creating a child thread that has access to the RDBMS software, which child thread is used exclusively for generating object identifier numbers and for returning the same to the parent thread. A unique object identifier table is created, which is maintained by the child thread. In response to a request by the parent thread for a unique object identifier, the child thread generates a finite number of the unique object identifiers and communicates their values to the parent thread. After this, a recording is made in the table of the fact that a finite number of unique object identifiers have been generated.","Still other objects, features and advantages of the present invention will become readily apparent to those skilled in the art from the following detailed description, wherein is shown and described only the preferred embodiment of the invention, simply by way of illustration of the best mode contemplated of carrying out the invention. As will be realized, the invention is capable of other and different embodiments, and its several details are capable of modifications in various obvious respects, all without departing from the invention. Accordingly, the drawings and description are to be regarded as illustrative in nature, and not as restrictive, and what is intended to be protected by Letters Patent is set forth in the appended claims. The present invention will become apparent when taken in conjunction with the following description and attached drawings, wherein like characters indicate like parts, and which drawings form a part of this application.","Before proceeding with a detailed description of the method of the present invention a background discussion of object-oriented terminology and repositories would be helpful. This discussion will focus on the terminology used herein. Background information that may be helpful in understanding the present invention may be had by reference to an issued U.S. Pat. No. 5,408,657 entitled METHOD OF IMPOSING MULTI-OBJECT CONSTRAINTS ON DATA FILES IN A DATA PROCESSING SYSTEM by Richard Bigelow and John Thompson, and assigned to the same assignee hereof.","A normal object program stores objects in the computer system's memory. When the program terminates, the memory used by those objects is freed and reused by other programs, making the objects that the program stored transient. An object database stores objects on a computer disk. Since the information on a computer disk remains in existence, even when the computer is turned off, an object database provides the ability to persistently store objects. An object program that uses an object database thus has the option of storing objects transiently or persistently.","An object is an abstract representation of a real-world concept or thing. For example, an object can be used to represent a customer account in a banking application. An object has features, which can be either an operation or a property. An operation defines an action that an object can perform, or an action that can be performed on the object. For example, \u201cmake withdrawal\u201d could be defined as an operation on a customer account object. Properties indicate the state of an object. Every property of an object has a value, and it is the property values that define the state of the object. A property can be either an attribute or a reference. An attribute defines a value that is stored within the object. For example, \u201ccurrent account balance\u201d could be an attribute of the customer account object. The numeric value for the customer's account balance would be stored in the customer account object. A reference is a link or pointer to another object, and implies a relationship to that other object. A reference is typically used when it is desired not to duplicate data. For example, the customer account object could store the customer's name and address as attributes. But, if the customer opened multiple accounts, the customer's name and address would appear in multiple account objects. Therefore, it is desirable to define a separate customer object and place the name and address as attributes of the customer object. The customer account object would then contain a reference to the customer object.","A class is a set of objects with similar attributes and behavior. Every managed object instance has a class association with it. An object is an instance of its class. Stated otherwise, a class is a template of objects of similar nature. A superclass is a managed class from whose specification another class (i.e., its subclass) is derived. Inheritance is the conceptual mechanism by which features are acquired by a subclass from its superclass.","The present invention is described herein as a part of an Object-Oriented\/Relational Database Management System, referred to as OSMOS, which is available from Unisys Corporation, assignee hereof. However, it is pointed out that the present invention is useful in any database management system where it is necessary to employ object identifiers.","Referring now to the drawings and  in particular, a block diagram is shown of a system in which the method of the present invention may be used. A server  is shown coupled to a storage device . The server may comprise any readily available computer on the market today, such as for example the Unisys ES3000, ES5000 or ES7000. The server  is shown executing database software , and at least three separate client applications ,  and . In one example to be amplified hereinbelow, each of the three client applications ,  and  are attempting to access data through the database software , wherein such data is persistently stored in the storage device . A problem can occur when all three client applications are attempting to access data at the same time.","Referring now to , a hardware\/software block diagram further illustrates details of the database software . Client applications , , and  access an object-oriented database that is managed by an Object Oriented Database Management System  (\u201cOODBMS\u201d), such as the OSMOS Object Oriented Database Management System available from the assignee hereof, by means of an API . One embodiment of the present invention, in the form of a Data Abstraction Layer (\u201cDAL\u201d) , which implements the functionality of the OODBMS  using the functionality provided by a Relational Database Management System (\u201cRDBMS\u201d)  by means of another API . Since it is necessary to have an object identifier (\u201cOID\u201d) for every object stored in an OODB, the DAL  is employed for generating unique OID's within the scope of the database. The RDBMS  has direct access to the storage device . It is the function of the DAL  to provide an interface between the OODBMS database  and the relational database . One function of the DAL  is a computer-implemented method for generating unique object identifiers, which will be explained in greater detail hereinbelow.","Referring now to , a diagram illustrating a problem with the prior is shown, which problem is addressed by the method of the present invention. Each of the three client applications ,  and  are making a request ,  and , respectively, for an object identifier (OID) at substantially the same time. According to the prior art, the first to take over is the first to get an OID, as shown by the left-most thread emanating from the request . The OIDGEN table entry is locked from the point in time at which an OID is generated (block ) until a later point in time when the user application commits the user transaction (block ). The user application may perform an indeterminate amount of work between these two points in time, which are under user control. Once the first thread issues a commit, the second thread emanating from the request  now locks the OIDGEN table entry and generates an OID (block ). At this time the second thread is free to perform an indeterminate amount of work followed by a commit to the user transaction (block ). Also, the third thread emanating from the request  performs a lock and generate OID (block ) may perform an indeterminate amount of work, followed by a commit to the user transaction (block ). The time between each of theses actions can be enormous in comparison to processor time.","Referring now to , a diagram illustrating the same problem as shown in  is shown when addressed by the method of the present invention. The same three client applications ,  and  are again making requests for object identifiers (OID's) as represented by blocks ,  and . However, in this example there are three separate lock, generate and commit OID operations (blocks ,  and ) performed independently of the transactions of their respective parent's threads, which are hereinafter sometimes referred to as \u201cchild\u201d threads. The original threads are sometimes referred to hereinafter as \u201cparent\u201d threads. As a result of employing the separate or child threads for generation of the OID's commit user transactions (blocks ,  and ) can now occur almost simultaneously. Because the lock and generate OID operations (blocks ,  and ) are relatively quick, and are separate from the user application controlled transactions, they occur within a few milliseconds of one another in comparison to several seconds as in the prior art technique.","Referring now to  a set of four Petri net diagrams illustrate the operation of the method of the present invention. Before describing these diagrams in detail, a description of a Petri net or diagram may be useful to the reader. A Petri net is represented as a bipartite directed graph. The two types of nodes in a Petri net are called places and transitions. Places are marked by tokens; a Petri net is characterized by an initial marking of places and a firing rule. A firing rule has two aspects: a transition is enabled if every input place has at least one token. An enable transition can fire; when a transition fires, each input place of that transition loses one token, and each output place of that transition gains one token. In modeling, the firing of a transition simulates the occurrence of that event. Of course, an event can take place only if all of the conditions for its execution have been met; that is, the transition can be fired only if it is enabled. For more information on Petri nets, reference is made to a textbook entitled \u201cSoftware Engineering Concepts\u201d, by Richard E. Fairley, published by McGraw-Hill Book Company of New York. Also, Petri nets are described in another textbook entitled \u201cDiscrete Mathematics\u201d by Richard Hohnsonbaugh, published by Macmillan Publishing Company of New York.","As alluded to hereinabove, every object stored in an object-oriented database must have an object identifier (OID) that is unique within the scope of the database. Collectively, the operations depicted in , ,  and  describe a method for efficiently generating such object identifiers. They make use of multi-threading, a thread local storage facility (TLS), thread synchronization primitives as well as a special table (OIDGEN) within the relational database. Analogous functionality could be implemented using multi-processing, shared-memory, process synchronization primitives and the OIDGEN table within the relational database.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5A","b":["20","21","23","60","61"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["ODB1. Create a childEvent object for synchronizing the execution of the child thread. Store a pointer to this object in the Thread Local Storage (TLS) container (pointed to by oidGenCont);","ODB2. Create a parentEvent object for synchronizing the execution of the parent thread. Store a pointer to this object in the TLS container;","ODB3. Set the \u201coperation\u201d member of the TLS container to its \u201cinitialize\u201d state;","ODB4. Set the TLS member variables used to pass \u201cparameter values\u201d corresponding to the \u201cinitialize\u201d state (e.g. server name, database name, user name, user's password);\n        \n        ","ODB5. Signal the childEvent object to indicate that the child thread has work to do and should resume execution if it is currently waiting on its childEvent event."]}}}},"A result of signaling the childEvent in step ODB5 above (transition , ) is that the Control Worker portion of the process () may be allowed to resume execution. The edge leading from the transition  to the Control Worker portion of the process () is denoted by a connector A, and will be amplified further hereinafter in conjunction with the description of . Following the transition , a place  indicates another transition , which includes the following step:\n\n","After this, a place  indicates another transition , which saves the child's thread id in the TLS container ODB7). Next, a place  indicates another transition  to wait on the parentEvent ODB8. The wait is for the child thread to signal that it has attempted to initialize properly and establish its own connection with the database. Note that the transition  must wait for both the place  and a place  in the Control Worker () as denoted by a connector B.","Next, a place  indicates yet another transition , which performs steps ODB9 through ODB12 as follows:\n\n","Referring now to , a Petri net diagram of the Close Database operation of the process is shown. While implementing a user application's request to close an Object Oriented Database (using the OODBMS application programming interface), this operation requests closure of the parent thread's connection to the relational database. It also requests that the child thread close its connection to the relational database. Lastly, it waits for the client thread to terminate. Beginning with a request from the user application through the OODBMS  and its API , a place  controls execution of a transition , which sets the \u201coperation\u201d member of the TLS container (pointed to by oidGenCont) to its \u201cterminate\u201d value.","After this, a place  controls execution of a transition , which signals the childEvent Object that is pointed to by a member variable of the TLS container. This action indicates that the child thread has work to do and should resume execution if the child tread is currently waiting on its childEvent event. At this juncture of the process, a signal is made to the Control Worker portion of the process, as denoted by a connector A, which will be amplified further hereinafter in conjunction with the description of . Following execution of the transition , a place  controls execution of transition , which imposes a wait on the parentEvent. The wait is for the child thread to signal that it has attempted to close its connection with the database. Note that the transition  must wait for both the place  and the place  in the Control Worker () as denoted by a connector B.","Following the above, a place  controls execution of a transition  for joining of the threads by executing the thread package's operation to join the child thread to the currently executing parent thread. Next, a place  controls execution of a transition , which performs the following steps:\n\n","Referring now to , the Create Record operation of the process is illustrated. While implementing a user application's request to create a new object in the object-oriented database of the OODBMS  (using the API ), it is necessary to generate an object identifier whose value is unique within the scope of the entire database. The purpose of this operation is to generate unique object identifiers.","In the Data Abstraction Layer  of the OODBMS , Object Identifiers comprise two concatenated values. The first identifies the class of the object (classId) and the second is a unique value within the class (nextRow). To facilitate computing these unique values, an extra table (OIDGEN) is added to the relational database. This table has a row for each class of the object database that is represented in the relational database. Each row contains the next available unique value for the class.","The parent thread maintains a table of structures (gen). There is one entry in this table for each class in any object-oriented database that is accessed by using the OODBMS . The structures contain two fields. The first is the next row number that is available to the thread (gen[classId]->next) and the second is the number of rows that the parent thread has rights to use (gen[classId]->numberAvailable). Beginning with the user application invoking the object construction API  of the OODBMS , a place  controls execution of a transition , as follows: when the number of available row numbers for a given class allocated to the parent is equal to zero, the following steps are performed:\n\n","Following the above and returning back to the place , execution of the transition  proceeds as follows. When the number of available row numbers for a given class allocated to the parent is greater than zero a place  controls execution of a transition , which executes the following steps:\n\n","Referring now to , a Petri net diagram of the Control Worker operation of the process is illustrated. The purpose of this operation is to provide synchronization between the parent and client threads. This operation provides the primary control routine for the client thread; and, it is basically a simple loop. At the top of the loop it waits for a place  to be marked. When the place  is marked an indication is made that there is a task for the child thread to perform. At the bottom of the loop the transition  marks the place  which signals the parentEvent (as denoted by the connector B) indicating that the child thread has completed the task. The body of this loop determines which operation is being requested and invokes the appropriate operation.","The functionality of the control worker operation is further defined herein below. Beginning with the place  entry is made into a loop that performs the following steps:\n\n","Referring now to , a flow chart is illustrated of the Initialize Operation of the process, which is called by the transition  within the Control Worker operation (). The Initialize Operation opens the client thread's connection to the relational database. The process begins with an enter bubble  followed by a step of un-marshalling the \u201cinitialize\u201d parameters (e.g. database name, user's name, user's password\u2014block ). Next, the child thread invokes the thread package's function that retrieves the identifier of the child thread. This thread identifier value is used to create a database context (block ) for the relational database. After this, an attempt is made to establish the child thread's connection to the relational database (block ) using the API  of the RDBMS . Finally, a step of marshalling a return value that indicates the success or failure of the attempt to establish the connection is made (block ) and the process returns (bubble ).","Referring now to , a flow chart of the Terminate Operation of the process is shown. This operation, which is called by the transition  () closes the client thread's connection to the relational database using the API . The process begins with an enter bubble  followed by a step of un-marshalling the \u201cterminate\u201d parameters (e.g. database name) (block ). Next, a rollback is made of any open transactions on the child thread's connection to the relational database (block ) using the API . After this, an attempt is made to close the child thread's connection to the relational database (block ) using the API . A step of freeing the child thread's database context is made (block ). Finally, a step of marshalling a return value that indicates the success or failure of the attempt to close the relational database is made (block ) and the process returns (bubble ).","Referring now to , a flow chart of the generate Object Identifier (\u201cOID\u201d) is shown. The client thread uses this operation to pre-allocate the right for the parent thread to use a set of sequentially ordered Object Identifiers of a constant size (DALROWSALLOCATED). This operation is called by the transition  (). The operation begins with an enter bubble  followed by a step of un-marshalling the \u201cgenerateOID\u201d parameters (e.g. database name, child context, child connection name, gen) (block ). Next, a transaction is begun within the relational database using the API  (block ). An attempt is next made to fetch the nextRow value from the classId row of the OIDGEN table (block ). The purpose for the step at the block  is to retrieve the largest unallocated object number. The process illustration continues in  as denoted by a connector C.","Referring now to  at the connector C, an inquiry is made as to whether or not the row for classId exist in the OIDGEN table (diamond ). The OIDGEN table contains a row for each class of object stored in the object-oriented database. Each of these rows contain a number field that stores the smallest unassigned object number for each class. As new objects of a given class are created in the object-oriented database the number field of the corresponding (classID) row of the OIDGEN table takes on increasing values. If the OIDGEN table does not contain a row for classID, then the current invocation of generate OID () is a part of the very first creation of an object of the class so the parent's gen[classId] structure is initialized; and, its next field is set to zero and its numberAvailable field to a constant value (DALROWSALLOCATED) (block ). This marshals the return values, which assigns all object numbers between zero and the constant value DALROWSALLOCATED for future use. After this, a new row is created for the classId in the OIDGEN table; and, its nextRow value is set to a constant value (DALROWSALLOCATED) (block ). Following this, a commit is made to the transaction within the relational database (block ). Thus, recording the allocations of object numbers on disk. If un-recoverable errors occurred during any step, a return value is marshaled, which indicates an error condition; otherwise, a return value is marshaled, which indicates a success condition (block ) and a return is made to the user (bubble ().","If there is a row for classId in the OIDGEN table, that is if the answer to the inquiry in the diamond  is yes, then the parent's gen[classId] structure is reset; its next field is set to the nextRow value just fetched from the OIDGEN table; and, its numberAvailable field is set to a constant value (DALROWSALLOCATED) (block ). Next, the classId row of the OIDGEN table is updated; and, its nextRow field is incremented by a constant value (DALROWSALLOCATED) (block ). After this, a commit is made to the transaction within the relational database (block ). The step depicted by the block  is repeated: If irrecoverable errors occurred during any step marshal a return value that indicates an error condition, otherwise marshal a return value that indicates a success condition.","The methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMS, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. The methods and apparatus of the present invention may also be embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates analogously to specific logic circuits.","Although the invention has been described with reference to a specific embodiment, this description is not meant to be construed in a limiting sense. Various modifications of the disclosed embodiment as well as alternative embodiments of the invention will become apparent to one skilled in the art upon reference to the description of the invention. It is therefore contemplated that the appended claims will cover any such modifications of embodiments that fall within the true scope of the invention."],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ONE EMBODIMENT","Object Terminology"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 5A through 5D"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 8A and 8B"}]},"DETDESC":[{},{}]}
