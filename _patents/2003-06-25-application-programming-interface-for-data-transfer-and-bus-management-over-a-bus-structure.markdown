---
title: Application programming interface for data transfer and bus management over a bus structure
abstract: In a first embodiment, an applications programming interface (API) implements and manages isochronous and asychronous data transfer operations between an application and a bus structure. During an asynchronous transfer the API includes the ability to transfer any amount of data between one or more local data buffers within the application and a range of addresses over the bus structure using one or more asynchronous transactions. An automatic transaction generator may be used to automatically generate the transactions necessary to complete the data transfer. The API also includes the ability to transfer data between the application and another node on the bus structure isochronously over a dedicated channel. During an isochronous data transfer, a buffer management scheme is used to manage a linked list of data buffer descriptors. During isochronous transfer of data, the API provides implementation of a resynchronization event in the stream of data allowing for resynchronization by the application to a specific point within the data. Implementation is also provided for a callback routine for each buffer in the list which calls the application at a predetermined point during the transfer of data. An isochronous API of the preferred embodiment presents a virtual representation of a plug, using a plug handle, to the application. The isochronous API notifies a client application of any state changes on a connected plug through the event handle. The isochronous API also manages buffers utilized during a data operation by attaching and detaching the buffers to the connected plug, as appropriate, to mange the data flow.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06901474&OS=06901474&RS=06901474
owner: Sony Electronics Inc.
number: 06901474
owner_city: Park Ridge
owner_country: US
publication_date: 20030625
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This patent application claims priority under 35 U.S.C. \u00a7119(e) of the co-pending U.S. provisional application Ser. No. 60\/208,825 filed on Jun. 2, 2000 and entitled \u201cAPPLICATION PROGRAMMING INTERFACE FOR DATA TRANSFER AND BUS MANAGEMENT OVER A BUS STRUCTURE.\u201d The provisional application Ser. No. 60\/208,825 filed on Jun. 2, 2000 and entitled \u201cAPPLICATION PROGRAMMING INTERFACE FOR DATA TRANSFER AND BUS MANAGEMENT OVER A BUS STRUCTURE,\u201d is also hereby incorporated by reference.","This Patent Application is a continuation application of U.S. patent application Ser. No. 09\/607,134, filed on Jun. 29, 2000, now U.S. Pat. No. 6,631,435 and entitled \u201cApplication Programming Interface For Data Transfer And Bus Management Over A Bus Structure,\u201d which is a continuation-in-part of U.S. patent application Ser. No. 09\/337,057, filed on Jun. 21, 1999, and entitled \u201cApplication Programming Interface For Managing And Automating Data Transfer Operations Between Applications Over A Bus Structure,\u201d now issued as U.S. Pat. No. 6,243,783, which is a continuation of U.S. application Ser. No. 08\/594,651, filed Feb. 2, 1996, now U.S. Pat. No. 5,991,520, issued on Nov. 23, 1999, and entitled \u201cApplication Programming Interface For Managing And Automating Data Transfer Operations Between Applications Over A Bus Structure.\u201d The U.S. application Ser. No. 09\/607,134, filed on Jun. 29, 2000, and entitled \u201cApplication Programming Interface For Data Transfer And Bus Management Over A Bus Structure,\u201d the application Ser. No. 09\/337,057, filed on Jun. 21, 1999, and entitled \u201cApplication Programming Interface For Managing And Automating Data Transfer Operations Between Applications Over A Bus Structure\u201d now issued as U.S. Pat. No. 6,243,783, and the U.S. Pat. No. 5,991,520, issued on Nov. 23, 1999, and entitled \u201cApplication Programming Interface For Managing And Automating Data Transfer Operations Between Applications Over A Bus Structure\u201d are all hereby incorporated by reference.","The present invention relates to the field of providing an interface for applications to communicate over a bus structure. More particularly, the present invention relates to the field of controlling bus management and data transfer operations between applications over a bus structure in both asynchronous and isochronous formats.","The IEEE 1394-1995 standard, \u201c1394 Standard For A High Performance Serial Bus,\u201d is an international standard for implementing an inexpensive high-speed serial bus architecture which supports both asynchronous and isochronous format data transfers. Isochronous data transfers are real-time transfers which take place such that the time intervals between significant instances have the same duration at both the transmitting and receiving applications. Each packet of data transferred isochronously is transferred in its own time period. An example of an ideal application for the transfer of data isochronously would be from a video recorder to a television set. The video recorder records images and sounds and saves the data in discrete chunks or packets. The video recorder then transfers each packet, representing the image and sound recorded over a limited time period, during that time period, for display by the television set. The IEEE 1394 standard bus architecture provides multiple channels for isochronous data transfer between applications. A six bit channel number is broadcast with the data to ensure reception by the appropriate application. This allows multiple applications to simultaneously transmit isochronous data across the bus structure. Asynchronous transfers are traditional data transfer operations which take place as soon as possible and transfer an amount of data from a source to a destination.","The IEEE 1394 standard provides a high-speed serial bus for interconnecting digital devices thereby providing a universal I\/O connection. The IEEE 1394 standard defines a digital interface for the applications thereby eliminating the need for an application to convert digital data to analog data before it is transmitted across the bus. Correspondingly, a receiving application will receive digital data from the bus, not analog data, and will therefore not be required to convert analog data to digital data. The cable required by the IEEE 1394 standard is very thin in size compared to other bulkier cables used to connect such devices. Devices can be added and removed from an IEEE 1394 bus while the bus is active. If a device is so added or removed the bus will then automatically reconfigure itself for transmitting data between the then existing nodes. A node is considered a logical entity with a unique address on the bus structure. Each node provides an identification ROM, a standardized set of control registers and its own address space.","The IEEE 1394 standard defines a protocol as illustrated in FIG. . This protocol includes a serial bus management block  coupled to a transaction layer , a link layer  and a physical layer . The physical layer  provides the electrical and mechanical connection between a device or application and the IEEE 1394 cable. The physical layer  also provides arbitration to ensure that all devices coupled to the IEEE 1394 bus have access to the bus as well as actual data transmission and reception. The link layer  provides data packet delivery service for both asynchronous and isochronous data packet transport. This supports both asynchronous data transport, using an acknowledgement protocol, and isochronous data transport, providing real-time guaranteed bandwidth protocol for just-in-time data delivery. The transaction layer  supports the commands necessary to complete asynchronous data transfers, including read, write and lock. The serial bus management block  contains an isochronous resource manager for managing isochronous data transfers. The serial bus management block  also provides overall configuration control of the serial bus in the form of optimizing arbitration timing, guarantee of adequate electrical power for all devices on the bus, assignment of the cycle master, assignment of isochronous channel and bandwidth resources and basic notification of errors.","An application programming interface (API) for applications using the IEEE 1394 standard serial bus has been developed by Skipstone for enabling the application to use the IEEE 1394 bus for data transfers. With their API, Skipstone includes a manual entitled \u201cThe SerialSoft IEEE 1394 Developer Toolkit,\u201d available from Skipstone, Inc., 3925 West Braker Lane, #425, Austin, Tex. 78759. Skipstone defines their API as a collection of programming calls to be used by the application to manage data being written to and obtained from a device over an IEEE 1394 bus. To initialize an isochronous transfer, several asynchronous data transfers may be required to configure the applications and to determine the specific channel which will be used for transmission of the data. Once the channel has been determined, buffers are used at the transmitting application to store the data before it is sent and at the receiving application to store the data before it is processed. In a transmitting application, the Skipstone API actively manages the transfer of data from the appropriate portion of the appropriate buffer onto the bus structure, during the appropriate time period. In a receiving application, the Skipstone API actively manages the reception of data from the bus structure, storing the data in the appropriate portion of the appropriate buffer and the processing of the data in the appropriate time period.","During asynchronous data transfers, the Skipstone API actively manages the required transactions to complete the data transfer. During an asynchronous incoming write transaction, the application provides a buffer to the API, mapped to a certain area of the 1394 bus address space. As write transactions arrive at the API, their data is written to the buffer. During an asynchronous incoming read transaction the application is responsible for making sure that the buffer contains useful information. The 1394 bus driver then reads the data from the buffer at the requested address when the read transaction arrives. For both write and read transactions, the Skipstone API actively manages and generates each necessary transaction. For example, if a block of data is being transferred to the application, of a size requiring multiple transactions, the Skipstone API requires the application to describe each 1394 transaction necessary to complete the transfer of the block of data. This consumes significant overhead by the processor of the application as well as the full attention of the API during an asynchronous data transfer operation.","The Skipstone API supports isochronous data transfer operations in a similar way. Specifically, the application must describe each isochronous packet to the Skipstone API. The Skipstone API then transmits each packet at the proper time. This requires significant processor overhead and thereby prohibits efficient processing of the isochronous data by the application.","A block diagram of an exemplary IEEE 1394-1995 serial bus network including a computer system and a video camera is illustrated in FIG. . The computer system  includes an associated display  and is coupled to the video camera  by the IEEE 1394-1995 serial bus cable . Video data and associated data are sent between the video camera  and the computer  over the IEEE 1394-1995 serial bus cable .","A block diagram of the internal components of the computer system  is illustrated in FIG. . The computer system  includes a central processor unit (CPU) , a main memory , a video memory , a mass storage device  and an IEEE 1394-1995 interface circuit , all coupled together by a conventional bidirectional system bus . The interface circuit  includes the physical interface circuit  for sending and receiving communications on the IEEE 1394-1995 serial bus. The physical interface circuit  is coupled to the camera  over the IEEE 1394-1995 serial bus cable . The system bus  contains an address bus for addressing any portion of the memory  and . The system bus  also includes a data bus for transferring data between and among the CPU , the main memory , the video memory , the mass storage device  and the interface circuit .","The computer system  is also coupled to a number of peripheral input and output devices including the keyboard , the mouse  and the associated display . The keyboard  is coupled to the CPU  for allowing a user to input data and control commands into the computer system . A conventional mouse  is coupled to the keyboard  for manipulating graphic images on the display  as a cursor control device.","A port of the video memory  is coupled to a video multiplex and shifter circuit , which in turn is coupled to a video amplifier . The video amplifier  drives the display . The video multiplex and shifter circuitry  and the video amplifier  convert pixel data stored in the video memory  to raster signals suitable for use by the display .","IEC-61883 is a ratified international standard for the transport of audio\/video command requests and responses. This standard uses the concept of plugs and plug control registers to manage and control the attributes of isochronous data flows. It should be noted that plugs do not physically exist on an audio\/video device, but a plug is used to establish an analogy with existing audio\/video devices where each flow of information is routed through a physical plug.","An isochronous data flow flows from one transmitting device, such as the video camera , to one or more receiving devices, such as the computer system , by transmitting isochronous packets on an isochronous channel of the IEEE 1394-1995 serial bus. Each isochronous data flow is transmitted to an isochronous channel through one output plug on the transmitting device and is received from that isochronous channel through one input plug on the receiving device.","The transmission of an isochronous data flow through an output plug is controlled by an output plug control register (oPCR) and an output master plug register (oMPR) located on the transmitting device. The output master plug register controls all attributes that are common to all isochronous data flows transmitted by the corresponding transmitting device. The output plug control register controls all attributes of the corresponding isochronous data flow that are independent from attributes of other isochronous data flows transmitted by the transmitting device.","The reception of an isochronous data flow through an input plug is controlled by an input plug control register (iPCR) and an input master plug register (iMPR) located on the receiving device. The input master plug register controls all attributes that are common to all isochronous data flows received by the receiving device. The input plug control register controls all attributes of the corresponding isochronous data flow that are independent from attributes of other isochronous data flows received by the receiving device.","An isochronous data flow can be controlled by any device connected to the IEEE 1394-1995 bus by modifying the corresponding plug control registers. Plug control registers can be modified through asynchronous transactions on the IEEE 1394-1995 bus or by internal modifications if the plug control registers are located on the controlling device.","To transport isochronous data between two audio\/video devices on the IEEE 1394-1995 bus, it is necessary for an application to connect an output plug on the transmitting device to an input plug on the receiving device using an isochronous channel. The relationship between one input plug, one output plug and one isochronous channel is called a point-to-point connection. A point-to-point connection can only be broken by the application that established it. An application can also just start the transmission or reception of an isochronous data flow on its own device by connecting one of its output or input plugs respectively to an isochronous channel. The relationship between one output plug and one isochronous channel is called a broadcast-out connection. The relationship between one input plug and one isochronous channel is called a broadcast-in connection. Broadcast-out and broadcast-in connections are collectively called broadcast connections. A broadcast connection can be established only by the device on which the plug is located, but it can be broken by any device.","A plug has four possible states. These states are idle, ready, active and suspended. A plug is either on-line or off-line. Only a plug that is on-line is capable of transmitting or receiving an isochronous data flow. A plug will be off-line, for example, if it relies on resources that are temporarily unpowered or otherwise unavailable. A plug to which no connections exist is referred to as unconnected. A plug to which one or more connections exist is referred to as connected. A plug which is connected and on-line is in the active state. Only an active plug shall transmit or receive an isochronous data flow except in the case of a bus reset where the isochronous data flow is resumed immediately after the bus-reset.","A diagram of the software layers implemented within an IEEE 1394-1995 capable computer system  is illustrated in FIG. . The application layer  includes at least one application . The driver layer  includes the 1394 Protocol driver , the 1394 Bus Class driver  and the 1394 Port driver . The 1394 Protocol driver  performs commands that allow the application to communicate with other devices or applications across the IEEE 1394-1995 serial bus, such as the video camera . The 1394 Bus Class driver  is responsible for communications sent and received over the IEEE 1394-1995 serial bus. The 1394 Port driver  is a hardware interface driver. The hardware layer  includes the 1394 PCI Interface module  which provides the interface between the IEEE 1394-1995 serial bus and the system bus  within the computer system . The 1394 PCI Interface module  is coupled to the physical interface  of the video camera  by the IEEE 1394-1995 serial bus.","Such a stack of software layers as illustrated in  is currently provided by Microsoft within the Windows\u2122 98 operating system. The application programming interface (API) provided within this current implementation included within the Windows\u2122 operating system provides no feedback to an application relating to activities that occur on a plug. For example, if another device on the IEEE 1394-1995 serial bus changes the plug's connection or the isochronous data flow for a plug, these state changes are not reported by this API to the upper layer software which is using the plug, causing the upper layer software to fall into an unknown working state. This API also does not allow upper layer software clients to explicitly establish connections between other devices on the IEEE 1394-1995 serial bus. This API will also not allow a client application to create the actual connection and manage the type of connection between the PC and the external device.","What is needed is an API that provides automated generation of transactions necessary to complete a data transfer, without requiring supervision by the API and the processor of an application. What is further needed is an API which implements isochronous transfer features of the IEEE 1394 standard bus structure very efficiently, permitting a high degree of hardware automation, if needed by the application.","In a first embodiment, an applications programming interface implements and manages isochronous and asynchronous data transfer operations between an application and a bus structure. During an asynchronous transfer the API includes the ability to transfer any amount of data between one or more local data buffers within the application and a range of addresses over the bus structure using one or more asynchronous transactions. An automatic transaction generator may be used to automatically generate the transactions necessary to complete the data transfer without direct processor control or supervision by the applications programming interface. The API also includes the ability to transfer data between the application and another node on the bus structure isochronously over a dedicated channel. During an isochronous data transfer, a buffer management scheme is used to manage a linked list of data buffer descriptors provided by the application. The linked list of buffer descriptors is maintained by the API to ensure the uninterrupted flow of the continuous stream of isochronous data. This linked descriptor list can form a circular list of buffers and include a forward pointer to the next buffer in the list and a backward pointer to the previous buffer in the list for each buffer. The linked descriptor list may also form a linear list to which the application can append additional buffers or remove existing buffers from the list. During isochronous transfers of data, the API provides implementation of a resynchronization event in the stream of data allowing for resynchronization by the application to a specific point within the data. Implementation is also provided for a callback routine for each buffer in the list which calls the application at a predetermined point during the transfer of data.","In a preferred embodiment, an isochronous applications programming interface (API) implements and manages isochronous data transfer and receive operations between an application and a bus structure. The isochronous API presents a virtual representation of a plug, using a plug handle, in which multiple client applications can register to a given plug. Broadcast transmission operations are managed through an output plug to transmit data on a specified isochronous channel. Broadcast reception operations are managed through an input plug to receive data on a specified isochronous channel. Point-to-point transmission operations are managed through an output plug to transmit data to a specified input plug on a receiving device. Point-to-point reception operations are managed through an input plug to receive data from a specified output plug on a transmitting device. When receiving a request from a client application for an isochronous data transmission or reception, the isochronous API connects an appropriate plug, allocates the appropriate resources and manages the resources during the data transmission or reception. During a data transmission, the isochronous API attaches appropriate filled buffers to the output plug and when the data within the buffer is transmitted, detaches the buffer from the output plug. During a data reception, the isochronous API attaches appropriate buffers to be filled to the input plug and when the buffer is filled with received data, detaches the buffer from the input plug. The isochronous API also notifies a client application of any state changes on a connected plug through an event handle.","In one aspect of the present invention, an interface between an application and a bus structure for controlling isochronous data operations to and from the application over the bus structure includes means for allocating resources necessary for the isochronous data operation and means for controlling isochronous data flow between the application and the bus structure including managing buffers for the application utilized in the data operation. The resources include an isochronous channel and isochronous bandwidth. The isochronous data flow is from the application to the bus structure for transmission operations and from the bus structure to the application for reception operations. The bus structure preferably substantially complies with a version of the IEEE 1394 standard. The resources include a plug and the means for allocating resources connects the plug to the application. The means for controlling communicates with the application regarding changes in state of the plug. The interface provides a representation of the plug to the application. The isochronous data flow is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. During a transmission operation, the means for controlling attaches filled buffers to the output plug and detaches buffers from the output plug after data within the buffers has been transmitted on the bus structure. During a reception operation, the means for controlling attaches buffers to be filled to the input plug and detaches filled buffers from the input plug. The means for controlling triggers an event to inform the application regarding changes in state of the plug. Each of the buffers preferably include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers preferably include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The interface further includes means for monitoring for an exception condition including notifying the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The means for controlling further handles a data type through the plug. The data type is a selective one of raw data, DV data, MPEG data and audio data. The means for controlling handles the data type by adding header and appropriate extension information.","In another aspect of the present invention, a node configured to couple to a bus structure includes one or more applications, a transaction layer to control transactions between the applications and remote nodes coupled to the bus structure and an isochronous interface layer coupled to communicate with the one or more applications and the transaction layer to provide an interface to the one or more applications to control isochronous data operations to and from the one or more applications over the bus structure, wherein the isochronous interface layer allocates resources necessary for the data operations and controls the isochronous data flow between the one or more applications and the bus structure including managing buffers for the application utilized in the data operation. The resources include a plug and the isochronous interface layer connects the plug to the application. The isochronous interface layer provides a representation of the plug to the application. The isochronous interface layer communicates with the application regarding changes in state of the plug. The isochronous interface layer triggers an event to inform the application regarding changes in state of the plug. The resources include an isochronous channel and isochronous bandwidth. The isochronous data flow is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. During a transmission operation, the isochronous interface layer provides capability to attach filled buffers to the output plug and detach buffers from the output plug after data within the buffers has been transmitted on the bus structure. During a reception operation, the isochronous interface layer attaches buffers to be filled to the input plug and detaches filled buffers from the input plug. The bus structure preferably substantially complies with a version of the IEEE 1394 standard. Each of the buffers preferably include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers preferably include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The isochronous interface further monitors for an exception condition including notifying the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The isochronous interface layer further handles a data type through the plug. The data type is a selective one of raw data, DV data, MPEG data and audio data. The isochronous interface layer handles the data type by adding header and appropriate extension information.","In yet another aspect of the present invention, a method of providing an interface to an application and managing isochronous data transfer operations between the application and a bus structure includes receiving a request for a data transfer operation from the application, allocating necessary resources for the data transfer operation and managing the necessary resources for the data transfer operation, including managing buffers for the application utilized in the data operation. The method further includes connecting an appropriate plug for the data transfer operation. The resources include an isochronous channel and isochronous bandwidth. The resources include a plug. The method further includes providing a representation of the plug to the application. The method further includes communicating with the application regarding state changes of the plug. The method further includes triggering an event to inform the application regarding state changes of the plug. Data flow for the data transfer operation is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. The method further includes attaching filled buffers to the output plug and detaching buffers from the output plug after data within the buffers has been transmitted on the bus structure, during transmission operations. The method further includes attaching buffers to be filled to the input plug and detaching filled buffers from the input plug, during reception operations. The bus structure preferably substantially complies with a version of the IEEE 1394 standard. Each of the buffers preferably include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers preferably include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The method further includes monitoring for an exception condition including notifying the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The method further includes handling a data type through the plug. The data type is a selective one of raw data, DV data, MPEG data and audio data. Handling the data type through the plug includes adding header and appropriate extension information.","In still yet another aspect of the present invention, a method of providing an interface to an application resident within a node on a bus structure includes receiving a request for a data transfer operation from the application, connecting an appropriate plug for the data transfer operation, allocating necessary resources for the data transfer operation, managing the necessary resources for the data transfer operation, including managing buffers for the application utilized in the data operation and informing the application of any state changes within the plug. Informing the application of any state changes within the plug includes triggering an event to inform the application of the state changes within the plug. The resources include an isochronous channel and isochronous bandwidth. Data flow for the data transfer operation is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. The method further includes attaching filled buffers to the output plug and detaching buffers from the output plug after data within the buffers has been transmitted on the bus structure, during transmission operations. The method further includes attaching buffers to be filled to the input plug and detaching filled buffers from the input plug, during reception operations. The bus structure preferably substantially complies with a version of the IEEE 1394 standard. Each of the buffers preferably include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers preferably include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The method further includes monitoring for an exception condition and notifying the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The method further includes handling a data type through the plug. The data type is a selective one of raw data, DV data, MPEG data and audio data. Handling the data type through the plug includes adding header and appropriate extension information.","In yet another aspect of the present invention, a bus structure includes one or more remote nodes each including at least one remote application and a local node including one or more local applications, a transaction layer to control transactions between the local applications and remote nodes coupled to the bus structure and an isochronous interface layer coupled to communicate with the one or more local applications and the transaction layer to provide an interface to the one or more local applications to control isochronous data operations to and from the one or more local applications over the bus structure, wherein the isochronous interface layer allocates resources necessary for the data operations, including connecting an appropriate plug to the application, and controls the isochronous data flow between the one or more local applications and the bus structure including managing buffers for the application utilized in the data operation by attaching buffers to and detaching buffers from the plug. The resources include an isochronous channel and isochronous bandwidth. The isochronous data flow is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. During a transmission operation, the isochronous interface layer attaches filled buffers to the output plug and detaches buffers from the output plug after data within the buffers has been transmitted on the bus structure. During a reception operation, the isochronous interface layer attaches buffers to be filled to the input plug and detaches filled buffers from the input plug. The isochronous interface layer also communicates with the one or more local applications regarding state changes in the plug. The isochronous interface layer also triggers an event to inform the one or more local applications regarding state changes in the plug. The bus structure preferably substantially complies with a version of the IEEE 1394 standard. Each of the buffers preferably include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers preferably include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The isochronous interface further monitors for an exception condition including notifying the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The isochronous interface layer further handles a data type through the plug. The data type is a selective one of raw data, DV data, MPEG data and audio data. The isochronous interface layer handles the data type by adding header and appropriate extension information.","In another aspect of the present invention, a node coupled to a bus structure which substantially complies with a version of the IEEE 1394 standard includes one or more local applications, a transaction layer to control transactions between the applications and remote nodes coupled to the bus structure and an isochronous interface layer coupled to communicate with the one or more applications and the transaction layer to provide an interface to the one or more applications to control isochronous data operations to and from the one or more applications over the bus structure, wherein the isochronous interface layer allocates resources necessary for the data operations, including connecting an appropriate plug to the application and allocating necessary channel and bandwidth, and controls the isochronous data flow between the one or more applications and the bus structure including managing buffers for the application utilized in the data operation, by attaching buffers to and detaching buffers from the plug. The isochronous data flow is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. During a transmission operation, the isochronous interface layer attaches filled buffers to the output plug and detaches buffers from the output plug after data within the buffers has been transmitted on the bus structure. During a reception operation, the isochronous interface layer attaches buffers to be filled to the input plug and detaches filled buffers from the input plug. The isochronous interface layer also communicates with the one or more applications regarding state changes in the plug. The isochronous interface layer also triggers an event to inform the one or more applications regarding state changes in the plug. Each of the buffers preferably include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers preferably include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The isochronous interface further monitors for an exception condition including notifying the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The isochronous interface layer further handles a data type through the plug. The data type is a selective one of raw data, DV data, MPEG data and audio data. The isochronous interface layer handles the data type by adding header and appropriate extension information.","In yet another aspect of the present invention, an interface between an application and a bus structure to control isochronous data operations to and from the application over the bus structure includes a control system configured to allocate resources necessary for the isochronous data operation and a buffer system configured to control isochronous data flow between the application and the bus structure including managing buffers for the application utilized in the data operation. The resources include an isochronous channel and isochronous bandwidth. The isochronous data flow is from the application to the bus structure for transmission operations and from the bus structure to the application for reception operations. The bus structure substantially complies with a version of the IEEE 1394 standard. The resources include a plug and the control system connects the plug to the application. The buffer system communicates with the application regarding changes in state of the plug. The interface provides a representation of the plug to the application. The isochronous data flow is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. During a transmission operation, the buffer system attaches filled buffers to the output plug and detaches buffers from the output plug after data within the buffers has been transmitted on the bus structure. During a reception operation, the buffer system attaches buffers to be filled to the input plug and detaches filled buffers from the input plug. The buffer system triggers an event to inform the application regarding changes in state of the plug. Each of the buffers include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The interface further includes a monitoring circuit configured to determine when an exception condition occurs and notify the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The buffer system further handles a data type through the plug. The data type is a selective one of raw data, DV data, MPEG data and audio data. The buffer system handles the data type by adding header and appropriate extension information.","In still yet another aspect of the present invention, a method of providing an interface to an application, managing isochronous data transfer operations between the application and a bus structure and monitoring for an exception includes receiving a request for a data transfer operation from the application, allocating necessary resources for the data transfer operation, managing the necessary resources for the data transfer operation, including managing buffers for the application utilized in the data operation, determining if an exception condition occurs and notifying the application when the exception condition occurs. The exception condition includes a condition within a group consisting of data out of sequence, receiving dummy packets, change of data stream format and data becoming out of synchronization. The method further includes connecting an appropriate plug for the data transfer operation. The resources include an isochronous channel and isochronous bandwidth. The resources include a plug. The method further includes providing a representation of the plug to the application. The method further includes communicating with the application regarding state changes of the plug. Data flow for the data transfer operation is from the application to the bus structure through an output plug for transmission operations and from the bus structure to the application through an input plug for reception operations. The method further includes attaching filled buffers to the output plug and detaching buffers from the output plug after data within the buffers has been transmitted on the bus structure, during transmission operations. The method further includes attaching buffers to be filled to the input plug and detaching filled buffers from the input plug, during reception operations. The bus structure substantially complies with a version of the IEEE 1394 standard. Each of the buffers include a callback routine which is activated to call the application at a point during a data transfer operation. Each of the buffers include a resynchronization event which is activated to resynchronize the application to a point during a data transfer operation. The method further includes triggering an event to inform the application regarding changes of the plug.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 3","b":["50","52","54","56","58","56","50","52","50","52","58","52","54","52","54"]},"An applications programming interface (API) according to the present invention could be implemented within any one or all of the connected subsystems including the video camera , the video cassette recorder  or the computer , for controlling data transfer operations communicated across the bus structures  and . In the first embodiment of the present invention the bus structures  and  are preferably IEEE 1394-1995 standard cables.","A block diagram of a hardware system resident in each system for implementing the applications programming interface of the present invention is illustrated in FIG. . In the hardware system illustrated in , a printed circuit board  is coupled to a user interface . The printed circuit board  includes a central processing unit (CPU)  coupled to system memory,  and to an I\/O bus interface  by the system bus . The user interface  is also coupled to the system bus . The user interface  is subsystem specific, but can include a keyboard, display or other I\/O devices for communicating with a user of the subsystem.","Each of the subsystems including the video camera , the video cassette recorder  and the computer , in order to implement the applications programming interface of the present invention, will include a hardware system such as the system illustrated in FIG. . The CPU  within each of these devices is used to execute the application program instructions. The API of the present invention will then manage both isochronous and asynchronous data transfer operations between the resident subsystem and one of the other subsystems over an appropriate one of the busses  or .","An applications programming interface according to a first embodiment of the present invention implements isochronous and asynchronous data transfers to and from an application over a bus structure. An application as used herein will refer to either an application or a device driver. The bus structure over which the data transfer operations are completed is preferably an IEEE 1394-1995 standard bus structure. However, as will be apparent to those skilled in the art, the applications programming interface of the present invention will also be applicable for use in managing data transfers over other types of bus structures. The applications programming interface of the first embodiment includes the ability to transfer any amount of data between a local data buffer provided by the application and a range of addresses over the bus structure using one or more asynchronous transactions. When an asynchronous transfer of a block of data is initiated, the applications programming interface sends a command to an automatic transaction generator. The automatic transaction generator then automatically generates the read or write transactions necessary to transfer the complete block of data asynchronously without direct processor control or requiring supervision by the applications programming interface.","The applications programming interface of the first embodiment also includes the ability to transfer data between the application and another node on the bus structure isochronously over a dedicated channel. During an isochronous data transfer, a buffer management scheme is used to manage data buffers within the application. The application may use one, more than one or a linked list of buffers depending on the type and amount of data to be transferred. A linked list of buffer descriptors that point to the buffers is maintained by the API to ensure the uninterrupted flow of the continuous stream of isochronous data. This linked descriptor list may implement a linear or a circular list of buffers and includes a forward pointer to the descriptor for the next buffer in the list and a backward pointer to the descriptor for the previous buffer in the list for each buffer. When a linear list is implemented, the application can dynamically append buffers to the list or remove existing buffers from the list, as necessary, for the processing of the data.","During an isochronous transfer of data, the applications programming interface of the present invention provides implementation of a resynchronization event in the stream of data allowing for resynchronization to a specific point within the data. Implementation is also provided for a callback routine for each buffer which calls the application at a predetermined specific point during the data transfer operation. Both the resynchronization event and the callback routine are supported by the IEEE 1394 standard.","The applications programming interface of the present invention also includes the ability to perform bus management operations, as necessary, over the bus structure. Such bus management operations include allocating and deallocating isochronous channel numbers, as necessary, and allocating and deallocating isochronous bandwidth. If the bus structure is an IEEE 1394 standard bus structure, then the applications programming interface also performs other bus management operations as required by the IEEE 1394 standard.","A block diagram schematic of an applications programming interface of the first embodiment, according to the present invention, within a system including a bus structure is illustrated in FIG. . The API  serves as an interface between the applications  and  and the bus structure , managing the transfer of data between the bus structure  and the applications  and . As illustrated in , a single API  may serve as an interface between multiple applications and the bus structure . For example, within the computer system , illustrated in , a single API  could serve as an interface between one or more applications being run by the computer system .","A hardware and physical interface  is included between the API  and the bus structure . The hardware and physical interface  includes an automatic transaction generator  for automatically generating the necessary transactions for completion of an asynchronous data transfer between one of the applications  or  and another node on the bus structure . The hardware and physical interface  also includes a bus interface  for monitoring and managing the flow of data to and from the bus structure . The hardware and physical interface  is shown coupled to a set of memory buffers , as controlled by the API . The set of memory buffers  includes the memory buffers ,  and . As will be described below, the memory buffers ,  and  are dedicated to the API  by the application  for use in sustaining isochronous data transfers to and from the application .","Isochronous Data Transfers","To initialize an isochronous data transfer operation an application first requests an isochronous channel from the API . The application may either request a specific channel number or any currently available channel number. The API  then obtains a channel for the isochronous transfer per the requirements of the IEEE 1394 standard. The IEEE 1394 standard supports a six bit channel number which is broadcast with a stream of data across the bus structure . Once a channel is allocated for an isochronous data transfer between an application and another node on the bus structure , no other nodes may use that specific channel number. After a channel is allocated, data buffers must be assigned by the application to the API  to be used for the data transfer. The API  allows the application to assign one, more than one or a list of data buffers to use for receiving or transmitting the isochronous stream of data. Each buffer assigned to the API  may be contiguous or fragmented and logical or physical. The list of data buffers may be circular or linear. If a linear list of data buffers is assigned to the API  the application  can add additional buffers or remove buffers from the list as necessary to process the data.","In the system illustrated in , the application  has assigned three buffers , including the buffers ,  and  to the API  for isochronous data transfers. The application has also assigned a linked list of three buffer descriptors to the API, one for each of the buffers ,  and . The API  maintains a buffer descriptor for each buffer within the linked list and manages the flow of the isochronous data between the application, the assigned buffers and the bus structure . Within the list of descriptors managed by the API , each buffer is represented by a buffer descriptor, including a forward pointer to the descriptor for the next buffer in the list and a backward pointer to the descriptor for the previous buffer in the list. A list of buffer descriptors corresponding to buffers assigned to an API  by an application is illustrated in FIG. . Each of the buffer descriptors 1-n correspond to a memory buffer 1-n. Specifically, the buffer descriptor  corresponds to the memory buffer  and the buffer descriptor  corresponds to the memory buffer .","The buffer descriptors each include an address and length of the corresponding buffer. The buffer descriptor also includes a callback completion routine to call after the buffer has been filled or emptied, depending on the direction of the current data transfer operation. The buffer descriptors further include an optional synchronization event field which is programmed by the application and is how the buffer is synchronized to a specific event or time. Specifically, the buffer descriptor  corresponding to the memory buffer , includes an address and a length for the memory buffer . A completion routine and a synchronization event are also included, if necessary.","This use of buffer descriptors and memory buffers allows great flexibility to an application using the API of the present invention, since the descriptors, buffers, completion routines and synchronization events are all set up by the application according to its specific needs. As an example, for an application that is running in a digital video camera transferring data isochronously to a digital video monitor, data is loaded in memory buffers, for which the API maintains buffer descriptors. The API then manages the transfer of each packet of data from the buffers to the video monitor. The video camera is able to implement a 2\u00d7 compression feature in the vertical dimension by having pairs of descriptors point to the same memory buffer. That is, the descriptors  and  will point to the memory buffer , the descriptors  and  will point to the memory buffer , and so on. A completion routine in the second descriptor of each pair notifies the video monitor that data in the memory buffer is ready to be read. This means that as the video camera outputs first and second scan line data, the second scan line data overwrites the first scan line data in the memory buffer with the second scan line data. The video monitor does not read the memory buffer until after the second scan line is written so the monitor never sees the first scan line data. In this manner, every other scan line is skipped.","The descriptors allow the list to be circular in nature and thereby maintain the continuous stream of data to or from the buffers ,  and . During an isochronous data transfer from the application  to another node along the bus structure , the application  fills the buffers ,  and , in turn, with the data. The API  then manages the transferring of the data from the appropriate buffer to the bus structure  during an appropriate time period. The bus interface  within the hardware and physical interface  controls transferring the data from the buffers ,  and  onto the bus structure . During an isochronous data transfer from another node along the bus structure  to the application , the API  manages transferring the data from the bus structure , through the bus interface , to the appropriate buffer ,  and . As one allocated buffer is filled up, the data is stored in the next buffer in the linked list. The application  then reads the data from the appropriate one of the buffers ,  and  during the appropriate time period. Once the application  has finished reading the data from a buffer, the buffer is provided back to the API  and the application  processes the data from the next buffer.","The buffer descriptors will also implement a linear list of buffers which allows the application to assign buffers to or remove buffers from the API , as necessary to complete a data transfer operation. For example, during an isochronous receive operation, as the application is finished processing each buffer it can then reassign it to the API for receiving more data. Correspondingly, if additional buffers are necessary to complete a data transfer operation, the application can assign more buffers to the API.","The API  will execute a resynchronization event and\/or a callback routine during the transfer of isochronous data if requested by the application . A resynchronization event allows for resynchronization by the application to a predetermined specific point in time within the data during the transfer. Because the data is being transferred isochronously, this resynchronization event will also synchronize the application to an appropriate point in time relative to the data flow. The transfer of video data provides an ideal example for the implementation of a resynchronization event. During the transfer of video data from an application such as a video recorder, the data is transferred in blocks representing the data necessary to display one horizontal line on a monitor or television. After the display of each horizontal line, the monitor must reset itself to be ready to display the next horizontal line. A resynchronization event could be employed by the monitor at the end of the data for each horizontal line, allowing the monitor to resynchronize itself to the beginning of the next horizontal line.","In the first embodiment of the API of the present invention an isochronous operation may be synchronized or scheduled to be performed immediately, at a specific bus time, when a specific value appears in the isochronous data block packet header, or when isochronous data appears on a specific channel of the bus for start operations or ends on a specific channel of the bus for stop operations.","Each buffer assigned to the API  can have a resynchronization event and a callback routine. A callback routine could be employed during the transfer of video data at the end of the transfer of a block of data representing a frame. A monitor or television groups horizontal lines into a frame and at the end of each frame resets itself to the top of the screen to be ready for the beginning of the next frame. A callback routine could be used at the end of the stream of data representing each frame. Such a scheme would allow a buffer to be filled with the data representing a video frame from a source coupled to the bus structure . After the data representing the video frame has been transferred, the callback routine can be used to notify the application that the data representing the next frame has been transferred and is available for processing. The application could then process the data for this frame of data while the data for the next frame is being loaded into the next buffer.","A flow chart illustrating API buffer processing for isochronous send and receive operations is shown in FIG. . It is assumed that at the start  of an isochronous receive operation that the application has set up the buffers\/descriptors, completion routine calls and synchronization events. The flowchart  is entered at step  for each isochronous stream that requires processing in the bus system. The API  keeps track of a current descriptor for processing the incoming data. In other words, the API maintains a pointer to the next buffer, and location within the next buffer where data can be stored.","At step  the next buffer descriptor is obtained from the linked list. At step  a check is made to determine if any more descriptors are included within the linked list. If there are no more descriptors in the linked list then the processing is stopped at the step . If there are additional descriptors then the routine moves to the step  where it waits until the synchronization event for the current buffer is reached. Once the synchronization event is reached, then at the step  the current buffer is either filled with the incoming data for a receive operation or the data from the buffer is transmitted for a send operation. After the buffer has been processed, then at the step  it is determined if a callback routine was included for this buffer. If a callback routine was included, then, at the step  the callback routine is called. Otherwise, the routine goes back to the step  and obtains the next descriptor. Whether a callback routine is provided or not, the API and hardware subsystem  assure that the next buffer descriptor is obtained such that no isochronous data is lost.","The steps of the flowchart  may be performed by a CPU and related subsystems such as found in a typical personal computer (PC), embedded processing system, etc. as discussed above in connection with . In general, the steps of flowcharts presented in this specification may be implemented in any suitable programming language such as \u201cC\u201d, PASCAL, FORTRAN, BASIC, assembly language, etc., or in a combination of such languages. Any suitable computer programming technique may be used for a software design to implement the steps, such as procedural or object oriented programming, parallel or distributed processing, interrupt driven or polled event processing, etc. Steps may be modified, added to, or taken away from, those shown in the flowcharts while still achieving the method steps and apparatus elements described in this specification and recited in the claims. The processing in a single step may be broken into two or more steps. Also, in some embodiments, two or more steps may be accomplished at the same time, or their tasks interleaved. The sequencing, or routing, of the steps may also be changed. Each flowchart is but one instance of a primitive example of the logic used to achieve a function in the embodiments of the present invention recited herein.","For purposes of discussion, the cumulative steps of a flowchart are referred to as constituting a single \u201croutine,\u201d or program, although they may be implemented in two or more routines, programs, processes, etc. Flowchart steps may also be distributed among processors residing in the same or different devices.","As an example of an isochronous data transfer operation, if the application  is a video monitor which is receiving data isochronously from a video recorder at a node coupled to the bus structure , the API  will manage the flow of data from the bus structure to the buffers ,  and , each represented by a buffer descriptor in the linked list. A first buffer  is filled with the data received from the video recorder. When the first buffer  is filled, it is processed and displayed by the video monitor  while the next buffer  in the linked list is filled. If the first buffer  included a callback routine at the end of the data for a frame, then the callback routine could be used to notify the video monitor  that it could process the data in the first buffer , representing the first frame. When the video monitor  is finished processing the data within the first buffer  it can then provide the buffer  back to the API  for storing additional data received from the bus structure .","If the application  is a video recorder transmitting isochronous data to another node coupled to the bus structure, then the application loads the buffers ,  and , in turn, with data. The API  will then manage the transmission of the data from the buffers ,  and  onto the bus structure  with the appropriate channel number at the appropriate time. In this manner the API  of the present invention manages isochronous data transfers to and from an application .","Asynchronous Data Transfers","To execute an asynchronous data transfer operation between an application  and another node coupled to the bus structure , the API  defines essentially a direct memory access (DMA) model, utilizing a level of hardware automation to automatically generate the requests necessary to complete the transfer and allowing the application and the API  to perform other functions while the data transfer operation is being completed. The API  provides a memory-mapped interface to the application for asynchronous data transfers. To initiate an asynchronous data transfer, an application  transmits a descriptor to the API  including an address of a buffer within the application's address space, a starting address in the address space of the bus structure at which the transfer is to take place, a length of the block of data to be transferred and a code representing whether the transfer is to be a read or write operation. The API  provides the necessary data to the hardware automatic transfer generator  which then generates the one or more transactions necessary to complete the transfer of the entire block of data across the bus structure . The automatic transfer generator  then generates the necessary read or write transactions to complete the transfer of data between the buffer assigned by the application  and the appropriate addresses across the bus structure . This automation does not require the attention of the APT  or the application  to complete an asynchronous data transfer operation. While in the first embodiment of the present invention the automatic transaction generator  is preferably implemented in hardware, it should be apparent to those skilled in the art that the automatic transaction generator could also be implemented in software within the API . If the application does not require this level of hardware automation, the API  can also generate the transactions necessary to complete a data transfer operation, without using the automatic transaction generator .","As is known to those skilled in the art each read or write transaction can only transfer a certain amount of data depending on the system and the capabilities of the bus structure . Therefore, to transfer a block of data it may be necessary to generate multiple read or write transactions. In contrast to the systems of the prior art, the API  of the present invention sends a single command to the automatic transaction generator block . The automatic transaction generator block  then generates the read or write transactions necessary to transfer the complete block of data over the bus structure , without requiring further attention by the API . This allows the system to be more efficient, as the API  and the application  can perform other tasks while the transfer is taking place. Because the transfer is asynchronous, once the transfer of the entire block of data is complete, the API  will notify the application .","As discussed above, in the first embodiment of the present invention, the bus structure  is preferably an IEEE 1394 standard bus structure. For asynchronous data transfers the bus structure  therefore provides a 64 bit address space. Within the descriptor provided to the automatic transaction generator , the remote address at which the data transfer is to take place is specified by a 64 bit address.","To initiate an asynchronous read operation, the application  transmits a descriptor to the API  including the address of the buffer within the application's address space to which the data is to be transferred, a 64 bit starting address in the address space of the bus structure  from which the data is to be read, the length of the block of data to be transferred and a code representing that the transfer is a read operation. The API  then transmits the required information to the automatic transaction generator . The automatic transaction generator  then generates the necessary read commands to transfer the data to the application's buffer from the proper node on the bus structure . The application is responsible for ensuring that the specified buffer is available before the read transactions are generated. The data is then read in response to the transactions generated by the automatic transaction generator , in a known manner.","To initiate an asynchronous write operation, the application  transmits a descriptor to the API  including the address of the buffer within the application's address space from which the data is to be transferred, a 64 bit starting address in the address space of the bus structure  to which the data is to be written, the length of the block of data to be transferred and a code representing that the transfer is a write operation. The API  then transmits the required information to the automatic transaction generator . The automatic transaction generator  then generates the necessary write commands to transfer the data to the proper node on the bus structure  from the application's buffer. The data is then transferred from the application's buffer in response to the transactions generated by the automatic transaction generator  in a known manner. When the buffer is transferred the application  is notified.","API Conventions and Bus Management Operations","An application calls a routine in the API  either synchronously or asynchronously. If an application calls a routine synchronously, then at the time that the routine returns to the application, the API has completed the requested operation or the API returns a completion status indicating that the chosen request could not be completed. Alternatively, if an application calls a routine asynchronously, then the requested action is most likely not complete at the time that the routine returns control to the client. In order to call a routine asynchronously, the application provides a completion callback routine. The API may call this completion routine before returning from the original call. However, in most cases the API completes the requested operation after returning from the original call that initiated the operation, then calls the application's completion routine to indicate that the operation is done.","Before using any of the services provided by the API, an application must first initialize the API. Each application must initialize the API separately. An application initializes the API by calling an ActivateSonyAPI subroutine. This subroutine establishes a connection between the API and the application. When calling the ActivateSonyAPI, the application may specify indication routines which the API calls when a bus reset or other bus event occurs. The ActivateSonyAPI subroutine returns a value to the application which the application then uses on subsequent calls to the routines of the API.","Applications which expect a large number of indications during the course of their operation may call the AddIndBuffers routine in order to pass additional indication buffers to the API for its exclusive use. The client can first call the CountIndBuffers routine in order to check the number of buffers that the APT currently owns. Prior to deactivating the API, the application may release the indication buffers previously given to the API by calling a RelIndBuffers routine.","When an application is finished using the API, it calls a DeactivateSonyAPI routine. This routine breaks the connection between the application and the API and releases any indication buffers or other resources in use by the API on behalf of the application. Note that the API may not be able to disassociate from a given application immediately if some of the application's buffers are currently in use by the API. During the time that the API is active for a given application, that application has access to all of the services that the API provides.","After initializing the API, an application may perform various IEEE 1394 bus management functions, as defined in section  of the IEEE 1394 standard, and described below. An application may allocate and deallocate isochronous channel numbers from the currently active isochronous resource manager using the MGMTAllocateChannel and MGMTDeAllocateChannel routines, respectively. Using these applications, the application may request to allocate a specific channel number, if it is available. Alternatively, an application may request to allocate any currently available channel number. These API routines follow the requirements of the IEEE 1394 standard with regard to allocating and deallocating isochronous channel numbers. When using isochronous channel numbers, the application is responsible for following any other requirements which may apply in the IEEE 1394 standard or any other governing protocol document.","An application may allocate and deallocate isochronous bandwidth from the currently active isochronous resource manager using the MGMTAllocateBandwidth and MGMTDeAllocateBandwidth routines, respectively. These API routines follow the requirements of the IEEE 1394 standard with regard to allocating and deallocating isochronous bandwidth. When using these routines, the application is responsible for calculating the correct amount of isochronous bandwidth needed and allocating exactly that much. The application is also responsible for following any applicable rules as documented in the IEEE 1394 standard and any other governing protocol documents, with regard to allocating, deallocating or owning any isochronous bandwidth.","When an application deactivates the API, the API does not attempt to deallocate any bus resources that the application previously allocated. This permits the application to relinquish ownership of these resources easily, as required in the IEC AV protocols standard. However, this places complete responsibility on the application to follow the governing protocols when allocating and deallocating isochronous bus resources.","An application may retrieve the current topology map and speed map information from the active bus manager, if present, and any other available bus information using the MGMTBusInfo routine. This routine retrieves the most current information from the bus manager, whether or not the node on which the application is running is the active bus manager. Note that this routine will fail if there is no currently active bus manager. Section  of the IEEE 1394 standard defines the format of the topology map and speed map, and the conditions under which a bus manager exists or does not exist.","After initializing the API, the application may call the ASYNDataRequest routine to initiate asynchronous data transfer requests over the IEEE 1394 serial bus. The application may use this routine to initiate any asynchronous transaction that is defined in the IEEE 1394 standard, including data block read or write requests, quadlet read or write requests or any lock request. When the application calls the ASYNDataRequest routine, the routine passes a descriptor for a buffer in the application's address space, a starting address in the 64 bit IEEE 1394 address space, a data transfer length and a transaction code. The ASYNDataRequest routine then generates one or more IEEE 1394 transactions to satisfy the request. When the API finishes the requested data transfer operation, or if it encounters an error, the API returns to the application or calls the application's callback routine, depending on whether the application called this routine synchronously or asynchronously.","In order to perform a lock transaction over the IEEE 1394 serial bus, the application calls the ASYNDataRequest routine and passes an argument value, a data value, and a lock operation code. The API generates the requested lock operation and returns to the application or calls the application's callback routine, as determined by the type of call, e.g., synchronously or asynchronously.","After initializing the API, the application may source or sink a channel of isochronous data on the IEEE 1394 serial bus. Before transferring isochronous data, the application must first open an isochronous port using the ISOCHOpen routine. When calling this routine, the application specifies the direction and other information about the stream of isochronous data that the application intends to transfer. The ISOCHOpen routine determines if the necessary system resources are available then returns to the application. When this routine completes successfully, the application then has all necessary system resources reserved for its exclusive use to transfer a stream of isochronous data.","When an application talks or listens on an isochronous channel, the source or destination of the isochronous data in the host system is one or more data buffers owned by the application and described in a data structure. The application passes these buffers to the API by calling the ISOCHAttach routine. This routine \u201cattaches\u201d the application buffers to the isochronous stream in preparation for transferring application data into or out of these buffers. If the application wishes to reclaim its buffers before the API has finished with them, the application may call the ISOCHDetach routine, specifying those buffers that the application wishes to reclaim.","The API defined buffer descriptor which the application uses to describe its isochronous data buffers permits the application to specify one, more than one, or a list of data buffers to use for receiving or transmitting isochronous data. Each buffer may be contiguous or fragmented, logical or physical and the application may specify callback routines on a buffer by buffer basis. This permits extremely flexible buffer handing in the API on behalf of the application, thereby supporting a wide range of application requirements.","When the application has opened an isochronous port and has attached buffers to this port, then the application may control its stream of isochronous data. It does this by calling the ISOCHControl routine. This routine permits the application to start or stop an isochronous stream into or out of the application buffers. When calling this routine, the application may specify an event on which to start or stop the stream, e.g., immediately, on a particular isochronous cycle or other event. When the application is finished transferring a stream of isochronous data, it releases the system resources associated with the open port by calling the ISOCHClose routine.","The ActivateSonyAPI and DeactivateSonyApi routines provide the initialization mechanism which makes the IEEE 1394 specific services provided by the API available to the calling application. The ActivateSonyAPI routine establishes a connection to the services provided by the API. The DeactivateSonyAPI routine removes the specified connection to the services provided by the API. The result of an activation is a valid activateReq structure. The calling application passes a pointer to this structure as part of all subsequent calls to the API. As part of activating the API for an application, the application may provide indication routines which the API uses to inform the caller that something has happened on the associated IEEE 1394 bus, such as a bus reset or request indication from a remote node. The result of deactivation is that the indication routines, if any, which were registered at activation time are de-registered. Following deactivation, the caller may not use any of the API services, unless the API is first reactivated.","The following function activates the API for further operations:\n\n","The single parameter contains the address of an activatReq data structure. This data structure provides information necessary to activate the API, as defined in Table I below:",{"@attributes":{"id":"p-0104","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct ActivateReq {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void","(*BusResetHandler)(BusResetPtr);","\/* Bus Reset Handler *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STATUS (*IndicationHandler)(IndicationPtr);","\/* Indication Handler *\/"]},{"entry":[{},"void *RefPtr;","\/ * for use by above routines *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void","*SonyAPIPrivate;","\/* the cookie *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*AsyncCompletion)(struct ActivateReq *req); \/* completion routine *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void *UserPtr;","\/* for use by completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STATUS Status;","\/* completion status *\/"]},{"entry":["}","ActivateReq, *ActivateReqPtr;"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"When the BusResetHandler filed is not equal to null, it contains the address of the routine to call upon receiving a bus reset event. When a bus reset occurs on the IEEE 1394 bus, the API calls the BusResetHandler routine, passing the address of a data structure containing bus reset information. When the IndicationHanadler field is not equal to null, it contains the address of the routine to call upon the occurrence of an indication that is not handled by the API. When the API receives a request subaction from a remote node, it calls the IndicationHandler routine, passing the address of a data structure which describes the request. The API fills in the SonyAPIPrivate field as part of the activation process. The API uses the value in this field on subsequent calls. The calling application shall not modify the value in this field. When the AsyncCompletion field is not equal to null, it contains the address of the routine to call when the API is active and available for use by the invoking application. Note that the calling application may specify a completion routine whether the request is asynchronous or synchronous. The UserPtr field is available for use by the calling application's completion routine. The API does not modify this field. The Status field contains the status of the activation request.","The following function terminates the instantiation of the API represented by request:\n\n","The single parameter contains the address of the activateReq data structure used to activate the API previously. The section above defines this data structure and describes its fields. Note that when deactivating the caller must use the same data structure that was used to activate the API previously. The caller may modify the values in the AsyncCompletion field and the UserPtr field. The caller should not modify any other field in the activateReq data structure following the initial call to the ActivateSonyAPI routine and prior to the call to the DeactivateSonyAPI routine. In addition to deactivating the API for a specific application, this routine also releases any indication buffers that the application previously passed to the API. If there are outstanding indication buffers owned by the application and the application attempts to call this routine synchronously, this routine will return an error. If this happens, the application may call this routine again specifying a completion routine. The API will complete the deactivate request and call the application's indication routine when all of the application's indication buffers have been released.","The API calls the indication handling routines, BusResetHandler and IndicationHandler, asynchronously, and they may have limited system services available to them. Depending on the environment and possibly some other circumstances, the API may call these routines at interrupt level. In the BusResetHandler routine, the handler is passed a pointer to bus reset information. In the IndicationHandler routine, the handler is passed a pointer to indication information. The application passes the address of one or both of these indication routines to the API at the time that it activates the API. The application may provide either one of these handlers, both handlers or no handler routines at all.","The bus reset handling routine has the following calling convention:\n\n",{"@attributes":{"id":"p-0110","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ActivatereqPtr","activateReq;","\/* the session *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"QUADLET",{},"generation;",{},"\/* bus generation *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"QUADLET",{},"numNodes;","\/* number of nodes on the bus *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"TopologyMapPtr",{},"topology;",{},"\/* bus topology *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"... other?"},{"entry":"} BusResetBlock, *BusResetBlockPtr;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The API calls the bus reset handling routine any time that a bus reset occurs on the IEEE 1394 bus while the API is active for the application that provided the bus reset handler routine. When a cluster of resets occurs due to the physical nature of bus connection and disconnection, the handler will be called once. The handler will not be re-entered, but may be called several times in succession. As the result of the bus reset, all asynchronous transactions which were pending at the time of the bus reset will be completed with an error status. Isochronous traffic will resume per the IEEE 1394 specification, and may produce indications during the execution of the bus reset handler.","The asynchronous transaction request indication routine has the following calling convention:\n\n",{"@attributes":{"id":"p-0113","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE III"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ActivateReqPtr\u2003activateReq;","\/* the session*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LocalBufferPtr\u2003indicationBuf;\u2003\/* the info*\/"]},{"entry":[{},"} IndicationBlock, *IndicationBlockPtr;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The API calls the indication routine when it receives an asynchronous request subaction that is not handled by either the API itself, or by the IEEE 1394 interface hardware. For each such event, the API calls the indication routine of each application, beginning with the first application to activate the API and provide an indication handler. Each indication handler returns a value to the API to indicate whether or not it handled the indication. When the API receives a status from an indication routine indicating that it handled the indication, then the API does not call any other indication routines for this indication.","The API does handle some request subactions itself. For these transactions, the API does not call any indication handler routine. The API passes all IEEE 1394 transaction information that caused the indication and the additional information necessary for the indication handler routine to generate a response subaction through the API.","The application may contribute buffers to the Indication Handler. This facility allows the application to expand the default set of indication buffers in order to accommodate application specific requirements. A larger set of indication buffers allows more outstanding indications without causing a busy ack signal at the IEEE 1394 interface. The application is not guaranteed to receive a buffer belonging to it when it receives an indication from the API. Furthermore, the API may pass an application indication buffer to another application, if necessary, when reporting an indication.","The Current Indication Buffer Count function returns the total count of indication buffers in the indication buffer pool. The returned value is the current count of indication buffers.","The Add Indication Buffers function contributes buffers to the indication buffer pool. Buffer elements are described as a LocalBuffer. The caller of this function cedes ownership of the storage represented by this request to the API and must regain ownership prior to disposing of the storage.\n\n","The first parameter of an AddIndBuffers function contains the address of a valid ActivateReq data structure. The second parameter contains the address of a BufMgmtBlock data structure. This data structure describes the buffers, as defined in Table IV below.",{"@attributes":{"id":"p-0120","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE IV"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct BufMgmtBlock {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BMIdata APIprivate;","\/* API private *\/"]},{"entry":[{},"LocalBufferPtr buffs;","\/* the buffers to contribute *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*AsyncCompletion) (struct BufMgmtBlock *req);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/*completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void *UserPtr;","\/*for use by the completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS","Status;","\/*completion status for operation*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} BufMgmtBlock, *BufMgmtBlockPtr;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The APIprivate field includes private data for management of the request. The LocalBufferPtr field contains descriptors for the buffer(s) to contribute. These buffers can be of any size. The API may use none, part or all of the contributed buffers at its discretion. When the AsyncCompletion field is not equal to null, it contains the address of the routine to call upon completing the operation. The UserPtr field is available for use by the calling completion routine. The API does not modify this field. The Status field contains the status of the requested data transfer operation. The Status field contains status \u201cpending\u201d until the asynchronous operation is completed. When the completion routine is invoked, the Status field will contain completion status.","The Release Indication Buffers function returns previously added indication buffers to the invoker. Buffer elements are described as a LocalBuffer. The invoker of this function may specify a subset of the buffers added by an AddIndBuffers function request. When all of the requested buffers are released, the completion routine is invoked.\n\n","The first parameter of a Release Indication Buffer contains the address of a valid activateReq data structure. The second parameter contains the address of a BufMgmtPtr data structure. This data structure describes the buffers, as defined above. When the application requests the API to release a buffer, it must describe that buffer using the same description as when the buffer was first given to the API.","The Bus Management routines perform IEEE 1394 bus management functions. These functions include allocating and deallocating isochronous bus resources and retrieving information about the topology or configuration of the IEEE 1394 bus.","The MGMTAllocateChannel routine uses the protocols defined in section  of the IEEE 1394 standard to allocate a single isochronous channel number. The MGMTAllocateChannel routine calling convention is as follows:\n\n","The first calling parameter of a MGMTAllocateChannel routine is the address of an active ActivateReq data structure. The second parameter contains the address of a data structure as defined in Table V below.",{"@attributes":{"id":"p-0127","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE V"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct MGMTAllocateChBlock {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"QUADLET channel;","\/* channel number to allocate,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"or all ones *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QUADLET allocateCh;","\/* actual channel number allocated*\/"]},{"entry":[{},"OCTLET chAvailable;","\/* bit mask of available channel"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"numbers *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*MGMTCompletion) (struct MGMTAllocateChBlock *req);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/* client completion routine *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void *UserPtr;","\/ *for use by the completion routine *\/"]},{"entry":[{},"STATUS Status;","\/ *completion status *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} MGMTAllocateChBlock, *MGMTAllocateChBlockPtr"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The channel field contains the channel number to allocate. If the channel number is in the range of 0 to 63, inclusive, then the routine attempts to allocate the specified channel number. If the channel number is equal to all ones, then the routine chooses a channel number to allocate. If the channel field contains any other value, then the routine fills in the chAvailable field and returns the chUnavailable status. Note that this can be used to determine the current value of the channels available bit mask from the currently active Isochronous Resource Manager. The allocatedCh field is filled with the actual allocated channel number, or all ones if a channel was not allocated as a result of calling this routine. The chAvailable field is filled with the current value of the channels_available CSR at the Isochronous Resource Manager. Note that the value in the CSR may change at any time, so the value in this field is only a snapshot and may be different on subsequent calls. If the value in the MGMTCompletion field is not equal to NULL, then this field contains the address of the routine to call upon completion. The UserPtr field is available for use by the application's completion routine. The API does not modify this field. The Status field contains the completion status for this call. If the application calls this routine asynchronously, this field contains PENDING status until the completion routine is called.","The MGMTAllocateBandwidth routine uses the protocols defined in section  of the IEEE 1394 standard to allocate isochronous bandwidth. The MGMTAllocateBandwidth routine's calling convention is as follows:\n\n","The first calling parameter of a MGMTAllocateBandwidth routine is the address of an active ActivateReq data structure. The second parameter contains the address of a data structure as defined in Table VI below.",{"@attributes":{"id":"p-0131","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE VI"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct MGMTAllocateBWBlock {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"QUADLET bandwidth;","\/*bandwidth to allocate, or all ones*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QUADLET bwAvailable \/*actual value of BWAvailable register in IRM*\/"]},{"entry":[{},"void (*MGMTCompletion) (struct MGMTAllocateBWBlock *req);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/*client completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void *UserPtr;","\/*for use by the completion routine*\/"]},{"entry":[{},"STATUS Status;","\/*completion status*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} MGMTAllocateBWBlock, *MGMTAllocateBWBlockPtr;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The bandwidth field contains the amount of bandwidth to allocate. If this number is equal to all ones, then the routine fills in the bwAvailable field and returns the BWUNAVAILABLE status. Note that this can be used to determine the current value of the bwavailable field from the currently active Isochronous Resource Manager. The bwAvailable field is filled with the current value of the bandwidth\/available CSR at the Isochronous Resource Manager. Note that the value in the CSR may change at any time, so the value in this field is only a snapshot and may be different on subsequent calls. If the value in the MGMTCompletion field is not equal to NULL, then it contains the address of the routine to call upon completion. The UserPtr field is available for use by the application's completion routine. The API does not modify this field. The Status field contains the completion status for this call. If the application calls this routine asynchronously, this field contains PENDING status until the completion routine is called.","The MGMTDeAllocateChannel routine uses the protocols defined in section  of the IEEE 1394 standard to deallocate a single isochronous channel number. The MGMTDeAllocateChannel routine's calling convention is as follows:\n\n","The first calling parameter of a MGMTDeAllocateChannel routine is the address of an active ActivateReq data structure. The second parameter contains the address of a MGMTAllocateChBlock data structure. This routine deallocates the channel specified in the channel field of that data structure and fills in the chAvailable field with the current value of the channels_available bit mask from the currently active isochronous resource manager.","The MGMTDeAllocateBandwidth routine uses the protocols defined in section  of the IEEE 1394 standard to deallocate isochronous bandwidth. The MGMTDeAllocateBandwidth routine's calling convention is as follows:\n\n","The first calling parameter of a MGMTDeAllocateBandwidth routine is the address of an active ActivateReq data structure. The second parameter contains the address of a MGMTAllocateBWBlock data structure. This routine deallocates the bandwidth contained in the bandwidth field and fills in the bwAvailable field with the current value of the bandwidth_available register in the currently active isochronous resource manager.","The MGMTBusInfo routine returns information about the node on which the application is running and the connected IEEE 1394 bus. Such information includes the current setting of the PHY gap count, the number of nodes on the connected IEEE 1394 bus, a pointer to the bus topology map and a pointer to the bus speed map, as defined in the IEEE 1394 standard.","The ASYNDataRequest routine generates one or more IEEE 1394 asynchronous read or write transactions in order to transfer data between the application's data buffer and a linear range of addresses in the 64 bit IEEE 1394 address space. The ASYNDataRequest routine has the following calling convention:\n\n","The first parameter of an ASYNDataRequest routine contains the address of a valid activateReq data structure. The second parameter contains the address of an asyncTransport data structure. This data structure describes the requested data transfer operation, as defined in Table VII below.",{"@attributes":{"id":"p-0140","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE VII"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct AsyncTransport {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ASYdata APIprivate;","\/* API private *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPTION","OPCode",":4;","\/*defines the operation to perform*\/"]},{"entry":[{},"OPTION","BusSpeed",":4;","\/*bus speed to use for xfr*\/"]},{"entry":[{},"OPTION","NonIncr",":1;","\/*do not increment remote addr*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BUFSIZE","BlockSize","\/*for block read or write requests -"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"size to use for all block requests"]},{"entry":[{},"0 means use max for bus speed*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"LocalBuffer ApplBufPtr;","\/*buf descr for application data*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RemoteAddr RemoteBufPtr;","\/*64 bit address on IEEE 1394 bus*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BUFSIZE","Length;","\/*number of bytes to transfer*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*AsyncCompletion)\u2003(struct AsyncTransport* req);\u2003\/*cmpl routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void *UserPtr;","\/*for use by the completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS","Status;","\/*completion status for operation*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} AsyncTransport, *AsyncTransportPtr;"},{"entry":"enum OpCodes {"},{"entry":"\/*asynch data transfer operations *\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BLOCKWRITE ,","\/*transfer data using block write requests*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BLOCKREAD,","\/*transfer data using block read requests*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QUADLETWRITE ,","\/*transfer data using QUADLET write transactions*\/"]},{"entry":[{},"QUADLETREAD ,","\/*transfer data using QUADLET read transactions*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/*lock transactions*\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MASKSWAP,","\/*mask swap lock operation*\/"]},{"entry":[{},"COMPARESWAP,","\/*compare swap lock operation*\/"]},{"entry":[{},"FETCHADD,","\/*fetch and add lock operation*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"LITTLEADD,","\/*little endian fetch\/add lock operation*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BOUNDEDADD,","\/*bounded add lock operation*\/"]},{"entry":[{},"WRAPADD","\/*wrap add lock operation*\/"]},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The ASYdata field includes private data for management of the request. The OpCode field contains a code describing the requested operation which must be one of the values defined in the asyncOpCodes enum. The NonIncr field when set to one, instructs the routine to transfer all data to the same IEEE 1394 address contained in the remoteBufPtr field and when set to zero, instructs the routine to transfer data to an incrementing range of IEEE 1394 addresses, beginning with the address contained in the remoteBufPtr field. The BlockSize field contains the maximum size, in bytes, to use for all block read or write request subactions. A value of zero means to use the maximum request size for the chosen bus speed. The APPLBufPtr field contains the descriptor for the application data buffer. The RemoteBufPtr field contains the 64 bit address of the data buffer in a remote IEEE 1394 node. The Length field contains the number of bytes to transfer which may be less than or equal to the length of the application data buffer. When the AsyncCompletion field is not equal to null, it contains the address of the routine to call upon completing the data transfer. The UserPtr field is available for use by the calling application's completion routine and is not modified by the API. The Status field contains the status of the requested data transfer operation. This field contains status \u201cpending\u201d until the asynchronous operation is complete. When the completion routine is invoked, this field will contain completion status.","The ASYNLockRequest routine generates one lock transaction on the IEEE 1394 bus. The ASYNLockRequest routine has the following calling convention:\n\n","The first parameter of an ASYNLockRequest routine contains the address of a valid activateReq data structure. The second parameter contains the address of an AsyncLockBlock data structure. This data structure describes the requested data transfer operation, as defined in Table VIII below.",{"@attributes":{"id":"p-0144","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE VIII"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct AsyncLockBlock {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ASYdata APIprivate;","\/* API private *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"OPTION","OPCode",":4;","\/*defines the operation"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to perform*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPTION","BusSpeed",":4;","\/*bus speed to use for xfr*\/"]},{"entry":[{},"struct {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"union {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QUADLET","Arg32;"]},{"entry":[{},"OCTLET","Arg64;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} arg;","\/* 32 or 64 bit lock"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"argument *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"union {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QUADLET","Data32;"]},{"entry":[{},"OCTLET","Data64;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} data;","\/* 32 or 64 bit lock data *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} ArgData;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"RemoteAddr remoteBufPtr;","\/*64 bit address on IEEE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"1394 bus*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*AsyncCompletion) (struct AsyncLockBlock *req);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/*completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void *UserPtr;","\/*for use by the completion"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS","Status;","\/*completion status for"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"operation*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} AsyncLockBlock, *AsyncLockBlockPtr;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The APIPrivate field contains private data for management of the request. The OpCode field contains a code describing the requested operation and must contain one of the values defined in the asyncOpCodes enum. The ArgData struct field contains the argument and data for this lock transaction. The remoteBufPtr field contains the 64 bit destination address on the IEEE 1394 bus. When the AsyncCompletion field is not equal to null, it contains the address of the routine to call upon completing the lock transaction. The UserPtr field is available for use by the calling application's completion routine and is not modified by the API. The Status field contains the status of the requested data transfer operation. This field contains status \u201cpending\u201d until the asynchronous operation is complete. When the completion routine is invoked, this field will contain completion status.","The Isochronous Resource Management routines allocate and deallocate system resources needed to transfer isochronous data over the IEEE 1394 interface into or out of application data buffers. Allocation and deallocation is necessary to avoid conflicts among multiple potential applications of isochronous data in the system. Whenever isochronous data flows over the IEEE 1394 bus, there is an entity on the IEEE 1394 bus which owns the necessary bus resources, namely channel numbers and bandwidth. Each application which uses isochronous data has its own set of rules for who must allocate and deallocate these resources and when. The bus management routines in the API of the first embodiment permit an application to allocate these resources according to the requirements of the IEEE 1394 standard. Note that the routines in this section do not allocate IEEE 1394 bus resources; these routines only allocate system level resources necessary to transfer isochronous data into or out of application data buffers. These resources include a DMA channel and the system resources to sustain it, such as the low level interrupt handler and dispatcher.","The ISOCHOpen routine opens and initializes an isochronous port. An isochronous port is a collection of hardware and software resources in the local node on which the application of the API and the API are running. This collection of resources constitutes everything in the local node which is needed to transfer a single stream of isochronous data into or out of the node. This collection of resources does not include the IEEE 1394 bus resources which the application must allocate separately, according to the bus management rules defined in section  of the IEEE 1394 standard, and the governing application rules and requirements. The routines which enable an application of the API to allocate and deallocate IEEE 1394 bus resources have been described above.","The port open routine has the following calling convention:\n\n","The first parameter of the port open routine contains the address of a valid activateReq data structure. The second parameter contains the address of an ISOCHOpenBlock data structure. Upon successful completion of this routine, the application uses this ISOCHOpenBlock data structure to reference this opened isochronous port on future calls to the API which affect this port.","The possible status return values for a port open routine are GOOD, signalling that an open request was completed successfully, PENDING, signalling that the API has accepted the request and will complete it at a later time, NORESOURCES, signalling that an isochronous port or other necessary resource is not currently available and the request is denied, INVALIDREQUEST, signalling that the requested bus speed is not supported, INVALIDCONNECTION, signalling that the ActivateReqPtr field does not represent an active API connection, and UNDEFINEDERROR, signalling that the request could not be honored, but the error could not be identified.","The calling parameter of a port open routine contains the address of an ISOCHOpenblock data structure. This data structure describes the request, as defined in Table IX below.",{"@attributes":{"id":"p-0152","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE IX"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ISOlink APIprivate;","\/* API private *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPTION","Direction",":2;","\/*source\/sink*\/"]},{"entry":[{},"OPTION","BusSpeed",":4;","\/*requested bus speed*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void (*AsyncCompletion))struct ISOCHOpenBlock* req);"]},{"entry":[{},"\/*compl routine*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void *UserPtr;","\/*for use by the completion"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS","Status;","\/*completion status for"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"operation*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} ISOCHOpenBlock, *ISOCHOpenBlockPtr;"},{"entry":"enum Direction {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"INPUT ,","\/*specifies input to application"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"to data buffer*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"OUTPUT","\/*specifies output from application"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"data buffer*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The direction field indicates the direction of the isochronous data transfer. When the AsyncCompletion field is not equal to null, it contains the address of the routine to call upon completion. The UserPtr field is available for use by the calling application's completion routine and is not modified by the API. The Status field contains the status of the requested data transfer operation. This field contains status \u201cpending\u201d until the asynchronous data transfer operation is complete. When the completion routine is invoked, this field will contain completion status. When the application is finished with the isochronous port, it passes the isochPortPtr to the ISOCHClose routine.","The ISOCHClose routine closes an isochronous port that was previously opened using the ISOCHOpen routine. This routine has the following calling convention:\n\n","The first calling parameter of ISOCHClose routine is the address of a valid activateReq data structure. The second calling parameter is the address of the ISOCHOpenBlock used to open the port with the ISOCHOpen routine.","The isochronous data control routine controls a stream of isochronous data into or out of application data buffets. For applications which listen to isochronous data, these control routines only affect the flow of isochronous data into the system; they do not affect the isochronous data on the IEEE 1394 bus itself. For applications that transmit isochronous data from application data buffers, these control routines also affect the flow of isochronous data on the IEEE 1394 bus.","The ISOCHControl routine has the following calling convention:\n\n","The first parameter of an ISOCHControl routine contains the address of a valid ISOCHOpenBlock data structure. The second parameter contains the address of an ISOCHCtlBlock data structure. This data structure describes the requested control operation, as defined in Table X below.",{"@attributes":{"id":"p-0159","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE X"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct ISOCHCtlBlock {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ISOlink APIPrivate;","\/* API private *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPTION IsoOpCode",":4;","\/*operation to perform*\/"]},{"entry":[{},"OPTION IsoEvent",":4;","\/*trigger event for start\/stop*\/"]},{"entry":[{},"OPTION Sy",":4;","\/*sy field value, if needed*\/"]},{"entry":[{},"OPTION Tag",":2;","\/*tag value to use when"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"starting*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"OPTION Channel",":6;","\/*channel value to use when"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"starting*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BusTime Time;","\/* specifies when an event"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"should occur*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*AsyncCompletion)(struct ISOCHCtlBlock *req);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/*completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void *UserPtr;","\/*for use by the completion"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS Status","\/*completion status for"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"operation*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} ISOCHCtlBlock, *ISOCHCtlBlockPtr;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The APIPrivate field contains private storage used by the API to manage this request. The IsoOpCode field contains a value from the IsoOpCode enum which describes the requested control operation. The IsoEvent field specifies the trigger event on which to perform the requested operation. If the IsoEvent field contains the value \u201cSYFIELD,\u201d the Sy field contains the value in the sy field that will cause the isochronous channel to start or stop. If the IsoOpCode field contains the value \u201cSTART,\u201d the value from the Tag field is used for the tag value in the isochronous data block packet header. If the IsoOpCode field contains the value \u201cSTART,\u201d the value from the Channel field is used for the channel value in the isochronous data block packet header. If the IsoEvent field contains the value \u201cTIME,\u201d the Time field contains the bus time on which the requested action is to take place. When the AysncCompletion field is not equal to null, it contains the address of the routine to call upon completion of the data transfer. The UserPtr field is available for use by the calling application's completion routine. The API does not modify this field. The Status field contains the status of the requested data transfer operation. This field contains status \u201cpending\u201d until the asynchronous data transfer operation is complete. When the completion routine is invoked, this field will contain completion status.","The isochronous attach routine passes application data buffer descriptors to the API software. The application may call this routine at any time to make buffers available to the IEEE 1394 interface hardware and the associated low layers of software. The calling convention for this routine is as follows:\n\n","The first parameter of an ISOCHAttach routine contains the address of a valid ISOCHOpenBlock data structure. The second parameter contains the address of an ISOCHAppendBlock data structure. This data structure describes the application data buffer list as defined in Table XI below.",{"@attributes":{"id":"p-0163","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE XI"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct ISOCHAppendBlock {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ISOlink APIPrivate;",{},"\/* API private *\/"]},{"entry":[{},"isochBufferPtr","IsochBuffList;","\/*start of list of isoch buffers*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*AsyncCompletion) (struct ISOCHAppendBlock *req);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"\/*completion routine*\/"]},{"entry":[{},"void *UserPtr;",{},"\/*for use by the completion routine*\/"]},{"entry":[{},"STATUS status;",{},"\/*completion status for operation*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} ISOCHAppendBlock, *ISOCHAppendBlockPtr;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The APIPrivate field contains private storage used by the API to manage the request. The IsochBuffList field contains the address of the first isochronous buffer of a list to append to the specified port. If the current buffer list or the buffer list to append is circular then the operation can only be performed when the port is stopped and the append operation will replace any previously appended buffers. A non-circular list of buffers may be appended to an existing non-circular list of buffers at any time. When the AsyncCompletion field is not equal to null, it contains the address of the routine to call upon completion. The UserPtr field is available for use by the calling application's completion routine and is not modified by the API. The Status field contains the status of the requested operation. This field contains status \u201cPENDING\u201d until the asynchronous data operation is complete. When the completion routine is invoked, this field will contain completion status.","The IsochBuffList field contains the address of an isochBuffer. The isochBuffer data structure describes a single application data buffer. Typically, isochBuffer data structures exist in a doubly linked list. This data structure is defined in Table XII below.",{"@attributes":{"id":"p-0166","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE XII"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct isochBuffer {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct isochBuffer *Next;","\/*ptr to next block*\/"]},{"entry":[{},"struct isochBuffer *Previous;","\/*ptr to prev. Block*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPTION Circular",":1;","\/*list is circular*\/"]},{"entry":[{},"OPTION ResynchEvent",":4;","\/*optional resynch event*\/"]},{"entry":[{},"OPTION Sy",":4;","\/*sy field value*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"busTime Time;","\/*used with resynch event*\/"]},{"entry":[{},"localBufPtr ApplBufPtr;","\/*ptr to application data*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void (*IsochCompletion)(struct isochBuffer *buf);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/*completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void *UserPtr","\/*for use by the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"completion routine*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} isochBuffer, *isochBufferPtr;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The Next field contains the address of the next buffer in the list. The Previous field contains the address of the previous buffer in the list. The Circular field indicates that the complete set of buffers is circular. The ResynchEvent field contains an optional resynchronization event. A value of IMMEDIATE in this field indicates no resynchronization. When the ResynchEvent field contains a value of \u201cSYFIELD,\u201d the Sy field contains the sy value to pause for before transferring data into or out of this application data buffer. When the ResynchEvent field contains a value of \u201cTIME,\u201d the Time field contains the bus time to wait for before transferring data into or out of this application data buffer. The ApplBufPtr field contains the address of the application data buffer. This address may be logical, physical, scattered or contiguous, depending on the capabilities of the operating environment. The IsochCompletion field contains the address of the completion routine. If the value in this field is not null, then this routine is called when data transfer for this buffer is complete. The UserPtr field is available for use by the calling application's completion routine and is not modified by the API.","The ISOCHDetach routine retrieves application data buffers from the API and returns ownership to the application. The application may call this routine at any time to detach buffers from the IEEE 1394 interface hardware and the associated low layers of software. The requested buffers are detached when the completion routine is invoked. The calling convention for this routine is as follows:\n\n","The first parameter of an ISOCHDetach routine contains the address of a valid ISOCHOpenBlock data structure. The second parameter contains the address of an ISOCHAppendBlock data structure. This data structure describes the application data buffer list as defined above.","The applications programming interface of the first embodiment of the present invention provides an interface to an application and allows the application to transfer data over a bus structure in both isochronous and asynchronous data formats. The applications programming interface of the first embodiment supports transferring asynchronous data over the bus structure  during an isochronous data transfer. While the isochronous data is being transferred over the bus structure , the asynchronous data can be used to fill in the gaps. The IEEE 1394 standard specifies a worst case jitter for the isochronous data, thereby specifying a bounded latency for a packet of isochronous data. The API  therefore ensures that the packets of isochronous data are transferred during their appropriate time period. However, in the gaps between the packets of isochronous data, asynchronous packets of data are transferred.","In contrast to systems of the prior art, the API of the first embodiment of the present invention is capable of automating the transfer of asynchronous data by controlling an automatic transaction generator  which automatically generates the transactions necessary to complete an asynchronous data transfer over the memory-mapped bus structure . During an isochronous data transfer, a linked list of buffer descriptors, each representing a corresponding buffer, is maintained for transferring the data to or from the application over the bus structure . Each buffer can include a callback routine and a resynchronization event.","Isochronous API","An isochronous applications programming interface (API) according to the preferred embodiment of the present invention is implemented within any device transmitting or receiving isochronous data, such as either the computer system  or the video camera  of FIG. . The isochronous API according to the preferred embodiment of the present invention presents a virtual representation of a plug, using a plug handle, in which multiple client applications can register to a given plug. Once the client application is registered with the representation of the plug, the client application has an event handle that will signal the client application for any state changes that occur on the plug. The isochronous API also provides functions for the client application to establish the isochronous connection and the type of connection between devices on the bus. The isochronous API also manages data transfer operations through input and output plugs for client applications. When receiving a request from a client application for an isochronous data transmission or reception operation, the isochronous API connects an appropriate plug, allocates the appropriate resources and manages the resources during the operation.","An exemplary IEEE 1394-1995 serial bus network implementing the isochronous API of the present invention and including a computer system and a video camera is illustrated in FIG. . The computer system  includes an associated display  and is coupled to the video camera  by the IEEE 1394-1995 serial bus cable . Video data and associated data are sent between the video camera  and the computer system  over the IEEE 1394-1995 serial bus cable . The computer system  preferably includes the internal components and peripheral input and output devices as illustrated in FIG.  and implements the software layers, modules and drivers, as illustrated in FIG. .","The function of the isochronous API of the present invention is preferably implemented within a separate layer above the 1394 Bus Class driver , as illustrated in , for personal computer based implementations, such as within the computer system . The diagram illustrated in  is similar to the diagram illustrated in , except that an additional isochronous API layer  is added between the 1394 Bus Class driver  and the application layer . Alternatively, the function of the isochronous API of the present invention is implemented within a separate layer which side-by-side with the 1394 Bus Class driver . The isochronous API layer  manages the virtual representation of both input and output plugs for the device. Using a plug handle, multiple client applications can register to a given plug. The isochronous API layer  associates client applications that register with a given plug with the virtual representation of the plug. Once the client application is registered with the virtual representation of the plug, the client application has an associated event handle. The isochronous API layer  signals the client application of any state changes that occur on the plug through this associated event handle. The isochronous API layer  also provides functions for the client application to establish the isochronous connection and the type of connection for transmission of isochronous data between devices on the bus.","A hardware and physical interface  is included between the isochronous API layer  of the present invention and the IEEE 1394-1995 serial bus. The hardware and physical interface includes a bus interface for monitoring and managing the flow of data to and from the IEEE 1394-1995 serial bus structure.","An implementation of the isochronous API of the present invention within an embedded environment, such as the video camera , is illustrated in FIG. B. In this embedded environment, the isochronous API layer  is added between the 1394 Driver  and the application layer . Again, in this embedded environment, the isochronous API layer  manages the virtual representation of both input and output plugs for the device. Using a plug handle, client applications can register to a given plug. The isochronous API layer  associates client applications that register with a given plug with the virtual representation of the plug. Once the client application is registered with the virtual representation of the plug, the client application has an associated event handle. The isochronous API layer  signals the client application of any state changes that occur on the plug through this associated event handle. The isochronous API layer  also provides functions for the client application to establish the isochronous connection and the type of connection for transmission of isochronous data between devices on the bus.","A hardware and physical interface  is included between the isochronous API layer  and the IEEE 1394-1995 serial bus. The hardware and physical interface includes a bus interface for monitoring and managing the flow of data to and from the IEEE 1394-1995 serial bus structure.","Isochronous API Usage","Broadcast Transmission","Utilizing the isochronous API of the present invention, an application begins a broadcast transmission on an output plug, by transmitting a request to the isochronous API for a broadcast transmission. The isochronous API then connects an output plug, allocates the appropriate resources and manages the resources during the isochronous transmission. If an exception occurs during a broadcast transmission, then the isochronous API notifies the client application of the exception and allows the client application to handle the situation that caused the exception. A flowchart illustrating the exception handling process implemented by the isochronous API is illustrated in FIG. . This exception handling process is preferably implemented by the isochronous API in parallel with the broadcast and point-to-point operations, described herein.","The exception handling process starts at the step  in the flowchart of FIG. . The isochronous API waits at the step  until an exception condition occurs. Once an exception condition occurs, the isochronous API then notifies the client application at the step , as will be discussed below. The isochronous API then waits at the step  until the client application handles the exception condition. Once the client application has handled the exception condition, the isochronous API then returns to the step  to wait until another exception occurs.","A flowchart illustrating the process followed by the isochronous API in response to a broadcast transmission request from an application is illustrated in FIG. . This broadcast transmission process starts at the step . At the step , the output plug is created by calling a function OpenIsochOutputPlug, as defined in Table XIII below.",{"@attributes":{"id":"p-0182","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XIII"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS OpenIsochOutputPlug ( in BYTE plugNumber,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"in","ISOCH_OUTPUT_PLUG_REG"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"outputPlugData,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"in","BYTE dataFormat,"]},{"entry":[{},"in","EVENT plugEvent,"]},{"entry":[{},"out","PLUG_HANDLE *plugHandle )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0183","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XIV"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"BYTE channel;","\/*specifies isoch channel*\/"]},{"entry":[{},"BYTE dataRate:2;","\/*speed capability*\/"]},{"entry":[{},"BYTE overheadID:4;","\/* isoch overhead ID*\/"]},{"entry":[{},"BYTE payload:10;","\/*maximum quadlets per"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"packet*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BYTE pad;","\/*data struct padding*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} ISOCH_OUTPUT_PLUG_REG,"]},{"entry":[{},"*PISOCH_OUTPUT_PLUG_REG;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0184","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XV"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"DataRate Value","Speed Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","S100"]},{"entry":[{},"1","S200"]},{"entry":[{},"2","S400"]},{"entry":[{},"3","Reserved"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"An output parameter PLUG_HANDLE *plugHandle within the function OpenIsochOutputPlug is a handle to the opened plug and is used for other plug actions and to close the plug. A return value parameter STATUS returns a status value of success, specifying that the plug has been opened successfully, failed, specifying that the plug could not be opened, and invalid_parameter, specifying that the data passed in is not valid. The function OpenIsochOutputPlug opens a plug on which an isochronous stream is broadcast. A call to this function sets the online bit, allocates a resource, such as a DMA channel, for the plug, and while opened, if another device on the bus structure connects to the plug, the event that is passed in will be set. Until buffers are attached to the plug, dummy packets are broadcast from the plug.","After the output plug is created at the step , initial isochronous data buffers are then created and filled, at the step . After the buffers are created and filled, the isochronous data buffers are then attached to the plug, at the step , by calling the function AttachBufferToPlug, as defined in Table XVI below.",{"@attributes":{"id":"p-0187","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XVI"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS AttachBufferPlug ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"in","PLUG_HANDLE plugHandle"]},{"entry":[{},"in","PPLUG_BUFFER pPlugBuffers,"]},{"entry":[{},"in","UINT nBuffers )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0188","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XVII"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BYTE *pBuffer;","\/*specifies buffer"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"containing data*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"UINT bufferSize;","\/*size of the buffer*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PPLUG_BUFFER_CBACK Callback;\u2003\/*callback called when"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"buffer is filled, sent or"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"when an exception condition has occurred*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PVOID parameter 1;","\/*first parameter passed"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"through callback*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PVOID parameter2;","\/*second parameter passed"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"through callback*\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} PLUG_BUFFER, *PPLUG_BUFFER;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The parameter PPLUG_BUFFER_CBACK Callback represents a callback that is called after the buffer has been sent, in a transmission operation, filled, in a reception operation, and when an exception condition occurs. A plug exception condition occurs when an error is encountered during an isochronous transfer. This callback allows the isochronous API to inform the client application of the exception error that has occurred. This plug buffer callback has a structure as defined in Table XVIII below.",{"@attributes":{"id":"p-0190","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XVIII"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef void (*buffCback) ( PVOID param1, PVOID param2,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"PLUG_EXCEPTION exception)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PVOID parameter 1;"]},{"entry":[{},"PVOID parameter2;"]},{"entry":[{},"PLUG_EXCEPTION exception;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0191","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XIX"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef enum {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NO_EXCEPTION,"]},{"entry":[{},"DATA_OUT_OF_SEQUENCE,"]},{"entry":[{},"RECEIVING_DUMMY_PACKETS_ONLY,"]},{"entry":[{},"STREAM_FORMAT_CHANGED,"]},{"entry":[{},"DATA_OUT_OF_SYNC,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} PLUG_EXCEPTION;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The function AttachBufferToPlug is used to attach a series of one or more buffers to either an output plug, in the case of a broadcast, or an input plug, in the case of a reception. A return value parameter STATUS returns a status value of success, specifying that the buffers have been attached successfully, failed, specifying that the buffers could not be attached, invalid_plug_handle, specifying that the plug handle was not valid, and invalid_parameter, specifying that the parameter is not valid. If a callback is supplied, the callback is called when the buffer is either filled, in the receive case, or sent, in the transmit case and when an exception occurs during the isochronous data transmission. An exception condition occurs when issues with the isochronous data occur, as described above. If an exception does occur, preferably, after receiving notification of the exception condition, the client application handles the situation that caused the exception condition and recovers to continue the isochronous transfer operation.","After the isochronous data buffers are attached to the plug, at the step , the broadcast is then started by calling the function BroadcastTransmitOn, as defined in Table XX below, which allocates the appropriate isochronous bandwidth and channel, if necessary, at the step , and starts the broadcast, at the step , by incrementing the broadcast connection counter (BCC) of the output plug control register (oPCR) and informing the DMA to begin the isochronous transmission.",{"@attributes":{"id":"p-0194","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XX"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","BroadcastTransmitOn (","in PLUG_HANDLE *plugHandle,"]},{"entry":[{},{},"in BOOLEAN enableTakeOver )"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"After the broadcast has been started at the step , the data within the next buffer attached to the plug is transmitted at the step , and the registered callback is called. The buffer is then detached from the plug at the step , by calling the function DetachBufferFromPlug, as defined in Table XXI below.",{"@attributes":{"id":"p-0196","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XXI"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"STATUS","DetachBufferFromPlug ("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"in","PLUG_HANDLE plugHandle,"]},{"entry":[{},"in","PPLUG_BUFFER pplugBuffer )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"After the buffer is detached from the plug, at the-step , it is then determined at the step , if the transmission has been terminated. It should be apparent to those skilled in the art that the transmission can be terminated anytime during the broadcast transmission process including in the middle of the transmission of a buffer. If the transmission has not been terminated, then the next buffer is filled, at the step , and attached to the plug, at the step , as described above. Once the buffer is filled and attached to the plug, the data within the buffer is then sent out, at the step . Otherwise, if the transmission has been terminated, then the process ends at the step .","Utilizing the isochronous API of the present invention, an application ends a broadcast transmission on an output plug, by transmitting a request to the isochronous API to end the broadcast transmission. The isochronous API then ends the broadcast, deallocates the appropriate resources, if no other connections are present, detaches buffers from the plug and closes the plug. A flowchart illustrating the process followed by the isochronous API in response to an end broadcast transmission request from an application is illustrated in FIG. . This end broadcast transmission process starts at the step . At the step , the broadcast is then ended by calling the function BroadcastTransmitOff, as defined in Table XXII below, which decrements the broadcast connection counter (BCC) on the output plug control register (oPCR), determines if any other connections are present at the step , and if no other connections are present, then deallocates the isochronous bandwidth and channel associated with the plug, at the step .",{"@attributes":{"id":"p-0199","num":"0215"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XXII"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STATUS","BroadcastTransmitOff (","in PLUG_HANDLE"]},{"entry":[{},{},{},"*plugHandle )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"After it is determined that there are other connections present, at the step , or after the appropriate isochronous bandwidth and channel are deallocated, at the step , then, the buffers are detached from the plug, at the step , by calling the function DetachBufferFromPlug, as defined in Table XXI and discussed above. The plug is then closed at the step , by calling the function CloseIsochOutputPlug, as defined in Table XXIII below.",{"@attributes":{"id":"p-0201","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXIII"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","CloseIsochOutputPlug ( in PLUG_HANDLE handle )"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"442"},"When an ongoing broadcast transmission through a plug being represented by the isochronous API of the present invention is interrupted by another device, the isochronous API of the present invention stops the isochronous broadcast transmission and notifies the appropriate client application. A flowchart illustrating the process followed by the isochronous API when an ongoing broadcast transmission is interrupted by another device is illustrated in FIG. . This interrupted broadcast transmission process starts at the step . At the step , it is determined if another device has turned off the broadcast connection counter (BCC) of the local device's output plug control register (oPCR) to interrupt an ongoing broadcast transmission. A device turns off the broadcast connection counter (BCC) of the local device's output plug control register (oPCR) to interrupt an ongoing broadcast transmission by decrementing the broadcast connection counter (BCC) from one to zero. When another device turns off the broadcast connection counter (BCC), then the isochronous API stops the isochronous transmission, at the step , if all of the flags within the output plug control register (oPCR) are reset. At the step , the isochronous API then notifies the client application associated with the broadcast transmission on the output plug, that the broadcast transmission has been interrupted by another device. The process then ends at the step . When receiving this notification, the client application can wait for an event freeing the broadcast channel and restart the broadcast transmission or just abort the broadcast transmission.","Utilizing the isochronous API of the present invention, an application can request that a broadcast transmission is started and if appropriate, that the broadcast transmission deprive another device's transmission. In response to this type of request, the isochronous API of the present invention then connects an output plug, allocates the appropriate resources, including interrupting an existing broadcast transmission on the channel by another device and manages the resources during the isochronous transmission. This process is the same as the process followed by the API in response to a broadcast transmission request from an application illustrated in FIG.  and discussed above, with the exception that when the function BroadcastTransmitOn is allocating the isochronous channel, it may have to interrupt an ongoing broadcast transmission to obtain the channel. If it is determined during the allocation of resources at the step  () that the requested channel is being used for an ongoing broadcast transmission, the isochronous API then determines the broadcast channel base in order to determine the current transmission node for the channel. The isochronous API then reads the output plug control register (oPCR) of the transmission node. If the broadcast connection counter (BCC) is set and the point-to-point connection counter (PCC) is equal to zero, then the isochronous API resets the broadcast connection counter (BCC) of the transmission node to a value of zero, to interrupt the transmission. The broadcast connection counter (BCC) within the output plug control register (oPCR) of the local device is then set and the requested isochronous broadcast transmission is started, at the step .","Point-to-Point Transmission","Utilizing the isochronous API of the present invention, an application begins a point-to-point transmission on an output plug, by transmitting a request to the isochronous API to begin a point-to-point transmission. The isochronous API then connects an output plug, allocates the appropriate resources and manages the resources during the isochronous transmission to the input plug of the receiving device. If an exception condition occurs during a point-to-point transmission, then the isochronous API notifies the client application of the exception condition and allows the client application to handle the situation that caused the exception condition. The exception handling process is illustrated in , and discussed above.","A flowchart illustrating the process followed by the isochronous API in response to a point-to-point transmission request from an application is illustrated in FIG. . This point-to-point transmission process starts at the step . At the step , the handle of the receiving device is obtained by the isochronous API. Using the device handle, the isochronous API then obtains the input plug of the receiving device, at the step , using the function GetPlugNumber, as defined in Table XXIV below.",{"@attributes":{"id":"p-0207","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXIV"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["int","GetPlugNumber (","in","DEV_61883_HANDLE devHandle,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"in","PLUG_TYPE plugType",")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"sub":"\u2014"},{"@attributes":{"id":"p-0208","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE XXV"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum","PLUG_TYPE {"]},{"entry":[{},{},"ISOCH_INPUT_MASTER_PLUG,"]},{"entry":[{},{},"ISOCH_INPUT_CONTROL_PLUG,"]},{"entry":[{},{},"ISOCH_OUTPUT_MASTER_PLUG,"]},{"entry":[{},{},"ISOCH_OUTPUT_CONTROL_PLUG,"]},{"entry":[{},{},"ASYNC_CONN_INPUT_PLUG,"]},{"entry":[{},{},"ASYNC_CONN_OUTPUT_PLUG,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"At the step , the output plug is created by calling the function OpenIsochOutputPlug, as defined in Table XIII and discussed above. After the output plug is created at the step , initial isochronous data buffers are then created and filled, at the step . After the buffers are created and filled, the isochronous data buffers are then attached to the plug, at the step , by calling the function AttachBufferToPlug, as defined in Table XVI and discussed above.","After the isochronous data buffers are attached to the plug, at the step , the transmission is then started by calling the function PtoPTransmitOn, as defined in Table XXVI below, which allocates the appropriate isochronous bandwidth and channel, if necessary, at the step , and starts the transmission, at the step , by incrementing the point-to-point connection counter (PCC) of the output plug control register (oPCR) and informing the DMA to begin the isochronous transmission.",{"@attributes":{"id":"p-0211","num":"0227"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXVI"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","PtoPTransmitOn (","in","PLUG_HANDLE *plugHandle,"]},{"entry":[{},{},"in","DEV_61883_HANDLE devHandle,"]},{"entry":[{},{},"in","BYTE plugNumber )"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{},"sub":"\u2014"},"After the transmission has been started at the step , the data within the next buffer attached to the plug is transmitted at the step , and the registered callback is called. The buffer is then detached from the plug at the step , by calling the function DetachBufferFromPlug, as defined in Table XXI and discussed above. After the buffer is detached from the plug, at the step , it is then determined at the step , if the transmission has been terminated. If the transmission has not been terminated, then the next buffer is filled, at the step , and attached to the plug, at the step , as described above. Once the buffer is filled and attached to the plug, the data within the buffer is then sent out, at the step . Otherwise, if the transmission has been terminated, then the process ends at the step . As described herein, the isochronous API of the present invention utilizes a buffer management scheme to attach and detach buffers during the transmission and reception of data. Alternatively, as should be apparent to those skilled in the art, any other appropriate buffer management scheme can be used to transmit and receive data, including a circular buffer scheme.","Utilizing the isochronous API of the present inventions an application ends a point-to-point transmission on an output plug, by transmitting a request to the isochronous API to end the point-to-point transmission. The isochronous API then ends the point-to-point transmission, deallocates the appropriate resources, if no other connections are present, detaches buffers from the plug and closes the plug. A flowchart illustrating the process followed by the isochronous API in response to an end point-to-point transmission request from an application is illustrated in FIG. . This end point-to-point transmission process starts at the step . At the step , the transmission is ended by calling the function PtoPTransmitOff, as defined in Table XXVII below, which decrements the point-to-point connection counter (PCC) on the output plug control register (oPCR), determines if any other connections are present at the step , and if no other connections are present, then deallocates the isochronous bandwidth and channel associated with the plug, at the step .",{"@attributes":{"id":"p-0214","num":"0230"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXVII"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","PtoPTransmitOff (","in","PLUG_HANDLE *plugHandle,"]},{"entry":[{},{},"in","DEV_61883_HANDLE"]},{"entry":[{},{},{},"devHandle,"]},{"entry":[{},{},"in","BYTE"]},{"entry":[{},{},{},"plugNumberToDisconnect )"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{},"sub":"\u2014"},"After it is determined that there are other connections present, at the step , or after the appropriate isochronous bandwidth and channel are deallocated, at the step , then, the buffers are detached from the plug, at the step , by calling the function DetachBufferFromPlug, as defined in Table XXI and discussed above. The plug is then closed at the step , by calling the function CloseIsochOutputPlug, as defined in Table XXIII and discussed above. After the point-to-point transmission is turned off and the plug is closed, the process then ends at the step .","Broadcast Reception","Utilizing the isochronous API of the present invention, an application begins a broadcast reception on an input plug, by transmitting a request to the isochronous API to begin the broadcast reception. The isochronous API then connects an input plug, allocates the appropriate resources and manages the resources during the isochronous reception. A flowchart illustrating the process followed by the isochronous API in response to a broadcast reception request from an application is illustrated in FIG. . This broadcast reception process starts at the step . At the step , the input plug is created by calling the function OpenIsochInputPlug, as defined in Table XXVIII below.",{"@attributes":{"id":"p-0218","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXVIII"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS OpenIsochInputPlug (","in","BYTE plugNumber,"]},{"entry":[{},"in","BYTE channel,"]},{"entry":[{},"in","BYTE dataFormat,"]},{"entry":[{},"in","EVENT plugEvent,"]},{"entry":[{},"out","PLUG_HANDLE *plugHandle )"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"After the input plug is created at the step , initial isochronous data buffers are then created, at the step . After the buffers are created, the isochronous data buffers are then attached to the plug, at the step , by calling the function AttachBufferToPlug, as defined in Table XVI and discussed above.","After the isochronous data buffers are attached to the, plug, at the step , the broadcast reception is then started by calling the function BroadcastReceiveOn, as defined in Table XXIX below, which allocates the appropriate isochronous bandwidth and channel, if necessary, at the step , and starts the broadcast reception, at the step , by incrementing the broadcast connection counter (BCC) of the input plug control register (iPCR) and informing the DMA to begin the isochronous transmission.",{"@attributes":{"id":"p-0221","num":"0237"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXIX"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","BroadcastReceiveOn ( in","PLUG_HANDLE *plugHandle )"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"After the broadcast reception has been started at the step , the received data is stored within the next buffer attached to the plug at the step . Once the buffer is full of received data, then the registered callback is called. The buffer is then detached from the plug at the step , by calling the function DetachBufferFromPlug, as defined in Table XXI and discussed above.","After the buffer is detached from the plug, at the step , it is then determined at the step , if the transmission has been terminated. If the transmission has not been terminated, then the data within the filled buffer is processed, at the step , and the empty buffer is then attached to the plug, at the step , as described above. Once the buffer is emptied and attached to the input plug, the buffer is then again used to receive data, at the step . Otherwise, if the transmission has been terminated, then the process ends at the step .","Utilizing the isochronous API of the present invention, an application ends a broadcast reception on an input plug, by transmitting a request to the isochronous API to end the broadcast reception. The isochronous API then ends the broadcast reception, deallocates the appropriate resources, if no other connections are present, detaches buffers from the plug and closes the plug. A flowchart illustrating the process followed by the isochronous API in response to an end broadcast reception request from an application is illustrated in FIG. . This end broadcast reception process starts at the step . At the step , the broadcast reception is then ended by calling the function BroadcastReceiveOff, as defined in Table XXX below, which decrements the broadcast connection counter (BCC) on the input plug control register (iPCR), determines if any other connections are present at the step , and if no other connections are present, then deallocates the isochronous bandwidth and channel associated with the plug, at the step .",{"@attributes":{"id":"p-0225","num":"0241"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXX"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","BroadcastReceiveOff ( in","PLUG_HANDLE *plugHandle )"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"After it is determined that there are other connections present, at the step , or after the appropriate isochronous bandwidth and channel are deallocated, at the step , then, the buffers are detached firm the plug, at the step , by calling the function DetachBufferFromPlug, defined in Table XIX and discussed above. The plug is then closed at the step , by calling the function CloseIsochInputPlug, as defined in Table XXXI below.",{"@attributes":{"id":"p-0227","num":"0243"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXXI"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","CloseIsochInputPlug ( in","PLUG_HANDLE *plugHandle )"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"562"},"Point-to-Point Reception","A point-to-point reception is started as discussed above, to receive a point-to-point transmission. A client application can also request that a point-to-point reception be overlayed on a current broadcast reception by transmitting a point-to-point reception overlay request to the isochronous API of the present invention. The isochronous API then determines that the broadcast reception has been started, obtains the handle of the source device, allocates the appropriate resources and manages the resources during the reception from the output plug of the source device. A flowchart illustrating the process followed by the isochronous API in response to a point-to-point reception overlay request from an application is illustrated in FIG. . This point-to-point reception overlay process starts at the step . At the step , it is determined if the broadcast reception has started. Once the broadcast reception starts, then the handle of the source device is obtained by the isochronous API, at the step . Using the device handle, the isochronous API then obtains the output plug of the source device, at the step , using the function GetPlugNumber, as defined in Table XXIV and discussed above.","Because this is an existing reception, the input plug and data buffers are already initialized. After the isochronous data buffers are attached to the plug, the point-to-point reception is then started by calling the function PtoPReceiveOn, as defined in Table XXXII below, which allocates the appropriate isochronous bandwidth and channel, if necessary, at the step , and starts the reception, at the step , by incrementing the point-to-point connection counter (PCC) of the input plug control register (iPCR) and informing the DMA to begin the isochronous reception.",{"@attributes":{"id":"p-0231","num":"0247"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXXII"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","PtoPReceiveOn (","in","PLUG_HANDLE *plugHandle,"]},{"entry":[{},{},"in","DEV_61883_HANDLE devHandle,"]},{"entry":[{},{},"in","BYTE plugNumber )"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{},"sub":"\u2014"},"After the reception has been started at the step , the received data is stored within the next buffer attached to the plug at the step . Once the buffer is full of received data, then the registered callback is called. The buffer is then detached from the plug at the step , by calling the function DetachBufferFromPlug, as defined in Table XXI and discussed above.","After the buffer is detached from the plug, at the step , it is then determined at the step , if the transmission has been terminated. If the transmission has not been terminated, then the data within the filled buffer is processed, at the step , and the empty buffer is then attached to the plug, at the step , as described above. Once the buffer is emptied and attached to the plug, the buffer is then again used to receive data, at the step . Otherwise, if the transmission has been terminated, then the process ends at the step .","Utilizing the isochronous API of the present invention, an application ends a point-to-point reception on an input plug, by transmitting a request to the isochronous API requesting to end the point-to-point reception. The isochronous API then ends the point-to-point reception, deallocates the appropriate resources, if no other connections are present, detaches buffers from the plug and closes the plug. A flowchart illustrating the process followed by the isochronous API in response to an end point-to-point reception request from an application is illustrated in FIG. . This end point-to-point reception process starts at the step . At the step , the reception is then ended by calling the function PtoPReceiveOff, as defined in Table XXXIII below, which decrements the point-to-point connection counter (PCC) on the input plug control register (iPCR) of the local device and the output plug control register (oPCR) of the source device, determines if any other connections are present at the step , and if no other connections are present, then deallocates the isochronous bandwidth and channel associated with the plug, at the step .",{"@attributes":{"id":"p-0235","num":"0251"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE XXXIII"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["STATUS","PtoPReceiveOff (","in","PLUG HANDLE *plugHandle ,"]},{"entry":[{},{},"in","DEV_61883_HANDLE devHandle,"]},{"entry":[{},{},"in","BYTE plugNumberToDisconnect )"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{},"sub":"\u2014"},"After it is determined that there are other connections present, at the step , or after isochronous bandwidth and channel are deallocated, at the step , then, the buffers are detached from the plug, at the step , by calling the function DetachBufferFromPlug, defined in Table XXI and discussed above. The plug is then closed at the step , by calling the function CloseIsochOutputPlug, defined in Table XXIII and discussed above. After the point-to-point reception is turned off and the plug is closed, the process then ends at the step .","The isochronous API of the preferred embodiment of the present invention implements and manages isochronous data transfer and receive operations between a client application and a bus structure. The isochronous API presents a virtual representation of a plug, using a plug handle, in which multiple client applications can register to a given plug. The isochronous API also notifies a client application of any state changes on a connected plug through the event handle, ensuring that the client application is informed about the state changes. The isochronous API also manages buffers utilized during a data operation on a connected plug by attaching and detaching the buffers to the connected plug, as appropriate, to manage the data flow.","The present invention has been described in terms of specific embodiments incorporating details to facilitate the understanding of the principles of construction and operation of the invention. Such reference herein to specific embodiments and details thereof is not intended to limit the scope of the claims appended hereto. It will be apparent to those skilled in the art that modifications may be made in the embodiment chosen for illustration without departing from the spirit and scope of the invention. Specifically, it will be apparent to those skilled in the art that while the preferred embodiment of the present invention is used with an IEEE 1394-1995 serial bus structure, the present invention could also be implemented on any other appropriate bus structures."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3","b":["50","52","54","56","58"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5","b":"20"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 8","b":"200"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
