---
title: Converting information into different formats
abstract: A software layer (filter driver) residing between software components or application programs running locally or on a client across a network and a persistent store of an operating system provides on-the-fly conversions of persistent information formats. The filter driver determines which format a program expects, and dynamically converts the information from its storage format to the format expected by the program. Conversion includes both data format conversion, and conversion of access semantics. Loadable conversion modules are provided for converting application specific formats due to the potential large number of such formats which can be encountered. The filter driver may change the format that information is stored in based on access history or other system requirements. The software components or application programs may be ignorant of the true storage format used by the system, and thus the filter driver can be used to give old versions of software access to information stored in newer formats.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747594&OS=07747594&RS=07747594
owner: Microsoft Corporation
number: 07747594
owner_city: Redmond
owner_country: US
publication_date: 20040528
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["Related Applications","FIELD OF THE INVENTION","COPYRIGHT NOTICE\/PERMISSION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Hardware and Operating Environment","Conclusion"],"p":["This patent application is a continuation of and claims priority to U.S. patent application Ser. No. 10\/371,492, filed on Feb. 21, 2003 and issued on Jun. 1, 2004 as U.S. Pat. No. 6,745,176, which is a divisional of and claims priority to U.S. patent application Ser. No. 09\/157,698, filed on Sep. 21, 1998 and issued on Apr. 15, 2003 as U.S. Pat. No. 6,549,918.","This invention relates generally to the field of processing computer information formats and more particularly to a method and system for dynamically accessing information in a format different than the format used by the computer system to internally represent the information.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whosoever. The following notice applies to the software and data as described below and in the drawing hereto: Copyright \u00a9 1998, Microsoft Corporation, All Rights Reserved.","Computer applications such as document processors, data base programs, simulators, games, editors, and compilers all need to persist information even the application is not running. Computer systems store persistent information in a variety of ways, including disk-based file systems, data bases, hierarchical storage systems, internet servers, and distributed memory. Persistent application data is stored in different formats depending on the type of application, and even depending on the version of a single application. The format of the information is what gives meaning to the binary bits which are used to represent the information. The format includes both the explicit details of how to interpret the bits, as well as the rules that are to be observed when accessing the information such as how to concurrently access the data from multiple users, how to sequence modifications to the information so that it can be recovered after a system crash, or how to maintain auxiliary data used to manage the information for purposes such as workflow management, auditing, or security. Multiple formats can be applied to the same information. The persistent storage that holds the information produced by an application is sometimes referred to as a file. The computers on which such applications run have file systems and other persistent stores which store the files out onto memory devices in yet further forms. These multiple different formats, both at the application level and at the file server level lead to difficult interoperability problems. For example, a document produced by a later version of a document processor is often not readable by a previous version of the document processor. When a user buys a new computer loaded with the latest software, produces a document, and gives a copy of the document to someone else only having a previous version of the software, the copy can be useless and indecipherable by the previous version.","Further difficulties arise when a user desires to share documents and other files over a network with a person using a different operating system or application, or even a different version of the same operating system or application. If the different systems use different formats for the information, due to changes in the applications, or internal operating system components, they may have difficulty sharing information. In particular the newer system or application may use an information format that was invented after the earlier system was developed. These difficulties also arise with different applications that use a common type of information, but expect different formats, such as image processing applications that use JPEG instead of GIF, or document processors which use HTML instead of Word7 format. Incompatibilities can also be due to the file systems or other persistent stores used by different operating systems. One type of operating system has file savers that store data files formatted as a single stream. Applications with the file server via an interface, such as OLE32, and expected the data to be returned to it in a certain format. OLE32 was specifically designed to retrieve and transfer data in the single stream format of docfiles. A newer or different type of file format may use the same set of interfaces, but store the information in a different format, perhaps relying on a file system format that supports multiple streams in a single storage container, and this results in a compatibility problem.","Prior attempts to solve the problem of using different versions of applications and different applications storing data in different formats involved the use of conversion programs which performed explicit conversions on information between formats. Thus, when opening a document, a user would be presented with a choice of converting a document to a new format prior to opening it. Also, on storing out a document, a user may select many different application level formats in which to store it. These solutions worked well for new versions of software, where the support for such conversions was built into the programs, but did not work well when an older version of software was confronted with a data format produced by a newer version. If a user of the new version failed to explicitly save the information in a format that was understood by earlier systems, the information would be unavailable to users on earlier systems. Either the earlier system must be upgraded with a new program to convert the data, or the newer program must be started again and the file converted prior to trying to use the older version to work with it. This was an unsatisfactory solution because the older application or system would not understand that the information was in a newer format, and give the user confusing error messages. Even where the format problem could be detected, there were generally no tools available on the older system to effect the conversion. The problem is also common on computers coupled by network, where a file server, remote database or other distributed persistent storage mechanism may store data in a newer file system format, or there may be multiple versions of the same software on different machines, and one user does not have access to newer versions in order to appropriately transform application information formats.","Some image processing applications keep an image file in an internal compressed format, and then use an operating system driver to transform the file to appear to be in a fixed set of well-know image formats (JPEG, GIF, etc.). It does not allow modifications to the well-known formats, and is only involved in data format conversion.","Such solutions also fail to provide more than data format conversion. The \u2018how to\u2019 rules associated with the format are not implemented, so users cannot share or manage the information. This type of format conversion produces a copy of the information in the old format, which can be accessed or modified independently of the original, producing inconsistencies between the separately stored versions of the information.","There is a need for an easier and more convenient way to provide interoperability between different versions of applications and operating system persistent storage systems. There is a need for such a way which does not require modifications to the applications, and that is backward compatible with existing applications. The provision of such interoperability should be transparent to a user and should also be provided in an efficient manner. Further, it should allow persistent application information to be dynamically shared and managed according to the rules of the newer format, rather than requiring users of older software to only make a copy of the information in an older format.","An operating system layer resides between software components or application programs that expect information to be in one format and a persistent store manager of the operating system which maintains the information in its persistent form. The operating system layer, which is referred to as a filter driver, provides on-the-fly conversion between the file format expected by the application layer and the format used by the persistent store manager. The filter driver determines which format a program expects, and dynamically converts the information to such a format, including both the static layout of the binary data as well as the dynamic rules for how to access the data.","Computer programs access persistent information by invoking Application Programming Interfaces (APIs) which make copies of the information in the persistent store available in the program's memory, and also update the persistent store with any desired changes. In addition to the static binary data portion of the information, there is auxiliary information regarding aspects such as dates, security, amount of information available, and other properties. This auxiliary information is sometimes called \u2018meta-data.\u2019 The filter driver dynamically converts between formats by copying information between the persistent store and the application's memory according to a conversion algorithm, providing the application with a \u2018view\u2019 of the file that is different from the view offered by the underlying storage system. The \u2018converted view\u2019 provided by the filter driver does not necessarily mean that all the data and meta-data of the file has been converted. The requirement is only that the data that is copied into the application's memory appears to have been converted.","Both file system formats and application program specific formats are convertible by the filter driver. This allows applications and other programs to operate transparently with different file systems and older versions of applications without modification. In one instance of the invention, separate loadable conversion modules are provided for converting application specific formats due to the potential large number of such formats which can be encountered.","Loadable conversion modules are provided as either parts of the operating system or as parts of distinct applications. For example two versions of a word processor application might run on the same system, with the newer one storing documents in a different format. The newer version of the application could provide a conversion module for use by the filter driver to allow files created by the new application to be accessed by the old application.","The filter driver may reside in the kernel of an operating system of a computer system. Applications may be operating directly on the computer system, or may be networked to the computer system. In either event, the filter driver sits above a persistent store, such as a file system and intercepts requests for stored information coming from the local Application Programming Interfaces (APIs) or across the network. An indication that an application requires a data format transformation is provided to the filter driver by either the application specifying the desired format, or it is deduced from information such as the version of the system or application opening the file. If no indication of the desired format is provided, an older version of the application is assumed which requires the information to be in an older, well-known format. The stored form of the information may be converted to an intermediate format which is maintained by the filter driver to handle semantic differences. The intermediate format may include cached information in order to improve performance and avoid having to convert files with each access. The filter driver may also keep a file in different formats depending on access history or other system requirements.","Statistics are kept on the manner in which the information containers are accessed. The statistics are used to estimate the overall cost of dynamic conversion from the various alternatives for the actual storage format. If it is estimated that the overall costs, measured in cpu cycles, memory requirements, on-disk storage size, and similar resource metrics, will be less if a new stored format is used, the stored form of the information can be translated to a new format using otherwise idle system resources, such as during night or weekend hours.","The filter driver allows applications to open files in the formats that they expect even though the underlying file system and data format may be different. If the file's true format and expected format are compatible, the filter driver allows the open to succeed directly, bypassing the filter driver. If the formats are incompatible, then when the application reads and writes the file, the filter driver causes the file to appear in the expected format. Semantic information regarding concurrent access between applications is also translated. Auxiliary information having implied semantics such as access control lists, management information, property sets, alternate representations, cached information, annotations, audit trails and other similar information is also maintained and may be cached for faster access.","One benefit of the current invention is that parts of a system may be updated to work with a new file system or new versions of software without having to ensure that the entire system is at the same time. This makes upgrades easier to perform, and also allows upgrades to take place in stages, which can be very important for organizations with large numbers of systems. Applications can also embed files in a new context, such as in emails or copying to an offline media, where specific formats are required. Since the filter driver resides in or near the kernel, overhead of the conversions are low, and conversion is transparent to the applications. Further, when converting back to an older format the filter driver can choose a more efficient representation of the information in the older format based on information in the newer format, such as in WindowsNT 5.0 where NSS to docfile conversion results in contiguous file allocation tables.","In the following detailed description of exemplary embodiments of the invention, reference is made to the accompanying drawings which form a part hereof, and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiment may be utilized and that logical, mechanical, electrical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims.","The detailed description is divided into multiple sections. In the first section, the hardware and the opening environment in conjunction with which embodiments of the invention may be practiced are described. In the second section, the environment and operation of a filter driver for converting between selected formats is discussed. In the third section, different additional functions relating to the filter driver are discussed followed by a conclusion which states some of the potential benefits and describes further alternative embodiments.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["20","21","22","23","21","23","22","24","25","26","24","20","24","20","27","28","29","30","31","27","28","30","23","32","33","34","20","29","31"]},"Program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  and RAM . Program modules may include operating system , one or more application programs , other program modules , and program data . A user may enter command and information into personal computer  through input devices such as a keyboard  and a pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial-port interface  coupled to system bus ; but they may be contained through other interfaces not shown in , such as a parallel port, a game port, or a universal serial bus (USB). A monitor  or other display device also connect to system bus  via an interface such as a video adapter . A video camera or other video source is represented at  as being coupled to video adapter  for providing video images for video conferencing and other applications, which may be processed and further transmitted by the computer . In further embodiments, a separate video card may be provided for accepting is from multiple devices , including satellite broadcast encoded images. In addition to the monitor, personal computers topically include other peripheral output devices (not shown) as speakers and printers.","Personal computer  may operate in a networked environment using logical connections to one or more remote computers such as remote computer . Remote computer  may be another personal computer, a server, a router, a network PC, a peer device, or other common network node. It typically includes many or all of the components described above in connection with personal computer ; however, only a storage device  is illustrated in . The logical connections depicted in  include local-area network (LAN)  and a wide-area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When placed in a LAN networking environment, PC  connects to local network  through a network interface or adapter . When used in a WAN networking environment such as the Internet, PC  typically includes modem  or other means for establishing communications over network . Modem  may be internal or external to PC , and connects to system bus  via serial-port interface . In a networked environment, program modules, such as those comprising Microsoft\u00ae Word which are depicted as residing within  or portions thereof may be stored in remote storage device . Of course, the network connections shown are illustrate, and other means of establishing a communications link between the computes may be substituted.","Software may be designed using many different methods, including C, assembler, VisualBasic, scripting langages such as PERL or TCL, and object oriented programming methods. C++ and Java are two examples of common object oriented computer programming languages that provide functionality associated with object oriented programming.","An interface is a group of related functions that are organized into a named unit. Each interface may be uniquely identified by some identifier. Interfaces have no instantiation, that is, an interface is a definition only without the executable code needed to implement the methods which are specified by the interface. An object may support an interface by providing executable code for the methods specified by the interface. The executable code supplied by the object must comply with the definitions supplied by the interface. The object may also provide additional methods. Those skilled in the art will recognize that interfaces are not limited to use in or by an object oriented programming environment.","In , a client system  comprises an application such as Microsoft Word which utilizes several system libraries and components , and interfaces with an input\/output (I\/O) manager . The system libraries include OLE32 in one embodiment, which comprise a set of well known interface for providing multiple streams and other internal structure to a single information container stored by storage system or file system The version of OLE32 in  is older, and uses a docfile format which stores information in a single stream of the unit container provided by the file system. A dynamic conversion filter driver  resides between the I\/O manager  and a file system client  on an NTOS WindowsNT\u00ae kernel driver stack. The filter driver  provides conversion between different file or storage system formats to provide the application  and system libraries  with the ability to access information in the format that they know how to handle. Filter driver  will recognize the desired format, and provide a dynamic view of the information in that format. Even error codes are converted in case the application relies on such codes from the file system that it expects is handling and storing the data. The filter driver resides in the kernel of the operating system in one embodiment, and also has the ability to invoke loadable conversion modules for providing conversion of further application level and file system level formats. The loadable modules can be provided by the operating system. They can also be provided by applications so that data created in a new format can be made available to earlier versions of the application that expect a different format.","Application  can also access data to a network connection represented at . A server system also comprises a network connection  coupled to a remote filesystem server  which is in turn interfaced to a server I\/O manager . I\/O manager routes file interactions through a server conversion filter driver , which also has the ability to invoke loadable conversion modes . The filter driver  interfaces with a native file system  which stores data in a multi stream format on secondary storage . Secondary storage  comprises virtual or physical disks or other type of persistent storage. The native file system  is provided by Microsoft\u00ae WindowsNT\u00ae 5.0, and supports a multiple formats for document files. Documents stored on the WindowsNT FAT file system can be stored in the docfile format. Documents stored on the NT file system (NTFS) can be stored in either docfile or a native store storage (NSS). Docfile format is also available on previous Microsoft Windows\u00ae Systems, but NSS format is available only on WindowsNT 5.0 or later. The NTFS file system stores data in a multi-stream format, with the different streams representing different types or formats of data in a document, such as text, graph and spreadsheet. Applications written with the NSS format, utilize the same set of in which are used for docfiles, but the information is stored in the NSS format. When information stored in NSS format is transferred to other systems, or even to file systems on the same system which do not support the multi-streams of NTFS, there is a compatibility problem.","An application  residing on the server system  utilizes system libraries and components  and accesses data stored on the server through I\/O manager  as well. The two filter drivers  and  can be stacked across the network, and the conversion modules within a particular system can also be stacked. Thus, if there is a conversion provided between formats A and B on the client side, and between B and C on the server side, they can be stacked to get conversion between A and C. It is generally best to avoid stacking conversions for performance reasons, but being able to access data at any speed is better than not being able to access it at all. If a single conversion between A and C is available on only one of the client and server, only one conversion need take place. It should be noted that a filter driver on the server side may be all that is required, as it can provide format conversions on the client's view of information prior to providing it to the client, and also can appropriately transform information provided by the client to the proper format for storage on the server.","In further embodiments, the conversion modules provide for conversion of data for different versions of a single application, such as between documents stored in a Word 7.0 format and a Word 8.0 format. Software to perform such conversions is well known in the art, and is highly dependent on the particular applications involved. Further conversion modules can provide data from different applications, such as other word processors, spreadsheets, or imaging programs winch may have their own formats for storing data. One example of such a format is the tag based form of hypertext language (html). In this example, a word processor which is not tag based, may store a document in one format, and an html editor may request access to that document in html format. Upon receiving such a request to open the file containing the document, the filter driver may invoke a conversion module to perform dynamic conversion and provide an html view of the document to the html editor. Further conversion of the underlying storage format may also be required. These conversions can be transparent to the html editor such that it believes that it directly accessed an html file from the storage system. Upon completion of viewing or editing the document, the reverse conversions are performed, and the document is again stored in a non-html format in the original file system format",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3","b":["312","314","316","316","314","318","320","322","324","326","320","314","312"]},"Although OLE32  expects the WORD document to be represented as a single stream docfile, the OLE32 on the WindowsNT 5.0 system has previously stored the document using the new Native Structured Storage (NSS) format. The data shown in , , , and  are logical views of the data actually stored in , ,  and .","A dynamic storage format conversion filter at  converts between the docfile format view expected by Windows 95\/OLE32 and the multi stream structure NSS storage format used on WindowsNT 5.0 by default as represented in blocks , , , ,  and . The native structured storage is represented by a block  of synthesize metadata, which comprises auxiliary information about the file to aid in quickly converting it to the format desired by the application. Pointers and hints about the conversion are kept in streams represented by block . It can also include audit trails of file access, such as the identity and time of access to a file, and also a record of changes to allow reconstruction of various temporal versions of the file. Further information can include work flow semantics to ensure that proper approvals are obtained prior to changing a document by a member of a group, or to otherwise manage work flow. The application data, or user data is stored in multiple streams as indicated at blocks ,  and , while native format specific metadata is stored at block  and comprises a separate stream of associated attributes such as names of the files, and other well known information related to the NTFS file system.","The on-the-fly conversion allows non-WindowsNT 5.0 clients, such as older version applications, to read and write NSS files as if they were in docfile format, without severe performance penalty. It also allows NSS files to be concurrently accessed according to \u2018how-to\u2019 rules that satisfy both older docfile and newer NSS format requirements. Files in NSS format are not degraded to docfile format, unless absolutely necessary, such as when DOCVIEW is corrupted, or is being copied to a non-NTFS 5 volume.","The format of an information container includes more than the logical layout and semantics of the data. There may be auxiliary information that has implied semantics (ACLs, reparse points props sets, auxiliary data streams, alternate representations, cached information, annotations, audit trails, workflow specifications, synthesized data). Some of the semantics can be or more complex than just what data to provide for a read operation. Different status codes may be returned depending on the history of operations by the current, as well as other concurrent, applications and the underlying state of the system and network. When information is returned, the information itself may be dependent on the histories in a formalized way. The filter driver must also maintain the formal semantics relating to extraordinary events, such as system caches. The details of all these semantic considerations are part of the file format, and are translated by the filter-driver when providing a view of information requiring dynamic information conversion.","When applications open files, or database records, or other persistent information containers, they specify the format version that they expect to see by means of a parameter to the API, a naming convention, or through a default expected-format rule, though the file may actually be stored in a different format. If the file's true format and the expected format are compatible, the filter driver allows access to the information. When the application reads, writes or otherwise accesses the file, the filter driver give the application a view of the file that appears to be in the expected format.","Besides the format of the data, the filter-driver also translates semantic information regarding concurrent access between applications exposing various formats, as well as maintaining auxiliary information and meta-data, used for managing information and for other purposes, such as crash recovery or performance tuning.","When a file of a particular format-type is created, the filter driver picks a default format based on the format specified by the client and the target storage system where the file will reside. The filter driver not only provides a client with the expected format through dynamic conversion, it may also convert the actual format that a file is stored in. If an application opens a file in one format, but then changes the format itself to an unknown format, the final format may be used by the filter driver to store the modified file in the file system.","Files moved between storage systems with different characteristics may need to be converted to different formats. Also, a filter driver may keep a file in different formats depending on its access history, optimizing for the most common access, or using a private internal format that isn't exposed to applications.","In one embodiment of the invention, the filter driver is used to provide dynamic conversion between the multi-stream NSS format file used by the OLE32 component in WindowsNT 5.0 and the single-stream docfile used by OLE32 in earlier systems. The internal structure of a docfile can be quite complex\u2014due to the allocation\/de-allocation of FAT sectors over time. NSS files leverage the implementation of multi-stream files in NTFS to remove the allocation structures (FAT, DIF (double indirect FAT), and mini-FAT). When the filter driver synthesizes the docfile format from an NSS file when open is requested at  in , the NSS file is relieved at , and a cache is checked to see if allocation structures already exist. If not, appropriate docfile allocation structures are generated at . However they can be given a clean start using contiguous allocations, making the conversion from multi-stream format relatively easy to perform on-the-fly. The synthesis requires additional cycles on the server, but the synthesized data is cached at  between opens of docfile views. The stream that contains the synthesized docfile metadata is referred to as the conversion stream. The conversion stream, together with the NSS large streams and the ministream, which reside in native NTFS streams, comprise the docfile view of the NSS file which is provided to the application at .","Dynamic conversion maps docfile view read\/write requests into accesses on the underlying NITS streams . The key differences been the docfile and NSS formats are that the docfile FAT and DIF are missing from the NSS format. The allocation metadata for each large stream is maintained internally by NTFS. The header and the directory stream have different representations. The NSS ministream uses continuous allocation of small streams, eliminating the need for the docfile mini-FAT.","When a docfile view is extended, additional storage is allocated at the end of the conversion steams. If a docfile view is modified, the ages show up in the underlying streams. When the final docfile view is closed, the filter driver reconverts the internal conversion format that supports the docfile view into NSS format at  and ends at . Reconversion is performed carefully so that it can be recovered by the filter driver the next time the file is opened, if the system crashes while reconversion is being formed.","After a docfile view is opened until reconversion is complete, the native NSS view of the storage format of the file is unavailable. If a concurrent NSSVIEW open is attempted, it fails\u2014and OLE32\/STG will reopen for a docfile view. If there is already an NSS view open when a docfile view is opened, the filter driver follows the NSS\/docfile commit protocol to obtain a consistent view of the NSS file. The filter driver then performs a full conversion by copying all the NSS streams into the conversion stream after the synthesized docfile metadata. Every subsequent docfile view open performs another full conversion until all views of the file have been closed. Each full conversion will overwrite the previous conversion stream. The commit protocol keeps existing docfile view opens for trying to take a snapshot of the docfile view while a new docfile view open does full conversion.","Local opens of NSS files normally use an NSS view of the file, while network opens require a docfile view. For the most part, the operations on an NSS view are just passed down the driver stack. Operations on a docfile view are mapped into operations on the underlying streams using the conversion map, which specifies which parts of the docfile view live in the conversion stream and which parts live in the native NSS streams (i.e. the ministream and the large streams). This mode of operation is called partial conversion.","When there are both NSS views and docfile views on the same file, interoperation is complicated. In the general case, commits can occur from either type of view. A commit from an NSS view can be propagated to a docfile view simply by regenerating the conversion map and conversion stream. But a commit from a docfile view is much more expensive. The FAT\/DIF, mini-FAT and other docfile metadata have to be analyzed. This is the same operation performed when the last docfile view is closed (reconversion), but is too expensive to perform at every commit of a docfile view.","To avoid the overhead of it reconversion if an NSS view exists, the filter driver creams a complete copy of the docfile view in the conversion stream, rather than just the docfile metadata . This mode is called full conversion. Although the binary data in the format is fully converted in this case, the \u2018how-to\u2019 semantics continue to be implement by the filter driver. Achieving the desired behavior requires the cooperation of the OLE\/NSS implementation. If a docfile view is already open, the filter driver fails any NSS view opens and OLE32 in WindowsNT 5.0 retries requesting a docfile view.","The full conversion docfile view is updated every time a new docfile view open occurs, if needed. The full conversion is also updated at the end of every NSS view commit.","The NSS format in ea new traction implementation for structured storage. Changes arm recorded in a transaction log in a scratch stream. A concurrent docfile view open has to apply the changes specified in the log in order to see the correct NSS file. If the system or application crashed, then there will not be an NSS view when the log is processed by the filter driver, and the scratch stream will be deleted (and a ScratchID in an NSS header reset to invalid).","In NT5, reparse points are used to mark NSS files so that NSS doesn't have to read the header of every file opened on the volume. The directory stream is marked sparse so its length can be set to the length of the corresponding docfile view without using twice the disk allocation. Both of these designs are regarded as implementation details particular to NT5.","In the NT embodiment, the filter driver is implemented as a file system filter driver within the NT kernel, called CNSS (convert-NSS). The following changes to NTFS and NT I\/O in NT5 support CNSS\/NSS. Two new create\/open option bit combinations called FILE_STRUCTURED_STORAGE and FILE_COPY_STRUCTURED_STORAGE have been added to the NTCreate\/NtOpenFile APIs. NTFS files can be marked as being reparse points. An open to a file with a reparse point fails with STATUS_REPARSE and returns a tag which the filter driver uses to identify NSS files. Individual streams of an NSS file can be marked SPARSE and extended to an arbitrary size without taking up disk space. CNSS uses this feature to make the size of the unnamed data stream of an NSS view appear to be We same as the docfile view size. Support is also provided for associating file system filter driver context with open files. Other operating systems may require different modifications as will be apparent during normal implementation of the concepts of the invention.","In , a process in the filter driver for changing the format in which files are stored is depicted. At , file requests are monitored, and statistics are generated at  regarding the various formats the file is requested in. If the access pattern reaches a threshold , the format that the file is stored in may dynamically be altered to be a different format  for reasons of tuning efficiency. If the file is already stored in the most efficient format as indicated at , monitoring continues at . The file may be stored in a different format if that format is determined to be more efficient, or easier to convert from for the various formats that the file is most commonly accessed in. Efficiency is determined by augmenting the stored file format to include history information about the formats and types of accesses of the file. This information is used to predict the amount of overhead required by dynamic conversion from candidate storage formats. The overhead includes a number of different factors including cpu cycles, memory usage, and access latency. If the overhead for accessing a file is predicted to significantly lower (10-20%) if the storage format is different, the file is marked to be statically converted. Static conversion to a new format is performed during periods when the system resources are underutilized, such as evenings or weekends.","A conversion component referred to as a filter driver provides a view of information stored in one format through dynamic conversion to a requested format. The formats comprise application specific formats, as well as particular persistent store formats used by components of the system such as a file system or a database. While the embodiments described relate to the conversion between NSS and docfile formats, it is recognized that many other conversions can be performed, including dynamic conversions of application specific formats such as those required by different versions of a single or multiple applications. The invention may be used to simplify the use of information formats, application versions, and operating systems. These conversions can be provided by the conversion component of other dynamically loadable conversion modules, which allow format conversions to be provided by both operating systems and applications. The conversion modules run in the kernel below the I\/O manager. Both networked and local accesses are routed through the conversion component and conversion is performed if needed, providing a general solution to the problem of format incompatibles between different applications and operating systems and\/or versions. Cached data aids in the conversion in one embodiment. A reparse point is used to indicate that a file should be converted in one version of the invention, but other types of indication, such as flags or table based me may also be used. This application is intended to cover any adaptations or versions of the present invention. It is manifestly intended that this invention be limited only by the claims and equivalents thereof."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
