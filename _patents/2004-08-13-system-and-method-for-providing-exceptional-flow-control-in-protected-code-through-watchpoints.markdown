---
title: System and method for providing exceptional flow control in protected code through watchpoints
abstract: A system and method for providing exceptional flow control in protected code through watchpoints is described. Code is generated. The generated code includes a sequence of normal operations and is subject to protection against copying during execution of the generated code. Execution points within the generated code are identified. A watchpoint corresponding to each of the execution points is set. An exception handler associated with each watchpoint is defined and includes operations exceptional to the normal operations sequence that are performed upon a triggering of each watchpoint during execution of the generated code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07647586&OS=07647586&RS=07647586
owner: Sun Microsystems, Inc.
number: 07647586
owner_city: Santa Clara
owner_country: US
publication_date: 20040813
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The invention relates in general to exceptional flow control and, in particular, to a system and method for providing exceptional flow control in protected code through watchpoints.","Fundamentally, a computer program is a sequence of instructions expressed according to the rules and syntax of a high level programming or assembly language, such as C++ or JAVA\u2122 from Sun Microsystems, Santa Clara, Calif., USA (hereinafter \u201cJava\u201d). The program specifies the control flow and logic to be performed at runtime. Prior to execution, the instructions are translated into machine operations by an interpreter or compiler. An interpreter performs a runtime translation of the instructions, which sacrifices speed for convenience and is generally inefficient. However, interpreted code is acceptable for non-critical applications and can be modified on-the-fly without having an appreciable effect on execution speed.","Conversely, compilers generate executable code embodied as an executable module. Compiled or generated code typically executes efficiently, but, once compiled, cannot be changed except through patching, which statically modifies or replaces the generated code. Patching is often performed for code updates to fix program bugs or to provide improve functionality. Patching can also be performed as temporary memory writes to facilitate secondary system activities, such as exceptional flow control, which uses short-lived modifications to the generated code that are removed upon completion of the system activity. Temporary memory writes include setting breakpoints, setting safepoints for rendezvous of threads, selective instrumentation or profiling, and performing garbage collection activities, such as object header marking for liveness checking. Rendezvous points or safe points are set to enable a task that requires all threads to be in a known state to safely execute.","For example, patching generated code is particularly effective at improving the efficiency of garbage collection in memory-constrained embedded systems, where memory fragmentation can be damaging to performance. In garbage collection, precise pointer scanning can be used to allow a virtual machine environment to fully compact a memory heap by tracking memory pointers assigned to dynamically allocated objects. For efficiency, the generated code is kept garbage collection unsafe at runtime. Garbage collection safepoints are defined at particular execution points within the code and memory pointer manipulation is allowed to proceed at runtime without fear of interacting with garbage collection operations. Safepoints avoid the overhead incurred by having to track memory pointers by stopping all execution threads during a rendezvous to allow garbage collection to proceed. Typically, safepoints are defined at method invocations, object allocations, thread synchronization calls, loop iterations, and similar execution points to ensure that all threads can be reached and stopped.","Safepoints are triggered in response to a garbage collection request, which can be detected through polling. However, polling is computationally expensive. For instance, on RISC architectures, polling often requires up to five processor cycles per poll, which creates unacceptably high overhead, particularly where safepoints are set at each loop iteration. Alternatively, code patching allows garbage collection request monitoring to proceed with no overhead cost. In the absence of a garbage collection request, a table of the locations of the safepoints is maintained for use by a dynamic complier, which patches the generated code at each safepoint at runtime upon receiving a garbage collection request. The patches invoke exception flow control that stops thread execution through, for instance, a function call, code branch, software trap, or instruction that causes a memory fault trap. Generally, a patch causing exceptional flow control modifies only a small section of code to cause execution to be redirected to an exception handler. The exception handler then performs extra operations and removes the patch to enable regular execution to resume once control is returned back from the exception handler.","Patching code, such as used for garbage collection safepoints, can be incompatible with generated non-modifiable code, such as read only code or code embodied in read only memory. Patching code can also be ill-suited to code maintained in a copy protected form that does not readily accommodate patching, such as code found in precompiled and linked methods or speculatively initialized application models. Similarly, process cloning as provided through copy-on-write or deferred copying allows a child process to implicitly share the process memory space, including generated code, of a master parent process, provided that the shared memory space of the child process remains unmodified. Code patching destroys the implicit sharing relationship and can negate memory advantages gained through process cloning.","Therefore, there is a need for an approach to providing temporary writes to generated code without destroying copy protection to enable exceptional flow control. Preferably, such an approach would be performed in a non-destructive manner using operating system-provided watchpoints.","One embodiment provides a system and method for providing exceptional flow control in protected code through watchpoints. Code is generated. The generated code includes a sequence of normal operations and is subject to protection against copying during execution of the generated code. Execution points within the generated code are identified. A watchpoint corresponding to each of the execution points is set. An exception handler associated with each watchpoint is defined and includes operations exceptional to the normal operations sequence that are performed upon a triggering of each watchpoint during execution of the generated code.","Still other embodiments of the invention will become readily apparent to those skilled in the art from the following detailed description, wherein are described embodiments of the invention by way of illustrating the best mode contemplated for carrying out the invention. As will be realized, the invention is capable of other and different embodiments and its several details are capable of modifications in various obvious respects, all without departing from the spirit and the scope of the invention. Accordingly, the drawings and detailed description are to be regarded as illustrative in nature and not as restrictive.","System Overview",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1","FIG. 2","FIG. 3"],"b":["10","15","15","17","19","11","12","14","16","18","20"]},"In a further embodiment, each operating system supports a process cloning mechanism that spawns multiple and independent isolated user applications by cloning the memory space of specifiable processes, as further described below with reference to . An example of a process cloning mechanism suitable for use in the present invention is the fork( ) system call provided by the Unix or Linux operating systems, such as described in M. J. Bach, \u201cThe Design Of The Unix Operating System,\u201d Ch. 7, Bell Tele. Labs., Inc. (1986), the disclosure of which is incorporated by reference. The process invoking the fork( ) system call is known as the \u201cparent\u201d or master process and the newly created process is called the \u201cchild\u201d process. The operating system assigns a new process identifier to the child process, which executes as a separate process. The operating system also creates a logical copy of the context of the parent process by copying the memory space of the parent process into the memory space of the child process. In a copy-on-write variant of the fork( ) system call, the operating system only copies references to the memory space and defers actually copying individual memory space segments until, and if, the child process attempts to modify the referenced data of the parent process context. The copy-on-write fork( ) system call is faster than the non-copy-on-write fork( ) system call and implicitly shares any data not written into between the parent and child processes.","Executable Process Address Space",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":["30","66","66","31","32","33","33","31","11","31","32","33","32","33"]},"As shown, the code segment , data segment  and heap segment  are loaded as generated code into a memory in a single linear address space beginning with the code segment  at the lowest memory address. However, in a machine architecture supporting virtual memory paging, the entire address space of the executable process  could be paged to memory, thereby resulting in non-contiguous placement of the segments or, where a segment spans multiple pages, parts of segments. Moreover, in memory-constrained programmable devices, the code segment  and data segment  can be designated as read only or be embodied on a ROM device to avoid having to be read from non-volatile storage into memory prior to execution. Consequently, only objects defined within the heap segment  are actively allocated and deallocated at runtime.","Portions of the generated code in the executable process , including individual segments, parts of segments, or the entire process, can be subject to protection against copying during execution. Copy protection includes designation as read only or embodiment on a ROM device. Copy protection also includes precompiled and linked methods or speculatively initialized application models, such as respectively described in commonly-assigned U.S. patent application, entitled \u201cSystem and Method for Providing Precompiled Code through Memory Space Cloning of a Master Runtime System Process,\u201d Ser. No. 10\/745,020, filed Dec. 22, 2003, pending, and U.S. patent application, entitled \u201cSystem and Method for Performing Speculative Initialization of Application Models for a Cloned Runtime System Process,\u201d Ser. No. 10\/745,022, filed Dec. 22, 2003, pending, the disclosures of which are incorporated by reference, or process cloning as provided through copy-on-write or deferred copying, such as described in commonly-assigned U.S. patent application, entitled \u201cSystem and Method for Dynamic Preloading of Classes through Memory Space Cloning of a Master Runtime System Process,\u201d Ser. No. 10\/745,023, filed Dec. 22, 2003, pending; U.S. patent application, entitled \u201cSystem and Method for Performing Incremental Initialization of a Master Runtime System Process,\u201d Ser. No. 10\/745,164, filed Dec. 22, 2003, pending; and U.S. patent application, entitled \u201cSystem and Method for Eliminating Static Initialization Overhead by Memory Space Cloning of a Master Runtime System Process,\u201d Ser. No. 10\/745,021, filed Dec. 22, 2003, pending; the disclosures of which are incorporated by reference. Other types of copy protection over generated code are possible.","Prior Art System for Providing Exceptional Flow Control",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":"40"},"The system  defines an exemplary runtime environment  provided through an operating system and includes a virtual machine (VM) process  that executes generated code  maintained in non-volatile storage . Typically, the generated code  remains unchanged in memory and, at runtime, portions of the generated code  are progressively staged from memory into a code cache  as execution proceeds. However, to accommodate requests for exceptional flow control , the generated code  can be patched by a dynamic compiler  to temporarily write modifications or changes, as specified through patch code , into the generated code  in memory. The patch code  is typically a set of function calls to runtime system rendezvous code that stop thread execution by suspending execution or causing the thread to sleep or wait. Exceptional flow control requests  include setting breakpoints, setting safepoints for rendezvous of threads, selective instrumentation or profiling, and performing garbage collection activities, such as object header marking for liveness checking. Other types of exceptional flow control requests  are possible.","At runtime, the dynamic compiler  maintains a table of execution points  within the generated code  that includes the locations in memory of method invocations, object allocations, thread synchronization calls, loop iterations, and similar execution points to ensure that all threads can be reached and stopped. Other execution points are possible. Upon receiving an exceptional flow control request , the dynamic compiler  consults the execution points table  and patches the generated code  in memory with the patch code , which provides instructions that stop the corresponding execution thread at a rendezvous point. The thread that requested exceptional flow control waits for the watched execution threads to stop during a rendezvous. Upon completion of the rendezvous, including any secondary work that needs to be done, such as performing a garbage collection, the patch code  is removed from the generated code  and normal execution by the watched execution threads resumes.","While effective at accommodating exceptional flow control requests , the patching of the generated code  in memory is either inconsistent or incompatible with copy protected code. Generated code maintained as read only or embodied on a ROM device cannot be patched. And patching generated code for recompiled and linked methods, speculatively initialized application models, or cloned processes, as provided through copy-on-write or deferred copying, can negate significant memory advantages as provided through pre-compilation, initialization and implicit sharing.","Memory Mapping for a Parent Process","In a further embodiment, the runtime environment  executes an application framework that spawns multiple independent and isolated user application process instances by preferably cloning the memory space of the virtual machine process  as a \u201cparent\u201d or master process to create one or more \u201cchild\u201d processes. The example of an application framework suitable for use in the present invention is the Unix operating system, such as described generally in M. J. Bach, supra at Ch. 2, the disclosure of which is incorporated by reference.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["60","65","62","62","65","62","64","63","61","65"],"i":["a","d"]},"Memory Mapping for a Child Process",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5","b":["70","65","66","62","64","62","65","66","62","72","71","67","66","66","65","66","41","41","43","65","31"],"i":["a","c ","a","d"]},"Memory Mapping for a Child Process with Copy-on-Write",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIGS. 6A-B","FIG. 6A"],"b":["80","90","65","66","62","63","65","81","66","66","64","66","66","62","66"],"i":["a","d "]},"Referring next to , the child process  has attempted to modify one of the pages in the memory space of the parent process context, such as through code patching. In response, the operating system creates a physical copy of the to-be-modified memory space page as a new page  and updates the allocation in the page table entries  for the child process . Through copy-on-write semantics, the overall footprint of the runtime environment  is maintained as small as possible and only grows until, and if, each child process  actually requires additional memory space for application-specific context. Nevertheless, the new page  is needlessly created, as code patching for exceptional flow control introduces only temporary modifications or changes to the child process , which are removed upon completion of the exceptional flow control.","System for Providing Exceptional Flow Control Through Watchpoints",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7","b":"100"},"The system  also defines an exemplary runtime environment  provided through an operating system and includes the virtual machine (VM) process  that executes the generated code  maintained in the non-volatile storage . As before, portions of the generated code  are progressively staged from memory into a code cache  at runtime as execution proceeds. At runtime, an exception monitor  running within the dynamic compiler  sets watchpoints, as further described below with reference to , at the execution points identified in the execution point table  to accommodate requests for exceptional flow control . Each watchpoint is set through a watchpoint application programming interface (API)  exported by the operating system in the runtime environment , such as provided by the Solaris operating system. The operating system maintains a table of watchpoints  that identifies code triggered upon execution of watched generated code. Exception handlers  associated with each set watchpoint define code that stop thread execution. Thus, upon receiving an exceptional flow control request , the exception monitor  sets the watchpoints and, once detected by the set watchpoints, control is redirected to the exception handlers  to stop thread execution. The thread that requested exceptional flow control waits for the watched execution threads to stop at a rendezvous point. Upon completion of the rendezvous, the watchpoints are cleared and normal execution by the watched execution threads resumes.","Other implementations of watchpoint facilities are possible. For example, in a further embodiment, a signal handler implemented by the operating system or a watchpoint library sends a signal to the watched process when a watchpoint is hit, in a manner similar to having a shared exception handler for all watchpoints. The watched process then discovers the watchpoint that was triggered by examining the program counter or other information in the context information supplied to the signal handler.","Memory Mapping with Watchpoints Set",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 8","b":["110","111","62","47","111","49","111","113","112","61","47","113"]},"Method for Providing Exceptional Flow Control Through Watchpoints",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 9","FIG. 7"],"b":["120","100","101"]},"Initially, one or more watchpoints  are set (block ) in response to an exceptional flow control request . The generated code  executes (block ) and, upon execution into a watch region (block ), execution is redirected (block ) to trigger the execution of an exception handler  (block ), after which the watchpoint is cleared and execution of the generated code  resumes (block ).","While the invention has been particularly shown and described as referenced to the embodiments thereof, those skilled in the art will understand that the foregoing and other changes in form and detail may be made therein without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 6A-B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
