---
title: Method and apparatus for timing information flow in a distributed system
abstract: A computer and software method and apparatus for distributed data processing which provides agreement between data sources (sensors) and data sinks (actuators) as to what data has been written into a shared buffer. The invention further provides methods and means for meeting data timeliness requirements. Invention employs a programming primitive which recognizes semantics so as to provide a consistent view of computation modules over prescribed time intervals, called “epochs”. Application-level control of the asynchrony and timing of information flow between various computation modules is realized. The invention has applications which include sensor fusion and network gaming.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07877748&OS=07877748&RS=07877748
owner: The United States of America as represented by the Secretary of the Air Force
number: 07877748
owner_city: Washington
owner_country: US
publication_date: 20051102
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY CLAIM UNDER 35 U.S.C. \u00a7119(e)","STATEMENT OF GOVERNMENT INTEREST","BACKGROUND OF THE INVENTION","REFERENCES","OBJECTS AND SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This patent application claims the priority benefit of the filing date of provisional application Ser. No. 60\/629,824, having been filed in the United States Patent and Trademark Office on Nov. 19, 2004 and now incorporated by reference herein.","The invention described herein may be manufactured and used by or for the Government for governmental purposes without the payment of any royalty thereon.","This invention relates generally to distributed real-time information systems in which the data generated by source modules have timeliness constraints for dissemination by sink modules.","Generally, an embedded system consists of a distributed real-time computation that collects data from the external environment and processes this data to reason about the system behavior [1]. An example is the deployment of radar devices in battle terrains to detect the movement of enemy planes. An application thus involves the processing of time-sensitive data flowing from source modules (see , ) to sink modules (see , ), thereby requiring programming-level support to enable a timely processing of data.","The asynchronous execution of data sources and sinks is compounded by the lack of physical shared memory between them (i.e., these modules may be distributed over a network). Given this computation structure, the movement of data to a shared or common buffer (see , ) over the intervening network should satisfy certain correctness requirements, as follows:\n\n","The programming-level enforcement of timing and consistency has become a necessity in the evolving application domains of distributed multimedia systems and real-time embedded systems. The prior art provides atomicity of data access operations on a shared buffer only in a \u2018logical time\u2019 framework where the ordering of operations define the forward progress of the underlying computation without any relationship to the time elapsed for these operations. This notion of logical time is, however, difficult to adapt to real-time embedded systems which have their data access operations originate from and culminate on physical systems that form the external environment of the computation subsystems. Therefore, there is a pressing need for programming primitives that accommodate the \u2018passage of time\u2019 as part of the semantics of data access operations.",{"@attributes":{"id":"p-0008","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["[1] H. Kopetz and P. Verissmo. -, Chapter 16, in Distributed Systems, Ed. S. Mullender, Addison-Wesley Publ., 1993.","[2] A. Singh. Atomic Registers: 1993.","[3] M. Singhal and N. Sivaratri. , Chapter in , McGraw-Hill Publ., 1993.","[4] K. Birman and et al. ISIS\/Horus Distributed System, Cornell University Technical Report, 1997.","[5] L. Peterson and et al. x-Kernel system University of Arizona Technical Report, 1995.","[6] J. P. Courtiat, L. Fernando, Rust da Costa Carmo, Roberto Cruz de Oliveira. General-purpose Multimedia Synchronization Mechanism based on Causal Relations. IEEE Journal of Selected Areas in Communications, vol. 14, pp. 185-195, January 1996.","[7] R. Baldoni, R. Prakash, M. Raynal, M. Singhal. Efficient \u0394-Causal Broadcasting. International Journal of Computer Systems Science and Engineering, 1998.","[8] S. L. Presti, D. Bert, A. Duda. Tao: Temporal Algebraic Operators for Modeling Multimedia Presentations, Journal of Network and Computer Applications (Elsevier Science Ltd.), vol. 25, pp. 319-342, 2002.","[9] K. Ravindran. Transport-oriented Service Models for Multimedia Data Presentation, proc. SPECTS'00, Vancouver (Canada), July 2000."]}},"The present invention provides a programming primitive that embodies both the atomicity and timing properties of data access operations on a shared buffer and is referred to as \u2018timed atomic write\u2019 (TAW).","The time interval over which a set of time-dependent data items can be processed by the sources and sinks in an application constitutes an epoch. During an epoch, one or more sources write their data items in the buffer as an unordered set, and thereupon, the sinks process various data items from the buffer as determined by the application needs. The reaching of agreement between the various modules as to which data items are processed in a given time interval is subsumed into the notion of epoch. The present invention's TAW primitive allows a programmer to prescribe epochs by stipulating an application-specific timing condition on the data items processed through a shared buffer. It is the responsibility of an application to enforce state consistency across the various modules by exercising a temporal ordering on the epochs. Thus, the TAW primitive enables integrating the \u2018passage of real-time\u2019 and \u2018state consistency\u2019 in an application program through a prescription of epochs.","The TAW primitive is different from \u2018atomic registers\u2019 [2] in that the latter enforces an agreement not only on the set of data items but also on the order in which they will be written into the buffer. With TAW, the application needs to enforce an ordering of data items only to the extent required. Comparing with \u2018distributed transactions\u2019 [3], the latter often determines a serializable schedule on the set of writes on the buffer, which may not be consistent with the application's expected ordering (and hence requires a re-ordering of data items at the application level). With TAW provided by the present invention, however, an application implements its own ordering of data items in the buffer to the extent desired. This entails a higher potential for execution performance of applications. Thus, the TAW may be viewed as providing a thin layer of functionality (i.e., a weaker semantics) as part of the distributed programming abstraction, in comparison with existing works that (implicitly) advocate a thick layer of functionality (i.e., a stronger semantics) with the attendant performance penalty.","Furthermore, unlike the TAW primitive, the prior art works [2,3] do not consider the \u2018passage of time\u2019 as part of an application state. So, a potential use of the existing primitives for embedded systems programming requires a separate sub-layer of functionality to integrate \u2018time\u2019 as part of the read-write semantics, thereby entailing inflexibility and complexity in application-level programming.","Thus, the TAW primitive of the present invention, with its explicit application-level control of the asynchrony and timing of information flow between various application modules is highly desirable. The architectural differences in the programming structures that employ the TAW primitive, relative to the existing primitives, are a part of the invention. This present invention provides the structure and semantics of the TAW primitive, and the application-level programming structures using the TAW primitive.","It is therefore an object of the present invention to provide a method and apparatus for agreement on common data and its availability in distributed systems.","It is a further object of the present invention to provide programming primitives which utilize systems semantics in distributive data processing so as to provide a consistent view of common data.","It is still a further object of the present invention to extract parallelism among tasks in distributed system so as to provide for agreement between sensors and acuators about shared data availability and process timelines.","Briefly stated, the present invention achieves these and other objects through a computer and software method and apparatus for distributed data processing which provides agreement between data sources (sensors) and data sinks (actuators) as to what data has been written into a shared buffer. The invention further provides methods and means for meeting data timeliness requirements. Invention employs a programming primitive which recognizes semantics so as to provide a consistent view of computation modules over prescribed time intervals, called \u201cepochs\u201d. Application-level control of the asynchrony and timing of information flow between various computation modules is realized. The invention has applications which include sensor fusion and network gaming.","The above, and other objects, features and advantages of the present invention will become apparent from the following description read in conjunction with the accompanying drawings, in which like reference numerals designate the same elements.","In the present invention, the spontaneity in the arrival of input data for a distributed task, the timeliness of generation of results by the task, and therefore the overall system performance, is inextricable from the parallelism in computing these results. Since each sensor (see , ) constitutes a distinct unit of data collection for input to the task, the extraction of parallelism in the flow of data through various subsystems implementing the task should be at the data semantics level. The relevant semantics pertaining to a sensor data item x (see ) basically involves identifying the task execution points when x is needed relative to the processing of other data items or the partial results generated therefrom. Such an ordered execution of sub-tasks to process various sensor data items constitutes the processing pipeline associated with the main task.","System Model","Referring to , u, u, uN are the source processes  collecting data from the external environment for input to the application task through the shared data buffer . The sink processes  represented by v, v, . . . , vM disseminate the results output by the application task onto the external environment (note that N, M\u22671). The application task is itself built into computation processes , ,  represented by fx, fy, . . . , fz that are interposed between the sources  and sinks . In a given time interval [Ti, Ti+1], a set of sources W generate requests to write into the shared buffer. The processes attempting a write are drawn from a set W\u2032 declared as eligible to write during [Ti, Ti+1], i.e., WW\u2032 {u, u, . . . , uN}. The set of sources W\u2033 whose data are actually written into the buffer is then selected from W\u2032, i.e., W\u2033W\u2032. The accesses to the shared buffer containing the data items W\u2033 are realized through \u2018read\u2019 and \u2018write\u2019 operations exercised in an asynchronous manner.","The computation modules may be either part of the source  and\/or sink  modules or realized on separate nodes of a multi-processor\/distributed system. The present invention relies upon the various modules having access to a synchronized real-time clock, at a sufficient level of time granularity (for use by the protocols underlying a TAW realization).","The application task comprises sensors u, u, u generating data d, d, d, respectively , , , and further comprising a computation subsystem of processes implementing sub-tasks fx, fy, fz, , ,  and actuators v, v taking actions on the environment. The use of such an application scenario to simplify the discussions does not however compromise the generality of our model to a case of arbitrary number of sensors and actuators and an arbitrary set of computation modules.","\u2018Dataflow\u2019-Style Programming for Real-Time Tasks","Still referring to , an exemplary programming structure for the present invention is depicted. The interconnections of the various modules depict the \u2018functional dependency\u2019 relationships between them, specifically, the arrow  from fx  to fz  indicates the dependency that fz needs its input data from fx before its computation can start. The module fz starts executing as soon as the inputs , ,  from fx and fy and the sensor module u, respectively, are available. In turn, the output of fz,  in conjunction with the output of fy , triggers the execution of actuator module vb. Such a \u2018dataflow\u2019-style program structuring enhances the parallelism in task execution. The input-output relationships of various modules are as shown in the Figure.","In a distributed programming-level implementation, fx and fy are part of the sensor modules u and u respectively  and fz is a part of the actuator module vb . The computations fx  and fy  execute in parallel if the data d  and d  are available, providing their results in a shared buffer  for use by fz , . Since fz also needs the input data d  from u, the ordering on {d, d, d} may be prescribed as: \u2225{d, d}\u2192d. This ordering is enforced by the computation structure with the use of TAW primitive, as opposed to enforcing the ordering by the communication layer in alternative programming models.","Extraction of Fine-Grained Parallelism","Any application run on the present invention occurs within the context of the input-output relationships between the results produced at various intermediate stages of computation on the input data. The computation may be partitioned into sub-tasks that synchronize their results at appropriate points in the computation. A task dependency graph (TSG) functions as a task scheduler  tracks the fine-grained parallelism between various computation modules. The task scheduler  ensures the prescribed real-time task deadlines are met. This is functionally possible because of the predictability of execution times of various sub-tasks and the well-defined interconnect structure between them to move the intermediate computation results (note that the task dependency relations form a part of the global knowledge at various computation modules). This parallelism among various sub-tasks itself falls under the realm of application-level programming.","To enable the software construction of such a task \u201cpipeline\u201d, the present invention requires a communication primitive with a proper level of abstraction. Such a primitive enables complete utilization of the available parallelism among sub-tasks, but should not in any way limit the programmer's ability to structure these sub-tasks. TAW primitive in the present invention is an enabler for such application-level program constructions.","Structure and Semantics of TAW Primitive","The TAW primitive basically allows writing an unordered set of data items W\u2033 into the shared buffer . The various sub-tasks embodied in an application program take the required data items from this buffer for processing. The TAW primitive embodies functional requirements to deal with two inter-woven issues that are relevant to the application-level processing of sensor data in a distributed embedded system, these requirements being:\n\n","The functional requirement 2 allows determining whether the time required to process various input data items for generating the composite output results meets prescribed deadlines. Often, a data d written into the buffer has real-time constraints \u0394(d) for dissemination, i.e., a time limit \u0394(d) before which d should be acted upon. The task scheduler , which may itself be distributed in the various computation modules, makes this determination based on the sub-task execution times and interconnect structure.","The present invention's TAW primitive combined with functional requirements 1 and 2 provide the ability to extract the parallelism among various sub-tasks involved in processing input data and output results.","Programming Model of TAW: Timing Spec","Referring now to , the temporal axis consists of a sequence of epochs e(0), e(1), . . . , e(j), . . . , where an epoch e(j) encompasses the write requests generated by one or more sources and their processing over a distinct time interval [Ti, Ti+1]. The duration of e(j) is given by:\n\n1>\u03b5+\u03b2+max({\u03b6}), 1, . . . , \n\nwhere \u03b5  depicts the time window during which write requests are generated, \u03b2  is the time needed to process the data generated by the computation sub-system, and \u03b6k denotes the persistence time of action triggered by vk .\n","By way of example, consider a temperature control system for a boiler plant that consists of multiple sensors and valves located at different points in the boiler to collect temperature data and to inject coolant liquids respectively. Here, an epoch depicts the time interval for sampling and processing of temperature data where \u03b5 is the maximum time skew allowed between the samples of various sensors in a given interval, \u03b2 depicts the time to process temperature data, and \u03b6 is the time to open (or close) the coolant valves.","The \u2018passage of time\u2019 in an application may be captured by the \u03b5 and \u03b6 parameters, with \u03b6 viewed as a non-deterministic time duration to model the transition from a current epoch e(j) to the next epoch e(j+1), where \u03b5, \u03b6>>\u03b2.","Programming Model of TAW: Distributed Agreement","Still referring to , the \u2018write\u2019 semantics requires that various processes agree on the set of data items W\u2033 actually written into the buffer (a source can write no more than one data item in a given time interval). The sink processes then generate actions based on processing the agreed datum. W\u2033={d, d} .","A situation may arise where a programming primitive that guarantees agreement (on W\u2033) among various modules as part of the read\/write semantics is not provided. In the absence of a consistent global knowledge as to what W\u2033 is, it is difficult (if not impossible) for the scheduler to precisely determine the actual dependency relations that are satisfied. Consequently, a specific instantiation of the task dependency relations for the writes that are deemed to have occurred, cannot be inferred. This in turn makes it difficult for the task scheduler  to determine if the real-time constraints of the task on hand can be met.","The semantics of presenting an unordered set of data items that is consistent across the various computational processes {p, p, . . . , pN} enables a \u2018data-driven\u2019 computation in which each process picks up the data items that it needs to accomplish its part of the application-level computation ,  and then produce results to synchronize with that produced by the other processes . With data arrivals occurring asynchronously, the non-imposition of any ordering among the data by the communication layer allows the computation modules to start executing as soon as their required input data are committed in the buffer . This in turn allows the present invention to benefit from the fine-grained parallelism in the computation, and accordingly enhance the ability to meet real-time deadlines of data.","Program Notations for TAW","A process p housing a sensor ui may invoke a write_buf primitive after its data di becomes available for processing, in the form:\n\n:=write(),\n\nwhere wrtset is the set of successful writes on the buffer in the current epoch e and grp is the broadcast group address to which the process p is subscribed to. Here, 1\u2266|wrtset|\u2266nwrt\u2266|W\u2032|, where nwrt is the application-specified maximum number of processes that are allowed to write in the current epoch. The parameter nwrt is made available to the communication layer as part of a control entity in the application program that manages the flow of epochs in the computation. Each element x\u03b5 wrtset has 2 fields: x.dt and x.id, denoting the data written in the buffer and the id of process who wrote this data respectively. The case of ui \u03b5 wrtset. {id}indicates that the write of ui successfully completed at the buffer, i.e., committed; ui \u2209wrtset. {id} indicates otherwise. A process p\u2032 housing an actuator vk and subscribed to the group address grp may examine the buffer contents by invoking a primitive of the form:\n\n:=read().\n\nThe invocation blocks vk until all the writes selected by the communication layer for the epoch e complete.\n","The \u03b5-parameter provides a time-window over which the competing write requests are collected by the communication layer. The collection takes place until the time-window expires or nwrt requests are collected, whichever occurs earlier. The wrtset contains the set of data items in the shared buffer, as agreed upon by all the processes subscribed to the group address grp.","Benefits of TAW Over Non-Synchronized Data Writes","Referring to , the TSG is implemented in a decentralized manner in various processes. The TSG information, combined with an agreement among processes about the data being committed in the current epoch, allows each process in the computation subsystem to have a consistent view of which of the task input requirements have been met. Given that a process P implementing a sub-task is often equipped with recovery procedures to deal with the absence of a data d at its input, P can determine its output that is consistent with the outputs of other processes that also depend on d. The consistency can be achieved without a need for P to coordinate with the other processes about whether they saw d or otherwise. Such a consistent view of processes about the TSG relative to the actual data inputs in the current epoch  enhances the ability of processes to determine their local computation schedules relative to the overall task deadline.","Still referring to , a timing scenario depicts the asynchronous arrival of d, d, d, with the arrival of d delayed past the initial \u03b5-window at fz, due, for example, to source-level timing errors . With a non-commit of d, the present invention consistently decides that actuator vb triggers its action but actuator va does not ,. This consistent enforcement of timing and recovery procedures by sinks va and vb.","Referring to , a prior art scenario is depicted where no agreement is reached on the non-commit of d,  because unlike the present invention, no TAW-like primitive is available to the programmer. Here, d is seen by va but not by vb ,  Accordingly, the scheduler at va determines that both va and vb trigger their actions but the scheduler at vb determines that only vb triggers its action but va does not. Since the schedulers at va and vb need to coordinate with each other to determine what exactly they saw at the buffer, it is difficult to decide on the consistency and timing of their actions.","Benefits of TAW Over \u2018Ordered Data Writes\u2019","The present invention can achieve agreement on the set of data written into the shared buffer by using programming primitives that order the data writes on the buffer over time. The temporal ordering is based on application-level prescription of the causal dependency relation among the data messages, combined with timing constraints. Referring back to , the causal dependency relation is: \u2225{d, d}\u2192d. The temporal ordering may be transcribed onto the communication layer using \u2018vector clocks\u2019 [4] or \u2018message dependency graphs\u2019 [5] and incorporating timing constraints therein using the specification techniques described in [6,7,8,9]. But, having the communication layer order the data writes is an overkill in terms of timeliness and performance of data delivery, in comparison to the application layer synchronizing the data to the extent required. This is because an ordering imposed by the communication layer is indifferent to the asynchrony in data arrivals and\/or the process computation times on dependent data. Therefore, an ordered write needs to stipulate a temporal constraint based on a worst-case data arrival pattern and a conservative estimate of the process computation times. Consequently, the use of ordered write primitive may incur an additional synchronization delay in many cases, with an ordered write of data equaling the performance of TAW only in the limiting case.","Case of \u2018Dataflow\u2019-Structured Programs","Referring to , a timing scenario of the data arrivals and processing in the sample computation structure depicts the benefits of the present inventions TAW over prior art ordered write. The temporal constraint passed on from the application to the communication layer for an ordered write of d relative to d and d is:\n\n\u03b1>max({(),()}),\n\nwhere Tcmp( . . . ) denotes the computation time of a sub-task . The communication layer delivers d after a time of a has elapsed since the delivery of d and d , . In comparison, the TAW primitive in the present invention allows the delivery of d to occur without any ordering constraint . Accordingly, the additional synchronization delay incurred by a prior art ordered write relative to the present invention TAW is:\n\nmax({0,max({(1),(3)})+\u03b1\u2212max({[(1)+()], [(3)+()]})}),\n\nwhere Tarr( . . . ) denotes the arrival time of a data 61.\n\nCase of Monolithically Structured Programs\n","Referring to  and , a monolithically structured program for the sample computation (see ) is depicted. Here, a rigid programming structure has the functions fx, fy and fz executed sequentially by a processing subsystem that is separate from the sensor and actuator modules . Here, the temporal constraint on the delivery of d is depicted in the prior art ordered write primitive  and in the present invention's TAW primitive :\n\n\u03b1>()+().\n","With a monolithic structure, the additional synchronization delay incurred by a prior art ordered write relative to the present invention's TAW is :\n\nmax({0,max({(1),(3)})+\u03b1\u2212max({[(1)+()],(3)})+()}).\n","As can be seen, even with a \u2018dataflow\u2019-style program structure that offers the potential to reap the maximum performance, a prior art ordered write incurs additional synchronization delay over the present invention TAW primitive under normal cases.",{"@attributes":{"id":"p-0056","num":"0067"},"figref":"FIG. 9"},"A Reference Code Skeleton in \u2018Dataflow\u2019-Style Program Structure","Referring to , a real-time embedded application modeled as per the \u201cproduce-consume\u201d style of computation may employ the write_buf and read_buf primitives as building blocks. The processing of a data d by an actuator vk be denoted by a function f(k,j)(d) where j indicates the epoch number. The global state Sj+1, as indicated,  is guaranteed to be consistent across all the processes, since the TAW primitive enforces an agreement on wrtset and Tj+1 among all the processes.","Having described preferred embodiments of the invention with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various changes and modifications may be effected therein by one skilled in the art without departing from the scope or spirit of the invention as defined in the appended claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0028"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0029"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0030"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0031"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0032"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0033"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0034"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0035"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0036"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0037"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
