---
title: Versatile register file design for a multi-threaded processor utilizing different modes and register windows
abstract: A method for optimizing a register file hierarchy in a multithreaded processor. The method includes providing a register file hierarchy with a plurality of register file cells, associating the plurality of register file cells with respective threads when the processor is operating in a multithreaded mode and flattening the plurality of register file cells with a single thread when the processor is operating in a single threaded mode. The register file cells correspond to threads of the multithreaded processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07418582&OS=07418582&RS=07418582
owner: Sun Microsystems, Inc.
number: 07418582
owner_city: Santa Clara
owner_country: US
publication_date: 20040513
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates to processors and more particularly to register files within processors.","2. Description of the Related Art","Known processors provide registers for storing data or for providing status or control information regarding the state of the processor. A known method of organizing registers within a processor is via a register windowing technique to access a plurality of registers in a register file. With register windowing, a register window includes a predetermined number of contiguous registers, and the window can be moved linearly within the register file. At any given time, the register window permits program access to a subset of the total number of registers in the register file. Control registers are associated with the register window so that a program can manipulate the position of the window within the register file and monitor the status of the window.","Multi-threaded processors with register windows serialize register window management instructions or pay a high price in area for \u201cflattening\u201d their register windows, i.e., making all register windows available all the time. One of the major costs in implementing multi-threading within a processor is the replication of the architectural registers. For example, in a four thread processor, the number of registers is quadruplicated, resulting in a significant core area increase. A side-effect of a register window issue is a more challenging timing due to longer wires. The issue is compounded because register file (RF) cells are fairly large due to multiple ports.","The issue may be further complicated in architectures (e.g. the Sun Microsystems SPARC architecture) which use register windows to enable faster procedure calls. In these architectures, instructions such as a SAVE instruction and a RESTORE instruction are used to switch from one instruction window to another instruction window while overlapping the output register (OUT) of the caller with the input registers (IN) of the callee. Each register window also has local registers, which are not shared (i.e., the local registers belong only to the callee). Most implementations have several (e.g. eight) register windows for a single thread.","When the actual number of register windows is not enough for a particular function, the actual register windows are spilled to memory, to make room for new register windows. When returning to a procedure whose register windows were spilled to memory, the register windows are \u201cfilled\u201d from the proper memory addresses. A register file implementing all the register windows in relatively large, multi-ported register file cells can be prohibitively large (and, possibly, slow). For example, an integer register file with eight register windows of 16 registers each would require, for a four threaded processor, 4*8*16=512 registers per processor (only for the register windows; there are also global registers and temporary registers which are part of the register file design; these registers, in a multi-threaded processor implementation, are per thread, but global across a thread's windows). The main advantage of such a register file is that all the windows' registers are, potentially, available for the pipe to read, so there is no need to serialize the pipe on window manipulating instructions (like SAVE or RESTORE).","The terms \u201cthread\u201d and \u201cstrand\u201d are used for a multi-threaded processor design. The term \u201cstrand\u201d is used for the processor's hardware resources supporting the execution of one software thread.","In accordance with the present invention, a register file design for use with a multi-threaded processor implementation having a multi-threaded mode and a single-threaded mode is set forth. In single-threaded mode the processor takes advantage of the inactive threads' register file resources to \u201cflatten\u201d the register windows of the only thread running in the pipeline and thus obtains a higher performance.","In one embodiment, the invention relates to a method for optimizing a register file hierarchy for a mode of operation in a multithreaded processor. The method includes providing a register file hierarchy with a plurality of register file cells, associating the plurality of register file cells with respective threads when the processor is operating in a multithreaded mode and flattening the plurality of register file cells with a single thread when the processor is operating in a single threaded mode. The register file cells correspond to threads of the multithreaded processor.","In another embodiment, the invention relates to a processor which includes a register file hierarchy with a plurality of register file cells wherein the register file hierarchy associates the plurality of register file cells with respective threads when the processor is operating in a multithreaded mode and flattening the plurality of register file cells with a single thread when the processor is operating in a single threaded mode. The register file cells correspond to threads of the processor.","In another embodiment, the invention relates to an apparatus for optimizing a register file hierarchy for a mode of operation in a multithreaded processor. The apparatus includes a register file hierarchy, means for associating the plurality of register file cells with respective threads when the processor is operating in a multithreaded mode and means for flattening the plurality of register file cells with a single thread when the multithreaded processor is operating in a single threaded mode. The register file hierarchy includes a plurality of register file cells. The register file cells correspond to threads of the multithreaded processor.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","110","112","114","120","122","130","132","140","142","150","152"]},"The instruction fetch unit  includes an instruction cache and branch prediction logic. The instruction fetch unit  is coupled to the instruction renaming unit  as well as to the memory management unit  and the secondary cache unit .","The instruction renaming unit  is coupled to the instruction fetch unit  and to the instruction scheduling unit . The instruction renaming unit  includes dependency check logic and a helper instruction generator.","The instruction scheduling unit is coupled to the floating point and graphics unit  and to the integer execution unit . The instruction scheduling unit  includes an instruction window module.","The floating point and graphics unit  is coupled to the instruction scheduling unit  and to the floating point and data cache unit . The floating point and graphics scheduling unit  includes floating point and graphics execution units, a floating point register file and a floating point and graphics result buffer.","The integer execution unit  is coupled to the instruction scheduling unit  and to the data cache unit . The integer execution unit  includes integer execution units, an integer register file and virtual address adders.","The memory management unit  is coupled to the instruction fetch unit  and to the secondary cache unit . The memory management unit  includes a virtual address to physical address translation module as well as a translation lookaside buffer.","The data cache unit  is coupled to the floating point and graphics unit , to the integer execution unit  and to the secondary cache unit . The data cache unit  includes a data cache and a memory disambiguation buffer.","The secondary cache unit  is coupled to the memory management unit , the data cache unit  and the external interface unit . The secondary cache unit  includes a memory scheduling window as well as a unified L2 (level 2) cache.","The external interface unit  is coupled to the secondary cache unit  as well as to an external cache and an input\/output (I\/O) controller. The external interface unit  includes a transaction scheduling window, an external cache controller and an I\/O system interconnection controller.","The test processing unit  is coupled to various units across the processor . The test processing unit  includes a power on controller as well as a clock controller.","The performance hardware unit  is coupled to various units across the processor . The performance hardware unit includes performance instrumentation counters as well as a sampling mechanism.","The instruction fetch unit  is responsible for fetching instructions from the instruction cache and then sending the resulting bundles of instructions to the instruction renaming unit . The instruction fetch unit  may fetch multiple instructions per cycle. Each group of instruction s delivered to by the instruction fetch unit is referred to as a fetch bundle. The instruction cache sources instructions to the processor pipeline by accessing a local instruction cache with predetermined cache indices. The instruction is virtually addressed by an instruction pointer generator. The branch prediction logic enables the instruction fetch unit  to speculatively fetch instructions beyond a control transfer instruction (CTI) even though the outcome or target of the control transfer instruction is not yet known.","The instruction renaming unit  decodes instructions, determines instruction dependencies and manages certain processor resources. The instruction scheduling unit  scheduling instructions from each thread for execution, replays instructions that are consumers of loads when the load misses in the data cache, maintains completion and trap status for instructions executing within the processor  and separately retires instructions in fetch order from each thread.","The floating point execution unit  implements and executes floating point instructions and graphics instructions. The integer execution unit  implements and executes fixed point integer instructions. Additionally, the integer execution unit  assists in execution of floating point instruction which depend on integer condition codes, integer registers and floating point condition codes.","The memory management unit  performs virtual address to physical address translation and includes a translation lookaside buffer that provides for a translation for the most frequently accessed virtual pages.","The data cache unit  provides the main interface between execution pipelines and memory within the processor . The data cache unit  executes load and store instructions as well as derivatives of load and store instructions. The data cache unit  provides a first level cache that is coupled directly to the execution units. The memory disambiguation buffer dynamically disambiguates memory addresses to enable execution of out of order instructions.","The secondary cache unit  provides a unified L2 cache. The L2 cache is controlled by the memory scheduling window which tracks accesses that miss in the L1 caches, the MMU and snoop system request. The memory scheduling window provides an interface between the instruction fetch unit and the L2 cache. The memory scheduling window also receives snoops from the external interface unit  and retired stores from the data cache unit .","The external interface unit  controls data flow among the L2 cache and the external cache, controls system interconnect, provides external cache control and provides a common interface for external processors, I\/O bridges, graphics devices, and memory controllers.","The test processing unit  performs power on tests as well as diagnostic access within the processor . The test processing unit  provides clock control, design for testability and access to external interfaces.","The performance hardware unit  uses the performance instrumentation counters to gather aggregate information about various performance events across a plurality of instructions. The sampling mechanism gathers more detailed instruction history for specific executions of a sampled instruction.","Referring to , a block diagram of a register file design in accordance with the present invention is shown. More specifically, the register file design of the processor  includes four strands, each with eight register windows, each window with eight IN registers, eight OUT registers and eight local registers. All four strands are active only in multi thread mode.","At any given time, in multithreaded mode only one register window is visible for a given thread, as determined by a current window pointer (CWP) register. The current window pointer is incremented or decremented by SAVE and RESTORE instructions, respectively. The SAVE and RESTORE instructions are generally executed on procedure call and return, respectively. Within the register file design, the IN registers contain incoming parameters, the LOCAL registers function as scratch registers and the OUT registers contain outgoing parameters. The register windows overlap partially, thus the OUT registers are renamed by the SAVE instruction to become the IN registers of the called procedure.","The register file design also makes use of single-port memory cells that are much smaller than multi-ported register file cells. The register file structure implements only a current (i.e., active) register window using relatively large, multi-ported register file cells. All these register file cells are backed up by small, single ported memory cells, which hold the values of all register windows. For example, a register window for the processor  includes eight IN registers, eight OUT registers and eight local registers in register file cells for the register window currently in use.","To allow these register file cells to be backed up by memory cells, the register file design uses the overlap between the OUT registers of a register window and the IN registers of the next window. Such an implementation provides separate IN registers for even and odd windows. This register file design reduces the number of windows in memory backing up these register file cells (from eight to four in a processor with eight register windows). The register file design includes logic to track which of the IN register file cells is the IN and which is the OUT for the current register window.","However, to avoid SAVE or RESTORE instructions from becoming serializing instructions in single threaded mode, the register file design includes an improved register hierarchy. Without the improved register hierarchy, SAVE or RESTORE instructions can cause the processor pipe to drain to update the architectural registers in register file cells before the current register window is saved in the memory cells for that window and the next window, requested by SAVE or RESTORE, is loaded in the register file cells. This occurrence affect to a lesser extent the performance on a processor core which is executing in multi-threaded (MT) mode, because the pipe switches between threads, reducing the SAVE or RESTORE penalty for an individual thread. However, when the processor  is executing in a single thread mode to achieve higher single-thread performance, there is no switching between threads, so the performance price is high for many applications. Accordingly, the improved register hierarchy uses the register hierarchy (register file cells backed up by memory cells for the register windows) and serializes the pipe on SAVE and RESTORE instructions when the processor is executing in multithreaded mode. The current window's register bits are in register file cells, while the value of all register windows are in stored in the memory cells. Each of the four active strands includes respective current windows in register file cells and register windows in memory cells. When the processor is executing in a single threaded mode, the register windows are flattened to use only the register file cells. When operating in single threaded mode, only one strand is executing, so the register file cells of the other strands within the processor are not in use. Thus, these unused register file cells are used by the running strand. A flattened register file allows the processor to access any register window at any time, so no pipe serialization is needed on SAVE and RESTORE instructions.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["3","6","5","3","5","5","5","6"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 4","FIG. 4"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5"},"As with the IN\/OUT registers, access to the multithread mode implementation of local registers is straightforward. For example, local register L of window , strand  is addressed via the Even_N\/Odd_win address bit to the register file set to one (because window  is an odd window). The strand number is also part of the register file address (there are four copies of odd and even local registers in register file cells, one per strand in multithread mode).",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6"},"The present invention is well adapted to attain the advantages mentioned as well as others inherent therein. While the present invention has been depicted, described, and is defined by reference to particular embodiments of the invention, such references do not imply a limitation on the invention, and no such limitation is to be inferred. The invention is capable of considerable modification, alteration, and equivalents in form and function, as will occur to those ordinarily skilled in the pertinent arts. The depicted and described embodiments are examples only, and are not exhaustive of the scope of the invention.","For example, while a particular processor architecture is set forth, it will be appreciated that variations within the processor architecture are within the scope of the present invention.","Also for example, while a particular register file architecture is set forth, it will be appreciated that other register file architectures are within the scope of the present invention.","Also for example, the above-discussed embodiments include modules and units that perform certain tasks. The modules and units discussed herein may include hardware modules or software modules. The hardware modules may be implemented within custom circuitry or via some form of programmable logic device. The software modules may include script, batch, or other executable files. The modules may be stored on a machine-readable or computer-readable storage medium such as a disk drive. Storage devices used for storing software modules in accordance with an embodiment of the invention may be magnetic floppy disks, hard disks, or optical discs such as CD-ROMs or CD-Rs, for example. A storage device used for storing firmware or hardware modules in accordance with an embodiment of the invention may also include a semiconductor-based memory, which may be permanently, removably or remotely coupled to a microprocessor\/memory system. Thus, the modules may be stored within a computer system memory to configure the computer system to perform the functions of the module. Other new and various types of computer-readable storage media may be used to store the modules discussed herein. Additionally, those skilled in the art will recognize that the separation of functionality into modules and units is for illustrative purposes. Alternative embodiments may merge the functionality of multiple modules or units into a single module or unit or may impose an alternate decomposition of functionality of modules or units. For example, a software module for calling sub-modules may be decomposed so that each sub-module performs its function and passes control directly to another sub-module.","Consequently, the invention is intended to be limited only by the spirit and scope of the appended claims, giving full cognizance to equivalents in all respects."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features and advantages made apparent to those skilled in the art by referencing the accompanying drawings. The use of the same reference number throughout the several figures designates a like or similar element.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
