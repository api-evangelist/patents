---
title: Data processing environment with methods providing contemporaneous synchronization of two or more clients
abstract: A synchronization system providing multi-client synchronization is described. By storing the data that is actually being synchronized (i.e., storing the actual physical body of a memo, for instance) inside an extra database, “Grand Unification Database” (GUD), (or by specially-designated client data set) under control of a central or core synchronization engine, rather than transferring such data on a point-to-point basis, the system of the present invention provides a repository of information that is available at all times and does not require that any other synchronization client (e.g., PIM client or hand-held device) be connected. The GUD provides a super-set of the other client data sets. Therefore, if the user now includes an additional client, such as a server computer storing user information, the synchronization system has all the information necessary for synchronizing the new client, regardless of whether any of the other clients are currently available. The system can, therefore, correctly propagate information to any appropriate client without having to “go back” to (i.e., connect to) the original client from which that data originated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06915312&OS=06915312&RS=06915312
owner: Starfish Software, Inc.
number: 06915312
owner_city: Scotts Valley
owner_country: US
publication_date: 20010813
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","COMPUTER PROGRAM LISTING APPENDIX","COPYRIGHT NOTICE","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT"],"p":["The present application is a continuation of U.S. application Ser. No. 09\/136,212, filed Aug. 18, 1998, now U.S. Pat. No. 6,275,831; which is related to and claims the benefit of priority from the following commonly owned, formerly U.S. provisional patent applications: Ser. No. 60\/069,731, filed Dec. 16, 1997, and entitled DATA PROCESSING ENVIRONMENT WITH SYNCHRONIZATION METHODS EMPLOYING A UNIFICATION DATABASE; Ser. No. 60\/094,972, filed Jul. 31, 1998, and entitled SYSTEM AND METHODS FOR SYNCHRONIZING TWO OR MORE DATASETS; and Ser. No. 60\/094,824, filed Jul. 31, 1998, now abandoned and entitled DATA PROCESS ENVIRONMENT WITH METHODS PROVIDING CONTEMPORANEOUS SYNCHRONIZATION OF TWO OR MORE CLIENTS. The disclosures of the foregoing provisional applications are hereby incorporated by reference in their entirety, including any appendices or attachments thereof, for all purposes. The present application is also related to the following co-pending, commonly owned U.S. patent application, the disclosures of which are hereby incorporated by reference in their entirety, including any appendices or attachments thereof, for all purposes: Ser. No. 09\/136,215, filed Aug. 18, 1998, now U.S. Pat. No. 6,295,541, and entitled SYSTEM AND METHODS FOR SYNCHRONIZING TWO OR MORE DATASETS. The present application is also related to the following commonly owned U.S. patent applications, the disclosures of which are hereby incorporated by reference in their entirety, including any appendices or attachments thereof, for all purposes: Ser. No. 08\/609,983, filed Feb. 29, 1996, now U.S. Pat. No. 5,845,257, and entitled SYSTEM AND METHODS FOR SCHEDULING AND TRACKING EVENTS ACROSS MULTIPLE TIME ZONES; Ser. No. 09\/020,047, filed Feb. 6, 1998, now U.S. Pat. No. 6,216,131, and entitled METHODS FOR MAPPING DATA FIELDS FROM ONE DATA SET TO ANOTHER IN A DATA PROCESSING ENVIRONMENT; and Ser. No. 08\/923,612, filed Sep. 4, 1997, and entitled SYSTEM AND METHODS FOR SYNCHRONIZING INFORMATION AMONG DISPARATE DATASETS.","The file of this patent contains a computer program listing appendix submitted on one compact disc, including a duplicate compact disc, in a file named \u201cAPPENDIX.TXT\u201d, having a date of creation of Jun. 28, 2004 and a size of 28,672 bytes. The contents of the compact disc are hereby incorporated by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The present invention relates generally to management of information or sets of data (i.e., \u201cdata sets\u201d) stored on electronic devices and, more particularly, to a system implementing methods for maintaining synchronization of disparate data sets among a variety of such devices, particularly synchronizing three or more devices at a time.","With each passing day, there is ever increasing interest in providing synchronization solutions for connected information appliances. Here, the general environment includes \u201cappliances\u201d in the form of electronic devices such as cellular phones, pagers, hand-held devices (e.g., PalmPilot\u2122 and Windows\u2122 CE devices), as well as desktop computers and the emerging \u201cNC\u201d device (i.e., a \u201cnetwork computer\u201d running, for example, a Java virtual machine or a browser).","As the use of information appliances is ever growing, often users will have their data in more than one device, or in more than one desktop application. Consider, for instance, a user who has his or her appointments on a desktop PC (personal computer) but also has a battery-powered, hand-held device for use in the field. What the user really wants is for the information of each device to remain synchronized with all other devices in a convenient, transparent manner. Still further, the desktop PC is typically connected to a server computer, which stores information for the user. The user would of course like the information on the server computer to participate in the synchronization, so that the server also remains synchronized.","A particular problem exists as to how one integrates disparate information\u2014such as calendaring, scheduling, and contact information\u2014among multiple devices, especially three or more devices. For example, a user might have a PalmPilot (\u201cPilot\u201d) device, a REX\u2122 device, and a desktop application (e.g., Starfish Sidekick running on a desktop computer). Currently, in order to have all three synchronized, the user must follow a multi-step process. For instance, the user might first synchronize data from the REX\u2122 device to the desktop application, followed by synchronizing data from the desktop application to the Pilot device. The user is not yet done, however. The user must synchronize the Pilot back to the REX\u2122 device, to complete the loop. Description of the design and operation of the REX\u2122 device itself (available as Model REX-3, from Franklin Electronic Publishers of Burlington, N.J.) is provided in commonly-owned U.S. patent application Ser. No. 08\/905,463, filed Aug. 4, 1997, and entitled, UIMMDHLUI, the disclosure of which is hereby incorporated by reference.","Expectantly, the above point-to-point approach is disadvantageous. First, the approach requires user participation in multiple steps. This is not only time consuming but also error prone. Further, the user is required to purchase at least two products. Existing solutions today are tailored around a device-to-desktop PTM (Personal Information Manager) synchronization, with no product capable of supporting concurrent synchronization of three or more devices. Thus for a user having three or more devices, he or she must purchase two or more separate synchronization products. In essence, existing products to date only provide peer-to-peer synchronization between two points, such as between point A and point B. There is no product providing synchronization from, say, point A to point B to point C, all at the same time. Instead, the user is required to perform the synchronization manually by synchronizing point A to point B, followed by synchronizing point B to point C, then followed by point C back to point A, for completing the loop.","As a related disadvantage, existing systems adopt what is, in essence, an approach having a \u201chard-coded\u201d link for performing synchronization for a given type of data. Suppose, for example, that a user desires to update his or her synchronization system for now accommodating the synchronization of e-mail data (e.g., Microsoft\u00ae Outlook e-mail). With existing synchronization products, the user cannot simply plug in a new driver or module for supporting this new data type. To the point, existing products today do not provide a generic framework into which data type-specific modules may plug into. As a result, these products are inflexible. In the event that the user encounters a new type of data for which synchronization is desired, he or she is required to update all or substantially all of the synchronization product. The user cannot simply plug in a driver or module for supporting synchronization of the new data type. All told, existing synchronization products today assume that users will only perform point-to-point (i.e., two device) synchronization, such as between a hand-held device and a desktop application running on a PC.","This assumption is far removed from reality, however. Users are more likely today to have data among multiple devices, such as among a desktop computer, a server computer (e.g., company network at the user's place of employment), and two or more portable devices (e.g., a laptop computer and a hand-held device). Given the substantial effort required to manually keep three or more devices synchronized, the benefits of synchronization largely remain unrealized for most computer and information application users today.","What is needed is a system providing methods which allows a user of information processing devices to synchronize user information, such as user-supplied contact lists, from one device to any number of other devices, including three or more devices concurrently. The present invention fulfills this and other needs.","The present invention introduces the notion of a reference database: the Grand Unification Database or GUD. By storing the data that is actually being synchronized (i.e., storing the actual physical body of a memo, for instance) inside an extra database (or by specially-designated one of the client data sets) under control of a central or core synchronization engine, rather than transferring such data on a point-to-point basis, the system of the present invention provides a repository of information that is available at all times and does not require that any other synchronization client (e.g., PIM client or hand-held device) be connected. Suppose, for instance, that a user has two synchronization clients: a first data set residing on a desktop computer and a second data set residing on a hand-held device. The GUD introduces a third data set, a middleware database. This third data set provides a super-set of the other two client data sets. Therefore, if the user now includes a third client, such as a server computer storing user information, the synchronization system of the present invention has all the information necessary for synchronizing the new client, regardless of whether any of the other clients are currently available. The system can, therefore, correctly propagate information to any appropriate client without having to \u201cgo back\u201d to (i.e., connect to) the original client from which that data originated.","Internally, the system of the present invention employs \u201ctype plug-in\u201d modules, each one for supporting a particular data type. Since the core synchronization engine treats data generically as \u201cblob\u201d objects, type-specific support is provided by the corresponding plug-in module. Each plug-in module is a type-specific module having an embedded record API (application programming interface) that each synchronization client may link to, for providing type-specific interpretation of blob data. For instance, the system may include one type-specific record API for contact information, another for calendar information, and yet another for memo information. In this manner, each client may employ a type-specific API for correctly interpreting and processing particular blob data. The engine, on the other hand, is concerned with correct propagation of data, not interpretation of that data. It therefore treats the data itself generically. In this fashion, the present invention provides a generic framework supporting concurrent synchronization of an arbitrary number of synchronization clients or devices.","Also internally, the synchronization system of the present invention employs an \u201caction queue,\u201d for optimizing the actual synchronization work performed. In contrast to conventional point-to-point (i.e., binary) synchronization systems, the synchronization system of the present invention does not immediately transmit updates or changes as soon as they are detected. Instead, the system determines or tabulates changes, net of all clients, before undertaking the actual work (e.g., record insertion) of synchronizing a particular client. In particular, all actions or tasks which are to be performed for a client by the system during synchronization are queued in the outbound action queue. This allows the system to apply synchronization logic or intelligence to the queue for further improving system performance, such as eliminating any activities which are redundant or moot. For example, if the system receives a request from two different clients to update a given record (i.e., conflict), the system, applying internal synchronization logic, can eliminate propagating the first update, as it is rendered moot by the second update. In this manner, the system can apply a first-level resolution of requests that are conflicting (or complimentary) and, as a result, eliminate those synchronization activities which are redundant or moot.","An exemplary method for synchronizing multiple data sets includes first establishing a data repository for facilitating synchronization of user information maintained among multiple data sets, the data repository storing user information from the data sets. At least one mapping is stored which specifies how user information may be transformed for storage at a given data set. Upon receiving a request for synchronizing at least one data set, the system may, based on user information stored at the data set(s) and based on the mapping, propagate to the data repository from each data set(s) any changes made to the user information, to the extent that such changes can be reconciled with user information already present at the data repository. Further, based on user information stored at said data repository and based on the mapping, the system may propagate to each data set(s) any changes to the user information which have been propagated to the data repository, to the extent that such changes are not present at the data set.","The following description will focus on the presently-preferred embodiment of the present invention, which is operative in an environment typically including desktop computers, server computers, and portable computing devices, occasionally or permanently connected to one another, where synchronization support is desired. The present invention, however, is not limited to any particular environment or device. Instead, those skilled in the art will find that the present invention may be advantageously applied to any environment or application where contemporaneous synchronization among an arbitrary number of devices (i.e., \u201csynchronization clients\u201d), especially three or more devices, is desirable. The description of the exemplary embodiments which follows is, therefore, for the purpose of illustration and not limitation.","System Hardware and Software","The present invention may be embodied on an information processing system such as the system  of , which comprises a central processor , a main memory , an input\/output (I\/O) controller , a keyboard , a pointing device  (e.g., mouse, pen device, or the like), a screen or display device , a mass storage  (e.g., hard disk, removable floppy disk, optical disk, magneto-optical disk, flash memory, or the like), one or more optional output device(s) , and an interface . Although not shown separately, a real-time system clock is included with the system , in a conventional manner. The various components of the system  communicate through a system bus  or similar architecture. In addition, the system  may communicate with other devices through the interface or communication port , which may be an RS-232 serial port or the like. Devices which will be commonly connected to the interface  include a network  (e.g., LANs or the Internet), a laptop , a handheld organizer  (e.g., the REX\u2122 organizer, available from Franklin Electronic Publishers of Burlington, N.J.), a modem , and the like.","In operation, program logic (implementing the methodology described below) is loaded from the storage device or mass storage  into the main memory , for execution by the processor . During operation of the program (logic), the user enters commands through the keyboard  and\/or pointing device  which is typically a mouse, a track ball, or the like. The computer system displays text and\/or graphic images and other data on the display device , such as a cathode-ray tube or an LCD display. A hard copy of the displayed information, or other information within the system , may be obtained from the output device  (e.g., a printer). In a preferred embodiment, the computer system 100 includes an IBM PC-compatible personal computer (available from a variety of vendors, including IBM of Armonk, N.Y.) running Windows 9x or Windows NT (available from Microsoft Corporation of Redmond, Washington). In a specific embodiment, the system  is an Internet or intranet or other type of network server and receives input from and sends output to a remote user via the interface  according to standard techniques and protocols.","Illustrated in , a computer software system  is provided for directing the operation of the computer system . Software system , which is stored in system memory  and on storage (e.g., disk memory) , includes a kernel or operating system (OS)  and a windows shell . One or more application programs, such as client application software or \u201cprograms\u201d  may be \u201cloaded\u201d. (i.e., transferred from storage  into memory ) for execution by the system .","System  includes a user interface (UI) , preferably a Graphical User Interface (GUI), for receiving user commands and data and for producing output to the user. These inputs, in turn, may be acted upon by the system  in accordance with instructions from operating system module , windows module , and\/or client application module(s) . The UI  also serves to display the user prompts and results of operation from the OS , windows , and application(s) , whereupon the user may supply additional inputs or terminate the session. In the preferred embodiment, OS  and windows  together comprise Microsoft Windows software (e.g., Windows 9x or Windows NT). Although shown conceptually as a separate module, the UI is typically provided by interaction of the application modules with the windows shell and the OS .","Of particular interest herein is a synchronization system or \u201cSynchronizer\u201d  of the present invention, which implements methodology for contemporaneous synchronization of an arbitrary number of devices or \u201cclients.\u201d Before describing the detailed construction and operation of the Synchronizer , it is helpful to first briefly review the basic application of synchronization to everyday computing tasks.","Brief Overview of Synchronization","A. Introduction","Many software applications, such as personal productivity applications as Starfish Sidekick\u00ae and Lotus\u00ae Organizer, have sets of data or \u201cdata sets\u201d (e.g., address books and calendars). Consider for instance a user scenario where an account executive needs to coordinate contacts and events with other employees of the XYZ corporation. When traveling, this executive carries a laptop PC with Starfish Sidekick\u00ae installed. At home, she and her husband use Lotus\u00ae Organizer to plan their family's activities. When on family outings, the account executive carries her PalmPilot\u2122 hand-held organizer. As the foregoing illustrates, a user often needs a means for synchronizing selected information from the data sets his or her applications rely upon. The account executive would not want to schedule a business meeting at the same time as a family event, for example.","Conventionally, the process of synchronizing or reconciling data sets has been a binary process\u2014that is, two logical data sets are synchronized at a time. Any arbitrary synchronization topology will be supported. Here, the system guarantees synchronization stability and the avoidance of undesirable side effects (cascading updates, record duplication, or the like). Data sets do not need to be directly connected but, instead, can be connected via a \u201cstore-and-forward\u201d transport, such as electronic mail.","B. Synchronization Design","1. Synchronization Type","Data set synchronization may, for convenience of description, be divided into two types: content-oriented and record-oriented. Content-oriented synchronization correlates data set records based on the values of user-modifiable fields. Value correlation requires semantic (or at least advanced syntactic) processing that the human brain is very good at and computers are not. For example, a record in one data set with a name field valued \u201cJohann S. Bach\u201d and a record in asecond data set with a name field valued \u201cJ. S. Bach\u201d could possibly refer to the same real-world person. A human being might arrive at this conclusion by correlating associated data (addresses) or drawing upon external information (e.g., Bach is an unusual name in the U.S.). Creating program logic or code with the ability to make these type of decisions is computationally very expensive.","Record-oriented synchronization correlates data set records by assuming that each record can be uniquely identified throughout its lifetime. This unique identifier is usually implemented as a non-modifiable, hidden field containing a \u201cRecord ID\u201d. Record-oriented synchronization algorithms usually require maintaining a mapping from one set of record IDs to another. In a preferred embodiment, the system employs record-oriented synchronization.","Record-oriented synchronization is conceptually simple and may be summarized as follows. In the rules below, A and B refer to two data sets which have a synchronization relationship. The rules are assumed to be symmetrical.\n\n","2. Timestamps","The actual synchronization logic in synchronization systems often needs to make processing decisions based on comparing the time at which past events occurred. For example, it is necessary to know if a record was modified before or after the last synchronization transaction. This requires recording the time of various events. A \u201ctimestamp\u201d value may be employed to this purpose. Typically, data sets involved in synchronization support timestamps, or can be supplied with suitable timestamps, in a conventional manner. In conjunction with the usage of timestamps to compare the relative timing of record creation or modification, the clocks on the respective devices may themselves be synchronized.","3. Record Transformations","During synchronization, a synchronization system will typically transform records from one application-usage-schema set to another application-usage-schema set, such as transforming from a Starfish Sidekick\u00ae card file for business contacts to a corresponding PalmPilot\u2122 data set. Typically, there is a one-to-one relationship between records in these two data sets, that is, between the source and target data sets. If this is not the case, however, the component of the system that interacts with a non-conforming data set may include logic to handle this non-conformance.","The record transformations themselves are a combination of field mappings and conversions from a source record to a target record. Exemplary types of field mappings include, for instance, the following.\n\n","With an understanding of the basic process of synchronizing information or computing devices, the reader may now better appreciate the teachings of the present invention for providing improved methodology for contemporaneous synchronization of an arbitrary number of devices (i.e., synchronization clients). The following description focuses on specific modifications to a synchronization system for implementing the improved synchronization methodology.","Synchronization System Providing Contemporaneous Synchronization of Two or More Clients","A. General Design Considerations","The present invention introduces the notion of a \u201cGrand Unification Database\u201d (GUD)\u2014a central repository or reference database for user data. By storing the data that is actually being synchronized (i.e., storing the actual physical body of a memo, for instance) inside an extra database (or by specially-designated one of the client data sets) under control of a central or core synchronization engine, rather than transferring such data on a point-to-point basis, the system of the present invention provides a repository of information that is available at all times and does not require that any other synchronization client (e.g., PIM client or hand-held device) be connected. Suppose, for instance, that a user has two synchronization clients: a first data set residing on a desktop computer and a second data set residing on a hand-held device. The GUD introduces a third data set, a middleware database. This third data set provides a super-set of the other two client data sets. Therefore, if the user now includes a third client, such as a server computer storing user information (or other information which the user desires synchronization to), the synchronization system of the present invention has all the information necessary for synchronizing the new client, regardless of whether any of the other clients are currently available. The system can, therefore, correctly propagate information to any appropriate client without having to \u201cgo back\u201d to (i.e., connect to) the original client from which that data originated.","Internally, the system of the present invention employs a driver-based architecture providing type-specific \u201cplug-in\u201d modules, each one for supporting a particular data type. Since the core synchronization engine treats data generically as \u201cblob\u201d objects, type-specific support is provided by the corresponding plug-in module. Each plug-in module is a type-specific module having an embedded record API (application programming interface) that each synchronization client may link to, for providing type-specific interpretation of blob data. For instance, the system may include one type-specific record API for contact information, another for calendar information, and yet another for memo information. In this manner, each client may employ a type-specific API for correctly interpreting and processing particular blob data. The engine, on the other hand, is concerned with correct propagation of data, not interpretation of that data. It therefore treats the data itself generically. In this fashion, the present invention provides a generic framework supporting concurrent synchronization of an arbitrary number of synchronization clients or devices.","Also internally, the synchronization system of the present invention employs an \u201caction queue,\u201d for optimizing the actual synchronization work performed. In contrast to conventional point-to-point (i.e., binary) synchronization systems, the synchronization system of the present invention does not immediately transmit updates or changes as soon as they are detected. Instead, the system determines or tabulates changes, net of all clients, before undertaking the actual work (e.g., record insertion) of synchronizing a particular client. In particular, all actions or tasks which are to be performed for a client by the system during synchronization are queued in the outbound action queue. This allows the system to apply synchronization logic or intelligence to the queue for further improving system performance, such as eliminating any activities which are redundant or moot. For example, if the system receives a request from two different clients to update a given record (i.e., conflict), the system, applying internal synchronization logic, can eliminate propagating the first update, as it is rendered moot by the second update. In this manner, the system can apply a first-level resolution of requests that are conflicting or complementary and, as a result, eliminate those synchronization activities which are redundant or moot.","B. Overview of Synchronization System Internal Architecture",{"@attributes":{"id":"p-0047","num":"0057"},"figref":"FIG. 2","b":["200","200","230","210","240","220","250"]},"The GUD , as previously described, serves as a central repository storing record data and mappings which dictate how records are transformed (i.e., from one data set to another). The synchronization engine  includes generic logic for managing the GUD , including locating and interpreting information in the GUD. Based on the information in the GUD  and client requests, the synchronization engine  builds the action queue , adding or removing specific tasks from the queue as necessary for carrying out synchronization transactions. The action queue  itself is an array of task entries; it may grow or shrink, depending on the current number of entries that it stores. In the currently-preferred embodiment, the array is sorted by record ID, that is, according to the record ID of the corresponding record from the GUD. Since entries are sorted by record ID, the task of identifying entries in conflict is simplified.","To communicate with the clients, the synchronization engine  employs the client API . The client API provides database engine-like functionality. For example, API function calls are provided for moving to records, reading records, and writing records. In the currently-preferred embodiment, clients accessors ,  are \u201caccessor\u201d portions of the synchronization system which, in turn, communicate directly with the \u201creal\u201d clients, such as REX. By implementing its architecture such that all clients communicate commonly through the client API , the system  provides plug-in capability for supporting new clients.","In order for the system to correctly determine record information in the GUD , the synchronization engine  communicates with type drivers or modules (e.g., X type  and Y type ) through the type API . As previously described, each type, such as calendar, contacts, and the like, is associated with a particular type module. The type API  allows the synchronization engine  to ask common questions about information stored in the GUD . For example, if the synchronization engine  needs to determine whether two records are identical, it can request a record comparison operation by the corresponding type module, using the type API . In comparison to the client API , the type API  is comparatively small. By implementing its architecture such that all type-specific requests are communicated commonly through the type API , the system  provides built-in extensibility. When support is desired for a new type, one need only plug in a new type module. Any client which wants to communicate with that new type now has automatically gained support for that new type. In the currently-preferred embodiment, a type module is unaware of any specific clients which it supports. Clients, on the other hand, typically know what types that each desires to synchronize with.","As also shown, each client accessor can communicate directly with the type modules, using a record API . In the currently-preferred embodiment, each type module surfaces its own record API, such as record API  for type module . The underlying record API is specific for each type. Each accessor communicates with a desired type module, not through the synchronization engine , but instead through the exposed record API for the desired type. Thus, in effect, there is a direct communication path between client accessors and type modules. In typical use, the record API is employed by a client accessor to create or write record-specific information. For example, if the client desires to write a \u201csubject\u201d for a contact record, the client, operating through the corresponding client accessor, can invoke the corresponding record API for requesting this service. In response to invocation of the record API, the corresponding type module would service the API call for assisting with creating or editing the underlying record, in the matter requested by the client. The actual work of creating or editing the record is typically performed by the client; however, the corresponding type module returns specific information about the given type, so that the client knows exactly how the record is structured. As a simple example, the record API might return information indicating that a particular record type consists of a structure having four string data members, each being 64 bytes long. Based on such information, the client now knows how to interpret and process that type.","C. Synchronization System Detailed Internal Architecture","1. GUD",{"@attributes":{"id":"p-0054","num":"0064"},"figref":"FIG. 3","b":["300","320","310","310","313","311"]},"Also shown, mapping tables  store entries comprising a reference ID , a source ID , a checksum or integrity value (e.g., CRC) , and a last modification (mod) timestamp . The reference ID  is the same ID as associated with a record in the data table . The source ID  is the record ID for the record, as it was received from the client. The last modification timestamp  establishes when the record was last synchronized through the system. The timestamp (e.g., system time structure) reflects the time on the system clock of the machine which is being synchronized. Optionally, the system stores a comparison value or checksum (e.g., cyclic redundancy checking or CRC) , for use with those clients that do not support timestamps. If the checksum is not used, the system stores 0 as its value.","Each table itself is linked to a particular client, through a table ID, with the correspondence being stored as configuration information (which in the currently-preferred environment exists as a higher level than the synchronization engine). In this manner, each one of the mapping tables can be associated with an appropriate client. The end result is that the system maintains a mapping table for each client. Thus, for a given record ID, the system can easily determine (from the above-described reference ID-to-source ID correspondence) where that record maps to for all clients. Consider, for instance, a particular record residing on a REX device. Based on the source ID for that record, the system can determine from the mapping table the corresponding mapping table item for that source ID. Now, the system has sufficient information allowing the particular record to be synchronized, as required by the user. When the data is completely synchronized with all clients, all mapping tables in the system will store that record ID (i.e., the record ID is now common to all tables once the data is completely synchronized with all clients).","2. Action Queue","The action queue stores entries of a particular action type, which are used during synchronization to indicate all actions needed to be performed by the system. In the currently-preferred embodiment, six action types are defined:\n\n","The CLIENT action types are used to indicate particular synchronization work which is required to be performed for a particular client. Suppose, for instance, that the synchronization engine determines that the REX client needs to be updated, as a result of actions undertaken by other clients; the REX client need not be currently available (e.g., need not be currently connected to the system). In such a case, the engine can post to the action queue appropriate action entries for indicating the synchronization work which is required to be performed the next time the REX client is connected. In a manner similar to that described above for the GUD, the system can specify an update (CLIENT_UPDATE), add (CLIENT_ADD), and\/or delete (CLIENT_DELETE) action, on a per client basis. In the instance of an update or delete action, there already exists a corresponding mapping table item. For an add action, however, the system undertakes as its first action item the task of creating a new mapping table item. Therefore, when the add action is eventually performed, the table item will be created as well. On the other hand, should the action be canceled, the mapping table item will not be created.","Additional pieces of information are tracked by each entry in the action queue: (1) record data, (2) source client, and (3) timestamp. The record data is the actual data (or a reference to the actual data) obtained from the client. In this manner, the actual data may be associated with a particular action. The source client indicates which client the action originated from. This is useful, for instance, during synchronization, so that the system does not attempt to synchronize the client from which the data just arrived. The timestamp stored in an action queue entry is the last modification time of the record from the source client. This is stored for possible use during conflict resolution (which is described in further detail below).","As previously described, the entries in the action queue are sorted by reference ID. In this manner, the system can quickly determine action queue entries which are potentially in conflict. For example, if the queue contains three entries all having the same reference ID, the system must examine those entries for uncovering any conflicts. The actual conflict resolution rules applied in the system are described below.","3. Methodology of System Operation",{"@attributes":{"id":"p-0063","num":"0079"},"figref":"FIG. 4A","b":["400","401","402","403"]},"Conflict resolution requires further explanation. As previously described, the entries in the action queue are sorted by reference ID. In this m a miner, the system can quickly determine action queue entries which are potentially in conflict. For example, if the queue contains three entries all having the same reference ID, the system must examine those entries for uncovering any conflicts. Not only are items in the action queue sorted by a reference ID but, as a second level of ordering, they are also sorted by action. GUD updates are always sorted to the top, thus establishing their priority over other types. Now, the following exemplary conflict resolution rules may be applied:",{"@attributes":{"id":"p-0065","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Rule 0:","GUD_UPDATE +"]},{"entry":[{},"<entry(ies) other than GUD_UPDATE>"]},{"entry":[{},"GUD_UPDATE wins; delete all others"]},{"entry":["Rule 1:","GUD_UPDATE +"]},{"entry":[{},"GUD_UPDATE"]},{"entry":[{},"GUD_UPDATE with greatest timestamp wins (or display UI)"]},{"entry":["Rule 2:","GUD_UPDATE +"]},{"entry":[{},"GUD_DELETE"]},{"entry":[{},"GUD_UPDATE (take data over non-data)"]},{"entry":["Rule 3:","CLIENT_UPDATE +"]},{"entry":[{},"CLIENT_UPDATE (from another client)"]},{"entry":[{},"Leave both (i.e., same)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"404"},{"@attributes":{"id":"p-0066","num":"0082"},"figref":"FIG. 4B","b":["402","421","422","421","422","423","424"]},{"@attributes":{"id":"p-0067","num":"0083"},"figref":"FIG. 4C","b":["404","431","432","433","434"]},"While the invention is described in some detail with specific reference to a single-preferred embodiment and certain alternatives, there is no intent to limit the invention to that particular embodiment or those specific alternatives."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1B","b":"1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 4A-C"}]},"DETDESC":[{},{}]}
