---
title: Persistent client-server database sessions
abstract: A client-server database system enables persistent client-server database sessions, without modification to a client-side application, a database system, or native client-side database drivers. The client is implemented with a driver manager to facilitate communication between the native database drivers and the database application. The driver manager wraps the native drivers, intercepting queries passed from the database application to the database drivers. The driver manager modifies the queries to form modified queries that direct the database server to render result sets produced from processing the queries persistent at the database server. Upon recovery following a server crash, the driver manager directs the drivers to reestablish a connection with the database server. The driver manager then finds the persistent result set table and, using logged data, returns to the same operation on the result set table just prior to the crash. The driver manager then reassociates the application context to the new database session without the database application being aware that a failure occurred. The recovery is thus transparent to the client-side application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07386557&OS=07386557&RS=07386557
owner: Microsoft Corporation
number: 07386557
owner_city: Redmond
owner_country: US
publication_date: 20040818
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION(S)","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This is a divisional of U.S. patent application Ser. No. 10\/128,053, entitled \u201cPersistent Client-Server Database Sessions\u201d, which was filed Apr. 22, 2002 as a divisional of U.S. patent application Ser. No. 09\/268,240, which was filed Mar. 15, 1999, now abandoned.","This invention relates to client-server computer systems. More particularly, this invention relates to systems and methods that enable database applications running on the client to persist across server crashes.","Computer systems occasionally crash. A \u201csystem crash\u201d is an event in which the computer quits operating the way it is supposed to operate. Common causes of system crashes include power outage, application operating error, and computer goblins (i.e., unknown and often unexplained malfunctions that tend to plague even the best-devised systems and applications). System crashes are unpredictable, and hence, essentially impossible to anticipate and prevent.","A system crash is at the very least annoying, and may result in serious or irreparable damage. For standalone computers or client workstations, a local system crash typically results in loss of work product since the last save interval. The user is inconvenienced by having to reboot the computer and redo the lost work. For servers and larger computer systems, a system crash can have a devastating impact on many users, including both company employees as well as its customers.","Being unable to prevent system crashes, computer system designers attempt to limit the effect of system crashes. The field of study concerning how computers recover from system crashes is known as \u201crecovery.\u201d Recovery from system crashes has been the subject of much research and development.","Current database systems support fault-tolerance and high availability by recovering quickly from system failures. In general, the goal of redo recovery is to return the computer system after a crash to a previous and presumed correct state in which the computer system was operating immediately prior to the crash. Then, transactions whose continuations are impossible can be aborted.","Much of the recovery research focuses on database recovery for database computer systems, such as network database servers or mainframe database systems. Imagine the problems caused when a large database system having many clients crashes in the midst of many simultaneous operations involving the retrieval, update, and storage of data records. Database system designers attempt to design database recovery techniques that minimize the amount of data lost in a system crash, minimize the amount of work needed following the crash to recover to the pre-crash operating state, and minimize the performance impact of recovery on the database system during normal operation.","While database recovery techniques are helpful for recovering data, the techniques offer no help in recovering applications that are interacting with the database at the time of failure. Currently, such applications either fail, resulting in an application outage, or are forced to cope with database failures assuming they survive the database crash. The former compromises application availability and can increase operational complexity. The later either severely restricts application flexibility or increases its complexity.","When an application fails because of a database system crash, organizations responsible for the application need to quickly bring the application back on line. In the enterprise-computing world, time is quite literally money. Database recovery ensures that the database state is consistent. However, an application retaining state across database transactions can have consistency requirements that are not captured at the database transaction boundary. Furthermore, parts of the application state may be lost during a crash. Restoring and continuing application execution is all too frequently a very complex and time-consuming operational problem.","In some system configurations, an application can survive a database system crash. For example, when the application executes on a client machine while the database is on a separate server. This permits the application to include logic to deal with database crashes and hence avoid an application outage. However, handling errors or exceptions is a very difficult part of getting applications right. Dealing with database system failures at the application level is tedious and error-prone, even when the application itself stays alive.","There has been some work in this area. One technique exploits logging and recovery techniques to enable applications to be recoverable. See, e.g., Lomet, D. Application recovery using generalized redo recovery. , Orlando, Fla. (February, 1998); and Lomet, D. and Tuttle, M. Redo recovery from system crashes. , Zurich, Switzerland (September 1995) 457-468. The focus of this work has been to minimize the impact of providing recovery on the normal operation of the system. In practice, this means minimizing the amount of logging and application checkpointing required. Sometimes, it means making the application an object that can be managed by the database recovery manager.","Other prior work on application fault-tolerance in distributed systems is based on some form of application \u201cinstallation points\u201d and\/or \u201cmessage logging\u201d. The prior work can be categorized into the following three approaches, all of which incur high normal operation and\/or recovery costs: (1) fault-tolerant process pairs, (2) distributed state tracking, and (3) persistent queues.","Another client-server system directed to application recovery is described in U.S. patent application Ser. No. 09\/033,511, entitled \u201cClient-Server Computer System With Application Recovery of Server Applications and Client Applications\u201d, which was filed Mar. 2, 1998 in the names of David B. Lomet (an inventor in this invention) and Gerhard Weikum. This application is assigned to Microsoft Corporation.","Despite these efforts, there remains a need to improve application recovery techniques in client-server database systems. Particularly, there is a need to provide application recovery at modest system implementation cost that avoids modification to the application itself.","This invention concerns a client-server database system that enables persistent client-server database sessions, without modification to a client-side application, database system, or native client-server access mechanisms (called drivers). The client-server database system preserves sessions across a server crash without the client-side application being aware of the outage, thereby making recovery transparent to the application.","In one implementation, the client-server database system has a client computer and a database server computer. The database server computer runs a database server program that handles client queries for data in one or more database tables stored in a stable storage.","The client has a database application to formulate the client queries for the data kept in the tables. One or more client-side database drivers facilitate communication between the database application and the database server program.","The client is further implemented with a driver manager to facilitate communication between the database drivers and the database application. The driver manager wraps the native drivers, intercepting queries passed from the database application to the database drivers and responses returned from the drivers to the application. The driver manager modifies the queries to form modified queries that direct the database server to render result sets produced from processing the queries persistent at the database server.","If the query will result in creation of a result set, for example, the driver manager alters the query to direct the database server to create a result set table in the stable storage and fill the table with the result set obtained from processing the query. In this manner, the result set will persist across a server crash. The driver manager continues to convert statements from the database application for operation on the result set table and reconvert responses from the database server prior to returning them to the database application. The driver manager further tracks application statements and a current result set table location in a log maintained at the client. Thus, the database application is unaware of the actions being taken to make the session persistent.","Upon recovery following a server crash, the driver manager directs the drivers to reestablish a connection with the database server. The driver manager then finds the persistent result set table and using data from the log, returns to the same operation on the result set table just prior to the crash. The driver manager reassociates the application context to the new database session without the database application even knowing that a failure occurred.","This invention concerns client-server database systems and techniques for making client-server database sessions persistent across database server crashes. In general, the system is responsible for application persistence across server failures. The system acts to ensure that the application is recoverable and able to continue execution after the crash, without the application taking any measures on its own to ensure its survival. This characteristic is referred to as \u201ctransparent\u201d application recoverability.","The transparent application recovery scheme is described in the context of a \u201cmiddleware\u201d software architecture in which a client-based software component is layered between a native database driver layer (e.g., ODBC layer) and a database application layer (e.g., SQL layer). The middleware infrastructure can be readily installed on client machines without introducing a substantial recovery manager or extensively modifying an existing database system's recovery manager. Furthermore, the middleware infrastructure requires no modification to the client-side drivers and application. It is noted, however, that the invention may be implemented in other architectures, such as at other client layers, or partly at the client and partly at the server.","System",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["20","22","24","26","22"]},"The server  is a general-purpose computer that is configured as a database server to serve data from a persistent database . The server is illustrated as a server-enabled personal computer, such as a computer configured to run the Windows NT operating system from Microsoft Corporation. However, the server  may further be implemented in other forms, such as a UNIX-based server, a minicomputer, or a mainframe. The server can service more than one clients, although only one client is shown for discussion purposes.","Software Architecture",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 1"],"b":["30","20","32","22","34","28","34"]},"The client-side software includes one or more database drivers  that facilitate data communication with the database server. The database drivers  are typically implemented as a client stub sold as part of the database system. The drivers support a set of APIs (application program interfaces).","The client-side software further includes a driver manager  that wraps the driver stub , and a client database application  (e.g., SQL client). The client application  communicates with the database server  by calling the APIs supported by the database drivers . With this architecture, the client database application  sends query requests via the database driver  to the database server  to locate data records maintained in one or more database tables , which are stored in database .","The driver manager  manages communications between the application  and database drivers . The driver manager  selects a driver for a particular database when the application first connects to the database and then passes all function calls coming from the application to the driver. The driver manager may also handle some function calls directly, and detect and handle some types of errors.","The client-server software architecture  provides persistent database sessions for the client application  during its interaction with the database server . The sessions can survive a database server crash without the client application  being aware of the outage, except for possible timing considerations.","The driver manager  wraps the database driver layer  and intercepts all communication between the client application  and the database driver . By wrapping the driver APIs, the intermediate manager layer  is able to alter commands from the client application to direct the server database to make volatile session state persistent. For example, when the client application sends a query to locate records in a database table , the manager  rewrites the query statement before passing the statement on to the native driver . The rewritten statement asks the database server to create a persistent database table into which the query result set can be captured. Thus, the result set from the query is stored in a result set table  that can survive a system failure.","The client  is also equipped with a cache  that stores a log . The driver manager  intercepts and logs all requests going from the client application  to the database server  in the log . The manager  also intercepts responses from the database server  and variously caches certain responses in cache , filters other responses, reshapes result sets returned in response to queries, and synchronizes with state materialized on the database server.","Accordingly, in one implementation, the manager  contains all of the necessary code to enable persistent database sessions to client application , without the application  needing to take measures for its recoverability. Further, there are no modifications to either the database system or native drivers . In this manner, the architecture  integrates database server recovery and transparent session recovery. The result is persistent client-server database sessions that survive a server crash without the client application being aware of the outage (except for possible timing considerations) and without requiring changes to the database system, native driver, or any special application programming.","General Operation",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["40","38","36","58","40","38","60","60","36","40","36","40"]},"To provide persistent database sessions, the intermediate driver manager layer  insulates the client application  from these underlying database sessions formed by the drivers . To do this, the driver manager layer  creates a virtual database session (step  in ) and maps the virtual session onto a normal database session supported by the drivers  (step ). In one implementation, the ODBC connection is identified by a connection handle and the driver manager  maps the connection handle to a virtual connection handle. The driver manager then returns the virtual connection handle to the application. Should a crash occur, the driver manager establishes a new connection with the database server and remaps the virtual connection handle to the handle for the new connection. This","At step  in , the client database application  submits a request for processing at the database server . The driver manager  intercepts the application request (step ). It performs a one-pass parse to determine the request type (step  in ).","Depending upon the request type, the driver manager  may modify the request to direct the database server to preserve the request and\/or results produced in response to the request in the persistent database  at the server  (step ). For example, if the request causes the server to search a database table  and create a result set, modification of the request may involve telling the server to create a persistent table  in which the result set can be stored. In this way, the architecture allows the volatile state to be materialized as persistent tables at the server. A detailed example involving creation of a persistent result set table in an ODBC\/SQL environment is given below under the main heading \u201cExemplary ODBC\/SQL Implementation\u201d and the subheading \u201cExemplary Session with Driver Wrapper Layer \u201d.","The driver manager  may optionally log the modified request in the log  in client cache  (step ). This is particularly helpful when interacting with a persistent result set table . The driver manager  can track location in the result set table  by logging such information in the log . Such location information can then be made available during recovery to return the pre-crash location in the table.","The driver manager  passes the modified request to the drivers  (step  in ). The drivers  send the request to the database access proxy  and server application  and receives responses returned from them (step ). The drivers  pass responses onto the application (step ).","The driver manager  intercepts the responses before they get to the application (step ). The driver manager  may modify the responses so that the application is unaware of the changes made to the original request (step ). For instance, the application may be unaware that it is interacting with a persistent result set table  stored in stable database  at the server. The driver manager also checks for errors in an effort to detect failures. The driver manager  then passes the response onto the application (step ).","When a crash is detected, the driver manager  requests a new session and the drivers  create a post-crash database session with an appropriate volatile state (step ). They do this by establishing a private database connection and pinging the server for recovery. Once the server is found, the driver manager  reconnects the virtual session with the new post-crash session (step ). This involves reconnecting the session to any persistent tables that were established prior to the crash. After the client application has successfully terminated, the manager  cleans up all persistent structures on the database server that were created to store database session state, dropping all tables and stored procedures.","The recovery is transparent to the application . When the application interrogates its virtual connection, it only sees the activity on the connection to which its virtual connection is mapped, not the activity on any private connection used by the driver manager layer . The mapped connection activity mimics the application's use of a normal ODBC connection.","Exemplary Computer",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 4","FIG. 1"],"b":["22","100"]},"Computer  includes a processing unit , a system memory , and a bus  that couples various system components including the system memory  to the processing unit . The bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS) is stored in ROM .","Computer  also has one or more of the following drives: a hard disk drive  for reading from and writing to a hard disk, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the personal computer. Although a hard disk, a removable magnetic disk and a removable optical disk are described, other types of computer readable media can be used to store data, such as flash memory cards, digital video disks, random access memories (RAMs), read only memories (ROM), and the like.","A number of program modules may be stored on the hard disk, magnetic disk, optical disk, ROM, or RAM. These programs include an operating system , one or more application programs , other program modules , and program data . As an example, the database driver , driver manager  and database application  are included as the programs  and program modules .","A user may enter commands and information into the personal computer  through input devices such as keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the bus , but may be connected by other interfaces, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device is connected to the bus  via an interface, such as a video adapter . In addition to the monitor, personal computers typically include other peripheral output devices (not shown) such as speakers and printers.","The server computer  is connected to the network  through a network interface or adapter , a modem , or other means for establishing communications over the network. The modem , which may be internal or external, is connected to the bus  via the serial port interface .","Exemplary ODBC\/SQL Implementation","A specific implementation of the client-server system  will now be described with reference to the software architecture shown in . In this implementation, the server-side database application  is the SQL server from Microsoft Corporation. The client-side application  supports SQL-based communications. Client-side database driver  is embodied as an ODBC-compliant driver. ODBC (Open Data Base Connectivity) is a standard application programming interface (API) by which the client application  accesses data in the database . The detailed implementation is described to examine the differences between a conventional ODBC-based database session and a persistent database session enabled by the client-server architecture  of , and namely by the driver manager wrapper layer  installed on the client.","ODBC enables any application to access any database that supports this standard by using a standard collection of call points. Included in the standard interface are the following:\n\n","Vendors support ODBC by providing drivers that are specifically designed for their particular database system. The ODBC driver's application interface adheres to the ODBC standard. All ODBC drivers support the same call points, regardless of what database engine is on the back end.","The ODBC driver interaction with the database system is customized to the specific database engine. This interaction requires use of proprietary communication protocols, SQL language message formats, and result set representations. Using ODBC, applications need not be customized to or even aware of the proprietary aspects of accessing the data they are using. The driver makes any necessary translations in sending SQL statements to the database system and presents the results back to the application in a standard way, including standard return codes.","According to aspects of this invention, the driver manager  is configured to intercept application requests going to the database and responses returned from the server. Like a conventional driver manager, the driver manager  is designed to wrap call points of the ODBC drivers . But, unlike a conventional driver manager, it creates a surrogate for each function in the ODBC API that intercepts the client application ODBC request on its way to the ODBC driver. Actions that the driver manager  takes to analyze the application request and provide for the persistence of volatile session state are performed in the surrogate, prior to passing the application request on to the native driver . This approach to providing server database sessions that survive server crashes is completely transparent to other system components. It requires no changes to native ODBC drivers , client application programs , or SQL database systems .","To illustrate the difference between a conventional ODBC session and one that is enhanced by the driver manager, the following discussion presents to different scenarios. The first scenario is a conventional ODBC session without the driver wrapper layer . The second scenario is a persistent ODBC session achieved by inclusion of the driver wrapper layer .","Exemplary Session without Driver Wrapper Layer ","A conventional ODBC database session for a SQL server is described with reference to , and with additional reference to selected architectural components in . It is noted that the conventional architecture used to achieve the ODBC session is similar to that shown in , except the driver manager  is not present. The conventional architecture may include a software layer between the application and drivers, but this layer is \u201cvanilla\u201d in that it merely facilitates communications between the application and drivers without attempting to modify the requests or track them or perform other functionality described herein that render the sessions persistent.","Consider a database session involving a data analysis query, similar to those in the TPC-D benchmark. This query involves three database tables: a master customer table (), a detail orders table (), and an invoice table (). The task is to extract appropriate records for a customer with the last name \u201cSmith\u201d from the customer table, find that customer's current orders from the detail orders table, and aggregate the order totals into an invoice table. This client application might be coded as follows.","At step  in , the client-side ODBC driver  creates an ODBC database session by opening a connection to a named database server, following a standard protocol to log on to the server, and issuing a series of ODBC function calls to set application specific attributes on the database connection. Next, at step , the ODBC driver  submits an ODBC function containing a SQL statement to create a result set  from the master customer table () consisting of records for customers with a last name of \u201cSmith\u201d. In response, the database server locates all customer records indexed for \u201cSmith\u201d and generates a result set  (step ).","At step  in , the client application issues fetch commands to retrieve records from result set, until the target customer record is found. The database server serves customer records from the result set until the customer record is located. Then, the client application submits an ODBC function containing a SQL statement to open a cursor on the orders table () for orders matching an identifier (ID) associated with the customer (step ). The server database responds by opening a cursor on the orders table () (step ).","The client application issues fetch commands to retrieve all matching order records in the orders table () that match this customer ID (step ). The client application calculates an aggregate of the order records associated with the customer ID (step ). It then submits an ODBC function containing a SQL statement to update the invoice table () with the calculated aggregate (step ). In response, the database server updates the invoice table ()(step ). Following the update, the ODBC driver  issues an ODBC function call to close the connection to the database, terminating the ODBC session (step ).","Unfortunately, the conventional ODBC standard leaves undefined what behavior the client application can expect should the database server to which it has a connection fail. The effects of a server failure might involve:\n\n","Exemplary Session with Driver Wrapper Layer ","Now, consider the client-server architecture  of , which includes the driver manager . In the ODBC\/SQL implementation, including the driver manager  intermediate of the client application  and ODBC drivers  provides persistent database sessions for the client application  during its interaction with the database server.","An initial step towards providing ODBC persistent database sessions is to decompose session state into separate elements, each of which can be managed as a distinct data object. These elements of session state have different lifetimes and recovery requirements. Session state elements include:\n\n","While there are subtleties to each element of an applications ODBC state, result sets are particularly challenging. Accordingly, an aspect of this invention is to configure the driver manager  to render result sets persistent and ensure their seamless delivery to a client application. A SQL statement result is made persistent by being stored as a persistent SQL table  in the database . Seamless delivery is ensured by re-accessing this table after a failure and reestablishing the place where the pre-crash delivery was interrupted.",{"@attributes":{"id":"p-0079","num":"0094"},"figref":["FIGS. 6","FIG. 2","FIGS. 6"],"i":["a ","b ","a ","b "],"b":["6","42","1","22","24","6","40","38","36"]},"At step  in , the client-side ODBC driver  creates an ODBC database session by opening a connection to a named database server, following a standard logon protocol of the server, and issuing a series of ODBC function calls to set application specific attributes on the database connection. Next, at step  in , the client application submits a query to search the customer table () for records of customers with a last name of \u201cSmith\u201d.","The driver manager  intercepts the application request (step  in ). It performs a one-pass parse to determine the request type (step  in FIG. ). If the application request is a SQL statement that generates a result set (as is the case in this example), the driver manager  determines the structure of the result set by modifying the query to acquire the result set \u201ctable description metadata\u201d (step  in ). The result set includes such items as the names of attributes, their types, and the order in which they appear in each returned tuple. Since the driver manager  need only know the result format in order to create a persistent SQL table, the driver manager gathers the metadata. The metadata describes the number of columns in the result set, the data types of those columns, their names, precision, nullability, and so on.","To minimize expensive network traffic between the server and client, the table description metadata is acquired with a single round trip to the server with minimum data transfer and minimum server impact. One way to modify the query is for the driver manager  to append the clause \u201cWHERE 0=1\u201d to the original SQL statement, essentially rewriting the statement. At step  in , the driver manager  sends the modified query to the server via the native ODBC driver . The server determines the table description metadata for the result set and ODBC delivers the result set metadata as a prefix to delivery of the result data (step  in ). By appending the clause \u201cWHERE 0=1\u201d, it is guaranteed that the query will not be executed and that no result data will actually be returned, thereby minimizing both server load and message size. Only query compilation is performed on the server, and only the metadata is returned in the reply message.","At step  in , once the server returns a response indicating the rewritten SQL statement has successfully executed, the driver manager  reads the table description metadata and reformats it into a CREATE TABLE statement. The driver manager  sends the CREATE TABLE statement to the database server  (step  in ). In response, the database server  creates an empty persistent table () in stable database  to hold an eventual result set obtained from the \u201cSmith\u201d query (step  in ).","At step  in , the driver manager  sends a request to the server  to execute a procedure containing the original SQL statement submitted by the client database application  in step . The server  executes the query to generate a result set (step  in ). In our example, the server executes original SQL statement query on the customer table () for all records having a customer named \u201cSmith\u201d and generates a result set . The result set  is then stored in the persistent result set table () (step ). Once the server has returned a response indicating the procedure was successfully executed, the result set is stable and will persist across server failures.","What is materialized depends on both the original SQL statement and on how the application requests the results set from the server. With ODBC, the \u201chow\u201d is determined by the statement options specified prior to executing a SELECT. When ODBC default values are used as the options, for example, the database server  sends the result set in the most efficient way possible. The server assumes that the application will fetch all the rows from the result set promptly. Therefore, the database server sends all rows from the result set and the client application buffers any rows that are not used immediately but may be needed later. This is referred to as a \u201cdefault result set\u201d.","To materialize a default result set, the driver manager creates the following stored procedure, using ANSI-standard SQL:\n\n","The advantage of using a stored procedure is that all data is moved locally at the server, not sent first to the client. It involves a single round-trip message from client to server, rather than having data moving across the network. Moreover, the action is itself an atomic SQL statement.","At step  in , the driver manager  issues a SQL statement (e.g., SELECT * FROM T) to open the result set table (). The driver manager  then returns control, to the database application program  for normal processing (step ).","As the database application program  makes requests on the result table (), the driver manager tracks the current location in the persistent result set () by logging location information in the stable log  in client cache . Should a failure occur, subsequent database recovery ensures the result set exists after the failure. The driver manager  resumes access to the result set at the remembered location of the last access before the database system failure.","Use of Persistent Cursors to Return Results","The above example used default result sets as a way to return results. It is noted that the SQL language permits results to be returned in ways other than by default result sets. An application can control delivery of results at a much finer granularity by exploiting cursors. Two cursor forms are keyset cursors and dynamic cursors.","An application's SQL query may return no rows, a few rows, or millions of rows. Since the user rarely wants to see millions of rows, fetching and buffering millions of rows is usually a waste of time and resources. Server cursors, such as keyset and dynamic cursors, allow an application to fetch results a block of rows at a time from an arbitrarily large result set. The application is permitted to \u201cnavigate\u201d through the result set via a server cursor. A server cursor allows the application to fetch any other block of rows, including the next n rows, the previous n rows, or n rows starting at a certain row number. The server fills each block fetch request only as needed. Some server cursors also allow an application to update or delete fetched rows. If the row data changes between the time the SQL cursor definition statement is executed and the time the row is fetched by the application, the updated row data is returned. These features of server cursors present unique challenges for the driver manager.","A keyset cursor captures the set of rows that satisfy a query at the time the cursor is opened and it permits those rows to be accessed and updated. If a keyset cursor is requested, the driver manager  materializes only keys of the result set rows in the persistent database table . When the application attempts to fetch a row from the result set, the driver manager reads the record key from the result row and SELECTs the record from the database server using this key. If the row data has been changed or the record itself has been deleted, the updated row data is returned. In this manner, the architecture transparently supports keyset cursor, but now the cursor persists across failures.","A dynamic cursor specifies a logical predicate (the WHERE clause) that defines the rows of interest. The set of rows fetched changes dynamically as rows are inserted and deleted. If a dynamic cursor is requested, the driver manager  materializes the keys of the result set rows in a persistent database table, exactly as it did for keyset cursors. Now, however, when the next row is fetched, it is not necessarily the row with the next key as an insertion may have occurred. Thus, a fetch causes the driver manager  to use the last record key seen by the application and the next record key from the table to SELECT a range of rows from the database server. If records have been inserted into this range, the driver manager fetches them and presents the appropriate row to the application. Again, the architecture transparently supports dynamic cursors, but now the cursors persist across failures.","Server and Session Crash Recovery",{"@attributes":{"id":"p-0096","num":"0114"},"figref":"FIG. 7","b":["30","38"]},"At step , the driver manager  detects a failure. Database server failures are detected by (i) intercepting communications errors raised by the drivers  or (ii) timing out application requests. Once a potential problem is detected, the driver manager  re-contacts the server using a private database connection to \u201cping\u201d the server and periodically attempts to reconnect to the database (step ). If after a period of time the driver manager is unable to connect to the server (i.e., the \u201cno\u201d branch from step ), it assumes the database system crashed and passes the communication error on to the application (step ).","If reconnection is successful (i.e., the \u201cyes\u201d branch from step ), the driver manager  determines if the database system actually crashed or whether there is simply a communication failure or delay (step ). This step attempts to discover whether the database session still exists or has been erased by a crash. There is no explicit test for this. Thus, the driver manager may test, for example, whether a special temporary table of the session exists as a proxy for whether the session still exists. Temporary tables exist only within a session and are deleted when a session terminates for any reason.","Assuming the proxy test reveals a server crash (e.g., the temporary table does not exist), the second phase of the process is to transparently reconnect the client application to the database server  and re-associate saved information with these new database connections. At step , the driver manager  reinstalls each client connection to the database system using the original connection request and login information. The manager  then issues a series of calls to the database server in order to reinstall application specified ODBC connection options (step ). Once complete, the driver manager  binds these new connections to the virtual database session (step ).","In the third phase, the driver manager  reinstalls SQL state. At step , the manager  verifies that all application state materialized in tables on the persistent database  was recovered by the database recovery mechanisms. It then identifies the application's last completed request for each database connection using the log  in the stable cache  (step ). The manager  asks the server to re-send the result set from the persistent result set table  (if necessary) (step ). Once this step is complete, the driver manager  resumes normal processing of application requests (step ). This creation of the new database session is masked from the application, giving the illusion of a single persistent database session.","No special treatment is required to handle a failure that occurs during session recovery. Since the database session recovery phase consists of reestablishing a connection to the recovered database server and executing idempotent operations to reinstall session state, the driver manager  can safely execute the recovery phase again to recover from failure.","Any active transactions on the database server are aborted during failure and are restarted by the client application. Transaction failure is a normal event that most applications are already capable of handling. The driver manager  aborts transactions interrupted by a system failure and permits the application to proceed as it would for other forms of transaction aborts.","When the database server commits a transaction and then fails before it can send a response to the client, that message will be lost to the client. The driver manager  prevents lost messages by including the transaction reply buffers in its persistent session context. The database server writes both the commit record and reply buffer to a persistent database table before committing the transaction and replying to the client. On database recovery, the driver manager  will deliver the reply buffer to the client, thus avoiding the lost message.","Although the invention has been described in language specific to structural features and\/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 6","i":["a ","b "]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
