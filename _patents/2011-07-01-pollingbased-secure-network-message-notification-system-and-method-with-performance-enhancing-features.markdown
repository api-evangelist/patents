---
title: Polling-based secure network message notification system and method with performance enhancing features
abstract: A method for the dissemination of an alert message to a plurality of personal computers using a network communications protocol from a server is disclosed that includes a first step wherein the client contacts the central server and requests the value of said alert ID number in said memory, a second step wherein said server transmits said value to said client, a third step wherein said client compares a stored value at the client with the value of the transmitted alert ID number, and if said transmitted value exceeds said stored value, a fourth step wherein said client transmits a second message to said server and requests for the server to transmit all unread alert messages in a GetUnreadAlerts SOAP request from said server that are specific to said client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09172765&OS=09172765&RS=09172765
owner: Desktop ALert, Inc.
number: 09172765
owner_city: Chatham
owner_country: US
publication_date: 20110701
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Patent Application No. 61\/398,796 filed Jul. 1, 2010.","The present invention is directed to an improved manner in which to provide alerts or messages to a plurality of clients or workstations from a central server. The improvements are directed to manners in which to improve the performance of legacy systems that use a conventional polling architecture. For example, a legacy system for which the present system provides improvements has been developed by Desktop Alert, Inc. of Washington, D.C. which uses an IP-Based alert technology that can be integrated with enterprise-class environments. The Desktop Alert system shares communications and commands using standardized protocols such as XML and HTML. It is a multi-media, GIS enabled mass notification platform that is used to deliver messages and media including live surveillance video, images, audio files, giant voice, interactive Flash files and other applications to desktops as well as other devices such as telephones, cell phones, e-mail and mobile devices. The Desktop Alert system allows transmission of such messages to a plurality of clients or communication devices and generally has the following features and capabilities:\n\n","Alert notification systems are particularly useful in connection with military installations, schools, business and government agencies and other groups that operate on networks and allow the operator or central command and control to timely provide information to a plurality of users or subscribers including critical emergency information or other news alerts. The communication can be directed to predetermined subsets of users that subscribe to the alert notification system.","Desktop Alert's Enterprise Level Mass Notification Platform provides a unified messaging platform for its message system and includes a feature rich web-based interface for instant mass alert publication to targeted personnel and devices. The alert systems may be a premise-based solution that is hosted by the purchaser of the system behind a firewall. In an alternative embodiment, the system can be provided as a software as a service (SAAS) over the web. Desktop Alert's commercially available system can integrate with directory services such as Active Directory, enterprise applications and appliances via web services. The system can be integrated with existing intelligence and business rules of the client. The architectural topology and sharing technology design is such that disparate systems across multiple networks can easily engage and interact with the Desktop Alert Mass Notification System. This is accomplished through the usage of Web Services Description Language (WSDL).","The present invention is an improvement to message systems wherein a plurality of clients are in communication with a server through a network that use a polling model, in contrast with systems that use a push model. The basic concept behind polling models is that the client periodically provides queries to the host or server requesting updated messaging information. Polling models are commonly used for checking email and for other applications that require the timely updating of information such as stock prices and weather.","As depicted in  electronic communication on a web service network often includes a client computer system (hereafter referred to as a \u201cclient\u201d) requesting access to a network service (e.g., web services) at a server computer system (hereinafter referred to as a \u201cserver,\u201d \u201cservice,\u201d or \u201cweb service\u201d). Accordingly, the client sends a request to the service for particular access to its system resources over a network, wherein the service replies with a response message providing the desired information. Of course, other messaging patterns between client and service may be available and include simple singleton messages as well as more sophisticated multi-message exchanges like, e.g., notifications, solicit-response, pub-sub patterns, polling, kick-push, queuing, and others. In addition, there may be other procedures needed for accessing the service resources, such as authentication and validation mechanisms.","The system of the invention therefore includes a client and a server that communicate over a network such as that illustrated in . The server is designed to provide a digital notification in the form of instant messages to clients which are users or groups of users having at least one communication device such as a desktop computer, a wireless computer, a smart phone, or other wireless device having an internet connection. The server, which may be operated over the interne or behind a firewall, can store information relating to the various users that poll the server. The server is also associated with a database which may be as SQL\u2122, MySQL\u2122, Oracle\u2122 or another industry standard database. The database may also include additional user contact data for groups of users and user selected priority information relating to additional manners in which the user may be contacted.","An administrator at the sever location may enter new alert messages by data entry through an administrator interface and thereby make them available to the clients at the server. The alert messages will include data reflecting those clients or groups of clients to which the messages are intended to be communicated. In addition to making the message available to the clients that poll the server for alerts, the server may also communicate the alert message though alternative techniques.","The server may communicate with the client using a local area network, a wide area network, a virtual private network, an asynchronous transfer mode network, a synchronous optical network, a wireless network, a WIFI network, a WiMax network or combinations thereof. The administrator that enters the alert message into the server may be a person, a computer, another digital notification and response system, an analog emergency notification system, a mass notification system, an application programming interface, and combinations thereof. The alert message is a prewritten or prerecorded message stored in the dynamic information database for subsequent use by the administrator","In an exemplary system using a polling model, in response to a request for message alerts, an alert is transmitted to the client in instant message format that opens a window on the display panel at the client station. As for scalability, the load placed on a server with each client that is polling every few seconds needs to be taken into consideration. Depending on an application's needs, the frequency of requests could be reduced, or even made dynamic so it polls less frequently if it receives fewer messages and increases the frequency if larger sets of messages are received. Since HTTP GET is used for the method call, the size of the data sent to the method is also restricted. The response to a remote method call has no explicit restrictions on size, but if large amounts of data per request are being passed to or from the server, this messaging architecture may be problematic. While polling architectures have been widely adopted, as the scaling increases, the performance of the system may be adversely affected.","The following data may be tracked and determined in existing polling based systems: Requests\/sec=Number of clients*polling frequency. For example: 83 requests\/sec for 5000 clients polling once per minute ( 1\/60). Conversely, the polling frequency can be set by knowing the number of expected clients and the available performance (potential requests\/second) of the selected hardware.","One manner to improve the performance of a network is to reduce the database usage. A database can only achieve so many read\/writes in a given time period. By reducing the number of read\/writes for any given operation, the potential to perform more of those operations in a given unit of time or to perform additional other operations is increased. In other words, most applications are I\/O bound. Because the assumed database use often is not the actual database use, the database use should be repeatedly measured to determine if theorized results are actualized. Another further manner to achieve better performance disclosed herein is achieved by caching data closer to the end point (user).","In an example, a test client that could simulate n user connections was created. More specifically, a set of clients each calling the Desktop Alert web service GetUnreadAlerts call was established. The GetUnreadAlerts is the call initiated by the client to the server and is communicated to the server at the polling frequency. The GetUnreadAlerts is a SOAP call which is discussed further below. Once the test client is put into operation, the code behind the critical GetUnreadAlerts call and the resulting database calls or usage in the conventional polling system, such as the Desktop Alert system may be evaluated.","In the Desktop Alert system, each call to GetUnreadAlerts results in:\n\n","The applicant has found that the \u201cdb.GetUser\u201d and \u201cdb.GetAccount\u201d calls could be cached in the web server process's memory (for a period of time), which avoids unnecessary repeated calls to the database. If no new alerts are entered into the system between same-client GetUnreadAlert calls, nothing has to be done. As a consequence, the logic in GetUnreadAlerts call may be \u201cshort-circuited\u201d and improved. To take advantage of this improved call structure, first a database caching class was added to the server as further described below and then implemented caching both the \u201cdb.GetUser\u201d and \u201cdb.GetAccount\u201d calls. It should be understood that cached database objects are subject to a specific timeout value.","Next, a global table (in-memory) was added that maps each requesting userId to the last system-wide alertId at the time of the last GetUnreadAlerts call. If the system-wide alertId changes (measured in increments), then and only then, does the db.GetUnreadUserAlerts database call get made for that user. This in effect provides a \u201cshort-circuit\u201d or \u201cshort-cut\u201d test for each poll request. As the client polls the server it requests the value of the alertID changes. The client then compares the value of the alertID change with the value stored in its memory. If the value is greater than zero, or if the alertID value has increased since the client last polled the server, the client then requests the unread alerts that are specific to the user. In summary, instead of the client asking if the server has any new alerts for the particular client, the client asks if there are any new alerts in the entire system since the client last called the server. If there exists a new alert message in the system, the server will send a message to the client that there are new alerts and the client will then transmit the GetUnreadAlerts as was performed in the prior art system.","Since the number of poll requests from the clients vastly outnumbers the number of new alerts that are posted in the server in any given day, this technique saves considerable processing time.","Test Configuration","Tests were conducted on two machines to compare the new feature to an existing system. A first machine or system, \u201cMachine 1,\u201d is established to run the Desktop Alert web application\/service+SQL Server. A second machine or system, \u201cMachine 2\u201d, is established to run the improved test client.","The test client is a single application that can run n threads against a target server. Each thread does essentially the same task: repeated calls to the Desktop Alert web service GetUnreadAlerts call. The database was configured with 10,000 users (username user, user, . . . usern), all with the same password. Each test thread randomly chooses among the available users for each call.","The test client fully engaged the server. At 500 threads the server, with back to back calls, reached its maximum performance. For instance, if 700 threads were applied the server would slow down due to request saturation.","Shown below in Table 1 is a summary of the results. The results provide data for the following parameters:","Requests\/Second: The number of requests per second of a roundtrip request\/response to the web service. The higher the better (we are trying to achieve maximum call throughput).","Database Transactions\/Second: The database activity in calls per second. The lower the better (we are trying to limit the use of the database).","Limit (row 3) established the limit using Machine 1 and Machine 2. The Limit test (aka HelloWorld Web Service test) makes a simple web service request to the server and receives the string response \u201cHello World.\u201d At 1,260 requests\/second, this essentially establishes the upper limit (on this hardware) of the potential throughput.","Existing GetUnreadAlerts: A maximum of 215 calls per second were recorded, resulting in an average of 756 database calls per second.","Improved GetUnreadAlerts: A maximum of 709 requests per second were recorded, resulting in an average of 3 database calls per second. This is an approximate 330% improvement in request throughput and results in a significant decrease in database use.",{"@attributes":{"id":"p-0042","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Summary of Improved performance"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Requests\/","Database Transactions\/Second"]},{"entry":["Process","Second","Required"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Existing GetUnreadAlerts","215","756"]},{"entry":["Improved GetUnreadAlerts","709","3"]},{"entry":["Limit","1260","n\/a"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"As illustrated in , screen display  depicts a the test client throughput is running  threads that repeatedly call the Desktop Alert web service GetUnreadAlerts is evaluated. The data in  reflects approximately 215 requests\/second, resulting in 258,665 calls in a 20 minute test period",{"@attributes":{"id":"p-0044","num":"0078"},"figref":"FIG. 3","b":"301"},"System Performance After Improvements Implemented","Now referring to , the screen depiction  of a screen of a test client, running  threads that repeatedly call the Desktop Alert web service was analyzed after the protocols according to the invention were implemented and the following data was collected relating to the GetUnreadAlerts. The data depicted in  reflects  requests\/second, resulting in 852,452 calls in a 20 minute test period.",{"@attributes":{"id":"p-0046","num":"0080"},"figref":["FIG. 5","FIG. 6"],"b":"501"},"The following section describes how the database is used for the critical GetUnreadAlerts web services calls. As the system starts, all clients tax the database at the extreme, as no database calls are cached in-memory (this use approximates the existing prior art model), but as database calls are cached, database use drops sharply. These cached results eventually expire (using a set timeout), and as they do, the database will be called to refresh the results. For the db.GetUser call a period of 10 minutes+\u22121 minute for a cache timeout was selected.","In addition, when a new alert is entered by a user, a flurry of database activity occurs, resulting in 1 db.GetUnreadUserAlerts call per user. This is because the global alertId is incremented, indicating that each client must go to the database to check if new alerts are available. After this check no calls to db.GetUnreadUserAlerts occur until another new alert is entered.","Summary of Results of System Using Enhanced Initial Call Logic","As demonstrated by Table 2, the improvements to the system and method greatly improve the polling performance of the previously available Desktop Alert notification system. It is estimated that the present system results in 300% improvement in comparison with the prior art system while at the same time vastly reducing the database use.",{"@attributes":{"id":"p-0050","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Requests\/","Database Transactions\/Second"]},{"entry":["Process","Second","Required"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Existing GetUnreadAlerts","215","756"]},{"entry":["Improved GetUnreadAlerts","709","3"]},{"entry":["Limit","1260","n\/a"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"The improvements disclosed above result in significant improvements to the performance of the system. As the example demonstrates, by altering the logic so that the system will seek to obtain new alerts only when the system has created new alerts, the polling frequency may be increased from 215 requests\/second to 709 requests\/second while dramatically reducing database usage. This improvement allows a installation to drop the polling interval by a factor of 3 without the requirement of any hardware changes. In other words, if the polling interval of a system is at 60 seconds, the present improvement allows the polling interval to be set at 20 seconds without effecting performance. Even if one were to a follow a very conservative approach the present improvement easily allows one to double the polling interval. Consequently, the speed in which messages are communicated to the users is increased.","Furthermore, since the database use model has changed dramatically, the database is no longer the limiting factor\u2014it's the potential throughput of the GetUnreadAlerts web services calls. A given box can only manage so many calls a second\u2014dispatching the call through the web server on the Windows platform to the web service, authenticating the request, and running the code behind GetUnreadAlerts. As discussed above, the maximum achievable call throughput in the test box was 1,260 requests\/second\u2014this limit cannot be improved on the existing hardware no matter what changes are made. But this means that more than one front-end web server coupled with a back-end database can dramatically improve overall the performance (or polling interval).","It follows that if 709 requests\/second can be achieved on one box, 2 boxes (with our new found database headroom) can manage 2\u00d7709 requests\/second, and so on. The practical reality is this: when a box is stressed with a high-frequency polling of GetUnreadAlerts, it becomes rather unusable for other tasks\u2014namely web application calls of the Desktop Alert web application.","A first contemplated system configuration includes 1 database box, n front-end web service only boxes, 1 web application box. This system includes a single box dedicated to web-service, web-application, and database.","A second contemplated system depicts n general purpose (web-service+web-application) front-end boxes and 1 dedicated database box. This system requires either WLBS (windows load-balancing service) or a round-robin DNS.","A third example as contemplates a single web-application front-end, n web-service front-ends, and 1 dedicated database box.","Reduction of the Communications Payload","As discussed above, altering the logic of the polling model is a first manner in which to increase the performance of a system using an alert notification system by reducing the demands on the database. While the contemplated deployments may allow a dramatic increase the polling frequency and scale (number of clients) of the system, other problems become evident: the amount of network data associated with the GetUnreadAlert SOAP calls starts to rise (and gets noticed). Ultimately, the polling frequency cannot be decreased while at the same time going for scale because the two concepts are opposed.","SOAP is relatively heavy-weight protocol with an unfortunate amount of overhead. In general, SOAP is an XML-based messaging protocol. It defines a set of rules for structuring messages that can be used for simple one-way messaging but is particularly useful for performing RPC-style (Remote Procedure Call or Remote) request-response dialogues. It is not tied to any particular transport protocol nor any particular operating system or programming language so theoretically the clients and servers in these dialogues can be running on any platform and written in any language as long as they can formulate and understand SOAP messages. As such SOAP can be used as a building block for developing distributed applications that exploit functionality published as services over an intranet or the Internet. SOAP messages must be parsed, interpreted and checked for compliance with security protocols. The overhead associated with an \u201cempty\u201d call (no returned new alerts for GetUnreadAlerts) is larger than the payload by far (and this is the most frequent call). Increasing the polling interval only increases the number of these calls, thereby flooding the network.  shows the request side of the GetUnreadAlerts call, this is 1,672 bytes in length, the \u201cempty\u201d return data is larger (though not appreciably). The optimization, discussed herein, can limit this from 1,672\u00d72 per request to about 20\u00d72 per request. Referring now to , a SOAP message is schematically represented and includes header , operation , Queiry Idetifier , Query expression , and other processing information . The Body  of the SOAP message includes the Wrapper construct , subset of OML content  and other payload data .","An additional manner in which to improve performance to a polling based system such as the Desktop Alert system is to change the client-server protocol to use a format other than SOAP for the \u201ctriggering\u201d GetUnreadAlerts call. In this alternative model, GetUnreadAlerts call remains intact but is not used for polling, rather a new polling call IsNewAlerts is added. This call passes the userId in a tight HTTP packet (not SOAP) to the web-server, approximately 20 bytes of payload. The result of this call is simply a Boolean value: true or false. If true is returned the client makes the formal (and existing) GetUnreadAlerts calls. IsNewAlerts does not require authentication and therefore can bypass the SOAP security layer.  depicts the client request data for GetUnreadAlerts from the server using the SOAP protocol. In contrast referring now to  is a screen shot  of a display depicting the improved Req.aspx call using the HTTP GET protocol and response messages is depicted which has a smaller communications and data payload.","Accordingly, a further aspect of the invention is therefore directed to a manner in which to reduce the necessary length of the communication from the client to the servers which results in increased efficiency of the system and a decrease on the load placed on the servers and database thereby improving performance and allowing for an increased number of users or clients that may be maintained by a particular server. While the message is reduced, the security of the system remains intact.","In an embodiment the message from the client to the server is a SOAP call, which refers to as Simple Object Access Protocol, which refers to a protocol for exchanging structured information in the implementation of web services in computer networks. The communication relies on Extensible Markup Language (XML) as its message format, and usually relies on other application layer protocols such as Remote Procedure Call (RPC) and HTTP for message negotiation and transmission. SOAP can form the foundation layer of a web services protocol stack, providing a basic messaging framework upon which web services can be built.","The key features of RPC are a request-reply protocol, and can exhibit the \u201cping-pong\u201d behavior typical of such protocols. This exchange is not fundamental to RPC's design, since multiple requests can be outstanding, and the replys can be received in any order. However, some programs will issue a single RPC request, and then block awaiting a reply. RPC operates over UDP or TCP. RPC\/UDP is a connection-less, stateless protocol. RPC\/TCP is slower, but provides a reliable, stateful connection. RPC encodes its data using the eXternal Data Representation (XDR) protocol, documented in RFC 1832 standard which standardizes the format of integers, floating point numbers, and strings, and thereby permitting different types of computers to enhance information seamlessly. RPC provides support for authenticating the calling program on one machine to the target subroutine on the other. This authentication can operate in several different modes. During operations, authentication usually takes the form of relaying UNIX user and group IDs to the file server for permission checking.","A SOAP message can be sent to a web service enabled web site or server with the parameters needed for a data search. The site then can return an XML-formatted message with the resulting data. Because the data is returned in a standardized machine-parseable format, it can be integrated directly into a third-party site. The SOAP architecture consists of several layers of specifications for message format, message exchange patterns (MEP), underlying transport protocol bindings, message processing models, and protocol extensibility. SOAP is the successor of XML-RPC, though it borrows its transport and interaction neutrality and the envelope\/header\/body from elsewhere.","As a SOAP call with envelope security, the request and response are \u201cfat\u201d or large in terms of the number of bytes transmitted. As discussed above, in the prior art Desktop Alert system a typical request from the client averages 1,670 bytes of SOAP payload. This payload does not include the HTTP, TCP, or IP header which amounts to another 400 bytes (approximately). The \u201cempty\u201d response from the server, or a response without any substantive content, averages 1,450 bytes of SOAP payload, with 350 bytes of HTTP\/TCP header (approximately).",{"@attributes":{"id":"p-0065","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Call","SOAP Payload","HTTP + TCP\/IP header","Total"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GetUnreadAlerts","1,670","400","2,070"]},{"entry":"Request"},{"entry":["GetUnreadAlerts","1,450","350","1,800"]},{"entry":["Response",{}]},{"entry":[{},{},{},"3,870"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"As demonstrated in Table 3 above, a request\/response pair that delivers no alerts has a network cost of 3,870 bytes on average. Worse, each side (the request and the response) falls over the Ethernet MTU threshold of 1,500 bytes. Consequently the request, as well as the response, must be transmitted in 2 packets each. Because two packets are required, the transmission introduces the potential for latency\/retransmits which is not preferred. In addition, this payload is periodically sent by each client in the subscription network. As an example, if there are 5,000 connected clients in a 24 hour period, polling once per minute, the resulting network traffic is 27.8 GB per day. If the polling frequency is increased, the daily network traffic is commensurately increased.","Additionally, the SOAP processing of large XML packets is processor intensive. Both the initial parsing by XMLDocument (the core XML component on Windows) and then the SOAP security processing is a heavy lift for the server.","The Improved Communications Protocol","In response to these issues, the present invention includes a new core polling call that avoids SOAP. Rather, the transmission from the client is a simple HTTP GET request (e.g., http:\/\/server.domain.com\/Req.aspx?OP=AT&UT=ddd451af) and returns a HTTP response with a simple XML result. According to the improved system, Req.aspx replaces GetUnreadAlerts as the polling call, but GetUnreadAlerts remains intact. Importantly, the system preserves the GetUnreadAlerts protocol and it can be called as before, ensuring 100% backwards compatibility (existing clients can connect unchanged).","The improved protocol is simple, employs a lighter payload, and is secure. According to the new system, the client starts with the GetUnreadAlerts SOAP request as has been used in prior art systems. On a protocol 2 enhanced Desktop Alert server, two pieces of additional information are returned from the server in the GetUnreadAlerts call: (1) a protocol number and (2) a temporary user token.","The protocol number, set to a value of 2, specifies the protocols available between client and server. The value of 2 indicates that protocol level 2 is available and refers to the method disclosed herein. An existing client of course will not test this value and therefore only know to poll through GetUnreadAlerts (which continues to work as before). A new client, seeing this value, can switch to the new protocol.","The temporary token is a value, temporary in nature, which is used in subsequent Req.aspx calls. The token is established on the server through the initial GetUnreadAlerts call, which is an authenticated SOAP call. The temporary token can become invalid, in which case a result is returned through Req.aspx that indicates the client must call GetUnreadAlerts to get a new token. The purpose of the temporary token is discussed below.","Next, the client calls Req.aspx with two parameters: OP and UT. Req.aspx is meant to be a general purpose call and may be extended in the future, but for our purposes OP is set to AT (meaning \u201calert test\u201d). UT is the temporary user token supplied by the GetUnreadAlerts call. The client will receive a small XML result from Req.aspx. For OP=AT, the possible results are set forth in Table 4 as follows:",{"@attributes":{"id":"p-0073","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Result","Meaning","Action"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<r><a>OK:0<\/a><\/r>","Call OK, 0 new","Schedule another call to"]},{"entry":[{},"alerts","Req.aspx at next poll interval"]},{"entry":["<r><a>OK:n<\/a><\/r>","Call OK, n new","Immediately call"]},{"entry":["Where n is a value > 0","alerts","GetUnreadAlerts to gather"]},{"entry":[{},{},"alerts for display; Schedule"]},{"entry":[{},{},"another call to Req.aspx at"]},{"entry":[{},{},"next poll interval"]},{"entry":["<r><a>ERR:1<\/a><\/r>","Call ERROR,","Immediately call"]},{"entry":[{},"temporary","GetUnreadAlerts to get a"]},{"entry":[{},"token invalid","new token (gather any alerts"]},{"entry":[{},{},"for display); Schedule another"]},{"entry":[{},{},"call to Req.aspx at next poll"]},{"entry":[{},{},"interval with new token"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"All calls to GetUnreadAlerts can provide a new temporary token and available alerts, the client should always assume this.","Now referring to , the improved Req.aspx call is light-weight in that it only contains approximately 90 bytes (as shown below at the first two lines beginning with GET\/web\/reg.aspx . . . ). The response is approximately 185 bytes (as shown in below at the lines beginning with \u201cHTTP\/1\/1 200 OK . . . \u201d).","When compared to the original method, 27.8 GB of network traffic per day, this new protocol is reduced to about 2 GB a day.","The Temporary Token Security Method","A temporary token value is generated and returned on the call to GetUnreadAlerts which serves as a security device. The caller must assume that the token value can change on every GetUnreadAlerts call, and therefore must acquire the most recent token on each call to GetUnreadAlerts. If the token becomes invalid prior to a GetUnreadAlerts call, where the client is normally polling via Req.aspx, Req.aspx will return a specific error (ERR:1) that indicates that the token is invalid. In this case, the client must simply call GetUnreadAlerts using the protocol according to the prior art SOAP system. The GetUnreadAlerts is an authenticated call and therefore is used to obtain the temporary security token.","In an embodiment, the token is generated on an initial call to GetUnreadAlerts and remains intact until the server is restarted (the value is kept in memory) or the user is pushed to another front-end server, in the case of a server farm. It is contemplated that the token can be invalidated more frequently, or on some other predetermined or random interval. However, if the token is invalidated, the client must access the server using the GetUnreadAlerts protocol to gather a new token. If the token is frequently altered, the server and system will require more processing as an increased amount of data is exchanged through the network. Generating a new token on each GetUnreadAlerts call is more practical, taking advantage of the call itself and thereby eliminating unnecessary calls.","The timeout phase must be carefully considered. The db.GetUser call does more than retrieve the user record it also updates the \u2018LastActivity\u2019 column for the online users function. So now the window of precision is not the set polling interval but rather 10 minutes or the set polling interval, whichever is longer. Also, as db.GetUser is now cached in memory (at least for the client GetUnreadAlerts call), a change to the user record will not be seen by the client for a maximum of 10 minutes. For example, if the user's password is changed in the opt-in model, a client can continue to access the system for a maximum of 10 minutes.","The db.GetUser call is not cached in general, but rather a db.GetUser_Cached call is provided (and right now used exclusively in the GetUnreadAlerts web services call) that attempts to use the cache (or failing that, retrieve from the database).","Caching adds some \u201cuncertainty\u201d to data access because the cached version might not be identical to the database version. However, considering its use, implications and advantages in the present system the technique provides an effective solution.","Additional Reports","Below are some additional reports that further characterize the database use in the before and after scenarios. Table 5 below is expanded to include database reads and writes. Each read or write is an 8K page, the smallest read\/write unit for SQL Server. The number of rows in an 8K page varies based on the table definition (number of columns\/size of those columns). The Read\/writes are 8K blocks, the smallest \u201cunit\u201d SQL Server reads\/writes.",{"@attributes":{"id":"p-0083","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Database",{},{}]},{"entry":[{},{},"Transactions\/"]},{"entry":[{},"Requests\/","Second","Database","Database"]},{"entry":["Process","Second","Required","Reads","Writes"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Existing","215","756","9.047,509","1,752"]},{"entry":"GetUnreadAlerts"},{"entry":["Improved","709","3","76,675","7"]},{"entry":"GetUnreadAlerts"},{"entry":["Limit","1260","n\/a","n\/a","n\/a"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0084","num":"0118"},"figref":["FIG. 9","FIG. 10","FIG. 11","FIG. 12","FIG. 13"],"b":["901","1010","1101","1103","1105"]},"While there has been shown and described what is considered to be preferred embodiments of the invention, it will, of course, be understood that various modifications and changes in form or detail could readily be made without departing from the spirit of the invention. It is therefore intended that the invention be not limited to the exact forms described and illustrated, but should be constructed to cover all modifications that may fall within the scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0037"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0038"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0039"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0040"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0041"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0042"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0043"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0044"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0045"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0046"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0047"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0048"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0049"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0019","num":"0050"},"figref":"FIG. 14"}]},"DETDESC":[{},{}],"heading":"DETAILED DESCRIPTION OF THE INVENTION"}
