---
title: CORBA embedded inter-orb protocol (EIOP)
abstract: A non-transient computer-readable storage medium that stores computer program code is provided. When this code is loaded into a computer system and executed thereon, it causes the computer to compile an interface definition language (IDL) configured to provide a custom inter-orb protocol (custom IOP), configure a message header for a message in accordance with to a specification in the IDL for at least a custom-IOP message header, and define a custom-IOP message header to replace the corresponding Common Object Resource Broker Architecture (CORBA) General Inter-Orb (GIOP) message header, wherein the custom-IOP message header requires fewer bits overall than the corresponding GIOP message header by changing or eliminating at least a portion of the fields in the corresponding GIOP message header.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08813092&OS=08813092&RS=08813092
owner: Raytheon Company
number: 08813092
owner_city: Waltham
owner_country: US
publication_date: 20111012
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","COPYRIGHT NOTICE","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Embodiments of the invention generally relate to software communication architectures. More particularly, the invention relates to systems and methods that provide an optimized CORBA messaging protocol between distributed clients and servers.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The Common Object Request Broker Architecture (CORBA) middleware platform has been a leading middleware platform in recent years. As is known in the art, CORBA is a standard defined by the Object Management Group (OMG) that enables software components written in multiple computer languages and running on multiple computers to work together as a single application or set of services. CORBA uses an interface definition language (IDL) to specify interfaces that objects will present to the outside world, and specifies a mapping from the IDL to a specific implementation language. CORBA uses an Object Request Broker (ORB) to send requests from objects executing on one system to objects executing on another system. The ORB allows objects to interact in a heterogeneous, distributed environment, independent of the computer platforms on which the various objects reside and the languages used to implement them. CORBA is specified and further explained in the CORBA Specification, version 3.1 (January 2008), including Part 1 (CORBA Interface) and Part 2 (Interoperability), available from the Object Management Group (OMG) at 109 Highland Ave, Needham, Mass. 02494. The entire CORBA Specification, including at least Parts 1 and 2, is hereby incorporated by reference in its entirety.","CORBA communication typically occurs over an Ethernet or other network, between a Client and Server.  is an illustrative prior art block diagram  showing client  to server  communication, in accordance with CORBA, in an exemplary environment.  illustrates what happens when a client application  invokes an operation on an object\/servant  in a server process . To implement an interface, CORBA IDL is compiled into the source code language with which the client  or server  is implemented. On the client side, this code is called a stub. On the server-side, this IDL code is called a skeleton. Typically, client-side application code  invokes a local proxy object  (e.g., via a proxy class generated by an IDL compiler). The proxy  gets information about the request (e.g., in and inout parameters, operation name) into a binary buffer, which is then passed into the ORB A library. The ORB A library sends a request message across the network to the server process . The ORB A waits for a reply message from the server process . The ORB A returns the reply buffer back to the proxy object , which unmarshals inout and out parameters and the return value (or a raised exception), and returns these to the client application code .","At the server  side, the ORB B runs a thread in an event loop that waits for incoming requests. When the request arrives from the client  the ORB B reads the request's binary buffer and passes this to some code that unmarshals the parameters and dispatches the request to the target servant . The code that performs the unmarshalling and dispatching is spread over two components, the Portable Object Adapter (POA) (shown in ) and the skeleton code that is generated by the IDL compiler. When the operation in the servant  returns, the skeleton code marshals the inout and out parameters (or a raised exception) into a binary buffer and this is returned via the POA  to the ORB B, which transmits the reply message across the network to the client process .","The main protocol for ORB communication as shown in  is the standardized General Inter-ORB Protocol (GIOP), which has been widely deployed for transport in the TCP\/IP environment. GIOP also is described further in the aforementioned CORBA Specification, and as of this writing is a version 1.3. GIOP over TCP\/IP is known as Internet Inter-ORB Protocol (IIOP). GIOP is a client-server protocol and defines the messages and format that are passed over the ORB between the client and the server object. The data placed in the GIOP follows CORBA Common Data Representation (CDR) syntax for placing and copying the data into an octet stream. CORBA is mainly used on General Purpose Processors (GPPs) using TCP\/IP and\/or OS Inter-Processor Communications (e.g., shared memory).","There is increasing need to apply technology such as the CORBA GIOP ORB in different types of environments, but some environments, especially embedded environments, require more efficient and\/or compact messaging than is provided via the GIOP message and GIOP header formats of . In addition, standard GIOP\/IIOP interoperability protocols can be less than optimal for applications having strict requirements for latency, overhead and message sizes. Furthermore, because the CORBA GIOP was originally developed for use in general purpose distributed computing environments, optimization of the GIOP may be required for the best performance in distributed embedded systems, which can be more complex, especially because of the many interfaces with different types of control devices and input\/output (I\/O) devices. Optimized interoperability protocols are thus becoming of greater importance.","The following presents a simplified summary in order to provide a basic understanding of one or more aspects of the invention. This summary is not an extensive overview of the invention, and is neither intended to identify key or critical elements of the invention, nor to delineate the scope thereof. Rather, the primary purpose of the summary is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","CORBA and its GIOP initially were designed for non-embedded environments. One issue with at least some known implementations of the aforementioned implementations is that for certain types of systems such as embedded constrained systems, the CORBA GIOP message headers are too large, which can result in inefficiencies and assurance issues. For example, for command and control type interface operations the GIOP header takes up at least 80% or more of the message size. Also, from an assurance standpoint it can be harder to verify that the information in the GIOP message headers is valid. In addition, the inventor of the instant application has found that, from an assurance stand point, not all of the types of CORBA GIOP messages need be supported in all types of environments. For example, in certain embedded environments, such as the Software Defined Radio (SDR), Request and Reply types of messages are the primary messages being used. Robotics is another example of an embedded environment that often does not require all types of CORBA GIOP messages.","There have been attempts to create customized or optimized protocols using certain subsets of the message types. One version, called nORB modifies the GIOP message format slightly by removing the service context field and supports only a subset GIOP messages: request, reply, locate request and locate reply messages. Another solution, referred to as GIOPLite, is a so-called \u201clightweight GIOP\u201d that proposes to optimize GIOP by removing certain fields from the GIOP header in an effort to improve performance. Removal of these fields from the GIOP header and GIOP request header theoretically should reduce the GIOP message footprint overhead. GIOPLite removes the following fields: Magic number, Version, Byte order flag, Request service context, and Request principal. Still another approach is the so-called Controller Area Network (CAN) approach, which its developers also refer to as Embedded IOP (EIOP), because it is an IOP that can be used in an embedded environment. CAN supports only the message types Request and Request Cancel, and has its own header definition for Request messages, which the header definition does not retain CORBA fields. In addition, the known attempts to create these types of subset protocols do not provide ORB support and none of the known approaches retains all the CORBA GIOP features with a reduced header definition.","Note that \u201cEmbedded IOP\u201d, also referred to as \u201cEIOP\u201d, is a generic term that describe more than one variant or implementation of an embedded IOP, and mere fact that the CAN implementation also is referred to as an EIOP, and that in some instances the present invention also is referred to as an EIOP, does not mean that they are identical as is further explained herein.","In one embodiment, the invention provides systems and methods for providing an optimized inter-ORB protocol (IOP), which is referred to herein both as the custom Inter-ORB Protocol (custom-IOP) and also, in certain embodiments, the Embedded Inter-ORB Protocol (EIOP), that supports all the fields in the CORBA GIOP, but which takes up significantly less bytes than the GIOP (that is, the custom-IOP (e.g., EIOP) described herein is an exemplary, but in no way limiting). In this embodiment, only the GIOP Request and Reply message types need be supported and are defined to be a small as possible and still support the CORBA features, giving better performance and throughput, reduced latency and better information assurance (as is well understood, sending less data improves information assurance). The CORBA Common Data Representation (CDR) is still supported. In a further embodiment, the custom-IOP IDL provides the capability by IDL compile directives of supporting either the minimum custom-IOP definition (request and reply messages with object key only), which is also referred to herein as \u201clightweight custom-IOP\u201d or \u201clightweight EIOP,\u201d or a \u201cfull\u201d custom-IOP (or EIOP) that supports all the GIOP features such as different addressing disposition (IOR, profile), all addressing modes (addressing, disposition) and all GIOP message types. In addition, in this embodiment, an interface definition language (IDL) compiler option provides an indicator as to whether GIOP and custom-IOP code is generated to eliminate, at run-time, checking which type of IOP is supported.","In one embodiment, the invention comprises a non-transient computer-readable storage medium storing computer program code that, when loaded into a computer system and executed thereon, causes the computer to:","(a) compile an interface definition language (IDL) configured to provide a custom inter-orb protocol (custom IOP);","(b) configure a message header for a message in accordance with to a specification in the IDL for at least a custom-IOP message header, wherein:\n\n","(c) define a custom-IOP message header to replace the corresponding GIOP message header, wherein the custom-IOP message header requires fewer bits overall than the corresponding GIOP message header by changing or eliminating at least a portion of the fields in the corresponding GIOP message header, including at least:\n\n","Advantageously, in one embodiment, the non-transient computer-readable storage medium is constructed and arranged to operate in a predetermined environment comprising a client and server that send and receive messages only in accordance with the custom IOP. For example, in one embodiment, the predetermined environment comprises an embedded client-server system, such that the custom-IOP comprises an embedded-IOP (EIOP). In addition, in a further embodiment, the computer program code further cause the computer to allow octet types as a discriminate value for a union.","In a further embodiment, the modified custom-IOP message header, in combination with the set of indicators and the predetermined environment, is configured to convey the same information as the GIOP message header but using fewer bits than the GIOP message header. In a still further embodiment, the computer program code further causes the computer to change the GIOP unbounded sequence marshaling rules for EIOP message headers. In a still further embodiment, the custom-IOP uses an octet addressing type.","In still another embodiment, the custom-IOP is assigned a version, the version assigned by one of the following steps: providing a version in a version number field in the custom-IOP message header; receiving, at a time of compiling the computer program code, information indicating the version of the custom-IOP; and assuming, if no version is indicated in the version number field and no version number is received at time of compiling, that the version corresponds to a default version. Dependent on the version, in one embodiment, the set of indicators further comprises a second indicator defining which CORBA GIOP message types are supported in the custom-IOP. In addition, dependent on the version and value of the second indicator, in one embodiment, the size of the GIOP message header is selected to accommodate the number of CORBA GIOP message types that are supported. For example, in one embodiment, the second indicator designates that all CORBA GIOP message types are supported in the custom-IOP. In another example, in one embodiment, dependent on the version, the set of indicators further comprises a third indicator defining a type of GIOP addressing disposition that is supported for supported in the custom-IOP. In a further embodiment, dependent on the version, the spare bit in the custom-IOP header is defined to be an indicator designating whether or not a fragment is present.","In still another embodiment, the program code further causes the computer to specify in the IDL a custom-IOP request header, where the custom-IOP request header is defined to replace the corresponding GIOP message header, wherein the custom-IOP request header requires fewer bits overall than the corresponding GIOP request header by changing or eliminating at least a portion of the fields in the corresponding GIOP request header, including at least:\n\n","For example, in one embodiment, if a custom-IOP request header is specified and if the setting of the service context indicator field is set to indicate the presence of service context information, the program code further causes the computer to:","(e-7) replace the 4 bytes (32 bits) Number of Service Contexts field with a 1 byte (8 bits) custom Number of Service Contexts field;","(e-8) replace the 4 bytes (32 bits) Service Context ID field with a 1 byte (8 bits) custom Service Context ID field; and","(e-9) replace the 4 bytes (32 bits) Service Context Length field with a 1 bytes (8 bits) custom Service Context Length field.","In still a further embodiment, if a custom-IOP request header is specified and if the custom-IOP further comprises a version number field and if the version specified in the version number field corresponds to a first predetermined version, then the program code further causes the computer to:","(e-5) remove the 4 bytes (32 bits) length of object key field and","(e-6) define a custom-IOP target object key comprising a fixed-size object key, the fixed-size of the custom-IOP object key being a size configured to accommodate the maximum possible number of objects allowed by a portable object adapter (POA) in an embedded client-server system.","For example, in one further embodiment, the maximum possible number of objects comprises 256 objects and the fixed-size object key has a size of two-bytes.","In still a further embodiment, if a custom-IOP request header is specified and if the custom-IOP further comprises a version number field and if the version specified in the version number field corresponds to a second predetermined version, the program code further causes the computer to:","(e-7) replace the 4 bytes (32 bits) length of object key field with a 1 byte (8 bits) custom length object key field; and","(e-8) define a custom-IOP target object key that comprises one of an EIOP::ObjectKey and an IOP::ObjectKey.","In still a further embodiment, if a custom-IOP request header is specified and if the custom-IOP further comprises a version number field and if the version specified in the version number field corresponds to a third predetermined version, the program code further causes the computer to:","(e-9) replace the 4 bytes (32 bits) length of object key field with a 1 byte (8 bits) custom length object key field; and","(e-10) define a custom-IOP target object key that is configured to support profile and reference addressing and which comprises one of an EIOP::ObjectKey, an IOP::ObjectKey, an IOP::TaggedProfile, and IORAddressingInfo.","In a further embodiment, if a custom-IOP request header is specified, the program code further causes the computer to:","(e-10) modify the CORBA marshaling rule for sequence types associated with request messages, by changing a corresponding string and sequence type from an unsigned long having a size of four (4) bytes to an octet type having a size of one (1) byte; and","(e-11) basing, for a given sequence associated with a request message, the size and alignment requirements on an unbounded sequence index type.","In still a further embodiment, the program code further causes the computer to specify in the IDL a custom-IOP reply header, where the custom-IOP reply header is defined to replace the corresponding GIOP message header, wherein the custom-IOP reply header requires fewer bits overall than the corresponding GIOP reply header by changing or eliminating at least a portion of the fields in the corresponding GIOP request header, including at least replacing the 4 bytes (32 bits) Request ID field and 4 bytes (32 bits) Reply status field with a custom 2 bytes (16 bits) Reply field, wherein the three most significant bits (MSB) of the custom Reply field are defined to be a three (3) bits custom Reply status field, and the remaining thirteen (13) bits are defined to be a Request ID field. In a further embodiment, if a custom-IOP reply header is defined and if the setting of the service context indicator field is set to indicate the presence of service context information, the program code further causes the computer to:","(g-2) replace the 4 bytes (32 bits) Number of Service Contexts field with a 1 byte (8 bits) custom Number of Service Contexts field;","(g-3) replace the 4 bytes (32 bits) Service Context ID field with a 1 byte (8 bits) custom Service Context ID field; and","(g-4) replace the 4 bytes (32 bits) Service Context Length field with a 1 byte (8 bits) custom Service Context Length field.","In a still further embodiment, if the custom-IOP reply header is defined, the program code further causes the computer to:","(g-5) modify the CORBA marshaling rule for sequence types associated with reply messages, by changing a corresponding string and sequence type from an unsigned long having a size of four (4) bytes to an octet type having a size of one (1) byte; and","(g-6) basing, for a given sequence associated with a reply message, the size and alignment requirements on an unbounded sequence index type.","In still another embodiment, the program code further causes the computer to:","(h) specify in the IDL a custom IOP Cancel Header; and","(i) define the custom-IOP cancel header to replace the corresponding GIOP cancel header, wherein the custom-IOP cancel header requires fewer bits overall than the corresponding GIOP cancel header by changing or eliminating at least a portion of the field in the corresponding GIOP cancel header, including at least replacing the 4 bytes (32 bits)","Request ID field with a custom 2 bytes (13 bits) Request ID field.","In a still further embodiment, the program code further causes the computer to:","(j) specify in the IDL a custom IOP LocateRequest Header;","(k) define the custom-IOP LocateRequest header to replace the corresponding GIOP LocateRequest header, wherein the custom-IOP LocateRequest header is configured to support at least one of a custom Target Addressing Disposition field, custom-IOP target object key, EIOP::ObjectKey, IOP::ObjectKey, custom-IOP target object key, IOP::TaggedProfile, IORAddressingInfo, and wherein the custom-IOP LocateRequest header is configured to require fewer bits overall than the corresponding GIOP LocateRequest header by changing or eliminating at least a portion of the field in the corresponding GIOP LocateRequest header, including at least:\n\n","In yet another embodiment, the program code further causes the computer to:","(l) specify in the IDL a custom IOP LocateReply Header;","(m) define the custom-IOP LocateReplyheader to replace the corresponding GIOP LocateReply header, wherein the custom-IOP LocateReply header requires fewer bits overall than the corresponding GIOP LocateReply header by changing or eliminating at least a portion of the fields in the corresponding GIOP LocateReply header, including at least:\n\n","In another embodiment, the program code further causes the computer to:","(n) specify in the IDL a custom IOP Fragment header; and","(o) define the custom-IOP Fragment header to replace the corresponding GIOP Fragment header, wherein the custom-IOP Fragment header requires fewer bits overall than the corresponding Fragment header by changing or eliminating at least a portion of the fields in the corresponding GIOP Fragment header, including at least replacing the 4 bytes (32 bits) Request ID field with a custom 2 bytes (13 bits) Request ID field.","Furthermore, the architectures and methods which are the subject of this disclosure can be used in conjunction with (and\/or adapted to work with) many different types of embedded environments, including but not limited to the Software Communications Architecture (SCA) for Software Defined Radio's (SDRs), both the existing 2.2\/2.2.2. Specification and future Specifications (e.g., SCA Next and beyond), all of which are hereby incorporated by reference. It is anticipated that at least some of the architectures and methods of this disclosure also are applicable to systems and devices that use software components to communicate with different waveforms or protocols\/standards, such as mobile\/cellular telephones and other wireless network devices. It is further anticipated that at least some of the architectures and\/or methods of this invention are applicable to other technologies and\/or domains that require a lightweight deployment and configuration infrastructure, as well as any application that is using CORBA internally.","Details relating to this and other embodiments of the invention are described more fully herein.","The drawings are not necessarily to scale, emphasis instead generally being placed upon illustrating the principles of the invention.","It should be understood that, in the following detailed description, detailed explanations are not provided in every instance for terms of art that can be located and explained in the aforementioned and incorporated-by-reference CORBA specifications. In addition, in the following discussion, for clarity of description, exemplary listings of actual code used, in accordance with one embodiment of the invention, to implement the various interfaces (e.g., the interface definition language (IDL)), is not provided as part of the body of the text. Rather, such code listings are provided as part of the Figures.","Before detailing the illustrative embodiments of the custom-IOP of the invention (e.g., the Embedded Inter-Orb Protocol (EIOP) of the invention), including detailed message headers and message formats unique to this custom-IOP, it is helpful, in showing the advantages provided by at least some embodiments of the invention, to contrast the disclosed embodiment with the existing, prior art CORBA GIOP 1.3 protocol, especially with respect to Request and Reply message types.","The OMG's GIOP 1.3 specification includes standards for messaging, data, and object referencing. Its messaging standard defines features such as packet headers, protocols for remote communication, and requirements on the underlying transport service. Its data standard, called the Common Data Representation (CDR) standard, defines encodings for primitive and structured data-types in messages. Its object referencing standard defines the structure and content of Interoperable Object References (IORs), which serve as location transparent object identifiers. The CORBA GIOP messaging standard defines eight different message types, as shown in Table 1. Note that, in accordance with GIOP version 1.3, if bidirectional GIOP is in use for GIOP protocol, either side (client or server) may originate messages.",{"@attributes":{"id":"p-0087","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CORBA GIOP Message Types"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Message Type","Originator","Function"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Request","Client (or Both, if ","Carry information necessary to invoke a remote object; sent to invoke"]},{"entry":[{},"bi-directional GIOP)","the remote method"]},{"entry":["Reply","Server (or both, if","Returned in response to Request. It normally contains the data,"]},{"entry":[{},"bidirectional GIOP)","returned from the remote method. In other cases the reply may contain"]},{"entry":[{},{},"the redirection instruction or the description of the exception that was"]},{"entry":[{},{},"thrown on a server side."]},{"entry":["CancelRequest","Client (or both, if","Advises servers that a reply is no longer required for a still-pending"]},{"entry":[{},"bidirectional GIOP)","request whose identifier is specified in the message (no longer waiting"]},{"entry":[{},{},"for the answer)."]},{"entry":["LocateRequest","Client (or both, if","Query Current Location of an object; verifies that the server knows and"]},{"entry":[{},"bidirectional GIOP)","supports the certain remote object, and (if not), to what address the"]},{"entry":[{},{},"requests for that object should be sent instead."]},{"entry":["LocateReply","Server (or both, if","Sent in response to LocateRequest message; if needed, it may contain"]},{"entry":[{},"bidirectional GIOP)","the new address of the remote object that has moved."]},{"entry":["CloseConnection","Server (or both, if","Advises client not to send further requests on the connection on which"]},{"entry":[{},"bidirectional GIOP)","the CloseConnection message was received; server indicates that it"]},{"entry":[{},{},"will not provide the future responses"]},{"entry":["MessageError","Client or Server","Sent in response to any message with a bad header, e.g., a malformed"]},{"entry":[{},{},"or otherwise invalid messages; not used to report errors outside the"]},{"entry":[{},{},"messaging system; such errors are reported using the Reply message"]},{"entry":["Fragment","Client or Server","A subsequent message, continuing the previous one; long messages"]},{"entry":[{},{},"can be split into fragments. Supports multi-fragment messages and"]},{"entry":[{},{},"follows an incomplete preceding message (of type Request, Reply,"]},{"entry":[{},{},"LocateRequest, LocateReply or Fragment) which has its \u201cfollowing"]},{"entry":[{},{},"fragment\u201d bit set."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In addition, per the CORBA standard, all of the GIOP message types shown in Table 1 presently use a fixed-size message header.  is an illustration of an exemplary prior art GIOP message format  and prior art message header format . In addition, the table of  (which is a table comparing the GIOP message header with the exemplary custom-IOP message headers (which in this example are EIOP message headers) of several embodiments of the invention, all described further herein) also provides information about the GIOP message header. Referring to , the GIOP message format  is a generic format of a message in accordance with the GIOP, the generic GIOP message  includes a GIOP message header , the optional message header  (where the optional message header  is specific to the particular message type\u2014the Request, Reply, CancelRequest, LocateRequest, and LocateReply message types include this message specific header  located in between the message header (of ) and the payload of the message, but the message header is not provided with other types), and message body .","Referring still to , the prior art GIOP message header  is a 12 byte (96 bit) header common to all messages). The GIOP message header  includes several fields, as shown in . The magic field  (also referred to as magic number field  or GIOP identifier), has a size of 4 bytes (i.e., 4 octets or 32 bits) and identifies a message as being a GIOP message. In GIOP, the value of the magic field  always is set to the four upper case characters \u201cGIOP\u201d, encoded in ISO Latin-1. As noted in the table of , the illustrated embodiments of the invention for custom-IOP eliminate this IOP identifier entirely, helping to reduce the size of the header. This magic field  portion of the message header  can be eliminated, as is done in the embodiments of the invention, for a number of reasons. For example, in a given embedded context, it may be known that all messages are going to be messages sent in accordance with the given custom IOP protocol (e.g., the EIOP protocol, in an embedded environment), so it is not necessary to further add a header specifically indicating this\u2014such a header would be redundant.","Referring again to , the next 4 bytes include the version field , the flags field , and the message type field , which together form a set of GIOP indicators. The GIOP_version field  is two octets, and the flags field  and message type field  are each an octet (1 byte or 8 bits) in size. The GIOP version field  contains the version number of the GIOP protocol being used in the message (in this example of , the major GIOP version number is 1 and the minor GIOP version number also is 1, showing GIOP version 1.1 (the minor could be one of 0, 1, or 2), but this is not, of course, limiting. Note, also, that GIOP message headers are the same as illustrated in  for GIOP 1.2 and 1.3. In the examples described herein, the difference between the three described minor versions (i.e., 0, 1, and 2) is the addressing mode that is supported. The flags field  is an eight-bit octet, where the least significant bit (LSB) indicates the byte ordering used in subsequent elements of the message (including message size), the second LSB indicates whether or not more fragments follow, and the most significant 6 bits are reserved, but set to 0 for GIOP 1.3. The message_type field  indicates the type of the message. The message_size field  (also referred to as message length) contains the number of octets in the message following the message header, encoded using the byte order specified in the byte order bit (the least significant bit) in the flags field , excluding the 12 octets of the fixed-size message header itself. For GIOP 1.3, if the second LSB of the flags field  is 1, the sum of the message_size field  value and 12 must be evenly divisible by 8. The message_size field  is itself 4 bytes in length.","Each message type in Table 1 also has its own format for its respective message header , as explained further in the aforementioned CORBA Specification. Two illustrative examples of prior art messages are shown in , and one of skill in the art will appreciate that similar examples of message headers for the other message types can be created in accordance with the CORBA Specification.  is a block diagram of a prior art CORBA GIOP 1.2\/1.3 request message header , and  is a block diagram of a prior art CORBA GIOP 1.2\/1.3 reply message header . These prior art request and reply messages of  are different from the custom-IOP request and reply messages of the embodiments described further herein, in connection with the embodiments of the invention described herein. This is also explained further herein in connection with the table of , which is a table comparing the custom-IOP (e.g., EIOP) Request Headers of certain embodiments of the invention (described further herein in connection with ) and of other embodiments of the invention with the custom-IOP (e.g., EIOP) Request Header.","Referring to , the prior art request message header  is part of the Request message of Table 1. A Request message (header  plus message body ) allows the client application  to invoke an operation on a remote server\/servant . The request message header  contains all the information which is needed for the invocation including the identity of the object, the operation name, and any parameters associated with the operation. Request messages are used to invoke operations which have been declared in an IDL interface, thus, the message format of the Request message is configured to support all of the syntax which can appear in an IDL operation definition.","Referring to , the prior art GIOP request_id field  is a 4-bytes (32 bits) field that is used to associate reply messages with request messages. In contrast, in the embodiments of the custom-IOP described further herein (e.g., in ), the entire request_id field  is reduced to 2 bytes (16 bits) total, which includes a 3 bits \u201cResponse Flags\u201d field  and a 13 bits Request ID field , as shown in , described further below. Referring again to , the response_flags field  (referred to as the \u201cResponse flags\u201d field in GIOP 1.0 and 1.1) is 4 bytes in length, and is set to 0x0 for a SyncScope of NONE and WITH_TRANSPORT. The flag is set to 0x1 for a SyncScope of WITH_SERVER. A non exception reply to a request message containing a response_flags value of 0x1 should contain an empty body, i.e. the equivalent of a void operation with no out\/inout parameters. The flag is set to 0x3 for a SyncScope of WITH_TARGET. These values ensure interworking compatibility between this and previous versions of GIOP. Note that, in the embodiments of the invention described herein in connection with the custom-IOP, the response flags field  is no longer a separate field; instead, response flags is instead a 3 bits part of the \u201crequest ID\u201d field (see, e.g.,  described further herein), thereby saving these bytes in the message length. The reserved field  (which in GIOP 1.1 is an array of three bytes\/octets) is set to 0 in GIOP 1.1","The target field  is a two bytes (16 bits) GIOP field that identifies the object that is the target of the invocation (in GIOP 1.0 and 1.1 the field that performs part of this function is the object_key field). As  show and as the table of  shows, in the described embodiments of the custom-IOP, the target\/addressing disposition field is reduced to one byte that is capable of representing all addressing disposition modes.","Referring again to , the prior art GIOP operation field  (also known as operation name field ) is an IDL identifier naming, within the context of the interface, the operation being invoked. As noted in the table of , the size of the prior art GIOP operation field  is unbounded, but there is a minimum estimate of 10 bytes for the size of the operation field . In contrast, as shown in , the operation field  of the embodiments of the invention is one byte in size and allows up to 256 operations per object. All Operation Name Length (length of operation name) field precedes the operation name. Also alignment padding of up to 3 bytes may occur after name for aligning on service context field . The service_context field  allows service specific context information to be passed along with a Request and is intended for use in conjunction with the CORBA services to carry extra information along with the Request; for example it contains ORB service data being passed from the client  to the server . As further described in section 7.7 of the incorporated-by reference CORBA interoperability specification, the service context field  can include information such as the number of service contexts (4 bytes), the service context ID (4 bytes) and service context length (4 bytes). In the GIOP, the service context length field is always required. In contrast, in the exemplary embodiments of the custom-IOP described further herein, the number of service contexts , service context length , service context ID , and service context data A-I (see ) are only required when the service context indicator field  in the custom-IOP message header ,  (see , B) is set to true. This is why the embodiments illustrated further herein include the request header without service context () and the request header with service context (), as well as the reply headers without and with service context (, respectively).","The message body  for the Request message, which is not specifically illustrated in  but further described in the CORBA specification, includes of a list of the operation parameters followed by any context strings for the operation","In the prior art GIOP implementation, reply messages () are sent in response to Request messages only if the response flags field  in the Request message is set to \\x03. Reply messages are intended is to pass back a return value for an operation in a Request and to indicate the completion status for the operation. The Reply message header  generally does not include as much information as the Request message header . Referring to , the Reply message header  includes a service context field , request-id field , and reply status field  (a Reply message body  also is included). The service_context field  is similar to the service_context field  of the Request message header  described above and contains ORB service data being passed from the server to the client, encoded. The request_id field  is used to associate replies with requests and contains the same request_id value as the corresponding request (i.e., the request_id is a unique (per client) identifier used to match Request and Reply). The reply_status field  indicates the completion status of the associated request, and also determines part of the reply body contents; the replay_status field  can indicate whether this is a normal Reply or if some error condition occurred in the server.","As will be explained below, the invention provides, in at least some embodiments, several implementations of a CORBA inter-orb protocol (referred to herein as the custom-IOP and, in particular embodiments, the \u201cEmbedded Inter-Orb Protocol\u201d (EIOP)) that are optimized for embedded computing environments As is explained further herein, the embodiments of the invention support various possible versions of the custom-IOP, including at least one embodiment that provides support for all eight CORBA message types and at least one version that provides support for only the most commonly used message types in embedded environments. Further embodiments of the invention include 2 major versions of the custom-IOP, and each major version supports three minor versions. This is explained further below.","Before describing these embodiments, an overview is provided describing several types of computing environment in which the invention can be embodied. In particular, the CORBA protocols described herein can be implemented in many different types of various computing systems that include various combinations of known computing elements. In at least one embodiment, the invention can be implemented as part of an embedded computing system, such as a software defined radio (SDR) system. An SDR is a radio whose function is defined not by its underlying hardware, but instead by its software, such that its output signal is determined by software. SDR systems are thus reconfigurable, within the limits of the actual underlying hardware capabilities, by loading new software as required by a user.",{"@attributes":{"id":"p-0100","num":"0117"},"figref":"FIG. 5B","b":["61","61","71","64","63","62"]},"The SDR hardware component  includes a radio receiver and\/or radio transmitter (which is shown for illustrative purposes only in  as a radio transceiver ), as well as an analog-to-digital (A\/D) converter (ADC)  for conversion of the radio waveform  (also referred to as analog baseband input) is required) to a digital baseband input signal  to the SDR software c component , and a digital to analog (D\/A) converter (DAC) , for D\/A conversion of the digital baseband output  from the SDR software component . The radio transceiver  is a component well understood by those of skill in the art and includes, for example, a radio frequency (RF) subsystem  and an intermediate frequency (IF) subsystem . In the receiving mode, signals received by the antenna  are processed by the RF subsystem  and IF subsystem : for example, the signals received at antenna  can be processed in a tuner (to select the desired signal, such as by filtering), a detector (to extract audio signal from the signal selected by the tuner), downconverted to the desired baseband frequency, and then sent to the ADC  to be converted from an analog baseband signal  to a digital baseband data signal .","In the transmit mode, the digital baseband output signal  from the SDR software component  is sent to DAC  for conversion to an analog baseband output signal , the analog baseband output signal  is sent the IF subsystem  and RF subsystem  of the radio transceiver  of the basic SDR Hardware  for further processing, which may include upconverting the analog baseband output signal  to the appropriate transmission frequency, amplification, and filtering, then sent to antenna  for transmission.","The SDR software component  runs on a host, which can be a general-purpose computer system (such as described further herein in connection with ), or hardware that has been configured by software, such as a field-programmable gate array (FPGA), embedded computing device, multiprocessor embedded systems, any equivalent computing\/processing circuit. A waveform can consist of a set of SDR software components executing on general purpose processors, FPGA's, digital signal processors, etc. The host is able to handle a considerable amount of the signal processing previously done by conventional radio hardware components such as mixers, filters, amplifiers, modulators\/demodulators, detectors, etc. Thus, the SDR system  provides a radio that can receive and transmit widely different radio protocols (sometimes referred to as waveforms) based solely on the software used.","The SDR software component  is in operable communication with the SDR hardware component  via one or more data channels. For example, in , the data channels include a first data channel  that permits reception of digital baseband input data from the ADC  of the SDR hardware component , a second data channel  that permits transmission of digital baseband output data from the SDR software component  to the SDR hardware component , and a control data channel A that permits transmission of control data from the SDR software component  to the SDR hardware component . The SDR software component  receives client input data  from an SDR client  and sends client output data  to the SDR client .","The digital baseband output  typically results from the SDR software component  performing a series of digital signal processing (DSP) functions necessary to prepare the client input data  from the SDR client  for transmission by the SDR hardware component . These functions may include: source encoding, encryption, error-correction coding, and baseband modulation, as well as the aforementioned functions performed by hardware components such as mixers, filters, amplifiers, modulators\/demodulators, detectors, etc.","The SDR software component  of , as noted above, as well as the SDR client , each can be implemented using a known computing system such as a general purpose computer. In accordance with at least some embodiments of the invention, the client and server can be on the same processor. In accordance with at least some other embodiments of the invention, the client and server can be on different processors, as is done with at least some embodiments of the SDR. An example of a multiple core processor architecture usable for embedded domains, such as those used for at least some embodiments of the invention, includes but is not limited to the OMAP architecture, available from Texas Instruments of Dallas, Tex.",{"@attributes":{"id":"p-0107","num":"0124"},"figref":"FIG. 5A","b":"50"},"Referring now to ,  provides an illustration giving an overview of an exemplary computing system  usable with at least some embodiments of the invention. Note that systems and methods in accordance with the invention can be implemented using any type of computer system, included but not limited to embedded computing systems, enterprise computing systems, etc., running any one or more types of operating systems. Exemplary types of computer systems  on which at least some embodiments of the invention can be embodied include any system or device having a processor (or equivalent processing functionality, such as via a microcontroller) installed or embedded, including but not limited to a desktop computer, personal computer (PC), laptop computer, notebook computer, tablet computer, handheld computer, netbook, personal digital device (including but not limited to personal digital assistant (PDA), mobile communications device (including but not limited to radio, conventional telephone, mobile\/cellular telephone, smart phone, music playing device, electronic reading device) server, workstation, and interconnected and\/or distributed group of computers, as well as any other type of device having a microprocessor or microcontroller installed or embedded thereto, such as a field-programmable gate array (FPGA).","Referring again to , the exemplary computer system  includes a central processor , associated memory  for storing programs and\/or data, an input\/output controller , a disk controller , a network interface , a display device , one or more input devices , a fixed or hard disk drive unit , a removal storage device\/drive (optional) , optionally a backup storage device (e.g., a tape drive unit) (not shown) and a data bus  coupling these components to allow communication therebetween.","The central processor  can be any type of microprocessor, such as a PENTIUM-family processor, made by Intel of Santa Clara, Calif. The display device  can be any type of display, such as a liquid crystal display (LCD), plasma display, cathode ray tube display (CRT), light emitting diode (LED), touch screen display, and the like, capable of displaying, in whole or in part, any desired information. The input device  can be any type of device capable of providing the desired inputs, such as keyboards, numeric keypads, touch screens, pointing devices, switches, styluses, and light pens. The network interface  can be any type of a device, card, adapter, or connector that provides the computer system  with network access to a computer or other device, such as a printer. For example, the network interface  can enables the computer system  to connect to a computer network such as the Internet. Other computer accessories well-known to those of skill in the art (e.g., microphones, cameras, speakers, biometric access-control devices such as fingerprint scanners, etc.), although not illustrated in the block diagram of , can of course be included as part of the computer system .","Several illustrative embodiments of the invention will now be described. In addition to the block diagrams and tables of  being described below, those of skill in the art are encouraged to view these diagrams in connection with , which together are a listing of a CORBA pseudo-IDL (PIDL) that maps to the custom-IOP Message Headers of . The CORBA PIDL of  provide details for implementing two versions of an custom-IOP message header (i.e., in ), as well as details for implementing custom-IOP Request and Reply headers, together with their corresponding service context headers (i.e., in ). Although the CORBA PIDL of  shows implementation details for all types of headers and all message types one of skill in the art can readily understand how to implement this PIDL (e.g., via IDL compile directives) so that the PIDL is configured to implement any subset of message types and\/or to implement any version described herein, and\/or to implement any future versions of the GIOP.","In addition, regarding the CORBA PIDLs of , it can be seen that the addressing type is an octet, which CORBA does not support at the time of this writing. That is, the code listing of  is a PIDL because it does not compile as written, because the Object Management Group (OMG) specification for CORBA, at this writing, does not support octet types as a discriminate value for a union. It is believed, however, that the OMG that sets the standards for CORBA is capable of supporting octet types as a discriminate value, and, that such an omission of octet types from the CORBA specification might be an inadvertent oversight. Furthermore, as those of skill in the art will appreciate, individual vendors can readily adapt CORBA to support octet types as a discriminate value.","Note, however, that the PIDL of  was verified being workable by changing temporarily the addressing disposition type to be an \u201cunsigned short\u201d so that it would compile. Thus, one of skill in the art can readily appreciate that, if and when the present CORBA specification is adapted to support octet addressing disposition types, the PIDL of  will, in fact, be a compilable IDL. Although the CORBA PIDLs of , however, are provided, with an octet addressing disposition, one of skill in the art will recognize the inventive structures and methods contained therein (and further described in the flow chart of ) can readily be adapted to any desired addressing disposition.",{"@attributes":{"id":"p-0114","num":"0131"},"figref":["FIG. 6A","FIG. 6B","FIG. 7","FIG. 6A","FIG. 6B","FIGS. 2 and 3","FIGS. 6A and 6B","FIG. 6A","FIG. 6B","FIG. 2","FIG. 6A","FIG. 6B"],"b":["70","100","30","70","100","70","100"]},"The invention provides several options to determine whether a Major Version 1 custom-IOP Message Header is to be used or whether a Major Version 2 custom-IOP Message header is to be used. In one embodiment, at run time, when compiling the IDL or version of PIDL, (e.g., an IDL based on the PIDL of ), the header of the IDL (or PIDL) provides an indication (e.g., a flag, such as an IDL compiler flag) as to the version that is being used and also which minor indicator is being used. For example, the exemplary IDL of the embodiment of  supports two \u201cMajor versions\u201d (e.g., version 1 EIOP and version 2 EIOP), and each Major version supports three Minor versions. (Minor 0, Minor 1, and Minor 2). Alternately, in another embodiment, at run-time, the version (i.e., version 1 or version 2) is checked by the ORB running the IDL. The Major versions determine message size that will be supported, and the Minor versions determine the Addressing Disposition values and TargetAddress type for a request header.","As a further illustration of the exemplary embodiment, consider , which is a flow chart depicting the processes of the exemplary PIDL of , in accordance with one embodiment of the invention. Portions of this flow chart illustrate how custom-IOP versioning is determined, in accordance with an exemplary embodiment of the invention. Referring to , at the start, prior to compiling, a check is made to see whether an EIOP preprocessor IDL is already defined (block ). If the answer is yes, the code is ignored and processing stops (block ). If the answer is no, then the EIOP preprocessor IDL is defined before compiling (block ), and an \u201comg.org\u201d prefix is added to appropriate repository identifiers (IDs) (block ). Referring briefly to  and again to A-B, prior to compiling, a check is made (e.g., of corresponding compiler flags) to see if a Minor Version (discussed further herein) is defined (block ) and whether a Major Version is defined (block ). If no Minor Version is defined, a default of Minor Version Zero (0) is assumed (block ). If no Major Version is defined, a default of Major Version 1 is assumed (block ). This combination of Major Version 1 and Minor Version 0 is also referred to herein as a \u201clightweight\u201d custom-IOP protocol, in accordance with one embodiment of the invention, where the lightweight protocol supports only the message types of Request, Reply, and MessageError (blocks , ) and supports only one type of addressing mode. In at least one embodiment, this so-called Lightweight custom-IOP protocol is the default protocol.","Note also that, in accordance with the PIDL of  and the flowchart of , even if there is a defined Minor Version and a Defined Major Version, the custom-IOP will always provide at least the lightweight custom-IOP behavior (e.g., \u201clightweight EIOP\u201d) of Minor Version 0 and Major Version 1 (i.e., will always support at least Request, Reply, and Message Error types, of a size less than 64K). As explained below, the Major versions 1 and 2 differ primarily in allowed message size. In addition, as will be explained further herein, the addition Minor Versions of the protocol (Minor Version 1 and Minor Version 2) described herein provides some additional capabilities, including additional message types and\/or additional addressing modes. For example, Minor Version 1 provides some additional addressing mode behavior, but not all the addressing mode behavior provided in the GIOP. Minor Version 2 supports all GIOP message types and all GIOP address modes and is the embodiment that is considered the \u201cfull EIOP\u201d protocol, as it supports all capabilities of GIOP (in particular GIOP version 1.3).","Although the embodiments of the invention described herein are, by example only, limited to the particular combination of Major and Minor Versions described in the illustrated embodiments, those of skill in the art will recognize that the invention is not so limited. Other types of versions (e.g., versions supporting some other message size, versions supporting some other subset of GIOP features) are within the spirit and scope of the invention, as will be appreciated by those of skill in the art.","Referring now to , B, A-F, and A-B, if it is known in advance that messages being used in a given environment are always going to be greater than a first predetermined size (which for exemplary purposes only is 64 kilobytes (64K)), e.g., if a compiler directive is defined (exists) where the compiler directive's existence indicates that the FULL-EIOP protocol is required (block ), then the so-called \u201cMajor Version 2\u201d optimized EIOP header , as shown in , is used (block ). If the compiler directive for FULL_EIOP is not defined (i.e., does not exist) (block ), then the so-called \u201cMajor Version 1\u201d optimized EIOP header , as shown in , i.e., the default Lightweight EIOP, is used. Note that all custom-IOP (e.g., EIOP) versions, including at least those described in accordance with the embodiments of the invention disclosed herein, are capable of supporting the full GIOP message set (i.e., implementing the FULL_EIOP protocol) by defining the compiler directive for FULL_EIOP when compiling the IDL.","The FULL_EIOP protocol defines additional message types beyond the Request, Reply, and Message Error types of the Lightweight EIOP protocol (see, e.g., the aforementioned CORBA specification and the PIDL of ). In addition, the implementation of these additional message types in the FULL_EIOP embodiment, as compared with the prior art GIOP, are explained briefly further herein, in connection with .","As noted above, the Lightweight EIOP, Major Version 1 protocol of  is more optimized (e.g., condensed), than the so-called \u201cMajor Version 2\u201d optimized EIOP header  of , which is used when it is known in advance that message sizes are bigger than the first predetermined message size (which is 64K, in this example, but this is not limiting. In at least one embodiment, the message length field is defined as 2 bytes, which is equivalent in this embodiment to 64K).","Referring still to , B, A-F, and A-B, after determining whether or not the implementation will be FULL_EIOP, a check is made to determine if the Major Version is set to 1 or 2 (block ). If the Major Version is set to 1, then request and reply messages will have a size <64K, and message header are defined to comply with the EIOP message header format of  (block ). If the Major Version is set to 2, then there is an 8 bytes message header, and Request and Reply messages can be \u226764K and are defined to comply with the EIOP message header format of  (block ).",{"@attributes":{"id":"p-0123","num":"0140"},"figref":["FIG. 7","FIG. 6A","FIG. 6B","FIGS. 2-4","FIGS. 2","FIG. 7","FIG. 2","FIGS. 6A","FIG. 6B","FIG. 6A"],"b":["6","6","70","100","30","6","7","70","72","74","100","30","100","70","100","70"]},"Referring still to , , A, B, and , it can be seen that magic number field  of the prior art GIOP message header  (also known as the \u201cidentifier\u201d field) is the only field that has been eliminated in the EIOP Major and Minor message headers , , respectively. As those of skill in the art will appreciate, in the system or embedded environment in which the invention is implemented, the identification provided by the magic number is not needed: that is, if the magic number is not present, the message inherently is considered to be a type of EIOP message. The prior art message type field , which had a size of one octet (i.e., 8 bits) is replaced in the Major Version 1 EIOP message header  and the Major Version 2 EIOP message header  with a message type field  of just 4 bits. This message type field  is big enough, however, to represent all CORBA message types, if it is desired, as it is in at least some embodiments, to represent some or all CORBA message types.","Referring still to , , A, B and , the Major Version 1 EIOP message header  and the Major Version 2 EIOP message header  each conveys all of the information of the prior art GIOP header , using differently named and configured fields not present in the prior art, as is explained further below. For example, the Major Version 1 EIOP message header  and Major Version 2 EIOP message header  each includes an In Use indicator field , having a size of one bit, which field  indicates if the IOP is use (shared memory usage\/shared memory transports). A value of false (0) indicates not in use; a value of true (1) indicates in use. This enables an EIOP message to be shared between a client and server without being copied. The Endian indicator field , having a size of one bit, indicates Little Endian byte orientation when set. A value of false (0) indicates a big-endian byte sequencing; true (1) indicates little-endian byte sequencing (as is known in the art, Big Endian means that the most significant byte of any multibyte data field is stored at the lowest memory address, which is also the address of the larger field, and Little Endian means that the least significant byte of any multibyte data field is stored at the lowest memory address, which is also the address of the larger field). This conveys information similar to the prior art flags field .","Referring again to , the Service Context Indicator field , having a size of one bit, indicates whether the request or reply header contains service context information. A value of false (0) indicates no service context; true (1) indicates service context is present. If that bit is set, then that means that the request or the reply has service context information in it. This helps to indicate which request or which reply header will be used. Note that, as shown in , the prior art Request and Reply messages each dedicate 4 bytes to a corresponding service context field  in their respective message headers, thereby inherently indicating, in the prior art Request and Reply messages, the presence or non-presence of service context information. In contrast, in the Major Version 1 EIOP header  of  and Major Version 2 EIOP header  of , there is a more compact definition of service context, via the service context indicator field , a 1 bit field that can indicate whether or not service context is present. This helps to eliminate having to have a message length indicator in the EIOP header. With the Major Version 1 EIOP header  and Major Version 2 EIOP header , the service context information is similar to that service context information for the GIOP request and reply (e.g., in ), but defined in a more compact structure. Also, as described further herein, sequence types are marshaled differently for the sequence length. Based on the setting of the service context indicator field , the header to use for a given request or a given reply can be determined.","There is a first spare bit field , having a size of one bit. There also is a second spare bit field Spare  having a size of four bits. Users can designate any desired use for these spare bit fields. In one embodiment, for example, the first spare bit field  is to indicate and\/or support use of fragmented messages, such as indicating that a fragment is present or not. The EIOP Indicator Minor field  an EIOP Indicator major field  are specific to the embodiments described herein as to their indication, but functionally serve a similar purpose to the GIOP major and minor version fields. The message length field , having a size of 16 bits (2 bytes\/octets) is similar to the prior art message_size field , except that it conveys the message body size in 2 bytes (EIOP) instead of 4 bytes (GIOP).","As noted above,  is a diagram of a version 2 EIOP Message Header , in accordance with one embodiment of the invention. The fields in the version 2 EIOP Message Header  are identical to the corresponding and similarly named and numbered fields in the version 1 EIOP Message Header  of , except that the version 2 EIOP Message Header does contain additional information. The version 2 EIOP Message Header  differs from the version 1 EIOP Message Header  by including a reserved field  (which is an unused 2 byte\/16 bit field) and a longer message length (4 bytes\/32 bits for version 2 EIOP Message Header, versus 2 bytes\/16 bits for version 1 EIOP Message Header.","In the following descriptions of EIOP Request and Reply headers (including those with service context), of , it should be understood that these headers work in connection with the same types of request and reply messages as are used with GIOP (and, where applicable (e.g., Full EIOP), the other types of messages), but in a more condensed format. In addition, as will be appreciated by those of skill in the art, the exemplary EIOP request and reply headers work with all Major and Minor versions of the EIOP described herein, with particular differences noted in the Tables of , , and -.",{"@attributes":{"id":"p-0130","num":"0147"},"figref":["FIG. 8","FIG. 9","FIG. 10","FIGS. 8 and 9","FIGS. 8 and 9","FIG. 9"],"b":["120","150","150","150","120","150"]},"Referring to , as with the EIOP message header , the EIOP Request Header  and EIOP Request Service Context Header  each provide a more compact version of the GIOP Request Header  (). The EIOP Request Header  and EIOP Request Service Context Header each, independently, conveys the same information as the GIOP Request Header  and performs the same functions as the GIOP Request Header . The EIOP Request Header  and the EIOP Request Service Context Header  are each a 16 bit header. Each type of request header ,  includes a three (3) bit Response flags field ; where the settings of this field are described in the Common Object Request Broker Architecture (CORBA) Specification, Version 3.1.1 2, states:\n\n","The Request_ID field  of each type of request header ,  is a 13 bit field, which (as Table 2 of  shows) is smaller than the 4 bytes of the GIOP. As can be seen in  with a Response flags  of 3 bits and a Request ID  of 13 bits, the total combined of these two fields is 16 bits\/2 bytes, but the comparison chart of  lists all two bytes as falling under the Request ID  field and 0 bytes in the Response flags  (Table 2 of , for convenience, shows individual fields rounded up or down to the nearest byte, but the total number of bytes, of course, matches the actual total number of bytes).","The Target field in the GIOP (e.g., GIOP 1.3) maps to several fields in the EIOP Request Header  of  (and the EIOP Request Service Context Header  of ), including: the Target-EIOP Object Key  (also referred to herein as object number field ), the Target Addressing Disposition field  and the Target-EIOP Object Key , where the Target-EIOP Object key  is a field itself includes subfields that include a User Defined indicator , a Transient Indicator , a Portable Object Adapter (POA) Identifier (ID) , and Transient Random Data .","In the GIOP, the Target field in a request header is defined as a union, and the addressing disposition discriminant type determines the type of target object reference. In the exemplary custom-IOP (e.g., EIOP), the addressing disposition discriminant type also determines the type of target object reference, but the contents of the Target field vary based on the setting of the Minor version (which, as noted earlier, indicates the addressing mode supported and the Target Address type for a request header). In addition, the exemplary custom-IOP described herein introduces a new target type, where the object key is 2 bytes and which is capable (via the Minor Versions 1 and 2) of supporting the other target object keys as defined in the GIOP. This is explained further below.","The fields that are included in the custom-IOP request header are at least partially dependent on the minor version of the custom-IOP and also help to ensure backwards compatibility with the various GIOP versions. For example, if the Minor Version is set to 0, the custom-IOP defines its target that is an object key of two bytes that is unique to the custom-IOP, as well as an object number  and object key flags  (all explained further below). If the Minor Version is set to 1 or 2, the respective custom-IOP supports the other GIOP addressing modes. For example, Minor Version 1 of the custom-IOP supports a custom-IOP object key and also an IOP::Object Key. Minor Version 2 of the custom-IOP supports not only the custom-IOP object key but also all Inter Orb Protocol (IOP) addressing, as well as additional Interoperable Object References (IORs) and tagged profiles (this is further detailed in the PIDL of ).","If the Minor Version is set to 0, the custom-IOP request header  includes a Target-EIOP object Key of 128 object number field and 127 object key flags field, which are both 8 bits (1 byte\/octet) in size and are fields unique to the custom-IOP (e.g., unique to EIOP). These fields also are unique to Minor Version 0. This Target EIOP Object Key  and  is a \u201cscaled down\u201d version of the Object key, because the Minor Version 0 supports only one addressing type. Note that for the other minor versions in the exemplary custom-IOP (e.g., Minor Version 1 and Minor Version 2), each has an object key length of one byte instead of the GIOP object key length of four bytes.","The Minor Version 0 (as well as Minor Versions 1 and 2) Target-EIOP object Key object number field  and object key flags field  is functionally equivalent to the Target field in the GIOP 1.3 Request header (and to the object_key field in the GIOP 1.0 and 1.1 request headers), and indicates the object that is the target of the invocation. For Minor Versions 1 and 2, the object key length is 1 byte in the custom-IOP, vs. 4 bytes in the GIOP.","As  and the PIDL of  illustrates (e.g., at top of ), the Object Number field  corresponds to byte  of the object key information. Byte  of the object key information, as shown in , includes a transient random data field  as its four LSBs, which is a random number for a transient object key. The two bits to the left of the transient Random Data are the POA ID field , field that identifies the portable object adapter that is the identifier associated with this object. The bit to the left of the POA ID field  is the transient indicator bit , which is a bit field that indicates if the object key is persistent or not: 0 means persistent, 1 means transient. The MSB of this byte  is the user-defined indicator bit , which is a bit field that indicates if the object key is user defined or orb defined.","The Minor Version 0 (as well as Minor Versions 1 and 2) also includes a Target-Addressing Disposition field , which is an 8 bit (1 byte\/octet) field that can, for the custom-IOP protocol(s) described herein accommodate the target addressing dispositions in GIOP (i.e., EIOP Object Key, Object Key, ProfileAddr, ReferenceAddr) and thus indicate the type of target addressing. Note that this still requires an object key, as a different object key is defined for an embedded constraint environment, as will be understood by those of skill in the art.","The Operation field  is an 8 bit (1 byte\/octet) field that indicates the corresponding operation number and is similar to the operation field  of , except that for the exemplary custom-IOP described herein it is a fixed size (vs. being unbounded in GIOP), enabling the operation name length of the GIOP to be eliminated in the custom-IOP. The custom-IOP request header  also includes marshaled parameters A-D (FIG. B)\/E-F (), which are fields where conventional CORBA marshalling rules take over, e.g., where parameters and user data go, as is well understood in the art (as is known, marshalling flattens complex data structures into a transportable representation, e.g., a stream of bytes, that not only contains the data itself, but also meta-information, such as the length of a certain entity or an encoding for its types). Marshaled parameters generally follow the end of a given header, and aren't part of the header itself, as is well understood in the art.","Both the custom-IOP Request Header  and the Request Service Context Header  include a number of marshaled parameters , and although they are numbered uniquely, they are not required to be different. In addition, in the Request Service Context Header , the Service Context information , ,  is located at the end of the message, as is done in GIOP versions 1.2 and later (earlier version of GIOP as are illustrated in  herein, such as GIOP 1.0 and 1.1, have Service Context information at the start of the message).","As indicated in Table 2 of  (and also Table 3 of , which relates to Replay messages), the custom-IOP reduces the size of fields as compared with the GIOP. For Example, the number of service contexts field  is reduced from four (4) bytes in the GIOP to one (1) byte in the custom-IOP, for all versions of the custom-IOP. As Table 2 notes (and as discussed previously), the custom-IOP header ,  includes a one (1) bit service context indicator field that indicates the presence of service contexts. The service context ID field  in the custom-IOP is reduced from four (4) bytes (in the GIOP) to one (1) byte in the custom-IOP, which allows for 256 possible service contexts (although CORBA at present has only 22). The service context length field  in the custom-IOP is reduced from four (4) bytes in the GIOP to one (1) byte in the custom-IOP, allowing a maximum number of 255 for the size of service context data","In addition, the EIOP Request Service Context header  of  also illustrates that, in accordance with one embodiment, the EIOP of this embodiment of the invention implements changes in the unbounded sequence marshaling rules. As is known in the art, there are two kinds of sequences: bounded and unbounded. A bounded sequence has a maximum length that is part of the IDL sequence type and cannot be changed. An unbounded sequence has a flexible maximum length that can be set during construction and modified during processing. In either case, the maximum length determines the amount of buffer storage used by the sequence to hold its elements. In at least one embodiment of the invention, one CORBA marshaling rule that is changed, only for the EIOP header types, is as follows: string and sequence length is an octet type and not an unsigned long of four (4) bytes. This new marshaling rule for sequence types in EIOP is applicable for any sequence for request and reply messages. One reason this marshaling rule can be implemented is that, in EIOP embodiments described herein, there is no requirement to support object keys that are more than 255 bytes or service contexts that are more than 255, or the service context data being more than 255 bytes. So, the marshaling rule for sequence types can be changed, to enable compacting the message header information, instead of requiring extra bytes to specify the length of various fields, with \u201cpadding\u201d of unused fields, as is done with the GIOP. As noted in Table 2, padding of the fields will occur for certain types, based on the types and how they are supposed to line up, as will be understood by those of skill in the art.","As an illustration of this marshaling rule change, consider Table 2 of , which compares the Request Header  and Request Service Context Header  of various Major and Minor modes, with the GIOP. In minor versions 1 and 2 that support the other addressing modes, where they include some type of sequence definition, the length of that corresponding object key  is only going to be a one byte field instead of four bytes. Thus, this is one area where the marshalling rule has changed. This type of reduction in size, as illustrated in Table 2, also can be seen in the number of service contexts, where all of the EIOP versions are using a field of just one (1) byte express the number of service contexts that are there, instead of a 4 byte length field as is done with GIOP.","In addition, as those of skill in the art are aware, GIOP requires that the number of elements be the first field and be an unsigned long value. However, in the EIOP of this embodiment, although the number of elements is again first, its size and alignment requirements are based upon the unbounded sequence index type. For the number of elements in sequence, its unbounded sequence index type is the sequence index type that defines the max number of elements for a sequence. This allows for better compaction of the encoded unbounded sequence type. This rule is similar to a union and its discriminate type. This allows the EIOP IDL file () to be compiled by an IDL compiler using this marshaling rule and not be treated as pseudo IDL.","The PIDL of  and Flow chart of , both previously discussed in connection with Message header formatting, also show how to implement the other message types used in the EIOP, as applicable depending on version and\/or whether FULL_EIOP directive is defined. Referring now to , A-F and A-B, after the fields of the Request Header are defined (block ), a check is made as to whether the Minor Version is set to 0 (block ). If the answer is yes, and if the FULL_EIOP directive is defined (block ), then the implementation is defined to use only the lightweight EIOP object key (because object key is a fixed size, object key length is not necessary) (block ).","If the Minor Version is set to 1 (block ), then support is defined for the HOP object key type (block ). If the Minor Version is set to 2 (block ), then full EIOP addressing disposition support is defined (block ). Regardless of the Major and Minor version, the Request Header is defined per , Request Header Service Context is defined per , Reply Header per , and Reply Service Context Header per , are defined as shown in the Figures and PIDL of  (blocks  and ).","If the full_EIOP directive was defined (block ), additional Headers, Status types and Reply Status types are defined (blocks  and ), as shown in  and in the PIDL of .",{"@attributes":{"id":"p-0149","num":"0167"},"figref":["FIG. 11","FIG. 12","FIG. 13","FIGS. 8 and 9","FIGS. 11 and 12","FIG. 12"],"b":["160","180","160","180","180","160","180"]},"Referring to , the EIOP Reply header  and EIOP Reply Service Context Header  are each 16 bits long and each include a 3-bit Reply status field  and a 13-bit Request ID field  (as was noted above in connection with Table 2, Table 3 shows correct total bytes, but individual blocks round the bits up or down to the nearest byte; hence, Reply status of 3 bits shows up as \u201c0\u201d bytes and Request ID of 13 bits shows up as \u201c2\u201d bytes). The Reply status field  is similar to the reply status field  of  (the GIOP reply header). The Request ID field  is identical to the request_id field  of  (GIOP request header). The marshaled parameter field (G, H in , and J in ) is similar to the marshaled parameters described previously in connection with the Request headers of . The other comparisons in Table 3 (e.g., for Number of Service Contexts, Service Context Length, Service Context ID, etc.) between EIOP and GIOP are similar to those discussed in connection with Table 2.",{"@attributes":{"id":"p-0151","num":"0169"},"figref":["FIG. 14","FIG. 15","FIG. 16","FIG. 17"]},"In addition, as Table 5 of  illustrates, the Addressing Disposition field is one byte instead of two, and can represent all addressing disposition modes. The Length of Object Key field is reduced from 4 bytes in GIOP to: 0 for Minor Version 0 (because the Object Key field in EIOP Minor Version has a fixed size, thus no need to specify length); and to 1, for Minor Versions 1 and 2. Other changes shown in Table 5 are similar to those discussed above in connection with Table 2.","In , which compares the LocateReply Header of GIOP with EIOP, because the Locate Status is part of the EIOP Request ID field (see ), this field can be eliminated from the Locate Reply header.","As those skilled in the art will recognize, the various embodiments of the invention described herein can be modified to accommodate and\/or comply with any many different technologies and standards, including, for those embodiments utilized in an embedded environment such as the SDR, future SCA standards, including but not limited to SCA Next. In addition, the various embodiments of the invention described herein can be compatible with various versions of the GIOP protocol. For example, one version of the custom-IOP protocol described herein (i.e., the so-called \u201cfull EIOP\u201d (with support for all GIOP message types)), Major Version 2, Minor Version 2, maps to GIOP 1.3, supporting all GIOP 1.3 message types, but using the custom-IOP fields described herein (to reduce the number of bits required to provide data). Another version of the custom-IOP protocol described herein (i.e., the so-called \u201clightweight EIOP\u201d) generally maps to GIOP 1.1, but supports a subset of the GIOP 1.1 message types (and supports a subset of the GIOP 1.3 message type). Furthermore, one of skill in the art will recognize that the various embodiments disclosed herein can be implemented using a bridge (e.g., an inter-ORB bridge) to translate between versions (e.g., to be backwards compatible to even earlier versions of the GIOP), which may be advantageous in certain implementations.","In addition, variations, modifications, and other implementations of what is described herein can occur to those of ordinary skill in the art without departing from the spirit and the scope of the invention as claimed. Further, virtually any aspect of the embodiments of the invention described herein can be implemented using software, hardware, or in a combination of hardware and software.","It should be understood that, in the Figures of this application, in some instances, a plurality of system elements or method steps may be shown as illustrative of a particular system element, and a single system element or method step may be shown as illustrative of a plurality of a particular systems elements or method steps. It should be understood that showing a plurality of a particular element or step is not intended to imply that a system or method implemented in accordance with the invention must comprise more than one of that element or step, nor is it intended by illustrating a single element or step that the invention is limited to embodiments having only a single one of that respective elements or steps. In addition, the total number of elements or steps shown for a particular system element or method is not intended to be limiting; those skilled in the art will recognize that the number of a particular system element or method steps can, in some instances, be selected to accommodate the particular user needs.","It should also be appreciated that the IDL listings (including the PIDL), block diagrams, and flow charts provided herein do not depict the syntax of any particular programming language (although in some instances methods from C++, CORBA IDL and\/or Java programming language have been provided by way of example). Rather, the flow diagrams and flow charts illustrate the functional information one of ordinary skill in the art requires to fabricate circuits or to generate computer software to perform the processing required of the particular apparatus. It should be noted that many routine program elements, such as initialization of loops and variables and the use of temporary variables are not shown. It will be appreciated by those of ordinary skill in the art that unless otherwise indicated herein, the particular sequence of steps described is illustrative only and can be varied without departing from the spirit and scope of the invention.","Those skilled in the art will appreciate that computer systems embodying the present invention need not include every element shown in , and that equivalents to each of the elements are intended to be included within the spirit and scope of the invention. For example, the computer system  need not include the tape drive , and may include other types of drives, such as compact disk read-only memory (CD-ROM) drives, universal serial bus (USB) drives, and any other type of removable media onto which information can be stored. CD-ROM drives can, for example, be used to store some or all of the databases described herein.","Systems and methods in accordance with the invention can be implemented using any type of computer system running any one or more types of operating systems (including, by way of illustration and not limitation, the SDR environments and embedded environments described herein). Exemplary types of computer systems on which at least some embodiments of the invention can be embodied include any system or device having a processor (or equivalent processing functionality) installed or embedded, including but not limited to a desktop computer, personal computer (PC), laptop computer, notebook computer, tablet computer, handheld computer, netbook, personal digital device (including but not limited to personal digital assistant (PDA), mobile communications device (including but not limited to radio, conventional telephone, mobile\/cellular telephone, smart phone, music playing device, electronic reading device) server, workstation, and interconnected group of computers, as well as any other type of device having a microprocessor installed or embedded thereto, such as a field-programmable gate array (FPGA).","In at least one embodiment of the invention, one or more computer programs, such as those further described herein, define the operational capabilities of the computer system . These programs can be loaded into the computer system  in many ways, such as via the hard disk drive , via one or more removable storage devices\/drives  (e.g., a floppy disk drive a tape drive , a CD-ROM drive, a USB drive, etc.) or via the network interface  (e.g., wirelessly, via the Internet, etc.) Alternatively, the programs can reside in a permanent memory portion (e.g., a read-only-memory (ROM)) chip) of the main memory . In another embodiment, the computer system  can include specially designed, dedicated, hard-wired electronic circuits that perform all functions described herein without the need for methods from computer programs.","In at least one embodiment of the present invention, the computer system  is networked to other devices, such as in a client-server or peer-to-peer system. The computer system  can, for example, be a client system, a server system, or a peer system. In one embodiment, the invention is implemented at the server side and receives and responds to requests from a client, such as a reader application running on a user computer. The computer system can be implemented as part of, controlling, or in operable communication with a terminal, personal computer, mainframe computer, workstation, hand-held device, electronic book, personal digital assistant, peripheral device, notebook computer, a handheld computing device (e.g., a PDA), an Internet appliance, a telephone, an electronic reader device, an SDR, or any other such device connectable to the computer network.","In addition, software embodying the present invention, in one embodiment, resides in an application or other program running on the computer system . In at least one embodiment, the present invention is embodied in a computer-readable program medium usable with the general-purpose computer system . In at least one embodiment, the present invention is embodied in a data structure stored on a computer or a computer-readable program medium. In addition, in one embodiment, the present invention is embodied in a transmission medium, such as one or more carrier wave signals transmitted between the computer system  and another entity, such as another computer system, a server, a wireless network, etc. The present invention also, in an embodiment, is embodied in an application programming interface (API) or a user interface. In addition, the present invention, in one embodiment, is embodied in a data structure.","Further, in describing the embodiments of the invention illustrated in the figures, specific terminology is used for the sake of clarity. However, the invention is not limited to the specific terms so selected, and each specific term at least includes all technical and functional equivalents that operate in a similar manner to accomplish a similar purpose."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["The advantages and aspects of the present invention will be more fully understood in conjunction with the following detailed description and accompanying drawings, wherein:",{"@attributes":{"id":"p-0062","num":"0079"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0063","num":"0080"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0064","num":"0081"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0065","num":"0082"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0066","num":"0083"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0067","num":"0084"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0068","num":"0085"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0069","num":"0086"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0070","num":"0087"},"figref":["FIG. 7","FIG. 6A","FIG. 6B"]},{"@attributes":{"id":"p-0071","num":"0088"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0072","num":"0089"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0073","num":"0090"},"figref":["FIG. 10","FIGS. 8 and 9"]},{"@attributes":{"id":"p-0074","num":"0091"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0075","num":"0092"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0076","num":"0093"},"figref":["FIG. 13","FIGS. 11 and 12"]},{"@attributes":{"id":"p-0077","num":"0094"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0078","num":"0095"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0079","num":"0096"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0080","num":"0097"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0081","num":"0098"},"figref":["FIGS. 18A-18F","FIGS. 6-11"]},{"@attributes":{"id":"p-0082","num":"0099"},"figref":["FIG. 19A-19B","FIGS. 18A-18F"]}]},"DETDESC":[{},{}]}
