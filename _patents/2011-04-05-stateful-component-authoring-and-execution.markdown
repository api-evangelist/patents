---
title: Stateful component authoring and execution
abstract: A method for of authoring and executing stateful components for a distributed application is disclosed. An application schema for the distributed application is declaratively defined and includes a plurality of distributed modules. Each module hosts a set of stateful components co-located in a physical tier of a distributed environment having logic to manipulate state. The runtime supports partitioning the stateful components. Control flow opaqueness of component logic is banished in each of the stateful components, which would otherwise occur if state was externalized.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09465589&OS=09465589&RS=09465589
owner: Microsoft Technology Licensing, LLC
number: 09465589
owner_city: Redmond
owner_country: US
publication_date: 20110405
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Distributed computing applications are often deployed into environments having a multitude of different technologies and services that are used to form building blocks of the applications. Examples of distributed applications are legion and can include enterprise applications such as line of business or LOB, billing systems, customer relationship management or CRM, enterprise resource planning or ERP, business intelligence, human resource management, manufacturing, inventory control applications, and others. Such applications include components that are typically distributed across tiers in a computer network. Also, some applications are intended to run in a cloud computing environment, others are intended to run on the premises of the entity or user, and others are intended to span these environments. Further, the environment may change as an application evolves, the number of users change, or the locations of the users become dispersed.","One desirable characteristic of a distributed application is its ability to scale, or to cost-effectively change with the enterprise. Existing program models do not aim to support the development of scalable distributed applications. Typical component models are designed for desktop applications and are tier and technology specific. A distributed application is typically comprised of a set of distinct components, spread across tiers, which interact to perform work. While the components are virtualized, the relationship between the components is not. A physical wiring of components during runtime interaction is typically statically determined or otherwise hard-coded in this framework, which can place limits on the ways in which the application can be scaled or even on the application's overall ability to scale. While working with such models, many developers try to avoid writing stateful components because they are difficult to scale, but in making this choice the developer sacrifices benefits of other approaches, such as the natural expression of application logic.","Current techniques of state partitioning and replication are limited to high-end developers and are implemented by technologies of databases and distributed caches. Furthermore, current program models stich together components into composites in an ad hoc manner, which results in poorly scalable applications. There is no program model, however, that makes these techniques and technologies approachable and mainstream for developers to use in writing and scaling application state logic.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","The present disclosure is directed to an extensible framework that supports the authoring and execution of highly scalable and available stateful components. In one example, the extensible framework can be built on another framework. Stateful components co-locate state with logic that manipulates that state. Because the state accessed by the logic is local, the latency of data access is reduced, i.e. improved, as compared to a solution where the state is remote. Additionally, the logic of the component can be expressed more naturally and succinctly than if the state were externalized. A distributed component model and distributed composition runtime provide general-purpose support for component partitioning and replication techniques, which achieve high scalability and availability.","In one example, the disclosure is directed to a method for of authoring and executing stateful components for a distributed application. An application schema for the distributed application is declaratively defined and includes a plurality of distributed modules. Each module hosts a set of stateful components co-located in a physical tier of a distributed environment having logic to manipulate state. Runtime supports partitioning the stateful components. Control flow opaqueness of component logic is banished in each of the stateful components, which would otherwise occur if state was externalized.","In the following Detailed Description, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims. It is to be understood that features of the various exemplary embodiments described herein may be combined with each other, unless specifically noted otherwise.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},"The exemplary computer system includes a computing device, such as computing device . In a basic configuration, computing device  typically includes a processor system having one or more processing units, i.e., processors , and memory . Depending on the configuration and type of computing device, memory  may be volatile (such as random access memory (RAM)), non-volatile (such as read only memory (ROM), flash memory, etc.), or some combination of the two. This basic configuration is illustrated in  by dashed line . The computing device can take one or more of several forms. Such forms include a person computer, a server, a handheld device, a consumer electronic device (such as a video game console), or other.","Computing device  can also have additional features or functionality. For example, computing device  may also include additional storage (removable and\/or non-removable) including, but not limited to, magnetic or optical disks or solid state memory, or flash storage devices such as removable storage  and non-removable storage . Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any suitable method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile discs (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, universal serial bus (USB) flash drive, flash memory card, or other flash storage devices, or any other medium that can be used to store the desired information and that can be accessed by computing device . Any such computer storage media may be part of computing device .","Computing device  includes one or more communication connections  that allow computing device  to communicate with other computers\/applications . An example communication connection can be an Ethernet interface. In some examples, the computing device can also have one or more additional processors or specialized processors (not shown) to perform processing functions offloaded from the processor . Computing device  may also include input device(s) , such as keyboard, pointing device (e.g., mouse), pen, voice input device, touch input device, etc. Computing device  may also include output device(s) , such as a display, speakers, printer, or the like.","The computing device  can be configured to run an operating system software program and one or more software applications, which make up a system platform. In one example, the computing device  includes a software component referred to as a managed, or runtime, environment. The managed environment can be included as part of the operating system or can be included later as a software download. Typically, the managed environment includes pre-coded solutions to common programming problems to aid software developers to create applications, such as software programs, to run in the managed environment. An example of a managed environment can include an application framework sold under the trade designation .NET Framework available from Microsoft, Inc. of Redmond, Wash. U.S.A.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","100","100"]},"The programming model  includes a distributed component model , a distributed component runtime , and a distributed application model . The distributed component model  includes an extensible component abstraction that is technology and tier neutral and is consistent across cloud and premise environments. The distributed component model  provides support for stateless and stateful components, and provides for cloning, partitioning, and replication techniques used to scale the distributed application. The distributed component runtime  includes a distributed composition engine that virtualizes the component and inter-component interactions to shield code of the distributed application from disruptions caused by scaling out the application with cloning, partitioning, and replication strategies. In one example, the composition engine is lightweight and rehostable. The distributed composition runtime  brokers component interactions and also shields the distributed application from logical to physical address resolution and partition-aware routing. The distributed application model  provides a way to describe the distributed application components and the relationships between the components. In one example, the distributed application model  can include an application manifest and artifacts that can be serialized or presented in a graphic visualization within an integrated development environment, or IDE.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["300","302","300","302","202","300","302","304","304","304","304","306","306","306","306","302","306","306","302"],"i":["a","n","a","n ","a","n","a","n ","a","n "]},"The distributed application  has an identity and is a unit of deployment and management in the application fabric. When deployed, the application  spans tiers in the environment. Examples of tiers can include a client tier in many forms; a web tier, which is typically stateless, that can be available all of the time; a worker tier, including stateless and stateful components, that provides much of the logic of the application ; and a storage tier that can be located on premises, in the cloud environment, or in a combination of the two. (Stateless can include abstractions that have no state or externalize state.) In one example, the application  is deployed to application fabric host farms. Physically, the application includes a package containing an application manifest that describes the compositional structure of the application, implementation details, configuration, and application artifacts. The application  in the example also corresponds to a tenant in the distributed component model and can include tenants of its own. This provides a layered and extensible tenant model that can be used for billing, throttling, metering, and the like.","Modules -are a logical grouping of one or more components -. For example, modules -are each a tier-specific unit of hosting, which includes aspects of activation, scalability, availability, and isolation. Components -in module are deployed to the same host or single process and are typically co-located in the execution environment. The components -often leverage the co-location for data affinity or the like.","In one example, each module is a tier-specific unit of hosting. Each module -can have an associate role such as a worker in a worker module or web in a web module. Several types of modules can exist in the distributed component model, and the module types correspond to the capabilities of the hosting environment. Such module types can include browser, Web, stateless, stateful, and storage. The browser module can be hosted in a Web browser. The Web module is hosted on web hosts. A stateless module can include stateless components on modules capable of hosting stateless components, such as worker role or an application fabric role. A stateful module includes stateless components and can be hosted in a fabric-aware host. The storage module can be hosted on storage servers such as, for example, SQL (structured query language) database servers.","The modules -can also include cross-cutting aspects, which include aspects and filters to lift cross cutting concerns such as logging, throttling, and metering, and the like out of the application logic. In the distributed component model, the module can have zero or more cross cutting aspects associated with it. In one example, the cross cutting aspects reflect the core Aspect Oriented Programming (AOP) idioms. For example, each aspect can include zero to n advices, policy metadata, and a jointpoint for which it is being invoked. Also, each advice can include zero to n pointcuts and zero to n subscribers. The pointcut is a predicate, i.e., a LINQ expression, evaluated at a jointpoint. (Language Integrated Query (LINQ) is a trade designation for a data query component available from Microsoft, Inc., in the Microsoft.NET Framework that adds native data querying capabilities to .NET languages, such as C-sharp (C#)). Upon pointcut evaluation, all Before, After, and Around advices are invoked.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["306","202","306","402","404","406","408","410","306","306"],"i":["a","a ","a","n "]},"The component encapsulates a certain technology . Such technologies can include, for example, web application technologies or application programming interfaces (APIs) for building connected, service-oriented applications. More than one component type can be developed for a given technology. For example, the application  could include a web application component and a service component in the web tier, a code component, a cache component, and a workflow component in the worker tier, and various storage components (such as tables or queues) and an SQL database component in the storage tier. In one example, the component is a wrapper  around a set of functionality. This wrapper  hides the implementation details of the component yet exposes the functionality and dependencies that can allow loose coupling between service provider and consumers.","The component can include artifacts  and define the metadata  at runtime. In one example, a component metadata  can include a security configuration. A component artifact  can include configuration files, binaries, user code, and the like. Component metadata  and artifacts  can be captured in the application manifest and are made available to the component at runtime.","Components -can export, i.e., offer, a set of capabilities and can import, i.e., use, a set of capabilities. A component can export a capability or a service that can be consumed by other components. Also, a component can import a capability or a service for consumption from another component in the application  or from an external service. Thus, component exports  and component imports  are the mechanisms by which the components -are stitched together to form the application . Stitching may be described at the design stage or can be dynamic in that available exports can be discovered, imported, and used at runtime. In either case, the stitching is a logical expression of a component relationship. The procurement of proxies and the resolution of physical addresses to get two component instances communicating are brokered at runtime.","The component export  is a declarative specification of a capability offered at runtime. The component export  can also represent an external piece of the application that is not part of the application being modeled. For example, an export  can represent a message queuing technology such as one offered under the trade designation of MSMQ available from Microsoft, Inc. or a web service such as one offered under the trade designation of Amazon Web Services (AWS) available from Amazon.com of Seattle, Wash. U.S.A. The component export  also includes runtime logic to manufacture proxies that component imports can use. Component exports  can be made visible at different scopes such as within the application or externally. Similar to components -, component exports  are associated with metadata and artifacts. Within the application , an export  can be identified by a contract and a logical address. The shape and semantics of the contract can be related to the technology  used and is opaque to the distributed component model. In one example, component exports  are reusable, and independent software vendors can provide the components exports  as a library. The component export includes metadata regarding cardinality, which specifies the number of imports acceptable to the component: none, one, or more than one.","A component import  is also a declarative specification of a capability consumed by an instance of the component . Component imports  are satisfied by component exports from other components that match the criteria of the component import , and matching criteria is expressed as a declarative predicate on the component import . The predicate is evaluated to match\/select from a set of available component exports visible scope of the component requesting the import. In one example, the component will determine a match based on the name of the predicate, but the component can also determine a match on import\/export metadata specified by an author of the component or the application . The component import  typically includes metadata regarding to cardinality, which specifies the number of exports acceptable to the component : none, one, or more than one.","Composition of components in the distributed application  can be static or dynamic. In static composition, the relationships between importing and exporting components are established statically and at design time. Static composition is a degenerate case of the more general dynamic composition. In static composition, the importing component includes an import predicate that is set to a known value. The known value does not change at runtime and thus it is possible to determine the matching exporting components statically at design time. This type of composition lends itself to a complete static analysis of the composite application. In dynamic composition, the relationships between importing and exporting components are established dynamically and at run time. Matching of components is established by the distribute composition runtime  and includes evaluating import predicates against available exports within the scope or visibility of the importing component.","The distributed component model  provides a mechanism for declaratively describing and constructing the distributed application  in an application definition. The application definition describes a form of a type system that captures the components -within the application , the producer-consumer relationships between the components -, and any external components or services consumed by components -in the application . The application definition describes the configuration and constraints of the components as well as component dependencies, interrelationships, and interactions of the distributed application in a declarative manner. The application definition also provides the ability to schematize and extend the compositional structure and metadata, such as metadata , in a format\/representation agonistic manner. It can be use to validate the compositional structure of the distributed application  as well as enforce the composition structure at runtime. Such a representation of compositional structure of an application having complex interactions among a set of distributed components provides the ability to reason over an application lifecycle and can be used to scale the distributed application  in a distributed environment.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5","b":["500","500","502","504","504","506","506","504","300","502","504","504","304","304","506","506","306","306","508","510","512"],"i":["a","n","a","n ","a","a","n ","a","n","a","n ","a","n"]},"The definition constructs include a declarative description of the corresponding application, module, and component. Each definition construct includes associated metadata that further describes the construct. In one example, the component definitions -for the application each includes a common set of metadata that describe the aspects of the corresponding component. Similarly, the module definitions -for the application each include a common set of metadata that describe the aspects of the corresponding module. The component import definitions , the component export definitions , and the component aspect definitions  can each include common sets of metadata. In addition to the common set of metadata, each component definition can specify component-specific metadata, which is also true for module, component export, component import, and component aspect definitions. In one example, the component-specific metadata is opaque to the distributed component model and is understood by the component and other components that consume it. The application definition  in the distributed component model is validated to enforce component interrelationship and metadata. Each definition construct can also specify custom validation logic against the application definition.","The distributed programming model  provides developers and enterprises the ability to cost-effectively build, run, and evolve the distributed application . Both stateful and stateless components can be developed using familiar technologies, emerging technologies, and custom paradigms for specific domains. The components -can be stitched together either statically or dynamically to form the application . Cloning, replication, and partitioning are supported within the application , as is the ability to make architectural tradeoffs such as among consistency, availability, and tolerance of \u201cpartitions\u201d (such as describe in Brewster's CAP Conjecture).","The distributed programming model  provides for scalable applications to include the techniques of cloning, replication, and partitioning. Different techniques may apply to different parts of the application , which may change over time as the application grows. For example, cloning is a relatively straightforward technique, but in certain technologies it is exclusively suited for stateless components. Replication is currently an effective technique for stateful components, but it can be complex and limited. For example, the amount of state can grow during the life of the application  such as in the form of user sessions or cached data that are replicated across machines, or a row-locking scheme in a shared store that becomes the bottleneck to the performance of the application . In order to address the issue of growing state, a developer may choose to partition one or more components, which previously involved a costly and difficult re-architecture of the application .","In order to avoid a costly re-architecture, the application  is initially designed in a distributed component model  to support partitioning, which can be used regardless of whether application growth is anticipated. Design patterns and use of a distributed component runtime  can make intra-component wiring immune to otherwise invasive changes such as sharding, which is typically know as horizontal partitioning of a database, and component partitioning. Partitioning is made available in the application  and then is activated as desired. The application  can be readily designed to map the partitions to machines as well. Additionally, the developer can retain flexibility about whether a component or the entire application  runs on premise or in a cloud-computing environment. As the costs of infrastructure change over time, the architecture of the application  can naturally evolve to take advantage of the relative cost changes.","A component is \u201cpartitioned\u201d when a given job belongs to only one part and can be performed only on the node that owns the part. The total job responsibilities of the component are split into multiple parts and each node that hosts the component owns one or more parts. This pattern, when applied to stateful services, overcomes the limitation that exists for \u201ccomponent cloning.\u201d","Partitions can be made to be mutually exclusive of one another. Mutually exclusive partitions do not overlap one another. The following example provides an illustration as to correct and incorrect partitioning of a three digit \u201cOrder-Id\u201d range:\n\n","A partition can also be a unit of load balancing. In this respect, partitions become more efficient as they approach equal load. The following example provides an illustration as to an advantageous and disadvantageous partitioning of a consumer credit score range given that most credit scores are between 600 and 750.\n\n","Additionally, partitions can be made atomic. Each atomic partition lives and fails as a unit. Each atomic partition is a single point of failure unless backups such as replicas are maintained using a process called replication. Under replication, a primary partition can include one or more replicas, such as secondary or tertiary replicas that are configured to assume the role of a primary partition in case the primary partition fails. In one example, the primary and its replicas are each maintained on separate nodes or machines, which helps ensure the high availability of the component.","The clients address the service with a logical address. In one example, the client side will provide an address resolution from logical address to physical address on the client side at runtime. In some circumstances, this can be avoided on messages where a partitioning key is part of the message. The client requests the naming service for the routing table for the given logical address and then looks up the physical address. The partitioning scheme and context are defined on the server and are brought to the client side as part of routing table. For example, the client sends a message to the service with a request for \u201cHotel Search Information.\u201d The service will respond with a key from a key generation function that asks for a city. The client provides a partitioning key with \u201cSeattle.\u201d The service can produce a list from the portioning function with \u201c1\u201d represents Seattle and \u201c2\u201d represents London. The partitioning ID is set to \u201c1.\u201d The look up routing table will use the partitioning ID to find the correct address of the desired service.","Each module can be a logical grouping of related components -for the purposes of co-location and partitioning. Components -grouped together within a module can run within the same application domain. For example, two or more components -can be co-located if they abide by the same partitioning scheme. In a partitioned module, each part is independent of the others and hence receives its own application domain within which the set of co-partitioned components for the corresponding part will run. The components -within a module, such as module , can communicate via direct method invocations. Across modules -, components communicate by sending messages. A module type can correspond to the capability of the host. For example, a stateless component, such as a web role, is hosted in a stateless module. Execution environments for modules include web and worker roles for stateless components and a fabric role for stateful components.","During runtime, the distributed programming model  can monitor the application  to diagnose and repair issues as well as meter the use of the components -. The distributed component model  can elastically allocate and reclaim resources to support a fluctuating demand. Further, the distributed programming model  provides for the ability to later partition the application , co-locate partitioned components -, change a mapping of partitions to a physical infrastructure, and shard a database without costly re-architecture.","In one example, an application fabric available under the trade designation of AppFabric can run on premise, such as a server operating system available under the trade designation of Windows Server, and in a cloud environment having a cloud computing or cloud services operating system available under the trade designation Windows Azure, all available from Microsoft, Inc., allowing entire applications (or components within them) to be deployed to either environment or a combination the two. Web roles, workflow, and the like can be built using developer tools such as those sold under the trade designations of Windows Communication Foundation (WCF) and Windows Workflow Foundation (WF) available from Microsoft, Inc.","Designers of distributed applications wrestle with tradeoffs. Central to this struggle is Brewer's CAP Conjecture, which states in part that a system cannot at once be consistent, available, and partition-tolerant but selects two of these desirable characteristics. (Note that the concept of a \u201cpartition\u201d in the context of the CAP conjecture is different than the idea of \u201ccomponent partitioning\u201d which is described in this document as a technique for achieving scalability.) Stateless components and stateful components often use different techniques to scale. As alluded to above, components that do not manage state can be straightforwardly cloned in order to achieve scalability. Components that do manage state are harder to scale, and stateful components are not cloned because doing so would violate the current principles of state consistency. Typical application designs tend to externalize the state of such a component and scale the state differently than the stateless logic, which at times can be a good approach. More frequently, however, there are benefits to co-locate state, rather to externalize state, with the logic that manipulates that state, i.e., a stateful component.","In a (truly) stateless component, the output of a request to the component is purely a function of the input. For example, the following component sets forth a stateless web service with various calculator methods:",{"@attributes":{"id":"p-0053","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"public interface IStatelessCalculator",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003int Add(int x, int y); \/\/ returns x + y",{}]},{"entry":[{},{},"\u2003int Subtract(int x, int y); \/\/ returns x \u2212 y",{}]},{"entry":[{},{},". . .",{}]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In stateful components, however, the output of a request to the component is a function of the input, plus some data that was materialized in the context of previous requests. For example, a web service with various calculator methods is stateful if it keeps track of a \u201ccurrent value\u201d much like a hand-held calculator does:",{"@attributes":{"id":"p-0055","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface IStatefulCalculator",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003void Enter(int x); \/\/ sets \u2018current value\u2019 to x",{}]},{"entry":[{},"\u2003void Clear( ); \/\/ like calling Enter(0);",{}]},{"entry":[{},"\u2003int Add(int x); \/\/ \u2018current value\u2019 += x, returns new value",{}]},{"entry":[{},"\u2003int Subtract(int x); \/\/ \u2018current value\u2019 \u2212= x, returns new value",{}]},{"entry":[{},"\u2003. . .",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The stateful calculator can be a singleton, or, more usefully, can support many instances. In the latter case, each request will indicate which calculator instance the request is targeting, either explicitly (such as with a \u201cCalculatorId\u201d parameter of each operation) or using some other mechanism tied to the broader technical design of the service (e.g. a \u201cCalculatorId\u201d value in a request message header).","Stateless components can be cloned to achieve scalability and high availability. But providing scalability and high availability for a stateful component does not come so easily. A previous technique of simulated cloning for stateful components includes externalizing state of the stateful component. This technique allows the component logic to be stateless, and therefore capable of being cloned. Despite the apparent similarity, there are very real differences between truly stateless components and \u201ccomponents with stateless logic, which externalize their state.\u201d For example, when handling a request, the stateless component logic retrieves previously externalized state using a key provided within the request:",{"@attributes":{"id":"p-0058","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["public class StatefulCalculator : IStatefulCalculator",{}]},{"entry":["{",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003public int Add(int x)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003long calculatorId = . . . \/\/ obtain value from request message",{}]},{"entry":[{},"\u2003\u2003header",{}]},{"entry":[{},"\u2003\u2003int currentValue = (int) GetDurableValue(calculatorId,",{}]},{"entry":[{},"\u2003\u2003\u201cCurrentValue\u201d);",{}]},{"entry":[{},"\u2003\u2003return currentValue + x;",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003. . .",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["}",{}]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Although this development technique is viable and widely practiced, it has costs in terms of efficiency. First, the method used to author the component is unnatural. In the example above, durable data is stored and retrieved using application programming interfaces. In an example to simplify some of the complexity in this entails, sessions, as in ASP.NET, remove the prerequisite for the \u201cCalculatorId\u201d parameter to the \u201cGetDurableValue\u201d method in the code snippet above because there is an implicit session ID that scopes the externalized data available to the current request handling logic. Even while it is possible to simplify over some of the complexity, the opaqueness of the data flow of the component logic, especially across multiple operations, cannot be avoided. Exacerbating the problem, the overall (cross-request) control flow (request sequencing, branching, looping, parallelism) of a stateful component is difficult to express succinctly and readably using this approach. So control flow is also opaque.","Second, this technique is error-prone and susceptible to subtle bugs in code. For example, the code above returned the correct result, but it does not set the durable state of the current calculator instance to \u201ccurrentValue+x\u201d in order to handle multiple instances.","Third, the medium for storing the externalized component state itself must be designed for scale and high availability. So the problem of avoiding the limitation state is not really solved, just moved to a different part of the application architecture. In this technique, the state will typically need to be replicated eventually, which brings with it the limitations of the CAP Conjecture.","Therefore, regardless of whether a developer chooses to externalize component state or embody the state in the component logic itself, such as in Windows Work Flow, the framework will eventually partition the state in order to scale. In fact, even a component that is stateless with respect to inbound requests, i.e. there are no sessions, can be usefully partitioned if it uses external data (not scoped to a user request) that can be cached in a partitioned manner as part of that component.","In order to address the problems of the current techniques, the programming model provides a scalability tool to design stateful components or applications to be capable of being partitioned, or partitionable, from the outset. The scalability tool also allows for application logic to be expressed in a natural way, which makes code easier to write and enhance than in the techniques described above. A simple illustrative example of a partitionable stateful component is a version of the stateful calculator service that keeps the \u201ccurrentValue\u201d in a member variable, where it can be naturally accessed by all of the calculator's methods:",{"@attributes":{"id":"p-0064","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"public class StatefulCalculator : IStatefulCalculator",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003[Replicable]",{}]},{"entry":[{},{},"\u2003int currentValue; \/\/ will be replicated",{}]},{"entry":[{},{},"\u2003[ReplicateOnExit]",{}]},{"entry":[{},{},"\u2003public int Add(int x)",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003this.currentValue += x;",{}]},{"entry":[{},{},"\u2003\u2003return currentValue;",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"\u2003. . .",{}]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The programming model also provides other pathways to explore new models for stateful components. As another example, component logic can explicitly manipulate distributed collections.","As a different example includes stateful program instances, i.e., where the program instance itself is the state, (such as in a developer tool such as Windows Workflow Foundation) banishes control flow opaqueness. This can be expressed as a textual representation or other representations such as XAML and the like. An example of a textual representation can appear as:",{"@attributes":{"id":"p-0067","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"int currentValue = 0;",{}]},{"entry":[{},{},"bool done = false;",{}]},{"entry":[{},{},"\/\/ the instance state is replicated at idle points",{}]},{"entry":[{},{},"while (!done)",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003parallel",{}]},{"entry":[{},{},"\u2003{",{}]},{"entry":[{},{},"\u2003\u2003receive (Exit( ))",{}]},{"entry":[{},{},"\u2003\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\u2003done = true;",{}]},{"entry":[{},{},"\u2003\u2003}",{}]},{"entry":[{},{},"\u2003\u2003receive (Add(int x))",{}]},{"entry":[{},{},"\u2003\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\u2003currentValue += x;",{}]},{"entry":[{},{},"\u2003\u2003\u2003return currentValue;",{}]},{"entry":[{},{},"\u2003\u2003}",{}]},{"entry":[{},{},"\u2003\u2003receive (Subtract(int x))",{}]},{"entry":[{},{},"\u2003\u2003{",{}]},{"entry":[{},{},"\u2003\u2003\u2003currentValue \u2212= x;",{}]},{"entry":[{},{},"\u2003\u2003\u2003return currentValue;",{}]},{"entry":[{},{},"\u2003\u2003}",{}]},{"entry":[{},{},"\u2003}",{}]},{"entry":[{},{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Thus, the programming model  can provide application developers with choices for developing stateful components that can be built naturally, without sacrificing scalability.","The following provides an example application programming interface constructed to provide scalability tools:",{"@attributes":{"id":"p-0070","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"301pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"publicabstractclassStatefulComponent<T> : StatefulComponent, IRequestHandlerProvider,",{}]},{"entry":[{},"IServiceProvider, IRequestHandler",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\/\/ Methods",{}]},{"entry":[{},"protectedIAsyncResultBeginCreateState(Partition partition, T state, string version, AsyncCallback callback,",{}]},{"entry":[{},"object asyncCallbackObject);",{}]},{"entry":[{},"protectedIAsyncResultBeginDeleteState(Partition partition, T state, string version, AsyncCallback callback,",{}]},{"entry":[{},"object asyncCallbackObject);",{}]},{"entry":[{},"protectedIAsyncResultBeginUpdateState(Partition partition, T state, string version, AsyncCallback",{}]},{"entry":[{},"callback, object asyncCallbackObject);",{}]},{"entry":[{},"protectedReplicationResultEndCreateState(IAsyncResult result);",{}]},{"entry":[{},"protectedReplicationResultEndDeleteState(IAsyncResult result);",{}]},{"entry":[{},"protectedReplicationResultEndUpdateState(IAsyncResult result);",{}]},{"entry":[{},"protectedvirtualCollection<T>OnCopyState(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedvirtualvoidOnCreateState(StatefulComponentExecutionContext executionContext, Partition",{}]},{"entry":[{},"ownerPartition, string version, T state);",{}]},{"entry":[{},"protectedvirtualvoidOnDeleteState(StatefulComponentExecutionContext executionContext, Partition",{}]},{"entry":[{},"ownerPartition, string version, T state);",{}]},{"entry":[{},"protectedoverridevoidOnLoad(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedoverridevoidOnPartitionChanged(StatefulComponentExecutionContext executionContext, bool",{}]},{"entry":[{},"isPartitionOwned, Partition partition);",{}]},{"entry":[{},"protectedvirtualvoidOnProcessRequestAsync(StatefulComponentExecutionContext executionContext,",{}]},{"entry":[{},"StateChangeRequestType requestType, string version, T state, Action<HttpStatusCode, string, T,",{}]},{"entry":[{},"ErrorResource> callback);",{}]},{"entry":[{},"protectedvirtualvoidOnPurgeState(StatefulComponentExecutionContext executionContext, Partition",{}]},{"entry":[{},"ownerPartition);",{}]},{"entry":[{},"protectedvirtualvoidOnReplaceState(StatefulComponentExecutionContext executionContext, Partition",{}]},{"entry":[{},"ownerPartition, Collection<T> stateSnapshot);",{}]},{"entry":[{},"protectedoverridevoidOnStart(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedoverridevoidOnStop(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedoverridevoidOnUnload(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedvirtualvoidOnUpdateState(StatefulComponentExecutionContext executionContext, Partition",{}]},{"entry":[{},"ownerPartition, string version, T state);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"publicclassStatefulComponent : Component, IStatefulComponent",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\/\/ Methods",{}]},{"entry":[{},"publicstaticstringGetPartitionKey<TState>(TState state);",{}]},{"entry":[{},"protectedvirtualvoidOnFault(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedvirtualvoidOnLoad(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedvirtualvoidOnPartitionChanged(StatefulComponentExecutionContext executionContext, bool",{}]},{"entry":[{},"isPartitionOwned, Partition partition);",{}]},{"entry":[{},"protectedvirtualvoidOnStart(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedvirtualvoidOnStop(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"protectedvirtualvoidOnUnload(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"}",{}]},{"entry":[{},"publicinterfaceIStatefulComponent",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\/\/ Methods",{}]},{"entry":[{},"IEnumerable<ReplicationOperation>GetCopyOperations(StatefulComponentExecutionContext",{}]},{"entry":[{},"executionContext, long maxSequenceNumber);",{}]},{"entry":[{},"voidOnApplyOperation(StatefulComponentExecutionContext executionContext, Partition ownerPartition,",{}]},{"entry":[{},"ReplicationOperation operation);",{}]},{"entry":[{},"voidOnClearOperations(StatefulComponentExecutionContext executionContext);",{}]},{"entry":[{},"voidOnOperationDataLost(StatefulComponentExecutionContext executionContext, long epoch);",{}]},{"entry":[{},"voidOnOperationReplicated(StatefulComponentExecutionContext executionContext, ReplicationOperation",{}]},{"entry":[{},"operation);",{}]},{"entry":[{},"voidOnPartitionChanged(StatefulComponentExecutionContext executionContext, bool isPartitionOwned);",{}]},{"entry":[{},"voidOnReplicaRoleChanged(StatefulComponentExecutionContext executionContext, ReplicaRole oldRole,",{}]},{"entry":[{},"ReplicaRole newRole);",{}]},{"entry":[{},"\/\/ Properties",{}]},{"entry":[{},"stringName { get; }",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In still a further example, Object-relational mapping can be integrated with stateful components. An Object-relational mapping (often referred to as ORM, O\/RM, or O\/R mapping) is a programming technique for converting data between incompatible type systems in object-oriented programming languages. An example Object-relational mapping software is sold under the trade designations \u201cEntity Framework\u201d or \u201cADO.NET Entity Framework\u201d available from Microsoft for the .NET Framework, which uses object contexts. The ObjectContext class is the primary class for interacting with data as objects that are instances of entity types that are defined in a conceptual model. An instance of the ObjectContext class encapsulates the following: connection to the database such as in the form of an EntityConnection object; metadata that describes the model such as in the form of a MetadataWorkspace object; and an ObjectStateManager object that manages objects persisted in the cache. When the object layer that represents a conceptual model is generated by the Entity Data Model tools, the class that represents the EntityContainer for the model is derived from the ObjectContext. ObjectContext provides the Object-relational mapping against an SQL database. ObjectContext is also used in tools such as Windows Control Flow (WCF) Data Services. In one example, each \u201cWindows Control Flow Data Service\u201d instance has an associated ObjectContext.","In the example, each ObjectContext is treated as an item in the per partition dictionary kept by the stateful component. The stateful component in the example can disregard whether the value in the dictionary is of type ObjectContext. The method simply inherits from ObjectContext and wire-up Replicate( ) methods in its SaveChanges and can replicate the state inside the context using System.Data as follows:",{"@attributes":{"id":"p-0073","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public abstract class ReplicableObjectContext : ObjectContext"},{"entry":"{"},{"entry":"public ReplicableObjectContext (string replicationBatchIdentifier)"},{"entry":"{ }"},{"entry":"\/\/TODO: override other base class constructors and explicitly take replicationBatchIdentifier"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public string ReplicationBatchIdentifier"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"308pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u2003get;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"publicoverride int SaveChanges(SaveOptions options)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/look for changed entities"]},{"entry":[{},"Var modifiedEntities = ObjectStateManager.GetObjectStateEntries(EntityState.Modified |"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"EntityStateAdded | EntityState.Deleted);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/TODO: var replicableEntities = loop over entities and find.Entity that has [Replicable] attribute"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"on it."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"StatefulComponent sc = this.ExecutingComponent as StatefulComponent;"]},{"entry":[{},"sc.Replicate(this.replicationBatchIdentifier, replicableEntities);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"294pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public IAsyncResult BeginSaveChanges(SaveOptions options, ...)"]},{"entry":[{},"{"]},{"entry":[{},"}"]},{"entry":[{},"public int EndSaveChanges(IAsyncResult result)"]},{"entry":[{},"{"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In distributed applications created using the distributed component model , the distributed component runtime  is used to broker component interactions. Interactions between components in the distributed application  are virtualized with logical addresses that are mapped to physical addresses with the distributed component runtime . The distributed component runtime  arbitrates the procurement of physical addresses from the hosting environment, maintains a logical to physical address mapping, and performs the logical to physical translation at runtime. Composition of components is agnostic of the locality of the importing and exporting components. In the distributed component model , an importing component does not know the physical address of the exporting component. The distributed component runtime  provides the logical to physical translation of addresses at application runtime when these interactions materialize. Logical addresses are assigned to component exports and are used to reference components in the application . Distributed component runtime  also addresses and routes to the appropriate partition.","In one example, a distributed application manifest provides the distributed application model  in definition constructs expressing the component configurations and their interrelationships to each other and interactions in a technology and format agnostic manner. The manifest is a serialized form of the application definition  and captures the entire structure of the application . In one example, the manifest is format agnostic and can be serialized in a variety of formats, which can include scripting languages such as extensible markup language (XML), extensible application markup language (XAML), JavaScript object notation (JSON), or binary JSON (BSON) and many others now know or yet to be created. The following example distributed application manifest is serialized in JSON:",{"@attributes":{"id":"p-0076","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u201cName\u201d: \u201cMyApp\u201d,"},{"entry":"\u201cId\u201d: \u201c622BN4TFQB3UHFEERJGFXPVX4A\u201d,"},{"entry":"\u201cBaseUri\u201d: http:\/\/MyApp.cloudapp.net\/,"},{"entry":"\u201cSelfLink\u201d: \u201c. . .\u201d,"},{"entry":"\u201cVersion\u201d: \u201c1.0.0.100\u201d ,"},{"entry":"\u201cReferences\u201d: ["}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"301pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{\u201cType\u201d: \u201cDistributedList\u201d, . . .}, {\u201cType\u201d:\u201cTaskScheduler\u201d,. . . }, {\u201cType\u201d:\u201cCloudQueue\u201d, . . .},"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{\u201cType\u201d: \u201cWCFService\u201d, . . . } ],"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u201cModuleDefinitions\u201d:"},{"entry":"\u2002["}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{\u201cName\u201d: \u201cMyWebModule\u201d, Type\u201d : \u201cWeb\u201d, \u201cInstanceCountHint\u201d: 2, \u201cComponents\u201d: [ { . . . }] },"]},{"entry":[{},"{\u201cName\u201d: \u201cMidTierModule\u201d, \u201cType\u201d : \u201cStateful\u201d, \u201cInstanceCountHint\u201d: 2,"]},{"entry":[{},"\u201cIsolationLevel\u201d: \u201cProcess\u201d, \u201cMachineSize\u201d: \u201cLarge\u201d,"]},{"entry":[{},"\u201cPartitionPolicy\u201d: { \u201cType\u201d: \u201cRangePartitionPolicy\u201d, \u201cKeys\u201d: [ \u201cA-G\u201d, \u201cH-M\u201d,\u201cN-Z\u201d] },"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cReplicaCountHint\u201d: 2, \u201cReplicationFormat\u201d: \u201cJSON\u201d, \u201cWriteQuorum\u201d: 1,"]},{"entry":[{},"\u2002\u201cComponents\u201d:"]},{"entry":[{},"["]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{\u201cName\u201d: \u201cMovieProcessor\u201d, \u201cModuleAffinity\u201d: \u201cStateful\u201d, . . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cImports\u201d:"]},{"entry":[{},"["]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{\u201cName\u201d: \u201cDistributedList\u201d, \u201cCardinality\u201d: \u201cExactlyOne\u201d, \u201cInstancingPolicy\u201d:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cPooled\u201d, \u201cConstraint\u201d: { . . . } } },"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{\u201cName\u201d: \u201cNewMovies\u201d,\u201cCardinality\u201d: \u201cAtleastOne\u201d,\u201cInstancingPolicy\u201d:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cSingleton\u201d,\u201cConstraint\u201d: { . . . } } },"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{\u201cName\u201d: \u201cMovieService\u201d,\u201cCardinality\u201d: \u201cAtleastOne\u201d,\u201cInstancingPolicy\u201d:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cSingleton\u201d,\u201cConstraint\u201d: { . . . } } },"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{\u201cName\u201d: \u201cTaskScheduler\u201d,\u201cCardinality\u201d: \u201cAtleastOne\u201d,\u201cInstancingPolicy\u201d:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u201cSingleton\u201d,\u201cConstraint\u201d: { . . . } } },"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"],"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"287pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2002. . ."},{"entry":"\u2002]"},{"entry":"\u2002. . ."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The manifest includes the application definition , the module definitions -, component definitions -, component exports , component imports , and component aspect definitionss . In the example, the module definitions -include metadata on instances, partitions, and replicas. A stateless module definition can include a declaratively defined instance count that control the number of module instances and describes the scalability and high availability (often referred to as \u201cHA\u201d) characteristics of a stateless module and its corresponding components. A stateful module definition can include a declaratively defined instance count, a partition policy, and a replica count to describe the scalability and high availability characteristics of a stateful module and its corresponding components. In order to evolve or scale the application, a developer adjusts the counts and policies within the metadata of the module definition to a selected amount.",{"@attributes":{"id":"p-0078","num":"0081"},"figref":"FIG. 6","b":["602","304","604","602","606","606","602","604","606","608","608","608","604","608","608"],"i":["a ","a","b","c","a","n "]},{"@attributes":{"id":"p-0079","num":"0082"},"figref":"FIG. 7","b":["702","304","704","702","706","708","710","706","708","710","716","704","706","712","712","712","708","714","712","712","712","716","712","712","712","714","716"],"i":["n ","a","b","c","a","b","c","a","b","c"]},{"@attributes":{"id":"p-0080","num":"0083"},"figref":"FIG. 8","b":["500","800","302","802","302","300","802","306","306","804","302","306","306","302","806","302","304","304","608","304","304","306","306","304","304"],"i":["a","n","a","n ","a","n ","a","n ","a","n ","a","n "]},"Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and\/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of embodiments and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments and together with the description serve to explain principles of embodiments. Other embodiments and many of the intended advantages of embodiments will be readily appreciated as they become better understood by reference to the following detailed description. The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIG. 2"]}]},"DETDESC":[{},{}]}
