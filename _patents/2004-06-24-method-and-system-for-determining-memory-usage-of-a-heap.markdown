---
title: Method and system for determining memory usage of a heap
abstract: A method and system for determining the memory utilization of a heap are provided. With the method and system, object allocations and optionally, possible memory freeing events are used to initiate a mark-and-count operation. The mark-and-count operation marks the live objects and maintains a running count of their memory bytes allocated to the live objects, referred to as a live count. The execution of the mark-and-count operation may be dependent upon various criteria including thresholds, functions of the live count, peak live counts, number of memory bytes allocated since a previous mark-and-count operation was performed, and the like. In addition to the live count, a total number of bytes allocated to objects may be maintained in order to obtain information regarding the heap memory utilization.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444484&OS=07444484&RS=07444484
owner: International Business Machines Corporation
number: 07444484
owner_city: Armonk
owner_country: US
publication_date: 20040624
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present application is related to co-pending and commonly assigned U.S. patent application Ser. No. 10\/875,931 entitled \u201cMethod and System for Obtaining Memory Usage Information for a Heap When a Peak Live Count is Updated,\u201d filed on even date herewith, and hereby incorporated by reference.","1. Technical Field","The present invention is generally directed to an improved data processing system. More specifically, the present invention is directed to a method and system for determining the memory utilization of a heap.","2. Description of Related Art","The memory utilization of a JAVA\u2122 heap is an important characteristic of program performance. Whenever a class instance or array is created in a running JAVA application, the memory of the new object is allocated from a single heap. Because a JAVA application runs inside its \u201cown\u201d exclusive Java Virtual Machine (JVM) instance, a separate heap exists for every Individual running application. As only one heap exists inside a Java Virtual Machine instance, all threads share it.","A \u201cnew\u201d construct in Java is supported in the JVM by allocating memory on the heap for a new object but Java includes no instruction for freeing that memory. The virtual machine itself is responsible for deciding whether and when to free memory occupied by objects that are no longer reference by the running application. Usually, a JVM implementation uses a garbage collector to manage the heap and clean up the heap, i.e. identify objects that no longer have active references in the running application to them and free the memory associated with these \u201cdead\u201d objects.","The garbage collector's primary function is to automatically reclaim the memory used by objects that are no longer reference by the running application. It also can move objects as the application runs to reduce heap fragmentation. The memory that makes up the heap need not be contiguous and can be expanded and contracted as the running program progresses.","Since the heap is a limited resource, it is important to know the live set, i.e. the set of objects that are currently referenced by the running application, at any point in time. The difficulty in obtaining this metric is due to the fact that there is no explicit free event, i.e. an explicit event that itself frees memory associated with \u201cdead\u201d objects, as discussed above. Objects are implicitly freed by reference updating (even an allocation can be freeing memory space) or scope changes (e.g., method\/block exits), but this information is not readily available to the user of performance tooling. Because of this, it is not known at any given time the amount of real live data in the heap. Information about the live set only becomes explicitly available at the time of a full garbage collection and this information may not be completely accurate due to enhanced sweeping mechanisms.","There are numerous situations where this information about the live set is invaluable. For example, with Internet based computing systems, administrators may be interested in understanding and planning for the heap requirements given certain inputs. That is, given a business object of a certain size, it is desirable to determine what the heap requirements are for this object as it flows through the JVM. Actually feeding the business object through the system and observing is possible, however due to reasons above, there is no way to observe or measure the information. Thus, it would be desirable to have a method and system for determining the memory utilization of a heap at any time during operation of the computing system.","The present invention provides a method and system for determining the memory utilization of a heap. With the method and system of the present invention, for each object allocation and possible freeing event, e.g., reference modification, method exit, code block exit, etc., a mark-and-count operation is performed. The mark-and-count operation marks the live objects and maintains a running count of their size. This may be done at a variety of times depending upon the granularity of the information desired. In addition other information may be collected at various times such as a heapdump or call tree.","In one exemplary embodiment, a running count of the number of bytes allocated is maintained along with a running count of the number of bytes associated with live objects. As a result, an indication of the utilization of the heap may be obtained for any particular point in time during operation of the computing system.","In a further embodiment of the present invention, rather than using the mark-and-count operation to collect live object memory usage for the heap with every allocation and possible freeing event, the mark-and-count operation may be performed only when the most current peak live count may be exceeded. With this embodiment, a running count of the total allocation of bytes is maintained (allocation count), a running count of the current allocation of bytes to live objects is maintained (live count), and a current peak allocation of bytes to live objects is maintained (peak live count). A mark-and-count operation is performed on each object allocation event and is not performed on events that may possibly free memory. In addition, if the total bytes allocated since the last measure of the peak live count is less than the peak live count, then the mark-and-count operation need not be performed even though an allocation event occurs. This embodiment helps to reduce the amount of CPU overhead associated with generating the live count information for determining utilization of the heap.","In another embodiment of the present invention, in addition to maintaining the allocation count and live count, a count of the allocated bytes since the last mark-and-count operation is maintained. When this count is greater than a predetermined threshold, a new mark-and-count operation is initiated. This helps to provide an approximation of the heap memory utilization without requiring a mark-and-count operation with every object allocation event and with every possible memory freeing event.","In a further embodiment of the present invention, a low overhead mechanism is provided for determining an approximation of a peak live count for the heap memory utilization. Using a tolerance or threshold approach as discussed above with the determination of the peak live count can provide a peak utilization approximation which can be used to identify memory bottleneck analysis.","With this embodiment, a tolerance or threshold value Is specified that identifies the most that the final peak Live count can differ from the actual peak live count. In addition, an optional lower bound for the start of collection of the peak live count data may be specified. A mark-and-count operation is performed at specific times determined based on a relationship between a number of bytes allocated since a last mark-and-count operation, a number of bytes of memory allocated to live objects at the last mark-and-count operation, an absolute peak live count from a previous mark-and-count operation, and the tolerance or threshold value.","In one exemplary embodiment, a mark-and-count operation is performed when the sum of the number of bytes allocated since a last mark-and-count operation and a number of bytes of memory allocated to live objects at the last mark-and-count operation is greater than the sum of the absolute peak live count and the tolerance or threshold value. This guarantees that a measurement is taken within a threshold number of bytes of the actual peak live data. If the number of live object memory bytes falls well below the previous peak live count, then the overhead for the measurement will become very small.","In yet another embodiment of the present invention, one or more of the above mechanisms for identifying a peak live count is enhanced such that additional information about the heap is obtained when the mark-and-count operation is performed. For example, when a new peak live count is determined to exist and a mark-and-count operation is performed, a heap dump is collected. If a new peak live count is determined to exist, the previously collected heap dump is replaced with a new heap dump collected at the new peak live count point.","In another embodiment, rather than a heap dump, one or more of the above mechanisms for identifying a peak live count is enhanced by incorporating a real time arcflow tool to generate an arcflow tree of the live objects. This arcflow tree may be replaced with a new arcflow tree when a new peak live count is identified.","These and other features and advantages of the present invention will be described in, or will become apparent to those of ordinary skill in the art in view of, the following detailed description of the preferred embodiments.","The present invention is directed to a mechanism for determining heap utilization. The present invention is preferably used with computing devices that are part of a distributed data processing environment, such as the Internet, a wide area network (WAN), local area network (LAN), or the like, but is not limited to such and may be used in a stand-alone computing system or completely within a single computing device. The following  are intended to provide a context for the description of the mechanisms and operations performed by the present invention. The systems and computing environments described with reference to  are intended to only be exemplary and are not intended to assert or imply any limitation with regard to the types of computing system and environments in which the present invention may be implemented.","With reference now to the figures,  depicts a pictorial representation of a network of data processing systems in which the present invention may be implemented. Network data processing system  is a network of computers in which the present invention may be implemented. Network data processing system  contains a network , which is the medium used to provide communications links between various devices and computers connected together within network data processing system . Network  may include connections, such as wire, wireless communication links, or fiber optic cables.","In the depicted example, server  is connected to network  along with storage unit . In addition, clients , , and  are connected to network . These clients , , and  may be, for example, personal computers or network computers. In the depicted example, server  provides data, such as boot files, operating system images, and applications to clients -. Clients , , and  are clients to server . Network data processing system  may include additional servers, clients, and other devices not shown. In the depicted example, network data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the Transmission Control Protocol\/Internet Protocol (TCP\/IP) suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational and other computer systems that route data and messages. Of course, network data processing system  also may be implemented as a number of different types of networks, such as for example, an intranet, a local area network (LAN), or a wide area network (WAN).  is intended as an example, and not as an architectural limitation for the present invention.","Referring to , a block diagram of a data processing system that may be implemented as a server, such as server  in , is depicted in accordance with a preferred embodiment of the present invention. Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors  and  connected to system bus . Alternatively, a single processor system may be employed. Also connected to system bus  is memory controller\/cache , which provides an interface to local memory . I\/O bus bridge  is connected to system bus  and provides an interface to I\/O bus . Memory controller\/cache  and I\/O bus bridge  may be integrated as depicted.","Peripheral component interconnect (PCI) bus bridge  connected to I\/O bus  provides an interface to PCI local bus . A number of modems may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Communications links to clients - in  may be provided through modem  and network adapter  connected to PCI local bus  through add-in connectors.","Additional PCI bus bridges  and  provide interfaces for additional PCI local buses  and , from which additional modems or network adapters may be supported. In this manner, data processing system  allows connections to multiple network computers. A memory-mapped graphics adapter  and hard disk  may also be connected to I\/O bus  as depicted, either directly or indirectly.","Those of ordinary skill in the art will appreciate that the hardware depicted in  may vary. For example, other peripheral devices, such as optical disk drives and the like, also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.","The data processing system depicted in  may be, for example, an IBM eServer pSeries system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced Interactive Executive (AIX) operating system or LINUX operating system.","With reference now to , a block diagram illustrating a data processing system is depicted in which the present invention may be implemented. Data processing system  is an example of a client computer or stand-alone computing device in which the aspects of the present invention may be implemented. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Accelerated Graphics Port (AGP) and Industry Standard Architecture (ISA) may be used. Processor  and main memory  are connected to PCI local bus  through PCI bridge . PCI bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus  may be made through direct component interconnection or through add-in boards. In the depicted example, local area network (LAN) adapter , SCSI host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . Small computer system interface (SCSI) host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in . The operating system may be a commercially available operating system, such as Windows XP, which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provide calls to the operating system from Java programs or applications executing on data processing system . \u201cJava\u201d is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive , and may be loaded into main memory  for execution by processor .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the present invention may be applied to a multiprocessor data processing system.","As another example, data processing system  may be a stand-alone system configured to be bootable without relying on some type of network communication interfaces. As a further example, data processing system  may be a personal digital assistant (PDA) device, which is configured with ROM and\/or flash ROM in order to provide non-volatile memory for storing operating system files and\/or user-generated data.","The depicted example in  and above-described examples are not meant to imply architectural limitations. For example, data processing system  also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system  also may be a kiosk or a Web appliance.","Although the present invention may operate on a variety of computer platforms and operating systems, it may also operate within an interpretive environment, such as a REXX, Smalltalk, or Java runtime environment, and the like. For example, the present invention may operate in conjunction with a Java Virtual Machine (JVM) yet within the boundaries of a JVM as defined by Java standard specifications. In order to provide a context for the present invention with regard to an exemplary interpretive environment, portions of the operation of a JVM according to Java specifications are herein described.","With reference now to , a block diagram illustrates the relationship of software components operating within a computer system that may implement the present invention. Java-based system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. JVM  is one software application that may execute in conjunction with the operating system. Alternatively, JVM  may be imbedded inside a Java enabled browser application such as Microsoft Internet Explorer\u2122 or Netscape Communicator\u2122. JVM  provides a Java run-time environment with the ability to execute Java application or applet , which is a program, servlet, or software component written in the Java programming language. The computer system in which JVM  operates may be similar to data processing system  or computer  described above. However, JVM  may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core. At the center of a Java run-time environment is the JVM, which supports all aspects of Java's environment, including its architecture, security features, mobility across networks, and platform independence.","The JVM is a virtual computer, i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement, with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example, all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.","The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM, which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java run-time system.","The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code.","A JVM must load class files and execute the bytecodes within them. The JVM contains a class loader, which loads class files from an application and the class files from the Java application programming interfaces (APIs) which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.","One type of software-based execution engine is a just-in-time (JIT) compiler. With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for \u201cjitting\u201d a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes, but JVMs may also use other techniques, such as just-in-time compiling, to execute bytecodes.","When an application is executed on a JVM that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","With reference now to , a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM  includes a class loader subsystem , which is a mechanism for loading types, such as classes and interfaces, given fully qualified names. JVM  also contains runtime data areas , execution engine , native method interface , and memory management . Execution engine  is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine  may be, for example, Java interpreter  or just-in-time compiler . Native method interface  allows access to resources in the underlying operating system. Native method interface  may be, for example, a Java native interface.","Runtime data areas  contain native method stacks , Java stacks , PC registers , method area , and heap . These different data areas represent the organization of memory needed by JVM  to execute a program.","Java stacks  are used to store the state of Java method invocations. When a new thread is launched, the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks: it pushes and pops frames. A thread's Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method, the JVM pushes a new frame onto the Java stack of the thread. When the method completes, the JVM pops the frame for that method and discards it.","The JVM does not have any registers for holding intermediate values; any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java instruction set is well-defined for a variety of platform architectures.","PC registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own pc register (program counter) and Java stack. If the thread is executing a JVM method, the value of the pc register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the pc register are undefined.","Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM implementations, native method stacks  and Java stacks  are combined.","Method area  contains class data while heap  contains all instantiated objects. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap, each of which are shared by all threads running inside the JVM. When the JVM loads a class file, it parses information about a type from the binary data contained in the class file. It places this type information into the method area. Each time a class instance or array is created, the memory for the new object is allocated from heap . JVM  includes an instruction that allocates memory space within the memory for heap  but includes no instruction for freeing that space within the memory. Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","The garbage collector performs operations generally referred to as mark\/sweep\/compact. These operations are the marking of live objects and coalescing sequences of dead objects and spaces that are not marked as live to thereby free or reclaim memory space. Any fragmentation caused by the live objects within the heap is compacted during the compact operation. Compaction moves objects toward one end of the heap with the goal of creating the largest possible contiguous free area or areas. Compaction helps to avoid allocating new memory to expand the heap size. More information about garbage collection may be found in Dimpsey et al., \u201cJava Server Performance: A Case Study of Building Efficient, Scalable JVMs,\u201d IBM System's Journal, January 2000, which is hereby incorporated by reference.","The present invention makes use of the mark operation of garbage collection to identify live objects to which memory space is allocated in the heap. Objects are marked (noted as live) by following chains of references from a set of root objects to all other objects they reach. Marks are recorded in an area of memory allocated outside of the heap, referred to as a mark bit array. A single bit in the mark bit array is set as each new live object is discovered Root objects, the initial set of known live objects, are identified by a set of global references (such as objects referenced by the Java Native Interface) and through inspection of the dynamic state of the program. The entire run-time stack of each thread involved in the Java program is scanned, looking for pointers to objects. Because the location of pointers within the stack is uncertain, a combination of tests is applied to each value on the stack to determine whether it may be a pointer to an object. For instance, if the stack variable in question points outside the range of the heap, it certainly is not a pointer to a Java object. If, after these tests, a value appears to be a pointer to an existing object, that object is marked and included in the root set.","When an object is marked, a reference to it is pushed on a stack called the marking stack. The marking stack is processed by popping an object reference and scanning the associated object for references to other unmarked objects. Newly discovered objects are placed on the stack for future processing. The process completes when all root objects have been examined and the mark stack is empty.","The present invention uses the marking ability of a garbage collector to mark live objects and determine a count of the memory bytes allocated to live objects. During the marking process described above, as the marking stack is processed, the number of memory bytes associated with the objects corresponding to the object references on the marking stack is determined and used to increment a live object count, hereafter referred to as a \u201clive count.\u201d The process of marking live objects and counting the number of memory bytes associated with the live objects is referred to as a mark-and-count operation.","The live count in addition to a count of the number of memory bytes allocated to objects in the heap, which is incremented as objects are allocated in the heap during the normal operation of object allocation, may be used to determine the utilization of the heap. These counts may be maintained by hardware or software counters and the values of these counters may be written out to a utilization history file for later use in analyzing the utilization of the heap. The utilization of the heap at any one point in time is determined as the relationship of the number of memory bytes allocated to live objects in the heap and the total number of memory bytes allocated to objects in the heap for that point in time. This relationship identifies how much of the memory allocated to objects in the heap are actually being used by live objects with the remaining allocated bytes being associated with dead objects.","In one exemplary embodiment, the mark-and-count operation described above is performed with each object allocation event and possible memory freeing event, e.g., a reference update event, a method\/block exit, or the like. Thus, with every object allocation, the mark-and-count operation is performed such that the count of the number of memory bytes associated with live objects in the heap, i.e. the live count, is updated. In addition, from the object allocation event itself, the number of memory bytes associated with the object is determined and used to increment the count of the total allocation of memory bytes to objects in the heap. The live count is also updated with each reference update, method\/block exit, or other event that may result in memory allocated to objects in the heap being freed. At each update of the counts, the values of the counters may be stored in a utilization history file or memory for later use in determining heap utilization.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 5","FIG. 5"],"b":["510","520","530"]},"Performing the mark-and-count operation with every object allocation and possible memory freeing event provides accurate information about the heap memory utilization at any point during operation of the Java Virtual Machine. However, performing this mark-and-count operation at each of these events causes additional processor overhead. It would be desirable to reduce this overhead in implementations of the present invention where such detailed utilization information is not deemed necessary.","In a further embodiment of the present invention, in order to reduce the additional overhead of the mark-and-count operation discussed above, rather than using the mark-and-count operation to collect live object memory usage for the heap with every allocation and possible freeing event, the mark-and-count operation may be performed only when the most current peak live count may be exceeded. With this embodiment, a running count of the total allocation of bytes is maintained (allocation count), a running count of the current allocation of bytes to live objects is maintained (live count), and a current peak allocation of bytes to live objects is maintained (peak live count). A mark-and-count operation is performed on each object allocation event and is not performed on events that may possibly free memory.","In addition, if the total bytes allocated since the last measure of the peak live count is less than the peak live count, e.g., memory is reclaimed due to garbage collection since the last measure of the peak live count, then the mark-and-count operation need not be performed even though an allocation event occurs. This embodiment helps to reduce the amount of processor overhead associated with generating the live count information for determining utilization of the heap by limiting the mark-and-count operations to only those points in time when the highest, or peak, live count is exceeded. This embodiment provides the necessary information for capacity planning since such planning generally is concerned with the maximum necessary memory allocation size for the heap.","In another embodiment of the present invention, in addition to maintaining the allocation count and live count, a count of the allocated bytes since the last mark-and-count operation is maintained. When this count is greater than a predetermined threshold, a new mark-and-count operation is initiated. This helps to provide an approximation of the heap memory utilization without requiring a mark-and-count operation with every object allocation event and with every possible memory freeing event.","Thus, with this embodiment, a threshold is set and a mark-and-count operation is performed with the next object allocation. The count of allocated bytes since the last mark-and-count operation is then initialized. With each subsequent object allocation, the count of allocated bytes since the last mark-and-count operation is incremented by the number of memory bytes allocated to the object. Once the count of allocated bytes is greater than the threshold, a new mark-and-count operation is performed to determine the current number of memory bytes allocated to live objects, i.e. the live count.","Using this embodiment, the number of mark-and-count operations performed is reduced and thus, the processor overhead is reduced.  is a graph of the live count versus the allocated count in which the approximation generated using the present embodiment is shown in relation to the actual graph generated using the embodiment discussed above where the mark-and-count operation is performed for every object allocation and memory freeing event. As shown in , the curve generated by the approximation of the present embodiment provides a good approximation of the heap memory utilization within a threshold of the actual curve.","In a further embodiment of the present invention, a low overhead mechanism is provided for determining an approximation of a peak live count for the heap memory utilization. Using a tolerance or threshold approach as discussed above with the determination of the peak live count can provide a peak utilization approximation which can be used to identify memory bottleneck analysis.","With this embodiment, a tolerance or threshold value is specified that identifies the most that the final peak live count can differ from the actual peak live count. In addition, an optional lower bound for the start of collection of the peak live count data may be specified. A mark-and-count operation is performed at specific times determined based on a relationship between a number of bytes allocated since a last mark-and-count operation, a number of bytes of memory allocated to live objects at the last mark-and-count operation, an absolute peak live count from a previous mark-and-count operation, and the tolerance or threshold value.","In one exemplary embodiment, the a mark-and-count operation is performed when the sum of the number of bytes allocated since a last mark-and-count operation (X) and a number of bytes of memory allocated to live objects at the last mark-and-count operation (Y) is greater than the sum of the absolute peak live count (Z) and the tolerance or threshold value (T):\n\n\n","Performing mark-and-count operations based on the above relationship guarantees that a measurement is taken within a threshold number of bytes of the actual peak live count. If the live bytes falls well below the previous peak live count, then the overhead for the measurement will become very small.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 7","FIG. 7"]},"In yet another embodiment of the present invention, one or more of the above mechanisms for identifying a peak live count is enhanced such that additional information about the objects allocated in the heap is obtained when the mark-and-count operation is performed. For example, when a new peak live count is determined to exist and a mark-and-count operation is performed, a heap dump is collected. If a new peak live count is determined to exist, the previously collected heap dump is replaced with a new heap dump collected at the new peak live count point. A heap dump provides information about all objects left live on the heap and provides the information necessary to know why specific objects are still referenced. Taking periodic heap dumps helps to identify memory leaks by seeing what objects are new and which ones are still around.","In another embodiment, rather than a heap dump, one or more of the above mechanisms for identifying a peak live count is enhanced by incorporating a real time arcflow tool to generate an arcflow tree of the live objects. An arcflow tree is a representation of the method calls performed by live objects in the heap and includes such information as the number of calls made to each method, the dependency structure of the calls, the base and cumulative percentage of resources consumed, and the like. Arcflow is a known tool and is described, for example, in Alexander et al., \u201cA Unifying Approach to Performance Analysis in the Java Environment,\u201d IBM Systems Journal, volume 39, no. 1, 2000, which is hereby incorporated by reference. This arcflow tree may be replaced with a new arcflow tree when a new peak live count is identified.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 8","FIG. 8","FIGS. 2"],"b":"3"},"As shown in , the primary operational components are the mark-and-count engine , the heap , the mark stack , the counters and threshold storage  and the heap memory utilization history storage . The mark-and-count engine  identifies events occurring with respect to the heap  that may require a mark-and-count operation to be performed. These events may be, for example, an object allocation in the heap , a method\/block exit in an object in the heap , a object reference update in the heap , and the like. Upon the occurrence of such an event, the mark-and-count engine  performs a marking operation in which live objects in the heap  are identified using the mark stack , as discussed above.","Information obtained from the marking operation, as well as information that may be obtained from the processing of the detected events (e.g., total memory bytes allocated to objects in the heap ), are used to update the counters and threshold storage . For example, the total allocation counter  stores a total number of bytes of memory that have been allocated to objects (live or dead) in the heap . This counter  may be updated whether or not an actual mark-and-count operation is performed or not and may be reset when a garbage collection operation is performed.","The live counter  counts a number of memory bytes allocated to live objects in the heap . The live counter  is updated with each mark-and-count operation to reflect the current allocation of memory to live objects in the heap .","The peak live count storage  stores a count of the highest value for the live counter  up to the present time. The value in peak live count storage  may be updated as a larger peak value is encountered during the operation of the mark-and-count engine .","The threshold storage  stores various thresholds for determining when to perform the mark-and-count operations. The threshold storage  may be accessed by the mark-and-count engine  in determining when to perform such operations.","The number of bytes since last mark-and-count operation counter  stores the number of bytes of memory that have been allocated to objects in the heap  since a last mark-and-count operation. The counter  may be reset after each mark-and-count operation.","The uses of these various counters and threshold storage  depend upon the particular mark-and-count methodology selected for the particular implementation of the present invention. A plurality of embodiments is described above and any one or more of them may be implemented within the mark-and-count engine . Thus, some or all of the counters and threshold storage  depicted in  may or may not be used depending upon the implementation. The manner by which these counters and threshold storage  are used with regard to each methodology is evident from the above descriptions of the various embodiments and the following flowchart descriptions.","The heap memory utilization history storage  provides a storage device into which counter and register values may be stored in order to provide a history of the heap memory utilization during operation of the computing device. In addition, heap dumps and\/or arcflow trees corresponding to peak live counts may be stored in this storage  or in a separate storage device (not shown). The history information, heap dumps and\/or arcflow trees may be output to a user workstation via a user interface such that a user may determine the manner by which the heap uses memory resources. This may be important for capacity planning, debugging, and other applications.","Thus, the present invention provides a method and system for determining heap memory utilization at any point during operation of the computing device. The method and system of the present invention may be implemented in a number of different ways with a core feature being the use of a mark-and-count operation, to identify live objects in the heap and count the number of bytes of memory currently allocated to live objects in the heap, at various times and under various conditions.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIGS. 9-13"},"Accordingly, blocks of the flowchart illustrations support combinations of means for performing the specified functions, combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each block of the flowchart illustrations, and combinations of blocks in the flowchart illustrations, can be implemented by special purpose hardware-based computer systems which perform the specified functions or steps, or by combinations of special purpose hardware and computer instructions.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 9","FIG. 9"],"b":["905","910","920","930"]},"If the event is not an object allocation (step ), then a determination is made as to whether the event is a memory freeing event (step ). If not, the operation terminates. If the event is a memory freeing event, or after step , the operation marks live objects in the heap and determines the number of bytes of memory allocated to each live object (step ). A live counter is then incremented by the number of bytes of memory allocated for each live object in the heap (step ). The live counter value and the total allocation counter value are then stored in the history storage for later use and output to a user workstation (step ). The operation then terminates but may be repeated at the next event occurrence.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 10","FIG. 10"],"b":["1005","1010","1020","1030"]},"A determination is then made as to whether the total bytes allocated is greater than (or possibly equal to) the peak live count (step ). If not, the operation terminates. If the total bytes allocated is greater than the peak live count, then a mark-and-count operation is performed (step ), e.g. steps  and  of FIG. . The live counter and total allocation counter values are then stored in the history storage (step ). The peak live counter is then set to the live counter value (step ) and the operation terminates but may be repeated at the next event occurrence.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 11","FIG. 11"],"b":["1105","1110","1120","1130"]},"Thereafter, the total number of bytes of memory allocated since a last mark-and-count operation counter is incremented by the number of bytes allocated to the object (step ). A determination is made as to whether the total bytes allocated since the last mark-and-count operation is greater than (or possibly equal to) a threshold amount (step ). If not, the operation terminates. If the total bytes allocated since the last mark-and-count operation is greater than (or equal to) a threshold amount, a mark-and-count operation is performed (step ). The live counter and total allocation counter values may then be stored in the history storage (step ) and the number of bytes allocated since a last mark-and-count operation counter may be reset (step ). The operation then terminates but may be repeated at the next event occurrence.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 12","FIG. 12"],"b":["1205","1210","1220","1230"]},"The number of bytes of memory allocated since a last mark-and-count operation counter is then incremented by the number of bytes allocated to the object (step ). Thereafter, the value of the number of bytes of memory allocated since a last mark-and-count operation counter and the value of a live counter for the previous mark-and-count operation are summed to generate a first sum (step ). A peak live count is then summed with a threshold value to generate a second sum (step ) and a determination is made as to whether the first sum is greater than (or possibly equal to) the second sum (step ).","If the first sum is greater than (or equal to) the second sum, then a mark-and-count operation is performed (step ). A determination is then made as to whether the peak live count has increased from a previous value (step ). If so, the peak live count is updated to be the higher value (step ). Thereafter, or if the peak live count has not increased, the live counter and total allocation counter values are then stored to the history (step ) and the number of bytes allocated since the last mark-and-count operation counter is reset (step ). The operation then terminates and may be repeated when the next event occurs.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 13","FIG. 13","FIG. 10","FIG. 12"],"b":"1380"},"Thus, the present invention provides mechanisms for determining the heap memory usage at any time during the operation of the computing system. As a result, information about heap utilization may be obtained for use in capacity planning, debugging, and the like. The present invention avoids having to obtain live object information at garbage collection time and thus, avoids the inaccuracies that may be in such information due to the garbage collection operations.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
