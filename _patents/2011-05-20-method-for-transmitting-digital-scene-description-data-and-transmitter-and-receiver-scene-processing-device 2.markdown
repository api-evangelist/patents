---
title: Method for transmitting digital scene description data and transmitter and receiver scene processing device
abstract: A method for transmitting digital scene description data from a transmitter scene processing device to at least one receiver scene processing device is disclosed. The method comprises the steps of encoding of scene description data and rendering commands in the transmitter scene processing device by setting of priorities for the scene description data and related rendering commands and dynamically reordering the scene description data and related rendering commands depending on the respective priorities in order to reduce the bandwidth required for transmission and/or to adapt to unreliable bandwidth; and transmitting the encoded scene description data and related rendering commands to the at least one receiver scene processing device for decoding and executing the rendering commands in relation to the transmitted scene description data by the at least one receiver scene processing device to achieve animated digital graphic.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619916&OS=09619916&RS=09619916
owner: Dream CHIP Technologies GmbH
number: 09619916
owner_city: Garbsen
owner_country: DE
publication_date: 20110520
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION THE INVENTION"],"p":["Field of the Invention","The invention relates to a method for transmitting digital scene description data from a transmitter scene processing device to at least one receiver scene processing device.","The invention is further related to a transmitter scene processing device and to a receiver scene processing device.","Background Description","There is a need of transmitting digital scene description data from a transmitter scene processing device to at least one receiver scene processing device and further using the transmitted digital scene description data with high quality. However, transmitting digital scene description data to be used in high quality requires transmitting a high amount of data in reasonable time and processing the digital scene description data in reasonable time.","Rendering procedures for reducing the amount of data to be transmitted are well known in the art. Rendering is a process of generating an image from at least one model or scene by means e.g. of computer programming instructions executed on a processing unit. A scene contains objects in a defined language or data structure. A scene comprises attributes e.g. for defining geometry, viewpoint, texture, lighting and shading for describing the scene. Executing rendering commands on digital scene description data including attributes results in an animated digital image or graphics image file.","The term \u201cscene\u201d as set forth in the present application comprises at least one picture, frame of a picture, or sequence of pictures, i.e. video.","A plurality of graphic processing tools is available to the public including OpenGL (Open Graphics Library) providing program instructions and related executables for rendering processing:","The OpenGL specification encoding resources comprising rendering libraries are available in the internet from the OpenGL organisation (http:\/\/www.opengl.org) without licence as open source. OpenGL is further described in the OpenGL reference manual: The Official Reference Document to OpenGL, Version 1.4 (4Edition), Mar. 26, 2004, Editor Dave Schreiner, Addison-Wesley Professional and in Dave Schreiner, OpenGL Programming Guide: The Official Guide to Learning OpenGL, Versions 3.0 and 3.1 (7Edition), Jul. 31, 2009, Addison-Wesley Professional.","US 2007\/0153004 A1 discloses an animation file player provided for display animation files with an embedded system graphics application programming interface. For displaying an animation file information on a graphics enabled mobile device, an animation file is stored and converted to graphics rendering information. The graphics rendering information is passed to a mobile device graphics subsystem where the graphics rendering information is processed to obtain pixel data. An animation of the pixel data is displayed on a mobile device display.","WO 2009\/040313 A1 discloses a method and system for remote visualisation of a graphics application using an OpenGL library. A local computer system comprises the OpenGL library and an encoder for translating operation systems specific OpenGL interface operations into operating systems independent operations for transmitting between the local computer system and one or more remote computer systems. The at least one remote computer system is comprising a decoder for decoding the operating system independent operations into operations of the second OpenGL interface for a second type of operating system. The operations may relay to windowing system specific rendering methods.","A problem of the prior art is that processing of digital scene description data on a device requires a lot of limited processing resources and limited battery power and that the bandwidth for transmitting the required amount of digital scene description data for higher resolution display is limited.","The object of the present invention is achieved by the method according to claim  and the transmitting and receiver scene processing device according to the independent claims.","According to the present invention, the method comprises the steps of\n\n","According to the present invention, scene description data and related encoded rendering commands are transmitted from the transmitter scene processing device to the at least one receiver scene processing device for decoding and executing the encoded rendering commands in relation to the transmitted scene description data.","Thus, the transmitter scene processing device can be a mobile device with limited battery capacity, since executing the rendering commands is performed on the receiver scene processing device.","Further, the required bandwidth for transmitting digital scene description data is significantly reduced when transmitting digital scene description data and independent from these encoded rendering commands.","According to the present invention, the scene description data and related rendering commands are dynamically reordered having the effect of significantly reduced bandwidth for data to be transmitted to the at least one of the receiver scene processing devices.","Encoding by way of reordering of scene description data and related rendering commands and executing the rendering commands in the receiver scene processing device rather than transmitting an already rendered animated digital graphic in encoded and thereby compressed way has the advantage that the full information of the digital scene description data is maintained without loss of quality.","The effect of the method and the related transmitter scene processing device and receiver scene processing device is providing fast reaction speed and fluent animations over unreliable and especially narrowband links between transmitter scene processing device and at least one receiver scene processing device. The band links can also be wideband links. Besides wired links (e.g. TCP\/IP links and USB links) the method works very well with wireless links (e.g. WiFi and Bluetooth), including disturbed wireless links. The wireless links which gain most of the present invention are specifically high-loaded and nasty unrelated disturbed connections, e.g. multi-WiFi access point environment where many concurrent, unrelated and variable active links act as disturber.","It is preferable to first transmit compressed digital scene description data, in particular texture data, from the transmitter scene processing device to the at least one receiver scene processing device. This will result in a reduced quality of the resulting rendered animated digital graphic. In order to achieve an improved graphic quality, the digital scene description data is later updated by transmitting the former compressed digital scene description data with higher quality from the transmitter scene processing device to the at least one receiver scene processing device. Thus, the available bandwidth can be used for updating the digital scene description data with higher quality, e.g. in uncompressed form. Thus, the animated digital graphic can be used first with reduced quality wherein the picture quality of the animated digital graphic is later improved by updating the digital scene description data without disturbing or interrupting the stream of animated digital graphic.","In a preferred embodiment, the digital scene description data transmitted from the transmitter scene processing device to the at least one receiver scene processing device includes vertex data provided for describing scene points of a scene. Said vertex data comprising the position of the respective scene point and attributes of the respective scene point provided for rendering an object related to the vertex data.","A vertex as set forth in the present application is a data structure that describes an scene point in two dimensional (2D), two and half (2.5D) or three dimensional (3D) space. 2.5D is a graphical projection which causes a series of images or scenes to fake or appear to be three-dimensional (3D) when in fact they are not.","When describing an object by use of an array of flat surfaces, e.g. triangles, the location and other attributes of the corners of the surfaces are defined by vertices. Thus, the vertices of the corner points of the triangles are associated with the position of the corner points and with additional graphic attributes including colour at the vertex point, the normal of an approximated curved surface at the position of the corner point, as well as textures and reflections of the surface of the related triangle. Thus, vertex data comprises the set of data which can be preferably encoded and transmitted in encoded and thereby compressed form from the transmitter scene processing device to the at least one receiving scene processing device in order to reduce the amount of data.","Since the image data e.g. useful for defining the texture can be transmitted independently from the vertex data e.g. without encoding and therefore without loss of quality, the animated graphic can be still displayed with high resolution and high quality even if the amount of data is reduced by encoding.","It is preferred to encode or compress the digital scene description data and in particular the vertex data, by use of delta compression. In the method of delta compression, the differences of actual digital scene description data to a preceding set of corresponding digital scene description data is calculated and transmitted. Delta compression is well known in the prior art of lossless data encoding. The method of delta compression has the advantage of a significantly reduced amount of data compared to transmitting the scene description data of one picture or frame itself.","Further, it is preferred when transmitting scene description data being primarily visible in an animated digital graphic for user and the rendering commands related to such prior scene description data with increased priority over (unprioritised) scene description data and related rendering commands having a secondary (reduced) visibility or being invisible in an animated digital graphic.","Thus, the available bandwidth and resources including battery power is primarily used for encoding and transmitting the primarily visible content of an animated digital graphic. The data content of minor priority being in the background or being invisible are processed with lower priority. The priority of scene description data and related rendering commands can be set according to the visibility of graphic content resulting from rendering these scene description data by use of related rendering commands. This method of priorisation of processing can be applied for encoding and transmitting the rendering commands only or applied to both encoding and transmitting the rendering commands and transmitting (with optionally prior compressing\/encoding) related digital scene description data.","By ignoring the rendering commands related to invisible parts of an animated digital graphic and optionally the related digital scene description data itself, the required processing resources and bandwidth for transmitting is reduced. When processing scene description data and related rendering commands having a secondary visibility with reduced priority processing resources and bandwidth can be used at the time of availability without reduction of the available resources for processing the data for primarily visible content of the animated graphic.","Further, it is preferable to translate the rendering resolution of the digital scene description data provided by the transmitter scene processing device to a resolution desired for a display connected to a receiver scene processing device by processing digital scene description data in the receiver scene processing device. Therefore, the adaptation of the animation digital graphic to the resolution required for the receiver scene processing device is adapted by the receiver scene processing device. Thus, processing resources including available battery power is saved on the transmitter scene processing device. Adapting the resolution on the receiver scene processing device practically without significant loss of quality becomes possible by transmitting the digital scene description data with the method according to the present invention.","The method requires only loose or priority dependent synchronisation of both the transmitter scene processing device and the at least one receiver scene processing device. The reason is that the digital scene description data is transmitted independently from rendering commands wherein the rendering commands transmitted with reduced amount of data are executed on the digital scene description data in the receiver scene processing device.","In case that a period in which the receiver scene processing device is blocked to proceed with processing digital data exceeds a preconfigured time-limit, it is preferred that the at least one receiver scene processing device sends a synchronisation information to the transmitter scene processing device.","In a preferred embodiment, the characteristics of a channel used for transmitting the encoded scene description data and related rendering commands is measured. The step of dynamically reordering is controlled in relation to the actual measured characteristics of the channel. Such characteristics of a channel are for example the data transmission statistics, the reaction time (e.g. ping time) or the like. Such information about properties of the channel are often available as an output of an interface device or can be implemented by use of standard firmware resources.","The advantage of controlling the encoding process, i.e. the step of dynamical reordering, in dependence of the channel property has the advantage of adapting the amount of data to be transmitted to the receiver scene processing device in an optimised way to the available bandwidth of the channel.","Further, it is preferred to cache scene description data in a data memory of a receiver scene processing device. When encoding the scene description data in the transmitter scene processing device, such scene description data already cached in a related receiver scene processing device is not considered, e.g. by setting a priority of Zero. The cached scene description data is therefore not transmitted again. The cached scene description data can be reused from the memory by the receiver scene processing device when decoding and executing rendering commands related to such cached scene description data. This has the effect of a significant reduced amount of data to be transmitted from the transmitter scene processing device to the at least one receiver scene processing device.","The object is further achieved by the transmitter scene processing device comprising a data memory for storing digital scene data, at least one processing unit and at least one interface for connecting to at least one receiver scene processing device to transmit scene description data to the at least one receiver scene processing device.","The transmitter scene processing device according to the present invention comprises an encoder for encoding of scene description data and related rendering commands in the transmitter scene processing device by:\n\n","Said rendering commands comprise instructions for obtaining an animated graphic from digital scene description data stored in the data memory when executing the instructions on a processing device. The transmitter scene processing device is arranged to transmit scene description data and related encoded rendering commands to at least one receiver scene processing device via the at least one interface.","The transmitter scene processing device is preferably arranged, e.g. by software programming with executables executed on the processing unit, to perform at least one of the aforementioned steps intended to be performed on the transmitter scene processing device.","The object is further achieved by the receiver scene processing device comprising a data memory for storing digital scene description data, at least one processing unit and at least one interface for interconnection to at least one transmitter scene processing device. The receiver scene processing device comprising a decoder arranged for decoding encoded rendering commands wherein the receiver scene processing device is arranged to execute the encoded instructions related to the rendering commands for obtaining an animated graphic from digital scene description data received from the at least one transmitter scene processing device via the interface when executing the instructions on the processing unit.","According to the transmitter scene processing device, the receiver scene processing device is preferably arranged to perform at least one of the steps intended to be performed on the receiver scene processing device, e.g. by software program executables to be executed on the processing unit.",{"@attributes":{"id":"p-0046","num":"0051"},"figref":"FIG. 1","b":["1","2","3","3"]},"The at least one receiver scene processing device  is connected to a display unit  provided for displaying an animated graphic processed by rendering digital scene description data on the receiver scene processing device .","The transmitter scene processing device  comprises a processing unit , e.g. in form of a programmable graphic processor, and a data memory  connected to the processing unit  provided for storing digital scene description data. Optionally, software program executables could be stored in the data memory .","Further, the transmitter scene processing device  comprises a rendering command library  including executables and\/or commands for rendering of digital scene description data to achieve animated graphic. Such rendering command library can include for example the OpenGL library according to the OpenGL open source standard. However, the transmitter scene processing device  could also support any other rendering command language like VirtualGL, WebGL or the like according to the need of the user and according to a specific implementation chosen when designing the transmitter scene processing device .","The transmitter scene processing device  further comprises an interface  for connection to at least one receiver scene processing device . The interface  can be a wired or wireless interface  supporting e.g. the wire data transmission protocols TCP\/IP, USB or the like or wireless data transmission protocols WiFi, Bluetooth or the like. Such interfaces  are commonly available in form or hardware blocks (integrated circuits), firmware or a combination thereof.","Further, the transmitter graphic processing unit  comprises an encoder  for encoding scene description data and related rendering commands stored in the rendering command library . The encoder  is arranged e.g. by software programming or in form of a logical hardware block to encode the scene description data and related rendering commands with the steps of setting priorities to scene description data and related rendering commands and reordering the scene description data and rendering commands in relation to the priorities set before such that the bandwidth required for transmitting the scene description data into related rendering commands is reduced and\/or that the sequence of scene description data and related rendering commands is adapted to unreliable bandwidth.","For reordering the scene description data and related rendering commands, the encoder  caches (intermediate storing) scene description data and related rendering commands having a lower priority over high-priority scene description data and related rendering commands. When reordering the scene description data and related rendering commands, the encoder  can have access to the cache memory for changing and optimizing the sequence order of the scene description data and related rendering commands to achieve the afore mentioned object.","Preferably, the interface  comprises a measuring unit for measuring the properties of the channel, i.e. the data link . Such properties are for example the data transmission rate, the reaction time (e.g. ping time) or the like. As shown by the dotted arrow, the interface  controls the encoder  and in particular the steps of setting priorities, caching and reordering to adapt the data flow of the encoder  to the measured channel property.","One of the options is to transmit digital scene description data first in compressed form from the transmitter scene processing device  to the at least one receiver scene processing device . The result is that the required bandwidth for transmitting this type of data is highly reduced. However, there is a disadvantage of loss of quality when displaying an animated graphic based upon compressed data, since there is a loss of information when compressing data. To overcome this disadvantage, the digital scene description data will be updated later on by transmitting the former compressed digital scene description data with higher quality, e.g. in uncompressed form, from the transmitter scene processing device  to the at least one receiver scene processing device . The scene description data can be transmitted in data packets using any available bandwidth, which is not used for transmitting data with higher priority. The result is, that the quality of the animated graphic is later improved.","In practice, the lower quality of the animated graphic at the beginning will have no significant effect to a user when improving the graphic quality later on.","Another option is encoding of vertex data to compress the vertex data. The digital scene description data comprises vertex data among others, wherein the vertex data are provided for describing scene points of a scene point. The vertex data comprises a position of the respective scene point and attributes of the respective scene point. Said attributes may comprise information about texture, illumination, viewpoint, linewidth, scale factor, colour, reflectance of the related surface and the normal of an approximated curved surface at the location of the vertex.","When encoding the digital scene description data, in particular vertex data, the method of delta compression can be applied. Delta compression is well known in the prior art for lossless data encoding. In principle, the differences of actual scene description data to a preceding set of related scene description data is calculated and transmitted when performing the method of delta compression. Thus, not the absolute values of the actual scene description data are encoded and transmitted, but the differences of the actual scene description data to a preceding set of related scene description data. The amount of data of differences is significantly lower than the absolute data.","Another option is setting an increased priority to scene description data and related rendering commands, which results in graphic being primarily visible in an animated digital graphic for a user. Thus, those scene description data and related rendering commands causing animated graphic in the focus of an observer is privileged over scene description data and related rendering commands related to background graphic or even invisible parts of an animated digital graphic.","The receiver graphic processing unit  also comprises an interface  connected to the data link  and the transmitter scene processing device . The interface  corresponds to the interface  of the transmitter scene processing device.","The receiver scene processing device  further comprises a graphic processing unit  and a data memory  provided for storing digital scene description data including digital scene description data.","The receiver scene processing device  further comprises a decoder  for decoding the data stream received from the transmitter scene processing device . Said data stream comprises a sequence of digital scene description data and related rendering commands.","The graphic processing unit  of the receiver scene processing device  is arranged to execute rendering commands received in relation to digital scene description data received from the transmitter scene processing device . Preferably, the graphic processing unit  is controlled by respective firmware to execute the rendering commands and perform rendering for graphic processing.","Optionally, the graphic processor  can have access to a rendering command library  comprising executables e.g. in form of firmware or software code controlling the graphic processing unit  to perform specific steps of rendering. Then, the rendering commands received by the receiver scene processing device  from the transmitter scene processing device  can be limited to codewords related to executables stored in the rendering command library  of the receiver scene processing device .","The rendering command library  can be then restricted to a library of such codewords without need of storing executables in the transmitter scene processing device .","In the embodiment shown in , the rendering scene processing device  is (optionally) connected to a display  provided for displaying an animated digital graphic . Said animated digital graphic  comprises vertex data provided for describing scene points  of a scene.",{"@attributes":{"id":"p-0066","num":"0071"},"figref":"FIG. 2"},"Based upon a stream of digital scene description data, SDD, the scene description data and related rendering commands will be encoded in the step a).","The step a) of encoding comprises the steps of a1) for setting of priorities for the scene description data SDD and related rendering commands and the step a2) of dynamically reordering the scene description data SDD and related rendering commands depending on the respective priorities, which are set in set a1) in order to reduce the bandwidth required for transmission and\/or to adapt to unreliable bandwidth.","The step a) of encoding includes the step of caching scene description data and related rendering commands to store this data in case that decreased priority is assigned to such data. When caching such data, the encoder  can access this data later on to include this data in a stream of digital scene description data and related rendering commands. Thus, scene description data and related rendering commands with high priority, e.g. due to visibility of related animated graphic scenes in the focus of an observer, have the precedence over scene description data and related rendering commands with less priority.","The reordered sequence of digital scene description data and related rendering commands is then transmitted from the transmitter scene processing device  in step b) over the data link  to the at least one receiver scene processing device . It should be noted that the scene description data SDD will be transmitted\u2014in a preferred embodiment\u2014separately from the rendering commands over the same channel, i.e. data link . Thus, the step b) is divided in step b1) for transmitting the digital scene description data SDD and step b2) for transmitting the rendering commands. The digital scene description data SDD and the related rendering commands can also be transmitted separately from each other through different channels or can be transmitted combined in a common data packet via the same channel.","In the receiver scene processing device , the transmitted digital scene description data SDD and related rendering commands are received in step c).","Then, in step d), the received digital scene description data SDD and optionally the related rendering commands are decoded.","In step e) the rendering commands are executed e.g. by use of related executables stored in the rendering command library  of the receiver scene processing device  in relation to digital scene description data already received from the transmitter scene processing device . These related digital scene description data can be also data, which had been cached in the receiver scene processing device  for subsequent reuse of the same data content. Thus, recurring data content is allowed to be transmitted only once from the transmitter scene processing device  or any other source, e.g. data storage medium, to the receiver scene processing device .","The result of executing the rendering commands to process digital scene description data is an animated graphic which can be immediately displayed on a display in step f) or stored for later use.","In the following, preferred implementations of the present invention are presented:","Crystallization: The method according to the present invention is implemented in a multipart apparatus for a RemoteGPU (Remote Graphics Processing Unit) setup. This implements a protocol encoder, dynamic channel estimator and decoder methods for scene synthesis elements over low & unreliable bandwidth links.","A system implementing the present invention employs a method and apparatus for efficiently pre-processing, encoding, transmitting over data links and decoding of 2D, 2.5D and 3D scene synthesis elements and transformations between subsequent respective not subsequent but sufficient related scenes within a given timeframe and bandwidth. The approach is to optimize the position within the narrow link to the entropy of least data transport as optimal for the specific display object. Key methods of the present invention describe how to process the source-sink interaction on this optimal point to still achieve excellent reaction speeds. This will be detailed in the following.","The key-innovations described in the subsequent chapter are:\n\n","The apparatus suggested for implementing the method according to the present invention can appear at least in the following combination embodiments:",{"@attributes":{"id":"p-0080","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"Source - Encoder embodiment"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Phone","Laptop","Digi-Cam","PC"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Sink -","TV","STB,","STB,","STB,","STB,"]},{"entry":["Decoder",{},"Embed","Embed","Embed","Embed"]},{"entry":["embodiment","Monitor","Plug,","Plug,","Plug,","All"]},{"entry":[{},{},"Hub,","Hub,","Embed"]},{"entry":[{},{},"Embed","Embed"]},{"entry":[{},"Projector","Plug,","Plug,","Plug,","All"]},{"entry":[{},{},"Embed","Embed","Embed"]},{"entry":[{},"Car","Embed","Embed","Embed","Embed"]},{"entry":[{},"Glasses","Embed","Embed","Embed","Embed"]},{"entry":[{},"PoS","All","All","All","All"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"The mayor, but not all possible Sink\u2014Decoder embodiment's are:\n\n","The various specifics of the possible Sink-Decoder embodiment's setup are:\n\n","Further embodiments are seamless possible and benefit significantly from integrating methods according to the present invention:\n\n","The apparatus related user interaction options in suggested embodiments are predominantly:\n\n","Valid embodiments of the present invention can implement at least all of the above options or any combination of subsets.","The utilization of OpenGL, specifically OpenGL|ES 2.0 API examples does not constitute any limitation for applicability of the methods implementing the present invention to any specific rendering API.","What is claimed is in the context of pre-render objects over unreliable interfaces:","Toplevel view: It is distinguished between the following general display objects:\n\n","As point 1. is already well covered in prior art but part of the proposed apparatus, the following claims center on points 2. and especially on 3. 2D and 2.5D GUI is considered as one (2D) or several parallel (2.5D) surfaces perpendicular to the 3D viewport.","Physical Interfaces","The physical interface used for implementing the present invention is depending on desired Application complexity and start-time requirements. The apparatus enables standard wired and wireless links to be used. For most vector and object based rendered GUI Applications Bluetooth is sufficient. To speed up Application start-time Bluetooth 3.0 is suggested. For start-time the WiFi-Phy is used for high-throughput, while during runtime typically Bluetooth 2.1 is sufficient. This allows significant power consumption reductions in contrast to WiFi or any wired or wireless framesynchonous interface.","Related Graphics Elements","Typical PC graphics subsystems like X11 (Linux) or GDI (Windows) handle resources of which the displayed programs are constructed separately. This also applies to Smartphone graphics subsystems, too. This are:\n\n","Scene Transfer Protocol\u2014General Overview","The STP protocol consists of two independent uplink and one downlink connections. Connections are initialized by the encoder. The streams operate on different ports. Thus, in a Qualtity of Service (QoS) controlled environment the performance can be boosted further. The preferred methods consists of three connections\u2014a 3channel where each server sends back QoS evaluation results to client. Those information provide info about e.g. the current rendering speed (min, max and average FPS), load conditions that could be used by the client to optimize the network traffic.\n\n","The separation between those two uplink communication channels ensures that a big texture upload does not block the rendering pipeline. Moreover, it allows the server to make decisions about rendering resources that have not arrived yet. For example, a missing texture can be rendered as solid color (e.g. grey), as background-color or checkered pattern (iOS style) or use a low resolution placeholder texture. Alternatively, the server can be directed to wait (block) for this specific resource to arrive.","The vector and object based methods are organized as follows: Set: Not modified GL, GL extensions, better represented, loop broken, new commands, group control commands e.g. WM., Decoder statistics.\n\n","Synchronization of Encoders and Decoders","An apparatus implements loose synchronization. Most encoder methods require no tight synchronization with decoder or no synchronization at all. This applies especially to those animations without any user interaction. Other applications increase the number rendered frames per second depending on the device capabilities and utilization. That allows this application to appear more fluent on faster HW. To enable also such dynamic application adoption over this now much longer loop without suffering from synchronous in-loop delays, the encoder provides dynamic render guidance information locally. This is based on over the loop channel estimations and sink GPU capabilities. As the channel may change this measured throughput and delay-spread information with the according render guidance to the application is updated based on last rendered frames throughput. Depending on environment conditions and apparatus capabilities, this elaboration time-window is variable.","Further synchronization methods are introduced by unforeseeable blocking of the local respective remote render hardware. The application has no complete a-priori knowledge which of its commands will actually block the render hardware for a relevant period of time. Usually most commands including rendering commands cost neglect able time, while some seldom happening events will cause a normally irrelevantly fast command to be delayed a couple of milliseconds. This is caused by the actual implementation of the render hardware. The GPU blocks because it runs out of memory, needs to sync on a different core executing some previous work, waits for a buffer read arrival, etc.","The major advantage of an encoder according to the present invention is the almost complete decoupling from the blocking causing decoder HW. The application visible execution time for GL commands is approaching zero, since they are being buffered and not executed. Thus a client application would assume an unrealistic even about infinite frame rate. The encoder queue implementation is parameterized for far worse channel timing behavior than the render HW can cause delays and is capable to buffer this. The decoder method is to report back to encoder spurious blockings and drop warnings if this blocked time is beyond a preconfigured limit. The inverse number of the sum of all short term and partly medium term delays is the reported frame rate per second. This equalized possible frame rate is than enforced by blocking.","The following conditions will cause a GL function call to block in the client application:\n\n","Blocking and Re-Grouping Network Traffic\n\n","Scaling: Resolution Optimization Methods","The decoder automatically translates the decoder rendering resolution to fit full screen. In practical terms, the application assumes it's rendering at local resolution e.g. 800\u00d7480 pixels for which it's written, while the decoder is actually pixel accurately rendering at e.g. 1920\u00d71080.","If the aspect ratio of the encoded scene viewport is not identical to the decoding display device, the decoder apparatus uses letter boxing for more widescreen original content and Pillar boxing for a less widescreen original content to preserve the original aspect ratio.","If the resolution is different in any or both directions between the encoded and decoded resolution than the following methods apply:","The decoder calculates the required matrix at scene setup for the affine transformation matrix to transpose the vertex coordinates linearly from the viewport defined by the application running at the encoder side to the optimal coordinate system of the decoder side. The resulting frustum is than rendered as intended by the application, but rasterized at different typically much higher resolutions. For example: Resulting not orthogonal lines which would have ugly steps from a traditional bitmap-scaling appear pixel perfect drawn also on much higher resolution.","Bitmap content such as textures suffer of course from being mapped on a much higher resolution surface since that may require bitmap scaling if the original resolution of the texture it too low. To reduce this well known effects which become worse on higher resolution displays the decoder replaces an low quality scaling command which the application may have called expecting a low resolution display by the maximum quality scaler e.g. bilinear texture rendering of the decoder platform. Alternatively, as the encoder can report the true maximum resolution display apps may select a higher resolution texture. This method is also used to cope with bandwidth congestions. Here a subsampled quite low resolution texture is send over the narrowband interface, rendered and shown first. In the background a better quality, higher resolution and thus bigger amount of bulk data is transported and replaced by the decoder when arrived. Further methods from the short-term and longer term respective permanent caching methods are applied.","Managed Multi Caching","When encoding the screen description data and related rendering commands three different kind of caching data for reordering are of preliminary interest. In the persistent caching strategy the data are made available in a persistent data memory so that the data can be accessed during the complete time of processing an animated graphic. This requires increased amount of memory capacity versus the short or long dynamic caching strategy while having the advantage of great flexibility and effect of the reordering procedure. In the short or long dynamic caching strategy data is cached only for a long or short time so that reordering considers a time limited time frame of a sequence of animated graphics only. The advantage is that reduced memory capacity is required.","Resource Stream Optimization for Narrow Bandwidth Conditions","A preferred implementation of the method allow to progressively update a texture resource. The client at start can send a heavily-compressed JPEG version of the resource and update it with full-quality image later on. This method eliminates all round trips times from decoder to encoder, since the encoder doesn't need to wait for the decoder reply. When a program generates a texture resource on the client side, the encoder assigns a unique local id for it from it's pool. For instance, it provides the texture an id of . It pushes the request to the decoder with this id number to which the resource will be referred to by this particular client as . The client executes the actual on-chip resource creation command and gets, say, an id of . Now the decoder knows that client texture id  is an actual id . This mapping never needs to be communicated back to the encoder. The client will continue to use  when identifying the resource and the server mapps this as .","For a multiple encoders setup connecting to the same decoder, the decoder maintains this mapping separately for every connected encoder.","Lower Bandwidth Solutions:","Scene-Graph Based Encoding Prioritization Methods","The following methods are known in a different context for a different purpose in contrast to this in this invention. They have been used for improved processing of higher complexity sceneries with very high performance target points in local graphics accelerated systems. This is done to reduce by culling away primitives before processing them in detail and rendering for finally anyway not shown fragments to gain more available computation power to render the visible pixels.","The apparatus will use these known methods in the new application scenery as precedence encoding methods distinguishing transport relevance and priorities under significant bandwidth restricted situations to remote vertex buffers. The resulting effect of these methods are a much faster application start and faster not a-priori known scene changes with high complexity scenes under low bandwidth conditions. The traditional high performance methods named \u201cView-Frustum culling\u201d, \u201cocclusion culling\u201d, \u201cSmall feature culling\u201d and \u201cLevel Of Detail (LOD) nodes\u201d became now:","View-Frustum Reordering\n\n","Level of Detail (LOD) Nodes Reduction\n\n","Small Feature Reduction\n\n","These methods are only used in very low bandwidth situations as last resort or to speed up too high complexity scenes. This approach allows still quite fast reaction to user interaction, but reduces the immediate ability to move the perceptivity within the 3D scenery. The lower priority elements are transported as best effort in the background. In case some details are transported later, this detail is included when it arrives at the decoder. Thus if the user doesn't move to fast the user will with increased likelihood not be bothered with this hard squeezed situation.","The following methods of encoding for data compression can be preferably used in the method:","Compression of Vertex\/Index Data","Floating-point or 16\/32-bit integer data doesn't compress well with traditional LZ-based approaches. As mostly neighboring vertex coordinates are encoded significant size reduction is achieved from delta coding. This encodes the base-value and represents the differences \u2018delta\u2019 between one value and the next with a much shorter representation. Thus neighboring vertices are referred as a common base encoding only using the offset.","Delta compression is also used for incremental transfers. The encoder maintains a full copy of base data. When transferring further data blocks, subtract the new data from the old data and transmit the difference. The difference information can typically be represented with much less data than the full data promises high gains for dynamic texture data.","Entropy Compression","An less efficient but more regular method for the command protocol stream encoder is the application for basic encodes stream with the known lossless entropy compression methods using e.g. zlib. Each frame is a packed and delivered as a compressed package. The decoder decomposes this back into individual commands and processes them individually.","A specific embodiment of entropy compression are:","Command and Object Specific Encoding Claims","The network format is as lean as possible with prioritization for low data, but visible reaction commands to ensure fast reaction, as the following are immediately visible to the user. The header is encoded with 16-bit command ID+16-bit size.","Function parameters are encoded in most compact way possible. e.g. GLenum: typically 32 bit on the CPU, but only 16 bits used. This is encoded as 16 bits and packed.","Stencil masks are handled as 32 bit on the CPU, but stencil buffers have just 8 bits thus the use for the present invention fragment packing here.","Color values are floating-point on the CPU, but display has just 8 bits.","The following methods can be applied in improved embodiments:","Progressive Textures Upload","Textures are sent fully asynchonous to the decoder over a separate stream. There is support for progressive uploads: The encoder first sends a quick low-resolution sub sampled version of the texture before sending the high detail texture which requires higher throughput. The encoder also downscales textures which are bigger then supported by the server-side GLES driver.","Dynamic Frame Shaping Support","Based on the feedback from the server, the client automatically adjusts it's FPS rendering ratio to fit the server\/network performance.","Redundant Command skipping: The encoder maintains a local stack copy\/state. This removes redundant high priority command traffic through skipping of commands that set values which are already set. For example end-user applications often reset state switches on every frame \u201cjust to be sure\u201d. Such behavior is detected and skipped.","Texture State Tracking Optimizations","For the global GL state, the encoder caches each texture's state and skips redundant operations. This optimizations are especially effective for Toolkits like Qt.","Simple functions as state changes, vertex attributes, and similar convey only a few bytes of data (0-16 for most, a few with 64) This are: glUse-Program, glTexParameteri, glUniform3f, glFlush, . . . . About half of all OpenGLES2.0 functions belong to this category.","In contrast to previous implementations are functions that transfer bulk data like texture data, vertex buffers, . . . . This can be any size from a few bytes to multiple megabytes. Some of this data is updated every frame. Examples: glTexlmage2D, glBufferData, glDrawElements, . . . . These functions are the major bandwidth bottlenecks!","Special improvement: glVertexAttribPointer. In locally rendered OpenGL|ES, this function does not actually upload data to the graphics chip. Instead, it just updates a pointer to graphics data. Actual data isn't read until the next glDrawArrays or glDrawElements call. A preferred implementation state tracks this data referenced by a vertex attribute pointer since that may change every time between draw calls.","In contrast functions that transfer small amounts of data are e.g. strings identifying shader variables, lists of buffers, . . . . This is typically less than 100 bytes and not frequently used i.e. unlikely to occur in every frame. To this category belongs: glUniformLocation, glDeleteTextures, Functions that transfer strings are shader source or binary code communication whose typical range: is 100 bytes to 10 kBytes. Not frequently used i.e. unlikely to occur in every frame is glShaderSource, glShaderBinary. This both usually compresses well with common LZ-based lossless compression methods. Improved implementations of the present invention makes use of deferred indexing and standard compressed transfer.","The abbreviations used in the description have the following meaning:","API Application Programming Interface","DVI-I Digital Vision Interface-Integrated","DHCP Dynamic Host Configuration Protocol","DTV Digital Television","DVFS Dynamic Voltage and Frequency Scaling","EGL Embedded System Graphcs Library","FPS Frames per Second","GL Graphics Library","HDMI High Definition Multimedia Interface","HW Hardware","LCD Liquid Crystal Display","LRU Least Recently Used","MSS Maximum Segment Size","MUD Multi User Dungeon","OpenGL Open Graphics Library","OpenGL|ES Graphics Library Embedded Solution","OS Operating System","PoS Point of Sale","QoS Qualtity of Service","QR Quick Response","RemoteGPU Remote Graphics Processing Unit)","SSID Service Set Identifier","STP Scene Transfer Protocol","Sub-D VGA Sub-D Video Graphics Array","TCP\/IP Transmission Control Protocol\/Internet Protocol","TV Television","USB Universal Serial Bus","VNC Virtual Network Computing","WebGL Web Graphics Library","WM Window Manager"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the following, the invention is exemplarily described by way of an embodiment with the enclosed drawings. It shows:",{"@attributes":{"id":"p-0044","num":"0049"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0045","num":"0050"},"figref":"FIG. 2"}]},"DETDESC":[{},{}]}
