---
title: Snapshot preserved data cloning
abstract: A method and device for cloning snapshots is provided. A new snapshot can be created by cloning an existing snapshot. The clone snapshot may use the preserved data of the existing snapshot, thereby obviating the need to copy the preserved data. Additionally, the clone snapshot may be created with a data structure for storing write data. Since the clone snapshot initially has no write data to store, the creation of the entire clone snapshot can be accomplished without copying any preserved data or write data from the existing snapshot, thereby increasing the efficiency with which a clone snapshot can be created.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08656123&OS=08656123&RS=08656123
owner: Dot Hill Systems Corporation
number: 08656123
owner_city: Longmont
owner_country: US
publication_date: 20090812
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION(S)","FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a divisional of U.S. Pat. No. 7,716,183 (application Ser. No. 11\/734,081 filed Apr. 11, 2007), issued May 11, 2010.",{"@attributes":{"id":"p-0003","num":"0002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Ser. No.","Filing Date","Title"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7,426,618","Mar. 28, 2006","SNAPSHOT RESTORE METHOD"]},{"entry":["11.277,738",{},"AND APPARATUS"]},{"entry":"(4430-58)"},{"entry":["11\/945,940","Nov. 27, 2007","METHOD AND APPARATUS FOR"]},{"entry":["(4430-58-CIP)",{},"MASTER VOLUME ACCESS"]},{"entry":[{},{},"DURING VOLUME COPY"]},{"entry":["11\/561,512","Nov. 20, 2006","DATA REPLICATION METHOD"]},{"entry":["(4430-61)",{},"AND APPARATUS"]},{"entry":["11\/561,680","Nov. 20, 2006","PULL DATA REPLICATION MODEL"]},{"entry":"(4430-62)"},{"entry":["11\/560,174","Nov. 15, 2006","METHOD AND APPARATUS FOR"]},{"entry":["(4430-66)",{},"TRANSFERRING SNAPSHOT DATA"]},{"entry":["11\/624,524","Jan. 18, 2007","METHOD AND APPARATUS FOR"]},{"entry":["(4430-67)",{},"QUICKLY ACCESSING BACKING"]},{"entry":[{},{},"STORE METADATA"]},{"entry":["11\/624,565","Jan. 18, 2007","DELETION OF ROLLBACK"]},{"entry":["(4430-68)",{},"SNAPSHOT PARTITION"]},{"entry":["11\/747,109","May 10, 2007","AUTOMATIC TRIGGERING OF"]},{"entry":["(4430-69)",{},"BACKING STORE"]},{"entry":[{},{},"RE-INITIALIZATION"]},{"entry":["11\/747,127","May 10, 2007","BACKING STORE"]},{"entry":["(4430-70)",{},"REINITIALIZATION METHOD AND"]},{"entry":[{},{},"APPARATUS"]},{"entry":["11\/768,127","Jun. 25, 2007","SNAPSHOT RESET METHOD AND"]},{"entry":["(4430-72)",{},"APPARATUS"]},{"entry":["11\/779,965","Jul. 19, 2007","METHOD AND APPARATUS FOR"]},{"entry":["(4430-73)",{},"SEPARATING SNAPSHOT"]},{"entry":[{},{},"PRESERVED AND WRITE DATA"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The present invention is directed to data storage management. In particular, the present invention is directed to methods and apparatuses for cloning snapshots.","The need to store digital files, documents, pictures, images and other data continues to increase rapidly. In connection with the electronic storage of data, various data storage systems have been devised for the rapid and secure storage of large amounts of data. Such systems may include one or a plurality of storage devices that are used in a coordinated fashion. Systems in which data can be distributed across multiple storage devices such that data will not be irretrievably lost if one of the storage devices (or in some cases, more than one storage device) fails are also available. Systems that coordinate operation of a number of individual storage devices can also provide improved data access and\/or storage times. Examples of systems that can provide such advantages can be found in the various RAID (redundant array of independent disks) levels that have been developed. Whether implemented using one or a plurality of storage devices, the storage provided by a data storage system can be treated as one or more storage volumes.","In order to facilitate the availability of desired data, it is often advantageous to maintain different versions of a data storage volume. Indeed, data storage systems are available that can provide at least limited data archiving through backup facilities and\/or snapshot facilities. The use of snapshot facilities greatly reduces the amount of storage space required for archiving large amounts of data.","Snapshots provide a versatile feature that is useful for data recovery operations, such as backup and recovery of storage elements. However, traditional snapshots are read-only accessible and their contents cannot be modified, thereby rendering their use somewhat limited, particularly for operating systems and applications that do not have a notion of a read-only data store (e.g., a read-only file system) and that expect to write metadata at any time that the file system is accessible. When a storage element that is held in a snapshot is exported to a client or host and contains the data for such a problematic file system, an issue arises in that the host may attempt to write data to the read-only image. This is a fundamental issue in the design of a reliable system for backups. In general, once a backup image is made via a mechanism like a snapshot, that image should be maintained as a point-in-time representation of the storage volume. A controller typically modifies snapshot data by what is known as a copy-on-write (COW) operation. The COW operation determines when a change to a storage volume is going to occur and then determines if the targeted blocks of that storage volume have changed since a snapshot was taken. If the blocks have not changed since the snapshot was taken, then the controller proceeds by copying the original contents of those blocks and writing them to the snapshot data prior to changing the storage volume. The COW operation ensures that the data from the storage volume at the point-in-time that a snapshot was taken either resides on the storage volume or on the snapshot. The controller therefore changes the snapshot only when doing so is required to preserve the data that was on the storage volume at the time the snapshot was taken, but that will be overwritten on the storage volume.","On the other hand, direct modification of a snapshot image (e.g., direct modification by a client or host rather than a controller performing a COW operation) could have serious consequences. Such consequences may include the fact that the data of the snapshot is no longer a point-in-time copy and a consistent image of the storage volume may no longer be available for subsequent recovery operations. Accordingly, most snapshot facilities do not allow a host to write data directly to a snapshot, because doing so will change the point-in-time representation of that snapshot. Thus, most snapshots are limited to read-only operations.","A relatively recent advance in backup facilities is the ability to \u201cclone\u201d an existing snapshot, and perform a backup of the clone instead of from the active file system. With this type of file system, the file server is allowed to remain on-line during the backup. A clone of a snapshot is generally intended to represent the same point-in-time as the snapshot from which the clone originated. Accordingly, clones have the same read-only restrictions imposed on them as their parent snapshots and those that do not have read-only restriction imposed thereon cannot guarantee that a snapshot or its clone actually represent the point-in-time that the snapshot was taken. Another drawback to current cloning systems is that the creation of a clone may take a significant amount of time to complete because most cloning systems create a complete block-by-block copy of the snapshot for the clone. This complicates the creation of a single clone and all but precludes the creation of multiple clones of the same storage volume. The result is that clones tend to be used, one at a time, for short term operations and then are deleted.","The present invention is directed to solving these and other problems and disadvantages of the prior art. In accordance with embodiments of the present invention, a service for efficiently cloning a snapshot is provided. The method generally comprises identifying a first snapshot of a storage volume, where the first snapshot corresponds to a first point-in-time capture of data on the storage volume. The method also comprises altering the first snapshot after the first point-in-time and creating a second snapshot that is a clone of the first snapshot and corresponds to the first point-in-time capture of the data on the storage volume. In accordance with at least some embodiments of the present invention, the method may be characterized by the fact that the second snapshot comprises less data than the first snapshot. By creating a clone snapshot with less data than its base snapshot, the efficiency of creating clone snapshots is greatly increased.","In accordance with other embodiments of the present invention, a device for controlling a storage system is provided. The device generally comprises a cloning application, where the cloning application is adapted to create a first clone snapshot of a base snapshot. The base snapshot may comprise a first data structure for maintaining preserved data in association with the base snapshot and a second data structure for maintaining write data in association with the base snapshot. Additionally, the first clone snapshot may reference the first data structure for preserved data and comprise a third data structure for maintaining write data in association with the first clone snapshot. This allows the first clone snapshot to share the preserved data of its base snapshot such that both snapshots can initially correspond to the same point-in-time of a storage volume. This may allow users to create a control data set established by the base snapshot that can be individually altered at each clone snapshot. Such a feature may be useful in conducting multiple experiments and variations thereof on a base data set without fear of having one experiment affect another experiment.","In accordance with still other embodiments of the present invention, a clone of a snapshot corresponding to a point-in-time capture of data on a storage volume is provided. The base snapshot may comprise both preserved data and write data whereas the clone snapshot may comprise a first data structure that references the preserved data of the snapshot and a second data structure for maintaining write data in association with the clone.","Additional features and advantages of embodiments of the present invention will become more readily apparent from the following description, particularly when taken together with the accompanying drawings.","In accordance with embodiments of the present invention, a snapshot is a block level point-in-time representation of data on a storage volume. The data is essentially frozen in time at the instant that the snapshot is taken. Although data on the storage volume may change as a result of write operations, the data within the snapshot will remain constant and frozen in time at the instant that the snapshot was taken. In order to preserve snapshot data, a backing store, also known as a snap pool, is used to store data that is not otherwise represented in the storage volume and snapshot metadata. All data and metadata associated with the snapshot is stored in the backing store. In accordance with embodiments of the present invention, data is stored within the snapshot in \u201cchunks.\u201d A chunk is equivalent to a number of Logical Block Addresses (LBAs). Alternatively or in addition, data can be stored within subchunks. A subchunk is a fixed size subset of a chunk. Pointers, table entries, or other data structures can be used to identify the location of a chunk in the backing store.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["100","104","108","100","112","100","116","112"]},"The data storage systems ,  are typically interconnected to one another through an in-band network . The in-band network  may also interconnect the data storage systems ,  to a host computer  and\/or an administrative computer . The electronic data system  may also include an out-of-band network  interconnecting some or all of the electronic data system  nodes , ,  and\/or . For example, one or more host computers  are connected to each data storage system , . For instance, a first data storage system  is connected to a second data storage system  across some distance by a Fibre Channel or a TCP\/IP network , and each of these data storage systems ,  is connected to a host computer  through an in-band  and\/or an out-of-band  network.","The in-band or storage area network  generally functions to transport data between data storage systems  and\/or  and host devices , and can be any data pipe capable of supporting multiple initiators and targets. Accordingly, examples of in-band networks  include Fibre Channel (FC), iSCSI, parallel SCSI, Ethernet, ESCON, or FICON connections or networks, which may typically be characterized by an ability to transfer relatively large amounts of data at medium to high bandwidths. The out-of-band network  generally functions to support the transfer of communications and\/or commands between various network nodes, such as data storage resource systems , , host computer , and\/or administrative computers , although such data may also be transferred over the in-band communication network . Examples of an out-of-band communication network  include a local area network (LAN) or other transmission control protocol\/Internet protocol (TCP\/IP) network. In general, the out-of-band communication network  is characterized by an ability to interconnect disparate nodes or other devices through uniform user interfaces, such as a web browser. Furthermore, the out-of-band communication network  may provide the potential for globally or other widely distributed management of data storage systems ,  via TCP\/IP.","Every electronic data system node or computer , ,  and , need not be interconnected to every other node or device through both the in-band network  and the out-of-band network . For example, no host computer  needs to be interconnected to any other host computer , data storage system , , or administrative computer  through the out-of-band communication network , although interconnections between a host computer  and other devices , ,  through the out-of-band communication network  are not prohibited. As another example, an administrative computer  may be interconnected to at least one storage system  or  through the out-of-band communication network . An administrative computer  may also be interconnected to the in-band network  directly, although such an interconnection is not required. For example, instead of a direct connection, an administrator computer  may communicate with a controller of a data storage system ,  using the in-band network .","In general, a host computer  exchanges data with one or more of the data storage systems ,  in connection with the performance of the execution of application programming, whether that application programming concerns data management or otherwise. Furthermore, an electronic data system  may include multiple host computers . An administrative computer  may provide a user interface for controlling aspects of the operation of the storage systems , . The administrative computer  may be interconnected to the storage system ,  directly, and\/or through a bus or network  and\/or . In accordance with still other embodiments of the present invention, an administrative computer  may be integrated with a host computer . In addition, multiple administrative computers  may be provided as part of the electronic data system . Furthermore, although two data storage systems ,  are shown in , an electronic data system  may include more than two data storage systems or may include a single data storage system.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["104","108","104","108","204","204","204","204","204","204","104","204","104","204","204","204","112","116"]},"A data storage system , , in accordance with embodiments of the present invention, may be provided with a first controller slot . In addition, other embodiments may include additional controller slots, such as a second controller slot . As can be appreciated by one of skill in the art, a controller slot  may comprise a connection or set of connections to enable a controller  to be operably interconnected to other components of the data storage system , . Furthermore, a data storage system ,  in accordance with embodiments of the present invention includes at least one controller . For example, while the data storage system ,  is operated in a single controller, non-failover mode, the data storage system ,  may include exactly one controller . A data storage system ,  in accordance with other embodiments of the present invention may be operated in a dual redundant active-active controller mode by providing a second controller . When a second controller is used in addition to a first controller , the second controller slot receives the second controller. As can be appreciated by one of skill in the art, the provision of two controllers, and , permits data to be mirrored between the controllers -, providing redundant active-active controller operation.","One or more busses or channels  are generally provided to interconnect a controller or controllers  through the associated controller slot or slots  to the storage devices . Furthermore, while illustrated as a single shared bus or channel , it can be appreciated that a number of dedicated and\/or shared buses or channels may be provided. Additional components that may be included in a data storage system  include one or more power supplies  and one or more cooling units . In addition, a bus or network interface  may be provided to interconnect the data storage system ,  to the bus or network , and\/or to a host computer  or administrative computer .","Although illustrated as a complete RAID system in , it should be appreciated that the data storage system ,  can comprise one or more storage volumes implemented in various other ways. For example, the data storage system ,  may comprise a hard disk drive or other storage device  connected or associated with a server or a general-purpose computer. As further examples, the storage system  may comprise a Just a Bunch of Disks (JBOD) system or a Switched Bunch of Disks (SBOD) system.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":["212","212","304","212","304","304","304"]},"A controller  also generally includes memory . The memory  is not specifically limited to memory of any particular type. For example, the memory  may comprise a solid-state memory device, or a number of solid-state memory devices. In addition, the memory  may include separate non-volatile memory  and volatile memory  portions. As can be appreciated by one of skill in the art, the memory  may include a read cache  and a write cache  that are provided as part of the volatile memory  portion of the memory , although other arrangements are possible. By providing caches , , a storage controller  can improve the speed of input\/output (IO) operations between a host  and the data storage devices  comprising an array or array partition. Examples of volatile memory  include DRAM and SDRAM.","The non-volatile memory  may be used to store data that was written to the write cache of memory  in the event of a power outage affecting the data storage system . The non-volatile memory portion  of the storage controller memory  may include any type of data memory device that is capable of retaining data without requiring power from an external source. Examples of non-volatile memory  include, but are not limited to, compact flash or other standardized non-volatile memory devices.","A volume information block  may be stored in the non-volatile memory , although in accordance with at least some embodiments of the present invention, the volume information block  resides in volatile memory . The volume information block  comprises data that may be used to represent attribute and state information for master volumes, backing stores, and\/or snapshots. Each master volume, backing store, and snapshot is typically associated with a different volume information block . The volume information block  is generally employed by the processor  to determine whether certain data is located on master volumes, backing stores, and\/or snapshots and whether such data is safe to access based on the state of each. For example, the state of a master volume or backing store may be such that if data access were attempted, data corruption may occur. Accordingly, the volume information block  may be referenced prior to data access during an I\/O operation.","The memory  also includes portions of the memory  comprising a region that provides storage for controller code . The controller code  may comprise a number of components, including an I\/O application  comprising instructions for accessing and manipulating data. The I\/O application  may provide the controller  with the ability to perform read and\/or write operations of data on a storage volume and\/or on a snapshot. The I\/O application  may reference the volume information block  prior to executing such operations. The I\/O application  may also employ the read and write caches  and  respectively when performing such operations.","A snapshot cloning application  is an example of another application that may be included in the controller code . The snapshot cloning application  may be adapted to create and manage clones of existing snapshots. In accordance with at least one embodiment of the present invention, the snapshot cloning application  is characterized by the ability to create snapshot clones that represent the same point-in-time as their base snapshot, even if the base snapshot allows both read and write operations. Furthermore, the snapshot cloning application  may be adapted to create clone snapshots that support controller  initiated and host  initiated read and write operations.","The controller code  may also comprise a snapshot delete process or application  comprising instructions for deleting a snapshot from a backing store as described herein. The snapshot delete application  may be operable to delete snapshots having clones as well as clone snapshots themselves. Further details of the snapshot delete application  are described more fully in U.S. patent application Ser. No. 11\/560,174, filed on Nov. 15, 2006, the entire contents of which are hereby incorporated herein by this reference.","A storage controller  may additionally include other components. For example, a bus and\/or network interface  may be provided for operably interconnecting the storage controller  to the remainder of the data storage system , for example through a controller slot  and a bus or channel . Furthermore, the interface  may be configured to facilitate removal or replacement of the storage controller  in a controller slot  as a field replaceable unit (FRU). In addition, integral signal and power channels may be provided for interconnecting the various components of the storage controller  to one another.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","b":["400","404","404","404","212","404","112","404","404","404","404","404","404","404"],"i":["a ","b "]},"In accordance with one embodiment of the present invention, preserved data is only copied to the newest snapshot during a COW operation that is initiated when there is a write of data to the master volume. As a result of a snapshot only being updated during a COW, it is possible that the older snapshot does not contain a pointer or table entry for all data from the master volume at the time the older snapshot was taken. Rather, data stored on the master volume at the time the older snapshot was taken may be preserved in association with the first snapshot if that data was not written until after the newer snapshot was taken. Alternatively, if the data has not changed on the master volume since a snapshot was taken, the data for the snapshot is maintained on the master volume.","A TLPT  generally comprises a list of pointers, where each pointer points to a different Bottom Level Page Table (BLPT) . The pointers to each BLPT  are typically stored in the TLPT  as a TLPT Entries (TLPTEs) . Each TLPTE  does not necessarily need to point to a BLPT, meaning that a TLPTE  can have a null value until additional snapshot data needs to stored in association with the TLPT . Accordingly, when a snapshot of a master volume is taken, a TLPT  can be created with TLPTEs -N, where N is typically greater than or equal to one. In one embodiment, upon creation of a snapshot, a TLPT  is created with a number of TLPTEs -N. These TLPTEs -N are initially empty (i.e., have a null value). Each TLPTE  corresponds to a BLPT  and therefore a range of BLPT Entries (BLPTEs) . A structure of BLPTEs  are also created with each BLPTE  being reserved to point at a particular chunk  corresponding to a Logical Block Address (LBA) on the master volume. However, since data from the master volume is only written to the backing store when the master volume is being rewritten the BLPTEs  are initially null as well. As the operation of the master volume continues some of the TLPTEs -N may eventually have pointers to BLPTs , whereas other TLPTEs -N may be empty. A pointer included in a TLPTE  is generally stored as a memory address of the BLPT and generally has a size of about 4 bytes but can have a size of up to about 8 bytes. Although the TLPTEs -N are shown being filled in order (i.e., the first TLPTE is filled before the second TLPTE which is filled before the Nth TLPTE N), the order in which TLPTEs -N are populated may be arbitrary.","The BLPTs -N contain pointers, stored as BLPTEs , that point to actual preserved data or write data for the snapshot associated with the corresponding TLPT . In one embodiment, each BLPTE -M represents a range or \u201cchunk\u201d that comprises at least a subset of the snapshot data -K on the backing store . An address chunk identifier  identifies the location of the corresponding chunk of data  on the backing store . A chunk  stores data that provides a moment in time picture of an LBA on the master volume. Therefore, two different chunks  can store data related to the same LBA but taken at different times.","Each chunk -K may be further divided into subchunks via the use of a present bitmap . Although described as a bitmap, one skilled in the art will appreciate that the present bitmap  may be replaced with any other type of data table or map used to organize and manage chunk and subchunk data. The present bitmap  information stored in the BLPTE  can be used to indicate where that subchunk is located within the chunk , either on the backing store  or on the master volume and if the subchunk contains user data. In accordance with one embodiment, each chunk  corresponds to about 2 MB of memory and each subchunk corresponds to about 64 KB of memory. As can be appreciated by one skilled in the art, the chunk address identifiers  for each BLPTE  in a BLPT  does not need to be assigned to a chunk  consecutively as shown in . For example, the Mth BLPTE  of the first BLPT could be allocated before first BLPTE  of the first BLPT . However, in other embodiments, the BLPTEs  could be assigned chunks  consecutively to make assignment of chunks more orderly.","The controller  uses a hierarchical system of pointers to store snapshot data so that read and write commands for the snapshot data can be quickly and efficiently executed. When a snapshot read command is received by the controller , the controller  can quickly locate a portion of snapshot data by first identifying the TLPT  corresponding to the requested snapshot then drill down to the requested data using the pointers in the TLPT  and BLPT . If the controller  determines that the data is not on the requested snapshot (e.g., ), the controller  will search for a newer snapshot (e.g., ). If the data is not on the newer snapshot (e.g., ), then the data will be on the master volume. However, in accordance with one embodiment of the present invention, when a newer snapshot is deleted, the controller  will ensure that data which should be stored on an older snapshot but was stored on the snapshot being deleted is preserved in the older snapshot before the newer snapshot is deleted so that such data is not lost.","Although the data structure  employed in accordance with preserving snapshot data is depicted and described as having two levels of entries (i.e., top levels and bottom levels), it can be appreciated by one of skill in the art that a greater or lesser number of levels may be employed. For instance, several levels of entries may be utilized. Additionally, aspects of the present invention may be employed with different levels of indirect page tables. Furthermore, other types of snapshot data structures may be employed in accordance with embodiments of the present invention such as B-Trees and other similar quick-lookup data structures.","With reference to , a series of snapshots and clone snapshots will be described in accordance with at least some embodiments of the present invention. Referring initially to , a master volume  is depicted having two snapshots and associated therewith. The snapshots are ordered based on their relative age where the first snapshot is a newer snapshot of the master volume  than the second snapshot . Accordingly, if the I\/O application  were searching for snapshot data associated with the second snapshot , the I\/O application  would first search the second snapshot , and if the data is not found there, the I\/O application  would search the first snapshot . If the data is not on the first snapshot , then the I\/O application  would find the data on the master volume .","As noted above, each snapshot  may be created with separate and distinct preserved data  and write data . The preserved data  may correspond to a first TLPT and the write data  may correspond to a second TLPT. Accordingly, changes to the snapshot  by a COW operation may affect the preserved data  while host initiated changes to the snapshot  may affect the write data .","Changes in the master volume  made after creation of the second snapshot but before creation of the first snapshot are written to the preserved data  of the second snapshot . The preserved data  of the second snapshot is changed by COW operations initiated by the controller . However, once the newer first snapshot is created, the preserved data  of the second snapshot is not changed. Rather, changes to the master volume  are reflected in the preserved data  of the first snapshot ","Referring now to , the snapshot cloning application  may create a first clone snapshot of the first snapshot . The first clone snapshot is assigned an \u201cage\u201d that is relatively older than the first snapshot , although the first clone snapshot effectively represents the same point-in-time of the master volume  as the first snapshot . Since the first clone snapshot is associated with the first snapshot , it will be considered newer than the second snapshot that was created prior to the first snapshot ","In accordance with embodiments of the present invention, the first clone snapshot is created with separate data structures for the preserved data  and write data  much like its base snapshot (i.e., first snapshot ). Unlike the base snapshot, however, the preserved data structure  for the first clone snapshot is empty or null. Instead of maintaining its own preserved snapshot data , the first clone snapshot utilizes the preserved data  of its base snapshot. The preserved data  for the first clone snapshot may be associated with or share the preserved data  of the first snapshot by assigning the first clone snapshot the same image ID as the base snapshot. This way, when the I\/O application  is searching for preserved data from the first clone snapshot , the I\/O application  will know to search the base snapshot.","In accordance with further embodiments of the present invention, considering the clone snapshot  as an older snapshot than its base snapshot  will allow the I\/O application  to use its normal search algorithm to find the snapshot data for the clone snapshot . Since the first clone snapshot does not have any preserved data, when the I\/O application  searches the first clone snapshot for preserved data  it will find none and automatically move on to search the base snapshot  where the preserved data  is maintained for the clone .","The write data  of the first clone snapshot may also be created as an empty data structure. In other words, the write data  may initially correspond to a TLPT  that has no values for its TLPTEs . The write data  may only be populated in response to a host  initiated write command. All other changes to the first clone snapshot may correspond to COW operations initiated by the controller , which change the preserved data  of the first snapshot rather than altering the first clone snapshot ","Referring now to , a second clone snapshot may be created in a similar fashion to the first clone snapshot . The second clone snapshot may either be a direct clone of the first snapshot or a clone of the first clone snapshot . Regardless, the second clone snapshot may comprise separate data structures for the preserved data  and write data . The preserved data structure  may be left empty and may therefore share the preserved data of its base snapshot (i.e., the first snapshot ). Alternatively, the clone  may be created without any data structure for preserved data . Either way, a plurality of snapshot clones  may be created without creating multiple copies of the same preserved data . Furthermore, the clone snapshots  may be maintained for a relatively long amount of time since a change to the clone snapshot's  write data  will not affect the write data  or preserved data  of the base snapshot .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 6","b":["520","508","512","516","604","508","504","512","508","212","516","508","112","512","516","608","212","112","504","212","512","516"]},"At some point after the first snapshot  has been created, and likely after it has been altered, the controller  receives a request to clone the first snapshot  (step ). The request may be initiated by a host  or administrative computer . Alternatively, the request may be controller  initiated in response to instructions stored on the controller  requesting the automatic creation of a clone snapshot  at a particular point time.","In response to receiving the request, the snapshot cloning application  creates the clone  along with a data structure for the clone's write data  (step ). In accordance with one embodiment of the present invention, the snapshot cloning application  creates clone snapshots  without preserved data structures. In an alternative embodiment, the snapshot cloning application  creates a data structure for the clone's  preserved data, but that particular data structure will remain empty since the clone  will be sharing the preserved data  of its base snapshot  (e.g., the first snapshot).","As an alternative to creating a preserved data structure for the clone snapshot , the snapshot cloning application  assigns the clone snapshot  an image ID equal to the image ID of the base snapshot (step ). The image ID may provide the I\/O application  with an indication of which snapshot should be searched when the I\/O application  attempts a search of the clone  for preserved data. In other words, the I\/O application  may quickly identify a clone's  base snapshot  by referencing the image ID and thus may be able to skip directly to the preserved data  of the base snapshot rather than searching a number of clones . This may prove especially useful if a base snapshot  has a large number of clone snapshots .","After the snapshot cloning application  has assigned the clone snapshot  an image ID, the snapshot cloning application  continues by designating the clone snapshot  as older than its base snapshot  (step ). The relative age designation can help facilitate snapshot data retrieval functions in that the clone snapshot  will first be searched for its snapshot data. If the data is not found on the clone snapshot , then a snapshot-searching algorithm executed by the I\/O application  will cause the newer (i.e., the base snapshot  having the preserved data ) to be searched next.","Thereafter, the operation of the data storage system  may continue where changes to the master volume  are reflected in the preserved data  of the newest snapshot. However, a host  or the like can directly alter the clone snapshots  and other snapshots  in the write data . Accordingly, the method continues upon receiving a host  request to alter a clone snapshot  (step ). In response to receiving this direct request, the write data  of the identified snapshot is altered according to the host's  request (step ). Advantageously, altering the write data  for a clone snapshot  will not affect its base snapshot  and vice versa.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 7","b":["212","704","708","112","112","504"]},"Upon receiving the request, the controller  determines if the change in snapshot data is due to a COW operation (step ). In other words, the controller  determines if the master volume  has changed such that original data on the master volume  needs to be transferred to snapshot data prior to changing the master volume . In the event that the change in snapshot data is required as a part of a COW operation, the controller  continues by changing the preserved data  of the newest base snapshot  associated with the master volume  (step ).","In the event that the change to snapshot data is not due to a COW operation, and is instead a direct request by a host  to change the snapshot data, then the controller  determines if the targeted snapshot is a clone snapshot  (step ). This determination may be made affirmatively if the snapshot does not have any preserved data  associated therewith. If the targeted snapshot is a clone snapshot , then the controller  continues by altering the write data  of the clone snapshot  (step ). On the other hand, if the targeted snapshot does not correspond to a clone snapshot  (i.e., it is a base snapshot), then the controller  changes the write data  of the snapshot , which may be considered a base snapshot if it has a corresponding clone  (step ).","Once the appropriate snapshot data has been changed, the method continues by determining if a new clone snapshot  is requested (step ). If a new clone snapshot  has not been requested, then the method returns back to step  where the controller  awaits its next commands. However, if a request for a new clone snapshot  has been received, then the controller  utilizes the snapshot cloning application  to create a clone snapshot  along with its associated write data structure  (step ). Thereafter, the clone snapshot  is assigned an image ID equal to the image ID of its base snapshot  (step ). Assigning the clone  and base snapshot  the same image ID provides a reference between the clone snapshot  and the base snapshot  such that the clone snapshot  can share the preserved data  of its base snapshot . Once the clone snapshot  has been successfully created, the method returns back to step .",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 8","b":["212","804"]},"Upon receiving the request, the controller  employs the I\/O application  to determine if the data is associated with a clone snapshot  (step ). In other words, the I\/O application  determines if the data was requested from a clone snapshot . If the data is from a clone snapshot , then the I\/O application  searches the write data  of the identified clone snapshot  (step ). The I\/O application  may search each memory location associated with the write data  by scanning the TLPT  and possibly the BLPTs  associated with the write data . The I\/O application  will search all of the write data  to determine if the data is found in the write data structure  (step ). If the data is found in the write data , then the I\/O application  continues by retrieving the requested data from the backing store  and pulls it into the read cache  (step ). Of course, the I\/O application  may reference the volume information block  to determine if the requested data is currently in use by another task or application. If the data is marked as currently in use, the I\/O application  may wait to retrieve the data so that data corruption does not occur.","After the data has been retrieved from the proper storage device  and pulled into the read cache , the I\/O application  performs the requested I\/O command (step ). The actions performed in connection with the I\/O command may include providing the requested data to the host  or administrative computer , performing a write of the requested data, or any combination thereof.","Referring back to step  and , if the requested data is not from a clone  or if the requested data was from a clone  but not found on the write data  of the clone , then the I\/O application  continues by searching the preserved data  of base snapshot  (step ). The base snapshot  corresponds to the base of the clone snapshot  if there was a clone snapshot. If there are multiple clones  of the same snapshot, then the I\/O application  may optimize its search for the requested data by skipping all other clone snapshots  and moving directly to the base snapshot . Alternatively, if there was no clone snapshot , the base snapshot  that is searched is the actual snapshot associated with the requested data. The I\/O application  will search the preserved data  until either the requested data is found or the I\/O application  has determined that the requested data is not stored on the preserved data  of the base snapshot (step ). If the data is found on the preserved data  of the base snapshot , then the method proceeds to step , where the requested data is retrieved from the storage device .","However, if the requested data is not found on the preserved data , then the I\/O application  continues searching for the snapshot data on a newer, if such a snapshot exists (step ). The I\/O application  generally searches newer snapshots that are base snapshots  and skips any clone snapshots  that are considered newer, since such snapshots do not typically comprise preserved data . The I\/O application  searches the preserved data  of the newer base snapshot , if there is any, and determines if the requested data has been stored on that snapshot's  preserved data  (step ). If the requested data is found on the newer snapshot, then the I\/O application  retrieves the subject data from the proper storage device  (step ).","On the other hand, if there was not a newer base snapshot , or if the data was not found on the newer snapshot, then the method continues by determining if there are any newer snapshots than the one previously searched (step ). If there are more newer snapshots of the same master volume , then the I\/O application  continues by searching the next newer base snapshot  (step ). If there are no newer snapshots of the master volume , then the I\/O application  retrieves the requested data from the master volume  itself (step ). The data is on the master volume  because it has not been changed since any the requested snapshot was taken and therefore the data has not been transferred to a snapshot via a COW operation. After the data has been recovered from the master volume , then method continues with the I\/O application  performing the requested I\/O command (step ).",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 9","b":["212","904","112","116","212"]},"Upon receiving the request to delete a snapshot, the controller  utilizes the snapshot delete application  to determine if the subject snapshot is a clone snapshot  (step ). The snapshot delete application  may check the data structures of the subject snapshot to make this determination. If the snapshot has a preserved data structure  populated with snapshot data, then the snapshot delete application  may determine that the snapshot is not a clone. If the snapshot does not have a preserved data structure , or has an empty preserved data structure , then the snapshot delete application  may determine that the snapshot is a clone snapshot.","In the event that the subject snapshot is determined to be a clone snapshot , then the snapshot delete application  continues by deleting the subject snapshot (step ). Of course, the snapshot delete application  may reference the volume information block  prior to deleting the subject snapshot to ensure that its data is not currently in use by another application. The snapshot delete application  may delete the subject snapshot by clearing all of the entries of its associated data structures or by deleting the entire data structures. Alternatively, the snapshot delete application  may delete the snapshot and its associated data on an entry-by-entry basis, depending upon if another application is currently using some but not all of the snapshot data.","If the subject snapshot is not determined to be a clone snapshot , that is the snapshot is a base snapshot  or a traditional snapshot without a clone snapshot, then the method continues with the snapshot delete application  determining if the subject snapshot has a clone snapshot (step ). This determination may be made by comparing the subject snapshot's image ID with the image ID of each snapshot that is considered older than the subject snapshot. If an older snapshot is found having the same image ID, then the snapshot delete application  may determine that the subject snapshot has a clone snapshot. In the event that the subject snapshot does have a clone snapshot, the snapshot delete application  transfers the preserved data  of the subject snapshot to the clone snapshot (step ). The transfer of the preserved data  is important since the clone snapshot is relying upon the preserved data  of its base snapshot. If the base snapshot is deleted along with its preserved data , then the point-in-time picture of the clone snapshot will be lost. If there are multiple clones of the base snapshot, then the preserved data  can be transferred to the most recent of those clone snapshots. The most recent clone snapshot may then be considered the base snapshot for all other clone snapshots. This allows all other clones to continue sharing the preserved data  of their base snapshot and avoids the need for multiple copies of the same preserved data . Once the preserved data  has been transferred to the newest clone snapshot, the snapshot delete application  continues by deleting the subject snapshot (step ).","Referring back to step , if the subject snapshot does not have a clone snapshot, then the snapshot delete application  determines if there are any snapshots of the master volume  that are older than the subject snapshot (step ). This determination may be made by comparing the image ID of each snapshot associated with a particular master volume . If there are no snapshots of the same master volume  that are older than the subject snapshot, then the snapshot delete application  continues by deleting the subject snapshot (step ).","However, if there are snapshots of the same master volume  that are older than the subject snapshot, then those snapshots may require data from the subject snapshot's preserved data field . In other words, data associated with the point-in-time of the older snapshot may be stored in association with the subject snapshot's preserved data . Accordingly, if there are older snapshots of the same master volume , then the snapshot delete application  determines the difference between the preserved data  of the subject snapshot and the preserved data  of the older snapshot (step ). In other words, the snapshot delete application  may perform a chunk-by-chunk comparison of the preserved data  of each snapshot to determine if the subject snapshot is storing snapshot data that should be transferred to the older snapshot.","Once the snapshot delete application  has identified what, if any, preserved data  needs to be transferred to the older snapshot, the snapshot delete application  continues by transferring the actual data to the older snapshot (step ). In accordance with one embodiment of the present invention, the snapshot data is transferred by updating pointers within the preserved data structure  of the older snapshot such that they point to the LBA range where the required snapshot data is stored on the backing store . This way, the snapshot delete application  does not have to create a copy of the actual data but only has to change the pointer of the older snapshot's preserved data structure . Once the necessary data has been transferred to the older snapshot, the subject snapshot may be deleted (step ).","Finally, those skilled in the art should appreciate that they can readily use the disclosed conception and specific embodiments as a basis for designing or modifying other structures for carrying out the same purposes of the present invention without departing from the spirit and scope of the invention as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
