---
title: Systems and methods for managing shared resources in a computer system
abstract: An operating system is provided wherein a plurality of objects are established and registered in response to requests from hardware or software associated with the computer system. The objects include at least one type, at least one attribute, and a handle. The plurality of objects are then manipulated to effect processing and exchange of information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08028298&OS=08028298&RS=08028298
owner: Conexant Systems, Inc.
number: 08028298
owner_city: Newport Beach
owner_country: US
publication_date: 20030818
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present application claims priority to co-pending U.S. Provisional Patent Application No. 60\/403,660, filed Aug. 16, 2002, the entirety of which is incorporated by reference herein.","The present invention relates generally to the field of computer systems and, more particularly, to systems for scheduling process execution to provide optimal performance of the computer system.","The operation of modern computer systems is typically governed by an operating system (OS) software program which essentially acts as an interface between the system resources and hardware and the various applications which make requirements of these resources. Easily recognizable examples of such programs include Microsoft Windows\u2122, UNIX, DOS, VxWorks, and Linux, although numerous additional operating systems have been developed for meeting the specific demands and requirements of various products and devices. In general, operating systems perform the basic tasks which enable software applications to utilize hardware or software resources, such as managing I\/O devices, keeping track of files and directories in system memory, and managing the resources which must be shared between the various applications running on the system. Operating systems also generally attempt to ensure that different applications running at the same time do not interfere with each other and that the system is secure from unauthorized use.","Depending upon the requirements of the system in which they are installed, operating systems can take several forms. For example, a multi-user operating system allows two or more users to run programs at the same time. A multiprocessing operating systems supports running a single application across multiple hardware processors (CPUs). A multitasking operating system enables more than one application to run concurrently on the operating system without interference. A multithreading operating system enables different parts of a single application to run concurrently. Real time operating systems (RTOS) execute tasks in a predictable, deterministic period of time. Most modern operating systems attempt to fulfill several of these roles simultaneously, with varying degrees of success.","Unfortunately, the ability of known operating systems to efficiently handle resource allocation and application\/hardware performance on embedded systems remains deficient to the requirements of modern systems, particularly embedded systems. Accordingly, there is a need in the art of computer systems for an operating system which enables such efficient and accurate handling of requirements in an embedded system. Further, there is a need for an operating system which can work together with conventional operating systems, thereby enabling conventional systems to work with hardware\/software for which it was not specifically designed.","This present invention overcomes the above-described limitations and deficiencies by providing a operating system environment including the following elements: 1.) system service abstraction API (application programming interface); 2.) legacy service API to support existing OS code; 3.) native (i.e., new) OS implementation; 4.) hosted 3rd party OS implementation; 5.) structural abstraction to allow broad application together with excellent performance (interfaces); 6.) a simplified object-oriented system design and properties to provide consistent end user API and minimized implementation work for new hosted 3party platforms; 7.) unique interrupt handling architecture; 8.) architectural support for hardware acceleration; and 9.) support for multiprocessor\/multi-ASIC designs.","In one embodiment of the present invention, a method for managing shared resources in a computer system is provided comprising establishing and registering a plurality of objects in response to requests from hardware or software associated with the computer system. The objects include at least one type, at least one attribute, and a handle. The plurality of objects are then manipulated to effect processing and exchange of information.","The inventive operating system (hereinafter referred to as the Quantum\u2122 operating system or simply, Quantum\u2122) provides a new execution environment for applications and driver software. It targets the embedded software space, where issues such as performance, real-time response, software reliability, and hardware flexibility are dominant. Quantum\u2122 aims to provide all client embedded applications with the following:","1. Pre-emptive multitasking with sophisticated application quality of service (QoS);","2. Support for protected and virtual memory on platforms with a hardware MMU;","3. Support for multi-processor hardware configurations;","4. Inherent application portability to third party OS platforms;","5. Inherent application portability to new hardware architecture;","6. Increased performance over comparable OS platforms such as ATMOS\u2122 from GlobespanVirata Incorporated;","7. A single, simple programming model for all software; and","8. Support for all existing ATMOS\u2122 applications.","More particularly, the Quantum\u2122 operating system aims to provide these features by means of a new OS Kernel, hereinafter referred to as ATMOS2. The APIs have also been concurrently specified to map to other OS platforms, allowing easy support of Quantum\u2122 compliant applications and drivers on other third party OS software regimes.","Referring now to , there is shown a generalized block diagram illustrating two potential Quantum\u2122 configurations: a native configuration  and a hosted configuration . The various public APIs  (application program interfaces) for Quantum\u2122 have been carefully designed to allow extremely efficient implementations on target hardware platforms, while also providing a relatively simple mapping to a typical third party OS platform . The underlying design is also intended to take advantage of hardware accelerators to improve message passing and general task scheduling behavior. On dual-processor class ASICs (application-specific integrated circuits), such as the Helium\u2122 series devices from GlobespanVirata Incorporated of Redbank, N.J., this acceleration can be provided for the first or protocol processor (PP) by means of a software assist running in parallel on the second or network processor (NP). On future ASICs, additional hardware support may be added to improve the efficiency and performance of the task scheduling system. For this reason, the \u201cnative\u201d implementation is usually not shown as a distinct entity from Quantum\u2122 itself, since functions may be implemented by hardware directly or by a few inline assembler instructions.","A public API in Quantum\u2122 is any programmatic interface that may used by software, either application or driver-specific code, outside of Quantum\u2122 itself. There are currently two public API sets: Quantum\u2122 AS (application services) and Quantum BS (board support). The Quantum\u2122 AS software layer is the main application service API set. It comprises a number of loosely connected function libraries that may be called from C or C++ application code. In one embodiment, the following functionality is provided:","1. Platform abstraction (word size and endian support);","2. Memory management;","3. Task support;","4. Inter-task messaging and network data buffering;","5. Inter-task synchronization via semaphores and mutexes;","6. Hardware interrupt service support; and","7. General utilities (block memory handling, strings, etc)","Additionally, alternative or enhanced embodiments may also incorporate the following functionality:","1. Logging and console support APIs;","2. High performance driver support (Quantum\u2122 Warp Engine);","3. Generic attribute and application management; and","4. Multi-processing implementations","Quantum\u2122 BS: Board Support","The Quantum\u2122 BS software layer is the board support API. Unlike the AS API's, this defines functions that are used to implement board specific support code. Such functions are currently limited to defining interrupt logical routing and providing interrupt stub handlers for platforms where these are not directly provided by the Quantum\u2122 software itself. The BS API currently defines only one function type:","bs_PackageInitialise( )","This function is normally provided by the board designer. For example, ASIC (application specific integrated circuit) specific support packages are implemented internally within Quantum\u2122 and are \u201chidden\u201d from an actual user of a Quantum\u2122 release. The initialization function is called at start of day after Quantum\u2122's internal system initialization is complete but before any application tasks or drivers have been started. Its sole purpose is to define the interrupt mappings that will be used on the board (e.g., mapping the \u2018dying-gasp\u2019 interrupt from a physical chip to a specific GPIO (general purpose Input\/Output) interrupt line with a specific level sense condition).\n\nQuantum\u2122 Internal APIs\n","The public API set provided by Quantum\u2122 is backed by a number of internal APIs with a variety of implementations that may depend on the target hardware or on the underlying third party OS (if any). The following internal API sets currently exist:","1. Quantum\u2122 XS\u2014Platform neutral functions","2. Quantum\u2122 HS\u2014Host Support functions","3. Quantum\u2122 CS\u2014Compiler Support functions","4. Quantum\u2122 LS\u2014Legacy Support functions","This partitioning is not always absolute. The diverse range of supported platforms often mean that functions intended for one module area \u201cleak\u201d into another (e.g., CPU specific speed up code in Quantum\u2122 XS, or compiler or tool support code in Quantum\u2122 HS). Accordingly, such a shared or leaked structure is envisioned and supported by the system of the present invention. However, where possible the software tries to use the indicated structural organization to maximize code reuse between platforms.","The legacy support module (LS) implements functions historically provided by the ATMOS Kernel. Its purpose is to allow original ATMOS application code to continue running. LS is not supported on hosted OS targets, since the APIs provided by the original ATMOS design are extremely difficult to implement effectively under some key target OS's. Referring now to , there is shown a block diagram illustrating one embodiment of an internal structure for a hosted Quantum\u2122 target, including the relative structure of the Host Operating System (OS) , the Quantum AS , the Quantum HS and XS layers  and , and the Quantum CS layer .","Referring now to , there is illustrated a diagram corresponding to a native target implementation (i.e., no Host OS) where the HS layer is directly implemented on the target hardware. A legacy support layer, Quantum LS () is further provided in this embodiment. By layering the LS structure  directly on top of the HS module , the original ATMOS functions can be implemented extremely efficiently. In fact, the performance of the LS implementations of ATMOS's original messaging APIs is significantly better than that of the original ATMOS Kernel (in some cases, as much as 5 to 10 times faster).","Quantum\u2122 XS","Quantum\u2122 XS is intended to be a generic portable software layer that simplifies the implementation of the platform specific portions of Quantum\u2122. Its major functions include:","1. Debug\u2014generic and extensible system debug framework;","2. UART\u2014low level UART access functions for use in system startup;","3. Object\u2014the system object manager; and","4. Startup\u2014the system startup manager.","The debug functions implement low level diagnostic code for use in non-release builds. These include assert( ) like traps and a simple console based debug task with an extensible command parser. The debug console is entered by explicit request from within the Quantum\u2122 software, and is typically used to allow diagnosis of fatal exceptions such as unexpected memory aborts. This is a low level tool that allows inspection and modification of system objects and memory, however, it is not a symbolic source debugger.","The UART functions provide a low-level access to a console UART (universal asynchronous receiver transmitter), together with simple Kernel printf( ) functionality. This may be used by engineers working on Quantum\u2122 to help diagnose internal problems in Quantum\u2122 itself. It should be noted that kernel level UART and printf ( ) handling are not available to application code. Rather, these functions (and all other internal functions) may only be used from within the operating system itself.","The object support library provides a generalized management tool for arbitrary objects that may need to be implemented by a host specific platform, such as memory, sempahores, tasks, etc. The object API's implement a filing system like hierarchical database that tracks usage of objects and which provides a generic mechanism to provide access to object properties by means of an attribute mechanism. The object system is a superset of that originally provided by the BUN (broadband unified network) driver framework, and provides support for inheritance and aggregation of types. Unlike BUN, the system is dynamic, permitting objects to be created and destroyed. The system also provides for arbitrary run-time extension of the data types and run-time type safety for clients of the object system. The startup function is a simple module that handles initialization of Quantum\u2122, ensuring that the various library modules are initialized in the correct sequence, and starting any statically defined application tasks.","Quantum\u2122 HS","Quantum\u2122 HS implements the host specific portion of the software, either by mapping API calls to a third party OS or by directly interacting with the CPU or other system hardware for native implementations. Facilities provided by the HS layer include tasks (the execution unit in Quantum\u2122), messaging, semaphores, mutexes and memory management. The HS layer may also override some functions in other portable software layers in order to provide specific performance gains (e.g.; for memcpy( )). HS software typically makes extensive use of the XS object library to implement basic functions such as opening, closing, creating and deleting system objects such as tasks or semaphores.","Quantum\u2122 CS","Quantum\u2122 CS provides compiler support functions. C or C++ compiler tools often require a small support library to implement \u201cinternal\u201d functions such as copying of data structures (for assignment), basic math operations (such as integer division on CPUs with no divide machine instruction) or C++ features (such as the new and delete operators, RTTI, exception handling, etc). Currently, Quantum\u2122 simply uses the compiler support code from ATMOS. This is specifically targeted at the GNU tool chain.","Quantum\u2122 LS","Quantum\u2122 LS implements legacy APIs necessary to maintain existing ATMOS software. LS is only supported on native platforms.","Quantum\u2122 Application Architecture","The Quantum\u2122 system service APIs define the basic structure of an application, setting down the way application code interacts with hardware and software in a complete system. The basic unit of execution in Quantum\u2122 is the task. Quantum\u2122 makes no distinction between the traditional concepts of a \u201cprocess\u201d and a \u201cthread\u201d and instead uses a single object type to implement both facilities. This reduces the number of APIs needed, reduces the porting effort to new platforms, and allowing focused optimization of the task handling code for best performance. A task typically executes a message loop, receiving requests from other tasks or hardware and performing some processing in response. The following code structure represents one embodiment of a messaging scenario.",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tASErr main(int argc, const char* argv[ ])",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003\/\/ Indefinite loop to process messages.",{}]},{"entry":[{},"\u2003for (;;)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/\/ Wait for a message to be sent here",{}]},{"entry":[{},"\u2003\u2003tASMessage msg = as_MessageWaitPrimary( );",{}]},{"entry":[{},"\u2003\u2003\/\/ Decode the message and handle it",{}]},{"entry":[{},"\u2003\u2003switch (as_MessageCode (msg) )",{}]},{"entry":[{},"\u2003\u2003{",{}]},{"entry":[{},"\u2003\u2003\u2003case abc:",{}]},{"entry":[{},"\u2003\u2003\u2003...",{}]},{"entry":[{},"\u2003\u2003\u2003case xyz:",{}]},{"entry":[{},"\u2003\u2003\u2003...",{}]},{"entry":[{},"\u2003\u2003}",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003\/\/ Break out of the loop to exit.",{}]},{"entry":[{},"\u2003return kASEOK;",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Quantum\u2122 employs a back-end object database that implements access to all system objects\u2014tasks, shared, memory, semaphores, etc. Most Quantum\u2122 APIs there tend to have a similar look and feel. The API set for most system objects is of form:\n\n",{"@attributes":{"id":"p-0079","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/task","tasks and objects created by tasks"]},{"entry":[{},"\/memory","global shared memory"]},{"entry":[{},"\/pool","global message pools"]},{"entry":[{},"\/interface","global interfaces"]},{"entry":[{},"\/interrupt","hardware interrupt sources"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Objects may possess many different forms. For example, a message pool provides a specific pool handle as well as an interface that can be used to provide message functions. Hence the following API calls:","tASPool pool;","tASInterface interface;","as_PoolOpen(&pool, \u201c\/pool\/generic\u201d);","as_InterfaceOpen(&interface, \u201c\/pool\/generic\u201d);","both refer to the same object\u2014the generic message pool. However, the two calls return different representations of the same object\u2014the first a pool handle which can be used to perform pool specific operations, the second an interface that can be used to allocate or release messages. This genericity means that many of the APIs you might normally expect to find in an system service software layer appear not to be present in Quantum\u2122. Message pools, inter-task message exchange and interrupt handling are all performed using the interface object type exported by many of the system objects.","Objects may be accessed by both a type specific API and a generic attribute mechanism. Attributes are typically used when creating a new object of a specified type. The following example code will create a new globally accessible pool object:","tASPool pool;","as_PoolNew(&pool, \u201c\/pool\/magic\u201d, \u201csize=1024\/count=32\/prefix=64\u201d);","The pool object will accept attributes both specific to the pool itself, but also for any other representations that it might possess. Hence a pool object also provides all of the attributes of an interface object. Objects may also be created using a relative path name.\n\nTasks, Messages and Interfaces\n","A task is a single thread of execution, with all tasks being scheduled independently by the operating system. Further, in order to protect such execution threads, tasks may utilize protected memory within the computing system. A message is a block of information that can be passed to other tasks by means of an interface. Messages can carry network datagrams, control information, or requests to perform some action. Message content is defined by the application code, not Quantum\u2122. The basic functions common to all interfaces are:","1. put\u2014send a message to an interface;","2. get\u2014non-blocking fetch a message from an interface; and","3. wait\u2014blocking wait for a message to arrive at an interface.","All interfaces support these basic operations. The AS APIs provide syntactic sugar to provide additional APIs with semantics for message replies and synchronous send-wait calls. However, all such operations are based on these three primitive functions.","Interfaces may also represent other tasks in the system, such as \u201cpools\u201d of free messages that can be allocated, or \u201cinterrupt\u201d objects that implement traditional interrupt processing under Quantum\u2122. While all interfaces respond to the same API semantics, the manner in which they are used by applications is a matter of convention, largely driven by the naming of the interface.","Referring to , there is shown an example of a uni-directional message exchange between two tasks under Quantum\u2122. Initially, task alpha  requests a message from the free pool of messages  through their associated interfaces  and , respectfully. Task alpha  then sends the message to task beta  through its interface . Task beta then returns the message to the free pool . As shown, no distinction is visible to the tasks between the three interfaces, other than their objects names and the way that they are used. The basic operations used to exchange the messages are independent of the type of interface that the message is being exchanged with.","Referring now to , there is illustrated a flow diagram showing a more complete send-reply messaging sequence. Initially, task alpha  requests a message from the free pool of messages  through their associated interfaces  and , respectfully. Task alpha  then sends the message to task beta  through its interface . Task beta  replies to task alpha using the message. Task alpha  then returns the message to the free pool .","Quantum\u2122's message model brings a simplification of the programming APIs, performance gains and more efficient support for protected or virtual memory. All Quantum\u2122 messages must be allocated from a dedicated message pool; messages cannot be simply created as a structure on the local application stack. These messages contain a type code that defines the purpose of the message and its content. Type codes are assigned by the applications, not by Quantum\u2122. Messages may be uni-directional, or use a send-reply sequence as described above. Uni-directional messaging is inherently more efficient, but may only be used where no explicit acknowledgement of the message is required by the originator.","Memory Space Issues","In accordance with the present invention, Quantum\u2122 supports protected and virtual memory configurations. This places constraints on the access that may be made to memory between tasks. In particular, each top-level task is provided with its own private memory resource. Any sub-tasks created inherit access to the parent's memory space, as well as any handles owned by the parent for system objects, such as semaphores or mutexes.","The diagram of  illustrates one example memory structure of the present invention. More particularly, it can be seen that the memory is accessible to a typical set of tasks running under Quantum\u2122: Memory allocated by any task is accessible by it and any subtasks that it may choose to create\u2014but not from other tasks in the system. Therefore, in the example of , alpha's memory  is entirely private to alpha, memory  allocated by beta can be seen by beta and any subtasks, and memory  or  allocated by beta1 or beta 2 is local to the subtask and can not be directly accessed by either alpha nor beta directly. The general rule is that allocated memory is only accessible to that task and any subtasks that have been created, not vice-versa.","Explicit blocks of shared memory can also be created and exported using the AS memory APIs. Shared memory regions are identified by name under the \u201c\/memory\u201d area of system file space. The AS API's contain functions to map such regions to an address that may be directly addressed by a task. As with locally allocated memory, any shared memory that is accessible by a task is also accessible by its subtasks.","Interrupts","As stated above, Quantum\u2122 does not permit the use of \u201ctraditional\u201d interrupt handlers, as used by systems such as ATMOS (other than in the LS emulation layer). In fact, there are no application APIs that would appear to provide any support at all for hardware interrupts. Rather, interrupt service requests are handled using the above-described messaging system, coupled with specialized \u201cinterrupt\u201d message interfaces. In this manner, sending a message to an interrupt interface enables the interrupt source. When the interrupt fires, the interrupt is disabled and the message returned to the originator as a reply.","Referring now to , there is shown a flow diagram illustrating one embodiment of an interrupt handler task's interaction with an interrupt object. Initially, task phyhandler  requests a message from the free pool of messages  through their associated interfaces  and , respectfully. Task phyhandler  then sends the message to arm an interrupt enable at an interrupt object phy  through the interrupt's interface . The interrupt object phy  then disables the interrupt and replies to task phyhandler  using the message.","Interrupt objects are very simple. They know nothing about the format or content of the messages exchanged with them. The simple presence or absence of a message is sufficient to handle the interrupt enable and disable, and also to signal when an interrupt has triggered. The following code example illustrates the implementation of an interrupt handler task:",{"@attributes":{"id":"p-0104","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tASErr main(int argc, const char* argv [ ])",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003tASInterface interrupt;",{}]},{"entry":[{},"\u2003tASInterface pool;",{}]},{"entry":[{},"\u2003tASMessage msg;",{}]},{"entry":[{},"\u2003tASErr err;",{}]},{"entry":[{},"\u2003\/\/ Find our interrupt source's interface.",{}]},{"entry":[{},"\u2003err = as_InterfaceOpen(&interrupt, \u201c\/interrupt\/phy\u201d);",{}]},{"entry":[{},"\u2003if (kASEOK != err) return err;",{}]},{"entry":[{},"\u2003\/\/ Find a pool and allocate a message from it.",{}]},{"entry":[{},"\u2003err = as_InterfaceOpen(&pool, \u201c\/pool\/generic\u201d);",{}]},{"entry":[{},"\u2003if (kASEOK != err) return err;",{}]},{"entry":[{},"\u2003msg = as_InterfaceWait(pool);",{}]},{"entry":[{},"\u2003for (;;)",{}]},{"entry":[{},"\u2003{",{}]},{"entry":[{},"\u2003\u2003\/\/ Enable the interrupt source and wait for it to",{}]},{"entry":[{},"\u2003\u2003\/\/ fire. This simple example assumes that the only",{}]},{"entry":[{},"\u2003\u2003\/\/ message delivered to this task is the interrupt",{}]},{"entry":[{},"\u2003\u2003\/\/ message itself.",{}]},{"entry":[{},"\u2003\u2003as_MessageSendWait(interrupt, msg);",{}]},{"entry":[{},"\u2003\u2003\/\/ Handle the interrupt here, accessing the hardware as",{}]},{"entry":[{},"\u2003\u2003\/\/ needed. When done, we just loop back around to re-enable",{}]},{"entry":[{},"\u2003\u2003\/\/ the interrupt source and wait for the next request.",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"With careful choice of the message code used for a given interrupt source, a single task could handle multiple interrupt sources as well as processing messages received from other tasks.","Interrupt objects appear by convention in the global file space under \u201c\/interrupt\/\u201d. Interrupt source names are logical names assigned by the system integrator in the Board Support package. For example, the board support (BS) API may be used to create an interrupt named \u201c\/interrupt\/phy\u201d that is mapped to a specific GPIO line with specific level sensitivity characteristics.","The Quantum\u2122 Object Database","Quantum\u2122 provides a global system object database, with facilities to support safe dynamic run-time typing and the construction of new object types at run time using the basic principles of single inheritance and aggregation. The database is currently used as the back-end to all Quantum\u2122 system objects, such as tasks or semaphores. As such, it also supports facilities for tracking the users of objects, greatly simplifying the problems associated with dynamic object creation and deletion in an embedded real-time system.","A Quantum\u2122 object is an arbitrary block of data characterized by the following:\n\n","Referring now to , there is shown a block diagram illustrating the relationships between the various structures used to construct an object using inheritance. As shown, an object is made up of several general structures, including descriptions of specific object instances , inheritance properties , and a handle . The inheritance properties include any derived objects  and their attributes . The object handle  is typically a simple integer or pointer value that normally references a data structure that is used to implement the specific object. This object handle  is returned to an application in response to a request to create or open an instance of the object type, and is also passed to the code that implements the specific object type in response to requests to query or set attribute values.","As shown in , derived objects  use the same handle  as their parent classes . This means that all APIs for the parent class  may also be used with a subclassed object . There is no mechanism for a subclass to override methods provided by the parent class (object \u201cmethods\u201d are in this case simply C function calls). To support this, object implementation must be able to cast (in the C type sense) between the base and derived object handles. This means that a derived type's data should always be appended to the data for the parent type. Referring now to , there is shown a block diagram illustrating one example of a possible object implementation under Quantum\u2122. More particularly, a base object structure  is provided with any derived object structures  appended thereto.","Unfortunately, imposing such a scheme on all objects can introduce unnecessary overhead to the function call APIs, typically due to a need to construct container objects where simple single inheritance is not practical. As a result, Quantum\u2122 also supports an aggregation form of inheritance.  illustrates one example of an aggregate manner of object implementation. Unlike the single inheritance model of , specific object implementations are each provided with discrete handles  and .","To an application, both implementations function the same since the code must issue type-specific API calls to obtain the object handles. That is, a single object of type task that inherits from type interface always appears as a single object when accessed via the attribute access mechanisms, but always appears as two objects of different type when accessing the handle for use with performance critical object-specific API calls. Such a scheme differs from most traditional inheritance mechanisms, where a single handle would respond to API calls (methods) of two or more types. By not supporting this, Quantum\u2122's object model can retain maximum performance (no virtual function-call overheads) while still benefiting from the structural and code-reuse benefits that occasionally arise from an object oriented design.","The type system used by Quantum\u2122 is entirely generated at run-time. Accordingly, any code that implements a particular type of object must register the type with Quantum\u2122 at run time. This registration process allows Quantum\u2122 to ensure that all types are unique, inheritance information for the type, and specific attribute keys. In one embodiment, objects are typed using the AS TYPE( ) macros exported from as types.h. These use a four-character code to generate a 32 bit numeric type identifier. Conventions are used to avoid conflicts in type codes arising, and in any event, any conflict will be trapped at run time when the type is first registered\u2014giving the implementors of an object a chance to correct the error.","The following examples illustrate object creating in Quantum\u2122:","Creating a new semaphore:","#include \u201cquantum\/as.h\u201d","tASSemaphore sem;","tASErr err;","err=as_SemaphoreNew(&sem, \u201clock\u201d, \u201ccount=10\u201d);","where \u201cerr\u201d refers to the error status code; \u201c&sem\u201d refers to the returned handle; \u201clock\u201d refers to the object name; and \u201ccount=10\u201d refers to the object's properties.","Opening a message free-pool's message interface:","#include \u201cquantum\/as.h\u201d","tASInterface pool;","tASErr err;","err=as_InterfaceOpen(&pool, \u201c\/pool\/generic\u201d","where \u201cerr\u201d refers to the error status code; \u201c&pool\u201d refers to the returned object handle; and \u201c\/pool\/generic\u201d refers to the object's name.","Object Attributes","Quantum\u2122 objects use a attribute mechanism to provide access to non-performance critical properties or status information. In this mechanism, derived types extend the attributes of the parent type. The extended attribute set can override attributes of the parent so that attribute \u201cset\u201d and \u201cget\u201d operations only access those of the derived object and not the parent. Referring now to , there is shown a block diagram illustrating one embodiment of a object\/attribute structure of the present invention. In the embodiment of , attribute access for each of a parent object  and a derived object  are shown. The parent object  includes alpha and beta attributes  and , respectively, while the derived object  includes beta and delta attributes  and , respectively. In view of the present mechanism, an initial attribute access for alpha access the alpha attribute  of the parent object . However, in a subsequent beta access, only the beta attribute  of the derived object  is accessed. No access is made of the parent's beta attribute  unless such an access is invoked by the derived object's code.","Attribute keys and accessor methods are defined once and used for all objects of a specific type. In contrast, there may be many specific instances of an object, each with its own data that may be accessed through the common attribute access information. The following code sequence illustrates the creation of a base object class with two derived types:",{"@attributes":{"id":"p-0125","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"\/\/ Structure definitions for a base class containing a single",{}]},{"entry":[{},{},"\/\/ integer variable and a derived class containing a single",{}]},{"entry":[{},{},"\/\/ string variable.",{}]},{"entry":[{},{},"typedef struct",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003int base_value;",{}]},{"entry":[{},{},"} tBaseType;",{}]},{"entry":[{},{},"typedef struct",{}]},{"entry":[{},{},"{",{}]},{"entry":[{},{},"\u2003struct sBaseClass base;",{}]},{"entry":[{},{},"\u2003char derived_value[32];",{}]},{"entry":[{},{},"} tDerivedType;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0126","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tASErr base_setValue(tBaseType* pObject, int* pValue)",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003pObject->base_value = *pValue;",{}]},{"entry":[{},"\u2003return kASEOK;",{}]},{"entry":[{},"}",{}]},{"entry":[{},"tXSObjectKey baseKeys [ ] =",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003XS_OBJECT_KEY_INTEGER(\u201cbase-integer\u201d, 0, base_setValue),",{}]},{"entry":[{},"\u2003XS_OBJECT_KEY_END",{}]},{"entry":[{},"};"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0127","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define kBaseType AS_TYPE(\u2018b\u2019, \u2018a\u2019, \u2018s\u2019, \u2018e\u2019);"]},{"entry":[{},"err = xs_ObjectTypeRegisterBase("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003kBaseType,","\/\/ Type being registered"]},{"entry":[{},"\u2003\u201ctBaseType\u201d,","\/\/ The C typedef name (or equivalent)"]},{"entry":[{},"\u2003100,","\/\/ Version number"]},{"entry":[{},"\u2003baseKeys);","\/\/ List of keys"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0128","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"tXSObjectKey derivedKeys[ ] ="},{"entry":"{"},{"entry":"\u2003\u2003XS_OBJECT_KEY_INTEGER(\u201cderived-integer\u201d, 0, "},{"entry":"\u2003\u2003derived_setValue),"},{"entry":"\u2003\u2003XS_OBJECT_KEY_END"},{"entry":"};"},{"entry":"tASErr derived_setValue(struct sDerivedClass* pObject, const char* "},{"entry":"pszValue)"},{"entry":"{"},{"entry":"\u2003return as_StrCopy(pObject->derived_value, pszValue, sizeof pObject->"},{"entry":"\u2003derived_value);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0129","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#define kDerivedType AS_TYPE(\u2018d\u2019, \u2018e\u2019, \u2018r\u2019, \u2018v\u2019);"]},{"entry":[{},"err = xs_ObjectTypeRegisterDerived("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003kDerivedType,","\/\/ Type being registered"]},{"entry":[{},"\u2003\u201ctDerivedType\u201d,","\/\/ The C typedef name (or equivalent)"]},{"entry":[{},"\u2003100,","\/\/ Version number"]},{"entry":[{},"\u2003derivedKeys,","\/\/ List of keys"]},{"entry":[{},"\u2003kBaseType);","\/\/ Type that this one derives from"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0130","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tXSObject object;","\/\/ System software object handle"]},{"entry":[{},"struct sDerivedType data;","\/\/ Type specific data"]},{"entry":[{},"err = xs_ObjectNew(",{}]},{"entry":[{},"\u2003&object,","\/\/ Returns system object handle"]},{"entry":[{},"\u2003pszName,","\/\/ Name for object"]},{"entry":[{},"\u2003pszDefaults,","\/\/ Default properties to be applied"]},{"entry":[{},"\u2003&data,","\/\/ Object specific handle"]},{"entry":[{},"\u2003kDerivedType,","\/\/ Object type code"]},{"entry":[{},"\u2003hs_TaskCurrent( ));","\/\/ Task requesting the operation"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"In accordance with one embodiment of the present invention, objects are organized by a global file system. This appears to clients of the object database much like a traditional UNIX file system. There are two main exceptions to this:","1. \u201cfiles\u201d simply contain references to objects in memory, not data itself; and","2. Any \u201cfile\u201d may be both an object in its own right and a container for other objects.","The top-level structure of the file system is normally organized in the following manner, however, it should be understood that the following listing is not exhaustive and that additional top level structures may also be supported:",{"@attributes":{"id":"p-0135","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/task","System tasks"]},{"entry":[{},"\/pool","System global message pools"]},{"entry":[{},"\/mutex","System global mutexes"]},{"entry":[{},"\/semaphore","System global semaphores"]},{"entry":[{},"\/interface","System global interfaces"]},{"entry":[{},"\/interrupt","System global interrupt controllers"]},{"entry":[{},"\/memory","System shared memory objects"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Referring now to , there is shown a flow diagram illustrating one example of how such a structure may be implemented in software using the tXSObject structure type (this is actually a simplification of the actual implementation, which includes additional links and data to accelerate tree traversal and searching, however such extensions are largely trivial and understood by those skilled in the relevant arts.) The object database understands the identity of any task that makes a request to open, close, create or delete and object. This allows the use of either absolute or task-relative filenames.","Task relative filenames omit the leading \u2018\/\u2019 character, and are used to access objects contained within the accessing task. The top-level tasks in the above example could have been constructed using the following API calls:","as_TaskNew(&uart, \u201c\/task\/uart\u201d);","as_TaskNew(&bun, \u201c\/task\/bun\u201d);","while the objects created by BUN could have been created by the following calls issued from within the BUN task:","as_MutexNew(&mutex, \u201clock\u201d);","as_TaskNew(&task1, \u201cthread1\u201d);","as_TaskNew(&task2, \u201cthread2\u201d);","Such a scheme implements a second, weaker form of aggregation for Quantum\u2122 objects. In the example of , the bun task acts as a container for a mutex and two other tasks (thread1 and thread2). These objects are coupled to \u201c\/task\/bun\u201d such that any attempts to delete or remove \u201c\/task\/bun\u201d will also cleanup and remove the contained objects. However, the individual objects remain as independent entities. The bun task does not, for example, inherit any of the attributes of objects that it contains. Note that under Quantum\u2122, any object may be used as a container and all such associations are dynamic (i.e., established or removed at run-time, not statically at compile-time).\n\nARM-Specific Native Implementation Information\n","The native ARM implementation of Quantum\u2122 employs some specific features to improve performance on such a processor environment. This following section details the more obscure issues relating to this implementation.","Task and Interrupt Execution Environments","In accordance with an ARM-specific embodiment of the present operating system, all application tasks are executed in a non-privileged state; the ARM \u201cuser\u201d execution mode. Execution of key OS routines are performed using ARM software interrupts, known as SWI traps. The ARM SWI instruction forces the CPU in to a privileged execution state, with IRQ and FIQ interrupts disabled. This ensures that operations are atomic and allows access to the privileged instructions necessary to perform task switching.","Hardware interrupts are executed in IRQ or FIQ state. IRQ interrupts are always trapped by the system and handled by a stub interrupt handler that replies to messages posted to an interface. By preventing driver writers from direct access to the IRQ interrupt state, Quantum\u2122 can enforce QoS for all code running on the system, avoiding the problem of \u201crunaway IRQ code\u201d, where eventually all code ends up running in interrupt to improve performance of each handler and resulting in essentially unbounded interrupt latency.","Both IRQ and FIQ low level handlers can use the interface functions for \u2018put\u2019 and \u2018get\u2019\u2014but not \u2018wait\u2019. This allows the interrupt stubs to communicate with real driver code. Normally, stub IRQ handlers are provided for all the interrupt sources supported by a given ASIC as part of Quantum\u2122's host support package. Engineers developing device drivers are not permitted to write their own IRQ handlers at present.","SWI Traps and System Services","In accordance with the ARM-specific embodiment of the present invention, SWI instructions are used to gain access to a privileged CPU level for certain system functions, such as messaging or entering the system debugger. The conventional form of the SWI instruction in ARM assembler is:","swi <vector_number>,","where vector_number is a 24 bit number that is conventionally used to encode the function request. This number must be decoded from the SWI instruction opcode, requiring significant software overhead. Quantum\u2122 ignores the vector number, and instead uses a proprietary calling convention. It should be noted that this calling convention was specifically designed to improve the performance of message passing (see Interfaces and Messaging via SWI Traps discussed in detail below), though it is also used for other more general system operations.","Before entry to a SWI trap instruction, the following must be valid:\n\n","The basic definition of the dispatch structure is:",{"@attributes":{"id":"p-0153","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct sHFSWIDispatch"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{",{}]},{"entry":["\u2003U32 p1;","\/\/ 0: SWI Argument r2"]},{"entry":["\u2003U32 p2;","\/\/ 4: SWI Argument r3"]},{"entry":["\u2003U32 p3;","\/\/ 8: SWI Argument r4"]},{"entry":["\u2003U32 p4;","\/\/ 12: SWI Argument r5"]},{"entry":["\u2003void* handler;","\/\/ 16: SWI Trap Handler (program) address"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} tHFSWIDispatch;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0154","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"_hf_ArmAbortSWI:"]},{"entry":[{},{},"\u2003; r0 = dispatch structure address"]},{"entry":[{},{},"\u2003; r1 = function specific parameter"]},{"entry":[{},{},"\u2003ldmia r0, {r2-r5, pc} \/\/ Load parameters and jump to handler"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The simplest way to ensure robustness is to place all tHFSWlInterface structures in memory that is protected from write access by user-mode code, preventing the application from corrupting fields. If all such structures are allocated from a single contiguous area, validity checking can be a single range and alignment test on the supplied tHFSWIDispatch address. Individual trap handlers are called with the following parameters:\n\n","The trap handlers must preserve the registers noted above. A handler may not issue any system calls and must be written to be executed in a very short time since all interrupts are locked out. The trap handler must not change the interrupt enabled for SVC state. A trap handler should return with a movs pc, lr \/\/ Return from SWI instruction, to restore the caller's execution environment.","Interfaces and Messaging Via SWI Traps","The message and interface handling subsystem of Quantum\u2122 was specifically designed to offer the best possible performance while executing application code in a non-privileged state. Interfaces are widely used by a variety of different Quantum\u2122 objects, such as tasks, free buffer pools and interrupt sources. The design of the object system used by Quantum\u2122 specifically places the burden to implement polymorphism on the actual object implementors, typically using a simple function indirection. This is extremely well suited to the model of SWI dispatch processing supported by Quantum\u2122, where it is possible to push the polymorphism of the interface to the very lowest level of implementation and so achieve the best possible performance. All interfaces provide the following three basic operations:","1. \u201cPut\u201d a message on an interface;","2. \u201cWait\u201d for a message to arrive at an interface (blocking call); and","3. \u201cGet\u201d a message from an interface (non-blocking call).","Different implementations of these functions are needed depending on the specialization of the interface.","The Interface Control Structure and SWI Traps","The following base structure is used to define an interface:",{"@attributes":{"id":"p-0162","num":"0185"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct sHFInterface"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{",{}]},{"entry":[{},"\u2003U32 reserved;","\/\/ 0: Currently unused"]},{"entry":[{},"\u2003void* tail;","\/\/ 4: Message or task queue list tail"]},{"entry":[{},"\u2003S32 control; ","\/\/ 8: Queue control word (see text)"]},{"entry":[{},"\u2003void* head;","\/\/ 12: Message or task queue list head"]},{"entry":[{},"\u2003void* pfPut;","\/\/ 16: SWI handler for put functions"]},{"entry":[{},"\u2003void* pfWait;","\/\/ 20: SWI handler for wait functions"]},{"entry":[{},"\u2003void* pfGet;","\/\/ 24: SWI handler for get functions"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\/\/ Other non-SWI specific fields can be placed here"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} tHFInterface;",{}]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"figref":"FIG. 13"},"With these conventions, the application code sequences used to perform the three basic functions are simple:",{"@attributes":{"id":"p-0164","num":"0187"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"_hs_InterfacePut:"]},{"entry":[{},"\u2003; r0 = interface address"]},{"entry":[{},"\u2003; r1 = message address"]},{"entry":[{},"\u2003stmfd sp!, {r4-r5, lr} \/\/ Save work registers"]},{"entry":[{},"\u2003swi 0 \/\/ Run the put function in the interface"]},{"entry":[{},"\u2003ldmfd sp!, {r4-r5, pc} \/\/ Return"]},{"entry":[{},"_hs_InterfaceWait:"]},{"entry":[{},"\u2003; r0 = interface address"]},{"entry":[{},"\u2003stmfd sp!, {r4-r5, lr} \/\/ Save work registers"]},{"entry":[{},"\u2003add r0, r0, #4 \/\/ Run the wait function (a word is 4 bytes)"]},{"entry":[{},"\u2003swi 0 \/\/"]},{"entry":[{},"\u2003ldmfd sp!, {r4-r5, pc} \/\/ Return, with r0 set from the SWI handler"]},{"entry":[{},"_hs_InterfaceGet:"]},{"entry":[{},"\u2003; r0 = interface address"]},{"entry":[{},"\u2003stmfd sp!, {r4-r5, lr} \/\/ Save work registers"]},{"entry":[{},"\u2003add r0, r0, #8 \/\/ Run the get function"]},{"entry":[{},"\u2003swi 0 \/\/"]},{"entry":[{},"\u2003ldmfd sp!, {r4-r5, pc} \/\/ Return, with r0 set from the SWI handler"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In the above examples, these registers are preserved on the caller's stack. However, a more efficient implementation still is to use inline assembler instructions to inline the actual SWI dispatch within the application C code. With this approach, only one or two ARM assembler instructions are needed to dispatch the interface function, using the C compiler extensions to mark the corrupted registers as \u2018invalid\u2019 following the assembler sequence. The approach works well with the register usage optimizations performed with modern compilers such as GNU's GCC. Also note that the \u2018get\u2019 function is not directly passed the tail pointer for the queue. This is not necessary since the \u2018get\u2019 operation always removes from the list head.","Task and Message Queues","An interface may hold either a queue of tasks waiting for messages to arrive, or a queue of messages waiting for a task to get a message. The control word denotes whether the interface contains a list of tasks or a list of messages:\n\n","Referring now to , there are shown exemplary linked list structures for interface queue formation. As described above, for an instance  where the control word is zero, no messages or tasks are in the queue. For an instance  where the control word is positive, the queue includes tasks  waiting for execution. Lastly, for an instance  where the control word is negative, the queue includes messages  waiting for a task. Using this basic structure, it is simple to provide an efficient implementation of the interface functions.","Interface \u2018put\u2019 operations always increment the control word. If the word was negative, the head pointer references a task control block in to which the message handle can be directly written (normally to the saved state for r0), before removing the task from the queue and making it runnable. If the control word was positive, the message is simply added to the end of the queue. Interface \u2018get\u2019 operations are a trivial queue manipulation. \u2018Get\u2019 operations only return messages, so if the control word is zero or negative, the operation must return the invalid message handle. A \u2018get\u2019 operation needs access only to the control word and list head. Interface \u2018wait\u2019 operations attempt to perform a trivial get, but if no messages are present, the control word becomes negative and the task is appended to the queue of waiting tasks and suspended.","The Quantum\u2122 Warp Engine","The Quantum\u2122 Warp engine is an extension of the present operating system for providing low-level system support for constructing function call chains to permit data path processing performance optimizations for network data handling. The need for the a new network data path API is driven by the need for increased performance and flexibility from network device drivers and protocol elements. The network data path can be modeled as a sequence of self-contained processing operations of two forms: classification and modification.  illustrates one possible network data flow  in such a system.","The example of  shows the basic processing of data either being forwarded (bridged or routed) or terminated locally (such as for a Web based management tool). It should be noted that this is a simple case, since only a single network input or output port is shown, and there are only two priority levels: real systems will have potentially many more.","A network data-path priority represents both the importance and the urgency of data handling. This may be reflected in assignment of buffer memory resources and in the assignment of processing time. Incoming data will typically always enter the processing chain at the highest possible priority as shown in item . Classification is then used in item  to downgrade data handling for specific packets\u2014and in extreme cases discard low priority data in the event of memory or CPU starvation. Upon classification, the data is either discarded in item , modified in item  at the current priority level, or modified in item  at a lowered priority level. For lower priority data, it is again classified in item  and either passed to a local application in  or transmitted on the network at item . High priority data is simply transmitted at item . On hardware platforms with several receive ports, each port may be assigned a different initial processing priority (in this manner, the port at which data arrives is itself a form of classification, though it is outside of the system described here).","In such a system, the classification and modification elements may be implemented in many diverse forms. In some cases, dedicated hardware may perform some of the tasks. On others, software running on a dedicated network processor may contribute. Some or all of the software may be written in a portable language such as C or C++, and run on a single monolithic CPU along with all of the management and control software that typically abounds in such systems. There is only one certainty: there will be a tension between the demands of performance, portability, partitioning between hardware and software, ease of development, and the robustness of the final product.","Warp Modules","A Quantum\u2122. Warp Module implements part of the data path for a full system. An individual module is characterized by the following:\n\n","Typically, the processing performed by a single module is very simple\u2014such as performing a packet classification based on a field in an IP header or performing a simple LLC\/SNAP encapsulation. A high performance data path is coupled with a slower and more general configuration and status interface. The diagram of  illustrates one example of a system  having three linked modules, ,  and . A data transport interface  is provided for performing high performance data flow. Additionally, a configuration and status interface  is provided for supporting generic management. Real systems will also have modules with zero inputs (reading data directly from a hardware interface, generating data locally, or connecting to an application such as a telnet program), and modules with zero outputs (throwing data away or passing data to a hardware device).","Warp Module Data Path Connections","The data path connection between Warp Modules is constrained by the following:\n\n","Best performance is generally achieved by directly connecting modules by a simple function call interface. This is the approach used by the original BUN device driver framework and ATIC based software. Encapsulation of a module typically means that a given module must not be aware of the modules that may precede or follow it. A given module must also have the ability to use private per-data flow context information, per flow configuration and status information.","QoS (quality of service) branching means that a direct function call binding between two modules may be broken to defer handling of a given data item either to a later time or to a different (lower priority) execution context or thread. Support for multiple output streams is required to support classification. A generic mechanism is needed so that a module can pass data to an appropriate output connection. Quantum\u2122 Warp approaches these problems by carefully defining the programmatic interfaces to a Warp Module. The general form of the data path handling functions of a module is:",{"@attributes":{"id":"p-0178","num":"0212"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ MyModuleDataIn ( )"},{"entry":"\/\/"},{"entry":"\/\/ A given module must implement this function. The function is called"},{"entry":"\/\/ from the Warp framework to supply data to the module."},{"entry":"\/\/ Two arguments are passed:"},{"entry":"\/\/"},{"entry":"\/\/\u2003\u2003warpcon - Quantum Warp's data flow control data"},{"entry":"\/\/\u2003\u2003message - A Quantum message providing the data"},{"entry":"\/\/\u2003\u2003mycon - My provide data for this data flow"},{"entry":"\/\/"},{"entry":"\/\/ The module must process the data as shown in the following classification"},{"entry":"\/\/ example"},{"entry":"\/\/"},{"entry":"void MyModuleDataIn(tASWarpContext warpcon, tASMessage message, "},{"entry":"void* mycon)"},{"entry":"{"},{"entry":"\u2003\/\/ Look at the packet to determine an output channel number."},{"entry":"\u2003\/\/ The \u2018MyClassify( )\u2019 function uses the message and local context"},{"entry":"\u2003\/\/ to determine an output port number."},{"entry":"\u2003int output = MyClassify(message, mycon);"},{"entry":"\u2003\/\/ Pass the message to the output."},{"entry":"\u2003as_WarpDataOut(warpcon, message, output);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Quantum\u2122 manages the sets of context data for each module. The routine as WarpDataOut( ) handles the multiplexing and automatically ensures that the next module is able to access its own private per-flow context data. Quantum\u2122 always provides an output of index zero to denote termination of the processing chain with a discard of the data message. Modules should not simply free a message that is to be discarded, but should set the message status code to indicate the reason for the discard and pass the message to output zero. As an alternative to as WarpDataOut( ) a module may use the call as WarpDataSuspend( ) to temporarily suspend processing of a given data messages. This will typically be used if a message has been passed to a hardware unit (such as an NP or DMA engine) and the call chain can not proceed until the external unit has completed. Note that as WarpDataSuspend( ) does not save the current call chain state.","The software managing the external hardware unit is responsible for resuming the call chain processing. This is reasonable, since the typical action on completion of such processing will typically just release the message. To implement such a scheme, Quantum\u2122 must build a tree structure describing the possible pathways that a message may take. The tASWarpContext type is used to manage the call chain and output multiplexing. The Warp context passed to successive modules will be different. Consider the following configuration of modules.  simplistically illustrates one possible module configuration, while  illustrates the warp tree of structures and references corresponding to such a configuration.","The term mux is used to refer to the links between modules. Although muxes are typically used programmatically as output connections by driver software, they are in fact bindings combining input and output information from two modules. There will be one such structure for each possible data flow on the system, where a data flow is any logically distinct set or ordered data messages (e.g., data received on a single VCI, Ethernet frames targeted at a specific MAC address, etc).","The tASWarpContext objects of  are used to contain the context information for each module, its currently data-in handler, and the permissible outputs bound to that module. Such a system can be implemented as a linked list, however, significant performance improvements can be found by constructing call chains using blocks of contiguous memory, tightly coupled to the C procedure call standard for the host CPU. The following structure may be used to implement context state for an ARM platform:",{"@attributes":{"id":"p-0183","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct sASWarpContext"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003U32 mux_count;","\/\/ Number of muxes"]},{"entry":["\u2003struct sASWarpExit* exit;","\/\/ Reference to the exit structure (see later)"]},{"entry":["\u2003U32 reserved1;","\/\/ Pad header to align mux objects to"]},{"entry":["\u2003U32 reserved2;","\/\/ a cache line boundary"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003struct"},{"entry":"\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003struct sASWarpContext* pWarpContext;","\/\/ Warp context object"]},{"entry":["\u2003\u2003void* pModuleContext;","\/\/ Module private context"]},{"entry":["\u2003\u2003void (*pfDataInHandler)( );","\/\/ Module data-in handler."]},{"entry":["\u2003\u2003U32 reserved;","\/\/ Unused - pad size "]},{"entry":[{},"\u2003to 2{circumflex over (\u2009)}n words"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003} mux[ ];\u2003 \/\/ Variable length array of muxes"},{"entry":"};"},{"entry":"typedef sASWarpContext* tASWarpContext;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0184","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"_as_WarpDataOut:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\/\/","On entry:"]},{"entry":["\u2003\/\/","r0 = current tASWarpContext address"]},{"entry":["\u2003\/\/","r1 = message handle"]},{"entry":["\u2003\/\/","r2 = output index"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003ldr","\u2003r11, [r0], #16","\/\/ Read count of muxes and point "]},{"entry":[{},{},"\u2003at first"]},{"entry":["\u2003add","\u2003r3, r0, r2, lsl #2","\/\/ Compute address of output structure"]},{"entry":["\u2003cmp","\u2003r2, r3","\/\/ Range check output index"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\/\/","If the mux index is valid, execute the next handler."]},{"entry":["\u2003\/\/","On entry, the handler is passed:"]},{"entry":["\u2003\/\/","\u2003r0 = new tASWarpContext address"]},{"entry":["\u2003\/\/","\u2003r1 = message handle (as passed in to this code)"]},{"entry":["\u2003\/\/","\u2003r2 = the private context for the next module"]},{"entry":["\u2003\/\/","This matches the APCS-32 calling standard for C using"]},{"entry":["\u2003\/\/","tail recursion for the function chaining."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003ldmlsia r3, {r0, r2, pc}","\/\/ Jump to handler"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\/\/","If here, the supplied mux index is out of range. This"]},{"entry":["\u2003\/\/","indicates a software problem - it's better to trap this"]},{"entry":["\u2003\/\/","than simply crash. The trap handler is entered with:"]},{"entry":["\u2003\/\/","\u2003r0 = tASWarpContext associated with the faulty module"]},{"entry":["\u2003\/\/","\u2003r1 = message handle"]},{"entry":["\u2003\/\/","\u2003r2 = faulty mux index"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003sub","\u2003\u2002r0, r0, #16","\/\/ Adjust pointer back to "]},{"entry":[{},{},"\u2003tASWarpContext"]},{"entry":["\u2003b","\u2003\u2002_as_WarpDataOutTrap","\/\/ Jump to trap handler"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"A problem with such a code sequence is that it can not easily be inlined without changing the underlying C compiler support. Normally, a compiler will generate function pre-and-post-amble code sequences that save work registers on a stack. It can be difficult to persuade a compiler to perform tail-recursion so that the stack frame is deleted before the code for as WarpDataOut( ) is invoked. If the compiler won't perform tail recursion, the following call sequence results for a data message running though modules A, D and E. One example of a call sequence through modules A, D, and E is diagrammatically illustrated in .","This can be simplified by simply resetting the stack frame information at the point of chaining. The stack is simply a work space, with one work space per execution thread, and the stack pointer can simply be reset back to the start on each module entry. The following extension to the above ARM examples illustrate such a scheme where the stack pointer is saved in each output structure. This replicates the stack reference in many laces and makes the output structure specific to the actual task that executes the code. However, in practice this isn't a problem, since the software that constructs the chain of tASWarpContext objects has to understand this information anyway.",{"@attributes":{"id":"p-0187","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct sASWarpContext"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003U32 mux_count;","\/\/ Number of muxes"]},{"entry":["\u2003struct sASWarpExit* exit;","\/\/ Reference to the exit structure (see later)"]},{"entry":["\u2003U32 reserved1;","\/\/ Pad header to align mux objects to"]},{"entry":["\u2003U32 reserved2;","\/\/ a cache line boundary"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003struct"},{"entry":"\u2003{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003struct sASWarpContext* pWarpContext; ","\/\/ Warp context object"]},{"entry":["\u2003\u2003void* pModuleContext;","\/\/ Module private context"]},{"entry":["\u2003\u2003int* stack;","\/\/ Stack to use in the handler"]},{"entry":["\u2003\u2003void (*pfDataInHandler)( );","\/\/ Module data-in handler"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003} mux[ ];","\/\/ Variable length array of mux definitions"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"typedef sASWarpContext* tASWarpContext;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0188","num":"0222"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"_as_WarpDataOut:"},{"entry":"\u2003\/\/ See the previous example for calling parameters. The"},{"entry":"\u2003\/\/ only change here is that the stack pointer is loaded"},{"entry":"\u2003\/\/ prior to invoking the next module."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003ldr","r11, [r0], #16","\/\/ Read count of muxes and point at"]},{"entry":[{},{},"first"]},{"entry":["\u2003add","r3, r0, r2, lsl #2","\/\/ Compute address of output structure"]},{"entry":["\u2003cmp","r2, r11","\/\/ Range check output index"]},{"entry":["\u2003ldmlsia","r3, {r0, r2, sp, pc}","\/\/ Invoke handler, resetting the stack "]},{"entry":[{},{},"pointer"]},{"entry":["\u2003sub","r0, r0, #16","\/\/ Adjust pointer back to "]},{"entry":[{},{},"tASWarpContext"]},{"entry":["\u2003b","_as_WarpDataOutTrap","\/\/ Handle out of range output index"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{},"figref":"FIG. 20"},"The modified scheme adds one cycle of overhead to the output dispatch code, but removes the unwinding of the call stack and can also improve efficiency by re-using the same area of stack for each module to given improved use of the CPU's data cache. In effect, the invocation of as WarpDataOut( ) becomes a specialized form of the C language return statement, forcing tail recursion, automatically handling module chaining with support for private module data, and all without need to modify the C or C++ compiler tools. This discussion does not describe the actual invocation of the module call chain. This will typically either be from a standard C or C++ code wrapper, in which case the calling code will need to save the original stack reference prior to entering the call chain (which must itself use a different stack to avoid overwriting data owned by the caller). One alternative is to dispatch natively from a specialized form of Quantum\u2122 task that is dedicated to executing code in warp modules. Such a system is discussed in detail below, in the section entitled Implementing QoS: Multithreading.","An ARM code sequence that could be used to invoke a call chain can be implemented by adding a wrapper module to the end of the call chain. The sole purpose of the last module is to directly implement the function return:",{"@attributes":{"id":"p-0191","num":"0225"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ r0 = initial tASWarpContext"},{"entry":"\/\/ r1 = message handle"},{"entry":"\/\/ r2 = initial module context"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ldr","r3, [r0, #4]","\/\/ Get pr to the sASWarpExit structure"]},{"entry":["stmia","r3, [sp, pc]","\/\/ Save return state information"]},{"entry":["add","r0, r0, #16","\/\/ Invoke initial handler using mux #0"]},{"entry":["ldmia","r0, {r0, r2, sp, pc}","\/\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Code resumes from here when mux #0 is invoked on the"},{"entry":"\/\/ final tASWarpContext object."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0192","num":"0226"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"struct sWarpExit"]},{"entry":[{},{},"{"]},{"entry":[{},{},"\u2003int* stack; \/\/ Stack to restore"]},{"entry":[{},{},"\u2003int* lr; \/\/ Return program counter address"]},{"entry":[{},{},"};"]},{"entry":[{},{},"typedef struct sWarpExit* tWarpExit;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0193","num":"0227"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"_as_WarpDataSuspend:"]},{"entry":[{},"\u2003\/\/ On entry:"]},{"entry":[{},"\u2003\/\/\u2003r0 = tASWarpContext reference"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003ldr r1, [r0, #4]","\/\/ Get reference to tASWarpExit"]},{"entry":[{},"\u2003ldmia r1, {sp, pc}","\/\/ Break call sequence"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"To implement quality of service for a given call sequence, it is useful to introduce a new Quantum\u2122 task type. Traditional Quantum\u2122 tasks are driven by the delivery of messages to interfaces. A message could be used to wrap up a call chain argument, so that call chains could be invoked or distributed between many distinct threads of execution.","A more efficient mechanism is, however, to make the fundamental scheduling control for the task the data necessary to invoke a call chain or fragment of such a chain.","To begin a data path call chain, only three things need to be known:",{"@attributes":{"id":"p-0196","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":{"@attributes":{"id":"ul0015-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":["The target thread;","The message handle; and","The address of a mux object (within a tASWarpContext object)."]}}}},"A simple fixed size circular buffer may be used by the handler for an implementation of data-in handler that is dispatched from a mux and which wishes to defer execution to another thread. This in turn is tightly coupled to a specialized Quantum\u2122 task, referred to as a Warp Task. A warp task control block containing such a FIFO might have the following form:",{"@attributes":{"id":"p-0198","num":"0234"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"struct sHSWarpFifoEntry"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003void* message;","\/\/The message being passed"]},{"entry":["\u2003void* mux;","\/\/The mux used to process the "]},{"entry":[{},"message"]},{"entry":["};",{}]},{"entry":["struct sHSWarpFifo",{}]},{"entry":["{",{}]},{"entry":["\u2003struct sHSWarpFifoEntry* start;","\/\/ Start address of FIFO"]},{"entry":["\u2003struct sHSWarpFifoEntry* end;","\/\/ End address of FIFO"]},{"entry":["\u2003struct sHSWarpFifoEntry* read;","\/\/ Read pointer"]},{"entry":["\u2003struct sHSWarpFifoEntry* write;","\/\/ Write pointer"]},{"entry":["\u2003struct sHSWarpFifoEntry entries[n];","\/\/ Fixed size array of entries"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"struct sHSWarpTask"},{"entry":"{"},{"entry":"\u2003struct sHSWarpFifo fifo; \/\/ Request FIFO"},{"entry":"\u2003. . . other task state and context . . ."},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0199","num":"0235"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"_as_WarpTaskMainLoop:"},{"entry":"\u2003\/\/ Passed:"},{"entry":"\u2003\/\/"},{"entry":"\u2003\/\/ r0 = address of FIFO"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\/\/",{},{}]},{"entry":["\u2003mov","\u2003r8, r0","\/\/ Save address of FIFO"]},{"entry":["\u2003ldmia","\u2003r8, {r4-r7}","\/\/ r4 = start, r5 = end, r6 = read, "]},{"entry":[{},{},"\u2003r7 = write"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"loop1:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003bl","\u2003_hs_WarpTaskWait","\/\/ Wait for data to arrive at the FIFO"]},{"entry":["loop2:",{},{}]},{"entry":["\u2003ldmia","r6!, {r1, r2}","\/\/ Get first entry from read pointer"]},{"entry":["\u2003cmp","r6, r5","\/\/ Handle FIFO wrap"]},{"entry":["\u2003movge","r6, r4","\/\/"]},{"entry":["\u2003ldmia","r2, {r0, r2, sp, pc}","\/\/ Invoke call chain"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003 \/\/ Call chain returns by branching here"},{"entry":"_as_WarpTaskMainLoop_EndOfChain:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003str","r6, [r8, #8]","\/\/ Save updated read pointer in FIFO"]},{"entry":["\u2003ldr","r7, [r8, #12]","\/\/ Get next write pointer"]},{"entry":["\u2003cmp","r6, r7","\/\/ Anything more to do?"]},{"entry":["\u2003bne","loop2","\/\/ Yes - immediate dispatch"]},{"entry":["\u2003b","loop1","\/\/ No - sleep until something arrives"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"A different design of FIFO header will help, for example. To drive this, all that is needed is for the mux at the end of a module chain to simply drop the necessary information in to the appropriate FIFO. The simplest way to do this is to encode a specialized form of the previously described tASWarpExit structure using the module specific parameter (an alternative would be to encode this information in each and every mux object\u2014which is slightly faster but more wasteful of memory). The following structure can be used:",{"@attributes":{"id":"p-0201","num":"0237"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"struct sWarpExitThreaded",{}]},{"entry":[{},"{",{}]},{"entry":[{},"\u2003struct sHSWarpTask* task;","\/\/ Warp task to use"]},{"entry":[{},"\u2003void* mux;","\/\/ Mux to invoke"]},{"entry":[{},"\u2003int* stack;","\/\/ Stack to restore"]},{"entry":[{},"\u2003int* lr;","\/\/ Return program counter address"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"typedef struct sWarpExitThreaded* tWarpExitThreaded;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0202","num":"0238"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"_as_WarpDeferDataOut:"},{"entry":"\u2003\/\/ On entry:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\/\/","r0 = target warp task"]},{"entry":["\u2003\/\/","r1 = message handle"]},{"entry":["\u2003\/\/","r2 = context pointer, referencing a tASWarpThreadExit object"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003ldmia","\u2003r2, {r4-r5, sp, lr}","\/\/ r4 = task, r5 = mux, reset sp and get "]},{"entry":[{},{},"\u2003return address"]},{"entry":["\u2003ldmia","\u2003r4, {r6-r9}","\/\/ r6 = start, r7 = end, r8 = read, "]},{"entry":[{},{},"\u2003r9 = write"]},{"entry":["\u2003stmia","\u2003r9!, {r1, r5)","\/\/ Add message and mux to warp "]},{"entry":[{},{},"\u2003task's FIFO"]},{"entry":["\u2003cmp","\u2003r9, r7","\/\/ Handle wrap-around"]},{"entry":["\u2003movge","\u2003r9, r7","\/\/"]},{"entry":["\u2003cmp","\u2003r8, r9","\/\/ Check for overflow"]},{"entry":["\u2003beq","\u2003_as_WarpDeferTrap","\/\/ Trap overflows (see text)"]},{"entry":["\u2003str","\u2003r9, [r4, #12]","\/\/ Save updated write pointer"]},{"entry":["\u2003bl","\u2003_as_WakeWarpTask","\/\/ Magic glue to ensure warp task "]},{"entry":[{},{},"\u2003is running"]},{"entry":["\u2003mov","\u2003pc, lr","\/\/ Exit thread call sequence"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Warp tasks will need to be constructed as sub-tasks of a single data-path handling task. One embodiment of such task and sub-task structure is shown in  and implementing four priorities. The top level task , \/task\/data, is implemented as a standard Quantum\u2122 task using the normal message APIs. Other tasks in the system may send data messages directly to this task by simply using the as_Message-Send( ) API. This task implements the highest priority processing for the data path, directly running the function call chain in response to a message delivered from another task on the system. The embodiment of  also shows three sub-tasks, ,  and . These are shown embedded in the top level task since they share memory and resources. Sub-tasks are, however, executed independently of each other and any higher level tasks under Quantum\u2122. Each may have its own distinct set of Quantum\u2122 scheduler QoS parameters. Processing is deferred from any task to a lower priority one using the mechanisms outlined in this document.","Such a scheme means that the data path driver code always runs in the context of one of these tasks. Module code must therefore be structured as a shared library. Note that the information stored in the tASWarpContext and related data structures is intimately tied to the structure of these tasks and the priority at which processing is performed. If it is desirable to implement parallel threading, where parallel threads execute at the same priority, duplicate call chains must be constructed for each execution path (this may be desirable if, for example, a given thread processing chain needed to perform blocking calls and you do not want to stop all processing at that priority until the specific block has been released).","Enhancing Module Performance: Selectors","Many driver modules may wish to perform different processing actions based on some rarely changing configuration. For example, an encryption module may offer both DES or 3DES modes. Typically, this would be handled with the following code sequence:","if (mode==DES)","{\n\n","}","else if (mode==DES3)","{\n\n","}","This imposes run-time overhead for a module property that changes only rarely. A better solution is for a driver module to export a number of different processing functions\u2014e.g.:","void myDataIn_DES(tASWarpContext warpcon, tASMesssage message, void* mycon); void myDataIn_DES3(tASWarpContext warpcon, tASMesssage message, void* mycon);","Since the implementation of the call chains used by Quantum\u2122 warp contains a reference to the function used to perform packet processing by the module, it is trivial to provide an API that allows a module to change the data-in function that it has registered, typically in response to a configuration change to the module itself.\n\nModule Configuration and Status Access\n","The present application does not specify a particular mechanism used to configure warp modules. However, the generic attribute mechanisms supported by BUN provide a good reference point as to the design of a generic attribute API to support module configuration and status. Exposing these APIs to control Warp Modules and their data streams would maximize code re-use, while also providing system level management for object access (to handle issues such as multiple-clients referencing the same object, when someone decides that it should be deleted).","While the foregoing description includes many details and specificities, it is to be understood that these have been included for purposes of explanation only, and are not to be interpreted as limitations of the present invention. Many modifications to the embodiments described above can be made without departing from the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention can be understood more completely by reading the following Detailed Description of the Preferred Embodiments, in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 18","FIG. 17"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
