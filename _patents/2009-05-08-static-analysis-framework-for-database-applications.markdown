---
title: Static analysis framework for database applications
abstract: A tool facilitating static analysis for database applications, such that the static analysis tool (SAT) can significantly enhance the ability for developers to identify security, correctness and performance problems in database applications during the development phase of an application lifecycle. A static analysis tool for database applications presents a framework for database applications using the ADO.NET data access APIs. The SAT framework consists of a core set of static analysis services upon which verticals such as workload extraction, SQL injection detection, identifying data integrity violations, and SQL performance analysis are built using the core services.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08452754&OS=08452754&RS=08452754
owner: Microsoft Corporation
number: 08452754
owner_city: Redmond
owner_country: US
publication_date: 20090508
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Database application developers use integrated development environments (IDEs) to write database applications in programming languages such as C++, C#, Java\u2122 from Sun Microsystems, Inc., etc. Generally, IDEs such as Microsoft Visual Studio\u00ae provide tools to help developers develop, debug, and analyze applications during development. Often database applications are written to include data access application programming interfaces (APIs) to make SQL queries from the applications during execution. Examples of data access APIs for executing SQL statements include ADO.NET, Open Database Connectivity (ODBC), and Java Database Connectivity (JDBC\u2122).","However, current IDEs fail to recognize interactions between applications in development and database management systems (DBMSs). Additionally, relational database management systems (RDBMSs), such as SQL Server\u00ae from Microsoft\u00ae currently may not recognize when an SQL query made during execution of a database application has been changed or is inconsistent with the application.","A method and system for leveraging data access APIs and database application binaries to provide a set of analysis services via a Static Analysis Tool (SAT) are described herein. The SAT provides a framework for analyzing database application binaries to automatically identify security, correctness and performance problems in the database application via service tools and vertical tools.","In at least one embodiment, the service tools of the SAT are provided on top of a compiler facilitating the vertical tools. In at least one embodiment the SAT framework supports analysis within a single basic code block, across basic blocks within a function, and across functions.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","The same numbers are used throughout the disclosure and figures to reference like components and features.","Overview","A Static Analysis Tool (SAT) enables leveraging data access APIs and database application binaries to provide a set of analysis services for database applications. In another aspect, the SAT provides a framework for analyzing database application binaries to automatically identify security, correctness and performance problems in the database application via tools such as service tools and vertical tools.","Services enabled by the tools include: extracting the set of SQL statements that may execute in an application; identifying properties of the SQL statements such as tables and columns referenced; extracting parameters used in the SQL queries and their binding to program variables; extracting properties of how the SQL statement results are used in the application; analyzing user input and their propagation to SQL statements. Verticals built using the above services, enable: detecting SQL injection vulnerability, extracting the SQL workload from application binary, identifying opportunities for SQL query performance optimizations, and identifying potential data integrity violations.","An environment in which these tools may enable these and other techniques is set forth first below. This is followed by other sections describing various inventive techniques and exemplary embodiments of the tools. These sections describe exemplary ways in which the inventive tools enable analysis within a single basic block, across basic blocks within a function, and across functions.","Exemplary Operating Environment","Before describing the tools in detail, the following discussion of an exemplary operating environment is provided to assist the reader in understanding at least one way in which various inventive aspects of the tools may be employed. The environment described below constitutes but one example and is not intended to limit application of the tools to any one particular operating environment. Other environments may be used without departing from the spirit and scope of the claimed subject matter.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","101","102"]},"Computer-readable media can be any available media that can be accessed by a computing device such as computing devices , , and . Computer-readable media includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media comprises computer storage media. \u201cComputer storage media\u201d includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device such as computing devices , , and .","Computing device  may be one of a variety of computing devices, such as a cell phone, laptop computer, desktop computer, personal digital assistant, or server. Each computing device having at least one processor capable of accessing and\/or executing instructions embodied on the computer-readable media. The computing device may also include input\/output devices such as a keyboard, mouse, microphone, printer, monitor, and speakers (not shown) useable to implement one or more embodiments of the tools described herein.","The operating environment  also comprises one or more network(s)  and computing device server(s) . The network  enables communication between the computing device(s) , , and , and can comprise a global or local wired or wireless network, such as the Internet, a local area network (LAN), or an intranet. Computer-readable media of computing devices such as  and  comprises or has access to a browser, which is a module, program, or other entity capable of interacting with a network-enabled entity such as a server . In aspects of several embodiments server(s)  may be implemented as a web server, in a server farm, and as content provider(s) providing content from a database  upon which a query may be run, and combinations thereof.","In some embodiments, the operating environment  may further comprise at least a second computing device  having one or more processor(s) and computer-readable media, similar to computing device . Each computing device  comprises a computing device similar to . The computing device(s)  may be the same computing device as computing device , or can be a separate or different computing device. Further, computing devices , , and  may host or otherwise access any number of databases , e.g., database ( . . . N).","Aspects of computing devices, such as computing devices , , , in at least one embodiment include functionality for implementing the static analysis framework for database applications algorithm to implement the static analysis tool (SAT)  individually or encompassing a compiler functionality . For example, as shown from server , program modules may be implemented as computer-readable instructions, various data structures, and so forth via at least one processing unit to configure a computer having system memory to apply the SAT  with compiler functionality  within a single basic block, across basic blocks within a function, and across functions as discussed regarding , below. In several embodiments input to the SAT is made up of application binaries, e.g. .exe or .dll files and a database. In at least one embodiment this input is received via network , and in some embodiments the input may be received via a commonly hosted or otherwise accessed database such as .","Although the subject matter is described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts or to the structural proximity or sequences described herein. Rather, the specific features and acts described are disclosed as exemplary forms of implementing the claims.","Exemplary Architecture","The following discussion describes an exemplary architecture by which the SAT  improves analysis of characteristics such as security, performance, and correctness of database application binaries still in development. Code Example 1, below presents an example portion of application source code for a C# application allowing a user to search a product catalog. In this example, the application retrieves rows from a table in a database that contains the user submitted string.",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Code Example 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Event handler for button click"},{"entry":"private void onLookupButtonClick(object sender, EventArgs e)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ Get search string from edit box"},{"entry":"\u2003\u20031. string searchstring = lookupeditbox.Text;"},{"entry":"\u2003\u2003\/\/ Call the actual function"},{"entry":"\u2003\u20032. LookupProduct(searchstring);"},{"entry":"}"},{"entry":"\/\/ Look up the product in database"},{"entry":"private void LookupProduct(string searchstring)"},{"entry":"{"},{"entry":"\u2003\/\/ Create a ADO.NET SQLCommand object. Represents a SQL"},{"entry":"\u2003\u2002\u2009 statement"},{"entry":"\u20031. string cmdtext = \u201cselect sku, description, price from Products"},{"entry":"\u2003\u2002\u2009 where description like \u2018%\u201d + searchstring + \u201c%\u2019 \u201d;"},{"entry":"\u20032. SqlCommand cmd = new SqlCommand(cmdtext, dbConnection);"},{"entry":"\u2003\/\/ Does user want to sort the result or not?"},{"entry":"\u20033. if ( SortRows( ) ){ cmdtext += \u201c order by price \u201d; }"},{"entry":"\u2003\/\/ Sets the SQL statement to execute at the data source."},{"entry":"\u20034. cmd.CommandText = cmdtext;"},{"entry":"\u2003\/\/ Execute the query"},{"entry":"\u20035. SQLDataReader rdr = cmd.ExecuteReader( );"},{"entry":"\u2003\/\/ iterate through results"},{"entry":"\u20036. while (rdr.Read( )){\/* add to grid *\/}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["200","110","110","202","202","110"]},"The SAT  is made up of a layer of static analysis service tools for database applications (services)  and a layer of vertical tools (verticals)  for database applications. In at least one embodiment verticals  are built using services  and enable extracting the SQL workload from application binary, detecting SQL injection vulnerability, identifying opportunities for SQL query performance optimizations, and identifying potential data integrity violations.","Workload extraction  provides a vertical that identifies, during application development time, the set of SQL statements that can be executed by the application undergoing development. For example, when migrating an application from one DBMS to another, or from one release of a DBMS to the next release of the DBMS, identifying SQL statements issued by the application is important since some statements may need to be modified to adhere to the syntax and restrictions of the target DBMS. Another example of workload extraction is physical design tuning. While today's DBMSs have tools for tuning physical design that take as input a workload and recommend an appropriate physical design, extracting a workload from an application binary facilitates improved initial physical design for the database. This enables less costly refinement after the application is deployed.","Because query strings may be constructed across multiple functions, extraction of the workload can be non-trivial for arbitrary database applications. In the code sample presented in Code Example 1, two possible SQL queries can execute at Line 5\u2014the second query is executed if SortRows( ) in Line 3 returns TRUE.\n\n","In the above example, the workload was a set of SQL statements. It can also be useful to extract sequences of SQL statements, e.g., a sequence such as: CREATE TABLE T, INSERT INTO T . . . , SELECT . . . FROM S, T, WHERE . . . , DROP TABLE T. Capturing such a sequence from a database application binary enables invoking a tool that can tune a sequence of statements.","SQL injection detection  provides a vertical that identifies, during application development time, SQL injection vulnerability in the application undergoing development by examining the application binary.","In the example sample of application code presented in Code Example 1, above, the application retrieves rows from a table in a database that contains the user submitted string. In the function onLookupButtonClick the user input is read from an Edit Box control. In turn, the LookupProduct function is invoked. The LookupProduct function does the actual lookup in a Products table using a dynamically constructed SQL query. The query is executed using the ExecuteReader method of the SqlCommand object.","If the user submits a string such as \u201cMicrosoft Office 2007\u201d, then the following query string is constructed at Line 1 in the LookupProduct function.\n\n","Now consider when a malicious user submits a string such as the following string.\n\n","The following query string would now be constructed on Line 1 in the LookupProduct function.\n\n","Thus, the original intent of the query would be modified due to the concatenation of user input. As a result, when the query is executed on Line 5, this has the undesirable effects of first returning all rows in the Products table to the user and then dropping the table.","As the example above illustrates, catching an SQL injection vulnerability is important. Tools such as SAT  also need to not return an excessive number of false positives. For example, many application developers correctly use the ADO.NET APIs for passing user input as a parameter to a SQL query (e.g. AddParameter method). In such cases, the SQL injection detection vertical  detects that there is no injection vulnerability since the DBMS cannot interpret the user input as code.","Integrity checking  provides a vertical that identifies, during application development time, database integrity constraints in the application undergoing development by examining the application binary. Database integrity constraints may be enforced in the application layer and not the database layer to avoid operational disruptions since it is often easier to deploy a modified application module. For example, in hosted web service scenarios, the cost of altering an existing table may be more than deploying the modified application module.","Another example relates to performance cost where integrity constraint checking in DBMSs can be expensive. For example, if the application developer wants to enforce in the application code the constraint that the price column of the Products table always has a value >0, Code Example 2 may be used.",{"@attributes":{"id":"p-0045","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Code Example 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/\u2003Create\u2003a\u2003ADO.NET\u2003SQLCommand\u2003object\u2003for\u2003an\u2003INSERT"},{"entry":"statement"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1.","string myQuery = \u201cINSERT INTO Products"]},{"entry":[{},"\u2009(price,sku,description)"]},{"entry":[{},"VALUES(@price,@sku,@description)\u201d;"]},{"entry":["2.","SqlCommand cmd = new SqlCommand(myQuery, dbConnection);"]},{"entry":["\/\/","Bind program variables to the parameters"]},{"entry":["3.","cmd.Parameters.Add(new SqlParameter(\u201c@price\u201d, myprice));"]},{"entry":["4.","cmd.Parameters.Add(new SqlParameter(\u201c@sku\u201d, mysku));"]},{"entry":["5.","cmd.Parameters.Add(new SqlParameter(\u201c@description\u201d,"]},{"entry":[{},"mydesc));"]},{"entry":["\/\/","Execute the insert statement"]},{"entry":["6.","cmd.ExecuteNonQuery( );"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Given a constraint such as [DBName].[Products].[price]>0 as input, integrity checking vertical  enables automatically identifying all places in the application code where the price column can potentially be updated, and enables adding an assertion at such places in the code. For example, in the above code section, integrity checking vertical  would automatically recommend inserting the code \u201cAssert (myprice>0)\u201d before Line 3 to validate the given data integrity constraint [DBName].[Products].[price]>0. In order to provide such a recommendation, SAT  via integrity checking vertical : determines that a data manipulation language (DML) statement affecting the price column is occurring in the application code, and identifies the program variable\/expression that is bound to the price column in the DML statement. , below, represents a screenshot produced by the SAT , after analysis is complete.","SQL Performance Analysis  provides a vertical that identifies, during application development time, opportunities for improved query performance in the application undergoing development by examining the application binary and alerting the developer of the ability to improve performance. For example, code such as shown in Code Example 3, below, may include queried columns that are not consumed.",{"@attributes":{"id":"p-0048","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Code Example 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1.\u2003\u2003cmd.CommandText = \u201cselect sku, price, description from"]},{"entry":[{},"Products\u201d;"]},{"entry":[{},"\/\/ Execute the query"]},{"entry":[{},"2.\u2003\u2003SQLDataReader rdr = cmd.ExecuteReader( );"]},{"entry":[{},"\/\/ iterate through results"]},{"entry":[{},"3.\u2003\u2003while (rdr.Read( )){"]},{"entry":[{},"4.\u2003\u2003\u2003s = rdr[0]; \/\/ use sku value"]},{"entry":[{},"5.\u2003\u2003\u2003p = rdr[1]; \/\/ use price value"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Although there are three projection columns in the query \u201csku\u201d, \u201cprice\u201d, and \u201cdescription\u201d, the application references only two \u201csku\u201d and \u201cprice\u201d when consuming the query results. Thus, in this example, SAT  via SQL Performance Analysis vertical  detects this and alerts the developer so that the query performance can be improved by rewriting the query as \u201cselect sku, price from Products\u201d.","Other functionality is contemplated as a part of the illustrated verticals  or via similar individual verticals of SAT . For example, a development manager for an application may want to enforce a set of best practices in coding for all developers in the project. Such a best practices vertical may be implemented as part of or as a combination of integrity checking , SQL performance analysis , or others of the illustrated verticals; alternately, a separate best practices vertical (not shown) could be implemented as a part of verticals . The following illustrate examples that could be included in such a best practices vertical.\n\n","Such verticals of the SAT  leverage understanding of the data access APIs (e.g. SQLCommand.ExecuteReader is an API through which a query is executed in ADO.NET).","In addition, the SAT  for some of the examples may implement a deeper analysis via access to the database schema, SQL parser, and the query optimizer of the DBMS. One such example occurs when rewriting of the query is recommended. In order to quantify the estimated improvement in performance by such a rewriting, a query optimizer may be used to obtain the execution plan of the original and rewritten queries.","Verticals  have significant commonality. For example, the need to extract the SQL statements that can execute at a particular ExecuteReader( ) call in a program is common to both Workload Extraction  and SQL Performance Analysis . Similarly, identifying properties of the SQL such as which columns are referenced is important in Workload Extraction  and Integrity Checking . Thus, Services  comprises a library of services for database applications utilized to develop Verticals . In at least one embodiment, Services  is built on top of a compiler framework . Services  of the exemplary SAT  comprises five services of use in implementing verticals .","Extract SQL , during application development time, provides a service that given a function in the program binary, returns a set of SQL statement handles. A handle is a unique identifier that is a (line number, ordinal) pair in that function. The handle represents a SQL statement that can execute at that line number. Referring to the LookupProduct function in Code Example 1, above, Extract SQL  returns two handles (e.g. (5,1), (5,2)), corresponding to the two statements that can execute at line number 5 (the ExecuteReader( ) invocation in the function).","The Extract SQL service  may be configured to extract a specified portion of the SQL that may be executed by the application. For example, when the table names in the query are generated dynamically, the strings extracted by static analysis will not be syntactically valid SQL statements due to their dynamic nature. Another example is the presence of an \u201cIN\u201d clause in the query, where the values in the IN clause are generated inside a loop in the program. However, in real world database applications a large fraction of the SQL executable by the application may be extracted by static analysis alone.","During the application development time Identify SQL Properties  provides a service that, given a handle to a SQL statement, returns properties of the SQL statement. In at least one embodiment Identify SQL Properties  identifies the following properties: (1) the SQL string itself; (2) number and database types of columns in the result of the SQL statement (for SELECT statements); (3) tables and columns referenced in the statement; and (4) optimizer estimated cost of statement. Identify SQL Properties  identifies (2), (3) and (4) above via access to the database schema, an SQL parser, and obtaining the execution plan for a given SQL statement. In at least one embodiment, when extracted SQL indicates a derived property Identify SQL Properties  derives the property.","In at least one embodiment Identify SQL Properties  may obtain the database connection to use when accessing the database in multiple ways in a variety of embodiments. Examples of ways Identify SQL Properties  obtains a database connection to use when accessing the database include from a configuration file, automatically by Identify SQL Properties  analyzing the connection string used in the application, and via user input.","Extract Parameters , during application development time, provides a service that given a handle to a SQL statement, returns the parameters of the statement along with the program variable\/expression that is bound to the respective parameter, and the program variable\/expression data type in the application. For example, referring to Integrity Checking , the Extract Parameters  service returns {(@price, myprice, double), (@sku, mysku, int), (@description, mydescription, String)}.","Extract Result Usage , during application development time, provides a service that given a handle to a SQL statement, returns properties of how a result set is consumed in the application. In particular, Extract Result Usage  returns each column in the result set that is bound to a variable in the program, along with the type of the bound program variable. Referring to SQL Performance Analysis , the Extract Result Usage  service returns {(0, s, int), (1, p, double)} assuming the types of variables s and p are int and double respectively.","Analyze User Input , during application development time, provides a service that given a handle to a SQL statement, identifies all user inputs in the program such that the user input value v satisfies a \u201ccontributes to\u201d relationship to the SQL string of the statement. A contributes to relationship is defined as either: (a) v is concatenated into the SQL string; or (b) v is passed into a function whose results are concatenated into the SQL string in at least one embodiment.","Exemplary Operation","The following discussion of  describes an exemplary overview operation  of at least one embodiment of the static analysis framework for database applications. The discussion references elements discussed above regarding . This implementation takes as input an application binary  (e.g., a DLL or EXE) and database domain information  (e.g., a database schema, data access APIs, ADO.NET, etc. and at  performs custom static analysis on the binary via the SAT . In this example, output  is a set of security, performance and correctness problems as identified by the vertical tools . For certain verticals , e.g. identifying potential violations of data integrity constraints , the user can specify a set of constraints (e.g. Products.Price>0) as user input (e.g., constraints, functions, etc.) illustrated at . Also, based on user input , static analysis on the binary at  via the SAT  may be customized to analyze one or more functions, up to all of the function units in the binary.","The exemplary implementation illustrated relies upon a compiler framework  to build out the SAT  services  and verticals  to perform static analysis on the binary of the database application at . In at least one other implementation the SAT  services  and verticals  may be implemented independently from compiler framework  to perform static analysis on the binary of the database application at .","In the illustrated example, compiler framework  converts the application binary in Microsoft Intermediate Language (MSIL) illustrated at  into an intermediate representation (IR)  upon which the the SAT  operates to perform static analysis at .","In one aspect of the example, compiler framework  via the SAT  services  and verticals  performance of static analysis on the binary of the database application at  iterates over function unit(s) within the binary. In at least one implementation, the iteration is based at least in part on user input , although in other implementations no user input  need be involved. In another aspect of the example, compiler framework  via the SAT  services  and verticals  performance of static analysis on the binary of the database application at  effects data and control flow analysis . In yet another aspect of the example, compiler framework  via the SAT  services  and verticals  performance of static analysis on the binary of the database application at  iterates over individual instructions in the IR  within a basic block. In still another aspect of the example, compiler framework  via the SAT  services  and verticals  performance of static analysis on the binary of the database application at  provides extensions to dynamically extend the framework types like function units and basic blocks. In yet another aspect of the example, compiler framework  via the SAT  services  and verticals  performance of static analysis on the binary of the database application at  provides a flow graph  in order to iterate over basic blocks within a function unit. In yet another aspect of the example, compiler framework  via the SAT  services  and verticals  performance of static analysis on the binary of the database application at  provides a call graph  that represents the control flow across function units. For example, referring to Code Example 1, above, when there is a call to function LookupProduct from the function onLookupButtonClick at Line number 2.","An example of intermediate representation (IR) instructions for the function onLookupButtonClick follows as Code Example 4.",{"@attributes":{"id":"p-0066","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Code Example 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ IR corresponding to Line 1"]},{"entry":[{},"tv272 = ASSIGN [this]*\u201cSTAPort.Form1:: lookupeditbox\u201d"]},{"entry":[{},"tv273 = CALLVIRT* System.Windows.Forms.Control:: get_Text,"]},{"entry":[{},"tv272"]},{"entry":[{},"searchstring = ASSIGN tv273"]},{"entry":[{},"\/\/ IR corresponding to Line 2"]},{"entry":[{},"{*CallTag} = CALL* &STAPort.Form1:: LookupProduct, this,"]},{"entry":[{},"searchstring, {*CallTag}, $L5(EH)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In at least one embodiment data structure and control flow analysis  for a single basic block, for example, (also referred to as a block) is performed via the following operations. Each block represents a sequence of IR instructions. The control flow of the program enters a block at its first instruction and proceeds sequentially through the instructions in the block until it reaches the block's last instruction. The IR instructions corresponding to the function onLookupButtonClick is shown in the code snippet, above. Each IR instruction can be mapped into destination operand, opcode and source operands. In the example above, for the second instruction, the destination operand is tv273, the opcode is CALLVIRT, and the source operands are System.Windows.Forms.Control::get_Text and tv272.","SAT  maintains a hash table as a data structure that at any point during the analysis captures the current values of the operands referenced in instructions in the basic block. For example, as illustrated in  at , the hash table  is created after executing the instructions above. Hash table  has the destination operand as the key (e.g. temporary variable tv273 in the example) and associates the key with a data flow tree . The tree contains nodes that hold the operands and opcode. This may be understood as similar to algebraic expression trees. The leaf nodes are other operands or symbols, while the non-leaf nodes are the opcodes. When an assignment to an operand is encountered in the instruction stream  (e.g. ASSIGN IR) the assignment results in replacing the current tree associated with the operand with the data flow tree  of the source operand that was assigned. Data flow tree  is flexible and may be constructed using a variety of algorithms. Examples of such algorithms may be found in A. Aho, R. Sethi, and J. Ullman. Compilers. Principles, Techniques and Tools. Addison Wesley. (1986).","In addition to the operand\/opcode information, each node of the data flow tree  also stores and propagates information for static analysis services . Examples of such information include: symbols that are referenced by the node, line number associated with the node, whether the node is an ADO.NET object (e.g., SQLConnection, SQLCommand, SQLDataReader), and whether the node is part of a string concatenation operation.","By customizing what information is stored in each node, SAT  exposes each of the static analysis services . For example, to expose the user input analysis service  the operand\/symbol referenced in a user input function is tracked. This information is propagated through the data flow analysis and thus it enables SAT  to track whether the given user input value can contribute to a SQL string issued at a call site.","SAT  facilitates exploiting knowledge of data access APIs for data flow analysis. The static analysis services for database applications  leverages database domain information including knowledge of data access APIs and the DBMS itself. For example, upon encountering an instruction that calls the following ADO.NET API: System.Data.SqlClient.SqlCommand::ExecuteReader. SAT  identifies ExecuteReader as an API for executing a SQL statement. SAT  can also identify (based on the signature of the API method) that the first argument to the ExecuteReader is an SQLCommand object and thus is the second source operand in the instruction. SQLCommand objects have properties like the text of a command, parameter list, the active SQLConnection object etc. The data flow analysis (described regarding a basic block, above) will give the current values of the various properties of the SQLCommand object including its text field. For example, the text field of the SQLCommand object is the SQL string that is executed at the ExecuteReader instruction.","As a specific example, the call to ExecuteReader (Line 5 of LookupProduct method in Code Example 1) has the following IR representation:\n\n","Here tv306 is the destination operand, CALLVIRT is the opcode and &[System.Data]System.Data.SqlClient.SqlCommand::ExecuteReader, cmd are respectively the first and second source operands. Thus, SAT  is able to infer that the symbol cmd references an ADO.NET SQLCommand Object.","The data flow tree corresponding to the value of cmd in the hash table is shown in  at . The data flow tree for the cmd symbol has a root at  and two sub-trees from nodes  and . These sub-trees correspond to the SQL text portion and the SQLConnection object portion of the SQLCommand constructor (Line 2 of LookupProduct in Code Example 1). The leaf nodes of the union at  corresponding to the SQL text part captures the static parts of the SQL (the embedded SQL strings) and the dynamic part (the searchstring argument). Hence by traversing union , via nodes - or - and concatenating the leaf nodes of the appropriate branch, i.e.,  or , (e.g., , , and , or  or , , and ) the SQL executed at this line number may be extracted. In the illustrated embodiment, the subtree under newobj node  represents a connection string, which is not traversed.","In this example, the two CALL nodes  and  that are children of the UNION node  refer to string concatenation methods (e.g. System.String::Concat). In general, applications can build SQL strings at different places in the code and concatenate the fragments to build the SQL that is executed. Thus SAT  analyzes string concatenation API's to extract the set of strings that can be issued by the application at any call site. As another example, for a statement such as cmd.CommandText=a+b; where a and b are strings, to build the tree for cmd.CommandText SAT  would trace the CALL to the string concatenation function and concatenate the text contributed by the data flow trees for a and b.","In the illustrated example of , the UNION node  represents the case of the flow occurring over multiple paths (e.g., an If-Then-Else statement), and workload is extracted by concatenating the leaf nodes of the path. This is discussed in the context of global data flow analysis, below. Although the example illustrates the SAT  examining the ADO.NET API ExecuteReader, SAT  may also examine other ADO.NET APIs in an analogous manner. For example, there are other APIs such as ExecuteNonQuery, and ExecuteScalar, where the application can potentially issue a SQL statement. As another example, SAT  also analyzes the various parameter collection APIs (e.g. System.Data.SqlClient.SqlParameterCollection::Add) in the data client name space for extracting properties (e.g. data types) of program variables that are bound to parameters of the SQL statement.","Global data flow analysis extends the analysis to operands defined in other basic blocks in the same or another function. In the examples of single block analysis described thus far, for any operand of interest, it was assumed that its definition could be traced within the basic block. While this is true for temporary variables defined within the block itself, certain operands (e.g. the program symbol searchstring in the LookupProduct function) may be defined in other basic blocks (within the same or in a different function). The purpose of global data flow analysis is to enable tracking the definition of the operand of interest beyond the current basic block.","Global data flow analysis accounts for the plurality of control paths to a call site such as ExecuteReader. Building on that described for a single basic block in the discussion of , , and , SAT  first builds the data flow tree for operands within a basic block. If an operand cannot be resolved within the block, a backward traversal to one or more predecessor blocks in the call graph is performed until the operand's definition is obtained from the hash table of that block. Code Example 5, below presents a pseudo-code example algorithm for resolving an operand outside the current block.",{"@attributes":{"id":"p-0079","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Code Example 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ResolveNode"]},{"entry":[{},"Input: Current block C, Node N not resolved in C"]},{"entry":[{},"Output: Resolved data flow tree for Node N"]},{"entry":[{},"1. For each block B in the predecessor list of block C"]},{"entry":[{},"2.\u2003\u2002If N's data flow tree is in block B's hash table"]},{"entry":[{},"3.\u2003\u2003\u2002If N's data flow tree contains unresolved"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2009symbols"]},{"entry":[{},"4.\u2003\u2003\u2003\u2002For each symbol in the unresolved list"]},{"entry":[{},"5.\u2003\u2003\u2003\u2003\u2002ResolveNode(B,symbolnode)"]},{"entry":[{},"6.\u2003\u2003\u2002Else"]},{"entry":[{},"7.\u2003\u2003\u2003\u2002Replace symbol node N in current block with"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2009the data flow tree and mark as resolved"]},{"entry":[{},"8.\u2003\u2002Else \/\/ N's data flow tree not bound in block B"]},{"entry":[{},"9.\u2003\u2003\u2002ResolveNode (B,N)"]},{"entry":[{},"10.\u2003If node N is referenced in more than one predecessor"]},{"entry":[{},"\u2003\u2003\u2002blocks"]},{"entry":[{},"11.\u2003\u2003Add a root UNION node with children as the data"]},{"entry":[{},"\u2003\u2003\u2003\u2002\u2009flow trees referenced in the predecessor blocks"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"An example algorithm for resolving an operand (i.e., node) is shown in Code Example 5, above. In this example, SAT  recursively iterates over each predecessor of the current block. Thus, multiple resolutions (one per path) of the given operand N may occur. If multiple resolutions occur, then a UNION node whose children represent the alternatives is used to represent the alternate paths. Note, the predecessor block could be in the same or a different function unit\u2014the SAT  applies the above algorithm to both cases. SAT  assigns block id numbers to the blocks in depth first order so that the block id of the current node is always greater than its predecessor. This property allows the SAT  to correctly deal with cycles caused by loops.",{"@attributes":{"id":"p-0081","num":"0089"},"figref":["FIG. 6","FIG. 6"],"b":["216","600","602","604","606","608","610","110"]},"In at least one embodiment, vertical tools , introduced in , are implemented on top of the functionality described referring to . For example, SQL Injection Detection vertical  is implemented to detect attacks that occur when unvalidated user input is used to build a SQL string which is then executed on the database server. The adversary injects malicious SQL code in user input that gets executed by the query in the server.","The SQL injection detection tool  takes as input a set of function signatures that can supply user input to the program. For example, this includes a function such as System.Windows.Forms.Control::get_Text. Vertical  marks any destination operand in an instruction where the above function is a source operand as \u201ctainted\u201d. For example, consider the follow IR instruction:\n\n","In the exemplary instruction above, destination operand tv273 is assigned the return value of get_Text and hence the node is marked UNSAFE. The data flow analysis outlined in the previous sections also propagates the \u201csafety\u201d attribute (SAFE, UNSAFE, MAYBE UNSAFE) from the source (where the user input is read) to the sink (call site where the SQL is executed). Therefore, in the case where user data is propagated to the SQL string without passing through any other functions, the resulting SQL will also be reported as UNSAFE.","If the user input is passed into a function (e.g. a validation function) whose return value is propagated to the SQL string, it is marked as MAYBE UNSAFE. If the user input is passed in as a parameter to the SQL (using one of the ADO.NET APIs for passing parameters), the SQL string is marked as SAFE. Note that the SQL that is executed and the sink line number are gathered by using the \u201cExtract SQL\u201d service . As described above, given a handle to the SQL statement we use the Analyze User Input service  to identify all user inputs in the program such that the user input value contributes to the SQL.","In typical applications, it is common that code where the user data is read in and where the SQL is actually executed are in different functions. In these scenarios the ability of the SAT  to perform inter-function analysis is utilized to analyze the database application.","As another example, Integrity Checking vertical  is implemented to enforce data integrity checks in the application code rather than using database integrity checking functionality such as CHECK constraints. The vertical tool  for detecting violations of data integrity constraints takes as input a set of constraints specified by the user. In at least one embodiment constraints of the form (Database. Table. Column Op Value), where Op is a comparison operator and Value is a literal are supported.","Each constraint expression input by the user is parsed to obtain the table and column on which the constraint is specified. During the data flow analysis discussed regarding , above, the vertical tool  looks for INSERT or UPDATE statements on the object referenced in the input constraint expression. This is done by extracting the SQL statement for example, using the Extract SQL service , and parsing it to extract the table\/column information as well as statement type (INSERT\/UPDATE) (\u201cIdentify SQL Properties\u201d service ). SAT  also captures the association of the parameter name to the column in the INSERT\/UPDATE statement by analyzing the ADO.NET APIs for passing parameters to SQL (\u201cExtract Parameters\u201d service ). The ability of SAT  to capture the association of the parameter name to the column in the database, enables it to automatically recommend an assertion in the application code that will verify the data integrity constraint specified by the user. SAT  provides the application developer such a recommendation and an assertion in the code for review.","As discussed regarding , the SAT  takes the application binary as input. The user also specifies a database constraint. In the example shown in , the constraint shown is ([Products].[Price]>0).  illustrates a screenshot of a code sample for the example of detecting potential data integrity violation in the application code using integrity checking vertical  introduced regarding . In this example, the function button_insertclick inserts a row to the Products table in a database. The constraint to be enforced by the application is that the Price column of the Products table is greater than 0, i.e. [Products].[Price]>0.",{"@attributes":{"id":"p-0090","num":"0099"},"figref":["FIG. 8","FIG. 7"],"b":["110","802","804","806","808","810","810"]},"Exemplary Implementation","The following discussion describes an exemplary overview a variety of implementations of at least one embodiment of the static analysis framework for database applications. The implementations for applications discussed are merely illustrative, and not limiting. The discussion references elements discussed above regarding previous figures. The implementations discussed relate to operation of SAT  on several real world database applications such as Microsoft\u00ae's Conference Management Toolkit (CMT), SearchTogether, and a security training application (STA).","CMT is a web application sponsored by Microsoft Research that handles workflow for an academic conference (available at http:\/\/msrcmtresearch.microsoft.com\/cmt\/). SearchTogether is a Microsoft\u00ae application that allows multiple users to collaborate on web search (available at http:\/\/research.microsoft.com\/en-us\/um\/redmond\/projects\/searchtogether\/).STA is an internal Microsoft\u00ae security training application developed by the security training group at Microsoft\u00ae to demonstrate SQL injection vulnerability.","For each of the three exemplary applications evaluation of the Workload Extraction vertical  is reported in Table 1, below. The methodology was to compare the workload extracted by SAT  via vertical  with the workload obtained by manual inspection of the application code. The summary of results is shown in Table 1.",{"@attributes":{"id":"p-0094","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},{},"Lines of","Total # SQL","# SQL statements"]},{"entry":[{},"Application","Code","statements","extracted"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CMT","36000+","621","350"]},{"entry":[{},"SearchTogether","1700+","40","35"]},{"entry":[{},"STA","500+","10","10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"The column \u201cTotal # SQL statements\u201d reports the number of that SQL statements manually identified by examining the source code of the application. The column \u201c# SQL statements extracted\u201d refers to the number of statements that were extracted by SAT . Along with the SQL statements SAT  extracted parameter information via Extract Parameter service  as well. Thus, even though actual parameter values are not known at compile time, SAT  is able to extract syntactically valid queries, e.g., it is possible to obtain a query execution plan for such queries. Note, the CMT and SearchTogether applications both mostly use parameterized stored procedures.","In at least one embodiment a select set of ADO.NET APIs are covered, for example, not all SQL strings were extracted by the SAT . In other embodiments, different sets of ADO.NET APIs may be covered. It is to be understood that expansion to a variety of sets of ADO.NET APIs as well as Open Database Connectivity (ODBC) APIs and Java Database Connectivity (JDBC\u2122) APIs is expected to follow similar teachings and is considered within the scope of this document.","Furthermore, in SearchTogether, the SQLCommand object is a member variable of a class in some instances. The object is constructed in one method and referenced in another method. In this situation, the global data flow analysis of the test implementation is not sufficient since the variable (the SQLCommand object) is not passed across the two methods. In another implementation this case would be captured by the SAT tracking an additional state of the SQLCommand object, for example.","The SQL injection detection vertical  of SAT  was also run on the three applications. SAT  detected no SQL injection vulnerabilities in CMT and SearchTogether. In these applications user input is bound to parameters and executed as parameterized SQL. In STA, the security training application, SAT  identified the SQL injection vulnerabilities.  shows a screenshot of SAT  indicating the SQL injection vulnerability in one method. The left hand pane  shows the functions in the binary. In the right hand pane , the SQL Information grid  shows the SQL string and the SQL injection status (UNSAFE in this example). Grid  also shows the actual line number in the code where the user input (leading to this vulnerability) originated and the line number where the SQL statement is executed.","Exemplary Computing Device",{"@attributes":{"id":"p-0099","num":"0108"},"figref":"FIG. 10","b":"1000"},"For example, computing device  can represent one or more of the computing devices , , and computing device server  operating in environment . (And insofar as the computing device  includes conventional computing hardware,  also represents functionality that can be used to implement other computer-related aspects of the environment  shown in , such as equipment of server  and individual computer devices  and , including processing units, databases  ( . . . ), program modules, compiler functionality  and so forth). The computing resources shown in  can be implemented at a single site or distributed over plural sites.","The computing device  in this example includes at least one processing unit  and system memory . Depending on the configuration and type of computing device , the system memory  can be implemented as volatile memory (such as RAM), non-volatile memory (such as ROM, flash memory, etc.), or some combination of the two. The system memory  can include an operating system , one or more program modules , program data , and so forth. In the context of the present subject matter, the program modules  can include (A) the functionality for implementing the SAT  via services  and verticals  of . In at least one embodiment compiler functionality is implemented separately from the SAT Module, and in at least one other embodiment, the compiler is integrated with the SAT module. In general, the program modules  can be implemented as computer-readable instructions, various data structures, and so forth that configure a computer to operate SAT . The computer-readable instructions can be expressed using any programming technology. The instructions can also include markup language content (e.g., XML).","The computing device  can include additional features or functionality. For example, the computing device  can also include additional data storage devices, such as removable storage  (e.g., magnetic disks, magnetic tape, optical disks, static RAM devices, and so forth), and\/or non-removable storage  along with associated media reading\/writing functionality. Removable storage  may include a variety of computer-readable media.","The computing device  can also include various input device(s) , such as a keyboard, a mouse, a voice input device, a touch input device, and so on. The computing device  can also include various output device(s) , such as a display, speakers, printer, and so on. Finally, the computing device  can also include a communication interface  that allows the device  to communicate with other computing devices  over the network  of . The communication interface  can be implemented in any fashion, such as broadband (e.g., T1) interface, a telephone modem interface, a cable modem interface, a DSL-type interface, and so forth. One or more bus structures (not shown) internally couple each of the above-described modules together.","Conclusion","The above-described tools, systems, and methods enable static analysis tools for database applications, such that the SAT can significantly enhance the ability for developers to identify security, correctness and performance problems in database applications during the development phase of an application lifecycle. This description of static analysis tools for database applications presents a framework for database applications using the ADO.NET data access APIs. The SAT framework consists of a core set of static analysis services. We have built verticals such as SQL injection detection, workload extraction and identifying data integrity violations using these services; and performed initial evaluation on real world database applications. These and other techniques described herein may provide significant improvements over the current state of the art, by leveraging data access APIs and database application binaries to provide a set of analysis services via a Static Analysis Tool (SAT). The SAT provides a framework for analyzing database application binaries to automatically identify security, correctness and performance problems in the database application via service tools and vertical tools.","Although the system and method has been described in language specific to structural features and\/or methodological acts, it is to be understood that the system and method defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed tools, system and method."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
