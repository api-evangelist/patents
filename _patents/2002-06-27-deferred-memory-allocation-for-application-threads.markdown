---
title: Deferred memory allocation for application threads
abstract: Various systems and methods are provided that facilitate deferred memory allocation. In one method, an attempt to allocate an amount of memory for an application thread is made. If the attempt was unsuccessful and if the application thread is designated for deferred memory allocation, then the application thread is stored in a holding queue. Once the application thread is stored in the holding queue, periodic attempts are made to reallocate the amount of memory for the application thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07069396&OS=07069396&RS=07069396
owner: Hewlett-Packard Development Company, L.P.
number: 07069396
owner_city: Houston
owner_country: US
publication_date: 20020627
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Currently, various computer systems such as laptops, desktops, workstations, personal digital assistants (PDAs) and other systems may include a number of applications that are executed thereon. Such applications may include, for example, word processors, spreadsheets, calendars, task tracking systems, and other applications. Due to the increasing size of the various applications that may be executed on existing computer systems, it is often the case that there is not enough memory that can be allocated for the execution of various applications\/application threads generated by these applications. This is especially the case given that a user may execute a number of applications on a computer system concurrently. If no additional memory is available when a user attempts to execute a particular application or take other action that requires the allocation of memory, then the computer system may respond by providing a message that memory was unavailable. In such case, the attempted execution is aborted which creates frustration and limits the usefulness of the computer system.","With reference to , shown is a schematic of a computer system  according to an embodiment of the present invention. In this respect, the computer system  includes a processor circuit having a processor  and a memory , both of which are coupled to a local interface . In this respect, the computer system  may be, for example, a general-purpose computer, a personal digital assistant, a laptop, a workstation, or other apparatus with like capability.","Stored in the memory  and executable by the processor  are several software components that include one or more applications , a memory status application programming interface (API) , a number of runtime library functions , and an operating system . The application  may be, for example, word processor programs, spreadsheet programs, browsers, or any other application given that virtually thousands, if not millions, of applications have been created. The memory status API  includes a queue manager  and a holding queue . Stored in the holding queue  is\/are one or more application threads  that are generated by corresponding one or more applications . The operation of the memory status API , the queue manager  and the holding queue  provide for deferred memory allocation as will be discussed. Also, the operating system  includes memory management APIs  that operate to control allocation of the memory .","The memory  is defined herein as both volatile and nonvolatile memory and data storage components. Volatile components are those that do not retain data values upon loss of power. Nonvolatile components are those that retain data upon a loss of power. Thus, the memory  may comprise, for example, random access memory (RAM), read-only memory (ROM), hard disk drives, floppy disks accessed via an associated floppy disk drive, compact discs accessed via a compact disc drive, magnetic tapes accessed via an appropriate tape drive, and\/or other memory components, or a combination of any two or more of these memory components. In addition, the RAM may comprise, for example, static random access memory (SRAM), dynamic random access memory (DRAM), or magnetic random access memory (MRAM) and other such devices. The ROM may comprise, for example, a programmable read-only memory (PROM), an erasable programmable read-only memory (EPROM), an electrically erasable programmable read-only memory (EEPROM), or other like memory device.","In addition, the processor  may represent multiple processors and the memory  may represent multiple memories that operate in parallel. In such a case, the local interface  may be an appropriate network that facilitates communication between any two of the multiple processors, between any processor and any one of the memories, or between any two of the memories etc. The processor  may be electrical, molecular, or optical in nature.","The operating system  is executed to control the allocation and usage of hardware resources in the computer system  such as the memory, processing time and peripheral devices. In this manner, the operating system  serves as the foundation on which applications depend as is generally known by those with ordinary skill in the art. The specific memory allocation functions of the operating system  are performed by the memory management API's  and other portions of the operating system .","Next, a general description of the operation of the computer system  according to an embodiment of the present invention is described. To provide context for the following discussion, assume that one or more of the applications  have been executed by the processor  and are stored in a portion of the memory  such as, for example, random access memory or virtual memory to facilitate the execution thereof. Also assume that the user of the computer system  may wish to execute a further application  in addition to those already executed. As such, the new application  generates a request for memory or application thread  that is applied to the memory status API . Alternatively, rather than execute a further application , a user may employ a feature of a currently executed application  that my require allocation of additional memory.","The application thread  calls the memory status API  to allocate memory. The memory status API  then calls appropriate ones of the runtime library functions  to attempt to allocate memory for the execution of the new application . In one circumstance, a portion of the memory  that is employed to facilitate the execution of the application  may include enough available memory to accommodate the new application thread. As such, the memory management APIs  allocate the needed memory and return a memory pointer to the runtime library functions . The runtime library functions  return the memory pointer to the memory status API  which in turn provides such information to the new or existing application  requesting the allocation of memory. Thereafter, the new application  or additional feature of a currently executed application  is executed using the memory identified by the memory pointer for operation. In such case, the memory status API  simply passes through the memory allocation request to the runtime library functions .","However, in some circumstances, there may not be enough of the needed portion of the memory  to accommodate the application thread . As such, the memory management APIs  return a failure to allocate the memory to the runtime library functions  which, in turn, provide the failure to allocate memory to the memory status API . The memory status API  then determines whether the application thread  has been designated for deferred memory allocation. If the application thread  is so designated, then it can be stored in the holding queue  to await further attempts to reallocate a portion of the memory  to accommodate the new application .","If the application thread  is designated for deferred memory allocation, then the memory status API  places the application thread  in the holding queue . The designation of the application thread  for deferred memory allocation may take any one of multiple forms. For example, in one instance, the application thread  may be designated to be held in the holding queue  for a predetermined period of time. Alternatively, the application thread  may be designated to be held indefinitely until memory is available. Where the application thread  is to be stored in the holding queue  for a predetermined period of time, a storage turnout is associated with the application thread  by the originating application  that indicates a maximum period of time that the application thread  can be stored in the holding queue . If the application thread  is designated for indefinite storage in the holding queue , then the application thread  is held in the holding queue  until memory has been allocated for the execution thereof.","If the application thread  has been designated for temporary storage in the holding queue  by virtue of having a storage timeout associated therewith, then the application thread  will be stored in the holding queue  for the predetermined storage timeout. Upon an expiration of the storage timeout, the application thread  is removed from the holding queue  and a failure to allocate the amount of memory for the application thread  is returned to the respective application .","In addition, it may be the case that an application  designates an application thread  for non-deferred memory allocation. In such case, if the memory status API  receives a failure to allocate the memory for such an application thread  from the runtime library function , then the memory status API  immediately returns the failure to allocate the memory for the application thread  to the respective application  that originated the application thread . Thus, in generating application threads  for required memory allocation, the application  assign a designation to the application thread  as to whether or not deferred memory allocation is to be used. This may done, for example, by setting one or more flags associated with the application thread  that indicate whether deferred memory allocation applies. In addition, in cases where temporary memory allocation is to be used, the applications  assign a storage timeout thereto.","The queue manager  operates to maintain the holding queue . Specifically, the queue manager  operates \u201cin the background\u201d of the memory status API  and attempts to reallocate memory for application threads  that are stored therein. The queue manager  removes application threads  from the holding queue  when memory has been successfully allocated therefor. In addition, the queue manager  tracks the countdown of all storage timeouts associated with any application threads  held in the holding queue  and removes such application threads  from the holding queue  when the storage timeouts have expired. Upon an expiration of a storage timeout, the queue manager  also returns a failure to allocate memory to the appropriate application  for the expired application thread .","With reference then to , shown is an exemplary flow chart of the operation of the memory status API  in processing calls to allocate memory received from applications  for specific application threads  (). Alternatively, the flow chart of  may be viewed as depicting steps of a method implemented in the computer system  () to facilitate deferred memory allocation.","Beginning with box , the memory status API  waits to receive a call to allocate memory from a specific application thread . If such is received, then in box , the memory status API  calls heap manager functions in the runtime library functions  () to allocate the memory. In box , the memory status API  determines whether memory has been successfully allocated for the current application thread . This determination is made, for example, based upon the response returned from the runtime library functions  called by the memory status API . If memory has successfully been allocated, then the memory status API proceeds to box  in which the memory pointer for the allocated memory is returned to the requesting application so that the application thread  may be executed accordingly. Thereafter, the operation of the memory status API  ends.","On the other hand, if memory is not successfully allocated as determined in box , then the memory status API  proceeds to box  in which the memory status API  determines if the application thread  has been designated for deferred memory allocation. This may be done, for example, by examining flags that are associated with the application thread  that provide such an indication. Thereafter, in box , if the application thread  has not been designated for deferred memory allocation then the memory status API  proceeds to box  in which the failure to allocate the memory is returned to the requesting application . Thereafter, the operation of the memory status API  ends.","However, if in box  the application thread  has been designated for deferred memory allocation, then the memory status API  proceeds to box  in which the application thread  is placed in the holding queue . Thereafter, the operation of the memory status API  ends. In this manner, the memory status API  places appropriate application threads  into the holding queue  () to facilitate deferred memory allocation for those application threads  that are so designated.","Turning then to , shown is an exemplary flow chart that provides an example of the operation of the queue manager  according to an embodiment of the present invention. The queue manager  operates continuously in the background of the memory status API  to maintain the holding queue  (). Alternatively, the flow chart of  may be viewed as depicting steps of a method implemented in the computer system  () to maintain the holding queue .","Beginning with box , the queue manager  determines whether the holding queue  is empty. If so, then the queue manager  proceeds to box  in which a time delay is implemented for a predetermined period of time. In one embodiment, this time delay is approximately 10 milliseconds in duration, although any length of time may be used. Thereafter, the queue manager  reverts back to box .","Assuming that the holding queue is not empty in box , then the queue manager  proceeds to box . In box , the top application thread  () in the holding queue  is designated for further processing. Thereafter, in box , the queue manager  calls the heap manager function included in the runtime library functions  () to allocate memory for the designated application thread . Then, in box , the queue manager  determines whether the memory was successfully allocated based upon the return of either a memory pointer or failure to allocate the memory from the runtime library functions . If the memory is successfully allocated in box , then the queue manager  proceeds to box  to return the memory pointer for the allocated memory back to the requesting application  that generated the designated application thread . The queue manager  then proceeds to box  in which the designated application thread  is removed from the holding queue .","Once the application thread  is removed from the holding queue , then the queue manager  proceeds to box  to determine whether the last application thread  has been processed in the holding queue . If the last application thread  listed in the holding queue  has not been processed, then the queue manager  proceeds to box  to designate the next application thread  in the holding queue for processing. Thereafter, the queue manager  reverts back to box . On the other hand, if in box  the last application thread  in the holding queue  has been processed, then the queue manager  reverts back to box .","Referring back to box , if memory has not been successfully allocated for the designated application thread , then the queue manager  proceeds to box  in which it is determined whether the application thread  is to be held in the holding queue  indefinitely. If such is the case, then the queue manager  proceeds to box . This application thread  will remain in the holding queue  until a successful attempt to allocate memory for such application thread  occurs. In order to determine whether or not the application thread  is to be held in the holding queue  indefinitely, the queue manager  may examine appropriate flags or other characteristics of the application thread  itself that provide such information.","Assuming that the application thread  is not to be maintained in the holding queue  indefinitely in box , then the queue manager  proceeds to box  in which it is determined whether a storage timeout associated with the application thread  has expired. If such is the case, then in box  the queue manager  returns a failure to allocate memory for the respective application thread  to the respective application  () from which the application thread  originated. Thereafter, the queue manager  moves to box  in which the designated application thread  is removed from the holding queue .","However, if in box  the storage timeout has not expired, then in box  the queue manager  reduces the time remaining for the designated application thread  by a predetermined interval amount. In this manner, the storage timeout is reduced every time the queue manager  attempts to reallocate memory therefore until a value of zero is achieved, thereby indicating that the storage timeout has expired. Once the storage timeout has been reduced in box , then the queue manager  proceeds to box .","Thus, the queue manager  provides a continuous loop in which repeated attempts to reallocate memory for those application threads  in the holding queue  are made until either a failure to allocate the appropriate memory for the respective application threads  is reported to the originating application  or memory is successfully allocated for the respective allocation threads .","Turning then to , shown is an exemplary flow chart of a portion of an application  denoted application portion that is implemented to designate whether a particular application thread  is to be subject to deferred memory allocation. Alternatively, the flow chart of  may be viewed as depicting steps of a method implemented in the computer system  () to properly designate an application thread  for deferred memory allocation including setting appropriate flags and assigning appropriate storage timeouts thereto.","Beginning in box , the portion of the application portion determines whether an application thread  is to be designated for deferred memory allocation. If so, then in box , the appropriate flags are set in the application thread  that indicate whether or not the application thread  is subject to deferred memory allocation. Thereafter, in box , a storage timeout is associated with the application thread  if the application thread  is to be temporarily stored in the holding queue  (). Then, in box , the application thread  is caused to call the memory status API  () to begin the process of allocating memory. Thereafter, the operation of the application portion ends.","Although the memory status API  and the application portion are embodied in software or code executed by general purpose hardware as discussed above, as an alternative they may also be embodied in dedicated hardware or a combination of software\/general purpose hardware and dedicated hardware. If embodied in dedicated hardware, the memory status API  and the application portion can be implemented as a circuit or state machine that employs any one of or a combination of a number of technologies. These technologies may include, but are not limited to, discrete logic circuits having logic gates for implementing various logic functions upon an application of one or more data signals, application specific integrated circuits having appropriate logic gates, programmable gate arrays (PGA), field programmable gate arrays (FPGA), or other components, etc. Such technologies are generally well known by those skilled in the art and, consequently, are not described in detail herein.","The flow charts of  show the architecture, functionality, and operation of an implementation of the memory status API  and the application portion If embodied in software, each block may represent a module, segment, or portion of code that comprises program instructions to implement the specified logical function(s). The program instructions may be embodied in the form of source code that comprises human-readable statements written in a programming language or machine code that comprises numerical instructions recognizable by a suitable execution system such as a processor in a computer system or other system. The machine code may be converted from the source code, etc. If embodied in hardware, each block may represent a circuit or a number of interconnected circuits to implement the specified logical function(s).","Although the flow charts of  show a specific order of execution, it is understood that the order of execution may differ from that which is depicted. For example, the order of execution of two or more blocks may be scrambled relative to the order shown. Also, two or more blocks shown in succession in  may be executed concurrently or with partial concurrence. In addition, any number of counters, state variables, warning semaphores, or messages might be added to the logical flow described herein, for purposes of enhanced utility, accounting, performance measurement, or providing troubleshooting aids, etc. It is understood that all such variations are within the scope of the present invention.","Also, where the memory status API  and the application portion comprise software or code, they can be embodied in any computer-readable medium for use by or in connection with an instruction execution system such as, for example, a processor in a computer system or other system. In this sense, the logic may comprise, for example, statements including instructions and declarations that can be fetched from the computer-readable medium and executed by the instruction execution system. In the context of the present invention, a \u201ccomputer-readable medium\u201d can be any medium that can contain, store, or maintain the memory status API  and the application portion for use by or in connection with the instruction execution system. The computer readable medium can comprise any one of many physical media such as, for example, electronic, magnetic, optical, electromagnetic, infrared, or semiconductor media. More specific examples of a suitable computer-readable medium would include, but are not limited to, magnetic tapes, magnetic floppy diskettes, magnetic hard drives, or compact discs. Also, the computer-readable medium may be a random access memory (RAM) including, for example, static random access memory (SRAM) and dynamic random access memory (DRAM), or magnetic random access memory (MRAM). In addition, the computer-readable medium may be a read-only memory (ROM), a programmable read-only memory (PROM), an erasable programmable read-only memory (EPROM), an electrically erasable programmable read-only memory (EEPROM), or other type of memory device.","Although the invention is shown and described with respect to certain embodiments, it is obvious that equivalents and modifications will occur to others skilled in the art upon the reading and understanding of the specification. The present invention includes all such equivalents and modifications, and is limited only by the scope of the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The invention can be understood with reference to the following drawings. The components in the drawings are not necessarily to scale. Also, in the drawings, like reference numerals designate corresponding parts throughout the several views.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 4","FIG. 1"]}]},"DETDESC":[{},{}]}
