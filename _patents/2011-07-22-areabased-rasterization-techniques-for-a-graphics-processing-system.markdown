---
title: Area-based rasterization techniques for a graphics processing system
abstract: This disclosure describes area-based rasterization techniques that can improve the performance of a graphics processor. The techniques may include selecting a rasterization mode for a graphics primitive from a set of at least two candidate rasterization modes based on a metric indicative of an area of the graphics primitive. The techniques may further include performing, with fixed function scan conversion hardware of the graphics processor, scan conversion for the graphics primitive when a first candidate rasterization mode is selected as the rasterization mode for the graphics primitive. The techniques may further include performing, with a programmable shader unit of the graphics processor, scan conversion for the graphics primitive when a second candidate rasterization mode is selected as the rasterization mode for the graphics primitive.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09019280&OS=09019280&RS=09019280
owner: QUALCOMM Incorporated
number: 09019280
owner_city: San Diego
owner_country: US
publication_date: 20110722
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure relates to computing devices and, more particularly, to graphics processing techniques for computing devices.","Many computing devices utilize a dedicated graphics processing unit (GPU) to render graphics data for display onto a display device. GPUs typically include a highly-parallel graphics processing pipeline that provides more efficient processing of graphics data than a general purpose central processing unit (CPU). The graphics processing pipeline may include a plurality of processing stages. Each of the processing stages may be a fixed function processing stage or a programmable processing stage. One of the fixed function processing stages commonly found in a graphics processing pipeline is the rasterization stage, which includes circuitry to convert a graphics primitive into a set of pixels corresponding to the graphics primitive. The circuitry in the rasterization stage is typically optimized to process large primitives containing hundreds to thousands of pixels.","This disclosure describes area-based rasterization techniques that can improve the performance of a graphics processor. The graphics processor may include a rasterization mode selector that determines a metric indicative of the area of a graphics primitive to be rendered, e.g., the number of screen pixels covered by a graphics primitive. Based on this metric, the rasterization mode selector may configure the graphics processor to rasterize the primitive according to one of a large primitive rasterization mode or a small primitive rasterization mode. When rasterizing a primitive according to the small primitive rasterization mode, the graphics processor may rasterize small primitives more efficiently than when rasterizing according to the large primitive rasterization mode while still maintaining acceptable quality standards for the rasterization. For example, the small primitive rasterization mode may bypass all or part of the typical fixed function rasterization circuitry used to rasterize large primitives, and instead, use a programmable shader unit to rasterize the small primitives. For large primitives, the small primitive rasterization mode may be less efficient and\/or produce a substantially lower quality of rasterization as compared to the large primitive rasterization mode. Therefore, by selectively applying different rasterization techniques to the primitives based on the area of each primitive, the efficiency of the entire rasterization process may be increased without substantially reducing the quality of the resulting image.","In one example, this disclosure describes a method that includes selecting a rasterization mode for a graphics primitive from a set of at least two candidate rasterization modes based on a metric indicative of an area of the graphics primitive. The set of at least two candidate rasterization modes includes a first candidate rasterization mode and a second candidate rasterization mode. The method further includes performing, with fixed function scan conversion hardware, scan conversion for the graphics primitive when the first candidate rasterization mode is selected as the rasterization mode for the graphics primitive. The method further includes performing, with a programmable shader unit of the graphics processor, scan conversion for the graphics primitive when the second candidate rasterization mode is selected as the rasterization mode for the graphics primitive.","In another example, this disclosure describes a graphics processing device that includes a rasterization mode selector configured to select a rasterization mode for a graphics primitive from a set of at least two candidate rasterization modes based on a metric indicative of an area of the graphics primitive. The set of at least two candidate rasterization modes includes a first candidate rasterization mode and a second candidate rasterization mode. The graphics processing device further includes fixed function scan conversion hardware configured to perform scan conversion for the graphics primitive when the first candidate rasterization mode is selected as the rasterization mode for the graphics primitive. The graphics processing device further includes a programmable shader unit configured to perform scan conversion for the graphics primitive when the second candidate rasterization mode is selected as the rasterization mode for the graphics primitive.","In another example, this disclosure describes an apparatus that includes means for selecting a rasterization mode for a graphics primitive from a set of at least two candidate rasterization modes based on a metric indicative of an area of the graphics primitive. The set of at least two candidate rasterization modes includes a first candidate rasterization mode and a second candidate rasterization mode. The apparatus further includes means for performing scan conversion for the graphics primitive, with fixed function scan conversion hardware, when the first candidate rasterization mode is selected as the rasterization mode for the graphics primitive. The apparatus further includes means for performing scan conversion for the graphics primitive, with a programmable shader unit, when the second candidate rasterization mode is selected as the rasterization mode for the graphics primitive.","In another example, this disclosure describes a computer-readable storage medium that includes instructions that cause one or more processors to select a rasterization mode for a graphics primitive from a set of at least two candidate rasterization modes based on a metric indicative of an area of the graphics primitive. The computer-readable storage medium further includes instructions that cause one or more processors to perform scan conversion for the graphics primitive, with fixed function scan conversion hardware of the graphics processor, when the first candidate rasterization mode is selected as the rasterization mode for the graphics primitive. The computer-readable storage medium further includes instructions that cause one or more processors to perform scan conversion for the graphics primitive, with a programmable shader unit of the graphics processor, when the second candidate rasterization mode is selected as the rasterization mode for the graphics primitive.","The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the disclosure will be apparent from the description and drawings, and from the claims.","This disclosure describes area-based rasterization techniques that can improve the performance of a graphics processor. The graphics processor may include a rasterization mode selector that determines a metric indicative of the area of a graphics primitive to be rendered, e.g., the number of screen pixels covered by a graphics primitive. Based on this metric, the rasterization mode selector may configure the graphics processor to rasterize the primitive according to one of a large primitive rasterization mode or a small primitive rasterization mode. When rasterizing a primitive according to the small primitive rasterization mode, the graphics processor may rasterize small primitives more efficiently than when rasterizing according to the large primitive rasterization mode while still maintaining acceptable quality standards for the rasterization. For example, the small primitive rasterization mode may bypass all or part of the typical fixed function rasterization circuitry used to rasterize large primitives, and instead, use a programmable shader unit to rasterize the small primitives. For large primitives, the small primitive rasterization mode may be less efficient and\/or produce a substantially lower quality of rasterization as compared to the large primitive rasterization mode. Therefore, by selectively applying different rasterization techniques to the primitives based on the area of each primitive, the efficiency of the entire rasterization process may be increased without substantially reducing the quality of the resulting image.","Modern graphics processing units (GPUs) may include fixed function rasterization circuitry that is configured to efficiently rasterize large primitives that include hundreds or thousands of pixels. A primitive may be defined by the vertices of a polygon, such as, e.g., the vertices of a triangle. Rasterization, as used herein, may refer to the process of converting a vertex representation of a graphics primitive into a fragment representation, e.g., a pixel representation of the graphics primitive. For example, a primitive may be rasterized to produce pixels generally within an area defined by the vertices of the primitive. The fixed function rasterization circuitry may include fixed function primitive setup hardware and fixed function scan conversion hardware, which together may be used to determine which fragments or pixels are \u201ccovered\u201d by the primitive to be rasterized. The primitive setup hardware, e.g., triangle setup hardware, may calculate differentials, edge functions, plane equations and\/or other data that is used by the scan conversion hardware to traverse the primitive. The scan conversion hardware may execute a primitive traversal algorithm using the data provided by the primitive setup hardware to determine which fragments are covered by the primitive. The fixed function rasterization circuitry may also include fixed function attribute interpolation hardware, which may determine color values and other attributes values for each fragment based on the attribute values of the vertices of the primitive.","In some instances, a graphics application may need to render a plurality of small primitives. These primitives, typically triangles and\/or quadrilaterals, may be less than or equal to approximately one screen pixel in size. Such primitives may result from, for example, dense polygon meshes created by an artist to capture the fine surface detail in an object to be modeled in a graphics scene. Small primitives may also be the result of tessellating a coarse polygon mesh into small polygons with displacement mapping to show the fine detail in modeled objects. The fixed function rasterization circuitry described above, however, may render these small primitives in an inefficient manner. For example, the primitive setup operations, primitive traversal algorithms and\/or the attribute interpolation algorithms performed for large primitives may not need to be performed for small primitives, or at the very least, more efficient versions for one or more of the algorithms may be able to be performed for such primitives.","A GPU designed in accordance with this disclosure may render small primitives according to a small primitive rasterization mode that is configured to rasterize small primitives in a more efficient manner. For example, for small triangles, e.g., triangles having an area less than or equal to approximately one pixel, the vertices of the triangle and all interior portions of the triangle may map to a single screen pixel. In such examples, a scan conversion algorithm may not need to perform complex edge walking algorithms or triangle traversal algorithms, which are typically performed when rasterizing large triangles, in order to determine which pixels are covered by the triangle. Because the triangle traversal algorithms do not need to be performed for such primitives, all or part of the triangle setup operations typically performed when rasterizing large triangles may also not need to be performed for the triangle. In such examples, the small primitive rasterization mode may effectively bypass one or both of the triangle setup hardware and the scan conversion hardware in the fixed function rasterization circuitry.","In additional examples, complex attribute interpolation calculations may not need to be performed for small triangles, e.g., triangles having areas less than or equal to approximately one screen pixel. Rather, in some instances, one of the vertices of the triangle may be selected, and the attributes for the selected vertex may be used as the attributes for a single fragment associated with the small triangle. In other instances, the attribute values for the fragment may be interpolated based on the attribute values of the triangle vertices, but the interpolation algorithm may be simpler and more efficient than the interpolation algorithm used in the attribute interpolator hardware of the fixed function rasterization circuitry. In each of these examples, the small primitive rasterization mode may effectively bypass the attribute interpolator hardware in the fixed function rasterization circuitry.","Although a graphics processor designed in accordance with this disclosure may bypass one or more components of the fixed function rasterization circuitry when rasterizing according to the small primitive rasterization mode, it still may be desirable, in some cases, to perform one or more rasterization operations in place of those which are performed by the bypassed fixed function components. To that end, a programmable shader unit, e.g., a fragment shader program executing on a fragment shader unit or a unified shader unit, may be used to perform one or more rasterization operations for the graphics processor when rasterizing according to the small primitive rasterization mode. For example, the shader unit may perform scan conversion for the small triangle, e.g., convert a vertex representation of the triangle to a fragment representation of the triangle. For small triangles, the scan conversion performed by the shader unit may be less complex and\/or more efficient than the scan conversion performed by the scan conversion hardware in the fixed function rasterization circuitry. As another example, the shader unit may generate attribute values for the fragments covered by the triangle based on the attribute values associated with the vertices of the triangle. Again, for small triangles, the algorithm executed by the shader unit for the generation of the fragment attribute values may be less complex and\/or more efficient than the attribute interpolation algorithm implemented by the fixed function rasterization circuitry. By performing some or all of the small primitive rasterization techniques in the shader unit, the rasterization efficiency of the graphics processor may be increased without necessarily needing to add additional fixed function hardware dedicated to the performance of such techniques.","As discussed above, the techniques in this disclosure may improve the rasterization efficiency for small primitives by providing a separate small primitive rasterization mode that eliminates one or more of the rasterization steps typically performed by the fixed function rasterization circuitry and\/or replaces one or more steps of the fixed function rasterization circuitry with other steps that are less complex and\/or more efficient for smaller primitives. In addition to improvements in the efficiency of the rasterization algorithm itself, the techniques of this disclosure may provide further efficiency improvements by exploiting the parallelism of the fragment shader. In particular, a fragment shader unit may include a plurality of processing elements each configured to execute a shader program in parallel with the other processing elements. For example, the fragment shader unit may include a parallel single instruction, multiple data (SIMD) pipeline typically found in modern GPUs. By performing one or more rasterization operations for small primitives within a fragment shader unit, the small primitive rasterization mode may be able to use the multiple processing elements to rasterize multiple small fragments in parallel, thereby further improving the rasterization efficiency for small primitives.","The techniques discussed above for the rasterization of small primitives may not produce acceptable results, in terms of perceptual quality, for the rasterization of large primitives. Therefore, a GPU designed in accordance with the techniques of this disclosure may include a rasterization mode selector that selects either a large primitive rasterization mode or a small primitive rasterization mode based on a metric indicative of the area of the graphics primitive to be rasterized. In this manner, the rasterization throughput of the GPU may be improved for small primitives without sacrificing quality standards for the rasterization of large primitives.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["2","2"]},"As illustrated in the example of , computing device  includes a user input interface , a CPU , a device memory , a GPU , a GPU memory , a display interface  and a display . User input interface , CPU , device memory , GPU  and display interface  may communicate with each other using a bus . Bus  may be any of a variety of bus structures, such as a third generation bus (e.g., a HyperTransport bus or an InfiniBand bus), a second generation bus (e.g., an Advanced Graphics Port bus, a Peripheral Component Interconnect (PCI) Express bus, or an Advanced eXentisible Interface (AXI) bus) or another type of bus or device interconnect.","CPU  may comprise a general-purpose or a special-purpose processor that controls operation of computing device . A user may provide input to computing device  to cause CPU  to execute one or more software applications. The software applications that execute on CPU  may include a word processor application, an email application, a spread sheet application, a media player application, a video game application, a graphical user interface application or another end-user program. The user may provide input to computing device  via one or more input devices (not shown) such as a keyboard, a mouse, a microphone, a touch pad or another input device that is coupled to computing device  via user input interface .","CPU  may issue one or more graphics rendering commands or instructions to GPU  to cause GPU  to render a graphics primitive. CPU  may issue graphics rendering commands in accordance with an application programming interface (API), such as, e.g., an Open Graphics Library (OpenGL\u00ae) API, an Open Graphics Library Embedded Systems (OpenGL ES) API, a Direct3D API, an X3D API, a RenderMan API, a WebGL API, or any other public or proprietary standard graphics API.","Device memory  may store device configuration information that may be used at start-up or reset to configure computing device . Device memory may also store data and\/or program modules or instructions that are immediately accessible and\/or presently being operated on by CPU . Device memory  may additionally store information from other components of computing device , such as information output by GPU . Device memory  may include one or more volatile or non-volatile memories or storage devices, such as, for example, random access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), read-only memory (ROM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), Flash memory, a magnetic data media or an optical storage media.","GPU  may be configured to perform graphics operations to render one or more graphics primitives to display . Thus, when one of the software applications executing on CPU  requires graphics processing, CPU  provides the graphics information, e.g., primitive information, to GPU  for rendering to display . GPU  may, in some instances, be built with a parallel structure that provides more efficient processing of complex graphic-related operations than CPU . For example, GPU  may include a plurality of processing elements that are configured to operate on multiple vertices or fragments in a parallel manner. The highly parallel nature of GPU  may, in some instances, allow GPU  to draw two-dimensional (2D) and\/or three-dimensional (3D) graphics scenes onto display  more quickly than drawing the scenes directly to display  with CPU .","As part of the rendering process, GPU  may be configured to rasterize the graphics primitive to produce one or more screen pixels corresponding to the primitive. Rasterization may refer to the conversion of the graphics primitive from a vertex representation of the graphics primitive to a screen pixel representation of the graphics primitive. According to this disclosure, GPU  may be configured to rasterize a primitive in accordance with one of at least two different rasterization modes depending on the area of the primitive to be rasterized. For example, GPU  may be configured to rasterize relatively large primitives according to a large primitive rasterization mode, and to rasterize relatively small primitives according to a small primitive rasterization mode. A rasterization mode selector may classify the primitives as either large primitives or small primitives based on a metric indicative of the area of the primitive to be rasterized, and select a rasterization mode corresponding to the classification. The small primitive rasterization mode may be more efficient at rasterizing small primitives than the large primitive rasterization mode. However, for large primitives, the small primitive rasterization mode may be less efficient than and\/or produce a substantially lower quality of rasterization than the large primitive rasterization mode. Therefore, by selectively rasterizing according to different rasterization modes based on primitive area, the throughput of GPU  may be increased without substantially reducing the quality of the resulting image.","In some examples, GPU may include fixed function scan conversion hardware configured to perform a scan conversion algorithm and a programmable shader unit configured to execute a scan conversion program. In such examples, GPU  may be configured to select a rasterization mode from a set of at least two candidate rasterization modes based on a metric indicative of an area of a graphics primitive. The set of at least two candidate rasterization modes comprising a first candidate rasterization mode and a second candidate rasterization mode. When the first candidate rasterization mode is selected as the rasterization mode for the graphics primitive, GPU  may use the fixed function scan conversion hardware to perform scan conversion for the graphics primitive. When the second candidate rasterization mode is selected as the rasterization mode for the graphics primitive, GPU  may execute the scan conversion program on the programmable shader unit to perform scan conversion for the graphics primitive.","The scan conversion program that is executed on the programmable shader unit may be able to perform scan conversion for small primitives more efficiently that the fixed function scan conversion hardware. For example, the programmable shader unit may be able to scan convert multiple small primitives in parallel. In addition, for some primitives, such as, e.g., primitives that are less than or equal to approximately one screen pixel in size, the scan conversion program may not need to execute one or more of the setup calculations and\/or traversal algorithms, e.g., line walking or edge walking algorithms, that a hardware-based rasterizer may execute for large polygons. In this manner, the area-based rasterization techniques may be able to improve primitive throughput in GPU .","GPU  may, in some instances, be integrated into a motherboard of computing device . In other instances, GPU  may be present on a graphics card that is installed in a port in the motherboard of computing device  or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . GPU  may include one or more processors, such as one or more microprocessors, application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), digital signal processors (DSPs), or other equivalent integrated or discrete logic circuitry.","GPU  may be directly coupled to GPU memory . Thus, GPU  may read data from and write data to GPU memory  without using bus . In other words, GPU  may process data locally using a local storage, instead of off-chip memory. This allows GPU  to operate in a more efficient manner by eliminating the need of GPU  to read and write data via bus , which may experience heavy bus traffic. In some instances, however, GPU  may not include a separate memory, but instead utilize device memory  via bus . GPU memory  may be one or more volatile or non-volatile memory or storage device, such as random access memory (RAM), static RAM (SRAM), dynamic RAM (DRAM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), Flash memory, a magnetic data media or an optical storage media.","CPU  and\/or GPU  may provide image information to display interface  for presentation via display . In the case of 2D and 3D graphics, the image information is typically generated by GPU  for display . Display  may comprise a monitor, a television, a projection device, a liquid crystal display (LCD), a plasma display panel, a light emitting diode (LED) array, a cathode ray tube (CRT) display, electronic paper, a surface-conduction electron-emitted display (SED), a laser television display, a nanocrystal display or another type of display unit. Display  may be integrated within computing device . For instance, display  may be a screen of a mobile telephone. Alternatively, display  may be a stand-alone device coupled to computer device  via a wired or wireless communications link. For instance, display  may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.","When one of the software applications executing on CPU  desires to display a 2D or 3D graphics image on display , CPU  and GPU  may operate together to render the graphics to display . For example, the software application executing on CPU  may execute instructions that define one or more graphics objects within a model space or world space for the application. CPU  may then execute instructions to tessellate the object into a number of graphics primitives. After obtaining the graphics primitives associated with a modeled object, CPU  may issue one or more instructions to GPU  to render the graphics primitives associated with the graphics object. For example, CPU  may issue one or more instructions to GPU  that include vertex specification information, e.g., information that specifies one or more vertices associated with the primitive to be rendered information. The vertex specification information may include vertex positional coordinates and, in some instances, other attributes associated with a vertex, such as, e.g., color coordinates, normal vectors, and texture coordinates. CPU  may also issue one or more instructions to GPU  that include primitive type information, e.g., information that specifies the type of primitive to be rendered and\/or how the vertices are combined to form a primitive.","In some examples, the primitives may be triangle primitives. However, any other type of primitive or combination of primitive types may be used, including, e.g., points, line strips, line loops, separate lines, triangle strips, triangle fans, separate triangles, quadrilateral strips, separate quadrilaterals, or other types of primitives. The term primitive, as used in this disclosure, may be alternatively referred to as a polygon.","After receiving the primitive information, GPU  performs geometry processing on the primitive, rasterizes the primitive to generate a pixel representation of the primitive, performs pixel processing on the primitive, and outputs the final screen pixels to the frame buffer of display . In accordance with this disclosure, prior to rasterizing the primitive, GPU  determines a metric indicative of the area of the primitive to be rasterized, and selects one of at least two different candidate rasterization techniques based on the area metric. GPU  then rasterizes the primitive according to the selected rasterization technique.","The computing device  illustrated in  is merely one example of the components and architecture of a computing device that may implement the area-based rasterization techniques of this disclosure. In other examples, computing device  may contain the same or different components in the same or different architectural configuration.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 2","FIG. 1"],"b":["6","10","6","20","6","20"]},"Software application  may include one or more instructions that define graphics primitives to be rendered by GPU . The one or more instructions may, collectively, define all or part of a graphics scene that includes one or more graphics objects within a model space or world space for the application. Software application  may invoke GPU driver , via graphics API , to issue one or more commands to GPU  for rendering one or more graphics primitives into displayable graphics images. For example, software application  may invoke GPU driver , via graphics API , to provide primitive definitions to GPU . In some instances, the primitive definitions may be provided to GPU  in the form of a list of drawing primitives, e.g., triangles. The primitive definitions may include vertex specifications that specify one or more vertices associated with the primitive to be rendered. The vertex specifications may include positional coordinates for the vertex and, in some instances, other attributes associated with the vertex, such as, e.g., color coordinates, normal vectors, and texture coordinates. The primitive definitions may also include primitive type information, scaling information for the primitive, rotation information for the primitive, and the like. Based on the commands issued by software application  to GPU driver , GPU driver  may formulate one or more commands that specify one or more operations for GPU  to perform in order to render the primitive. When GPU  receives a command from CPU , graphics processing pipeline  decodes the command and configures one or more processing elements within graphics processing pipeline  to perform the operation specified in the command. After performing the specified operations, graphics processing pipeline  outputs the rendered data to a frame buffer associated with a display device.","GPU driver  may be configured to compile one or more shader programs, and to download the compiled shader programs onto one or more programmable shader units contained within GPU . The shader programs may be written in a high level shading language, such as, e.g., the OpenGL Shading Language (GLSL), High Level Shading Language (HLSL), or C for Graphics (Cg) shading language. The compiled shader programs may include one or more instructions that control the operation of a programmable shader unit within GPU . For example, the shader programs may include vertex shader programs that control the execution of a programmable vertex shader unit or a unified shader unit. The vertex shader programs may include instructions that specify one or more per-vertex operations. The shader programs may also include fragment shader programs that control the execution of a programmable fragment shader unit or a unified shader unit. The fragment shader programs may include instructions that specify one or more per-fragment operations. In accordance with this disclosure, the fragment shader programs may also include instructions that selectively perform one or more rasterization operations on a primitive in addition to or in lieu of the rasterization performed by the fixed function rasterizer.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 3","FIG. 2","FIG. 3"],"b":["30","30","30","30","30","30","32","34","36","38","40"]},"Command engine  may receive graphics processing commands and configure the remaining processing stages within command engine  to perform operations for carrying out the graphics processing commands. The graphics processing commands may include, for example, vertex commands and primitive type commands. The vertex commands may specify positional coordinates for one or more vertices and, in some instances, other attribute values associated with each of the vertices, such as, e.g., color coordinates, normal vectors, texture coordinates and fog coordinates. The primitive type commands may include information that specifies the type of primitive to be rendered and\/or how the vertices are combined to form a primitive. The graphics processing commands may also include transformation commands that specify the types of transformations to perform on the vertices. The graphics processing commands may also include lighting commands that specify the type, direction and\/or placement of different lights within a graphics scene. Command engine  may generate primitive information based on graphics processing commands and provide the primitive information to geometry processing block  for further processing. The primitive information may include, for example, vertex positional coordinates, vertex attribute values, primitive type information and\/or transformation specification information.","Geometry processing block  is configured to receive primitive information from command engine  and to generate processed primitive information based on received primitive information. The processed primitive information may include, for example, modified vertex positional coordinates, processed vertex attribute values and\/or the primitive type information. Geometry processing block  provides the processed primitive information to rasterization mode selector  for further processing. The information contained within processed primitive information may specify a vertex representation of a primitive to be rasterized by further stages of graphics processing pipeline .","Geometry processing block  may perform one or more transformations on the vertex position coordinates that are included within the primitive information to produce modified vertex positional coordinates that are included within the processed primitive information. For example, geometry processing block  may apply one or more of a modeling transformation, a viewing transformation, a projection transformation, a ModelView transformation, a ModelViewProjection transformation, a viewport transformation and a depth range scaling transformation to the vertex positional coordinates to generate the modified vertex positional coordinates. In some instances, the vertex positional coordinates may be model space coordinates, and the modified vertex positional coordinates may be screen space coordinates. The screen space coordinates may be obtained after the application of the modeling, viewing, projection and viewport transformations. In some instances, geometry processing block  may also perform per-vertex lighting operations on the vertices to generate modified color coordinates for the vertices. Geometry processing block  may also perform other operations including, e.g., normal transformations, normal normalization operations, view volume clipping, homogenous division and\/or backface culling operations.","Rasterization mode selector  is configured to determine a metric indicative of the area of a graphics primitive to be rasterized. Based on this metric, rasterization mode selector  may select a rasterization mode from a set of at least two different candidate rasterization modes for rasterizing the primitive. For example, rasterization mode selector  may select between a large primitive rasterization mode and a small primitive rasterization mode based on the metric indicative of the area of the graphics primitive.","The metric indicative of the area of the graphics primitive may be indicative of the area of the graphics primitive in terms of screen pixels. In other words, the metric may be indicative of the number of screen pixels covered by the primitive. The metric indicative of the area of the graphics primitive may, in some examples, be equal to and\/or directly represent the area of the graphics primitive in terms of screen pixels. In further examples, the metric indicative of the area may be equal to the double-area of a triangle graphics primitive, i.e., two times the area of the graphics primitive. The metric indicative of the area of the primitive may be referred to alternatively as an area metric.","Rasterization mode selector  may, in some cases, determine the metric indicative of the area of the graphics primitive in terms of screen pixels based on vertex positional coordinates associated with the graphics primitive to be rendered according to known techniques. In additional cases, rasterization mode selector  may generate a bounding box around a triangle primitive and determine the metric based on the area of the bounding box in order to approximate the area of the triangle primitive. In such examples, the metric indicative of the area of the primitive may be a metric indicative of the bounding boxed formed around the primitive. The bounding box may be screen-space axle oriented, or a general quadrilateral.","In some examples, graphics processing pipeline  may rasterize a batch of primitives (e.g., a plurality of primitives) as part of a single rasterization pass. In such examples, rasterization mode selector  may, in some implementations, select a rasterization mode for the batch of graphics primitives from a set of at least two candidate rasterization modes based on a metric indicative of an area of at least one graphics primitive in the batch of graphics primitives. In some cases, the metric indicative of the area of the at least one graphics primitive in the batch of graphics primitives may be a single metric indicative of the area of at least two different graphics primitives in the batch of graphics primitives. In additional cases, the metric indicative of the area of the at least one graphics primitive in the batch of graphics primitives may be a single metric indicative of the area of all of the graphics primitives in the batch of graphics primitives, e.g., a metric indicative of whether the area of all of the graphics primitives in the batch of graphics primitives is less than a threshold and\/or a metric indicative of whether the average area of the graphics primitives is less than a threshold.","In further examples, graphics processing pipeline  may select a rasterization mode for all or a subset of the primitives associated with an object to be rendered from a set of at least two candidate rasterization modes based on a metric indicative of an area of at least one graphics primitive associated with the object to be rendered. The object to be rendered may be a model space object or a world space object defined by a software application executing on the CPU. In some cases, the metric indicative of the area of the at least one graphics primitive associated with the object to be rendered may be a single metric indicative of the area of at least two different graphics primitives associated with the object to be rendered. In additional cases, the metric indicative of the area of the at least one graphics primitive in the batch of graphics primitives may be a single metric indicative of the area of all of the graphics primitives associated with the object to be rendered, e.g., a metric indicative of whether the area of all of the graphics primitives associated with the object to be rendered is less than a threshold and\/or a metric indicative of whether the average area of the graphics primitives is less than a threshold.","Rasterization mode selector  may configure one or more downstream processing stages, e.g., rasterization block  and\/or fragment processing block , to rasterize the graphics primitive according to the selected rasterization mode. For example, if the large primitive rasterization mode is selected, rasterization mode selector  may provide the processed primitive information to rasterization block  for rasterization and instruct fragment processing block  to not perform rasterization operations for the primitive. Otherwise, if the small primitive rasterization mode is selected, rasterization mode selector  may provide the processed primitive information to fragment processing block  for rasterization and instruct fragment processing block  to perform one or more rasterization operations for the primitive. In some cases, rasterization mode selector  may also instruct rasterization block  not to rasterize the primitive if the small primitive rasterization mode is selected, and instruct rasterization block  to rasterize the primitive if the large primitive rasterization mode is selected. Rasterization mode selector  may send instructions to rasterization block  and\/or fragment processing block  via one or more control signals.","In some examples, rasterization mode selector  may select a different rasterization mode for each individual graphics primitive to be rasterized, and graphics processing pipeline  may rasterize each primitive according to the rasterization mode selected for the respective primitive. In other words, in such examples, the rasterization mode may be primitive-specific. For example, graphics processing pipeline  may be capable of rasterizing two or more primitives in a partially or fully parallel manner. In such examples, graphics processing pipeline  may simultaneously rasterize two or more graphics primitives according to the same rasterization mode or according to different rasterization modes. In other examples, rasterization mode selector  may select a single rasterization mode for all primitives within a batch of primitives or for all primitives associated with an object to be rendered. The phrase rasterization mode, as used herein, may be alternatively referred to as a rasterization technique.","Rasterization block  is configured to receive processed primitive information for large primitives and to perform a fixed function rasterization technique on the large primitives. The fixed function rasterization technique may convert the vertex representation of the primitive included within the processed primitive information into a fragment representation of the primitive. Rasterization block  provides fragment information to fragment processing block  for further processing. The fragment information may include fragments representative of the rasterized primitive.","The vertex representation of the primitive may include a set of one or more vertices that define the primitive or polygon to be rendered. Each vertex may correspond to a corner of a polygon where two edges of the polygon meet. In the case of a triangle polygon, the triangle may be defined by three vertices. Each vertex may be associated with a set of attributes, such as, e.g., positional coordinates, color values, a normal vector, texture coordinates. The fragment representation of the primitive may include a set of one or more fragments. Each fragment may correspond to a display screen location and be associated with color and intensity attributes. The fragment representation of the primitive may include the fragments that are covered by the primitive. The fragments that are covered by the primitive may include fragments that represent the vertices of the primitive, fragments that represent the edges of the primitive and fragments that represent the interior of the primitive.","The term fragment is used instead of pixel to distinguish that multiple fragments from different primitives may be associated with a single screen pixel. However, the terms fragment and pixel are frequently used interchangeably by those of skill in the art. As such, the term fragment in this disclosure may also mean a pixel depending on the context, and the term pixel may also refer to one or more fragments associated with the pixel depending on the context. In addition, the fragment representation of the graphics primitive, as used herein, may be alternatively referred to as a pixel representation of the graphics primitive.","Fragment processing block  is configured to receive fragment information and perform additional processing on the fragment information to generate pixel color values and depth information that is provided to a frame buffer. Fragment processing block  may perform per-fragment operations to generate one or more color values for each fragment and, in some instances, a depth value for each fragment. The per-fragment operations may include, for example, color computation, shading, texture mapping, per-pixel lighting, fog processing, blending, a stencil test, a depth test, a scissors test and\/or stippling operations. Fragment processing block  may determine if the fragment is visible, and if so, place the resulting color values for the fragment in a frame buffer. When fragment processing block  receives instructions to operate in the small primitive rasterization mode, fragment processing block  may also be configured to receive processed primitive information from rasterization mode selector  and perform one or more rasterization operations on the processed primitive information to generate fragment information upon which subsequent per-fragment operations may be performed. When fragment processing block  receives instructions to operate in the large primitive rasterization mode, fragment processing block  may, in some instances, disable the performance of the rasterization operations.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 4","FIG. 3","FIG. 4","FIG. 3","FIG. 3","FIG. 3","FIG. 3"],"b":["30","52","44","34","46","48","50","38","52","54","40"]},"Vertex shader  is configured to receive primitive information from command engine , and to generate modified primitive information according to one or more vertex shader programs. The modified primitive information may include, for example, modified vertex positional coordinates, processed vertex attribute values and\/or the primitive type information. Vertex shader  may perform one or more transformations on the vertex positional coordinates included within the primitive information to produce the modified vertex positional coordinates. For example, vertex shader  may apply one or more of a modeling transformation, a viewing transformation, a projection transformation, a ModelView transformation, and a ModelViewProjection transformation to the vertex positional coordinates to generate the modified vertex positional coordinates. In some instances, the vertex positional coordinates may be model space coordinates, and the modified vertex positional coordinates may be clip space coordinates. The clip space coordinates may be obtained after the application of the modeling, viewing and projection transformations. In some instances, vertex shader  may also perform per-vertex lighting operations on the vertices to generate modified color coordinates for the vertices. Vertex shader  may also perform other operations including, e.g., normal transformations and normal normalization operations.","Vertex shader  may be a programmable shader unit that is configured to execute a vertex shader program. The shader program may be a pre-compiled program that is downloaded to the shader unit by the graphics driver prior to the processing of graphics operations. The vertex shader program may control the operation of the shader unit to perform any of the functions described above and\/or additional functions. In general, each vertex processed by vertex shader  may be processed by a corresponding vertex shader thread of the vertex shader program. In some examples, the programmable shader unit may include a plurality of processing units that are configured to operate in parallel, e.g., an SIMD pipeline. In such examples, the processing of each vertex shader thread may occur on a separate processing unit in parallel with the other processing units.","Primitive assembly unit  is configured to receive modified primitive information from vertex shader , and to generate processed primitive information based on the modified primitive information. Primitive assembly unit  may perform one or more operations on the vertices within the modified primitive information to generate the processed primitive information. These operations may include, for example, view volume clipping, user-defined clipping, homogenous division, a viewport transformation and depth range scaling.","Primitive setup block  is configured to receive processed primitive information from rasterization mode selector  and to determine primitive setup data that is used by scan conversion block  for scan conversion of the primitive. For example, primitive setup block  may calculate differentials, edge functions, plane equations and\/or other data that may be used by scan conversion block  to traverse the graphics primitive. Primitive setup block  may provide the primitive setup data to scan conversion block  for further processing. Primitive setup block  may be a fixed function graphics processing stage, which may be alternatively referred to herein as fixed function primitive setup hardware.","Scan conversion block  is configured to determine which fragments are covered by the primitive being rasterized. For example, scan conversion block  may execute a primitive traversal algorithm using the data provided by primitive setup block  to determine the fragments that are covered by the primitive. Executing the primitive traversal algorithm may include, e.g., executing an edge walking algorithm or evaluating edge equations for a plurality of candidate fragment locations. Scan conversion block  may provide the scan conversion information, which may include fragment positional information for the fragments covered by the primitive, to attribute interpolation block  for further processing. Scan conversion block  may be a fixed function graphics processing stage, which may be alternatively referred to herein as fixed function scan conversion hardware.","Attribute interpolation block  is configured to perform an attribute interpolation algorithm for each fragment covered by the primitive. The attribute interpolation algorithm may determine color values and other attributes values for a fragment based on the attribute values of the vertices associated with the primitive. Attribute interpolation block  may provide fragment information to fragment shader , which may include fragment positional information, color values and\/or other attribute values resulting from the interpolation. Attribute interpolation block  may be a fixed function graphics processing stage, which may be alternatively referred to herein as fixed function attribute interpolation hardware.","Although  illustrates a rasterization block  that includes a fixed function attribute interpolation block , in other examples, rasterization block  may not include attribute interpolation block . In such examples, attribute interpolation may be performed by a shader program within fragment shader .","Fragment shader  is configured to receive the fragment information from attribute interpolation block  and to generate modified fragment information according to one or more fragment shader programs. Fragment shader  may modify the color values for each of the pixels by performing one or more shading operations and\/or by performing one or more texture mapping operations. Fragment shader  may generate modified fragment information, which may include modified color values, and provide the modified fragment information to pixel processing block . When fragment shader  receives instructions to operate in the small primitive rasterization mode, fragment shader  may receive processed primitive information from rasterization mode selector  and perform one or more rasterization operations on the processed primitive information to generate fragment information upon which subsequent fragment shader processing may be performed.","Similar to vertex shader , fragment shader  may be a programmable shader unit that is configured to execute a fragment shader program. The shader program may be a pre-compiled program that is downloaded to the shader unit by the graphics driver prior to the processing of graphics operations. The fragment shader program may control the operation of the shader unit to perform any of the functions described above or additional functions. In general, each fragment processed by fragment shader  may be processed by a corresponding fragment shader thread of the fragment shader program. In some examples, the programmable shader unit may include a plurality of processing units that are configured to operate in parallel, e.g., an SIMD pipeline. In such examples, the processing of each fragment shader thread may occur on a separate processing unit in parallel with the other processing units.","In some examples, the programmable shader unit used to implement fragment shader  may be different than the programmable shader unit that is used to implement vertex shader . In further examples, the programmable shader unit used to implement fragment shader  may be the same as the programmable shader unit that is used to implement vertex shader . In such examples, the programmable shader unit may be referred to as a unified shader unit and\/or unified shader subsystem.","Pixel processing block  is configured to receive the modified fragment information from fragment shader  and to perform one or more per-fragment (or per-pixel) operations on the fragments. The per-fragment operations may include, for example, per-pixel lighting, fog processing, blending, a stencil test, a depth test, a scissors test and\/or stippling operations. Pixel processing block  may determine if the fragment is visible, and if so, place the resulting color values for the fragment in a frame buffer associated with the graphics display. The frame buffer may be used by the graphics display to control the color and intensity of pixels on the screen.","Vertex shader  and fragment shader  illustrated in the example graphics processing pipeline  of  may be programmable processing stages while command engine , primitive assembly unit , rasterization mode selector , primitive setup block , scan conversion block , attribute interpolation block  and pixel processing block  may be fixed function stages. It should be noted, however, that in other examples, one or more of the fixed function stages may be programmable stages or vice versa. For example, primitive assembly unit  may be implemented within a programmable geometry shader unit. In general, the programmable processing stages, referred to herein as programmable shader units, execute a set of program instructions within the shader unit. Such shader units may have a program memory that stores the shader program instructions and a state storage medium, e.g., a program counter register that indicates the current instruction in the program memory being executed or the next instruction to be fetched. In contrast, the fixed function processing stages include fixed function hardware that is hard-wired to perform certain functions. Although the fixed function hardware may be configurable, based on control signals for example, to perform different functions, the fixed function hardware typically does not include a program memory that is capable of receiving user-compiled programs.","According to this disclosure, rasterization mode selector  may be configured to select a rasterization mode for a graphics processing pipeline from a set of at least two candidate rasterization modes based on a metric indicative of an area of a graphics primitive. The set of at least two candidate rasterization modes includes a first candidate rasterization mode, e.g., a large primitive rasterization mode, and a second candidate rasterization mode, e.g., a small primitive rasterization mode. Fixed function scan conversion block  may be configured to perform scan conversion for the graphics primitive when the first candidate rasterization mode is selected as the rasterization mode for the graphics primitive. Programmable fragment shader unit  may be configured to perform scan conversion for the graphics primitive when the second candidate rasterization mode is selected as the rasterization mode for the graphics primitive.","In some examples, rasterization mode selector  may compare the metric indicative of the area of the graphics primitive to a threshold and select the large primitive rasterization mode as the rasterization mode for rasterization of the graphics primitive when the metric indicative of the area of the graphics primitive is greater than the threshold, and select the small primitive rasterization mode as the rasterization mode for rasterization of the graphics primitive when the metric indicative of the area of the graphics primitive is not greater than the threshold. In some instances, the threshold may be less than or equal to approximately one screen pixel.","Rasterization mode selector  may configure graphics processing pipeline  to rasterize the graphics primitive in accordance with the selected rasterization mode. In particular, graphics processing pipeline  may configure one or more downstream processing stages, e.g., primitive setup block , scan conversion block , attribute interpolation block  and\/or fragment shader  to rasterize the graphics primitive according to the selected rasterization mode. For example, when the large primitive rasterization mode is selected, rasterization mode selector  may provide processed primitive information to fixed function rasterization block  for rasterization, and instruct fragment shader  not to execute shader program instructions that perform rasterization operations for the primitive. Otherwise, if the small primitive rasterization mode is selected, rasterization mode selector  may provide processed primitive information to fragment processing block  for rasterization and instruct fragment processing block  to execute the shader program instructions that perform the rasterization operations for the primitive.","When the large primitive rasterization mode is selected, rasterization mode selector  may configure graphics processing pipeline  such that primitive setup block  performs primitive setup operations for the graphics primitive, scan conversion block  performs scan conversion operations for the graphics primitive, and attribute interpolation block  performs attribute interpolations for the graphics primitive. When the small primitive rasterization mode is selected, rasterization mode selector  configures graphics processing pipeline  such that the primitive to be rasterized effectively bypasses primitive setup block , scan conversion block  and attribute interpolation block . To compensate for bypassing one or more of the processing stages in fixed function rasterization block , fragment shader  may execute a shader program to perform one or more rasterization operations for the small primitive rasterization mode.","In some examples, fragment shader  may receive vertex information, e.g., modified vertex positional coordinates and attribute values, associated with the graphics primitive to be rendered, and execute a shader program on fragment shader  to perform scan conversion for the graphics primitive based on the vertex information associated with the graphics primitive. The scan conversion performed by fragment shader  may be less complex and\/or more efficient than the scan conversion performed by fixed function scan conversion block . For example, the scan conversion process may not necessarily need to perform a primitive traversal algorithm, such as, e.g., an edge walking algorithm. Moreover, the scan conversion performed by fragment shader  may not, in some instances, need to be preceded by some or all of the primitive setup operations performed by primitive setup block  thereby providing additional improvements in rasterization efficiency.","In additional examples, fragment shader  may receive fragment positional information, e.g., fragment screen coordinates, associated with the graphics primitive to be rendered, and execute a shader program on fragment shader  to generate attribute values, e.g., color values, for the graphics primitive based on the fragment positional information. Again, for small triangles, the algorithm executed by fragment shader  for the generation of the fragment attribute values may be less complex and\/or more efficient than the attribute interpolation algorithm implemented by the fixed function rasterization circuitry.","In some examples, fragment shader  may execute two different shader programs depending on the selected rasterization mode. In such examples, rasterization mode selector  may configure fragment shader  to execute a first shader program when the large primitive rasterization mode is selected, and to execute a second shader program when the small primitive rasterization mode is selected. The second shader program may include one or more rasterization operations and the first shader program may, in some instances, not include the one or more rasterization operations. In further examples, fragment shader  may execute a single shader program that selectively executes different sets of instructions depending on the selected rasterization mode. For example, rasterization mode selector  may configure fragment shader  to execute a first set of shader instructions when the large primitive rasterization mode is selected, and to execute a second set of shader instructions when the small primitive rasterization mode is selected.","The set of shader instructions executed in the small primitive rasterization mode (e.g., the second set of shader instructions) may include instructions for performing one or more operations for rasterizing and\/or processing small primitives. These operations may, in some examples, not be included in the set of shader instructions executed in the large primitive rasterization mode (e.g., the first set of shader instructions). For example, the one or more operations for rasterizing and\/or processing small primitives may include instructions for clipping and\/or scissoring of the polygon against the pixel boundaries, performing back face culling, computing edge-equations, evaluating the per-fragment attributes and texture coordinates and determining the amount of pixel covered by the polygon.","The set of shader instructions executed in the small primitive rasterization mode may also include optimizations to more efficiently evaluate the fragment color and\/or attributes compared to the fixed function rasterization pipeline. For example, the shader program for the small primitive rasterization mode may omit some calculations for rasterizing small primitives that otherwise may be performed by the fixed function rasterization block  in order to improve performance and\/or throughput. The set of shader instructions executed in the small primitive rasterization mode may also evaluate the fragment color and attributes differently compared to the large primitive rasterization mode in order to, for example, enhance image quality or reduce image aliasing. In additional examples, if a polygon normal is facing away from the light source, the set of shader instructions executed in the small primitive rasterization mode may omit lighting computations for the polygon depending on the lighting model used. If a polygon area is small (e.g., small in the z-direction), interpolation may not need to perform perspective correction, or anisotropic texture filtering if enabled.","In some examples, graphics processing pipeline  may include a primitive buffer (not shown) that stores a plurality of primitives. For small primitives, rasterization mode selector  may place the primitives in the primitive buffer prior to forwarding the primitives to fragment shader . After a threshold amount of graphics primitives are stored in the primitive buffer, the primitive buffer may forward the primitives to fragment shader  for the performance of one or more rasterization operations, e.g., primitive setup operations. The primitive buffer may be used to allow a plurality of primitives to be sent in parallel to fragment shader  as fragment shader  may, in some examples, require a plurality of primitives (e.g., 8, 16, 32, 64, etc. primitives) to be processed in parallel in a single shader core. For example, fragment shader  may perform primitive setup for a plurality of primitives in parallel during a single processing cycle. The number of primitives processed in parallel by fragment shader  may, in some examples, correspond to the number of shader ALUs that are running in parallel on a single shader core.","In further examples, graphics processing pipeline  may perform bin rendering or tile rendering, e.g., render an image in small pieces or tiles. For example, rasterization mode selector  may perform a binning pass where rasterization mode selector  determines which tiles each primitive contributes to or overlaps, and assign the primitive to one or more tile-specific bins based on the determination. During the binning pass, rasterization mode selector  may determine, calculate and\/or compute an area metric associated with each primitive and store the area metric along with the primitive information in a buffer associated with the bin. Rasterization mode selector  may then select a rasterization mode for a set of primitives within a particular bin based on the area metrics associated with the triangles in the bin. For example, rasterization mode selector  may send the set of primitives to fragment shader  if the large rasterization mode is selected for the set of primitives or send the set of primitives to fixed function rasterization block  if the small rasterization mode is selected for the set of primitives.","The rasterization operations performed by the shader program executing in fragment shader  may be more efficient for small primitives than the rasterization performed by the processing stages within fixed function rasterization block . Due to the small size of the primitives, such primitives may not need the full extent of the fixed function hardware rasterization algorithms implemented by rasterization block  in order to produce a rasterized primitive of acceptable quality. Therefore, the small primitive rasterization techniques described in this disclosure may increase the rasterization efficiency for small primitives without necessarily producing any decrease in perceptual quality of the resulting rasterized primitives. In addition, fragment shader  may have a highly-parallel architecture that can be exploited for rasterizing multiple small primitives in parallel providing further efficiency improvements with respect to small primitive rasterization.","The rasterization operations performed by the shader program executing in fragment shader  may not produce acceptable results, in terms of quality, for the rasterization of large primitives. Therefore, rasterization mode selector  may utilize the fixed function rasterization block  processing stages to perform the rendering for large primitives. Therefore, by selectively switching between different rasterization modes based on the area of each primitive to be rendered, the efficiency of the entire rasterization process may be increased without substantially reducing the quality of the resulting image.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 5","FIG. 3","FIG. 5","FIG. 4","FIGS. 4 and 5"],"b":["30","30","30","56","56"]},"When the second candidate rasterization mode is selected as the rasterization mode for the graphics primitive, small primitive processing unit  may receive processed primitive information from rasterization mode selector , and perform primitive processing on the graphics primitive to generate polygon information for the primitive. Small primitive processing unit  may be a fixed function processing stage, referred to herein as a fixed function primitive processing unit, that performs one or more small primitive processing algorithms to generate data that is in a more suitable form for being operated on by fragment shader . In examples where small primitive processing unit  is used, fragment shader  may execute a shader program on the programmable shader unit to perform scan conversion for the graphics primitive based on the polygon information.","Small primitive processing unit  may include fixed function hardware to perform clipping or scissoring of the polygon against the pixel boundaries, to perform back face culling, compute edge-equations, to evaluate the per-fragment attributes and texture coordinates and\/or to determine the amount of pixels covered by the polygon. Small primitive processing unit  may also include functionality to perform primitive setup operations, to calculate differentials, edge functions, plane equations and\/or other data that is used by fragment shader  for rasterization of the primitive. Small primitive processing unit  may also include functionality to determine color values and other attributes values in preparation for rasterization of the primitive by the fragment shader . Performing one or more rasterization operations in the dedicated hardware of small primitive processing unit  may free up resources in fragment shader  from performing operations that would otherwise be a performance bottleneck for fragment shader .","In some examples, fragment shader  may utilize small primitive processing unit  to assist in the performance of small primitive rasterization and\/or processing operations. For example, fragment shader  may send one or more operations in a fragment shader program to small primitive processing unit  to be performed by small primitive processing unit  while fragment shader  performs other operations in the small primitive fragment shader program.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIGS. 3-5","FIGS. 3-5","FIGS. 4 and 5","FIGS. 4 and 5"],"b":["52","52","52","52"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 6","b":["36","60","30","48","30","62","30","52","48","64"]},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 7","b":["36","66","36","68"]},"If the metric is greater than the threshold, rasterization mode selector  selects the large primitive rasterization mode as the rasterization mode for rasterization of the primitive (). When rasterizing according to the large primitive rasterization mode, graphics processing pipeline  performs primitive setup using fixed function primitive setup hardware  (). Graphics processing pipeline  performs scan conversion using fixed function scan conversion hardware  (). Graphics processing pipeline  generates attribute values using fixed function attribute interpolation hardware  (). In some examples, instead of performing attribute interpolation with fixed function attribute interpolation hardware , fragment shader  may be used to perform attribute interpolation.","If the metric is not greater than the threshold, rasterization mode selector  selects the small primitive rasterization mode as the rasterization mode for rasterization of the primitive (). When rasterizing according to the small primitive rasterization mode, graphics processing pipeline  optionally performs primitive processing using small primitive processing unit  (). Graphics processing pipeline  performs scan conversion using programmable fragment shader unit  (). Graphics processing pipeline  optionally generates attribute values for the fragments using programmable fragment shader unit  ().","The techniques described in this disclosure may be implemented, at least in part, in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over, as one or more instructions or code, a computer-readable medium and executed by a hardware-based processing unit. Computer-readable media may include computer-readable storage media, which corresponds to a tangible medium such as data storage media, or communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, computer-readable media generally may correspond to (1) tangible computer-readable storage media which is non-transitory or (2) a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and\/or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer-readable medium.","By way of example, and not limitation, such computer-readable storage media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if instructions are transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. It should be understood, however, that computer-readable storage media and data storage media do not include connections, carrier waves, signals, or other transient media, but are instead directed to non-transient, tangible storage media. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc, where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.","Instructions may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable logic arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the term \u201cprocessor,\u201d as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and\/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.","The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and\/or firmware.","Various aspects and examples have been described. However, modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIGS. 4 and 5","FIG. 3"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 6 and 7"}]},"DETDESC":[{},{}]}
