---
title: Thread execution analyzer
abstract: A thread execution analyzer analyzes blocking events of threads in a program using execution data and callstacks collected at the blocking events. The thread execution analyzer attempts to identify an application programming interface (API) responsible for each blocking event and provides blocking analysis information to a user. The blocking analysis information may be used by a developer of the program to understand the causes of blocking events that occur for threads of the program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08418148&OS=08418148&RS=08418148
owner: Microsoft Corporation
number: 08418148
owner_city: Redmond
owner_country: US
publication_date: 20090227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Computer programs may be written to allow different portions (e.g., threads) of the program to be executed in parallel. One challenge of parallel programming involves understanding the sources of program execution inefficiencies. When a parallel program is written using multiple processes or threads of execution, it may be difficult to measure the impact of the processes on one another. In addition, it may be difficult to determine the root causes and total duration of delays and relate the delays to the underlying program being studied.","This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","A thread execution analyzer analyzes blocking events of threads in a program using execution data and callstacks collected at the blocking events. The thread execution analyzer attempts to identify an application programming interface (API) responsible for each blocking event and provides blocking analysis information to a user. The blocking analysis information may be used by a developer of the program to understand the causes of blocking events that occur for threads of the program.","In the following Detailed Description, reference is made to the accompanying drawings, which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention may be practiced. In this regard, directional terminology, such as \u201ctop,\u201d \u201cbottom,\u201d \u201cfront,\u201d \u201cback,\u201d \u201cleading,\u201d \u201ctrailing,\u201d etc., is used with reference to the orientation of the Figure(s) being described. Because components of embodiments can be positioned in a number of different orientations, the directional terminology is used for purposes of illustration and is in no way limiting. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims.","It is to be understood that the features of the various exemplary embodiments described herein may be combined with each other, unless specifically noted otherwise.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1","FIG. 7"],"b":["12","10","10","100","10","14","12","16"]},"Thread execution analyzer  is executed by the computer system to analyze the execution of threads ()-(M) in program , where M is an integer that is greater than or equal to one. Program  includes subsets of instructions that are configured into one or more threads . Each thread  forms a sequence of instructions that is configured to perform one or more functions of program  when executed. Threads  may be executed sequentially or concurrently in the computer system during the execution of program . For example, threads  may be executed sequentially in a computer system with a single processing resource (e.g., a single processor with a single execution core) and may be executed concurrently in a computer system with multiple processing resources (e.g., multiple execution cores in a single processor or multiple processors each with one or more execution cores). Threads  may interact with one another to exchange data and\/or to synchronize.","At any given point in the execution of threads ()-(M), corresponding callstacks ()-(M) may be collected. Each callstack  stores a collection of instruction return addresses and is described in additional detail with reference to  below. Thread execution analyzer  uses callstacks  as a diagnostic tool to understand the hierarchy of program instructions traversed by threads  through function calls and report the root cause of thread blocking events when able. Each callstack  starts with a starting function and terminates with a return address from the last function call that was made in one embodiment.","Thread execution analyzer  interacts with kernel  to cause execution data  corresponding to program  to be stored each time a context switch (i.e., a kernel scheduling event) occurs with a thread . As used herein, a context switch is an operation where kernel  interacts with a thread  to pause execution (i.e., block) or resume execution (i.e., unblock). Kernel  schedules threads  for execution on processing resources of the computer system. In response to a thread  becoming blocked during execution, kernel  may perform a context switch to pause the execution of the blocked thread  and begin execution of another new or unblocked thread . After the blocked thread  becomes unblocked, kernel  causes the execution of the thread  to be resumed by rescheduling the thread  on an available processing resource. Kernel  may also preempt (i.e., block) an executing thread  to allow another thread  to execute. Kernel  stores information that describes each context switch in execution data  as described in additional detail below.","Thread execution analyzer  accesses execution data  to identify when each thread ()-(M) blocked and unblocked during execution. Thread execution analyzer  uses an analysis of corresponding callstacks ()-(M) collected at context switches and stored in execution data  to correlate blocking events with classes of blocking causes. Using the callstacks  in execution data , thread execution analyzer  may identify application programming interfaces (APIs) that cause threads  to block using a set of known blocking APIs and blocking classes  included with or otherwise accessible to thread execution analyzer . Thread execution analyzer  assigns a blocking class associated with a blocking API to the blocking event. If thread execution analyzer  is unable to identify an API that caused a thread  to block, then thread execution analyzer  may assign a generic blocking class provided by kernel  to the blocking event. Thread execution analyzer  generates a blocking analysis output  to provide the results of the analysis to a developer or other user of program  in graphical and\/or report formats. Accordingly, thread execution analyzer  may be used as a development tool that allows a developer or other user of program  to understand the causes of blocking events that occur for threads .","Kernel  manages the processing and other resources of the computer system or systems and provides a set of functions that allow thread execution analyzer , program , and other programs and processes in the computer system (not shown) to access and use the resources. Depending on the type and\/or configuration of the computer system that generates runtime environment , kernel  may include firmware, an operating system (OS), a hypervisor, or another suitable execution platform for the computer system.","In one embodiment, thread execution analyzer  may be included as part of an integrated development environment (IDE) . IDE  is executable by the computer system to provide tools for software development. The tools may include a source code editor, a source code analyzer, a compiler and\/or interpreter, a debugger, a profiler, a version controller, a class browser, and\/or an object inspector. The tools may also include tools to automate the building a complete program from libraries and other components and\/or tools to help create a graphical user interface. IDE  may support one or more programming languages and may be used by a developer to write, execute, debug, and analyze program . In other embodiments, thread execution analyzer  may be separate and independent from IDE .",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 2","FIG. 1"],"b":["24","12","12","14","18"]},"In , kernel  is configured to capture execution data  for program  as indicated in a block . In one embodiment, thread execution analyzer  registers with kernel  to configure kernel  to generate execution data  at each context switch that occurs with threads . In other embodiments, a user or IDE  may configure kernel  or kernel  may be configured automatically or by default to capture execution data .","Thread execution analyzer  may configure kernel  to begin generating execution data  anytime before or during the execution of program . Thread execution analyzer  may also configure kernel  to stop generating execution data  prior to the completion of program . Accordingly, kernel  may capture execution data  for the entire execution of program  or for selected portions of the execution of program . The execution of program  may be started by a user, thread execution analyzer , or IDE .","Each time that kernel  performs a context switch as indicated in a block , kernel  stores context switch data into execution data  as indicated in a block . Kernel  may continue to store execution data  at each context switch until otherwise configured by thread execution analyzer .",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 3","FIG. 3"],"b":["42","14","42","42","16","20","42","20","14","42","42","16","20","42","20","14","42","42","20","14","42","20","42","42","22","20","42","22","42","44","46","1","46","20"]},"Thread execution analyzer  may begin analyzing program  or a portion thereof in response to detecting that program  or the portion thereof has finished executing. Thread execution analyzer  may automatically detect that all or a portion of program  has finished executing, may be notified by kernel  and\/or IDE  that all or a portion of program  has finished executing, or may be executed by a user to analyze execution data  after all or a portion of program  has finished executing.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 4","FIG. 4","FIG. 1","FIG. 4"],"b":["20","12","16"]},"In , thread execution analyzer  accesses execution data  that includes context switch data  with corresponding callstacks F for each context switch recorded by kernel  as indicated in a block . Thread execution analyzer  identifies context switches involving program  using switched in process ID A and switched out process ID C in each set of context switch data  as indicated in a block . For each context switch involving program , thread execution analyzer  accesses and analyzes corresponding context switch data  in execution data  as indicated in a block . Thread execution analyzer  identifies the threads  involved in the context switch using thread IDs B and D and notes the time G of the context switch for each thread .","Thread execution analyzer  accesses the callstacks  in thread callstacks F to attempt to identify an API that caused the switched out thread  to block as indicated in a block . Thread execution analyzer  analyzes callstacks  by attempting to match stack frames (i.e., return addresses ), after symbol resolution, to the set of known blocking API signatures and blocking classes  that are used to identify the class or classes of blocking events encountered by the switched out thread . Using the state E and the thread callstacks F, thread execution analyzer  matches the blocking event associated with the context switch to either a blocking class associated with the blocking API where a match to a known blocking API is found or a reason provided by kernel  (i.e., the state E).","Thread execution analyzer  takes each frame in the callstack  and performs symbol resolution to attempt to translate the binary return addresses into the module (e.g., dynamic linked library) name, the file name, the function name, and, in some embodiments, the line number in program  of the blocking API. Thread execution analyzer  attempts to match each symbol resolved stack frame in the callstack  to a signature in known blocking API signatures and blocking classes . Each signature in known blocking API signatures  represents an API that can result in blocking (e.g., file I\/O, synchronization, processing kernel messages, and page faults, etc.) of a thread  and may include the file name and the function name in one embodiment. Each signature is also associated with a blocking class that is stored in known blocking API signatures and blocking classes  along with the signature. A user may add known blocking API signatures and classes to the set of known blocking API signatures and blocking classes .","For each symbol resolved stack frame that matches a known blocking API signature, thread execution analyzer  assigns the blocking class associated with the blocking API to the blocking event of the thread  and stores the blocking class with the blocking event in blocking analysis output  as indicated in a block . If no match to a known blocking API is found, thread execution analyzer  stores the reason provided by kernel  (i.e., the state E) with the blocking event in blocking analysis output  as indicated in a block .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 5","FIG. 5"],"b":["26","12","62","1","62","20","1","20","16","62","64","20","20","62","66","14","42","64","62","68","22","16","22","22","22","16"]},"Thread execution analyzer  continues analyzing context switches using execution data  until all context switches for program  have been analyzed. After all context switches have been analyzed, thread execution analyzer  provides blocking analysis output  to a user as indicated in a block . Thread execution analyzer  may provide blocking analysis output  to a user in any suitable format that includes any suitable combination of graphical and\/or textual information. An embodiment that provides blocking analysis output  to a user in a visual representation  will now be described with reference to .","As shown in , thread execution analyzer  provides graphical timelines ()-(M) for respective threads ()-(M). Thread execution analyzer  derives each timeline  from the corresponding thread execution analysis . Each timeline  depicts periods of execution  (unshaded in ) and periods of blocking  (shaded in ) in the chronological order encountered by threads . The different shades of the periods of blocking  correspond to different reasons for the blocking of the threads . The different shades may represent different colors or other visual differences in visual representation  to highlight the different blocking reasons. Timelines  may be adjusted by a user to show the entire period of execution of program  or one or more selected periods of execution of program .","Thread execution analyzer  also provides a tool tip  in response to an input from a user. The input may be positioning a selector (e.g., a mouse pointer)  in proximity to a period of blocking  or selecting the period of blocking  with a mouse or keyboard. Tool tip  displays details of the blocking event including the class of blocking event, the blocking API, callstack information, and a duration of the period of blocking . The callstack information explains what program  was executing so that a user can open the file that includes program  and examine the details of the behavior of program  that resulted in the blocking event.","In addition, thread execution analyzer  provides aggregate time graphs ()-(M) for respective threads ()-(M). Each graph  indicates the total amount of execution time and blocking time in each of the blocking classes. A legend  describes the different shades of the periods of execution and blocking. The different shades may represent different colors or other visual differences in visual format  to highlight the amount of execution time and blocking time for each blocking reason. Graphs  may be adjusted by a user to show execution and blocking times for the entire period of execution of program  or one or more selected periods of execution of program . Graphs  may also be adjusted by a user to show execution and blocking times for all threads ()-(M) of program  or one or more selected threads ()-(M) of program . Thread execution analyzer  adjusts the display of graphs  in response to user inputs that indicate the execution and blocking times and\/or threads to be displayed.","Thread execution analyzer  further provides a report , collated by callstacks , that lists the blocking APIs, the number of instances that each blocking API caused a blocking event, a total amount of time that each API caused blocks, and the blocking class for each blocking API. Report  may be adjusted by a user to cover the entire period of execution of program  or one or more selected periods of execution of program . Report  may be adjusted by a user to show all threads ()-(M) of program  or one or more selected threads ()-(M) of program . Thread execution analyzer  adjusts the display of report  in response to user inputs that indicate the period or periods of execution and\/or threads to be displayed.","With the above embodiments, thread execution analyzer  relies on context switch and callstack information to identify and analyze blocking events. By doing so, thread execution analyzer  may provide a user with information that identifies the source of inefficiencies in program  and allows the user to reduce or eliminate the inefficiencies.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 7","b":["100","12"]},"Computer system  includes one or more processor packages , a memory system , zero or more input\/output devices , zero or more display devices , zero or more peripheral devices , and zero or more network devices . Processor packages , memory system , input\/output devices , display devices , peripheral devices , and network devices  communicate using a set of interconnections  that includes any suitable type, number, and configuration of controllers, buses, interfaces, and\/or other wired or wireless connections.","Computer system  represents any suitable processing device configured for a general purpose or a specific purpose. Examples of computer system  include a server, a personal computer, a laptop computer, a tablet computer, a personal digital assistant (PDA), a mobile telephone, and an audio\/video device. The components of computer system  (i.e., processor packages , memory system , input\/output devices , display devices , peripheral devices , network devices , and interconnections ) may be contained in a common housing (not shown) or in any suitable number of separate housings (not shown).","Processor packages  each include one or more execution cores. Each execution core is configured to access and execute instructions stored in memory system . The instructions may include a basic input output system (BIOS) or firmware (not shown), thread execution analyzer , kernel , program , and IDE . Each execution core may execute the instructions in conjunction with or in response to information received from input\/output devices , display devices , peripheral devices , and\/or network devices .","Computer system  boots and executes kernel . kernel  includes instructions executable by execution cores to manage the components of computer system  and provide a set of functions that allow programs, including thread execution analyzer , program , and IDE , to access and use the components. kernel  and any additional runtime libraries generate a runtime environment (e.g., runtime environment  shown in ) to allow thread execution analyzer , program , and IDE  to be executed. In one embodiment, kernel  is the Windows operating system. In other embodiments, kernel  is another operating system suitable for use with computer system .","Memory system  includes any suitable type, number, and configuration of volatile or non-volatile storage devices configured to store instructions and data. The storage devices of memory system  represent computer readable storage media that store computer-executable instructions including those shown in . The instructions are executable by computer system  to perform the functions and methods described herein. Memory system  stores instructions and data received from processor packages , input\/output devices , display devices , peripheral devices , and network devices  including execution data  and blocking analysis output . Memory system  provides stored instructions and data to processor packages , input\/output devices , display devices , peripheral devices , and network devices . Examples of storage devices in memory system  include hard disk drives, random access memory (RAM), read only memory (ROM), flash memory drives and cards, and magnetic and optical disks.","Input\/output devices  include any suitable type, number, and configuration of input\/output devices configured to input instructions or data from a user to computer system  and output instructions or data from computer system  to the user. One or more input\/output devices  may be configured to allow a user to interact with thread execution analyzer , kernel , program , and\/or IDE . Examples of input\/output devices  include a keyboard, a mouse, a touchpad, a touchscreen, buttons, dials, knobs, and switches.","Display devices  include any suitable type, number, and configuration of display devices configured to output textual and\/or graphical information to a user of computer system . One or more display devices  may be configured to output visual format  (shown in ) to a user. Examples of display devices  include a monitor, a display screen, and a projector.","Peripheral devices  include any suitable type, number, and configuration of peripheral devices configured to operate with one or more other components in computer system  to perform general or specific processing functions.","Network devices  include any suitable type, number, and configuration of network devices configured to allow computer system  to communicate across one or more networks (not shown). Network devices  may be configured to allow execution data  and\/or blocking analysis output  to be transmitted to or received from another computer system (not shown) or storage device (not shown). Network devices  may operate according to any suitable networking protocol and\/or configuration to allow information to be transmitted by computer system  to a network or received by computer system  from a network.","Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that a variety of alternate and\/or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings are included to provide a further understanding of embodiments and are incorporated in and constitute a part of this specification. The drawings illustrate embodiments and together with the description serve to explain principles of embodiments. Other embodiments and many of the intended advantages of embodiments will be readily appreciated as they become better understood by reference to the following detailed description. The elements of the drawings are not necessarily to scale relative to each other. Like reference numerals designate corresponding similar parts.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
