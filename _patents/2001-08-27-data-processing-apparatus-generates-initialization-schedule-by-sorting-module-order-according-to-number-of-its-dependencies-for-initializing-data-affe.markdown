---
title: Data processing apparatus generates initialization schedule by sorting module order according to number of its dependencies for initializing data affecting execution of operational instructions
abstract: A method of initializing application instructions on a processing system. An application () comprises a number of dynamically shared objects or modules. Each of these modules may include data structures () that require initialization. Modules are dependent upon each other, and a module initialization order is identified by automatically registering a module's dependencies in an initialization list () during module loading, processing module dependencies to identify all dependencies, and generating an initialization schedule (). Module initialization () is then performed. Plug-in modules can be loaded and initialized after the application has started, and the plug-in schedule is appended to the initialization schedule. Finalization is performed in reverse order, when the application is closed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06931521&OS=06931521&RS=06931521
owner: Autodesk Canada Inc.
number: 06931521
owner_city: Quebec
owner_country: CA
publication_date: 20010827
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","INTRODUCTION TO THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention relates to initialising a plurality of modules of processing instructions prior to execution of an application running on a computer.","All processing devices, whether they be personal computers, personal digital assistants or embedded processors, suffer from complexity. The speed and capacity of processing and data storage devices has shifted the limits from hardware to application instructions.","The complexity of many applications is such that it is no longer possible to consider a set of application instructions as ever being finished. Instead, the source code for these instructions evolves over time, improving and following changing user requirements over a product lifetime of many years. Even in the short term, application instructions may change from day to day. In order to deal with this constant evolution, and to minimise the problems of managing complexity, it is established good engineering practice for applications to comprise a large number of small sets of instructions or modules. Individual teams of engineers can work on modules separately, and this permits parallel evolution of several aspects of application behaviour. Theoretically, any complex application can be broken down into sufficiently small individual modules so that complexity, at the module level, never becomes a limiting factor. However, as the number of modules increases, the problem of combining them to work together becomes more difficult. In the art, it is this problem which places an upper limit on the complexity of reliable application evolution.","A particular difficulty when combining modules in an application, is module initialisation, which has to occur before the main application processing begins. In order to avoid this problem, engineers have to keep application complexity as low as possible, while still fulfilling the application requirements.","In certain environments, such as complex power generation plants, application size and complexity cannot be avoided, and so it is possible for very significant difficulties to occur, when attempting to provide a reliable and fault free control system. Less critical, but of significance nevertheless to many users of processing systems, is the reliability of applications used continuously and widely in the workplace, such as word processing systems, or even operating systems. Furthermore, Internet and telecommunications systems are significantly complex, and increasing amounts of financial and other valuable data are transferred over them. Functional flaws in this environment are, in effect, security flaws which may be exploited.","It is an object of the present invention to provide an improved method of initialising an application comprising a large number of application modules.","According to an aspect of the invention, there is provided apparatus for processing data, comprising processing means and memory means for storing data and instructions for processing said data. The memory means includes application instructions and data that define an initialisation manager and a plurality of application modules. Each of the application modules includes a registration object for registering dependency of said module upon others of said application modules, to said initialisation manager. Each application module further includes operational instructions defining operations of said module used by other modules; and at least two of said application modules include initialisation instructions for initialising data affecting execution of said operational instructions. The initialisation manager includes instructions for performing the steps of: (a) processing said registered module dependencies to identify a dependency count for each module; (b) generating an initialisation schedule by sorting the module order according to the number of dependencies; and (c) calling said initialisation instructions in the order defined by said initialisation schedule.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1"},"A system for processing image and other data is illustrated in  processing system , such as an Octane\u2122 produced by Silicon Graphics Inc., supplies image signals to a video display unit . Moving image data is stored on a redundant array of inexpensive discs (RAID) . The RAID is configured in such a way as to store a large volume of data, and to supply this data at a high bandwidth, when required, to the processing system . The operator controls the processing environment formed by the processing system , the video monitor  and the RAID , by means of a keyboard , and a stylus-operated graphics tablet . The processing system shown in  is optimal for the purpose of processing image and other high bandwidth data. In such a system, the instructions for controlling the processing system are complex. The invention relates to any computer system where processing instructions are of significant complexity.","Instructions controlling the processing system  may be installed from a physical medium such as a CDROM or DVD disk , or over a network, including the Internet. These instructions enable the processing system  to interpret user commands from the keyboard  and the graphics tablet , such that image data, and other data, may be viewed, edited and processed.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},"User operations of the system shown in  are summarised in FIG. . At step  the user switches on the computer system. At step  application instructions for controlling the processing system  are installed if necessary. These instructions may be installed from a CDROM or DVD , or via a network, possibly the Internet. At step  the user interacts with the processing system  in such a way as to start the application instructions. At step  the user interacts with the application now running on the processing system . These interactions include the loading and saving of files.","Files of various formats may be loaded and saved. Each file format has a specific set of instructions for loading and saving. Where a large number of formats is to be loaded and saved, instructions for all formats are not loaded simultaneously. Instead, instructions for format loading and\/or saving are only loaded when the user initiates an action that explicitly requires them. Instructions of this kind are sometimes referred to as plug-ins, reflecting the fact that a user can obtain such instructions and make them available to the main application according to his or her specific needs.","Plug-ins may provide a broad variety of functionality. In image processing, various types of image filtering, enhancement and modification can be performed by algorithms available as plug-ins. Furthermore, the main application instructions and additional plug-ins need not be written by the same author; they merely need to conform to a standard application programming interface.","At step  the user closes the application, and at step  the processing system  is switched off.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3"},"The processing system  shown in  is detailed in FIG. . The processing system comprises two central processing units  and  operating in parallel. Each of these processors is a MIPS R12000 manufactured by MIPS Technologies Incorporated, of Mountain View, Calif. Each of these processors  and  has a dedicated secondary cache memory  and  that facilitate per-CPU storage of frequently used instructions and data. Each CPU  and  further includes separate primary instruction and data cache memory circuits on the same chip, thereby facilitating a further level of processing improvement. A memory controller  provides a common connection between the processors  and  and a main memory . The main memory  comprises two gigabytes of dynamic RAM.","The memory controller  further facilitates connectivity between the aforementioned components of the processing system  and a high bandwidth non-blocking crossbar switch . The switch makes it possible to provide a direct high capacity connection between any of several attached circuits. These include a graphics card . The graphics card  generally receives instructions from the processors  and  to perform various types of graphical image rendering processes, resulting in images, clips and scenes being rendered in real time on the monitor . A high bandwidth SCSI bridge  provides an interface to the RAID , and also, optionally, to a digital tape device, for use as backup.","A second SCSI bridge  facilitates connection between the crossbar switch  and a DVD\/CDROM drive . The DVD drive provides a convenient way of receiving large quantities of instructions and data, and is typically used to install instructions for the processing system  onto a hard disk drive . Once installed, instructions located on the hard disk drive  may be fetched into main memory  and then executed by the processors  and . An input output (I\/O) bridge  provides an interface for the graphics tablet  and the keyboard , through which the user is able to provide instructions to the processing system .","Application instructions running on the processing system  are complex. Whether the application is a word processor, image editor or a digital film editor, the instructions that define the application's functionality typically run into hundreds of thousands, if not several millions, of individual binary instructions for the processors  and . Definition of these instructions is achieved by the use of a high level language such as C++, which is compiled into binary machine code compatible with the intended target processor. However, the use of a high level language, while reducing the effort required to define instructions, still does not solve the complexity problem entirely. As high level languages have become more sophisticated, this has allowed engineers to create more complex applications. The requirement of organisation still imposes a limit upon the complexity that application instructions can achieve. This complexity is minimised by splitting up an application into a large number of modules.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4"},"A particular difficulty encountered when combining modules in a single application is that of module initialisation. In , an illustration is shown of the relationships between modules that lead to this difficulty. An application  comprises an executable module  and several other modules  to . The modules  to  are dynamically loaded shared objects. Under Unix type operating systems, such as Irix\u2122 and Linux\u2122, dynamically shared objects are usually abbreviated as dso's. They are also known simply as shared objects. Under Windows\u2122 operating systems, dso's are known as dynamically loaded libraries, or dll's. The executable module  defines the starting point of the application instructions , while the other modules  to  provide additional functionality that is invoked via the executable .","Each module  to  includes instructions , in the form of several functions , and data structures . There are two types of data that it is necessary to consider. The first type of data is user data, supplied usually from files on the hard disk , and which is to be created, manipulated and stored by the application. User data includes word processing files, text files, image files and so on. However, from an engineer's perspective a second type of data exists, which has an effect on the behaviour of the application, and the functions  within each module. These types of data are indicated at .","An example of this type of data is a mathematical function which is required to calculate a sine function at high speed. A look up table includes a number of pre-calculated results, thus reducing significantly the time required for the function to execute. Thus a data structure affects a function in a module. In some implementations the data structure is created when the application starts, by invoking an initialisation function prior to the start of the main application. In order for the application to function correctly, it is essential for the sine function to be initialised before the application begins. This is an example where data structures  within modules must be initialised.","A second requirement for initialisation is when hardware components of the processing system  are to be initialised. For example, the graphics card  has the potential to operate in a variety of display modes. The application may require a particular mode to operate. In order to do this, a graphics interface module  can be used to interrogate the graphics card  and determine which of its available modes is suitable for the application. The graphics card is then instructed to operate in the selected mode. Thereafter, many other modules will require information about the selected graphics mode in order to function correctly within the overall context of the application. This is an example of a requirement for hardware initialisation, which also results in data structures being initialised, that represent the behaviour and characteristics of the graphics card so that other modules may function in an appropriate way.","Various types of modules require initialisation, although it is possible that some modules will require none. The situation is made complex by the fact that the order in which modules are initialised is important. For example, if the fast sine function's characteristics are dependent upon the graphics resolution set on the graphics card, it will be necessary for the graphics module to be initialised before the module containing the sine function. In an application comprising ninety or so separate modules, sufficient dependency of this sort exists, that defining the order of initialisation is extremely difficult to achieve. A dependency graph is illustrated at , in which module A is dependent upon modules B and C, module B dependent upon modules D and F and so on. This may be represented as a dependency list, as shown at .","As the application modules undergo daily evolution, through modification and\/or improvement, these dependencies change also. However, this requires the engineers working on an individual module to be aware of the network of dependencies, and therefore of the overall structure of the application. In the art, the order of initialisation of modules is determined manually by an engineer or engineers, who then write instructions to perform initialisation in the appropriate order. This process is sufficiently complex that trial and error may often be used to determine the most reliable initialisation order. This leads to a reduction in reliability, since it is possible that an incorrect initialisation order will only be exposed by a crash that occurs under very rare conditions.","This is how instruction modularity reaches its complexity limit. Above a certain number of modules, the requirement to identify the initialisation order becomes impossible to meet reliably. The reduction in complexity achieved by splitting the application into modules only works for applications below a certain size, or for applications comprising modules that do not have to be initialised in any particular order. Without these restrictions, application quality and reliability are compromised.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5"},"A preferred embodiment of the invention is summarised in , which highlights the step , of , in which the application is started. At step  an operating system running on the processing system  performs loading of all application modules. As a result of this process, each module is registered in a list, along with its dependencies. At step  the dependencies are processed. At step , a question is asked as to whether the module dependencies are valid. This condition is known as a result of the processing carried out in step . If the dependencies are not valid, control is directed to step , at which point the application launch is cancelled. Alternatively, control is directed to step .","At step  an initialisation schedule is generated by sorting the modules in order of the number of their dependencies. In this step, the number of dependencies is higher than that provided by the list of registered modules at step . This increment is the result of dependency processing performed in step . At step  the modules are initialised in the order defined by the initialisation schedule, and at step  the post-initialisation application processing begins.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6"},"As a result of the processing performed by the steps in , the contents of main memory  are as shown in FIG. . The operating system that performed the loading resides in main memory as indicated at . The application is also resident in main memory as indicated at . Application data  includes data loaded by default for the application, possibly including image data, and other data that the application will process, display and or modify. System data  includes data used by the operating system . The operating system is Irix\u2122, available from Silicon Graphics Inc.","The application  comprises around eighty to ninety application modules, including an executable  and an initialisation manager . The initialisation manager  and an example application module  are shown in detail. The initialisation manager includes an initialisation list  and an initialisation schedule . These are generated as a result of the steps shown in FIG. . The application module  includes a registration object , an initialisation function  and a finalisation function . Operational functions  include all the main operations carried out by the module  that are not related to initialisation. These functions ,  and  comprise sets of instructions that are executable on the processors  and . Initialised data  includes data in the module  that affects the operation of its functions . Initialised data has to be initialised by the initialisation function  before the operational functions  can be used. Not all modules necessarily require initialisation, but it is assumed that they do, so as not to restrict the evolution of the application as these types of functions are added freely to modules as required.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7"},"The step  of loading all application modules, initially shown in , is summarised in FIG. . When the application first starts, the initialisation manager  includes an empty initialisation list. When executed, the steps shown in  result in this list being filled.","The actions of the steps shown in  are performed in accordance with known activities of operating system application loading procedures. However, the existence of the registration object  in each module causes these steps, nevertheless, to form a part of the invention. When step  is first encountered, the executable module  is loaded. At step , the first other module referenced inside the executable module is identified. At step  a question is asked as to whether this module is already loaded. If so, control is directed to step . Alternatively, at step , this referenced module is loaded, and the steps of  are executed for that module recursively. At step  a question is asked as to whether another module is referenced inside the present module. If so, control is directed to step , and the next referenced module is loaded as necessary. Alternatively, once all referenced modules within the present module have been considered, control is directed to step .","Within each of the application modules there is a registration object . The loading process automatically executes constructors for all the statically declared objects in each module. This occurs at step , as a result of standard operating system procedures. Each registration object's constructor contains instructions to add the module to the initialisation list, along with its dependencies. This occurs before main application processing begins. As a result of the recursive execution of the steps of , all modules will have registered their existence and their dependencies, and the initialisation list  will have been filled. The order of the initialisation list at this stage is not important.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 8"},"An edited example of the source code for a module containing a registration object is shown in FIG. . The source code is written in C++, but defines the actions of events that occur during the loading of a module which may be implemented in binary processor instructions or any other appropriate instruction medium, and which may be stored on a hard disk, optical disk, or transferred as a stream over a network to facilitate an initialisation process. Furthermore, the example in  is heavily edited to convey the essence of the invention. Proper engineering practice will result in these features being placed in several files, including header files, and a source code file dedicated to initialisation functionality alone, as will be appreciated by those skilled in the art.","In the source code listing, a registration object  is declared at . Because this is declared outside any function or other type of structure, it is static. That is to say, it exists from the time the module is loaded to the time the module is unloaded. At  a constructor for the template class invoked at  is defined. The constructor for a static object is called automatically by the loading process at step . Thus, even before the main application starts, the constructor for each module is called. Any instructions may be placed here, and to implement the invention, a function, addDependency( ) is called. Its argument, contained in brackets, defines an additional dependency for the present module. The constructor shown in this example has three lines of code, each defining a dependency. Thus, as a result of executing these three lines of code, an entry will have been made in the initialisation list equivalent to:\n\nfoo\u2192database, osal, initialize\n\nmeaning that module foo is dependent upon modules database, osal and initialize.\n","For completeness in this example, code for the performinitialize( )  and performFinalize( )  functions is also shown, resulting in compiled functions  and  shown in FIG. .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 9"},"The initialisation list  is illustrated in FIG. . An extract of the dependencies is shown, not including all eighty modules, and naming each module A, B, C and so on, for convenience. The equivalent dependency graph for this small number of modules is shown at . Even this small fragment of twelve modules illustrates the complexity problem. In reality, the relationships are in the region of eighty or ninety modules and potentially, several hundred. A further difficulty may arise in that a cyclic dependency may exist, as shown at . This can be written as:\n\nB\u2192D\u2192W\u2192B\n\nIf such a situation exists it needs to be identified, as it is not possible to correctly initialise an application that includes this kind of configuration.\n",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 10"},"The step  of processing dependencies, shown in , is detailed in FIG. . At step  a square dependency matrix is created. It comprises an array of N by N locations, where N is the number of modules registered in the initialisation list . Each of the locations in the matrix can take the value of TRUE or FALSE. Each row in the matrix defines dependency information for a single module. Thus, the row for module A, has locations set at TRUE or FALSE in each of the columns corresponding to B, C, D and so on. Initially the dependency matrix is all clear. At step  the known dependency information from the initialisation list is used to set the entries in each column accordingly. Additionally, the number of dependencies for each module is recorded.","The dependency information provided by the initialisation list is non-transitive. If module A is dependent upon module B and module B is dependent upon module C, then the fact that module A is ultimately dependent upon module C is not recorded. This type of indirect dependency is known as a transitive dependency. At step  an algorithm known as the Warshall algorithm is used to set locations in the matrix in accordance with transitive dependencies. Cyclic dependencies are also detected. The number of dependencies recorded for each module is increased accordingly. At the end of step , the dependency matrix includes transitive and non-transitive dependencies, and dependency totals for each module that include both types of dependencies. If, as a result of the steps shown in , a cyclic dependency is found, this results in question  in  being answered in the negative.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 11"},"The state of the dependency matrix after the completion of step  in , is illustrated in FIG. . Each row of the dependency matrix  records the non-transitive dependencies defined by the initialisation list  shown in  set of dependency totals  for each module is also shown. The illustration is an example only. In practice the number of rows and columns is much higher.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 12"},"The Warshall procedure applied in step  in  is detailed in FIG. . This algorithm is used in graph theory, where the condition of transitive closure provided by the process can provide information about relationships between sets of connected vertices. At step  a variable N is set to equal the number of registered modules. At step  an outer loop is commenced, indexed by a variable Z. At step  a question is asked as to whether the module whose dependencies are represented by row Z has any dependencies at all. If answered in the negative, control is directed to step . This exclusion of modules from the outer loop can save valuable processing time. At step  a middle loop is initiated, indexed by the variable X. At step  a question is asked as to whether X is equal to Z. If so, there is no need to process this level any further, as it would only consider a situation where the module is dependent upon itself. At step , it is known that X and Z are different, and a question is asked as to whether the module indexed at row X is dependent upon the module indexed at column Z. This condition is indicated by the matrix at the confluence of this row and column being set to a Boolean value of TRUE. The question may be expressed in the form:\n\nX\u2192Z?\n","If this is not true, then there is no need to consider module X in this loop any further, and control is directed to step . If module X is dependent upon module Z, control is directed to step .","At step , an inner loop is set up, indexed by a variable Y. At step  a question is asked as to whether Y is equal to Z. If so, this indicates a consideration as to whether a module is dependent upon itself, which is not considered of interest. In this case, control is directed to step  and another value for Y is taken for the inner loop. Alternatively, if Y  and Z are different, a question is asked as to whether module Z is dependent upon module Y:\n\nZ\u2192Y?\n","If this condition does not exist, control is directed to step , and another value for Y is taken. Alternatively, control is directed to step . At step  two conditions are known, from which a conclusion may be drawn:\n\nX\u2192Z\n\nand Z\u2192Y\n\nso X\u2192Z\u2192Y\n\nand therefore X\u2192Y\n","At step  a transitive dependency has been identified from an analysis of the dependency matrix. In the matrix, the location at row X and column Y is set to a value of TRUE. At step  a question is asked as to whether X is equal to Y, which would indicate a dependency cycle of the form:\n\nX\u2192Z\u2192X\n","If this is the case, a note is made that a dependency cycle has been found, and control is directed to step . Alternatively, if the dependency is non-cyclic, the number of modules that module X is dependent upon is incremented. Thereafter, the inner, middle and outer loops are continued at steps ,  and  respectively.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 13"},"Once the algorithm of  has completed, all transitive and non-transitive dependencies will have been recorded by the dependency matrix , and the total number of dependencies recorded for each module. An example of the type of result that can be expected is shown in , based upon the preceding example shown in FIG. . Here it will be noted that the number of TRUE entries in the matrix has increased, and the dependency counts also have increased for most of the modules.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 14"},"Processing at this stage has now reached step  in , or, if a cycle was found, step . With the number of dependencies, direct and indirect, known for all the modules, it is now possible to sort them into dependency order. At step , this sorting process is performed, resulting in the creation of an initialisation schedule , as illustrated in FIG. . At the top of the list is the module with the least dependencies. Initialisation may proceed in the order defined by the schedule, and this is performed at step  in FIG. .",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 15"},"The initialisation procedure performed at step  is detailed in FIG. . At step  the first module in the initialisation schedule  is selected. At step , the initialisation function , , is called for the selected module. This has the result that the data  in the module, upon which correct module functionality depends, is initialised before other modules attempt to use the operational functions . At step  a question is asked as to whether initialisation is complete. If not, control is directed to step , where the next module in the initialisation schedule  is selected. All the application modules are thereby initialised in the order required by their dependency. Dependency characteristics for each module may vary over time, as new features are added and improved, without causing difficulty in identifying the correct initialisation order for the application.","The application modules may be augmented by additional modules at any time while it is running. Modules may be dynamically loaded in response to specific user requirements. It is even possible that a user may download a module from the Internet and use it with the application without stopping and restarting the application. A typical application of this is in import and export filters for different file formats. In image processing, for example, there are many formats in which image data can be stored, including several varieties of compressed image format, such as JPEG. A comprehensive set of filters for all image formats could take up a significant amount of main memory, and also take some considerable time to load and initialise if they were all considered as application modules. A solution to this difficulty is in loading such modules on demand. For example, when a user first requires to export to a JPEG format file, a module including JPEG compression instructions can be loaded. It then remains in memory, as it is likely that the user, having used this facility once, will want to use it again before the application is shut down.","Modules loaded in this way are sometimes referred to as plugins, as they can implement new functionality for the application simply by the addition of one or two modules, rather than a complete re-installation of the application. Additional use of plug-ins includes image processing algorithms, lens effects, image blur, colour correction and so on. The use of modules, both as standard application modules and in the form of plug-ins that are loaded on demand, is a powerful method of enhancing application functionality, and tailoring it to individual user requirements.","The initialisation framework that has been described can be extended to include all modules loaded at any time during the application's execution. In , at step , the user performs various actions, including actions that require the loading of plug-in modules.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 16"},"The steps that occur when plug-ins are loaded are detailed in FIG. . At step  the user performs an action requiring the use of a plug-in module. For example, the user decides to save a file in the JPEG format. At step , a temporary initialisation manager is instantiated, having an empty initialisation list and schedule. At step  the plug-in module or modules are recursively loaded in accordance with the process described in detail with reference to  new initialisation list is created, containing only those modules that have not been initialised, even when the plug-in module has a dependency upon modules that were loaded as part of the application at step .","At step  new dependencies are processed as previously described with reference to  to . At step  a question is asked as to whether the module dependencies are valid. If so, control is directed to step . If a dependency cycle has been found, control is directed to step , and the plug-in cannot be loaded. An error message is supplied to the user, and, preferably, this information is also supplied back to the vendor of the plug-in for debugging. At step  an initialisation schedule is created, by sorting the modules in order of least dependent, as shown in FIG. . At step  the plug-in modules are initialised, as detailed in FIG. .","At step  the initialisation schedule generated by the newly instantiated initialisation manager is appended to the end of the main initialisation schedule . At step  plug-in processing can begin.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 17"},"The effect of loading plug-ins on the initialisation schedule  is illustrated in FIG. . Each time a new set of modules is loaded, the temporary initialisation schedule created as a result of this process is added to the end of the existing initialisation schedule. This has no effect upon the initialisation of plug-in modules, as their schedules are only added to the main one after their initialisation has been completed. The purpose of recording initialisations in this way is to ensure that finalisation can be performed in a similarly rigorous way.","Finalisation of modules can be as important as initialisation. When an application closes down, various clean-up operations take place. If a function starts behaving incorrectly, because a module that it relied upon has not been closed down correctly, then it is possible for this to cause serious problems. When an application is closed, usually some data is stored to disk. In many cases, incorrect finalisation can cause an application to crash, thus losing this data, and at the very least causing some consternation for the user.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 18"},"The correct order of module finalisation is the reverse of module initialisation. This is the reason for appending all subsequent plug-in initialisations to the main initialisation schedule. Finalisation, performed in step  in , is detailed in FIG. . At step  the last module in the initialisation schedule  is selected. At step  the finalisation function , , is called in the selected module. At step  a question is asked as to whether finalisation is complete. If not, control is directed to step , and the next last module is selected. This sequence repeats until the first module, at the top of the schedule is reached. Thereafter no more finalisation is required and the application closes.","The loading of modules performed at step , when the application is first loaded, builds the initialisation list  automatically as a result of executing the constructor  for an registration object , , in each application module. Steps  to  are not automatic, and must be invoked as the first operation performed by the application when the operating system has completed the loading process.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 19"},"An application written in C++ usually has its starting point defined in a main( ) function. This may typically be found in a file called main.cpp. Key features of the source code in this file are shown in FIG. . The file main.cpp defines a module called main, and this therefore has a registration object and constructor as shown in  for other modules. The feature of relevance in  is shown at . An initialisation object ig is instantiated between pairs of curly braces at  and . At , the ig object is created, calling instructions for its constructor. The constructor contains a call to a function that performs the initialisation steps  to  shown in FIG. . At  the ig object moves out of scope, and it's destructor function is called, thereby invoking instructions for finalisation. Between  and , the main( ) function contains the main application functionality.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 20"},"The constructor for the Initguard class, invoked by the declaration at  in , is detailed in FIG. . Here it can be seen that a function, located in the initialisation manager module , is called. This function performs the functionality of steps  to  shown in FIG. .",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 21"},"An example of code used when loading plug-in modules is shown in  pair of curly braces  and  defines the scope of a re-initialisation object rig. The constructor for this object increments a reference counter and a temporary empty initialisation list and schedule are created as a result of this declaration. It is possible for re-initialisation functionality to be nested, although this is not usually the case. This corresponds to step  in FIG. . Two dlopen( ) functions load the plug-ins \u201cPlugin\u201d and \u201cPlugin\u201d. Loading of these modules results in the temporary initialisation list of rig being filled, in accordance with step  in FIG. . As rig moves out of scope at , its destructor is called. This is shown in FIG. . This calls a function, ReInitManager.inititialize( ), within the initialisation manager module , which has the effect of performing steps  to  shown in FIG. .","The steps summarised by FIG.  and detailed thereafter, and also in , describe events that occur within an initialisation framework. Finalisation is considered part of this framework. The framework exists by virtue of certain data structures being present in the application modules, and any plug-ins that the application requires to use. During the course of application module development, the initialisation manager  remains fixed in its operation. Other modules, of course, may vary, as source code in C++ or other language becomes debugged, modified or improved. The engineers responsible for the development of a particular module must write the initialisation and finalisation functions  and  themselves, as these are entirely dependent upon the intended functionality of the module. However, the declaration  of the initialisation object and the contents of its constructor  may be generated automatically in response to a list of dependencies supplied by an engineer. A text processing utility, such as sed, may be used to automatically generate detailed code, thus leaving the engineers to concentrate on more creative aspects of the module's design."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 7","FIG. 5"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 9","FIG. 6"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 10","FIG. 5"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 12","FIG. 10"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 14","FIG. 6"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 15","b":"5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 16","FIG. 2"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 18","FIG. 2"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 20","b":"5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 22"}]},"DETDESC":[{},{}]}
