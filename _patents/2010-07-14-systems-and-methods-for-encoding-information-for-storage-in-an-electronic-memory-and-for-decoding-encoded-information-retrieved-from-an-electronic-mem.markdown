---
title: Systems and methods for encoding information for storage in an electronic memory and for decoding encoded information retrieved from an electronic memory
abstract: Method and system embodiments of the present invention are directed to encoding information in ways that are compatible with constraints associated with electrical-resistance-based memories and useful in other, similarly constrained applications, and to decoding the encoded information. One embodiment of the present invention encodes k information bits and writes the encoded k information bits to an electronic memory, the method comprising systematically encoding the k information bits to produce a vector codeword, with additional parity bits so that the codeword is resilient to bit-transition errors that may occur during storage of the codeword in, and retrieval of the codeword from, the electronic memory, ensuring that the codeword does not violate a weight constraint, and writing the codeword to the electronic memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08407560&OS=08407560&RS=08407560
owner: Hewlett-Packard Development Company, L.P.
number: 08407560
owner_city: Houston
owner_country: US
publication_date: 20100714
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["STATEMENT OF GOVERNMENT INTEREST","TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION OF THE INVENTION","Electrical-Resistance-Based Memories","Description of Selected Error-Control Encoding Techniques","Embodiments of the Present Invention"],"p":["This invention has been made with Government support. The government has certain rights in the invention.","The present invention is related to error-control coding and electronic memories and, in particular, to methods and systems for encoding information for storage in electronic memories associated with constraints related to the encoded information.","Error-control coding is a well-developed, interdisciplinary field that spans applied mathematics, computer science, and information theory. Error-control coding techniques are used throughout modern computing, communications, and data-storage systems. In general, error-control coding involves supplementing digitally encoded information with additional, redundant information in order to render the encoded information less susceptible to corruption or loss due to various types of transmission errors, errors that arise as the encoded information is passed through various types of physical and logical interfaces, and errors that arise when the information is stored in, and retrieved from, various types of electronic data-storage media.","Recently, a new generation of electrical-resistance-based memories, various types of which include one-dimensional, two-dimensional, and three-dimensional arrays of nanoscale resistors or memristors, have been developed for a variety of data-storage and computational applications. These newly developed memory arrays have various electronic and physical properties and characteristics that constrain the types of data that can be stored within, and retrieved from, the memories. Researchers and developers of these new types of memories therefore are seeking error-control-coding techniques that can accommodate the data constraints associated with electrical-resistance-based memories, and error-control-coding theoreticians and researchers continuously seek new methods and systems for error-control coding applicable to newly encountered and not-yet encountered applications.","Method and system embodiments of the present invention are directed to encoding information in ways that are compatible with constraints associated with electrical-resistance-based memories and useful in other, similarly constrained applications, and to decoding the encoded information. Method and system embodiments of the present invention employ a combination of error-control coding techniques and encoding and decoding techniques based on bitwise complementation operations. The error-control-coding techniques provide systematic redundancy, error detection, and error correction, and the bitwise-complement operations generate encoded information that satisfies the constraints associated with electrical-resistance-based memories and other application domains.","It should be noted, at the onset, the method embodiments of the present invention, discussed below, are necessarily implemented for execution on a computer system and\/or implemented as logic circuits within an electronic device. When executed by a general-purpose computer, the general-purpose computer is transformed into a special-purpose encoding and decoding machine that represents a system embodiment of the present invention. The methods of the present invention cannot be carried out by hand calculation or by mental calculation, because the methods involve very large numbers of arithmetic and logic operations, even when small amounts of information are encoded. Calculation by any means other than an electronic computer or other electronic device would take many orders of magnitude of time in excess of the times needed for preparing data for storage in electronic memories, and would be far too error prone to serve any practical purpose.","In a first subsection, below, electrical-resistance-based memories are described, along with a data constraint associated with certain electrical-resistance-based memories. In a second subsection, certain error-control-coding techniques are described. In a third subsection, certain embodiments of the present invention are discussed.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1","FIG. 1","FIG. 1","FIG. 1"],"b":["102","104","109","103","104","110","114","118","120","122","130","132","130","132"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 2"],"b":["202","204","206","202","208","215","208","209","202"],"sub":["d ","H","L"]},{"@attributes":{"id":"p-0022","num":"0021"},"maths":[{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mn":"1","msub":{"mi":["R","T"]}},"mo":"=","mrow":{"mrow":{"mfrac":[{"mi":"numH","msub":{"mi":["R","H"]}},{"mi":"numL","msub":{"mi":["R","L"]}}],"mo":"+"},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":{"mi":["R","L"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"numH"}},{"msub":{"mi":["R","H"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"numL"}}],"mo":"+"},{"msub":[{"mi":["R","H"]},{"mi":["R","L"]}],"mo":"\u2062"}]}}}}},{"@attributes":{"id":"MATH-US-00001-2","num":"00001.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"i","mo":"=","mrow":{"mfrac":[{"msub":[{"mi":["V","d"]},{"mi":["R","T"]}]},{"mrow":[{"msub":{"mi":["V","d"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msub":{"mi":["R","L"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"numH"}},{"msub":{"mi":["R","H"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"numL"}}],"mo":"+"}}},{"msub":[{"mi":["R","H"]},{"mi":["R","L"]}],"mo":"\u2062"}]}],"mo":"="}}}}],"br":{},"b":["220","222","224","224","226","224"],"figref":"FIG. 2","sub":["0 ","200 "]},"A problem encountered in certain types of resistance-based memory arrays, particularly those with nanoscale components, is that when too many memory elements are in the low-resistance state, the current flow through a column signal line or row signal line that interconnects them may be sufficiently high to damage or destroy the signal line and the memory array containing the signal line, and, even when not sufficiently high to destroy the signal line, may be sufficiently high to induce various unwanted current paths through unselected memory elements. Thus; as also shown in graph  in , a memory array may be constrained to store data that can be represented in the array with no more than a threshold number of memory elements in any row or column in the low-resistance state at any particular point in time. As an example, in graph , the current i represents the highest current that can be safely carried by a column signal line or row signal line, corresponding to 100 memory elements  out of 200 memory elements being in the low-resistance state.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 3","FIG. 3"],"b":["302","304","304","306","306","304"]},"Embodiments of the present invention employ concepts derived from well-known techniques in error-control encoding. An excellent reference for this field is the textbooks \u201cError Control Coding: Fundamentals and Applications,\u201d Lin and Costello, Prentice-Hall, Incorporated, New Jersey, 1983 and \u201cIntroduction to Coding Theory,\u201d Ron M. Roth, Cambridge University Press, 2006. In this subsection, a brief description of the error-detection and error-correction techniques used in error-control coding are described. Additional details can be obtained from the above-referenced textbooks, or from many other textbooks, papers, and journal articles in this field. The current subsection represents a concise description of certain types of error-control encoding techniques.","Error-control encoding techniques systematically introduce supplemental bits or symbols into plain-text messages, or encode plain-text messages using a greater number of bits or symbols than absolutely required, in order to provide information in encoded messages to allow for errors arising in storage or transmission to be detected and, in some cases, corrected. One effect of the supplemental or more-than-absolutely-needed bits or symbols is to increase the distance between valid codewords, when codewords are viewed as vectors in a vector space and the distance between codewords is a metric derived from the vector subtraction of the codewords.","In describing error detection and correction, it is useful to describe the data to be transmitted, stored, and retrieved as one or more messages, where a message \u03bc comprises an ordered sequence of symbols, \u03bc, that are elements of a field F. A message \u03bc can be expressed as:\n\n\u03bc=(\u03bc,\u03bc, . . . \u03bc)\n\nwhere \u03bc\u03b5F.\n\nThe field F is a set that is closed under multiplication and addition, and that includes multiplicative and additive inverses. It is common, in computational error detection and correction, to employ finite fields, GF(p), comprising a subset of integers with size equal to the power m of a prime number p, with the addition and multiplication operators defined as addition and multiplication modulo an irreducible polynomial over GF(p) of degree m. In practice, the binary field GF(2) or a binary extension field GF(2) is commonly employed, and the following discussion assumes that the field GF(2) is employed. Commonly, the original message is encoded into a message c that also comprises an ordered sequence of elements of the field GF(2), expressed as follows:\n\n=()\n\nwhere c\u03b5GF(2).\n","Block encoding techniques encode data in blocks. In this discussion, a block can be viewed as a message \u03bc comprising a fixed number of symbols k that is encoded into a message c comprising an ordered sequence of n symbols. The encoded message c generally contains a greater number of symbols than the original message \u03bc, and therefore n is greater than k. The r extra symbols in the encoded message, where r equals n\u2212k, are used to carry redundant check information to allow for errors that arise during transmission, storage, and retrieval to be detected with an extremely high probability of detection and, in many cases, corrected.","In a linear block code, the 2codewords form a k-dimensional subspace of the vector space of all n-tuples over the field GF(2). The Hamming weight of a codeword is the number of non-zero elements in the codeword, and the Hamming distance between two codewords is the number of elements in which the two codewords differ. For example, consider the following two codewords a and b, assuming elements from the binary field:\n\n","The encoding of data for transmission, storage, and retrieval, and subsequent decoding of the encoded data, can be notationally described as follows, when no errors arise during the transmission, storage, and retrieval of the data:\n\n\u03bc\u2192()\u2192()\u2192\u03bc\n\nwhere c(s) is the encoded message prior to transmission, and c(r) is the initially retrieved or received, message. Thus, an initial message \u03bc is encoded to produce encoded message c(s) which is then transmitted, stored, or transmitted and stored, and is then subsequently retrieved or received as initially received message c(r). When not corrupted, the initially received message c(r) is then decoded to produce the original message \u03bc. As indicated above, when no errors arise, the originally encoded message c(s) is equal to the initially received message c(r) and the initially received message c(r) is straightforwardly decoded, without error correction, to the original message \u03bc.\n","When errors arise during the transmission, storage, or retrieval of an encoded message, message encoding and decoding can be expressed as follows:\n\n\u03bc()\u2192()\u2192()\u2192\u03bc()\n\nThus, as stated above, the final message \u03bc(r) may or may not be equal to the initial message \u03bc(s), depending on the fidelity of the error detection and error correction techniques employed to encode the original message \u03bc(s) and decode or reconstruct the initially received message c(r) to produce the final received message \u03bc(r). Error detection is the process of determining that:\n\n()\u2260()\n\nwhile error correction is a process that reconstructs the initial, encoded message from a corrupted initially received message:\n\n()\u2192()\n","The encoding process is a process by which messages, symbolized as \u03bc, are transformed into encoded messages c. Alternatively, a message \u03bc can be considered to be a word comprising an ordered set of symbols from the alphabet consisting of elements of F, and the encoded messages c can be considered to be a codeword also comprising an ordered set of symbols from the alphabet of elements of F. A word \u03bc can be any ordered combination of k symbols selected from the elements of F, while a codeword c is defined as an ordered sequence of n symbols selected from elements of F via the encoding process:\n\n{\n","Linear block encoding techniques encode words of length k by considering the word \u03bc to be a vector in a k-dimensional vector space, and multiplying the vector \u03bc by a generator matrix, as follows:\n\n\n\nNotationally expanding the symbols in the above equation produces either of the following alternative expressions:\n",{"@attributes":{"id":"p-0034","num":"0035"},"maths":[{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":"c","mn":"0"},{"mi":"c","mn":"1"},{"mi":"c","mrow":{"mi":"n","mo":"-","mn":"1"}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":"\u03bc","mn":"0"},{"mi":"\u03bc","mn":"1"},{"mi":"\u03bc","mrow":{"mi":"k","mo":"-","mn":"1"}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"g","mn":"00"}},{"msub":{"mi":"g","mn":"01"}},{"msub":{"mi":"g","mn":"02"}},{"mi":"\u2026"},{"msub":{"mi":"g","mrow":{"mn":"0","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"\u22ee"},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"\u22f1"},{"mi":"\u22ee"}]},{"mtd":[{"msub":{"mi":"g","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"0"}}},{"msub":{"mi":"g","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"1"}}},{"msub":{"mi":"g","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"2"}}},{"mi":"\u2026"},{"msub":{"mi":"g","mrow":{"mrow":[{"mi":"k","mo":"-","mn":"1"},{"mi":"n","mo":"-","mn":"1"}],"mo":","}}}]}]}}],"mo":"\u2062"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00002-2","num":"00002.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}},"mo":"\u2062","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":"c","mn":"0"},{"mi":"c","mn":"1"},{"mi":"c","mrow":{"mi":"n","mo":"-","mn":"1"}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":"\u03bc","mn":"0"},{"mi":"\u03bc","mn":"1"},{"mi":"\u03bc","mrow":{"mi":"k","mo":"-","mn":"1"}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":"g","mn":"0"}}},{"mtd":{"msub":{"mi":"g","mn":"1"}}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"mi":"\u22ee"}},{"mtd":{"msub":{"mi":"g","mrow":{"mi":"k","mo":"-","mn":"1"}}}}]}}],"mo":"\u2062"}],"mo":"="}}}}],"br":{},"sub":["i","i,0","i,1","i,2","i,n-1"]},"The generator matrix G for a linear block code can have the form:",{"@attributes":{"id":"p-0036","num":"0037"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"G","mrow":{"mi":["k","n"],"mo":","}},"mo":"=","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"p","mrow":{"mn":["0","0"],"mo":","}}},{"msub":{"mi":"p","mrow":{"mn":["0","1"],"mo":","}}},{"mi":"\u2026"},{"msub":{"mi":"p","mrow":{"mn":"0","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}},{"mn":"1"},{"mn":"0"},{"mn":"0"},{"mi":"\u2026"},{"mn":"0"}]},{"mtd":[{"msub":{"mi":"p","mrow":{"mn":["1","0"],"mo":","}}},{"msub":{"mi":"p","mrow":{"mn":["1","1"],"mo":","}}},{"mi":"\u2026"},{"msub":{"mi":"p","mrow":{"mn":"1","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}},{"mn":"0"},{"mn":"1"},{"mn":"0"},{"mi":"\u2026"},{"mn":"0"}]},{"mtd":[{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mn":"0"},{"mn":"0"},{"mn":"1"},{"mi":"\u2026"},{"mn":"0"}]},{"mtd":[{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"}]},{"mtd":[{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"}]},{"mtd":[{"msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"0"}}},{"msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"1"}}},{"mi":"\u2026"},{"msub":{"mi":"p","mrow":{"mrow":[{"mi":"k","mo":"-","mn":"1"},{"mi":"r","mo":"-","mn":"1"}],"mo":","}}},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mi":"\u2026"},{"mn":"1"}]}]}}}}},"br":[{},{},{},{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{}],"i":["G","=[P","|I","G","=[I","|P","c","c",",c",", . . . ,c"],"sub":["k,n","k,r","k,k]","k,k","k,n","k,k","k,r]","0","1","r-1","0","1","k-1","i","0","0,i","1","1,i","k-1","k-1,i","i "]},"One form of a second, useful matrix is the parity-check matrix Hdefined as:\n\n]\n\nor, equivalently,\n",{"@attributes":{"id":"p-0038","num":"0039"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"H","mrow":{"mi":["r","n"],"mo":","}},"mo":"=","mrow":{"mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mn":"0"},{"mn":"0"},{"mi":"\u2026"},{"mn":"0"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["0","0"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["1","0"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["2","0"],"mo":","}}}},{"mi":"\u2026"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"0"}}}}]},{"mtd":[{"mn":"0"},{"mn":"1"},{"mn":"0"},{"mi":"\u2026"},{"mn":"0"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["0","1"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["1","1"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["2","1"],"mo":","}}}},{"mi":"\u2026"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"1"}}}}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"1"},{"mi":"\u2026"},{"mn":"0"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["0","2"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["1","2"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["2","2"],"mo":","}}}},{"mi":"\u2026"},{"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"2"}}}}}]},{"mtd":[{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mi":"\u2026"},{"mn":"1"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":"0","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":"1","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":"2","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}}},{"mi":"\u2026"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":[{"mi":"k","mo":"-","mn":"1"},{"mi":"r","mo":"-","mn":"1"}],"mo":","}}}}]}]}},"mo":"."}}}},"br":[{},{},{}],"in-line-formulae":[{},{}],"i":["S","s",",s",", . . . ,s","c","r","H"],"sub":["0","1","r-t","r,n "],"sup":["T ","T "]},{"@attributes":{"id":"p-0039","num":"0040"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["H","T"]},"mo":"=","mrow":{"mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":[{"mn":"1"},{"mn":"0"},{"mn":"0"},{"mi":"\u2026"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"1"},{"mn":"0"},{"mi":"\u2026"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"1"},{"mi":"\u2026"},{"mn":"0"}]},{"mtd":[{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mn":"1"}]},{"mtd":[{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["0","0"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["0","1"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["0","2"],"mo":","}}}},{"mi":"\u2026"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":"0","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}}}]},{"mtd":[{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["1","0"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["1","1"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["1","2"],"mo":","}}}},{"mi":"\u2026"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":"1","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}}}]},{"mtd":[{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["2","0"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["2","1"],"mo":","}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":["2","2"],"mo":","}}}},{"mi":"\u2026"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mn":"2","mo":",","mrow":{"mi":"r","mo":"-","mn":"1"}}}}}]},{"mtd":[{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"},{"mi":"\u2026"}]},{"mtd":[{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"0"}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"1"}}}},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":{"mi":"k","mo":"-","mn":"1"},"mo":",","mn":"2"}}}},{"mi":"\u2026"},{"mrow":{"mo":"-","msub":{"mi":"p","mrow":{"mrow":[{"mi":"k","mo":"-","mn":"1"},{"mi":"r","mo":"-","mn":"1"}],"mo":","}}}}]}]}},"mo":"."}}}},"br":{},"sup":"T "},"The syndrome S is used for error detection and error correction. When the syndrome S is the all-0 vector, no errors are detected in the codeword. When the syndrome includes bits with value \u201c1,\u201d errors are indicated. There are techniques for computing an estimated error vector \u00ea from the syndrome and codeword which, when added by modulo-2 addition to the codeword, generates a best estimate of the original message \u03bc. Details for generating the error vector \u00ea are provided in the above mentioned texts. Note that only up to some maximum number of errors can be detected, and fewer than the maximum number of errors that can be detected can be corrected.","As discussed above, embodiments of the present invention are directed to encoding and decoding techniques for coding information to be stored in memory arrays and memory vectors and decoding information retrieved from memory arrays and memory vectors, with the codewords produced by coding embodiments of the present invention satisfying the above-discussed data constraint. For example, the constraint may specify that no row or column in a two-dimensional bit-matrix codeword can have a Hamming weight greater than a threshold value. In examples used to illustrate embodiments of the present invention, square-matrix codewords may be constrained to have no column or row with a Hamming weight greater than n\/2, where n is the row or column dimension of the matrix and \u201c\/\u201d indicates integer division.",{"@attributes":{"id":"p-0042","num":"0043"},"figref":["FIGS. 4A-B","FIG. 4A","FIG. 4A","FIG. 4A"],"b":["402","403","404","410","412","414"]},{"@attributes":{"id":"p-0043","num":"0044"},"figref":["FIG. 4B","FIG. 4A"],"b":["420","422","423","426"]},"While the encoding and decoding method that represents one embodiment of the present invention, discussed above with reference to , does allow for encoding of information bits in compliance with a Hamming-weight constraint, the methods suffer from disadvantages when errors occur in storage, or while a codeword x is being written to, or read from, a vector memory. For example, when the final bit of the encoded vector x is erroneously inverted, the resulting decoded vector u is generally quite different, in bit values, from the original, input information bits.","A second encoding and decoding method that represents another embodiment of the present invention is based on identifying a generator matrix G for a linear block code:\n\n\n\n",{"@attributes":{"id":"p-0046","num":"0055"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mn":"1","mi":"\u03b1"},"mo":["<","<"],"mi":["\u025b","\u03b1"]}}},"br":{}},{"@attributes":{"id":"p-0047","num":"0056"},"figref":["FIGS. 5A-B","FIGS. 4A-B","FIG. 5A","FIG. 5B"],"b":["510","512","514","516","518","520","522"]},{"@attributes":{"id":"p-0048","num":"0057"},"figref":["FIG. 5B","FIG. 5A","FIG. 5A","FIG. 5A"],"b":["530","532","534","536","538","540","542","544","544","520","546","516","548"]},"The encoding and decoding methods illustrated in , which represent embodiments of the present invention, have certain desirable features. Encoded-vector inversion by bitwise complementation ensures that encoded vectors comply with the Hamming-weight constraint, namely having Hamming weights less than a threshold weight . Encoding of the modified information-bit vector u\u2032 using generator matrix G introduces additional parity bits that are subsequently used, on decoding, to detect and correct up to a maximum number of errors. As discussed in the preceding section, the number of errors that can be detected is generally greater than the number of errors that can be both detected and corrected.",{"@attributes":{"id":"p-0050","num":"0059"},"figref":["FIGS. 6A-B","FIGS. 6A-B","FIG. 6A"],"b":"602","br":[{},{}],"in-line-formulae":[{},{}],"i":["q","m\u2212","n\u2212","p "]},"n is the number of columns in the two-dimensional memory; and","p is a number of parity bits generated for inclusion in the two-dimensional-array codeword.","Next, in step , the q received information bits are arranged within an m\u00d7n array A, using a well-defined mapping between an ordered, vector representation of the input q bits and the bit positions within array A. Within array A, p positions are reserved for the parity bits, and are referred to as \u201creserved bits,\u201d and the final row and final column of array A are initialized to contain only bits with value \u201c0.\u201d As discussed in greater detail, below, the parity bits are distributed within the array so that, even were all the parity bits equal to \u201c1,\u201d the array would nonetheless comply with the Hamming constraint for the columns and rows of the array. Note that, the arrangement of information bits and 0-valued bits in memory may be different from the logical arrangement, and the logical arrangement obtained by programmatic retrieval of bits in a particular order during array-based operations. Next, in a while-loop comprising steps -, a row or column in matrix A with a Hamming weight greater than a threshold weight % is selected, assuming the reserved R positions are 1's, in each iteration of the while-loop, and inverted in all non-reserved positions using bitwise-complement operations until no column or row in array A has a weight greater than the threshold weight. Next, in step , values of the p parity bits are computed from all but the reserved bits in array A, using a systematic code, and finally, in step , the computed parity bits are placed into the reserved positions of the array A to complete construction of the array codeword A. The codeword can be stored in a two-dimensional resistor-based memory without violating the row and column constraints.","In , it is assumed that there is a single threshold Hamming-weight constraint, represented by threshold value t that applies both to columns and rows of array A. In alternative embodiments of the present invention, different threshold values tand tmay be applied to rows and columns, respectively, to reflect different constraints in the underlying two-dimensional resistor-based array. As is discussed in greater detail, below, the encoding method that represents one embodiment of the present invention discussed with reference to  is well suited for generating two-dimensional codewords in an array with dimensions m\u00d7n, where m and n are even, and row and column threshold values tand tare greater than or equal to n\/2 and m\/2, respectively, and p is less than or equal to the minimum of in and n. In this case, any q input bits can be successfully encoded by the method discussed above with reference to . In other cases, the method is slightly altered, as discussed further below.",{"@attributes":{"id":"p-0055","num":"0064"},"figref":["FIG. 6B","FIG. 6A","FIG. 6A","FIG. 6A"],"b":["650","652","604","654","610","656","658","660","662","668","673","671","672","606","608","676","678"]},{"@attributes":{"id":"p-0056","num":"0065"},"figref":["FIGS. 7-9","FIG. 6A-B","FIGS. 7-9","FIGS. 7-9"],"b":["702","704","20","706","708","710","708","712"]},"Note that the parity bits are arranged along the main diagonal of the array codeword. This arrangement insures that each column and row contains only a single parity bit. As discussed above, with reference to , the non-reserved bits of the array codeword are input to a systematic encoder in order to compute the values for the parity buts, in the penultimate step  of . Therefore, prior to that step, it needs to be guaranteed that, regardless of what value is assigned to each parity bit, no column or row of the array codeword will have more than n\/2 or m\/2, respectively, bits with value \u201c1.\u201d In order to make this guarantee, the reserved positions are assumed to have a value \u201c1,\u201d during the while-loop in which bitwise-complement operations are carried out until the Hamming-weight constraint is satisfied (- in ). Since the threshold t is m\/2, or 3, no row or column containing a reserved position, can have more than 2 bits with value \u201c1,\u201d and no row or column without a reserved position can have more than 3 bits with value \u201c1,\u201d prior to calculation of the parity-bit values. Because both m and n are even and equal, when a row or column has more than m\/2 bits with value \u201c1,\u201d inversion of the row or column necessarily produces a complementary row or column with less than m\/2 bits, regardless of the value subsequently assigned to a parity bit in the row or column. However, in the case that a row or column length, m or n, is odd, then either the minimum Hamming-weight-constraint threshold needs to be m\/2+1 or n\/2+1, respectively, or any reserved positions need to be paired with an additional reserved 0-valued position and the minimum Hamming-weight-constraint threshold maintained at m\/2 or n\/2. The additional reserved positions are assumed to be 0 in the Hamming-weight computation and like the original reserved positions are unchanged during the inversion step of the row-column inversion loop (-).","Next, the row and column inversions are carried out, as in the while-loop of steps - in . Intermediate array codewords - are generated by row and column inversion, with array codeword  satisfying the row and column Hamming constraint that no row or column should have more than three bits with value \u201c1.\u201d For example, array codeword  is generated by inversion of the 5row of array codeword . Note, in intermediate array codeword , that the Hamming-weight constraint is satisfied even when all five parity bits, represented by the symbol \u201cR,\u201d are set to bit value \u201c1.\u201d Then, the non-reserved bits of the codeword are assembled into a modified vector s\u2032  which is multiplied by a generator matrix G  of a systematic encoding method to produce a codeword c from which five parity bits are obtained . These parity bits are then inserted in the intermediate array codeword to produce a final array codeword . The vector s\u2032 may not necessarily be constructed in memory, but may only be logically constructed as bits are selected from array codeword  during the multiplication by generator matrix G .",{"@attributes":{"id":"p-0059","num":"0068"},"figref":["FIGS. 8 and 9","FIGS. 7-9","FIG. 7","FIG. 7","FIG. 7","FIG. 8"],"b":["802","730","802","804","730","722","730","806","808","810","812","814","816"]},{"@attributes":{"id":"p-0060","num":"0069"},"figref":["FIG. 9","FIG. 6B","FIG. 9","FIG. 8","FIG. 6B","FIG. 6B","FIG. 6B","FIG. 9","FIG. 9"],"b":["668","673","816","668","673","902","670","904","670","906","671","910","912"],"sub":["0,0 ","0,1 "]},{"@attributes":{"id":"p-0061","num":"0070"},"figref":["FIG. 10","FIG. 10","FIG. 11","FIGS. 6A-B"],"b":["1002","1004","1006","1008","1010","1012","1014","1006","1016","1012","1018","1020","1022","1024","1026","1028"]},{"@attributes":{"id":"p-0062","num":"0071"},"figref":["FIG. 11","FIG. 11"],"b":["1102","1104","1106","1108","1110","1112"]},{"@attributes":{"id":"p-0063","num":"0072"},"figref":["FIGS. 12-17","FIG. 12","FIGS. 12-17","FIG. 12"],"sub":["m\u00d7n","m\u00d7n ","m\u00d7n","m\u00d7n ","m\u00d7n ","m\u00d7n ","m\u00d7n ","m\u00d7n ","m\u00d7n","m\u00d7n"],"b":["1202","1204","1202","1204","1210","1212","1214","1202","1204"]},{"@attributes":{"id":"p-0064","num":"0073"},"figref":"FIG. 13","b":["1302","1304","1306"],"sub":["m\u00d7n","m\u00d7n "]},{"@attributes":{"id":"p-0065","num":"0074"},"figref":["FIG. 14","FIG. 6A","FIGS. 12-14","FIG. 12","FIG. 14","FIG. 14","FIG. 15","FIG. 12","FIG. 14","FIG. 15","FIG. 12","FIG. 12","FIG. 14","FIG. 15","FIGS. 12 and 15"],"b":["1402","1404","1406","1410","1412","1413","1416","1418","606","608","1202","1204","1412","1418","1502","1502","1510","1204","1510","1516","1202","1520","1521","1502","1502","1510","1516","1520","1502"],"br":[{},{},{}],"in-line-formulae":[{},{},{},{}],"i":["i+j=k ","i=m+n\u2212"],"sub":["m\u00d7n ","m\u00d7n","m\u00d7n ","m\u00d7n","m\u00d7n ","m\u00d7n ","m\u00d7n "]},{"@attributes":{"id":"p-0066","num":"0075"},"figref":["FIGS. 16 and 17","FIGS. 12-17","FIG. 14","FIG. 6A","FIG. 17","FIG. 14","FIG. 68"],"b":["1602","1604","1402","1606","1608","1610","606","608","1702","1704","1706","1708","1710","1712","1714","668","673","1716","1718"],"sub":"m\u00d7n "},{"@attributes":{"id":"p-0067","num":"0076"},"figref":"FIG. 18","b":["1802","1805","1808","1810","1812","1810","1814","1816","1818","1820","1822","1827","1827","1828"]},"Although the present invention has been described in terms of particular embodiments, it is not intended that the invention be limited to these embodiments. Modifications will be apparent to those skilled in the art. For example, a variety of different implementations of the various embodiments of the present invention can be obtained by varying any of many different implementation parameters, including programming language, modular organization, control structures, data structures, and other such implementation parameters. Many embodiments of the represent invention employ systematic coding and decoding techniques, including systematic linear block codes. A variety of different systematic coding and decoding techniques can be used in certain embodiments of the present invention. While descriptions of embodiments of the present invention refer to vectors, array codewords, and other such entities, these entities may be implemented in various ways for storage and retrieval from computer memory and mass-storage devices, and often, a vector codeword and an array codeword equivalent to the vector codeword may be stored in one form that is programmatically transformed to between various formal representations. Thus, for example, were a two-dimensional data array used to store a codeword, the two-dimensional data array can be programmatically treated as a vector codeword for matrix multiplication by a generator matrix. While the above discussion of embodiments of the present invention use vectors and arrays containing elements of the GF(2) field, equivalent methods can be implemented to handle information encoded using elements of other fields. The positions of the all-0 column and row of the array codewords is illustrated and described as the final row and column of the array codeword, but other positions can be selected for the all-0 row and column, in alternative embodiments of the present invention. Of course, an opposite convention, in which the reserved row and column are initialized to have bits with \u201c1\u201d values, and the inverse of the column-and-row inversion inverts bits when the sum of related bits is even, can also be used to implement embodiments of the present invention. Similarly, in the vector-encoding embodiments of the present invention, the additional bit can be initially set to \u201c0,\u201d with inversion indicated by a value \u201c1\u201d in the additional bit. In similar fashion, the weight of a codeword can be computed according to either of two conventions, the convention chosen determining the nature of the threshold comparison used to decide whether or not to invert a row, column, or vector codeword.","The foregoing description, for purposes of explanation, used specific nomenclature to provide a thorough understanding of the invention. However, it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention. The foregoing descriptions of specific embodiments of the present invention are presented for purpose of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments are shown and described in order to best explain the principles of the invention and its practical applications, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents:"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 4A-B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 5A-B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 6A-B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIGS. 7-9","FIG. 6A-B"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 12-17"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 18"}]},"DETDESC":[{},{}]}
