---
title: N-way runtime interoperative debugging
abstract: Simultaneous debugging of code running in multiple types of runtime environment can be performed by an n-way interoperative debugging environment. Code running within a particular runtime can be debugged simultaneously with a code running within other runtimes within a single process. Out-of-process debugging support is provided for inspection and execution control. A compatible debugger or runtime communication protocol is used. Transitions from one runtime to another runtime can be detected. Exceptions thrown in one runtime can be caught by another runtime. Stepping operations can occur in multiple runtimes. A callstack including frames from multiple runtimes can be walked.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572438&OS=08572438&RS=08572438
owner: Microsoft Corporation
number: 08572438
owner_city: Redmond
owner_country: US
publication_date: 20110624
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["When a process is being debugged, debug events can be generated. A debugger typically listens and responds to the debug events. Debug events can be created when a process is created, when a module is loaded, when an exception is thrown, when a breakpoint is encountered and so on. A debugger uses the debug events and inspection application programming interfaces (APIs) to implement debugging operations. When a debug event is dispatched, the debuggee (the process being debugged) is typically stopped until the debugger continues the debug event. While the debuggee is stopped, the debugger can inspect the state of the debuggee. When the debuggee is continued, the process runs until the next debug event is encountered. Typically, managed code and native code debugging have different sets of debug events and different ways of transitioning between stopped and running states.","Native debugging is typically implemented by the operating system (OS). The OS provides the debugging API for listening to and continuing debug events. When a debug event occurs, the OS freezes the debuggee (the process being debugged). Native debugging is an out-of-process operation, that is, the process is frozen and code outside the process (in the OS) inspects values from the frozen process. Out-of-process debugging does not need cooperation from the debuggee. The native debuggee stop state is called frozen because the process has been stopped by the OS and no code executes inside the process until the OS starts the process up again.","Debugging in a virtual machine environment (e.g., in Eclipse or in Microsoft's Visual Studio\u00ae) is not performed by the operating system on a frozen process. Debugging in a virtual machine environment is typically implemented by the runtime environment of the virtual machine and is an in-process operation. Code inside the process executes to perform the debugging operations. The OS has no knowledge of when this type of debugging is occurring. The debuggee stop state is sometimes referred to as \u201csynchronized\u201d because a synchronized process is live from the OS perspective, but all the threads are stopped by the runtime environment. Virtual machine debug events may be \u201cbuilt on top of\u201d or implemented using native debug events.","Virtual machine runtime services implement virtual machine debugging operations and do not implement native debug operations. Similarly, native debugging APIs do not provide support for debugging in a virtual machine environment. Debug operations in a virtual machine environment and native debug operations are implemented differently. For example, in Visual Studio\u00ae, managed stepping is implemented via a runtime environment API while native stepping is implemented via a native debug library that consumes native debug events. Native execution control (control of stepping operations and breakpoints) is typically implemented using OS exception processing and lacks explicit support in the native debugging API. The managed debugging API explicitly has breakpoint and stepping functionality. The difference in the abstraction levels of managed and native debugging prevents code sharing between managed and native debugging operations.","Some IDEs are able to debug code running in a virtual machine runtime environment and in a native runtime in a single debug session. This is called interoperative debugging. The mechanisms used in known interoperative debuggers are limited and rely on a tedious and fragile cooperation between the native and virtual machine runtime debuggers because of the underlying conflicting debugging architecture designs.","Simultaneously within the same debug session, debugging of code running within multiple types of runtime environments within a single debuggee process can be performed using an extensible debug architecture. Such simultaneous debugging is referred to herein as n-way interoperative debugging. N-way interoperative debugging can provide a holistic view of the entire debuggee process including a logical view of all of the runtime environments executing in the single debuggee process (in a single debug session). Interactions between runtime debuggers can also be viewed. The debugging support for a virtual machine runtime environment enables interoperative debugging using a set of debugger interfaces to facilitate debugging operations. Debugging support created by the virtual machine runtime environment does not interfere with debugging other runtime debuggees in the process.","Interoperative debugging enables execution control, stepping a debuggee code running from one runtime into another, setting breakpoints in multiple runtime debuggees, inspecting values from multiple runtime debuggees and executing callstacks that contain code from multiple runtime debuggers. Runtime debuggers are prioritized so the highest priority runtime debugger controls execution and unwinds the stack.","Conforming runtime debuggees can be interoperatively debugged by the n-way interoperative debugger. A conforming runtime debuggee is one that uses out-of-process debugging support for inspection and execution control, uses a compatible debugger\/debuggee communication protocol, can detect boundaries into and out of a runtime debuggee for execution control and stack unwinding. For those runtime debuggees that throw exceptions, compatible runtime debuggers can detect exceptions thrown from one runtime debuggee and caught within another runtime debuggee. Out-of-process debugging does not involve executing code in the debuggee process so that the runtimes do not interfere with each other's threading model or execution model. Conforming runtime debuggers can be plugged into the n-way interoperative debugger.","The interfaces and mechanisms described herein can be used as a general extensibility model for stepping operations in a debugger.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Overview","In accordance with aspects of the subject matter disclosed herein, a runtime debugger architecture that can interoperatively debug with any compatible runtime debugger in the process is described. Code running on n-way interoperative compatible runtime debuggees can be debugged using an out-of-process operation. Core debugger operations including but not limited to data inspection, execution control, and stack unwinding can be performed from outside the debuggee process using OS primitives that do not require executing code within the debuggee process. Executing code in the runtime debuggee process is avoided in part because executing code in the runtime debuggee process could generate more debug events when the process was stopped, as well as for other reasons. Out-of-process debugging ensures that multiple runtime debuggees will not interfere with each other's threading model at debug time. It also ensures that inspecting a runtime within the debuggee process will not cause side effects that other runtime debuggers cannot handle.","Read\/write process memory primitives allow the debugger to read\/write memory into the debuggee process. Get and set thread context primitives enable the access and modification of the register set in the debuggee process. Debugger primitives that are written on top of the OS primitives include breakpoints and single step instruction. A single step operation tells the processor to execute a single instruction and then stop and notify the debugger. The debug API can notify the debugger of a set of events that happen in the debuggee process including process create and destroy, module load and unload, breakpoint hit, single step finished, exception occurred. Notification from the communication channel is also done using an out-of-process model so that when a breakpoint is hit a notification is sent to the debugger without running code in the debuggee process.","A compatible protocol between the debuggee process and the out-of-process debugger is used for n-way interoperative debugging compatible runtimes. That is, a runtime debuggee notifies a debugger that a debug event has occurred in the debuggee process in a way that does not cause other runtime debuggers to malfunction or to be unable to communicate. One n-way interoperative debug compatible protocol that can be used is the Win32\u00ae debug event model created by Microsoft Corporation.","Boundaries between n-way interoperative compatible runtime debuggees in the process are identifiable when a runtime debugger controls a debug operation. For example, if code running on Runtime Debugger A calls into code running on Runtime Debugger B, Runtime Debugger B can detect that control has transitioned into Runtime Debugger B and can take control of the debug operation.","N-way interoperative debug compatible runtime debuggers that support an exception model are able to identify when an exception is being caught by its runtime debugger. Exceptions can originate in one runtime debugger and be caught in another. For example, suppose code running on Runtime Debuggee A calls into code running on Runtime Debuggee B, and a user is stepping through code running on Runtime Debuggee B. If an exception is thrown while the step operation is occurring, that exception may get caught by Runtime Debuggee A. In this case, the debugger step operation can be suspended at that point. When a runtime debugger detects when an exception is caught by its runtime debuggee, a handler found notification can be generated. Exceptions from one runtime debuggee can be used as the implementation of exceptions for another runtime debugged. For example, exceptions thrown within the Common Language Runtime (CLR) are actually native Structured Exception Handler exceptions. Thus, the native debugger is unaware that a step is complete when an exception is thrown and caught until after the CLR's debugger can inspect the handler block. Compatible debuggees do not have to use an exception model for indicating errors.","N-way Interoperative Debugging",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 3","FIG. 4","FIG. 4"],"b":["100","100","100","100","104","104","100"]},"System  may include one or more computing devices or computers such as a computer  comprising: one or more processors such as processor , etc., a memory such as memory , an n-way interoperative debugger such as debugger , a debuggee , and a set of debug APIs . Debugger  can include one or more modules including one or more modules comprising a stepping manager  and a debug monitor . In accordance with aspects of the subject matter disclosed herein a developer debugging program code executing in the debuggee process can debug the multiple runtimes simultaneously using debugger . The developer can step from code running in one runtime debuggee to code running in another debugee runtime. Breakpoints can be set in any, some or all of the runtime debuggees executing in the debuggee process. Debuggee values (e.g., values of variables, etc.) can be inspected in one runtime debuggee while another runtime is being viewed. A callstack associated with the debugger  can include code from multiple runtimes. Debugger  can include one or more of: a native runtime debugger , an interpreter debugger , a stack provider  and one or more managed runtime debuggers , etc. Debugger  can also include a stack provider . Debugger  can be extensible so that one or more n-way interoperative compatible debuggers can be plugged into debugger .","A debuggee  can include some or all of: one or more managed runtime debuggees , etc., a native runtime debuggee  and an interpreter debuggee . An instance of a module can be loaded into the debuggee process that is marked as a transition module by a runtime (e.g., transition module  in managed runtime debuggee , transition module  in native runtime debuggee , transition module  in interpreter debuggee ). Other components well known in the arts may also be included but are not here shown. It will be appreciated that one or more of the above can be loaded into memory  to cause one or more processors such as processor  to perform the actions attributed to the one or more modules which together perform n-way interoperative debugging as described more fully below.","Stepping manager  can comprise a module or class that provides a communication channel between runtime debuggers such as managed runtime debugger , etc. native runtime debugger  and interpreter debugger . Stepping manager  can implement stepping arbitration, described more fully below. Stepping manager  can include a module that receives a single step request that stores state about the step including the type of step (step-over, step-in, step-out), the unit of the step (statement, line, or instruction) and the starting frame base and address. A debug monitor such as debug monitor  can comprise a module or class that manages the communication channel between the debugger (e.g., debugger ) and the debuggee (e.g., debuggee ). Debug monitor  can route debug events to a corresponding debugger. For example, events generated in managed runtime debuggee  can be routed by debug monitor  to managed runtime debugger , events generated in native runtime debuggee  can be routed by managed runtime debugger  to native runtime debugger , events generated in interpreter  can be routed by debug monitor  to interpreter debugger  and so on. The debug monitor  can comprise a module or class that implements the debug event loop (e.g., the Win32 debug event loop). The debug monitor  can comprise a debug monitor module or class that can translate debug events from the debugger process runtimes into debug events compatible with the debug APIs .","An n-way interoperative debugger  can receive a request from a callstack window to start walking callstack frames such as frame  , frame   . . . frame n  of callstack . The n-way interoperative debugger  can route the call to the stack provider . The stack provider  can ask each runtime debugger (e.g., managed runtime debugger , etc., native runtime debugger , interpreter runtime debugger ) if the runtime debugger owns the current location, that is if the instruction currently being executed is in a range of frames belonging to that runtime debugger. The runtime debuggers are asked in order of priority. When a runtime debugger claims the location in the callstack , frames are requested from the callstack  by the claiming runtime (the current controlling runtime debugger) and are processed by the claiming runtime debugger until the claiming runtime debugger detects a frame that does not belong to it. Runtime debuggers are prioritized because one runtime debugger can be implemented on top of another runtime debugger. The priority order of runtime debuggers is useful because it is possible for higher level runtime debuggers such as interpreters to be implemented using another runtime such as a managed or native runtime debugger. For example, in the case of an interpreter runtime debugger implemented in managed code, the interpreter runtime debugger can be given a chance to unwind the frame before the managed runtime debugger. Suppose Runtime Debugger A is implemented on top of Runtime Debugger B. Runtime Debugger A can take priority over Runtime Debugger B to ensure that the higher level runtime debugger, Runtime Debugger A, is able to perform execution control and can unwind the stack. For example, suppose an interpreter runtime debugger is implemented in managed code. In this case, the interpreter runtime debugger has priority over the managed code runtime debugger. Ultimately, all code is native, so the native execution engine and stack unwinder can be the lowest priority runtime.","Each of the runtime debuggers in an n-way interoperative debugger such as debugger  represents a single instance of a runtime debugger debugging a particular runtime in a debuggee process. Examples of different types of runtime debuggers that can execute in debugger  include a native runtime debugger instance, a virtual machine runtime debugger instance and an interpreter runtime debugger instance. Each runtime debugger instance is responsible for understanding and implementing debugging of a particular runtime debuggee. That is, a managed runtime debugger  debugs code running within the managed runtime, a native runtime debugger  debugs code running on the native runtime within a debuggee process and so on.","System  can provide out-of-process debugging support for inspection and execution control. Out-of-process debugging is used because although managed runtime environments can implement debugging support within the debuggee process, doing so introduces incompatibilities between runtimes. For example, an in-process debugger runs the debugger code within the debuggee process. Out-of-process debuggers such as native debuggers will not allow the debuggee thread to run while the debugger is in break-mode. Because an in-process debugger can chose from any of a large number of possible threading models, defining compatible models that enable n-way interoperative debugging for any in-process debugger is an intractable problem. Therefore, the out-of-process debugger model is implemented in system .","One example of a runtime that conforms to the \u201cout-of-process\u201d debugger model is Microsoft's native win32 runtime. Debuggers designed to debug native code running on the win32 operating system use a combination of the pdb (program database) file, a file that holds debugging and project state information, the win32 debugging APIs, and features on the hardware to perform various debugger tasks such as stepping, or examining variable state. For example, to examine a local variable on the stack in a native application, the native runtime debugger first looks up the information about that variable in the pdb. The information in the pdb includes the type of the variable, how it is formatted in memory, and where in memory the variable resides. The debugger uses out-of-process read memory APIs to obtain the bytes for the variable from the debuggee process. It can then format the value as described in the pdb and display the formatted information to the user. Another example of an out-of-process operation is stepping a native win32 application. To perform a step operation, the native debugger can look up the debuggee's current instruction pointer in the pdb to obtain a source line to memory range mapping. It can use primitives such as single-step and breakpoint instructions to cause the debuggee process to execute until the end of the source range is encountered.","Runtimes that need more dynamic interactions between the runtime and the debugger such as interpreters or virtual machine runtime environments can expose data structures at well-known locations to allow the corresponding debugger to read the data structures using out-of-process read memory APIs at debug time. A corresponding runtime debugger can read from and write to the data structures to affect runtime behavior. For example, to set a breakpoint on an interpreter source line, the debugger can locate the breakpoints data structure and write information to the data structure to enable the breakpoint. The runtime debuggee can trigger the breakpoint when execution reaches the breakpoint. Stepping can be implemented similarly. For example, the debugger can write the step information into a data structure defining the thread. The interpreter can stop when the step is complete. Information about a thread's stack can be made available for data inspection operations via out-of-process read memory APIs. The debugger can select the correct stack frame, match it with the correct stack frame object in the debuggee using out-of-process read memory, and use the data structure to obtain the names, values, and types of the variables on the stack frame.","A just-in-time (JIT) based runtime can expose data structures in ways that the debugger can access them using out-of-process APIs. Data structures can be abstracted into higher level objects that reside in the debugger process. The debugger can consume the objects using read and write process memory. Execution control operations such as stepping and breakpoints can be implemented using the same hardware primitives native code would use (single step and hardware breakpoints). Actual mapping from source line to instruction address can be based on the output of the JIT compiler and therefore can be dynamic. Actual mapping (and stepping ranges) can be obtained by reading data structures out of the process.","An n-way interoperative compatible debuggable runtime has to have a way to communicate debug events to the debugger. To support n-way interop, the protocol must be compatible with the other runtime debuggers debugging the process. One way to ensure compatibility is to implement a protocol that works with the out-of-process model and does not cause event confusion between the various runtime debuggers. Some runtime debugger architectures use a higher level protocol such as named pipes for this purpose, but such protocols often violate the out-of-process model. Hence in accordance with aspects of the subject matter discloser herein, a native debug pipeline such as but not limited to the win32 debug pipeline is implemented. Functions including a WaitForDebugEvent function and a ContinueDebugEvent function can be used to allow the debugger to receive notifications about what is happening in the process and to continue execution of the debuggee when it has finished processing a debug event. Debug events include a create process event, a create thread event, a load module event and exceptions. A hit breakpoint event and a complete single step event can be implemented on top of exceptions using specific exception codes. To enable multiple runtime debuggers to receive the events through the debug APIs, an n-way interoperative debug architecture can separate out the debug event loop from the actual runtime debugger implementations, as described more fully below.","To implement execution control in an n-way interoperative debugger (i.e., interoperative execution control), in accordance with aspects of the subject matter disclosed herein, transitions into and out of a runtime have to be detectable because a runtime debugger that begins a step operation may not be the runtime debugger that finishes the step operation. For example, during a step-in operation, if a call instruction is encountered, the call may be made to code running within another runtime debuggee in the process. The runtime debugger that is currently in control of the operation (\u201cthe current controlling runtime debugger\u201d) has to be able to relinquish control and let another runtime debugger take over control. Detection of a transition into another runtime debuggee can be implemented in various ways including but not limited to those described below.","The runtime debuggee may use a standard module (i.e., a transition module) for the entry point. That is, any time a step operation causes the debuggee's instruction pointer to land within a transition module, a possible transition into another runtime debuggee has been encountered. In response the current controlling runtime debugger can stop stepping, and give the other runtime debuggers a chance to finish the step. If no new controlling runtime debugger is encountered, the original runtime debugger can complete the step. The process of allowing other runtime debuggers to inspect the current instruction pointer and take control is called \u201cStepping Arbitration\u201d herein.","The runtime debuggee may have well known functions that are called at runtime transition points, enabling the runtime debuggee to set breakpoints at these functions. When these breakpoints are hit during a stepping operation, the runtime debugger for that runtime can request that the previous controlling runtime debugger give up control of the operation.","An interpreter or other tightly controlled runtime debuggee including but not limited to the CLR may be able to fire a debug event into the debugger at the transition point. If a step operation is occurring, that runtime debuggee's debugger can request that the former runtime debugger give up control of the operation. When unwinding the callstack, the runtime's unwinder can be aware of the regions in the callstack, where code running on the runtime exists. This ensures the correct runtime unwinder is called for a particular region of the callstack. Because one runtime debugger can be implemented on top of another runtime debugger, the higher level runtime debugger can be given priority to prevent the lower level runtime debugger from unwinding the wrong section of the callstack.","Finally, an n-way interoperative debugger compatible runtime debuggee has to be able to detect when an exception has been caught by a handler in the runtime debuggee even if the exception was originally thrown from another runtime debuggee. At least some runtime debuggees have some kind of error handling. When an error occurs in one runtime environment and it transitions to another runtime environment, if it is possible for the runtime to stop the process and handle the error condition, it can stop execution control. Runtime debuggees that do not support exceptions do not have to detect caught exceptions. Being able to detect a caught exception allows a step operation to complete when a handler is found even if the exception crosses runtime debuggee boundaries. Some runtime debuggers have to initiate arbitration when their handler found notification is fired because their exception model is implemented on top of another runtime debuggee's exception model.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","i":"a ","b":["202","204","206","208"]},"At  the stepping manager can perform top-level or initial step arbitration, asking each runtime debugger instance in priority order if the debuggee is currently executing within its runtime. A debuggee is currently executing within a runtime debugger when the instruction pointer points to a region of the callstack that belongs to that runtime debugger. At  the current controlling runtime debugger is selected. At  the stepping manager notifies all the other runtime debuggers of the new controlling runtime debugger (current controlling runtime). Notification enables the other runtimes to perform special processing for the particular runtime acting as the current controlling runtime. At  the current controlling runtime debugger begins to step the process. At  at each call instruction that is encountered during the step or anytime the current stack frame changes, the current controlling runtime debugger checks to see if the instruction pointer has landed within a transition module owned by another runtime debugger. Alternatively, another runtime debugger may detect a transition into its runtime when a breakpoint is hit or when another debug event occurs.","At  in response to determining that no transition is possible, processing continues at  where the step is completed by the controlling runtime debugger. When the stepping operation completes at , the current controlling runtime debugger notifies the stepping manager that the step is complete at . At  the stepping manger notifies all the other runtime debuggers that the step is done. At  the debugger user interface receives the step complete notification and enters break mode. If however, at  it is determined that a transition is possible, stepping arbitration is requested and processing returns to . During step arbitration, the stepping manager asks each runtime debugger in priority order if the runtime claims the location. If no other runtime debugger claims the location, the current controlling runtime debugger finishes the step at . If however at  the stepping manager determines that a runtime transition has occurred, processing continues at .","A runtime debugger instance may also detect transitions into its runtime directly using breakpoints, exceptions, or another debug event. If a transition occurs, the runtime debugger instance can ask the current controlling runtime debugger for control through the stepping manager. If the current controlling runtime debugger instance agrees, step control is given to the new runtime debugger instance. The other runtime debugger instances can be notified of the change in the controlling runtime debugger. All stepping operations including step-in, step over and step-out are enabled by this mechanism. It will be appreciated that a step over may encounter a new boundary module (e.g., if, for example, the step steps off the end of a function). Similarly, a new boundary module can be encountered when the current frame is stepped out from.","Inspection in a debugger is based on callstack frames. In n-way interoperative debugging, each runtime debugger instance is responsible for unwinding its own call stack frames. Each runtime debugger of the n-way interoperative debugger can mark the current frame as its own so that variable inspection can be routed to the appropriate runtime debugger instance. The n-way interoperative architecture can provide a way for frames from different runtime debugger s to be stitched back together after the full call stack is complete. It also must provide a way for \u201cruntime glue\u201d frames to be hidden from the user.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2","i":"b ","b":["250","252","254","256"]},"At  a runtime debugger claims the location and at  requests frames from the callstack until the current frame does not belong to the runtime debugger. At  in response to detecting a frame that does not belong to the runtime an \u201cend of runtime\u201d value is indicated to the stack provider. At  the runtime notifies the stack provider of the position in the callstack at which the runtime's code starts again (if it does). This prevents another runtime from unwinding a portion of the callstack that does not belong to it. To understand how this could happen, suppose a stack provider is not informed of stack transition points. Suppose a managed unwinder stops at a managed to native transition point. The native runtime will continue unwinding the callstack until the entire stack has been processed even if there is another transition point back to managed code. This happens because all code is ultimately native code.","Similarly, a transition from managed code to interpreted code could be unwound by a managed runtime debugger because the interpreter is implemented in managed code, even though the stack should by unwound by the interpreter. In contrast, in accordance with aspects of the subject matter disclosed herein, because the stack provider knows each transition point, the stack provider can ask each runtime debugger in priority order if the runtime debugger would like to process the next call stack frame. When a runtime debugger claims a frame, the claiming runtime debugger is given control of the unwind. Once all frames have been unwound, call stack frames are filtered. That is, each runtime debugger is given the opportunity to hide runtime glue code or to completely change the contents of a frame. Finally, each frame in the call stack is formatted by the language expression evaluator that matches the frame the in question.","When interoperative debugging is performed, an exception thrown in one runtime debugger can be caught in a catch handler in code running on another runtime debugger. If a step operation is occurring when an exception is thrown, the step is usually stopped. A runtime debugger that supports exceptions can be told when an exception is caught by its runtime debugger using the runtime debugger's exception handler found notification. illustrates an example of a method  for handling exceptions in accordance with aspects of the subject matter disclosed herein. At  a step operation begins. At , in response, the stepping manager notifies all runtime debuggers that the step operation has begun. At  in response to the notification each runtime debugger instance can enable its catch handler found notifications. An exception may be thrown by a frame called from the current stepping frame and can be caught by a frame before the unwind has passed through the stepping frame. In accordance with aspects of the subject matter disclosed herein, the Frame Base of the frame can be used to detect such an instance. The frame base is the value of the stack pointer before any stack operations occur for the frame. In an n-way interoperative debug system in which the callstack grows in a downward direction, a call higher on the callstack will have lower frame base than a call lower on the callstack. That is, if function a calls function b, which itself calls function c, then the callstack will appear as:\n\n","If the catch handler found notification of a runtime fires before a step is complete, the runtime debugger can compare the current stack frame's frame base with the frame base of the stack frame at the time the step was started. If the current stack frame's frame base is lower than the starting frame's frame base, then the exception was thrown and caught by a frame called by the frame for the current step and can be ignored. However, if the frame base is greater than or equal to the frame base at the time of the step, then the exception has transitioned past the point of the step and the step operation can be considered complete. It will be appreciated that some runtimes, including but not limited to CLR, use another runtime's exception model to implement exceptions. Typically managed exceptions are built on native exceptions but other possibilities exist. Any runtime that uses another runtime's exception model can initiate stepping arbitration after the step handler found notification is fired. For example, assume function A (running on the CLR) calls function B (native code). If function B throws an exception, both native and managed runtime instances will receive their handler found notifications (possibly at different times). However, because the target handler is actually managed code, the native runtime instance should allow the managed runtime to finish the step. Logically, the implementation of this looks like this in the CLR:",{"@attributes":{"id":"p-0050","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Try"]},{"entry":[{},"{"]},{"entry":[{},"\u2002Call NativeCode"]},{"entry":[{},"}"]},{"entry":[{},"Catch (native filter)"]},{"entry":[{},"{"]},{"entry":[{},"\u2002Call managed catch handler"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If, when stepping over the native code, an exception is thrown, the runtime instance can be sent a catch handler found notification at the native catch block. Step arbitration can be performed whenever catch handler found notification fires. If the location is not claimed, the catch block is in native code and the step is complete. If another runtime debugger claims the location, the claiming runtime debugger can finish stepping. It will be appreciated that the mechanisms described herein in the context of an n-way interoperative debugger can also be applied to a general extensibility model for stepping in a debugger. For example, step arbitration and transition modules can be used by a technology to change the debugging behavior when that technology is being used in a debuggee. For example, COM RPC stepping can invoke a plug-in component that can detect an RPC transition and can cause an in-flight step operation to stop at the target of an RPC call.","Example of a Suitable Computing Environment","In order to provide context for various aspects of the subject matter disclosed herein,  and the following discussion are intended to provide a brief general description of a suitable computing environment  in which various embodiments of the subject matter disclosed herein may be implemented. While the subject matter disclosed herein is described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other computing devices, those skilled in the art will recognize that portions of the subject matter disclosed herein can also be implemented in combination with other program modules and\/or a combination of hardware and software. Generally, program modules include routines, programs, objects, physical artifacts, data structures, etc. that perform particular tasks or implement particular data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. The computing environment  is only one example of a suitable operating environment and is not intended to limit the scope of use or functionality of the subject matter disclosed herein.","With reference to , a computing device in the form of a computer  is described. Computer  may include a processing unit , a system memory , and a system bus . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit . The system memory  may include volatile memory  and nonvolatile memory . Nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM) or flash memory. Volatile memory  may include random access memory (RAM) which may act as external cache memory. The system bus  couples system physical artifacts including the system memory  to the processing unit . The system bus  can be any of several types including a memory bus, memory controller, peripheral bus, external bus, or local bus and may use any variety of available bus architectures.","Computer  typically includes a variety of computer readable media such as volatile and nonvolatile media, removable and non-removable media. Computer storage media may be implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other transitory or non-transitory medium which can be used to store the desired information and which can be accessed by computer .","It will be appreciated that  describes software that can act as an intermediary between users and computer resources. This software may include an operating system  which can be stored on disk storage , and which can allocate resources of the computer system . Disk storage  may be a hard disk drive connected to the system bus  through a non-removable memory interface such as interface . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It will be appreciated that computers can be implemented with various operating systems or combinations of operating systems.","A user can enter commands or information into the computer  through an input device(s) . Input devices  include but are not limited to a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . An interface port(s)  may represent a serial port, parallel port, universal serial bus (USB) and the like. Output devices(s)  may use the same type of ports as do the input devices. Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers and printers that require particular adapters. Output adapters  include but are not limited to video and sound cards that provide a connection between the output device  and the system bus . Other devices and\/or systems or devices such as remote computer(s)  may provide both input and output capabilities.","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computer(s) . The remote computer  can be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . Remote computer(s)  can be logically connected via communication connection . Network interface  encompasses communication networks such as local area networks (LANs) and wide area networks (WANs) but may also include other networks. Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . Connection  may be internal to or external to computer  and include internal and external technologies such as modems (telephone, cable, DSL and wireless) and ISDN adapters, Ethernet cards and so on.","It will be appreciated that the network connections shown are examples only and other means of establishing a communications link between the computers may be used. One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the subject matter disclosed herein may pertain to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. Aspects of the subject matter disclosed herein may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. Aspects of the subject matter disclosed herein may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.",{"@attributes":{"id":"p-0059","num":"0061"},"figref":"FIG. 4","b":["600","602","600","610","600","600","650","610","611","620","611","650","660"]},"A user can create and\/or edit the source code component according to known software programming techniques and the specific logical and syntactical rules associated with a particular source language via a user interface  and a source code editor  in the IDE . Thereafter, the source code component  can be compiled via a source compiler , whereby an intermediate language representation of the program may be created, such as assembly . The assembly  may comprise the intermediate language component  and metadata . Application designs may be able to be validated before deployment.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus described herein, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. As used herein, the term \u201cmachine-readable medium\u201d shall be taken to exclude any mechanism that provides (i.e., stores and\/or transmits) any form of propagated signals. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects, e.g., through the use of a data processing API or the like, may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2","i":"a ","b":"200"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2","i":"b ","b":"250"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2","i":"c ","b":"270"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
