---
title: Non-privileged access to data independent of filesystem implementation
abstract: An application programming interface (API) module provides access to data, independent of filesystem implementation in a non-privileged user mode. A discovery volume having a filesystem recognizable by an operating system has cover files which prevent damage to data stored in an unrecognizable primary volume. The discovery volume also includes a data access API available for execution in a non-privileged user mode to render the primary volume accessible by operating systems which would otherwise find the primary volume unrecognizable.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08073886&OS=08073886&RS=08073886
owner: Microsoft Corporation
number: 08073886
owner_city: Redmond
owner_country: US
publication_date: 20090220
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Access to data across multiple filesystems is a significant concern for computer users. Users may encounter difficulties when trying to access filesystems supported in a source system but not supported in an accessing system. For example, an older version of an operating system may be unable to access a volume created in a newer version of the operating system because of new features present in the filesystem of the newer version, which render the newer version inaccessible to the older version.","Attempts to access volumes containing a filesystem incompatible with the accessing device may have unintended consequences for users. The accessing system may not recognize the filesystem of the source system and present the volume as \u201craw,\u201d or apparently unrecognized. At the least, the accessing system may not be able to determine that data is present on that volume. At worst, an accessing system which fails to recognize the volume may prompt the user to reformat the entire volume, causing loss of the data in the volume.","Furthermore, loading of special drivers or software to allow access to a volume ordinarily unrecognizable by an operating system has traditionally required execution in kernel mode, thus running afoul of security policies which limit execution to user mode.","An original boot region (or boot sectors) of a primary volume on a computer readable storage medium is defined as a virtualized region. The virtualized region and its data are moved to another location on the primary volume. A discovery volume is initialized, which takes the place of the virtualized region, using an application programming interface (API). The discovery volume acts as an overlay for the primary filesystem and comprises a filesystem recognizable by a desired array of accessing devices. The discovery volume includes one or more pointers in its boot region, which lead to the virtualized region relocated to accommodate the discovery volume at the beginning of the volume. For example, a discovery volume using a File Allocation Table (FAT) filesystem contains boot region entries consistent with a FAT boot region, and one or more pointers to the relocated virtualized boot region of the primary filesystem.","The discovery volume stores a data access application programming interface (API) configured to allow an operating system of an accessing system to read a primary volume filesystem which would otherwise be unrecognizable by the operating system. This data access API executes in a non-privileged user mode, allowing its execution without requiring privileged kernel mode access. Use of an overlay comprising a commonly recognized format, for example a FAT volume, thus renders the primary filesystem on the volume independent of a source system. The discovery volume may also contain an information file for users, alerting them to the presence of data on the volume.","Cover files protect data in the primary filesystem when the primary filesystem is unrecognized by the accessing system. Cover files are file entries in the discovery volume filesystem which make it appear to the accessing system as though the discovery volume claims space actually used by the primary filesystem. Thus, while a discovery volume may actually utilize a small number of sectors on the disk, an accessing system may see the cover files of the discovery volume consuming the entire space.","When attempting to mount a disk containing a primary filesystem unrecognized by the accessing system, the accessing system will surface the discovery volume to the user. Based on the information presented in that discovery volume, a user may ascertain that another filesystem is present. Additionally, the presence of the discovery volume and cover files prevents an erroneous determination that the primary volume is \u201craw\u201d or unformatted and a resulting presentation of a prompt to reformat the volume while also preventing unwanted overwriting of otherwise unrecognizable data in the primary volume.","Thus, the discovery volume is visible to a wide array of accessing systems, the cover files prevent accidental overwrite of data otherwise unrecognizable by the accessing systems, and the data access API allows the accessing systems to access the primary volume storing primary data using a non-privileged user mode.","This summary introduces the subject matter described below in the Detailed Description. This summary is not intended to identify essential features of the claimed subject matter, nor is it intended for use in determining the scope of the claimed subject matter.","Introduction","As noted above, when a filesystem on a volume is unrecognized, a user will be unable to access the data stored in the volume and may even be prompted to reformat or otherwise erase the data stored on that volume which appears raw. This application describes an application programming interface (API) and system to provide access to data, independent of filesystem implementation, in a non-privileged user mode.","The data at the beginning of a volume of a computer readable storage medium, including an original filesystem boot region, is defined as a virtualized region. The virtualized region is first moved to another location in a primary volume. A discovery volume is then written to the recently vacated space at the beginning of the volume. The discovery volume boot region contains entries consistent with a widely recognized filesystem boot region, including cover files and pointers to the virtualized region. The cover files claim blocks used by the primary volume filesystem as being used in the discovery volume filesystem. In other words, the cover files make it appear to the accessing system as though the discovery volume uses space actually used by the primary filesystem. Thus, while a discovery volume may actually utilize a small number of sectors on the disk, an accessing system may see cover files of the discovery volume consuming the entire space. This makes the entire volume appear to be in use, preventing accidental formatting or inadvertent overwrites of data. Cover files also provide access to the underlying volume.","The discovery volume stores a data access application programming interface (API) configured to allow the operating system of the accessing system to recognize a filesystem, which would otherwise be unrecognizable by the accessing operating system. This data access API executes in a non-privileged user mode, allowing its execution without requiring privileged kernel mode access, which may be restricted because of security policies or other concerns.","The discovery volume may also contain one or more information files describing the underlying primary filesystem. The information files may be visible to users and contain data which is human-readable, machine-readable, or both, as to the nature of the other volumes on the disk.","In one implementation, FAT format may be used for the discovery volume filesystem. Because of the FAT format's wide support, the discovery volume would be visible across a wide range of platforms and operating systems. However, any filesystem may be utilized which provides the desired visibility commonality across potential accessing systems.","Thus, when an accessing system attempts to mount a physical disk containing an unrecognizable primary volume, the accessing system will find the discovery volume accessible. The presence of the discovery volume prevents the accessing system from prompting the user to reformat the volume. The presence of the cover files prevents an inadvertent overwrite of data on the unsurfaced (that is, an unrecognized) primary volume, while the data access API gives an accessing system the ability to recognize and access the primary volume in a non-privileged user mode.","Illustrative Storage Device Sharing Environment",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","102","104","104","106"]},"Storage device  may be any computer-readable storage medium including random access memory (RAM), read-only memory (ROM), electrically erasable programmable read-only memory (EEPROM), flash memory or other solid-state memory technology, compact disk read-only memory (CD-ROM), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computing device. For example, storage device  may be a removable flash memory drive or a removable hard drive which the user may carry to other computers.","Stored on storage device  is a discovery volume  which contains a primary volume . Discovery volume  is hidden, because primary volume  is recognized and thus accessible by operating system A. Within discovery volume  is primary volume . Discovery volume  comprises a data access API  and a cover file . Within primary volume  is primary data . Primary data  may comprise data stored by computer  or other computers and may include data files such as documents, multimedia files, etc.","Computer system  running operating system \u201cB\u201d is then connected to storage device . Operating systems A and B may be different operating systems, or different versions of the same operating system. In the illustrated example, operating system B on computer  is unable to recognize the filesystem used by operating system A of computer , as shown at . Thus computer  cannot access the primary volume . However, operating system B on computer  is able to access discovery volume  because it uses a filesystem which is visible to operating system B. Thus discovery volume  is visible while primary volume  is not.","When computer  executes the data access API  in non-privileged user mode , the primary volume  and primary data  are now accessible along with the discovery volume  and its contents, as shown at .",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 3"],"b":["200","200","202","204","204","202","206","206","208","106","202","208","108","108","114","210","110","210","212","212","110"]},"Also stored on discovery volume  is data access API , which may be executed in a non-privileged user mode  of operating system  to allow access to primary data .","Discovery Volume Containing a Primary Volume",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3","b":["300","300","210","108","302","212","110","304","306","114"]},"At , an information file may also be present within the discovery volume . This information file may be visible to users and contain human-readable information, machine-readable information, or both, as to the nature of the primary volume on the disk. This information file may be stored in plain text, hypertext markup language (HTML), or other suitable file format. The information file may contain a warning to users that the primary volume contains data, and refer them to a specific Internet address for technical support.","At , the data access API  stored within discovery volume  gives an accessing system the ability to recognize and access the primary volume  and primary data  when executed in a non-privileged user mode  of the operating system . Within primary volume  is the stash file containing the relocated boot regions of the primary filesystem .","Where the discovery volume file structure uses a FAT format, within the virtualized boot region  additional information such as a complete BIOS parameter block (BPB)  and associated fields may be present. Because some portions of the boot region are not critical for FAT functionality, other data may be stored therein including pointers to metadata of components utilizing the discovery volume. As a result, these fields may be used to store information necessary for the primary volume or other filesystem volumes to function while still leaving a functional FAT discovery volume. When the FAT structure is in use, the boot region contains fields representing the FAT file structure within the discovery volume.","When the FAT file structure is used by the discovery volume, the VolumeLabel field (0x2b) may be updated to contain \u201cEncryptedVolume,\u201d or a similar string useful to identify the filesystem of the primary volume .","Illustrative Data Access API",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","402","112","112","404","406","112","206","106","402","112"]},"The access library module  provides the ability to access a primary volume  in a non-privileged user mode of an operating system. Illustrative code for one implementation of the cover file creation module  in the C language follows:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\/\/"},{"entry":"\/\/ Function implemented by caller that reads a sector run."},{"entry":"\/\/"},{"entry":"\/\/ The umfs library will call into this function to read ulByteCount"},{"entry":"\/\/ bytes from the backing store, starting at byte offset ullStartOffset,"},{"entry":"\/\/ and place the read data in pvReadBuffer."},{"entry":"\/\/"},{"entry":"\/\/ ulByteCount and ullStartOffset will always be sector aligned, and"},{"entry":"\/\/ pvReadBuffer will device aligned by umfs before being passed to"},{"entry":"\/\/ the function."},{"entry":"\/\/"},{"entry":"\/\/ pvContext will point to the context supplied to the library when"},{"entry":"\/\/ VOLUME_CONTEXT was passed to the library."},{"entry":"\/\/"},{"entry":"\/\/ pvReadBuffer will be large enough to contain the requested data."},{"entry":"\/\/"},{"entry":"\/\/ Any error HRESULT returned from this function will be passed back up"},{"entry":"\/\/ the call stack."},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"CDECL"},{"entry":"HRESULT"},{"entry":"(*PFN_UMFS_READ_SECTOR)("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003PVOID","pvContext,"]},{"entry":["\u2003\u2003ULONGLONG","ullStartOffset,"]},{"entry":["\u2003\u2003ULONG","ulByteCount,"]},{"entry":["\u2003\u2003PVOID","pvReadBuffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Function implemented by caller that writes a sector run."},{"entry":"\/\/"},{"entry":"\/\/ The umfs library will call into this function to write ulByteCount"},{"entry":"\/\/ bytes into the backing store, starting at byte offset ullStartOffset,"},{"entry":"\/\/ for the data in pvWriteBuffer."},{"entry":"\/\/"},{"entry":"\/\/ ulByteCount and ullStartOffset will always be sector aligned, and"},{"entry":"\/\/ pvReadBuffer will device aligned by umfs before being passed to"},{"entry":"\/\/ the function."},{"entry":"\/\/"},{"entry":"\/\/ pvContext will point to the context supplied to the library when"},{"entry":"\/\/ VOLUME_CONTEXT was passed to the library."},{"entry":"\/\/"},{"entry":"\/\/ pvWriteBuffer will be large enough to contain the data to be written."},{"entry":"\/\/"},{"entry":"\/\/ Any error HRESULT returned from this function will be passed back up"},{"entry":"\/\/ the call stack."},{"entry":"\/\/"},{"entry":"\/\/ NOTE: Since the V1 library will not support write, it is OK not to"},{"entry":"\/\/\u2003\u2003\u2003\u2003implement this."},{"entry":"\/\/"},{"entry":"typedef"},{"entry":"CDECL"},{"entry":"HRESULT"},{"entry":"(*PFN_UMFS_WRITE_SECTOR)("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003PVOID","pvContext,"]},{"entry":["\u2003\u2003ULONGLONG","ullStartOffset,"]},{"entry":["\u2003\u2003ULONG","ulByteCount,"]},{"entry":["\u2003\u2003PVOID","pvWriteBuffer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Function implemented by caller for control messages sent down from UMFS."},{"entry":"\/\/"},{"entry":"\/\/ Though currently unused, the umfs library will call into this function for"},{"entry":"\/\/ a variety of control and informational messages."},{"entry":"\/\/"},{"entry":"\/\/ pvContext will point to the context supplied to the library when"},{"entry":"\/\/ VOLUME_CONTEXT was passed to the library."},{"entry":"\/\/"},{"entry":"\/\/ ulControlMessage will indicate the type of message (none currently defined)."},{"entry":"\/\/"},{"entry":"\/\/ ulControlPacketSize is the count in bytes of a control packet attached to the message."},{"entry":"\/\/"},{"entry":"\/\/ pControlPacket is the packet itself, which may be NULL if there is no packet for this type of"},{"entry":"message."},{"entry":"\/\/"},{"entry":"\/\/ Any error HRESULT returned from this function will be passed back up"},{"entry":"\/\/ the call stack."},{"entry":"\/\/"},{"entry":"\/\/ NOTE: this interface is currently unused."},{"entry":"typedef struct _UMFS_VOLUME_CONTEXT {"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Pointers to the read and write functions."},{"entry":"\u2003\u2003\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003PFN_UMFS_READ_SECTOR","pfnReadSector;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ It is ok to specify NULL for pfnWriteSector, this means"},{"entry":"\u2003\u2003\/\/ the volume will be mounted read-only."},{"entry":"\u2003\u2003\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003PFN_UMFS_WRITE_SECTOR","pfnWriteSector;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ User supplied context parameter."},{"entry":"\u2003\u2003\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003PVOID","pvContext;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Physical parameters for the backing store."},{"entry":"\u2003\u2003\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003ULONG","ulSectorSize;"]},{"entry":["\u2003\u2003ULONGLONG","ullVolumeSize; \u2003\u2003\/\/ in bytes"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} UMFS_VOLUME_CONTEXT, *PUMFS_VOLUME_CONTEXT;"},{"entry":"typedef struct _UMFS_CONTEXT_STRUCT *UMFS_CONTEXT,**PUMFS_CONTEXT;"},{"entry":"typedef struct _UMFS_HANDLE_STRUCT\u2003*UMFS_HANDLE,**PUMFS_HANDLE;"},{"entry":"typedef struct _UMFS_ENUM_STRUCT\u2003*UMFS_ENUM_CONTEXT,**PUMFS_ENUM_CONTEXT;"},{"entry":"\/\/"},{"entry":"\/\/ Function to initialize the library."},{"entry":"\/\/"},{"entry":"\/\/ The caller must allocate and initialize a UMFS_VOLUME_CONTEXT structure"},{"entry":"\/\/ and pass it in. The UMFS_VOLUME_CONTEXT structure must stay valid for"},{"entry":"\/\/ as long as you use the library."},{"entry":"\/\/"},{"entry":"\/\/ It may be freed only after UmFsUninitialize is called."},{"entry":"\/\/"},{"entry":"\/\/ The function will allocate and return an opaque context structure"},{"entry":"\/\/ representing the mounted filesystem."},{"entry":"\/\/"},{"entry":"\/\/ If the volume is unrecognized, this function will return failure"},{"entry":"\/\/ HRESULT_FROM_WIN32( ERROR_UNRECOGNIZED_VOLUME )"},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsInitialize("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003_inout","PUMFS_VOLUME_CONTEXT","pVolumeContext,"]},{"entry":["\u2003\u2003_out","PUMFS_CONTEXT","pFilesystemContext"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Uninitializes the UmFs library."},{"entry":"\/\/"},{"entry":"\/\/ Pass the address of the context, it will be cleaned up and then NULL'd"},{"entry":"\/\/ on your behalf."},{"entry":"\/\/"},{"entry":"\/\/ If you have outstanding handles open, you will get"},{"entry":"\/\/ HRESULT_FROM_WIN32(ERROR_DEVICE_IN_USE)"},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsUninitialize("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003_inout_opt","PUMFS_CONTEXT","pFilesystemContext"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Enumeration describing the currently supported filesystems in the"},{"entry":"\/\/ library."},{"entry":"\/\/"},{"entry":"enum UMFS_TYPE {"},{"entry":"\u2003\u2003UMFS_TYPE_UNSUPPORTED,"},{"entry":"\u2003\u2003UMFS_TYPE_FAT16,"},{"entry":"\u2003\u2003UMFS_TYPE_FAT32,"},{"entry":"\u2003\u2003UMFS_TYPE_EXFAT,"},{"entry":"};"},{"entry":"typedef struct _UMFS_PROPERTIES {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"259pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003UMFS_TYPE","eFsType;"]},{"entry":["\u2003\u2003WCHAR","wszVolumeLabel[MAX_PATH+1];"]},{"entry":["\u2003\u2003ULONG","ulSerialNumber;"]},{"entry":["\u2003\u2003ULONG","ulClusterSize;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} UMFS_PROPERTIES, *PUMFS_PROPERTIES;"},{"entry":"\/\/"},{"entry":"\/\/ Function to get filesystem properties."},{"entry":"\/\/"},{"entry":"\/\/ Pass it an empty FS_PROPERTIES struct and it will fill it out."},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsQueryFilesystemProperties("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003_inout","UMFS_CONTEXT","FilesystemContext,"]},{"entry":["\u2003\u2003_out","PUMFS_PROPERTIES","pUMFSProperties"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Function to open a directory or a file by name."},{"entry":"\/\/"},{"entry":"\/\/ !!!!!!!!"},{"entry":"\/\/"},{"entry":"\/\/ Note that opening by filename is unimplemted in V1 of the library."},{"entry":"\/\/ Please use UmFsOpenFileById."},{"entry":"\/\/"},{"entry":"\/\/ !!!!!!!!"},{"entry":"\/\/"},{"entry":"\/\/ All directory opens are relative to ParentDirectoryHandle, although may be implemented"},{"entry":"\/\/ to allow open via absolute path."},{"entry":"\/\/"},{"entry":"\/\/ . and .. will not be present in the directory listing."},{"entry":"\/\/"},{"entry":"\/\/ A file or directory may be opened more than once."},{"entry":"\/\/"},{"entry":"\/\/ A NULL ParentDirectoryHandle and a NULL pwszName indicates you"},{"entry":"\/\/ want to open the root directory."},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsOpenFileByName("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003_inout","UMFS_CONTEXT","FilesystemContext,"]},{"entry":["\u2003\u2003_inout","UMFS_HANDLE","ParentDirectoryHandle,"]},{"entry":["\u2003\u2003_in","WCHAR","*pwszName,"]},{"entry":["\u2003\u2003_out","PUMFS_HANDLE","pHandle"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Function to open a directory or a file."},{"entry":"\/\/"},{"entry":"\/\/ All directory opens are relative to ParentDirectoryHandle, although may be implemented"},{"entry":"\/\/ to allow open via absolute path."},{"entry":"\/\/"},{"entry":"\/\/ . and .. will not be present in the directory listing."},{"entry":"\/\/"},{"entry":"\/\/ A file or directory may be opened more than once."},{"entry":"\/\/"},{"entry":"\/\/ A NULL ParentDirectoryHandle and a NULL pwszName indicates you"},{"entry":"\/\/ want to open the root directory."},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsOpenFileById("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003_inout","UMFS_CONTEXT","FilesystemContext,"]},{"entry":["\u2003\u2003_inout","UMFS_HANDLE","ParentDirectoryHandle,"]},{"entry":["\u2003\u2003_in","ULONGLONG","ullFileId,"]},{"entry":["\u2003\u2003_out","PUMFS_HANDLE","pHandle"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Cleans up any handle returned from the UmFs library."},{"entry":"\/\/"},{"entry":"\/\/ Pass the address of the handle, it will be cleaned up and then NULL'd on"},{"entry":"\/\/ your behalf."},{"entry":"\/\/"},{"entry":"\/\/ Returns S_OK on success."},{"entry":"\/\/"},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsCloseFile("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003_inout_opt","PUMFS_HANDLE","pHandle"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Structure describing a file."},{"entry":"\/\/"},{"entry":"typedef struct _UMFS_FILE_ENTRY {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003ULONG","ulFileAttributes;",{}]},{"entry":["\u2003\u2003LARGE_INTEGER","liFileSize;",{}]},{"entry":["\u2003\u2003FILETIME","ftCreated;",{}]},{"entry":["\u2003\u2003FILETIME","ftModified;",{}]},{"entry":["\u2003\u2003FILETIME","ftAccessed;",{}]},{"entry":["\u2003\u2003ULONGLONG","ullFileId;","\/\/ file ID"]},{"entry":["\u2003\u2003WCHAR","wszFileName[MAX_PATH+1];","\/\/ null terminated"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} UMFS_FILE_ENTRY, PUMFS_FILE_ENTRY;"},{"entry":"\/\/"},{"entry":"\/\/ Returns the properties of a file or directory by handle."},{"entry":"\/\/"},{"entry":"\/\/ Can be used to determine if a file or directory was opened by looking at"},{"entry":"\/\/ UMFS_FILE_ENTRY::ulFileAttributes."},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsQueryFileInformation("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003_inout","UMFS_HANDLE","Handle,"]},{"entry":["\u2003\u2003_out","UMFS_FILE_ENTRY","FileInformation"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Function that returns the contents of a directory."},{"entry":"\/\/"},{"entry":"\/\/ It is designed to be called in a loop until all the directory entries have"},{"entry":"\/\/ been enumerated."},{"entry":"\/\/"},{"entry":"\/\/ The caller must allocate pFileEntryBuffer."},{"entry":"\/\/"},{"entry":"\/\/ The buffer size is passed in cbFileEntryBuffer. The buffer must be sizeof(UMFS_FILE_ENTRY)"},{"entry":"\/\/"},{"entry":"\/\/ The function will fill out pFileEntryBuffer with a single fixed sized UMFS_FILE_ENTRY"},{"entry":"\/\/ structure."},{"entry":"\/\/"},{"entry":"\/\/ The function will allocate and return pEnumContext, which is an opaque"},{"entry":"\/\/ structure that is used to track the enumeration context."},{"entry":"\/\/"},{"entry":"\/\/ pEnumContext should be freed with UmFsCleanupEnumContext."},{"entry":"\/\/"},{"entry":"\/\/ Passing *pEnumContext == NULL starts the enumeration at the beginning"},{"entry":"\/\/ of the directory."},{"entry":"\/\/"},{"entry":"\/\/ The function will return S_OK on success if the buffer has been filled"},{"entry":"\/\/ and there are more files remaining. You must call it again to get the next"},{"entry":"\/\/ file record, passing in the EnumContext to continue at the point"},{"entry":"\/\/ it previously left off."},{"entry":"\/\/"},{"entry":"\/\/ The function will return S_FALSE, when the enumeration is complete and"},{"entry":"\/\/ there are no more entries left."},{"entry":"\/\/"},{"entry":"\/\/ The function will return any failure HRESULT on failure."},{"entry":"\/\/"},{"entry":"#define UMFS_ENUM_RESTART \u2003\u2003\u2003\u20030x1"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsQueryDirectoryFileList("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003_inout","UMFS_HANDLE",{}]},{"entry":["DirectoryHandle,",{},{}]},{"entry":["\u2003\u2003_in","ULONG","ulFlags,"]},{"entry":["\u2003\u2003_out","PUMFS_FILE_ENTRY","pFileEntry,"]},{"entry":["\u2003\u2003_inout","PUMFS_ENUM_CONTEXT","pEnumContext"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Cleans up any enumeration context structure returned from the UmFs library."},{"entry":"\/\/"},{"entry":"\/\/ Pass the address of the enum context, it will be cleaned up and then NULL'd on"},{"entry":"\/\/ your behalf."},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsCleanupEnumContext("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003_inout_opt","PUMFS_ENUM_CONTEXT","pEnumContext"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"336pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003);"},{"entry":"\/\/"},{"entry":"\/\/ Returns a buffer of data from the file."},{"entry":"\/\/"},{"entry":"\/\/ The offset and length must be sector aligned."},{"entry":"\/\/"},{"entry":"\/\/ HRESULT S_OK is returned on success and the buffer is full."},{"entry":"\/\/"},{"entry":"\/\/ HRESULT S_FALSE is returned if the buffer is not full and EOF has been hit."},{"entry":"\/\/"},{"entry":"\/\/ HRESULT error on failure."},{"entry":"\/\/"},{"entry":"EXTERN_C"},{"entry":"HRESULT"},{"entry":"UmFsRead("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003_inout","UMFS_HANDLE","FileHandle,",{}]},{"entry":["\u2003\u2003_in","ULONGLONG","ullByteOffset,","\/\/"]},{"entry":["byte offset into the file",{},{},{}]},{"entry":["\u2003\u2003_in","ULONG","cbLengthRequested,","\/\/"]},{"entry":["length in bytes",{},{},{}]},{"entry":["\u2003\u2003_out_bcount_part(cbLengthRequested, *pulBytesRead)","PBYTE","pbReadBuffer,","\/\/"]},{"entry":["pointer to buffer",{},{},{}]},{"entry":["\u2003\u2003_out","PULONG","pulBytesRead","\/\/"]},{"entry":["bytes actually read",{},{},{}]},{"entry":"\u2003\u2003);"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The discovery volume management module  builds a discovery volume and associated cover files. Illustrative code for one implementation of the discovery volume management module  in the C language follows:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct _DISCOVERY_VOLUME_FILE_INFORMATION {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003WCHAR \u2003\u2003sourcePath[MAX_PATH +1];","\/\/ path to source file, NULL terminated"]},{"entry":["\u2003\u2003WCHAR \u2003\u2003targetFile[MAX_PATH +1];","\/\/ name of target file, NULL terminated"]},{"entry":[{},"\/\/ (filename only, must be in root directory)"]},{"entry":["\u2003\u2003DWORD \u2003\u2003fileAttributes;","\/\/ file attributes."]},{"entry":["\u2003\u2003LARGE_INTEGER\u2003byteOffset;","\/\/ filled out with the byte offset of the file"]},{"entry":[{},"\/\/ inside the image"]},{"entry":["\u2003\u2003LARGE_INTEGER\u2003allocationSize;","\/\/ size in bytes of the allocation for the file"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} DISCOVERY_VOLUME_FILE_INFORMATION, *PDISCOVERY_VOLUME_FILE_INFORMATION;"},{"entry":"HRESULT"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CreateFAT32DiscoveryVolume (",{},{}]},{"entry":[{},"ULONGLONG","ullVolumeSize,"]},{"entry":[{},"ULONG","ulSectorSize,"]},{"entry":["\u2003\u2003_in_ecount(nFileInfo)","PDISCOVERY_VOLUME_FILE_INFORMATION","pFileInfo,"]},{"entry":[{},"SIZE_T","nFileInfo,"]},{"entry":[{},"DWORD","cbRecognitionInfo,"]},{"entry":[{},"DWORD","*pdwOffsetRecognitionInfo,"]},{"entry":[{},"HANDLE","hTargetFile"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":")"},{"entry":"\/*"},{"entry":"Description:"},{"entry":"Constructs a file containing an image of a FAT32 discovery volume."},{"entry":"The contents written to hTargetFile are the start of a FAT32 volume of volumeSize bytes. This includes"},{"entry":"the boot area, FATs, root directory and any files supplied for inclusion in the filesystem. If this"},{"entry":"image is then written to the leading bytes of a real volume of size volumeSize the result is a valid"},{"entry":"FAT32 volume with the following properties:"},{"entry":"- \u2003\u2002The constructed volume will have a cluster size equal to or smaller than the clusterSize specified"},{"entry":"(which must be the clustersize of the original volume)."},{"entry":"- \u2003\u2002The smallest possible volume is 64MB."},{"entry":"- \u2003\u2002The largest possible volume is 2TB @ with 32k clusters (512 byte sectors)."},{"entry":"- \u2003\u2002The files in the fileInfo structs appear in the root directory with names set to"},{"entry":"DISCOVERY_VOLUME_FILE_INFORMATION.targetFile"},{"entry":"- \u2003\u2002All the bytes in the volume beyond the constructed area are allocated to cover-files."},{"entry":"- \u2003\u2002The cover-files appear in the root directory."},{"entry":"- \u2003\u2002The cover-files have a prefix \u201cCOV \u201d"},{"entry":"- \u2003\u2002The cover-files are numbered from 0000 to 9999."},{"entry":"- \u2003\u2002The cover-files will each have the extension \u201c. ER\u201d <- note the space"},{"entry":"- \u2003\u2002Each cover file is up to 2{circumflex over (\u2009)}32 bytes - (1 cluster) bytes in size."},{"entry":"- \u2003\u2002All files are read\/only. The cover-files are also hidden & system."},{"entry":"- \u2003\u2002There is no free space left on the volume."},{"entry":"- \u2003\u2002There is at least 8KB of free directory entries (for future servicing)."},{"entry":"Parameters:"},{"entry":"volumeSize - must contain the volume size in bytes of the target volume."},{"entry":"sectorSize - must contain the current sectorsize in bytesof the target volume."},{"entry":"clusterSize - must contain the current clustersize in bytes of the target volume."},{"entry":"fileInfo - pointer to an array of DISCOVERY_VOLUME_FILE_INFORMATION structs."},{"entry":"nFileInfo - count of DISCOVERY_VOLUME_FILE_INFORMATION structs."},{"entry":"cbRecognitionInfo - the length in bytes of the recognition info, up to 40 bytes."},{"entry":"pdwOffsetRecognitionInfo - returns the offset into the volume file where it is safe to write"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003this recognition info"},{"entry":"hTarget - handle to the target file where the volume is created."},{"entry":"Return Value:"},{"entry":"On success returns S_OK, the image has been written to hTargetFile."},{"entry":"On failure returns a failure HRESULT. hTargetFile will be incomplete and should be deleted."},{"entry":"*\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5","b":["500","502","110","212","116","106","504","406","212","504","110"]},"At , the primary volume is shown after moving the original boot area and creating a discovery volume . Within discovery volume  is virtualized boot region , FAT , root directory , information file , data access API , and other components for the functionality of the discovery volume filesystem. The remainder of primary volume  comprises primary data , free clusters , and original boot area , which may be stored in a single stash file. This single stash file may be contiguous within the primary volume, and may contain additional space for future use .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6","b":["600","602","108","114","116","504","114"]},"At , the apparent volume is shown after executing the data access API in non-privileged user mode. The same operating system of  above is now able to access the discovery volume, the primary data , free clusters , and the original boot area . The original boot area  may be hidden, read only, have access restricted by the data access API, or otherwise be protected  from accidental change.","Appearance of Primary Volume with and without Cover Files",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 7","b":["700","702","116","212","504","108","210","108","210","212","212","108"]},"At , when the discovery volume is surfaced and no cover files are present, the portions of the volume containing the primary data , original boot area  and free clusters  appear to be apparently unallocated (or \u201craw\u201d) space . This unallocated space  may result in a prompt to a user to format, store files within, or make some other undesirable change to the volume, which would damage the actual data stored in a filesystem unrecognized by the accessing system.","At , cover file entries  are present in the discovery volume filesystem (for example, the FAT file listing). A cover file(s) presents a user with a discovery volume which, at , is apparently full. Thus, no prompt for reformatting is presented and, with no free space being shown as available in the discovery volume filesystem, the actual data under the cover files cannot be overwritten.","In another implementation, a discovery volume may be configured where the discovery file system does not extend over the entire volume. In this implementation, there are no cover files in the discovery volume and the discovery volume does not extend over the entire space allocated for the primary volume and reports itself as only consuming the space in the virtualized region. This implementation provides protection from accidental overwriting where an operating system does not typically permit multiple file systems within one volume.","This implementation may be used when non-privileged access to the primary file system through the cover files is unnecessary. For example, there may be a file in the discovery volume that describes to the user how to find and install software to enable access, or a tool may be present that will rewrite, transform, and\/or convert the data structures on the disk to enable the accessing system to surface the data stored in the primary file system. In one implementation of this, the changes made by such a tool may be permanent, and the discovery volume may be erased in the process.","Building a Discovery Volume",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 8","b":["800","406"]},"At , a discovery volume is initialized in memory. This discovery volume uses a filesystem which is visible to other operating systems. For example, the FAT filesystem is widely recognized across multiple operating systems and may be used.","At , a discovery volume boot region is initialized within the discovery volume. This discovery volume boot region is a virtualized boot region, that is, it contains the boot region information of the discovery volume filesystem, while including pointers to the primary volume filesystem. When the primary volume filesystem is recognized, the pointer allows the accessing system to redirect to the original boot area stored in the volume. When the primary volume filesystem is not recognized, the virtualized boot region provides access to the discovery volume filesystem.","At , the original real boot area is moved to a new location in the primary volume. For example, this location may be a single contiguous stash file, which is located anywhere except at the beginning of the volume in the boot sector(s).","At , a pointer is constructed in the discovery volume boot region, which points to the original boot area which contains original boot regions.","At , the discovery volume is written to the beginning of the volume. This placement in the beginning of the volume insures that an operating system will read the discovery volume boot regions, rather than the original boot area.","At , cover file entries are written to the discovery volume filesystem. These cover files are used to make the volume appear to be full of data when surfaced by the discovery volume.","At , a data access API including the access library module  is written to the discovery volume. Placement of the data access API into the discovery volume makes it visible and accessible to an accessing system which can read the discovery volume filesystem but not the primary filesystem. This data access API is configured to execute in user-mode and allow an operating system which cannot natively recognize the primary filesystem to recognize and access the primary volume data.","Accessing Primary Data on a Primary Volume",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 9","b":"900"},"At , a virtualized boot region is read by the operating system.","At , when the primary volume filesystem is recognized by the operating system and, at , the primary volume and primary data are accessible.","When, at , the primary volume filesystem is not recognized, at , the discovery volume is presented to the user and the discovery volume boot region is read. Cover files make the primary volume appear to be full. Primary data in the primary volume remains inaccessible.","At , when the data access API stored in the discovery volume is executed in the non-privileged user mode of the operating system, at , the data access API access library module provides the operating system with the functionality to access the primary volume and the primary data within.","Although specific details of illustrative methods are described with regard to the figures and other flow diagrams presented herein, it should be understood that certain acts shown in the figures need not be performed in the order described, and may be modified, and\/or may be omitted entirely, depending on the circumstances. As described in this application, modules and engines may be implemented using software, hardware, firmware, or a combination of these. Moreover, the acts and methods described may be implemented by a computer, processor or other computing device based on instructions stored on memory, the memory comprising one or more computer-readable storage media (CRSM).","The CRSM may be any available physical media accessible by a computing device to implement the instructions stored thereon. CRSM may include, but is not limited to, random access memory (RAM), read-only memory (ROM), electrically erasable programmable read-only memory (EEPROM), flash memory or other solid-state memory technology, compact disk read-only memory (CD-ROM), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computing device."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The disclosure is made with reference to the accompanying figures. In the figures, the left most reference number digit identifies the figure in which the reference number first appears. The use of the same reference numbers in different figures indicates similar or identical terms.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
