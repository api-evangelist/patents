---
title: Apparatus and method for avoiding deadlocks in a multithreaded environment
abstract: An apparatus and method for avoiding deadlocks in a multithreaded environment is provided. The apparatus and method provide a mechanism by which multiple threads are allowed to call a method virtually simultaneously without experiencing the problems regarding multiple compilations of the same method or a lock being held by one thread while other threads wait on the lock. With the apparatus and method, the first thread to call a method is the thread that causes the method to be compiled. Subsequent calls to the method, during a period of time in which the method is being compiled, are redirected to the JVM interpreter, thereby avoiding any deadlock situation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06883165&OS=06883165&RS=06883165
owner: International Business Machines Corporation
number: 06883165
owner_city: Armonk
owner_country: US
publication_date: 20000928
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention is related to commonly assigned and co-pending U.S. patent applications Ser. No 09\/617,876 entitled \u201cAPPARATUS AND METHODS FOR IMPROVED DEVIRTUALIZATION OF METHOD CALLS\u201d, Ser No. 09\/617,973 entitled \u201cAPPARATUS AND METHOD FOR IMPLEMENTING SWITCH INSTRUCTIONS IN AN IA64 ARCHITECTURE\u201d, Ser. No. 09\/671,877 entitled \u201cAPPARATUS AND METHOD FOR DETECTING AND HANDLING EXCEPTIONS\u201d, Ser. No. 09\/671,771 entitled \u201cAPPARATUS AND METHOD FOR VIRTUAL REGISTER MANAGEMENT USING PARTIAL DATA FLOW ANALYSIS FOR JUST-IN-TIME COMPILATION\u201d, Ser. No. 09\/671,873 entitled \u201cAPPARATUS AND METHOD FOR AN ENHANCED INTEGER DIVIDE IN AN IA64 ARCHITECTURE\u201d, Ser. No. 09\/671,874 entitled \u201cAPPARATUS AND METHOD FOR CREATING INSTRUCTION GROUPS FOR EXPLICITLY PARALLEL ARCHITECTURES\u201d, and Ser. No. 09\/671,875 entitled \u201cAPPARATUS AND METHOD FOR CREATING INSTRUCTION BUNDLES IN AN EXPLICITLY PARALLEL ARCHITECTURE\u201d, filed on even date herewith and hereby incorporated by reference.","1. Technical Field","The present invention is directed to an apparatus and method for avoiding deadlocks in a multithreaded environment.","2. Description of Related Art","Java Just-In-Time (JIT) compilers compile Java bytecode to native instructions of a target processor. This can occur as late as when a method is first executed. Java is a multithreaded language and thus, it is possible that two or more threads of execution could simultaneously attempt to execute the same method for the first time in the system. If the method was compiled by both threads then time and space would be wasted. A lock may be used to prevent one thread from compiling a method which has already started to be complied by another thread. However, improper use of locks may lead to a deadlock situation.","For example, when a method is compiled, the JIT compiler may need to resolve some constants which involve calling back into the Java Virtual Machine (JVM). It is possible that more Java code will be executed in the process of resolving the constant, particularly if a class loader is involved. If the process of constant resolution calls the same method that is being compiled then a problem arises because the half-compiled method cannot be executed. Prior art solutions to this deadlock situation typically involve embeddeding lock acquisition calls in the compiled code and removing them as compilation progresses.","Thus, it would be beneficial to have an apparatus and method for avoiding simultaneous compilation of the same method by two different execution threads. It would further be beneficial to have an apparatus and method for avoiding simultaneous compilation while also avoiding deadlocks in a multithreaded environment.","An apparatus and method for avoiding deadlocks in a multithreaded environment is provided. The apparatus and method provide a mechanism by which multiple threads are allowed to call a method virtually simultaneously without experiencing the problems regarding multiple compilations of the same method or a lock being held by one thread while other threads wait on the lock.","With the apparatus and method of the present invention, the first thread to call a method is the thread that causes the method to be compiled. Subsequent calls to the method, during a period of time in which the method is being compiled, are redirected to the JVM interpreter, thereby avoiding any deadlock situation.","The redirection of subsequent calls to the method is facilitated by the setting of pointers in fields of a method block to redirect calls to the JVM interpreter. Once the method is compiled, the fields of the method block are set so that subsequent calls to the method are redirected to the compiled method code. Other features and advantages of the present invention will be described in, or will be apparent to those of ordinary skill in the art in view of, the following detailed description of the preferred embodiments.","With reference now to the figures, and in particular with reference to , a pictorial representation of a distributed data processing system in which the present invention may be implemented is depicted. Distributed data processing system  is a network of computers in which the present invention may be implemented. Distributed data processing system  contains a network , which is the medium used to provide communications links between various devices and computers connected together within distributed data processing system . Network  may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone connections.","In the depicted example, a server  is connected to network  along with storage unit . In addition, clients , , and  also are connected to a network . These clients , , and  may be, for example, personal computers or network computers. For purposes of this application, a network computer is any computer, coupled to a network, which receives a program or other application from another computer coupled to the network. In the depicted example, server  provides data, such as boot files, operating system images, and applications to clients -. Clients , , and  are clients to server . Distributed data processing system  may include additional servers, clients, and other devices not shown. In the depicted example, distributed data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the TCP\/IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational, and other computer systems, that route data and messages. Of course, distributed data processing system  also may be implemented as a number of different types of networks, such as, for example, an Intranet or a local area network.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},"With reference now to , a block diagram of a data processing system which may be implemented as a server, such as server  in , is depicted in accordance to the present invention. Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors  and  connected to system bus . Alternatively, a single processor system may be employed. Also connected to system bus  is memory controller\/cache , which provides an interface to local memory . I\/O Bus Bridge  is connected to system bus  and provides an interface to I\/O bus . Memory controller\/cache  and I\/O Bus Bridge  may be integrated as depicted.","Peripheral component interconnect (PCI) bus bridge  connected to I\/O bus  provides an interface to PCI local bus . A modem  may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Communications links to network computers - in  may be provided through modem  and network adapter  connected to PCI local bus  through add-in boards.","Additional PCI bus bridges  and  provide interfaces for additional PCI buses  and , from which additional modems or network adapters may be supported. In this manner, server  allows connections to multiple network computers. A memory mapped graphics adapter  and hard disk  may also be connected to I\/O bus  as depicted, either directly or indirectly.","Those of ordinary skill in the art will appreciate that the hardware depicted in  may vary. For example, other peripheral devices, such as optical disk drive and the like also may be used in addition or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.","The data processing system depicted in  may be, for example, an IBM RISC\/System 6000 system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced Interactive Executive (AIX) operating system.","With reference now to , a block diagram of a data processing system in which the present invention may be implemented is illustrated. Data processing system  is an example of a client computer. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Micro Channel and ISA may be used. Processor  and main memory  are connected to PCI local bus  through PCI Bridge . PCI Bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus  may be made through direct component interconnection or through add-in boards. In the depicted example, local area network (LAN) adapter , SCSI host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter (A\/V)  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . SCSI host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM  in the depicted example. Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in FIG. B. The operating system may be a commercially available operating system such as OS\/, which is available from International Business Machines Corporation.","An object oriented programming system such as Java may run in conjunction with the operating system and may provide calls to the operating system from Java programs or applications executing on data processing system . Instructions for the operating system, the object oriented operating system, and applications or programs are located on storage devices, such as hard disk drive  and may be loaded into main memory  for execution by processor . Hard disk drives are often absent and memory is constrained when data processing system  is used as a network client.","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. For example, other peripheral devices, such as optical disk drives and the like may be used in addition to or in place of the hardware depicted in FIG. B. The depicted example is not meant to imply architectural limitations with respect to the present invention. For example, the processes of the present invention may be applied to a multiprocessor data processing system.","The present invention provides an apparatus and method for avoiding deadlocks in a multithreaded environment. Although the present invention may operate on a variety of computer platforms and operating systems, it may also operate within a Java runtime environment. Hence, the present invention may operate in conjunction with a Java virtual machine (JVM) yet within the boundaries of a JVM as defined by Java standard specifications. In order to provide a context for the present invention, portions of the operation of a JVM according to Java specifications are herein described.","With reference now to , a block diagram illustrates the relationship of software components operating within a computer system that may implement the present invention. Java-based system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. JVM  is one software application that may execute in conjunction with the operating system. JVM  provides a Java run-time environment with the ability to execute Java application or applet , which is a program, servlet, or software component written in the Java programming language. The computer system in which JVM  operates may be similar to data processing system  or computer  described above. However, JVM  may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core. At the center of a Java run-time environment is the JVM, which supports all aspects of Java's environment, including its architecture, security features, mobility across networks, and platform independence.","The JVM is a virtual computer, i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement, with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example, all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.","The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM, which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format the compiled code is executable on many processors, given the presence of the Java run-time system.","The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code.","A JVM must load class files and execute the bytecodes within them. The JVM contains a class loader, which loads class files from an application and the class files from the Java application programming interfaces (APIs) which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.","One type of software-based execution engine is a Just-In-Time (JIT) compiler. With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for \u201cjitting\u201d a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs may interpret bytecodes or use other techniques, such as Just-In-Time compiling, to execute bytecodes. It is not uncommon for a JVM to interpret some methods and Just-In-Time compile others.","When an application is executed on a JVM that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","With reference now to , a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM  includes a class loader subsystem , which is a mechanism for loading types, such as classes and interfaces, given fully qualified names. JVM  also contains runtime data areas , execution engine , native method interface , and memory management . Execution engine  is a mechanism for executing instructions contained: in the methods of classes loaded by class loader subsystem . Execution engine  may be, for example, Java interpreter  or just-in-time compiler . Native method interface  allows access to resources in the underlying operating system. Native method interface  may be, for example, a Java native interface.","Runtime data areas  contain native method stacks , Java frames , PC registers , method area , and heap . These different data areas represent the organization of memory needed by JVM  to execute a program.","Java frames  are used to store the state of Java method invocations. When a new thread is launched, the JVM creates a new Java stack from which the thread will allocate Java Frames. A thread is a part of a program, i.e. a transaction or message, that can execute independently of other parts. In a multithreaded environment, multiple streams of execution may take place concurrently within the same program, each stream processing a different transaction or message.","A Java frame contains all the information pertaining to a single method invocation and is commonly partitioned into three regions. The first region holds all local variables including the input parameters. The second region is typically fixed in size and contains various pointers used by the interpreter including a pointer to the previous frame. The third region is the Java operand stack which is a FIFO stack that holds operands and results of bytecode operations. The operand stack is also used to pass parameters during invocation. The JVM performs only two operations directly on Java operand stacks: it pushes and pops stack items. These items may be object references or primitives such as integers or floating point values.","When the interpreter  invokes a Java method, the interpreter  saves the return PC, i.e. a bytecode pointer, in the current frame and makes an indirect call via a JVM invoker field in a method block of the Java method, as described in greater detail hereafter. Upon return from the JVM invoker, the interpreter fetches the current frame and resumes execution starting with the bytecode specified in the returnPC field. When an interpreted method completes, the current frame is discarded and the previous frame is made current.","Note that the JVM invoker field will point to different routines depending on the characteristics of the target method. For an interpreted method the JVM invoker routine allocates and initializes a Java frame and sets returnPC to the first bytecode of the called method. The new frame is made current and the JVM invoker returns to the interpreter to execute the method. For native and compiled code, the JVM invoker passes control to the called method and when a return is made to the interpreter the current frame is the same as when the call was made. By fetching the returnPC of the current frame, the interpreter resumes execution of the calling method. The JVM does not have any registers for holding intermediate values; any Java instruction that requires or produces an intermediate value uses the operand stack for holding the intermediate values. In this manner, the Java instruction set is well-defined for a variety of platform architectures.","PC registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own pc register (program counter) and Java stack. If the thread is executing a JVM method, the value of the pc register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the pc register are undefined.","Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM implementations, native method stacks  and Java frames  are combined.","Method area  contains class data while heap  contains all instantiated objects. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap, each of which are shared by all threads running inside the JVM. When the JVM loads a class file, it parses information about a type from the binary data contained in the class file. It places this type information into the method area. Each time a class instance or array is created, the memory for the new object is allocated from heap . JVM  includes an instruction that allocates memory space within the memory for heap  but includes no instruction for freeing that space within the memory.","Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","The present invention is equally applicable to either a platform specific environment, i.e. a traditional computer application environment loading modules or native methods, or a platform independent environment, such as an interpretive environment, e.g., a Java environment loading classes, methods and the like. The present invention is particularly useful in multithreaded environments as a mechanism for avoiding deadlock situations that may arise due to the nature of the multithreaded environment. For purposes of explanation of the features and advantages of the present invention, the examples of the preferred embodiments of the present invention will assumed that the environment is a Java environment.","The present invention provides a mechanism by which simultaneous compilation of a method by two execution threads is avoided while also avoiding any possible deadlock situations that may arise. The present invention may be implemented as part of a Java Virtual Machine (JVM) or as a separate hardware\/software component acting in conjunction with the JVM.","The present invention makes use of method block fields for redirecting calls of a method that arrive subsequent to a first call to the method. A method block is a control block data structure used to represent control parameters of a Java method. The use of the method block fields in the manner described hereafter allows simultaneous compilation and execution via the JVM interpreter. Once a method is fully compiled then further callers will use the newly compiled code.","With the present invention, the method block is provided with an invoker field which, before the JIT compiler itself is loaded, points to a standard JVM invoker which functions in conjunction with the interpreter. Once the JIT compiler has been loaded, all the invoker fields for newly loaded and existing methods that are candidates for JIT compilation are changed to point to the JIT compiler routine CompileThisMethod, thereby indicating that the method should be compiled. Whereas all Java methods are potential candidates for JIT compilation, native methods are not. Furthermore, certain Java methods such as class initializers that are run only once may be poor candidates for JIT compilation because unless they contain loops it is surely more efficient to interpret them than to compile and execute them. Once a method is compiled, the invoker field points to a routine which will call the compiled code.","The present invention involves the use of a method block having an invoker field for any thread coming from the interpreter and another invoker field for calls from JITted code. On entry to the CompileThisMethod function, the thread locks the method block and determines if compilation has started for this method. If it has not, then the method is marked as being in the process of being compiled and the JVM invoker and JIT invoker fields for the method are changed to indicate that the method should be interpreted. The lock is then released. Subsequent threads will go directly to the interpreter and will interpret the method while the original thread compiles the method. Once the method has been compiled, the compiling thread then reacquires the lock for the method block, marks the method as having been compiled, and changes the JVM invoker to a JVM to JIT transition routine and changes the JIT invoker to point to the newly compiled code.","There is a small window in which two threads can both enter the CompileThisMethod invoker. The first thread will get the lock and proceed as above. The second thread will get the lock after the first thread has changed the invoker and begun compiling the method. By this point the invokers will have been changed to point to the interpreter. The second thread will see from the flags that the method is in the process of being compiled so that the second thread does not attempt to compile the method but instead, merely releases the lock and executes the invoker which points back to the interpreter. Note that it is possible that the compilation could be finished by the time the second thread loads the invoker field in which case it would execute the compiled code.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 4","FIG. 4"],"b":["400","410","420","430","440"]},"The JVM Original Invoker field  is used to point to the original invoker of the method with which the method block is associated. The JVM invoker field  has three possible pointer settings: standard invoker code for the interpreter; CompileThisMethod from JVM; and JVM to JITted code (JVM to JIT). Before the JIT compiler is loaded, the JVM invoker field  is set to the standard invoker code for the interpreter. Once the JIT compiler is loaded, the original value of the JVM invoker field is saved in JVM Original Invoker field  and the JVM invoker field  is changed to point to the CompileThisMethod from JVM. The JVM invoker field is set in all normative method blocks during JIT initialization and in new method blocks during class loading. The CompileThisMethod from JVM routine calls the compiler with appropriate parameters to identify the called method. Upon return from the compiler it makes an indirect call via the JVM invoker field before returning to the interpreter.","Once the method has been compiled, the JVM invoker field  is changed to point to JVM to JIT code. The JVM to JIT code is code that redirects calls to the method to the compiled method code.","The JIT invoker field  is used when invoking a method from Jitted code and has three possible settings: JITted code to JVM (JIT to JVM); CompileThisMethod from Jitted Code; and JITted code. Before the JIT compiler is loaded field  is not used. While the method is compiled, the JIT invoker field  is set to point to CompileThisMethod from JITted code. The CompileThisMethod from JITted code calls the compiler with appropriate parameters to identify the called method. Once the method is compiled, the JIT invoker field  is set to point to the JITted code.","The JIT flags field  contains flags identifying the state of the method with regard to the JIT compiler. One flag that is of particular importance to the present invention is the JIT compilation flag identifying whether or not compilation of the method has begun. This flag is set to a \u201cstarted\u201d state when the JIT compiler begins compilation of the method in response to a thread calling the method for the first time.","On entry to the CompileThisMethod function, a thread calling the method locks the method block for the method and identifies if compilation has started for this method. This may be done by looking at the value of the JIT flags field  for the JIT compilation flag.","If compilation has not started, then the method is marked as being in the process of being compiled by setting the JIT compilation flag in the JIT flags field  to \u201cstarted.\u201d The JVM invoker and JIT invoker fields  and  for the method are changed to indicate that the method should be interpreted, i.e. the fields are changed to JVM Original Invoker and JIT to JVM, respectively. Thus, subsequent threads that call the method will be redirected to the interpreter and will interpret the method while the original thread compiles the method.","Once the method has been compiled, the compiling thread then gets the lock for the method block and changes the JVM invoker field  to the JVM to JITted code transition routine and changes the JIT invoker field  to point to the newly compiled JITted code.","In addition to the above, the lock on the method block must be maintained such that two threads are not allowed to update the same method block. This can be done by creating a new lock for every method. However, for typical Java code, which may have several thousands of methods, this approach may be expensive in terms of storage to maintain information about each lock.","Alternatively, a global lock could be used or an array of locks may be used where the precise lock to be used is selected based on a hash function of the method block address or an identifier held in the method block, for example. Because the computation time while holding the lock is quite small, a global lock would probably suffice for most uniprocessor environments. The lock array approach is recommended for multiprocessor environments and is described below.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 6","FIG. 6"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 7","FIG. 7"],"b":["710","720","725","730","740","750"]},"Once the method is compiled, the lock on the method block is again acquired (step ). The JVM invoker field is set to a JVM to JIT routine, the JIT invoker field is set to the JITted code (step ). The lock on the method block is then released (step ) and the operation is exited.","Thus, the present invention provides a mechanism by which deadlocks in a multithreaded environment may be avoided. The present invention allows multiple threads to call a method simultaneously without experiencing the problems associated with the prior art regarding multiple compilations of the same method or the use of imbedded locks in the compiled code. With the present invention, the first thread to call a method is the thread that causes the method to be compiled. Subsequent calls to the method, during a period of time in which the method is being compiled, are redirected to the JVM interpreter, thereby avoiding any deadlock situation.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media such a floppy disc, a hard disk drive, a RAM, and CD-ROMs and transmission-type media such as digital and analog communications links.","The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
