---
title: Editor visualization of symbolic relationships
abstract: Enhancing dynamic code. A method includes obtaining one or more first data structures defining constructs in a body of dynamic language source code. From the one or more first data structures, identifier information is extracted for one or more of the defined constructs. Knowledge about the constructs is augmented. Using the identifier information and augmented knowledge, metadata about the body of the dynamic language source code is generated. The generated metadata is represented as a symbol table. The body of dynamic language source code is visually enhanced based on the symbol table structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09256401&OS=09256401&RS=09256401
owner: Microsoft Technology Licensing, LLC
number: 09256401
owner_city: Redmond
owner_country: US
publication_date: 20110531
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","Background and Relevant Art","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["Computers and computing systems have affected nearly every aspect of modern living. Computers are generally involved in work, recreation, healthcare, transportation, entertainment, household management, etc.","Computers are typically controlled using computer software. The computer software includes executable instructions that can be executed by one or more processors to cause the computer to perform various functions. Computer software may be created using source code created in a programming language. Code may be categorized in several different ways. One distinctive method of categorizing computer code is categorizing it as either static or dynamic.","Static code can typically be easily analyzed before runtime as the code typically is defined before runtime and does not change at runtime, the type system is well defined before runtime and does not change at runtime, and types within the type system are defined before runtime and do not change at runtime. Compilers, before runtime, can perform static analysis on static code and provide information to developers regarding characteristics of the static code or potential problems with a body of code.","Alternatively, some computer code may be classified as dynamic. In dynamic code, new code may be added at runtime. Additionally, static code type systems are not well defined before runtime. Further still, types within a static code type system can change at runtime. Thus, static analysis, before runtime, of dynamic code is hard due to the changing nature of the dynamic code at runtime.","Generating and editing dynamic language source code can be confusing for a developer because of unusual rules implemented by some dynamic languages. For example, JavaScript has interesting and sometimes confusing scoping rules. In particular, a variable declaration within a brace in JavaScript may nonetheless be a global variable. Similarly, a variable may be declared at the end of a body of JavaScript code, but the declaration is sufficient for use with code declared earlier in the body of code. This can be visually confusing for a developer. Further, an out of scope reference to a variable in JavaScript will result in either a new variable being created or a global variable being used. These issues can result in code correctness problems and code editing difficulties.","The subject matter claimed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather, this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.","One embodiment described herein illustrates a method of enhancing dynamic code. The method includes obtaining one or more first data structures defining constructs in a body of dynamic language source code. From the one or more first data structures, identifier information is extracted for one or more of the defined constructs. Knowledge about the constructs is augmented. Using the identifier information and augmented knowledge, metadata about the body of the dynamic language source code is generated. The generated metadata is represented as a symbol table. The body of dynamic language source code is visually enhanced based on the symbol table structure.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Additional features and advantages will be set forth in the description which follows, and in part will be obvious from the description, or may be learned by the practice of the teachings herein. Features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. Features of the present invention will become more fully apparent from the following description and appended claims, or may be learned by the practice of the invention as set forth hereinafter.","Some embodiments herein facilitate dynamic code development and editing by visually presenting dynamic source code to a developer in a fashion that may be more intuitive and helps to identify scoping and other issues.","Embodiments may create a symbol table. The symbol table, as will be described in more detail below, may include details regarding symbol types, symbol origins, and symbol scopes. Using the symbol table, rich colorization visualizations can be created by parsing the source code with respect to the symbol table. Embodiments described herein implement functionality to distinguish and categorize symbol relationships (e.g., scope, type, origin, dependencies and other attributes), providing visual information that improves readability, assists in code refactoring and\/or helps avoid a large class of programming errors based on unexpected use or alteration of symbols declared globally or at other, non-local procedure depths.","Some embodiments implement functionality related to colorizing, visually adorning or grouping variables in the editor according to symbol scope. While some current editors, for prominent languages such as C++, C#, and JavaScript, render variable names in a uniform way, some embodiments may increase the information density of rendered variable names by colorizing them according to how they are resolved symbolically. Examples are illustrated below in  as will be discussed in more detail below.","Determining how to visually enhance a body of source code can be accomplished by parsing the body of source code with respect to the symbol table. This can be used to determine symbol types, origins, scopes, dependencies, etc as expressed in the source code based on organization and information in the symbol table. Additionally, errors can be determined. For example, if while parsing a body of source code, a symbol from the source code is not found in the symbol table, it can be determined that an error is likely in the source code. This can be visually indicated to a developer.","The following illustrates examples of how a symbol table and other related data structures may be obtained.","Some embodiments illustrated herein implement an approach to generate and maintain symbolic references from source code, without literally executing code, to support a range of features related to identifying, analyzing, refactoring, etc, variables and definitions.","As intimated above, it is hard to conclusively identify symbols backing references in dynamic languages through static parsing and\/or analysis. As a result, many modern editor language services today depend on code execution to generate a list of symbols at a specific source code context\/scope. This approach has clear limitations and issues. It is difficult to guarantee, for example, that a breakpoint set in a JavaScript function will be hit on calling it outside of actual program\/web site execution (or that the breakpoint will be hit in a timely way). It is even less practical to consider executing code across an entire program to generate the comprehensive sort of symbol analysis that would be performed, for example, identify all code locations that reference a given symbol.","Thus, embodiments can address these issues by implementing an approach to generate and maintain symbolic references, without literally executing code. In particular, as an alternate to code execution, embodiments may combine several components which, in concert, provide significant symbol analysis outside of a runtime environment. The result is a rich set of refactoring and other valuable integrated development environment features. An integrated development environment includes an integrated application that provides development functionality such as editing, project management, source control, compilation and\/or linking, publishing, post-build verifications, etc.","Referring now to , in some embodiments, a symbol table  is constructed from implied and explicit inputs (such as, among other things, source files of a body of code ) of a dynamic language. A symbol table data structure correlates identifiers in a program's source code with augmented information relating to its declaration or appearance in the source code. The symbol table may include, for example, correlation between an identifier and information related to type, scope level, location, etc.","In some embodiments, symbols and symbol references are read from persisted data and\/or discovered and\/or inferred from a multi-pass traversal of an abstract syntax tree (AST) representation  of a body of program code . While ASTs are referred to in the examples below, it should be appreciated that other types of syntax trees may be used additionally or alternatively. A symbol table  including mapping between source code offsets and symbolic references is constructed. This mapping can be used to implement various editor features. For example, such features may include one or more of \u2018go to symbol definition\u2019, \u2018find all references to this symbol\u2019, \u2018rename this variable\u2019, etc.","Illustrating now additional detail, some embodiments described herein include methods and\/or apparatus to construct and understand a rich set of symbols & symbolic references, by combining several different techniques into a single system. For example, as illustrated in , a first technique uses one or more parsers  to create ASTs  from source code . The one or more parsers can construct symbol tables  from the AST  input. A second technique that may be used, in some embodiments with the first technique, includes reading and\/or hydrating static, literal descriptions of symbols directly. In particular, if symbols can be determined by static analysis or inferences, this technique could be used to resolve some symbols. A third technique that could be used with other techniques includes using type inferencing code that models runtime type resolution. This could be augmented by static annotations that signify type information and\/or declarations for variables. A fourth technique that could be used with other techniques includes using code and\/or extensibility points that model symbol table manipulation based on an understanding of runtime behaviors of both a platform itself and\/or calls to specific APIs. A fifth technique that could be used with other techniques includes defining and\/or enforcing coding guidelines provided to developers that help maximize discoverability of relevant information. In some embodiments, enforcing guidelines may be facilitated by using coding tools to drive enforcement of the coding guidelines.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIGS. 2 & 3","FIG. 2"]},{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"var g;"]},{"entry":[{},"function foo(p) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"var v;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The example demonstrates raising symbols from a variable declared at global scope (g), a function \u2018foo\u2019 also declared at global scope, a parameter \u2018p\u2019 (the scope of which is constrained to function \u2018foo\u2019) and a local variable \u2018v\u2019, also constrained in scope to \u2018foo\u2019. The illustration shows the hierarchical relationship of these symbols. Referring now to , an example symbol mapping is illustrated for the following code",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"var g = {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"a: null,"]},{"entry":[{},"b: null"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"function foo(p) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"var v = {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"c: null"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Additional details are now illustrated. It should be appreciated that while the following examples illustrate specific types, functions, etc., other embodiments may use similar or equivalent types, functions, etc. In particular, naming strategies should not be considered limiting, but rather are used for concreteness and illustration. Illustrating now further details, a first parser pass illustrating general AST  and hierarchical symbol table  construction is illustrated. In the first pass, a set of inputs is identified, either explicitly (for example, using a command-line provided by a user or a program project file maintained in an integrated development environment) or implicitly (for example, by scanning product source code , making assumptions about a runtime execution environment, inferring dependencies from in-source information such as links to JavaScript, XML doc comments, etc).","Referring now to , a specific example of tools used to analyze JavaScript applications are illustrated. While  illustrates a specific JavaScript example, it should be appreciated that other embodiments can use similar elements for other dynamic bodies of source code.  illustrates two parsers, a format-capable parser  and a JavaScript parser . The parsers can parse various bodies of computer code to produce ASTs , such as the AST  illustrated in .","Embodiments can include source code which falls, in some examples, into one of three categories: 1) product code, 2) other supporting \u2018framework\u2019 code, and 3) other supporting \u2018reference\u2019 code, all of which is represented by the body of source code  illustrated in . The JavaScript parser  is able to parse product code or program source code . Product code refers to the source code that comprises the user source, which is typically the target of the analysis (ie, the source code for which useful information or functionality is raised against). The JavaScript parser  may also parse supporting source code . Supporting source code  may include source code that facilitates execution of the program source code. For example, supporting source code  may include framework source code. In general, supporting source code may be code that is not part of a particular program, but that can be used to provide more information about the program. For example, supporting source code may be one or more declarations of types. Supporting \u2018framework\u2019 code, refers to code that also executes at runtime but which is picked up from the system, other 3rd-parties, or which simply should not be regarded as of primary interest in the current scenario. Supporting \u2018reference\u2019 code, refers to augmenting information which happens to be rendered in the format of the dynamic language (because this is convenient, both for tooling and for maintenance by developers). \u2018Reference\u2019 code is consumed by the tool only, it is not executed at runtime.","Input files may be read sequentially and abstract syntax trees  created for them. The ASTs  are subsequently traversed and a hierarchical symbol table (such as the symbol table  illustrated in ) is constructed from them that expresses scoping of all discovered symbols. Symbols for functions are constructed in this phase.","A pass subsequent to the first pass may be performed to accomplish type inferencing and member population. During the subsequent pass, types are resolved as far as possible. In some embodiments, types may be resolved, for example, by inference and check. Also during the subsequent pass member symbols are populated. This subsequent pass is not performed in sequential order. The following illustrates heuristics used to determine the order in which the code is analyzed. Global code is analyzed first. Functions (both declarations and function expressions) are queued up for execution, and ceteris paribus will be analyzed in the same order they were found after all global code has been analyzed. A call to a function will cause it to be analyzed ad hoc, being removed from the queue, if present, or added to it if not. When performing the latter step, \u2018Miranda\u2019 prototyping rules are used, meaning that if the types of the parameters to a function are not known, they will be supplied by the known types of the arguments at the first function call point.","In the following description, much of the descriptive information is specific to JavaScript. However, it should be noted that these examples are merely illustrative and other embodiments may be used with other languages. Type inferencing is performed in a bottom-up fashion. As the parser  recursively walks the AST , it bubbles up types for sub-expressions recursively and applies rules to infer type expressions whose type is unknown. The following illustrate rules that may be applied. Literals (Boolean values, strings, numbers, null, objects, arrays) denote their own type. Identifiers that refer to functions are of type Function. Identifiers that refer to symbols whose types have been inferred are of the same type as the symbol to which they refer. Additive expressions are of type String if either operand is a String, in which case both sides are inferred to be of type String. Other additive expressions and all other arithmetic expressions (both binary and unary) are of type Number, and their operands are inferred to be of type Number. Boolean expressions (both binary and unary) are of type Boolean, and their operands are inferred to be of type Boolean. Function call expressions are of the same type as the function being called has been inferred to return. \u201cNew\u201d expressions are of the type designated by the function used in the new expression. Return statements cause the current function to be inferred to return the type of the return expression. Control flow statements (for loops, ifs, switches, returns, etc.) are of type \u201cvoid\u201d (or \u201cundefined\u201d in JavaScript). For inference rules above, it is possible to use annotations (see below) to explicitly define types.","In some embodiments, functions are categorized into one of four categories, i.e.: unknown, static functions, member functions, or constructors. A function may be initially unknown and is categorized based on usage. A function called directly is considered static. A function called through on an object instance is the objects member function. A function used in a new expression is marked as a constructor. As with types, the annotations mechanism can also impact categorization of functions.","Illustrating now a particular special case, JavaScript includes a keyword \u2018this.\u2019 The \u2018this\u2019 keyword refers to the execution context of a function, which can differ for each function call. The resolution of \u2018this\u2019 in JavaScript is dependent on runtime information complicating performance of a complete static analysis. Embodiments may use a number of now illustrated heuristics to determine to what a reference to \u2018this\u2019 refers. If the context is global code or if the function is static or unknown, then \u2018this\u2019 evaluates to a symbol that represents the global scope (e.g., the \u201cwindow\u201d object in browsers). If the context is a constructor, then \u2018this\u2019 evaluates to a prototype object of the function it represents. If the context is a function being assigned to an object member, then \u2018this\u2019 evaluates to the object. If the context is a member function, then \u2018this\u2019 evaluates to the prototype of the function that declares the type of the member on which this function is being called. It is possible to use language augmentations (annotations) to describe the binding of the function and override the above heuristic rules.","For property accessors, the type of the left-hand side expression is evaluated and the right-hand side identifier is sought in the symbol table, following the relevant type's prototype chain.","Some embodiments may implement or support direct symbol hydration and symbol hydration with alternate parsers. Embodiments may provide a mechanism for directly populating the symbol table  based on parsing inputs other than literal source code that will execute at runtime. In one illustrative example, the JavaScript parser  may further include functionality for parsing application programming interface (API) code. For example,  illustrates the JavaScript parser  parsing API code for W3C APIs, ECMA APIs, and browser-specific Document Object Model (DOM) APIs. W3C DOM API, ECMA(X) API (such as Math functions), JavaScript API, COM objects, browser-specific API, browser specific DOM extensions, etc, can be expressed as (generally bodiless) JavaScript functions\/variables that are passed to the AST analyzer described above. The JavaScript parser  may further include functionality for parsing reference code for other supporting JavaScript for which implementation is absent. This may be functionality (functions, types, etc.) that are assumed to be available during runtime, but are not part of the program. Reference code refers to metadata sufficient to model symbolic references which cannot be computed and\/or inferred from production code. This may include the body of executable API that is provided as built-in browser\/ECMA script functionality (such as the HTMLElement class and JS Math functions). This may include \u2018foreign\u2019 api that model code which is callable due to some interop mechanism (such as calling into a COM object or a web service). Reference code may include \u2018type definitions\u2019 which are superimposed onto production code but which are otherwise irrelevant at runtime. In a reference file, for example, embodiments may include a description for a type that includes only two methods, foo and bar. In a product file, a parameter may be annotated as being of this type. At analysis time, embodiments can ensure that only methods named foo or bar are called on that parameter.","The format-capable parser  is configured to parse HTML, COM type libraries, and other descriptive formats as now described in more detail. APIs that are \u2018foreign\u2019 to the language\/runtime (i.e., for which some sort of special interop code is required to execute at runtime, e.g., COM objects) can be added to the symbol table by parsing relevant descriptive formats (such as type libraries) and\/or these descriptions can be converted to a format (such as in the particular illustrated example, JavaScript) which can be fed directly to the symbol table construction code. The system can accept static (such as user-authorable) descriptions of symbols as well as extensions that parse arbitrary data formats and populate the symbol table accordingly. An example of the latter is an extension that parses HTML to populate the symbol table with DOM elements expressed in mark-up that are accessible to JavaScript code (such as calls to getElementsByld). There is some tolerance in the system for errors and\/or incompleteness of reference data as distinct from production code (which will be modified and\/or analyzed within the editor).","Some embodiments may implement or facilitate extensions that model runtime symbol construction. Embodiments may provide a mechanism for populating the symbol table not merely with code as it is analyzed but, in some cases, based on the result at runtime when executing that code. Some useful examples relate to JavaScript utility code that constructs and populates object instances with members. Ecma5 JavaScript provides helpers such as object.createProperty which can, in some cases, be modeled by the system. String literals passed to eval can be parsed into AST and injected into the AST and\/or symbol table.","Some embodiments may benefit from constraining development practices to maximize code discoverability. There are typically a set of coding guidelines\/practices that have a high return as far as helping with the ability of embodiments to function with a correspondingly low impact on the expressiveness and\/or utility of the dynamic language. One example of such a constraint is directing developers to avoid use of eval statements in JavaScript. In some embodiments, these constraints may be enforced by coding tools which prevent developers from violating constraints, or at least warn a developer if they are about to break or exceed a constraint.","Embodiments may include a mechanism for reporting conditions to users that limit the ability to analyze source. In particular, there may arise situations in which dynamic source code cannot be completely analyzed and\/or all symbols resolved. Embodiments can include functionality to indicate such to developers when such conditions arise.","Using the symbol table, embodiments may implement a number of other functionalities. For example, embodiments may implement various editor features such as one or more of \u2018go to symbol definition\u2019, \u2018find all references to this symbol\u2019, \u2018rename this variable and all references to it\u2019, etc.","Embodiments may include functionality to create or use an ability to display a representation of implicitly available API, for informational purposes and to potentially serve as both the target for \u2018go to reference\u2019 or the source for \u2018find all references to this symbol\u2019 features.","Embodiments may include functionality to create or use a mechanism for modeling symbol construction based on analyzed code. Embodiments may include call sites to an API that constructs a class object based on a set of input parameters. For example, input parameters could be transformed into symbols that represent actual objects as they will be available at runtime, based on analyzed code.","Embodiments may include functionality to create or use a mechanism for specifying, authoring\/edited descriptive inputs representing symbol tables entries, in formats such as XML, native JavaScript, etc. This may also include the ability to parse HTML to identify runtime-available objects. For example embodiments may be able to identify elements marked with a specific identifier (such as an HTML \u2018id\u2019 attribute).","Embodiments may include functionality to create or use an ability to annotate source code with \u2018type\u2019 information. This may allow embodiments to jump to a type or object definition that might exist as actual project source or is solely represented in generated code and\/or static descriptive input files.","Embodiments may include functionality to create or use an ability to annotate source code files with (or otherwise associate) a set of dependencies (such as another supporting JavaScript file) used to construct a comprehensive symbol space for analysis.","The following discussion now refers to a number of methods and method acts that may be performed. Although the method acts may be discussed in a certain order or illustrated in a flow chart as occurring in a particular order, no particular ordering is required unless specifically stated, or required because an act is dependent on another act being completed prior to the act being performed.","Referring now to , a method  is illustrated. The method  may be practiced in a computing environment. The method  includes acts for creating metadata for dynamic code in a descriptive metadata language. The method includes obtaining one or more first data structures defining constructs in a body of dynamic language source code (act ). For example, in some embodiments, the one or more first data structures comprise at least one of a syntax tree or an abstract syntax tree.  illustrates a abstract syntax tree  derived, at least in part from a body of source code . In the example illustrated in , the abstract syntax tree  is the specific example of a data structure.","The method  further includes, from the one or more first data structures, extracting identifier information for one or more of the defined constructs (act ). For example, embodiments may extract symbol names into a symbol table.","The method  further includes augmenting knowledge about the constructs (act ). Augmenting knowledge about the constructs can be accomplished in a number of different ways. For example, augmenting may be based on explicit inspection of the body of dynamic language source code. For example, the dynamic language source code may include comments in the code that can be used to augment knowledge about constructs in the code. Explicit inspection of the body of dynamic language source code may include inspection of code that is a surrogate for an actual implementation or which models code that is not explicitly expressed in source code form. For example, this may include cases of dropping in reference files to replace 3rd party frameworks in an analysis tool chain as well as modeling things like built-in DOM API (which have no actual representation as JavaScript source code.","Alternatively or additionally, augmenting may be based on one or more implied inferences. For example, if it can be determined that source code concatenates to a string literal using an object as an operand, it can be determined that the resulting object is a string. If an arithmetic operation is performed using an object as an operand, it can be determined that the object is a numerical type, such as an integer or floating point. Inferences may be may be made based on a framework supporting source code. For example, knowledge about a framework and knowing how that framework will consume source code can facilitate inferring addition information about the source code. Similarly, context can be used to infer additional information. For example, context such as a browser which source code will be used with and knowing how that browser will interact with source code can facilitate inferring addition information about the source code. Further still, stand in code can be used to make inferences to augment knowledge about source code. Stand-in code provides an alternate body (that is, implementation) of a function that is expressly designed to assist in computing symbolic information for variables that are within scope (as opposed to being intended to execute at runtime). This is an alternate approach to analyzing the actual implementation of a function to acquire information or depending strictly on annotations.","Embodiments could be implemented that include augmentation as a result of folding in runtime collected data. In particular, embodiments may instrument the runtime to provide information about how the type of set of types that a parameter resolved to at a specific code location. This new information may be folded into the augmented information.","Embodiments could be implemented that include augmentation as a result of modeling the results of executing code. For example, embodiments of the method  may be performed where augmenting includes modeling the effects upon a symbol table that would result from executing a call to one or more functions based on explicit, inferred or computed call site details. For example, assume that an embodiment has knowledge of a function constructNamespace(namespaceName), which creates a global object of the name that is passed in as an argument. During analysis, when embodiments observe a call site constructNamespace(\u201cMy.Namespace\u201d), the tool could add the specified namespace object to the symbol table so that it is subsequently available when processing the remainder of the function. Other embodiments may implement a more complicated path analysis to calculate a number of possible paths through the function, with implied arguments provided to a callee. For example, embodiments may implement symbolic execution, abstraction interpretation, control and data flow analysis, etc.","Alternatively or additionally, augmenting may be based on user input. For example a user interface using a command line tool and\/or graphical based tool may be used to augment the body of dynamic language source code. For example, a user can provide additional information about objects in code, similar to how commenting might work, but without needing to formally comment the source code. Rather, the tool may be used to allow a user to make external comments about source code.","The method  further includes providing metadata about the body of the dynamic language source code with the source code in a specific metadata format to a user (act ). For example, and as illustrated previously, the specific metadata format may include a symbol table.","The following now illustrates how various visualizations may be implemented based on information in the symbol table. Some embodiments may implement functionality related to colorization and\/or editor squigglies. An example of this is illustrated below in  at . This may be implemented for symbol declaration and\/or use that represents or contributes to possible code correctness and maintainability issues. For example, this may facilitate detecting instances of declaring a local variable in source code with the same name as an instance member. Colorization and\/or editor squigglies implementations may potentially include altering colorization of variables based on runtime aspects of the symbol. For example, such runtime aspects may include a semantic analysis that identifies use of uninitialized, disposed, and\/or otherwise invalid variables. The aspects can then be highlighted by colorization adornments and\/or editor squigglies.","Some embodiments may highlight all references to a symbol. In some embodiments, a symbol definition in a body of source code may be highlighted by a user using a user interface clicking an individual reference to the symbol. This feature may be particularly useful for JavaScript, other dynamic languages. Some embodiments may include a feature that could select and\/or highlight all variables required to generate a closure of a selection.","Embodiments may include functionality for colorizing, visually adorning and\/or grouping variables and other symbol definitions by accessibility. An example of this is illustrated at  in  and discussed in more detail below. For example, embodiments may include functionality for distinguishing between variables, functions, etc, that are available only within a class definition (i.e. private), available within that class and sub-types (i.e. protected), etc., and\/or distinguishing between writable and constant and\/or non-writable values.","Embodiments may include functionality for visualizations that represent the origin and optionally the resolution logic for a symbol. For example, a visualization associated with a non-fully qualified C# type name could display its source assembly and fully qualified namespace, as well as other symbols (such as identically named types in other assemblies or other types of identical short name in other namespaces). The other symbols could be alternate candidates for resolution, such as for example by qualifying the short type name with a different namespace.","Embodiments may include functionality for visualizations for symbol type information at a particular point in code based on static inputs, type inferencing via static analysis, etc. A JavaScript parameter, for example, could be visually identified as conclusively or possibly a String type at a specific point in code (via info tip, colorization, etc). Embodiments may colorize or otherwise visually enhance variables by type, String, Number, Object, Regexp, Function, a user-defined type, etc, when known and\/or colorize or otherwise visually enhance the type\/constructors names themselves.","Embodiments may include functionality for analyzing JavaScript that is inlined in HTML and\/or has DOM dependencies. JavaScript code can access symbols that represent HTML elements (referenced by id), CSS styles, etc., the resolution of which is not clear in the editor. The symbols could then be visually enhanced using the functionality illustrated herein.","Embodiments may include the ability to provide visual enhancement to help a developer distinguish between symbols defined in user source as opposed to supporting code. As described above, supporting source code may include, for example, implied browser\/W3C DOM and ecma JavaScript API, helper \u2018libraries\u2019 such as jquery, etc.","Embodiments may include functionality to provide visual enhancements to help a developer to identify and\/or distinguish symbols that are associated with a specific source. For example embodiments can provide visual enhancements to identify a source as one or more of an implied browser DOM, a supporting JavaScript file, or, in the managed world, a specific assembly, namespace or sub-namespace.","Embodiments may include the ability to support variable expansion and\/or interpolation. For example, embodiments may include functionality for resolving a construct such as window.eval(\u201cvar foo=7,\u201d) or, in C#, resolving a call to Activator.CreateInstance(string, string) with explicit or inferred argument values to the corresponding type symbol.","Embodiments may include functionality to provide visual enhancements to show variable declarations that override a symbol in a local or parent scope. For example, embodiments may provide squigglies, with right-click pop-up details regarding overridden symbols. Some embodiments may include the ability to navigate to symbol using gestures or other input.","Var declarations that do not explicitly use the \u2018liar\u2019 keyword often indicate a typo\/correctness problem. By visually enhancing all global data in a uniform way, embodiments can raise visibility on this class of issue.","Local variables which are defined without the \u2018liar\u2019 keyword are visible to other functions. Embodiments may include functionality to implement visual enhancements such as colorization and\/or the ability to view an aggregated list of all variables available in local scope. In some embodiments, this may be done for variables defined only in project and not supporting code.","In some languages, the scope of local variables is constrained from being restricted within a function body. Thus, embodiments may include functionality to provide visual enhancements to have an expandable view at the top of a function that shows all locally defined variables. In some embodiments, a user interface may be provided for refactoring code which allows a user to extract and define all local variables at the beginning of the function.","The resolution of \u2018this\u2019 within JavaScript code is often ambiguous. Thus, embodiments can provide visualizations to resolve ambiguities. As an example, hovering over \u2018this\u2019 might result in a tooltip that displays the type name of the instance referred to. In another example, the user might be able to right-click on \u2018this\u2019 and jump to the constructor\/class definition of the related type.","JavaScript symbol state (e.g. undefined vs. null) and type coercion rules are particularly complicated. Embodiments can provide visualizations to clarify symbol state and\/or type coercion. A \u2018definite assignment\u2019 analysis performed against code may allow embodiments to determine that a specific variable might be undefined. Another code path might indicate an assignment of a string. In a follow-on code path, embodiments might encounter the use of JavaScript constructs such as instanceof, typeof or equality to true or false. At these code points, embodiments may display to the user what possible type and\/or symbol states are believed to be included. This may allow embodiments to determine, for example, that a comparison in a conditional statement might never evaluate to true (or false). Alternatively or additionally, embodiments may issue a warning that a typeof comparison will never evaluate to true (or false).","Embodiments may include functionality to implement visual enhancements to distinguish between functions which are constructors and those which are not constructors. For example, functions which are constructors could be colorized in one way while functions which are not could be colorized in a different way. Some embodiments may have a default of no coloring, but colorizing for either functions which are constructors or those which are not constructors, but not both.","Some embodiments may implement visual enhancements that can be applied in dynamic languages. The following illustrates examples that may be used in static languages such as C#.","Some embodiments may include functionality to visually differentiate between access of parameters, locals, instance and static members.","Some embodiments may include functionality to colorize and\/or automatically group members by one or more of member kind (e.g. event, field, etc), mutability (e.g. const, readonly, etc), or accessibility (e.g. private, protected, etc)","Some embodiments may include functionality to colorize use of nested types within an implementation.","Some embodiments may include functionality to distinguish member access by member kind. For example, embodiments may include functionality to distinguish between accessing a field with a capitalized name versus accessing a property.","Some embodiments may include functionality to identify method definitions that unexpectedly replace those in a base type. Some embodiments may accomplish this by colorizing a weakly typed override that masks a strongly typed base definition. Some embodiments may include colorizing code that satisfies a code contract required by a base type (for example, an abstract member declared in a base type) or an interface. A developer may be interested in knowing, for example, the specific set of members declared on a type that were authored to provide a complete implementation of an interface.","Some embodiments may include functionality to inline or otherwise provide ability to view inherited members in a class definition.","Some embodiments may include functionality to expand method declarations to show chain of overrides leading to the definition.","Some embodiments may include functionality to colorize extension methods which are typically of visually non-obvious origin.","Generally, embodiments may include mechanisms for customizing visualizations. For example, user interface elements may be provided that allow a developer to enable or disable visualizations. Embodiments may include functionality to allow a user to switch between visualizations. Embodiments may include functionality to allow a user to use user gestures to dismiss and\/or disable specific visualizations and\/or results. Some embodiments may implement user extensibility points to allow a user to customize the appearance of various visualizations. For example, a user may be able to select a color scheme, the use of highlighting versus the use of squigglies, etc.","Referring now to , several visualizations by scope relationship in a JavaScript editor are illustrated. Note, in the examples illustrated in , text rendered in a blue font is shown in the drawings with a single underline, text rendered in a red font is shown in the drawings with a double underline, and text rendered in a green font is shown in the drawings with a triple underline. At  a global variable named \u2018myGlobal\u2019 is declared and each reference is colorized to indicate the reference originates in global scope. At , parameter \u2018name\u2019 is determined to have overwritten a symbol in global scope (window.name). The error is marked by a squiggly and a pop-up provides the user details of the issue. At , the identifiers for all variables within the most nested local scope are colorized as black in this code example. At , a variable \u2018index\u2019 is used without being explicitly declared. It is therefore of global scope and colorized in red. Additionally, the editor puts a squiggly under the identifier to call attention to the fact that there is an implicit declaration here that results in a modification to the global scope. At  the alert function is called with three different variables declared in varying scope, the most nested function, a parent function, and the global namespace.","Referring now to , another visualization example is illustrated. In the example illustrated in , the user has clicked on or hovered over a reference to \u2018myGlobal\u2019 and all visible references to that symbol are highlighted in the editor.","Referring now to , another visualization example is illustrated. In the example illustrated in , the user is click-dragging over a chunk of code. When the user pauses (with the mouse button still depressed), the editor draws boxes around all visible references that would be required to generate a closure of the selection.","Referring now to , another visualization example is illustrated. In the example illustrated in , the editor has aggregated all available global symbols, and locals for visible function definitions. The user has expanded the locals visualization for \u2018myFunction\u2019 and can view all variables of that scope. In the present example, this includes all variables defined within the function, as JavaScript does not constrain symbol scope to the declaring block within a routine. The locals visualization could also have usefully included\/noted the parameters in the function declaration as well.","The following discussion now refers to a number of methods and method acts that may be performed. Although the method acts may be discussed in a certain order or illustrated in a flow chart as occurring in a particular order, no particular ordering is required unless specifically stated, or required because an act is dependent on another act being completed prior to the act being performed.","Referring now to , a method  is illustrated. The method  may be practiced in a computing environment and includes acts for transforming dynamic code. The method  includes obtaining one or more first data structures defining constructs in a body of dynamic language source code (act ). From the one or more first data structures, the method  further includes extracting identifier information for one or more of the defined constructs (act ). The method  further includes augmenting knowledge about the constructs (act ). The method  further includes using the identifier information and augmented knowledge, generating metadata about the body of the dynamic language source code, the generated metadata being represented as a symbol table (act ). The method  further includes visually enhancing the body of dynamic language source code based on the symbol table structure (act ).","Embodiments of the method  may be practiced where visually enhancing the body of dynamic language source code comprises indicating symbol types by visual artifacts.","Embodiments of the method  may be practiced where visually enhancing the body of dynamic language source code comprises indicating symbol resolution by visual artifacts. This may address issue of determining how and\/or whether a symbol satisfies a required contract and\/or abstract definition, overrides or masks a previously existing symbol or base type definition, etc.","Embodiments of the method  may be practiced where the body of dynamic language source code comprises indicating at least one of symbol origin, symbol scope, indicating symbol, at least one of uninitialized, disposed or invalid variable, symbol availability by visual artifacts. Visually enhancing the body of dynamic language source code may include displaying visual artifacts. The visual artifacts may be embodied in various different forms, such as using, uniform colorization, tooltips, shading, outlining, squigglies, etc.","Further, the methods may be practiced by a computer system including one or more processors and computer readable media such as computer memory. In particular, the computer memory may store computer executable instructions that when executed by one or more processors cause various functions to be performed, such as the acts recited in the embodiments.","Embodiments of the present invention may comprise or utilize a special purpose or general-purpose computer including computer hardware, as discussed in greater detail below. Embodiments within the scope of the present invention also include physical and other computer-readable media for carrying or storing computer-executable instructions and\/or data structures. Such computer-readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer-readable media that store computer-executable instructions are physical storage media. Computer-readable media that carry computer-executable instructions are transmission media. Thus, by way of example, and not limitation, embodiments of the invention can comprise at least two distinctly different kinds of computer-readable media: physical computer readable storage media and transmission computer readable media.","Physical computer readable storage media includes RAM, ROM, EEPROM, CD-ROM or other optical disk storage (such as CDs, DVDs, etc), magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer.","A \u201cnetwork\u201d is defined as one or more data links that enable the transport of electronic data between computer systems and\/or modules and\/or other electronic devices. When information is transferred or provided over a network or another communications connection (either hardwired, wireless, or a combination of hardwired or wireless) to a computer, the computer properly views the connection as a transmission medium. Transmissions media can include a network and\/or data links which can be used to carry or desired program code means in the form of computer-executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above are also included within the scope of computer-readable media.","Further, upon reaching various computer system components, program code means in the form of computer-executable instructions or data structures can be transferred automatically from transmission computer readable media to physical computer readable storage media (or vice versa). For example, computer-executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module (e.g., a \u201cNIC\u201d), and then eventually transferred to computer system RAM and\/or to less volatile computer readable physical storage media at a computer system. Thus, computer readable physical storage media can be included in computer system components that also (or even primarily) utilize transmission media.","Computer-executable instructions comprise, for example, instructions and data which cause a general purpose computer, special purpose computer, or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be, for example, binaries, intermediate format instructions such as assembly language, or even source code. Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather, the described features and acts are disclosed as example forms of implementing the claims.","Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations, including, personal computers, desktop computers, laptop computers, message processors, hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, mobile telephones, PDAs, pagers, routers, switches, and the like. The invention may also be practiced in distributed system environments where local and remote computer systems, which are linked (either by hardwired data links, wireless data links, or by a combination of hardwired and wireless data links) through a network, both perform tasks. In a distributed system environment, program modules may be located in both local and remote memory storage devices.","The present invention may be embodied in other specific forms without departing from its spirit or characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order to describe the manner in which the above-recited and other advantages and features can be obtained, a more particular description of the subject matter briefly described above will be rendered by reference to specific embodiments which are illustrated in the appended drawings. Understanding that these drawings depict only typical embodiments and are not therefore to be considered to be limiting in scope, embodiments will be described and explained with additional specificity and detail through the use of the accompanying drawings in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
