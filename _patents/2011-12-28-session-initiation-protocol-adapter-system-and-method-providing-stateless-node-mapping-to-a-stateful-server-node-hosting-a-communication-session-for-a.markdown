---
title: Session initiation protocol adapter system and method providing stateless node mapping to a stateful server node hosting a communication session for an actor
abstract: In accordance with various embodiments, a set of features are described for enabling an application server platform for telecom based applications. A system for providing an application server for telecom-based applications can include an application server that includes a session initiation protocol (SIP) adapter. The SIP adapter can use a connection oriented protocol and provides interactions with application code in an actor of said application server by means of asynchronized SIP protocol events. The SIP adapter can also provide stateless node mapping to a stateful server node hosting a specific session for the actor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09258379&OS=09258379&RS=09258379
owner: ORACLE INTERNATIONAL CORPORATION
number: 09258379
owner_city: Redwood Shores
owner_country: US
publication_date: 20111228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","CROSS REFERENCE TO RELATED APPLICATIONS","COPYRIGHT NOTICE","FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of priority to U.S. Provisional Patent Application No. 61\/428,129, titled \u201cIMPROVED APPLICATION SERVER PLATFORM FOR TELECOM-BASED APPLICATIONS\u201d, filed on Dec. 29, 2010; and U.S. Provisional Patent Application No. 61\/432,554, titled \u201cAPPLICATION SERVER PLATFORM HAVING A DEPLOYMENT MANAGEMENT SERVICE, CONFIGURATION SERVICE, TCAP ADAPTER, SIP ADAPTER AND A JAVA MEDIA SERVER CONTROLLER\u201d, filed on Jan. 13, 2011; each of which applications are herein incorporated by reference.","The present application is related to U.S. patent application Ser. No. 13\/339,252, titled \u201cIMPROVED APPLICATION SERVER PLATFORM FOR TELECOM-BASED APPLICATIONS USING AN ACTOR CONTAINER\u201d, filed on Dec. 28, 2011 ; and U.S. patent application Ser. No. 13\/339,287, titled \u201cAN EVENT BROKER FOR AN IMPROVED APPLICATION SERVER PLATFORM FOR TELECOM-BASED APPLICATIONS\u201d, filed on Dec. 28, 2011 ; each of which applications are herein incorporated by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The current invention relates to mobile communications and in particular to providing application server platform for applications that utilize telecom-based functionality.","In today's world of telecommunications, more and more devices and functionalities are being integrated with one another in order to create new features and capabilities for the everyday user, as well as for large organizations and enterprises. Numerous examples of this can be seen in the realms of mobile devices, cellular phones and computers. Everything from electronic mail, internet access, text messaging, video and digital photography to video games, social networking and other forms entertainment, are becoming available for a wide variety of mobile devices. Countless web applications now provide services that can access or be accessed via mobile phone to enable a particular feature.","Given all of this pervasiveness, the management of software applications must expand in order to accommodate a multitude of mediums and modes of operation previously unconsidered by most developers. As a simple illustration, in order to allow an internet user of a web application to set up a conference telephone call between several end subscribers, the application must be able to interact in some meaningful way with multiple and substantially different protocols and networks. This is the general environment within which embodiments of the invention are intended to be used.","The current invention relates to mobile communications and in particular to providing application server platform for applications that utilize telecom-based functionality. A system for providing an application server for telecom-based applications can include an application server that includes a session initiation protocol (SIP) adapter. The SIP adapter can use a connection oriented protocol and provides interactions with application code in an actor of said application server by means of asynchronized SIP protocol events. The SIP adapter can also provide stateless node mapping to a stateful server node hosting a specific session for the actor.","In the following description, the invention will be illustrated by way of example and not by way of limitation in the figures of the accompanying drawings. References to various embodiments in this disclosure are not necessarily to the same embodiment, and such references mean at least one. While specific implementations are discussed, it is understood that this is provided for illustrative purposes only. A person skilled in the relevant art will recognize that other components and configurations may be used without departing from the scope and spirit of the invention.","Furthermore, in certain instances, numerous specific details will be set forth to provide a thorough description of the invention. However, it will be apparent to those skilled in the art that the invention may be practiced without these specific details. In other instances, well-known features have not been described in as much detail so as not to obscure the invention.","In accordance with various embodiments, a set of features are described for enabling an application server platform for telecom based applications. The application server provides a protocol-neutral programming model for application developers. Rather than having to account for specific protocol entry points into the server, all interactions in the server are abstracted as asynchronous events through the event broker layer. State management and concurrency are implemented as an actor-based model, where each actor owns its own segment of state and other actors wishing to update that state send asynchronous events to the owner. This architecture allows multiple protocols to be consumed in one process, allow applications sessions to span multiple environments and protocols, and allows the programming model to be decoupled from any particular protocol entry point.","Glossary","In accordance with an embodiment, the following terms as used herein are defined below:\n\n",{"@attributes":{"id":"p-0025","num":"0063"},"figref":["FIG. 1","FIG. 1"]},"As illustrated in , in accordance with an embodiment, the application server  can include an OSGI kernel , an application component environment , an event framework layer , an actor container , an adapter container , and a selection of server services .","The OSGI kernel provides lifecycle management, class loading, dependency resolution and deployment features for the application components on the server. In accordance with an embodiment, the application components, such as applications , , , can be basic OSGI bundles deployed on the server.","The event framework layer provides an event-based communication model between the application component environment and the adapter container. In particular, the framework layer provides an event broker that maps all protocol-specific communications exposed by the various protocol adapters , , ,  into asynchronous events, which can be consumed by the application components. Additionally, the application components can produce asynchronous events for propagation to the protocol adapters via the event broker.","The protocol adapters , , ,  enable the application server to support multiple protocols. In accordance with an embodiment, each of a plurality of various protocols, such as a session initiation protocol (SIP) , an intelligent network application part (INAP) of the SS7 protocol , a hypertext transfer protocol (HTTP) , or many other protocols , can have their own adapter. These protocol adapters then interface with the adapter container, the event framework, the actor container and the server services. The adapter container can expose a service provider interface, for use in building new protocol adapters as new protocols emerge or become more widely used.","In accordance with an embodiment, the event framework layer is used to communicate with application components. With respect to the event model, the protocol adapters are consumers and producers of asynchronous events. The SPI interfaces implemented by protocol adapters reflect the complexity relative to application components. Primarily, adapters implement efficient input and output operations (I\/O) towards a specific protocol. In addition, protocol-specific security, error handling, and abstraction can be encapsulated in adapters. The adapter container is designed to support a contract in which it cooperates with the adapters to provide connectivity to the network by the application components.","The server services act as basic building blocks for the rest of the functionality implemented on the application server. In accordance with an embodiment, these services are protocol neutral, reusable, and shared by the other layers of the stack. The set of services illustrated in  is not intended to be limiting or exhaustive, and is instead being provided for purposes of illustration. In accordance with an embodiment, various server services can be implemented as needed to address the particular needs of an application developer. For example, a clustering service can be used to maintain cluster membership\/replication, while an SLA management service can be used to keep track of service level agreement (SLA) enforcement.","TCAP Adapter","In accordance with an embodiment of the invention, the application server platform can automatically generate protocol adapters (processors\/translators) based on abstract lexical notation, such as Abstract Syntax Notation One (ASN.1). For example, the application server platform includes a Transaction Capabilities Application Part (TCAP) Adapter that is based upon the TE TCAP stack. This TCAP adapter can also support CAMEL Application Part (CAP)\/Mobile Application Part (MAP) and other TCAP user protocols by receiving ASN.1 files as input.","In accordance with an embodiment, the TCAP adapter provides integration with the Protocol Adapter Container. Additionally, the TCAP adapter can decode and encode CAP\/MAP\/INAP, and encapsulate operations in unified TCAP layout. The TCAP adapter can also automatically generate CAP\/MAP\/INAP layers, using ASN1 files as input. The TCAP Adapter works like a \u201ccontainer\u201d to support CAP, MAP, INAP or other customized TCAP user protocols. Further, the TCAP adapter can transfer JAIN TCAP messages to applications as a TCAP event, and similarly can convert a TCAP event to a JAIN TCAP message to be sent to network nodes.",{"@attributes":{"id":"p-0034","num":"0072"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","204","206","208","210","212"]},"An event API (TCAPOutboundEvent\/TCAPInboundEvent) is provided to facilitate communication between applications and TCAP adapter. An additional API is provided for child event objects (Cap2OutboundEvent\/Cap2InboundEvent), this API can be extended from TCAPOutboundEvent\/TCAPInboundEvent. An OSGi Service Registry  is used to register and find specific service. ANTLR  is an ASN1 parser to parse ASN1 files  and generate java classes. Additionally, a TE SS7 server  is provided.","The TCAP inbound\/outbound Event API can organize inbound and outbound events in a hierarchy. The two interfaces are defined to communicate with the event broker, one for inbound events and one for outbound events. Regardless of the particular TCAP user protocol used, a unified TCAP event API is exposed to applications. An empty interface can be provided (for example, an empty \u201cArgument\u201d interface), which can operate as a placeholder for all possible operations. This can be used to distinguish between different TCAP user protocols. For example, !InitialDP in CAP  can extend from \u201cArgument\u201d, thus be put into a TCAPInboundEvent and sent to applications. In accordance with an embodiment, the TCAP event API definition refers to the standard JAIN TCAP API. Similar naming conventions can be followed, like InvokeIndPrimitive and InvokeReqPrimitive: \u201cInd\u201d=indication(inbound), \u201cReq\u201d=request(outbound)","The TCAP Outbound Event Factory can be used to create outbound events. Additionally, CAP2 and Map Outbound event factories can be provided which include TC-user specific methods.",{"@attributes":{"id":"p-0038","num":"0076"},"figref":"FIG. 3","b":["300","302","304","306","308"]},"In accordance with an embodiment, the TCAP Adapter can provide a plurality of functions. For example, it can interact with the EventBroker to perform handler registration, inbound event publishing, and outbound event handling. It can also interaction with the TE stack to perform binding, and receiving\/sending JAIN TCAP messages; and can perform mapping between Events and JAIN TCAP messages. The TCAP adapter can also server as a container for TCAP user protocol layers and provide basic TCAP FSM control.","In accordance with an embodiment, the TCAP Adapter includes a plurality of modules. The TCAP API module, includes the TcUserProtocolService, and is a user protocol layer which implements the API and registers itself to the TCAP Adapter. The TCAPAdapterImpl implements ProtocolAdapter, integrates with PAC, and realizes the lifecycle control. The TCAPEventHandler implements EventHandler <TCAPOutboundEvent>, TCAPOutboundEventProcessor, and is responsible for receiving TCAP events from the EB, and publishing TCAP events to the EB. The TCAPEventMapping module maps between TCAPInbound\/OutboundEvent and JAIN TCAPMessages. The TE stack for TE module implements TCAPEventListener, and encapsulates JAINTCAPProvider, JAINTCAPStack. This module is the TE client implementation to communicate with the TE server, and is responsible for binding with the TE server, and for receiving and sending JAIN TCAP messages. The RuntimeMbean can be used to show statistics, stack status, and reset connections. A configuration module uses the ConfigurationService to configure the TE client info to TE server. The TCAP FSM module is a lightweight FSM control (supplement for TE TCAP stack) for every dialogue, e.g. Application context name checking and reloading, original address filling basic call state control for TC\u2014Begin, Tc\u2014Continue and Tc\u2014end, etc","In accordance with an embodiment, a TcUserProtocolService API is exposed to the TC user layer to implement, then is registered to OSGi service registry. After the TC user layer is started, the TCAP adapter can listen to them and hold the references.",{"@attributes":{"id":"p-0042","num":"0080"},"figref":"FIG. 4","b":["400","401","402","403","404","405","406","407","408","409","410"]},{"@attributes":{"id":"p-0043","num":"0081"},"figref":"FIG. 5","b":["500","501","502","403","504","505","506","507","508","509","510","511"]},"In accordance with an embodiment, all normal incoming TCAP messages are scheduled by the single TE stack thread to keep the messages in order. That is, the TCAP adapter gets all TCAP messages in the same TE thread. To enhance the performance and ensure the correct order, the TCAP adapter can collect one dialogue event and multiple component events in the same dialogue and put them into a cache. After the last component has arrived, it can create another thread to handle those messages and publish them as one event. The EB does not guarantee the order of events.","The callback operations of the TCAPEventListener are called by different threads. A first thread, the indication event thread, can call the process VendorIndEvent, process ComponentIndEvent and process DialogueIndEvent operations when a TCAP indication event is addressed to the listener. There is one indication event thread for each JAINTCAPProvider that the listener is added to. This thread can also call the getUserAddress List operation. From J-TCAP R3 this thread can also call the process TCAPError operation, but not at the same time as the Error event thread. A second thread, the error event thread, can call the process TCAPError operation when an error has occurred in the JTCAP that cannot be thrown as exception, for example errors with the connection to the attached stack. There is one error event thread for each JAINTCAPProvider that the listener is added to. This thread can also call the getUserAddress List operation. Additionally, user threads are threads that the JTCAP-user uses to call one of the operations in the JAINTCAPProvider or the JAINTCAPStack. These threads can call the getUserAddress List operation. To avoid threading problems, all data that is updated by more than one thread in the listener, must be thread safe. Thread safe means that the data update is atomic or synchronized; and that no dead locks are possible.","All TCAP outbound events are scheduled by the EB in a separate thread by a DefaultScheduler. The TCAP adapter can handle the event within the EB's thread space, but the EB's thread pool is shared between all adapters. For safe usage, the TCAP adapter can schedule a new work thread via a work manager of the PAC and end the EB's thread.","In accordance with an embodiment, the TCAP User Protocol(CAP2\/MAP\/ . . . ) layer can include a plurality of modules. The modules support automatic generation. For every TCAP user protocol, ASN1 files are the only input. ANTLR is a powerful BNF parser, with ASN1 files and ANTLR, implementation codes can be generated. These codes can include Event API, the data type API called by Event and Event Factory API; Event implementation, encoder and decoder and Event Factory implementation; Implementation of api Tc UserProtocolService; and RunTime MBean & persistence configuration.","In accordance with an embodiment, OctetString is a specific data type in ASN1. It is a byte array, but sometimes the value is encoded in a specific way, and the rule is described in comments of ASN1 file. So the ASN1 parser cannot always recognize it and automatically encode it. For these data types a utility can be used for reliable and automatic encoding and decoding. The utility can decode so that applications can get a specific data object from an OCTETString(byte array); and encode so that applications can get a byte array from a specific data object.","The TCAP adapter can include a plurality of configuration and management functions. For example, the Runtime MBean can include a resetStackConnection, which is a method that resets the connection towards the TE server. It can also include an is ActiveStack method which shows the client connection status. A listAllTcUserProtocols method can list all registered TC user protocols names and their SSNs. A listStatistics method can list specific SSN related statistics, including total dialogues, total handled events. Similarly, these statistics can be reset using a resetStatistics method.","The Cap2 layer can also include a plurality of functions. These functions can include a registerAddress method which is used to register a current SSN into the TCAP Adapter. This method can check whether this SSN has been added by the Configuration Service. If the SSN does not exist, then the method will throw an exception. This method can also invoke TCAPConfigService's registerTCAPListener(protocolname,ssn) method. An unregisterAddress method can be used to unregister a TCAP Address by SSN, This method can check whether this SSN has been removed by the Configuration Service. If the SSN exists, the method will throw an exception. This method can also invoke TCAPConfigService's unregisterTCAPListener(protocolname,ssn) method. A listAllSSN method can be used to list all registered SSN in the current protocol service. A listOperationTimer method can list all defined OperationTimers in the current protocol service.","In accordance with an embodiment, the mapped MBean attributes can include an SSN list, which is a list of the SSNs in the current protocol service. The MBean attributes can also include a Timer List which is a list of the current TimerLists in the current protocol service.",{"@attributes":{"id":"p-0052","num":"0090"},"figref":"FIG. 6","b":["600","602","604","606","608","610","612","614","616","618","608","2","620","614","622","616"]},{"@attributes":{"id":"p-0053","num":"0091"},"figref":"FIG. 7","b":["700","702","704","706","708","710","712","714","716","718","708","2","720","722","2","724","1","726"]},"SIP Adapter","In accordance with an embodiment, the application server platform includes a session initiation protocol (SIP) adapter. The SIP adapter uses a connection oriented protocol and provides interactions with application code in an actor by means of asynchronized SIP protocol events. The SIP adapter also provides stateless node mapping to a stateful server node hosting a specific session for the actor.",{"@attributes":{"id":"p-0055","num":"0093"},"figref":"FIG. 8","b":["800","802","804","806","808","801","812","814","816","818","820"]},"In accordance with an embodiment, for UDP transporting, there can be one permanent thread listening for all inbound event from pre-configured network access points. The work manager is not used here, because this thread is time critical and not supposed to be re-used by other modules. For TCP transporting, the thread mode of inbound event is selected according NetIO implementation. For both TCP and UDP transporting, outgoing events are handled by the SipEventScheduler, which relies on the PAC assigned work manager to schedule the thread.","In accordance with an embodiment, the transaction layer  can also include a plurality of submodules. The ActorMessage Handler  handles incoming\/outgoing stack events from\/to protocolExtension (PE). The TransactionManager  is a utility to create and manage server\/client SIP transactions and put them into call state object maintained by the Call State Manager . The Call State Manager is a utility to create\/retrieve\/manage SIP call states. A CallState  is a storage object which includes a transaction object, sip session object and associated states which have to be persisted in storage service to handle fail-over. The ClientTransaction  can include a protocol layer state machine of the transactions initialized from outbound event. The ServerTransaction  can include a protocol layer state machine of transactions initialized from incoming event. The SipSession object  can include several transaction objects, and can represent a SIP dialog. The SipProxy  is an internal utility class used to realize SIP proxy features. The SipEventMapping  can be used to translate between SIP stack events (exchanged between transport and transaction) and SIP events (used for application). The SipEventFactory  is a utility class used by application developers to create SIP events and associated URI objects.","The transaction layer can be realized by means of the Actor Protocol Context (Actor Protocol Extension), which re-uses the actor scheduler thread, no additional thread mode is introduced.",{"@attributes":{"id":"p-0059","num":"0097"},"figref":"FIG. 9","b":["900","902","904","906"]},{"@attributes":{"id":"p-0060","num":"0098"},"figref":"FIG. 10","b":"1000"},"The Configuration MBeans  can include a plurality of configuration items which are configured means of JAXB POJO  provided by configuration service and represented as Mbeans automatically. They are read-write from administrator's perspective. The configuration MBeans can include the name of this network accesspoint. The configuration Mbeans can indicate which managed server this network accesspoint is applied to. A value of null indicates that it is applied to whole domain. The configuration Mbeans can also include the protocol this network channel should use for connections, and the IP address or DNSname this network channel uses to listen for incoming connections. A value of null indicates that all network interface will be listened. The ListenAddress_Port indicates the default TCP port this network accesspoint uses to listen for regular (non-SSL) incoming connections. Minimum value: 1, Maximum value: 65535. The ListenAddress_Address Type indicates the address type (e.g., internet) and the ListenAddress_NetworkType indicates the network type (e.g., IP4). The ExternalListenAddress_Host indicates the IP address or DNSname representing the external identity of this network channel. A value of null indicates that the network channel's Listen Address is also its external address. This is required for the configurations which need to cross a firewall doing Network Address Translation. The ExternalListenAddress_Port is the externally published listen port for this network accesspoint. Minimum value: 1, Maximum value: 65535. The ExternalListenAddress_Address Type and ExternalListenAddress_NetworkType: indicate the address and network type similar to the ListenAddress parameters.","The Complete Message Timeout indicates the maximum amount of time this network accesspoint waits for a complete message to be received. A value of 0 disables network accesspoint complete message timeout. This timeout helps guard against denial of service attacks in which a caller indicates that they will be sending a message of a certain size which they never finish sending. Minimum value: 0 s Maximum value: 480 s. The Idle Connection Timeout indicates the maximum amount of time (in seconds) that a connection is allowed to be idle before it is closed by this network accesspoint. This timeout helps guard against server deadlock through too many open connections. Minimum value: 0 s. The Maximum Message Size indicates the maximum message size allowable in a message header. This maximum attempts to prevent a denial of service attack whereby a caller attempts to force the server to allocate more memory than is available thereby keeping the server from responding quickly to other requests. Minimum value: 4096 bytes Maximum value: 100000000 bytes. The Maximum Connected Clients indicates the maximum number of clients that can be connected on this network accesspoint.","In accordance with an embodiment, the SIP server can include a plurality of elements.","The T Timeout Interval represents the duration of the SIP protocol T timer, in milliseconds. Timer T also specifies the initial values of Timers A, E, and G, which control the retransmit interval for INVITE requests and responses over UDP. Timer T affects the values of timers F, H, and J, which control retransmit intervals for INVITE responses and requests; these timers are set to a value of 64 T milliseconds. The default is 500 ms.","The T Timeout Interval represents the duration of the SIP protocol T timer, in milliseconds. Timer T defines the retransmit interval for INVITE responses and non-INVITE requests. The default is 4 s.","The T Timeout Interval represents the duration of the SIP protocol T timer, in milliseconds. Timer T specifies the maximum length of time that a message remains in the network. Timer T also specifies the initial values of Timers I and K, which control the wait times for retransmitting ACKs and responses over UDP. The default is 5 s.","The Timer B Timeout Interval represents the duration of the SIP protocol Timer B, in milliseconds. Timer B specifies the length of time a client transaction attempts to retry sending a request. If the Timer B value is not configured, the server derives a value from timer T (64 T, or 32000 milliseconds by default). The Timer F Timeout Interval represents the duration of the SIP protocol Timer F, in milliseconds. Timer F specifies the timeout interval for retransmitting non-INVITE requests. If the Timer F value is not configured, the server derives a value from timer T  (64 T, or 32000 milliseconds by default).","In accordance with an embodiment, the Server Header Insertion specifies the conditions for inserting a Server header into SIP messages. Use this attribute to limit or eliminate Server headers to reduce the message size for mobile networks, or to increase security. By default, SIP Server inserts no Server header into SIP messages. The Server Header Value specifies the value of the Server header inserted into SIP messages. The SIP Server enables an administrator to control the text that is inserted into the Server header of generated messages. This provides additional control over the size of SIP messages and also enables you to mask the server entity for security purposes. To configure the header contents, the administrator can enter a string value. By default, SIP Server does not insert a Server header into generated SIP messages. If Server Header Insertion is enabled but no Server Header-value is specified, SIP Server inserts a default value.","In accordance with an embodiment, the Default Form for Header Insertion specifies how the server applies rules for compacting SIP message headers. This element configures the server-wide, default behavior for using or preserving compact headers in SIP messages. This element can be set to one of several different values. When set to compact:, the Sip Adapter uses the compact form for all system-generated headers. However, any headers that are copied from an originating message (rather than generated) use their original form. When set to force compact, the Sip Adapter uses the compact form for all headers, converting long headers in existing messages into compact headers as necessary. When set to long, the Sip Adapter uses the long form for all system-generated headers. However, any headers that are copied from an originating message (rather than generated) use their original form. When set to force long, the Sip Adapter uses the long form for all headers, converting compact headers in existing messages into long headers as necessary.","The Enable DNSServer Lookup element specifies whether the server performs DNS lookup. If this attribute is set to \u201ctrue,\u201d then the server can use DNS to: Discover a proxy server's transport, IP address, and port number when a request is sent to a SIP URI. Resolve an IP address and\/or port number during response routing, depending on the contents of the Sent-by field. For proxy discovery, Falcon Sip Adapter uses DNS resolution only once per SIP transaction to determine transport, IP, and port number information. All retransmissions, ACKs, or CANCEL requests are delivered to the same address and port using the same transport. When a proxy needs to send a response message, the Sip Adapter uses DNS lookup to determine the IP address and\/or port number of the destination, depending on the information provided in the sent-by field and via header. By default, DNS resolution is not used (\u201cfalse\u201d). Note: Because DNS resolution is performed within the context of SIP message processing, any DNS performance problems result in increased latency performance. It is recommended to use a caching DNS server in a production environment to minimize potential performance problems.","The Enable Contact Header For Non-Reliable Provisional (1xx) Response element specifies whether the server puts Contact Header in a non-reliable provisional(1xx) response having a To tag. This is not applicable for 100 and possible values are true and false. If this attribute is set to \u201ctrue,\u201d then the server puts a Contact header. The Globally Routable URI is a Globally-Routable User Agent URI (GRUU) that the Sip Adapter automatically inserts into Contact and Route-Set headers when communicating with network elements. The URI specified in this element should be the GRUU for the entire Falcon Sip Adapter cluster. In a single server domain, specify a GRUU for the server itself. Note that User Agents (UAs) deployed on the Sip Adapter typically obtain GRUUs via a registration request. In this case, the application code is responsible both for requesting and subsequently handling the GRUU. To request a GRUU the UA would include the \u201c+sip.instance\u201d Contact header field parameter in each Contact for which GRUU is required. Upon receiving a GRUU, the UA would use the GRUU as the URI for the contact header field when generating new requests. The Enable RPort element specifies whether symmetric response routing is requested (via the rport parameter) for requests generated by Kendo SIP Adapter. When this option is enabled, symmetric response routing is in effect.","In accordance with an embodiment, a Route Header can push a default route header on initial requests if no route header is specified. This is used for S-CSCFURI. Message debugging can be enabled\/disabled using the Enable Debug element. By default, message debugging is off (false). The debug level can be set to include a predefined collection of information to log for each SIP request and response. These predefined collections can include terse, which logs only the domain setting, logging level, and whether or not the message is an incoming message; basic, which logs the terse items plus the SIP message status, reason phrase, the type of response or request, the SIP method, the From header, and the To header; and full, which logs the basic items plus all SIP message headers plus the timestamp, protocol, request URI, request type, response type, content type, and raw content.","In accordance with an embodiment, if connection pools are utilized the Pool Name, Destination Host, Destination Port, and Maximum Connections can be specified. SipEvents include the attribute connection_id and node_id (adapter_id). At least for reliable transports such as TCP, the sip stack sends responses back according to the connection which the associated request of same transaction comes in. SipEvents include the attribute SESSION_ID (callId), Therefore regardless of which connection and which node a SIP event comes in, it will be forwarded to one actor by the eventbroker as long as the actor registered the dialog. The CallState of one actor is persisted into the storage service of an actor by protocolExtension, so that the transaction state and call state could survive by actor failing over.","In accordance with an embodiment, SIP-aware actors can implement a SIPProtocolBinding interface to get one instance of an SipEventFactory, which can be called back in an on Bind( ) method, between actor.start( ) and actor.resume( ).","In accordance with an embodiment, a SipInboundEventProcessor is provided. The SIP inbound event processor is a utility to provide strong-typed event dispatching. The SipEventFactory is a factory class to create sip outbound event according the inbound event. SIP events are mapped to different event classes according request type in RFC. There is a SipDialogTerminated event, to provide application developers one notification that an SIP dialog (session) has been terminated, without knowing detail of SIP call flows. It is useful when terminating a dialog associated with one or more actors. This event can be used to efficiently and safely perform actor clean-up, including shutdown actor and\/or un-register dialog. A best practice is to take advantage of SipDialogTerminated event. The system can automatically generate this event and dispatch it to applications when all SIP transactions within a SIP dialog are terminated. The application can listen for this event and make associated clean-up during the events' call back, without having to take care of the resource issues in signaling FSM. Two useful methods available in this event include getCallId( ) which can be used to identify which dialog is terminated, and getRemainingDialogCount( ) which can be used to know how many ongoing dialogues are still pending by the time this event is generated.","Actor Protocol Context","In accordance with various embodiments, the protocol specific state information is transactionally maintained on the application server on behalf of application programmable units. In accordance with an embodiment, the protocol specific state is maintained transparent to user code. The protocol context includes a suite of APIs to provide more flexibilities for the application developers to program protocol associated applications, as well as a framework to provide protocol adapter developers an opportunity to decorate and validate the protocol events within the context of an actor to make a stateful protocol stack.","Protocol extension enables one abstract class to be registered to an actor framework to decorate an event to\/from the actor. PE is designed to be as transparent as possible to application logic. Protocol extension (PE) is used to be the decorator to hook the incoming\/outgoing event from\/to the actor. Incoming\/outgoing events can reject PE and the PE author can decide to filter events or reject events including by implementing a callback and returning a different direction of events. The framework supports decorating events in the same direction, and returning inbound events for outbound events, as well as returning multiple events in different directions.","In accordance with an embodiment, PE is notified when an event fails to dispatch. A PE implementation can choose to return the passed event after handling and give an actor an opportunity to review the event, or return null so that actor will not receive it anymore (useful when a event is generated by the PE itself). It is also possible to start timer in PE. The timerEvent scheduled by PE will not reject the actor but the PE itself, therefore the PE layer timer and application layer timer are isolated. If multiple timers are scheduled, they can be distinguished using event callbacks.","In accordance with an embodiment, one PE instance is created per actor instance. When an actor is started, a PE is started. Similarly, when an actor is revived, a PE is created. When an actor is shutdown, e.g., when an application calls actorLifecycle.suspend( ) the PE makes a final garbage collection and notifies the framework of the shutdown by calling CompletionBarrier.complete( ). If the framework does not receive CompletionBarrier.complete( ) in a specified period, a force stop method can be called to give the PE a chance to make forceful finalizing. When an actor is migrated, the PE can finalize local variables which are not supposed to survive during action migration, and change some run time statistics if required.","In some cases the actor and PE are not supposed to stop work immediately when application decide to shutdown the actor. Therefore the framework will wait to stop the actor, and thus wait to call actor.suspend( ) until the PE notifies the framework that suspending work of PE is finished. As long as CompletionBarrier?.getCallback( ) is called in on Suspend( ) the system will assume a delayed shutdown and wait for the complete notification to finalize other resources. If PE can make sure all the finalize work is already finished in on Suspend( ) it can either explicitly call CompletionBarrier?.getCallback( ) completed( ) or not take any action on Completion Barrier?. The framework will recognize the two cases and consider the PE suspend completed without waiting for a complete notification. This will destroy actor resources immediately.","In accordance with an embodiment, a PE developer can choose to write persistence data into Coherence (such as FSM state which needs to be durable when failing-over\/migration).","In accordance with an embodiment, an opened OSGI service of the actor framework can be used when registering a PE. There are two ways to registering a PE. Using OSGi API, protocolName is identical to the attribute ATTRIBUTE_PROTOCOL_NAME in ProtocolEvent?. The framework relies on the parameter protocolName to identify whether a PE is triggered for a specified protocolEvent. Using Declarative APC, by declaring a PE class name in meta-data, the actor framework will auto-recognize it and register it automatically. In this case, the Protocolname? has to be defined as an annotation of ProtocolExtension? class.",{"@attributes":{"id":"p-0083","num":"0121"},"figref":["FIG. 11","FIG. 11"],"b":["1100","1102","1104","1106","1108"]},{"@attributes":{"id":"p-0084","num":"0122"},"figref":"FIG. 12","b":["1212","1200","1202","1204","1206","1208","1210","1212","1212","1204"]},"Throughout the various contexts described in this disclosure, the embodiments of the invention further encompass computer apparatus, computing systems and machine-readable media configured to carry out the foregoing systems and methods. In addition to an embodiment consisting of specifically designed integrated circuits or other electronics, the present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art.","Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.","The various embodiments include a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a general purpose or specialized computing processor(s)\/device(s) to perform any of the features presented herein. The storage medium can include, but is not limited to, one or more of the following: any type of physical media including floppy disks, optical discs, DVDs, CD-ROMs, microdrives, magneto-optical disks, holographic storage, ROMs, RAMs, PRAMS, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs); paper or paper-based media; and any type of media or device suitable for storing instructions and\/or information. The computer program product can be transmitted in whole or in parts and over one or more public and\/or private networks wherein the transmission includes instructions which can be used by one or more processors to perform any of the features presented herein. The transmission may include a plurality of separate transmissions. In accordance with certain embodiments, however, the computer storage medium containing the instructions is non-transitory (i.e. not in the process of being transmitted) but rather is persisted on a physical device.","The foregoing description of the preferred embodiments of the present invention has been provided for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations can be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the relevant art to understand the invention. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3","b":"300"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4","b":["400","401"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
