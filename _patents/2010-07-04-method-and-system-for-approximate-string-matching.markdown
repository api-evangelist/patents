---
title: Method and system for approximate string matching
abstract: Approximate string matching of a target string to a trie data structure in which the trie data structure has a root node and generations of child nodes, each node representing at least one character in an alphabet to provide a lexicon of words and word fragments. Traversing the trie data structure includes starting from the root node by comparing each node of a branch of the trie data structure to characters in the target string and adding characters traversed in a branch of the trie data structure to a gathered string to provide suggestions of approximate matches. If a node is reached that is flagged as a node for a word or a word fragment and, and if the target string is longer than the gathered string, the method loops back to the root node, and continues the traverse from the root node. At each node, the system determines if there is a correction rule for one or more characters in the remainder of the target string from the current node, and if so, applies the correction rule to the target string to obtain a modified target string.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251294&OS=09251294&RS=09251294
owner: International Business Machines Corporation
number: 09251294
owner_city: Armonk
owner_country: US
publication_date: 20100704
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["The present application is a Continuation under 35 U.S.C. 120 of commonly assigned prior U.S. application Ser. No. 11\/154,120, filed Jun. 16, 2005 in the names of Alexei Nevidomski and Pavel Volkov, now allowed, and accordingly also claims priority under 35 USC 119 to United Kingdom Application Number 0413743.6, filed Jun. 19, 2004.","This invention relates to the field of approximate string matching in a computer system. In particular, the invention relates to approximate matching of strings of characters with words and parts of words in a trie-based dictionary.","Approximate matching for a string of characters has applications in many areas. One area is spell-checking applications which locate words which are closely similar to a series of letters found in a text. Suggestions of correct spelling in a chosen language are found and displayed for a user to choose from. Another application of approximate searching is searching for a query correction in a search engine. Also, approximate matching for a string of characters may be used in a non-language based application, for example, close matches in a database may be required. Some of the known methods of approximate string matching are described below.","Linear searches can be carried out in which the target string is compared to each dictionary entry. Edit distance, n-grams, or other criteria can be used to reject candidates. This has the disadvantage that it is a very slow method of searching.","Partial enumeration using a hash function is another method. A special hash function is used which is invariant for certain types of mistakes. For example, the \u201csoundex\u201d function used by Oracle Corporation returns a phonetic representation of a string. This method inherits common drawbacks of hashing in which the quality depends on the function used, its performance may deteriorate to linear in the case of a high level of collisions, and there is additional space required to build the hash table.","The segmentation approach (n-gram method) is based on the assumption that the target string and candidates should have common substrings. The index is built from substrings of certain length (n-grams) and therefore it is possible to avoid a linear search in most cases and therefore this is faster than a linear search.","The classic spell-checker method is based on the modification of a target word according to known correction rules and performing simple look up in the dictionary. This method is suitable only for closed classes of applications. However, the method does have the advantage of bringing context to the process.","Trie data structures are used to carry out string searches particularly through large texts. The term \u201ctrie\u201d stems from the word \u201cretrieval\u201d. Trie structures are multi-way tree structures which are useful for storing strings over an alphabet. Trie structures are used to store large dictionaries of words. The alphabet used in a trie structure can be defined for the given application, for example, {0,1} for binary files, {the 256 ASCII characters}, {a,b,c . . . x,y,z}, or another form of alphabet such as Unicode, which represents symbols of most word languages.","The concept of a trie data structure is that all strings with a common prefix propagate from a common node. A node has a number of child nodes of, at most, the number of characters in the alphabet and a terminator. The string can be followed from the root to the leaf at which there is a terminator that ends a string. In this way a trie-based dictionary can be built for a lexicon. For example, an English-language dictionary can be stored in this way. A trie-based dictionary has the advantage that the data is compressed due to the common entries for prefixes and possibly postfixes. A method of scanning a trie-based dictionary in order to recover approximate matches is called a trie walker.","IEEE Transactions on Knowledge and Data Engineering August 1996 (Vol. 8, No. 4) pp. 540-547, H. Shang, T. H. Merrett, \u201cTries for Approximate String Matching\u201d describes a method of approximate string matching based on the usage of a trie-based dictionary. The lexicon of the trie-based dictionary is stored as a finite state machine i.e. along a path in the digital tree or trie as described in Proceedings of the International Symposium on Cooperative Database Systems for Advanced Applications, Kyoto, 1996. World Scientific, 1996. T. H. Merrett, H. Shang, Xiaoyan Zhao: \u201cDatabase Structures, Based on Tries, for Text, Spatial, and General Data\u201d, pp. 507-515.","The computational complexity of approximate string matching is a recurrent problem. The approximate matching procedure is a non-deterministic trie walker with rejects. Its computational complexity for a certain target word depends only on the target word length and the average distribution of the degree of a dictionary graph group, which is not much correlated to the dictionary size for natural languages. Thus, the complexity remains sub-linear to the size of the dictionary in practice for natural languages, i.e. with the growth of dictionary size the number of operations tends to be proportional to the length of the target word rather than the number of dictionary entries.","Approximate string matching in a trie-based dictionary also allows the combination of exact and approximate word matching. These advantages plus the fact that trie indexes contract prefixes and possibly postfixes and thus are compact in storage are the reasons of prevalence for this method of approximate matching.","Along with the advantages stated above, the trie-based method has drawbacks. One of the drawbacks is that it is not possible to use the method in its pure form for certain applications as natively it operates out of context. The only context available is the dictionary lexicon, which is not enough. For example, in order for spell-checkers to provide intelligent suggestion, they should rely on a set of common phonetic errors for a certain language, character similarity during optical character recognition (for example, i and l, cl and d, m and rn), or close layout of certain keys on a keyboard. This form of context is not provided in the known method.","Another example of an improvement provided by bringing the context into the process is the \u201cDid you mean?\u201d functionality of search engines. Suggestion of an alternative query can be found by substituting different fragments of the query with relevant synonyms while performing approximate match in the dictionary of previous queries. Thus context dependent correction rules are needed along with approximate match methods in order to bring context and improve intelligence by better narrowing and ranking of the set of result suggestions.","However, combining the application of text correction rules and practical non-deterministic traversing of the trie is a complicated task which historically has been performed in several passes as described in U.S. Pat. No. 6,616,704.","Another drawback is related to a prevalent practice of storing word fragments along with stand-alone words, particularly, although not exclusively, in applications for natural language processing for languages like German, Dutch, Danish, Swedish, Norwegian, Dutch, Icelandic, Afrikaans, etc. This practice permits the creation of compact dictionaries. A disadvantage to this approach is that the methods of approximate matches for compound words in dictionaries of word fragments do not match exact decompounding methods and require separate implementations.","A further drawback is that the implementation of suggestion gathering depends on the technique used for error value computation. While traversing the dictionary, the trie walker gathers suggestions, which conform to a predefined error tolerance as described in the reference IEEE Transactions on Knowledge and Data Engineering August 1996 (Vol. 8, No. 4) pp. 540-547, H. Shang, T. H. Merrett, \u201cTries for Approximate String Matching\u201d. Paths where the error value exceeds the error tolerance are rejected by the trie walker.","There are two prevalent techniques for error value computation in practice. For natural language applications, the notion of edit distance is used. Edit distance is a minimum number of changes such as replacement, insertion or deletion of one symbol, which have to be made to match two strings. There is one more operation, which has to be considered for spell aid applications\u2014transposition of two symbols. The second prevalent method of error value computation is sequence-oriented. It is based on the calculation of the number of common substrings of fixed length or n-grams. This method is used in areas such as computational biology, in particular in DNA sequence matching as described in reference R. C. Angell, G. E. Freund, and P. Willett, \u201cAutomatic spelling correction using a trigram similarity measure\u201d, Information Processing and Management, 19:255-261, 1983. Thus, there is an open option for the technique for error value computation in approximate string matching in a trie-based dictionary which is desirable to preserve.","The aim of the present invention is to provide an approximate string matching method, which inherits the advantages of approximate matching in a trie-based dictionary such as sub-linear computational complexity, combination of exact and approximate matches, dictionary compactness and independency of the method of error value computation, but which also reduces the approximate string matching task to appropriate context and is able to operate against a dictionary of word fragments.","A method of single pass, rule-driven approximate string matching in a trie-based dictionary is described as a lookup process for possibly non-delimited words against a trie-based dictionary of words along with word fragments, which results in a set of suggestions.","The following features are provided by aspects of the present invention which improves the prior technique of approximate string matching using a trie-based dictionary:","1. In order to follow context dependent correction rules during approximate string matching, a target input string has to be modified according to a correction rule if there is a match of the correction rule found at any position in the target string during non-deterministic trie traversing. In such a case, sequence-to-sequence character substitution is done according to the matched rule, and the non-deterministic traversing continues for the modified target as well as for the original target string. No additional modifications of the modified target string are allowed within its already modified parts.","2. In order to operate against a dictionary of word fragments, the prevalent trie walker is looped back to the root node of the dictionary trie if a word fragment gloss node is met and the gathered suggestion is shorter than the input target string.","3. As a supplement to the previous modification, in order to split non-delimited words (i.e. words with no word breaks) the trie walker is looped back to the root node and a word break is inserted into the currently gathered suggestion if a stand-alone word gloss node is met or a compound word is completed and the gathered suggestion is shorter than the target string.","According to a first aspect of the present invention there is provided a method of approximate string matching of a target string to a trie data structure, the trie data structure having a root node and generations of child nodes each node representing at least one character in an alphabet, the method comprising: traversing a trie data structure starting from the root node by comparing each node of a branch of the trie data structure to characters in the target string; adding characters traversed in a branch of the trie data structure to a gathered string; reaching a node flagged as a node for a word or a word fragment and, if the target string is longer than the gathered string, looping back to the root node, and continuing the traverse from the root node.","Preferably, at the step of reaching a node flagged as a node for a word or a word fragment, if the node is flagged as a word and if the target string is longer than the gathered string, the method includes adding a word break to the gathered string before looping back to the root node. However, if the node is flagged as a word fragment and if the target string is longer than the gathered string, the method includes looping back to the root node and continuing to add characters to the gathered string.","The method may also include: at each node, determining if there is a correction rule for one or more characters in the remainder of the target string from the current node; if so, applying the correction rule to the target string to obtain a modified target string. A correction rule may be a sequence to sequence character substitution. If a correction rule is applied, the method may include continuing the traverse for the modified target string as well as for the original target string and no additional modifications of the modified target string may be allowed within its already modified parts.","The method may also include at each node accepting a match for a character by appending the character to a gathered string and incrementing the current character in the target string, or applying an edit operation to a gathered string and incrementing a count of an error value for the approximation. The method may include predefining edit operations to be skipped depending on the edit operations carried out in previous steps of the traverse.","Preferably, the traverse is a single, non-deterministic pass which gathers entries which conform to an error tolerance.","According to a second aspect of the present invention there is provided a system for approximate string matching of a target string to a trie data structure, the system comprising: a trie data structure having a root node and generations of child nodes each node representing at least one character in an alphabet; means for traversing a trie data structure starting from the root node by comparing each node of a branch of the trie data structure to characters in the target string and adding characters traversed in a branch of the trie data structure to a gathered string; means for determining if a node is flagged as a node for a word or a word fragment and means for comparing the length of the target string to the length of the gathered string; means for looping back to the root node when the means for determining determines a node flagged as a node for a word or a word fragment and the means for comparing determines that the target string is longer than the gathered string.","The system may also include means for indicating if a node is a word or a word fragment and, if a word fragment, the position of the word fragment in a word.","The system may include means for providing a set of suggestions from the trie data structure. The system may also include a set of correction rules for applying a sequence to sequence substitution within a target string.","According to a third aspect of the present invention there is provided a computer program product stored on a computer readable storage medium, comprising computer readable program code means for performing the steps of: traversing a trie data structure starting from the root node by comparing each node of a branch of the trie data structure to characters in the target string; adding characters traversed in a branch of the trie data structure to a gathered string; reaching a node flagged as a node for a word or a word fragment and, if the target string is longer than the gathered string, looping back to the root node, and continuing the traverse from the root node.","According to a fourth aspect of the present invention there is provided a method of approximate string matching of a target string to a trie data structure, the trie data structure having a root node and generations of child nodes each node representing a character in an alphabet, the method comprising: traversing a trie data structure starting from a root node by comparing each node of a branch of the trie data structure to characters in the target string; at each node, determining if there is a correction rule for one or more characters in the remainder of the target string from the current node; if so, applying the correction rule to the target string to obtain a modified target string.","A correction rule may be a sequence to sequence character substitution. The method may include continuing the traverse for the modified target string as well as for the original target string and no additional modifications of the modified target string may be allowed within its already modified parts. The correction rules may be stored in the trie data structure or, alternatively, they may be stored in a separate, second data structure.","The method may also include: adding characters traversed in a branch of the trie data structure to a gathered string; reaching a node flagged as a node for a word or a word fragment and, if the target string is longer than the gathered string, looping back to the root node, and continuing the traverse from the root node.","At the step of reaching a node flagged as a node for a word or a word fragment, if the node is flagged as a word and if the target string is longer than the gathered string, the method may include adding a word break to the gathered string before looping back to the root node. However, if the node is flagged as a word fragment and if the target string is longer than the gathered string, the method may include looping back to the root node and continuing to add characters to the gathered string.","The method may include at each node: accepting a match for a character by appending the character to a gathered string and incrementing the current character in the target string; or applying an edit operation to a gathered string and incrementing a count of an error value for the approximation. The method may include predefining edit operations to be skipped depending on the edit operations carried out in previous steps of the traverse.","Preferably, the traverse is a single, non-deterministic pass which gathers entries which conform to an error tolerance.","According to a fifth aspect of the present invention there is provided a system for approximate string matching of a target string to a trie data structure, the system comprising: a trie data structure having a root node and generations of child nodes each node representing at least one character in an alphabet; means for traversing a trie data structure starting from the root node by comparing each node of a branch of the trie data structure to characters in the target string and adding characters traversed in a branch of the trie data structure to a gathered string; and a set of correction rules for applying a sequence to sequence substitution within a target string.","The set of correction rules may be stored in the trie data structure or, alternatively, they may be stored in a separate data structure.","The system may also include: means for determining if a node is flagged as a node for a word or a word fragment and means for comparing the length of the target string to the length of the gathered string; means for looping back to the root node when the means for determining determines a node flagged as a node for a word or a word fragment and the means for comparing determines that the target string is longer than the gathered string. The system may include means for indicating if a node is a word or a word fragment and, if a word fragment, the position of the word fragment in a word.","The system may also include means for providing a set of suggestions from the trie data structure.","According to a sixth aspect of the present invention there is provided a computer program product stored on a computer readable storage medium, comprising computer readable program code means for performing the steps of: traversing a trie data structure starting from a root node by comparing each node of a branch of the trie data structure to characters in the target string; at each node, determining if there is a correction rule for one or more characters in the remainder of the target string from the current node; if so, applying the correction rule to the target string to obtain a modified target string.","Referring to , a computer system  is shown on which the present invention may be implemented. A computer system  has a central processing unit  with primary storage in the form of memory  (RAM and ROM). The memory  stores program information and data acted on or created by the programs. The program information includes the operating system code for the computer system  and application code for applications running on the computer system . Secondary storage includes optical disk storage  and magnetic disk storage . Data and program information can also be stored and accessed from the secondary storage.","The computer system  includes a network connection means  for interfacing the computer system  to a network such as a local area network (LAN) or the Internet. The computer system  may also have other external source communication means such as a fax modem or telephone connection.","The central processing unit  includes inputs in the form of, as examples, a keyboard , a mouse , voice input , and a scanner  for inputting text, images, graphics or the like. Outputs from the central processing unit  may include a display means , a printer , sound output , video output , etc.","In a distributed system, a computer system  as shown in  may be connected via a network connection  to a server on which applications may be run remotely from the central processing unit  which is then referred to as a client system.","Applications which may run on the computer systems from a storage means or via a network connection may include word processing programs, Internet access programs including search engines for searching the World Wide Web, other text indexing and retrieving programs for databases, machine translation programs for translating foreign language documents, optical character recognition programs for recognizing characters from scanned documents, etc.","Many of these applications include executable code for carrying out approximate string matching against given resources. For example, a spell checking application carries out approximate string matching of words in a document executed in an application against a resource in the form of a dictionary of words in a chosen language and suggests alternatives to an unrecognized word. As another example, a search engine may include a word recognition application which compares an input word with words in a dictionary and suggests other words which may have been intended for the search input. Approximate string matching is not limited to word analysis and can extend to data base retrieval of recognized references and other applications.","One technique for approximate string matching uses a resource in the form of a trie-based dictionary. Referring to , a trie data structure  is shown. The trie data structure  is a multi-way tree structure with a root node  from which child nodes extend. In turn, each child node can become a parent node with child nodes of its own. The nodes in the trie data structure represent characters in an alphabet and a string of characters is represented by following a route down the trie from the root node  to a leaf node . Leaf nodes are provided by terminators for a recognized string of characters.","A trie data structure can be used to store a large dictionary of words and parts of words. The alphabet can be defined for the given application, for example, {0,1} for binary files, {the 256 ASCII characters}, {a,b,c . . . x,y,z}, or another form of alphabet such as Unicode, which represents symbols of most word languages.","The concept of a trie data structure is that all strings with a common prefix propagate from a common node. When the strings are words in the alphabet {a,b,c . . . x,y,z}, a node usually has at most 27 child nodes\u2014one for each letter and a terminator. The alphabet may also include punctuation characters such as an apostrophe or a hyphen in which case a node may have more child nodes. The string can be followed from the root to the leaf that ends a string. A trie-based dictionary has the advantage that the data is compressed due to the common entries for prefixes. A method of scanning a trie-based dictionary in order to recover approximate matches is called a trie walker.","In the example shown in , a trie data structure  is shown with a root node . The root node  will have a maximum number of child nodes for the characters in the alphabet plus a terminator. One path is illustrated in the trie  from the child node for the letter \u201cb\u201d . The string \u201cbe\u201d is a recognized word and therefore a terminator node  is a child node from the letter \u201ce\u201d . Similarly, the following recognized words are shown in the trie : \u201cbee\u201d, \u201cbeen\u201d, \u201cbean\u201d, \u201cbeans\u201d, \u201cbeat\u201d, \u201cbeats\u201d, \u201cbeaten\u201d, \u201cbeater\u201d, \u201cbeaters\u201d. Where each valid word ends in the trie , a terminator node is provided. The terminator node is referred to as a gloss node where the root-to-node path string is a valid dictionary entry.","A trie data structure represents a dictionary of words or recognized sequences of characters to which the approximate string matching technique compares a target string of characters which is the subject of the approximate matching. The target string is compared, one character at a time, to the nodes in a trie starting at the root node.","A traverse refers to a recursive process of constructing a string for every root-to-node path in the trie from an empty string. The traverse adds characters to a gathered string as it progresses through the trie. A trie walker refers to the recursive procedure of dictionary traversing defined above. The master dictionary refers to a dictionary which is subject to traverse.","An error value for the approximation is set to determine how many differences are allowed between the target string and the valid dictionary entries. For example, if the error value is set to 1, only one operation to change a character in the string can be allowed before the route through the trie is rejected.","If a current node in a trie path matches the current node in a target string, the current node in the trie path is appended to the gathered string. If a current node in the trie path does not match the current character in the target string, an edit operation is carried out such as an insertion or a deletion.","The target string must always progress one character forward in the target string, extending it with imaginary non-matching characters if necessary.","This method of target string matching is a non-deterministic trie walker with rejects. While traversing the dictionary the trie walker gathers suggestions, which conform to some predefined error tolerance. Paths whose error value exceeded the error tolerance are rejected by the trie walker. The process is independent from the method of error value computation.","In accordance with an aspect of the present invention, a method is described in which approximate string matching in a trie-based dictionary includes correction rules in the trie data structure. A target string is modified according to a correction rule if there is a match for a correction rule found at a position in the target string during a traverse. A correction rule refers to a pair of character sequences that describe a possible substitution within the target string, for example, substitution of sequence \u201cph\u201d to \u201cf\u201d is a correction rule reflecting a common phonetic misspelling for natural languages. A sequence-to-sequence character substitution is carried out according to the matched correction rule. The traversing then continues for the modified target string as well as for the original target string. No additional correction rules or other edit operations are allowed within the modified target string.","This provides a deterministic lookup procedure for the remainder of the target string at each trie node from the current position of the trie walker in order to match a correction rule. Each prefix of the remainder of the target string, which matches a correction rule, is substituted by the rule correction pair, and the traversing continues for the original target string and for the modified target strings.","The lookup for correction rules is forbidden within parts of the target string that have already been modified, in order to prevent overlapping of rules. Correction rules can be stored either in the master dictionary or in another dictionary not necessarily having a trie based structure. Applying the modification above forces the trie walker to operate with a modified target string according to the correction rule, thus correction rules are applied in parallel with trie traversing.","Another aspect of the present invention includes a trie-based dictionary with gloss nodes for word fragments as well as for complete words. A method is described which includes looping the trie walker back to the root node if it reaches the gloss node of a word fragment and the current gathered suggestion is shorter than the target string. This forces the trie walker to accept word fragments along with stand-alone words.","Non-delimited words (i.e. two or more words joined with no word breaks) can also be split by looping the trie walker back to the root node and appending a word break symbol to the current gathered suggestion if it reaches the gloss node of a stand-alone word or completes a compound word, and the current gathered suggestion is shorter than the target string. This forces the trie walker to split non-delimited words including compound words.","Edit operations which may be carried out as approximations in a traverse in accordance with an embodiment of the method of the present invention are as follows:\n\n","In addition, a specific performance improving technique is described in which certain edit operations are conditionally skipped depending on certain operations during the previous steps. These operations are shown in the following table:",{"@attributes":{"id":"p-0076","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"insertion","Substitution","deletion","Transposition"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["insertion",{},{},"skip","skip"]},{"entry":["substitution","skip"]},{"entry":["Deletion","skip","Skip",{},"skip"]},{"entry":["transposition",{},{},{},"skip"]},{"entry":["Match",{},{},{},"skip"]},{"entry":["White space",{},{},{},"skip"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"In the table, the rows are currently performed operations and the columns show marked operations forbidden for the next step. The reason is that one and the same result can be achieved by different sequences of operations, for example, \u201cinsertion+deletion\u201d=\u201csubstitution\u201d, and \u201csubstitution+deletion\u201d=\u201cdeletion+substitution\u201d. Preventing these extraneous operations from happening significantly reduces the amount of operations.","The described method is reducible to the prior known technique of approximate string matching in a trie-based dictionary by transformation of polynomial complexity O(r) where r is a number of correction rules and q is the maximum word length for a certain lexicon. Thus, the complexity of the described method is congruent to the complexity of the known method of approximate string matching using a trie-based dictionary. The method remains sub-linear in practice where the number of correction rules is substantially smaller than the number of entries in the master dictionary. The method remains independent of the method for error value computation.","Referring to , a schematic block diagram of the system components embodying an example of the described system is provided. A trie walker procedure  is a process that implements a non-deterministic trie walker with rejects. The procedure  performs a single non-deterministic traverse of a specified master trie  and gathers entries which conform to a predefined error tolerance. The procedure  also applies correction rules from a specified dictionary of correction rules , .","The master trie  is defined in a finite state framework  and is a trie-based dictionary which presents a lexicon, which can be infinite. Correction rules can be trie-based in the form of a dictionary of correction rules  which may be merged with the master trie  to form a merged trie-based dictionary . Alternatively, the correction rules can have an unspecified format  and a simple lookup interface can be used for the correction rules.","An input expression  is provided to the trie walker procedure  and the trie walker procedure  carries out a traverse of the master trie  and gathers entries which conform to the input expression  with a predefined error tolerance. The input expression  may or may not belong to the lexicon of the master trie . The gathered entries are output as a set of suggestions  from the master trie . Each suggestion  can be a stand-alone word, a compound word, or a multi-word expression.","The finite state framework  provides the functionality needed to operate with trie-based dictionaries. The following application programming interfaces are essential for dictionary operation:\n\n","The following application programming interfaces are essential for approximate matching functionality:\n\n",{"@attributes":{"id":"p-0084","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Get target string;"},{"entry":"Set current node to root node of the trie;"},{"entry":"Set gathered string to empty string;"},{"entry":"Set current position within the target string to zero;"},{"entry":"Set restriction count to zero;"},{"entry":"Set error value to zero;"},{"entry":"WALKER (target, current node, current position, gathered string, restriction count, error"},{"entry":"value)"},{"entry":"{"},{"entry":"\u2003\u2003\u2003FOR (every child node of current node)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/modifications of prior technique start here"},{"entry":"\u2003\u2003\u2003IF (node is a word fragment gloss)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003THEN","IF(gathered string shorter than target string)"]},{"entry":[{},"THEN WALKER( target, root node, current position, gathered"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2009string, restriction count, error value);"]},{"entry":[{},"ELSE PRINT gathered suggestion;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003\u2003IF (node is a standalone word gloss)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003THEN","IF(gathered string shorter than target string)"]},{"entry":[{},"THEN WALKER( target, root node, current position, gathered"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2009string+word break, restriction count, error value);"]},{"entry":[{},"ELSE PRINT gathered suggestion;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003IF(restriction count equals to zero) \/\/i.e. rules are not forbidden"},{"entry":"\u2003\u2003\u2003THEN"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003do lookup in order to match all substrings for target string from current"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003position against dictionary of correction rules;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003FOR(all matched substrings)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003create new target as a copy of target;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003substitute the matched sequence within the new target by its"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003correction pair;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003WALKER( new target, current node, current position, gathered"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003string, length of pasted correction, error value+1);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003decrement restriction count if restriction count is not zero;"},{"entry":"\u2003\u2003\u2003\/\/prior technique follows"},{"entry":"\u2003\u2003\u2003IF (latest transition character does not match character of target at the current"},{"entry":"position)"},{"entry":"\u2003\u2003\u2003THEN fix error within gathered string according to trie;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003WALKER( target, next node, current position+1, fixed gathered string,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2009restriction count, error value+1);"},{"entry":"\u2003\u2003\u2003ELSE append character to so-far gathering string;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003WALKER( target, next node, current position+1, gathered string,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002\u2009restriction count, error value);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0085","num":"0099"},"figref":"FIGS. 4A and 4B"},"Referring to , a part of the English dictionary trie map  shows the trie node visited by the trie walker in an attempt to gather suggestions for a misspelt target string \u201cvve'll\u201d. The shown dictionary contains word fragments along with standalone words. Words and word fragments are stored along the path from the root node  to gloss nodes.","In practice, gloss nodes contain references to data blocks associated with the word or word fragment. The data blocks can contain position codes for the word fragment such as: stand-alone word; beginning of word, middle of word, or end of word code; part of speech; and other data. The information contained in the data blocks conforms to the context in which the dictionary is used. In respect to approximate matching, such information is not essential, but can be used to improve the quality of gathered suggestions. For example, position codes and part of speech information is used to fix overproduction while forming compound words from word fragments observing that certain fragments can not be placed at a certain position within a word according to their position codes. The inclusion of such information is optional and therefore the gathering process is illustrated assuming that the only information in gloss nodes is a flag indicating whether a word is a stand-alone word or a word fragment.","Correction rules are stored in the same dictionary shown in , which is space efficient due to trie prefix contraction.","For the given example we will calculate the error value as edit distance. The error tolerance is set to 1 for this particular target word; this means that only one error is allowed. The likelihood of having more than one mistake by a typist or optical character recognition routine is low in this example due to the short length of the target word.","Following the method, the trie walker walks by recursively moving to every child of its current node or continuing with the current node, starting from the root node, and conditionally accepting transition characters into a gathered string. Along with this, the trie walker moves character-wise within the target string. If the current character in the target string is equal to the latest transition character on the current trie path, the trie walker appends the character to the gathered string. If the current character in the target string is not equal to the latest character on the current path, the trie walker fixes the error by performing certain edit operations over the gathered string and increments the error value (edit distance) for the current path. The edit operations are: accepting a non-matching character from the trie and not moving to the child node which means insertion of a missed character; accepting of non-matching character from the trie and continuing of traverse from the following node means substitution of a character; not accepting a non-matching character and not moving to the child node means deletion of a mistakenly pasted character; and two consecutive symmetric substitutions are considered as one transposition. The trie walker proceeds with all the options above, always moving one character forward in the target string, extending it with imaginary non-matching characters if necessary. The options that exceed error tolerance are rejected.","Referring to , the first level  of the trie map contains all letters of the English alphabet plus apostrophe. The paths at the first level  are dropped by the walker except for characters \u201cv\u201d , \u201cw\u201d  and \u201c'\u201d  as shown in . That means that the trie walker made an attempt to fix the error for the first character by substitution, insertion and deletion. After that the walker continues walking along those paths but all the following characters do not match either, therefore the edit distance would be beyond the predefined tolerance of 1.","Along with conditional acceptance of characters from the trie, the trie walker performs lookup in order to match all valid prefixes of the remainder of the target string in the dictionary of correction rules. In this embodiment this is provided in the same dictionary.","At the root node , the remainder of the target string is equal to the whole target string. There is one matching prefix \u201cvv\u201d in the dictionary, its gloss  contains the substitution for the sequence \u201cvv\u201d, which might be an incorrect optical recognition of the letter \u201cw\u201d. The trie walker performs substitution of the sequence \u201cvv\u201d with the letter \u201cw\u201d incrementing the edit distance for the new string. From this point, the trie walker continues traversing for two target strings: original \u201cvve'll\u201d  and aligned by correction rule string \u201cwe'll\u201d , the latter is disabled for correction lookups that include the letter \u201cw\u201d (i.e. until the remainder is \u201ce'll\u201d).","The dictionary does not contain the word \u201cwe'll\u201d, but does contain the pronoun \u201cwe\u201d, which is marked at gloss  as both a stand-alone word and a word fragment. Accordingly, \u201c'll\u201d string is stored and marked as a word fragment at gloss . Thus, the dictionary allows matching of compound words such as \u201cwe'll\u201d or \u201cwe'd\u201d or \u201cwe're\u201d and so on.","Referring to , as the trie walker meets a word fragment at gloss  and target string  is longer than the gathered string (\u201cwe\u201d), the trie walker is looped back  to the root node . It continues traversing \u201cll\u201d: as the edit distance equals 1 after applying the correction rule, the rest of the paths are ignored. The ultimate gathered string is the compound word \u201cwe'll\u201d , which is the result of application of correction rules and looping of the trie walker. It also fits into the error tolerance limit.","In the case of the absence of the \u201cvv\u201d to \u201cw\u201d correction rule, the edit distance required to match the desirable \u201cwe'll\u201d would be equal to 2\u2014one deletion and one substitution (or vice versa) would have to be made, which is beyond the error tolerance and therefore no suggestions would be gathered. In the case where the error tolerance is set to a bigger value, though, there will be more unlikely suggestions presented, i.e. the set of gathered suggestions will have worse quality compared to one with lesser tolerance.","Referring to , a further example of an approximate string matching traverse is shown. A fragment (or small stand-alone) trie-based dictionary  is shown and presents a practical example of the looping back technique with more manifold positional codes (not just a flag indicating whether a word is a stand-alone word or just a word fragment).","The shown dictionary  contains three entries: \u201cdo\u201d , \u201cdid\u201d , \u201cn't\u201d . A position code table relating to this dictionary  is shown below:",{"@attributes":{"id":"p-0099","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Position within a word","Active bit"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Stand-alone word","x000"]},{"entry":[{},"Beginning of word","0x00"]},{"entry":[{},"Middle of word","00x0"]},{"entry":[{},"End of word","000x"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"According to this table, entries \u201cdo\u201d and \u201cdid\u201d in the dictionary  have position codes \u201c1100\u201d which indicates that they can exist as stand-alone words and also as beginnings of words. Entry \u201cn't\u201d has a position code \u201c0001\u201d which indicates that it presents an ending word fragment.","For the given example, the error value is calculated as edit distance. The error tolerance is set to 1 for target word \u201cddn't\u201d .","After the first letter \u2018d\u2019 is successfully matched  (shown by the thick arrow), no continuation is available in the trie for the word \u201cddn't\u201d. Two modified strings are created, one by replacing the second letter \u2018d\u2019 with an \u2018o\u2019 , and the other one by inserting an \u2018i\u2019 , both carrying error value of 1. The traverse continues for both variants until they reach terminal states for \u201cdo\u201d  and \u201cdid\u201d  respectively. Full match is not achieved there, though, and the traverse loops ,  and continues from the beginning, according to the position codes.","Both variants successfully match the letters \u2018n\u2019 , \u2018'\u2019  and \u201ct\u201d  to form the ending part \u201cn't'\u201d . The two variants \u201cdon't\u201d , \u201cdidn't\u201d  are accepted in the final state as the position code allows it. The two suggestions of \u201cdon't\u201d and \u201cdidn't\u201d are also accepted by error value.","The described method preserves such advantages of approximate matching in trie-based dictionary as sub-linear computational complexity, combination of exact and approximate matches, dictionary compactness and independency of the method of error value computation. The described method concordantly reduces the approximate matching to appropriate context, allows it to operate against a dictionary of word fragments, and in addition permits the splitting of non-delimited words. The method performs the matching in one non-deterministic traverse pass of the dictionary trie. The method achieves the quality of suggestions provided by superposition of several different methods in a single fast technique. Extra tasks are solved which are common for practical applications with one traverse of the trie dictionary, allowing exact and approximate matches to be combined.","The described method also has the following advantages. The preserved sub-linear complexity permits usage of this method on the server side. Also, the preserved ability to combine exact dictionary lookup and approximate matching procedure is beneficial. For example, search engine can perform approximate index lookup using single procedure, avoiding exact index lookup. There are highly flexible languages like Finnish, Hungarian, Turkish, etc. for which a dictionary of words cannot currently be built. The proposed method can be used for these languages using a dictionary of fragments. The ability to operate against non-delimited sequences can be used to perform segmentation in parallel with error fixing.","The method remains independent of the technique of error value computation. This makes it possible for the method to be used in areas separate from text analysis. For example, if a number of common sequences is used as criteria for rejects, the method can be applied for approximate DNA matching, etc.","The present invention is typically implemented as a computer program product, comprising a set of program instructions for controlling a computer or similar device. These instructions can be supplied preloaded into a system or recorded on a storage medium such as a CD-ROM, or made available for downloading over a network such as the Internet or a mobile telephone network.","Improvements and modifications can be made to the foregoing without departing from the scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In order to facilitate a fuller understanding of the present invention, reference is now made to the appended drawings. These drawings should not be construed as limiting the present invention, but are intended to be exemplary only.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
