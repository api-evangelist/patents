---
title: Memory mapping for single and multi-processing implementations of code generated from a block diagram model
abstract: Methods and systems are provided for automatically generating code from a graphical model representing a design to be implemented on components of a target computational hardware device. During the automatic code generating process, a memory mapping is automatically determined and generated to provide an optimization of execution of the program on the target device. The optimized memory mapping is incorporated into building the program executable from the automatically generated code of the graphical model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07584465&OS=07584465&RS=07584465
owner: The MathWorks, Inc.
number: 07584465
owner_city: Natick
owner_country: US
publication_date: 20041220
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND INFORMATION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This present application claims priority to U.S. Provisional Patent Application No. 60\/611,618, entitled \u201cMemory Mapping For Single And Multi-Processing Implementations Of Code Generated From A Block Diagram Model\u201d, filed Sep. 20, 2004, which is incorporated herein by reference.","The present invention generally relates to technical computing, and, more particularly, to the memory mapping of a program automatically generated from a block diagram model.","Typically, computational hardware devices, such as general purpose processors, microcontrollers, and DSPs, will include one or more types of memory with varying memory access rates. For example, an embedded system may have digital signal processors (DSPs), where each processor may contain on-chip RAM and\/or ROM memory. Furthermore, each DSP may also access external memory and the multiple DSPs may share the same external memory. On-chip memory is typically faster but smaller in size than the external memory. The size of the code and data segments of a program may be larger than the available on-chip memory of the processor that will run the program. For example, an embedded real-time program designed for the DSP may be too large to fit in the on-chip memory. As such, sections of the code and data segments of the program must be stored to external memory, and the processing unit of the DSP will read and write code and data segments from the external memory as needed. As part of deploying a program to a target processor, the code and data segments are mapped to the internal and external memory available to the processor. Since there are various types of memory with different access rates, the resulting memory mapping scheme deployed for the program can significantly impact the execution performance of the program.","To determine how to map the data and code segments of the program to the available memory resources, a detailed understanding of the algorithm implemented by the program as well as the underlying architecture of the processor is required. As such, determining a memory mapping for a program implementing a certain algorithm for a particular type of processor with various memory access rates is a challenging and difficult task. Furthermore, this can be even more daunting for systems with multiple different processors sharing memory resources. Typically, a memory mapping for a particular program to run on a certain processor and memory profile is performed manually through trial and error. This approach delivers little assurance of providing an intelligent memory mapping in a systematic way that will improve or optimize execution of the program on the processor.","In graphical modeling environments, such as a model-based design tool, block diagram models can be created to represent the design, or algorithm, of an implementation for a computational hardware device. One or more block diagram models may represent a design targeted for a single or multiple processor devices with one or more memory elements. An automatic code generation application can automatically generate code and build programs from the block diagram model to implement code for the device based on the design. In this manner, the design of a block diagram model behaves as an implementation specification for automatic code generation. However, during the code generation process, a static, default memory mapping may be specified for compiling and linking the generated code. This default memory mapping is not optimized for the execution of the program on the target device. As such, the automatic code generation application does not incorporate optimization of the memory mapping into the code generation process. The automatically generated memory mapping is optimized as a function of the given block diagram model for the specified embedded hardware platform.","It is desired to provide an intelligent and systematic approach to determining and generating a memory mapping of code and data segments of a program that improves performance of the program generated from a graphical model, such as a block diagram model. The present invention provides systems and methods for automatically generating code for a software implementation of a graphical model and to automatically generate an optimized memory mapping to build a program from the generated code. The automatically generated memory mapping is optimized as a function of the given graphical model for a specific computational hardware device. A graphical model may represent a design to implement software in a computational hardware device with one or more processors and one or more memory elements, either on the processors and\/or external to the processors. The automatic code generation translates the graphical model into source code comprising the functionality represented by the graphical model. During generation of the source code and the building of object code, the code and data segments of the program are placed in uniquely named memory sections to provide an implementation structure to incorporate a modified memory mapping into the build process of the program.","From a profile of the code and data segments of the program and a profile of the memory elements of the target device, a memory mapping is automatically generated to provide an optimization of execution of the program on the target device. The memory mapping includes a description of the placement of the uniquely named memory sections to portions of the one or more memory elements of the target device. Optimization of memory mappings can employ various optimization techniques to provide improved execution of the program on the target hardware in comparison to any provided default memory mapping, such as a memory mapping provided by a manual trial-and-error process. The optimized memory mapping is provided to the automatic code generation process to incorporate into the building of the program executable. As such, the program when loaded and executed on the target device will execute according to the memory mapping optimizations.","Additionally, the systems and methods of automatically generating a memory mapping and source code from a graphical model can take into consideration multiple processor devices with multiple memory elements and memory elements shared between processors. The automatic code generation and optimization techniques of the present invention for memory mapping may take into consideration any data transfers between different processors, the broadcasting of data to multiple processors, any synchronization of processing across processors and any other impact the hardware topology and graphical model design may have on the optimization of the memory mapping for programs running on each of the processors. In summary, the present invention automatically determines an optimization of a memory mapping for one or more programs that are being automatically generated from one or more graphical models. The programs are built into executables incorporating the optimized memory mappings in order to execute according to the optimizations.","In one aspect, the present invention relates to a method for determining a memory mapping of a program to execute on a computational hardware device having one or more processors. The program may be generated from a graphical model, such as a block diagram model. The method includes the step of receiving program information comprising a description of one or more program segments. Each program segment includes a code and\/or a data segment of the program. The method also receives memory information comprising a description of one or more memory elements of the computational hardware device. The method then compares the program information to the memory information to determine a memory mapping that provides for executing the program in a desired manner, e.g., an optimization, on the computational hardware device. The memory mapping includes a description of placement of the program segments to portions of the memory elements. The method further provides that the memory mapping is determined automatically by a memory mapping generator and provided to build an executable of the program incorporating the memory mapping.","In one aspect of the present invention, the program information includes a description of one or more of the following: 1) a size of one of the code segments and the data segments, 2) a frequency of access by the program to one of the code segments and the data segments, and 3) a priority assigned to one of the code segments and the data segments. In another aspect, the memory information includes a description of one or more of the following: 1) a size of the memory element, 2) an access rate of the memory element, and 3) a configuration of the memory element. In a further aspect, the memory mapping is determined by applying a heuristic, an exhaustive, or a genetic type of optimization algorithm.","In another aspect of the present invention, the method determines the memory mapping by determining from the program information a first program segment having a first priority, and determining from the memory information a first memory portion of the one or more memory elements having a first desired characteristic. Then the method assigns the first program segment to the first memory portion. The method also determines from the program information a second program segment having a second priority, and determines from the memory information a second memory portion of the one or more memory elements. The second memory portion may include a portion of a memory element having the first desired characteristic if the second program segment fits into the second memory portion. Otherwise, the second memory portion may include a portion of a memory element have a second desired characteristic. The second program segment is then assigned to the second memory portion. The priority of program segments for assigning is determined from the size of any of the code and data segments of the program segment. The priority can also be determined from the frequency of access by the program to the program segment.","In an additional aspect of the present invention, the method determines the memory mapping by determining a first memory mapping from a plurality of memory mappings for executing the program on the computational hardware. The method determines a first time profile from executing on a program simulator the program incorporating the first memory mapping. Then the method determines if the first time profile associated with the first memory mapping provides a desired time profile. In a further aspect, the method obtains a second memory mapping from the plurality of memory mappings for executing the program on the computational hardware device, and determines a second time profile from executing on the program simulator the program incorporating the second memory mapping. The method then compares the first time profile to the second time profile to determine the memory mapping that provides the desired time profile.","In another aspect, the present invention relates to a device readable medium having device readable instructions to execute the steps of the method, as described above, related to determining a memory mapping of a program to execute on a computational hardware device. In a further aspect, the present invention also relates to computer data signals transmitted over a transmission medium that represent device readable instructions to execute the steps of the method, as described above, related to determining a memory mapping of a program to execute on a computational hardware device.","In another aspect, the present invention relates to a method for generating code to incorporate a memory mapping into an executable of a program to run on a computational hardware device. The method includes the step of initiating an automatic generation of code for a graphical model to provide a program to run on a computational hardware device having one or more processors. The method also includes the step of assigning one of a code segment and a data segment of the generated code to a named memory section to be associated with a memory element of the computational hardware device. The code and data segment represents at least a portion of functionality of the graphical model, such as a block of a block diagram model. The method obtains a memory mapping providing an optimization of execution of the program on the computational hardware device. The memory mapping describes a placement of one of the code segment and the data segment to a portion of a memory element of the computational hardware device. The method then provides a linker command file to associate in building an executable of the program the named memory section with the portion of the memory element as determined by the memory mapping. In one aspect, the method further includes building an executable of the program from the code with the linker file to incorporate the memory mapping. In another aspect, the method, during the automatic generation of code, assigns one of the code segment and the data segment to the named memory section by a compiler or linker directive.","In another aspect, the present invention relates to a device readable medium having device readable instructions to execute the steps of the method, as described above, related to generating code to incorporate a memory mapping into an executable of a program to run on a computational hardware device. In a further aspect, the present invention also relates to computer data signals transmitted over a transmission medium that represent device readable instructions to execute the steps of the method, as described above, related to generating code to incorporate a memory mapping into an executable of a program to run on a computational hardware device.","In one aspect, the present invention relates to a method for automatically generating code from a graphical model and determining a memory mapping to implement a program in a computational hardware device having one or more processors. The method initiates an automatic generation of code from a graphical model to generate a program to execute on the computational hardware device. The automatic generation of code provides compiler directives to place code and data segments into a named memory section. The code and data segments represent at least a portion of functionality of the graphical model. The method obtains program information that includes a description of the code and data segments of the program, and also obtains memory information that includes a description of the memory elements of the computational hardware device. The method then generates a memory mapping to provide an optimization of execution of the program on the computational hardware device, or to otherwise have the program executed in a desired manner. The memory mapping is automatically generated from a comparison between the program information and the memory information to determine a placement of one or more code and data segments of the program to portions of the one or more memory elements of the computational hardware device. The method also generates a linker command file to associate the named memory section with the portion of the memory element as determined by the memory mapping.","In an additional aspect of the present invention, automatically generating the memory mapping includes the steps of determining from the program information a first program segment having a first priority, and determining from the memory information a first memory portion of the one or more memory elements having a first desired characteristic, and assigning the first program segment to the first memory portion. The method then determines from the program information a second program segment having a second priority, and determines from the memory information a second memory portion of the one or more memory elements having either the first desired characteristic or a second desired characteristics, and assigns the second program segment to the second memory portion. The method provides as the memory mapping for the automatic code generation a memory mapping identifying the assignment of the first program segment and the second program segment. In a further aspect, the priorities of the first and second program segments are determined from a size of the program segment and an access frequency by the program to the program segment.","In a further aspect of the present invention, automatically generating the memory mapping includes the steps of determining a first memory mapping and a second memory mapping from a plurality of memory mappings for executing the program on the computational hardware. The method then simulates on a program simulator execution of the program incorporating the first memory mapping to determine a first time profile, and simulates on the program simulator execution of the program incorporating the second memory mapping to determine a second time profile. The method provides as the memory mapping one of the first memory mapping and the second memory mapping having a desired time profile.","In a further aspect, the present invention relates to a device readable medium including device readable instructions to execute the steps of the method, as described above, related to automatically generating code and determining a memory mapping for the execution of a program on a computational hardware device. In a further aspect, the present invention relates to computer data signals transmitted over a transmission medium that represent device readable instructions to execute the steps of the method, as described above, related to automatically generating code and determining a memory mapping for the execution of a program on a computational hardware device.","In one aspect, the present invention is related to a system to generate a program from a graphical model, such as a block diagram model, and to determine a memory mapping for the execution of the program on a computational hardware device. The system includes an automatic code generator and a memory mapping generator. The automatic code generator generates code from a graphical model to build a program to execute on a computational hardware device having one or more processors. The automatic code generator also provides a compiler directive to associate one of a code segment and a data segment with a named memory section to be associated with a memory element of the computational hardware device. The code and data segment represent at least a portion of functionality of the graphical model. The memory mapping generator obtains program information descriptive of the code and data segment, and obtains memory information descriptive of the one or more memory elements of the computational hardware device to automatically generate a memory mapping that provides an optimization of execution of the program on the computational hardware device. The memory mapping generator automatically generates the memory mapping from a comparison between the program information and the memory information to determine a placement of one or more code and data segments of the program to portions of the one or more memory elements of the computational hardware device.","In one aspect, the automatic code generator and the memory mapping generator may execute on one of a client and a server. Furthermore, the program information, the memory information, the code, and the memory mapping may reside on one of the client and the server. In a further aspect, the automatic code generator generates a linker file to incorporate the memory mapping provided by the memory mapping generator into the building of the program. The automatic code generator in communication with the memory mapping generator may automatically obtain the memory mapping from the memory mapping generator.","In an additional aspect, the memory mapping generator automatically generates the memory mapping by determining from the program information a first program segment having a first priority, and determining from the memory information a first memory portion of the one or more memory elements having a first desired characteristic, and assigning the first program segment to the first memory portion. The memory mapping generator then determines from the program information a second program segment having a second priority, and determines from the memory information a second memory portion of the one or more memory elements having either the first or a second desired characteristic, and assigns the second program segment to the second memory portion. The system then provides as the memory mapping a memory mapping that includes the memory assignments of the first program segment and the second program segment.","In yet another aspect, the memory mapping generator automatically generates the memory mapping by determining a first memory mapping and a second memory mapping from a plurality of memory mappings for executing the program on the computational hardware. The memory mapping generator simulates on a program simulator execution of the program incorporating the first memory mapping to determine a first time profile, and simulates on the program simulator execution of the program incorporating the second memory mapping to determine a second time profile. The memory mapping generator then provides as the memory mapping one of the first memory mapping and the second memory mapping having a desired time profile.","The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.","Certain embodiments of the present invention are described below. It is, however, expressly noted that the present invention is not limited to these embodiments, but rather the intention is that additions and modifications to what is expressly described herein also are included within the scope of the invention. Moreover, it is to be understood that the features of the various embodiments described herein are not mutually exclusive and can exist in various combinations and permutations, even if such combinations or permutations are not expressly made herein, without departing from the spirit and scope of the invention.","The illustrative embodiment of the present invention provides systems and methods for automatically and systematically generating a memory mapping for a program to be implemented in a computational hardware device with one or more processors and one or more memory elements. The memory mapping determines the placement of code and data segments of a program to selected sections of memory of the memory elements. Optimization techniques are applied during the memory mapping generation process to determine a memory mapping that optimizes execution of the program on the one or more processors. The resulting memory mapping is applied to an automatic code generating process to form an executable for the program that incorporates the memory mapping.","Furthermore, the illustrative embodiment provides for automatically generating code from a block diagram model in a manner by which a generated memory mapping can be implemented into the process of building a program executable. The automatic code generation process generates code for each block of a block diagram model to place each code and data segment of the code into a uniquely named memory section. From a provided memory mapping, such as an optimized memory mapping, the automatic code generation process creates a linker-command file to use during the compiling and linking of a program to form an executable. The linker-command file defines the memory mapping to direct the code and data segments of the uniquely named memory section for each block to be placed in the portions of memory as determined by the memory mapping.","Additionally, the illustrative embodiment of the present invention also provides for a user to flexibly configure memory mappings via a configuration mechanism such as a graphical user interface. A user can create and configure memory mappings to have code and data segments of the program generated from the block diagram model mapped to portions of memory elements also configurable by the user. Furthermore, the configurability of the present invention allows a user to select, edit and modify memory mappings generated automatically by the memory mapping generator to configure the program to run in a desired manner.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","b":["102","106","104","106","106","106","102","114","102","110","112","110","112","114","102","102","116","102","108","120","116","108","120"]},"Additionally, the computing device  may include a network interface  to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., 802.11, T1, T3, 56 kb, X.25), broadband connections (e.g. ISDN, Frame Relay, ATM), cluster interconnections (Myrinet), peripheral component interconnections (PCI, PCI-X), wireless connections, or some combination of any or all of the above. The network interface  may comprise a built-in network adapter, network interface card, PCMCIA network card, card bus network adapter, wireless network adapter, USB network adapter, modem or any other device suitable for interfacing the computing device  to any type of network capable of communication and performing the operations described herein. Moreover, the computing device  may be any computer system such as a workstation, desktop computer, server, laptop, handheld computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.","The computing device  may run any type of operating system such as Microsoft\u00ae Windows, a version of UNIX, a version of Linux, a real time operating system or any other type of operating system capable of operating on the computing device . The technical computing environment  may be capable of and configured to operate on any of the operating systems that may be running on and controlling the computing device . Furthermore, the technical computing environment  may be capable of and configured to operate on and take advantage of different processors  of a computing device . For example, the technical computing environment  may run on a 32 bit processor of one computing device  and a 64 bit processor of another computing device \u2032. One ordinarily skilled in the art will recognize the various combinations of operating systems and processors that may be running on any of the computing devices . In summary, the technical computing environment  and other components of the present invention may be deployed across a wide range of different computing devices, different operating systems and different processors.","In a brief introduction, the technical computing environment  of the present invention provides a graphical modeling environment, such as the graphical modeling environment of Simulink\u00ae from the MathWorks, Inc. of Natick, Mass., for creating, designing, simulating, testing and verifying block diagram models and for automatically generating code from block diagram models. In the graphical modeling environment, customizable functional blocks are used to create block diagram models that may represent a design, or algorithm, for a control system, a signal processing system, a communication system, any other time-varying or dynamic system or any computational hardware device. For example, the block diagram model may represent a design to be implemented on a multiple processor embedded control system with one or more memory elements such as shared memory. The technical computing environment also 120 comprises an automatic code generation application, such as the automatic code generator of Real-Time Workshop\u00ae from the MathWorks, Inc. of Natick, Mass., to generate source code from a block diagram model to translate the functionality of the blocks of the block diagram model into a program that may be designed to run on any microprocessor, real-time operating system, or otherwise customized to run on a specific target hardware platform. For example, a block diagram model representing a system design for a multiple processor embedded control system can be translated into source code to build a program executable to run on the specific type of processor of the target device.","The target device may comprise any type of computational hardware device that may be modeled by the graphical modeling environment, such as the graphical modeling environment provided by Simulink\u00ae. A computational hardware device may comprise one or more components integrated together to perform the intended purpose of the hardware design, and may also comprise other computational hardware devices, which in turn may comprise one or more components. A component of a computational hardware device may comprise any type of integrated circuit or chip, such as a processor, field programmable gate array (FPGA), programmable logic device (PLD), or application-specific integrated circuit (ASIC). A processor may be a digital signal processor (DSP), general purpose processor (GPP) or a microcontroller. Furthermore, the component may be a digital, analog or mixed-signal component. Moreover, the computational hardware device may comprise any combination of like and\/or different processors, FPGAs and ASICs to form a heterogeneous environment of components. For example, the computational hardware device may comprise multiple processors with one processor being a GPP and the other a DSP. Additionally, the computational hardware device may include a physical communication interface between components such as a programmable I\/O, Direct Memory Access (DMA), FIFO queued buffer, etc. One ordinarily skilled in the art will appreciate the various types of components that can be designed and integrated into a computational hardware device.","In one aspect, the present invention relates to automatically generating an optimized memory mapping for code generated for a specific hardware target by applying program specific and target specific information to the memory mapping optimization.  depicts an illustration of the components of an embodiment for practicing this aspect of the present invention. In brief overview, a system  comprises a technical computing environment  including an automatic code generator , such as Real-Time Workshop\u00ae, and a memory mapping generator . The automatic code generator  obtains a block diagram model  and any input files  to translate the blocks of the block diagram model  and generate source code representing the functionality configured in the blocks of the block diagram model . The automatic code generator  compiles the source code  into object code  and via the linker files can build a program executable . The memory mapping generator  obtains program information  describing attributes of the code and data segments of the program . The memory mapping generator also obtains memory information  describing attributes of the memory structure of a target specific hardware to which the model block diagram model  was designed to be implemented on. The memory mapping generator  can be configured with one or more optimization rules  for comparing the program information  to the memory information  to generate a memory mapping  according to the configured logic of the optimization rules . Additionally, the memory mapping generator  may interface with a program simulator  to simulate a performance of the program  or instructions of the program  based on a generated memory mapping .","As input to the automatic code generator , the block diagram model  may represent a design, or algorithm, to be implemented on a single or multiple processor computational hardware device with one or more memory elements internal and\/or external to the processors. The block diagram model  may comprise multiple block diagram models, each representing one or more components of a computational hardware device, such as one or more processors. In another embodiment, the block diagram model  may comprise a partitioned block diagram model  with each partition representing a component of a multi-component computational hardware device. The block diagram model  may comprise one or more files accessible by the technical computing environment  and in a format readable and understandable by the automatic code generator . In other embodiments, the block diagram model  may be obtained from a block diagram modeling environment, or another technical computing environment. In other embodiments, the automatic code generator  may obtain the block diagram model  from an application programming interface (API) call to another application, or via an interface to another system.","The one or more input files  to the automatic code generator  may include templates, commands, input parameters, configuration data, source code, data and class definitions, or any other information that may be used by the automatic code generator  to generate source code for the block diagram model . The input files  may include files to provide input to and configure the automatic code generator  to generate source code files  for a specific target hardware platform, for example, a specific processor. In an exemplary embodiment of Real-Time Workshop\u00ae as the automatic code generator , Real-Time Workshop\u00ae uses target language compiler script files, with a .tlc file extension, as input files  to the code generation process. The .tlc files provide sections of programming instructions to be implemented for block references as they may be found in a block diagram model  during the code generation process. The .tlc files also can provide data and class definitions for data element references found in the block diagram model . Additionally, the .tlc files also comprise compiler directives, built-in functions and other code generation commands to direct Real-Time Workshop\u00ae during the code generation process.","In operation, the automatic code generator  reads in the block diagram model  and the input files  to generate source code by translating the block diagram model  into one or more source code files . By way of example, the automatic code generation can be discussed in terms of generating code with Real-Time Workshop\u00ae from a block model diagram  generated with Simulink\u00ae. Simulink\u00ae creates and stores block diagram models into model files with a .mdl file extension. As part of the code generation process, Real-Time Workshop\u00ae reads in a .mdl model file and analyzes the model to generate an intermediate model file with an .rtw extension. This intermediate .rtw model file comprises a hierarchical structure of records describing systems and their blocks and connections analyzed from a block diagram model  of the .mdl file.","A language compiler called the target language compiler of Real-Time Workshop\u00ae works with .tlc files and .rtw files to produce code. The target language compiler interprets a program that reads the intermediate model file description of a .rtw file. As the target language compiler encounter a record in the .rtw file, it uses directives in the .tlc files corresponding to the record to direct the code generation process for the specific record. As such, the target language compiler works much like a text processor. For example, the target language compiler uses block .tlc files, which specify the particular code for a block, to transform each block into code. When it reads a record in the .rtw file that references a block, the target language compiler applies code from the corresponding block .tlc file to generate code for the block in source code files . Additionally, model wide .tlc files are also used to provide input to the target language compiler for global customization of the code. Model wide .tlc files may direct the target language compiler to generate main routines to provide entry points into the program, source code header files to setup data structures, and utility functions to support code for particular blocks. The block and model wide .tlc files can be modified to generate customized code for blocks and to generate any desired global customizations to the code.","The source code files  generated from the automatic code generator , such as Real-Time Workshop\u00ae, may comprise program instructions of a programming language, such as C, which may further be in a format and style following the ANSI\/ISO C standard. Additionally, the source code files  may be generated to comprise fixed-point or floating-point source code. The program instructions of the source code files  may be generated to run on any operating system, such as a real-time operation system, or for a specific processor. Furthermore, the programming instructions of the source code files  may be optimized for performance or versatility, and\/or for a specific target hardware platform. Furthermore, the automatic code generator  can be configured via the input files  to generate custom source code comprising a style and format as directed by the input files . The automatic code generator  can be also configured via the input files  to provide customized source code to support such customizations as error handling, optimization, code and data reduction, code reusability, scoping of variables, and other characteristics of the source code that may be modified during the source code generation process.","During the generation of source code, the automatic code generator  will generate source code for each block of the block diagram model  and place the code and data segments of the block's source code into a uniquely named memory section. In an exemplary embodiment, the automatic code generator  associates the code and data segments of a block's source code to a named memory section by using a compiler and\/or linker preprocessing directive of the programming language. For example, a #pragma statement in the C programming language is used to specify compiler directives, and can be used to define precise control over the memory area where data is placed. A #pragma <section-name> statement in C creates a defined named section within the object file created by compilation. The <section-name> provided should not conflict with any standard section names already used by the compiler. The compiler may generate code and data sections mapped to default memory sections, such as the .bss memory section, which is the default segment in the object code  for uninitialized data in a C\/C++ implementation. Another default memory section is the .data segment for holding initialized variables. With the #pragma <section name> statement, a uniquely named memory section can be defined using a name other than a standard section name to create a memory section with the name of <section name> in the compiled object code . For example, a section of code and data from a block from the block diagram model  may be placed into a named memory section of .sec1. A pragma directive of \u201c#pragma .sec1\u201d creates a named memory section of .sec1 to be used during compilation. Through pragma directives code and data segments generated from a block from a block diagram model  can be placed into, or otherwise associated, with the named memory section of .sec1. In this manner, the object code  comprises code and data segments associated with a named memory section to be mapped along with the standard named memory sections according to the memory mapping techniques of the present invention. One ordinarily skilled in the art will appreciate the use of compiler and\/or linker directives, such as the #pragma in C, to provide for named memory sections, and that such directives will depend on and may be different for various programming languages and architectures.","Although it is generally discussed above that the automatic code generator  places code and data segments generated for a block of the block diagram model  into a named memory section, the automatic code generator  may place code and data segments representing multiple blocks into the same named memory section. Furthermore, the block diagram model  may place code and data segments representing one or more signals of the block diagram model  into a named memory section. Signals in block diagram models , such as block diagram models  provided by Simulink\u00ae, are known by one ordinarily skilled in the art, and provide a time varying quantity that may be configured with a wide range of attributes. Moreover, the automatic code generator  may place code and data segments representing any portion of the block diagram model  of any granularity into a named memory section.","The automatic code generator  also provides for the building of the generated source code files  into object code  and a program executable . The automatic code generator  may generate a linker command file  using an initial or default memory mapping , or the automatic code generator  may allow a linking utility to generate the program executable  with a default memory mapping provided by the linking utility. This default memory mapping will not be optimized for the program  to run on a target device. The build process may include compiling the source code  and linking libraries, drivers and other programs via a make program or some other compiling utility to create object code files . The program executable  is built via a linker utility applying the linking command files  in processing the object code files . With the code and data segments of the source code  for each block placed into a uniquely named memory section, the object code  can be re-linked or linked with different linker files to generate a program executable  using a different memory mapping , \u2032. In one embodiment, the automatic code generator  can obtain a memory mapping  from the memory mapping generator  to produce linker command files  implementing the optimized memory mapping . For example, the automatic code generator  may automatically request a memory mapping  from the memory mapping generator  during the course of automatically generating source code and building an executable. The automatic code generator  then can build the object code , including the named memory sections, into a program  using the linker command files  representing the optimized memory mapping . In another embodiment, the memory mapping generator  may automatically generate linker command files  from a generated memory mapping .","Although generally discussed in terms of building a program , the automatic code generator  may build multiple programs  from one or more block diagram models  in one or multiple executions of the automatic code generator . As such, the automatic code generator  may produce multiple sets of source code files , multiple sets of object code , multiple linker command files  to produce multiple programs . Furthermore, each program  and associated source code , linker  and object files  may represent algorithms of the block diagram model  targeted to be implemented on separate processors of a computational hardware device and additionally may include communication interfaces between the processors such as a communication interface to shared memory used by the processors. Additionally, each communication interface of the programs  may be designed to transfer data between processors, broadcast data to multiple processors or otherwise synchronize processing across processors.","Still referring to , the memory mapping generator  generates one or more optimizations of a memory mapping  for the program  to run on a processor on a computational hardware device with one or more memory elements in the processor, or otherwise external to the processor. The generated memory mapping may be used by the automatic code generator . The memory mapping generator  obtains program specific information  and memory specific information  to apply one or more optimization rules  to generate the memory mapping .","The program information  comprises a description of attributes of the code and data segments of the program. Each code and data segment in the program information  may represent a block of the block diagram model  and may be uniquely identified by a name. The program information  may include the size in kilobytes or other related unit of measurement of each of the code and data segments. It may also include the frequency of access by the program  to the data segments and the frequency of execution by the program  of the code segments. The program information  may also include a computational burden of each section of code of the program . Additionally, the program information  may assign a priority or some other weighted factor to each of the code and data segments in the program information .","The program information  may be automatically generated from the automatic code generator  or extracted from any of the source code files , linker files  or object code  produced by the automatic code generator . The memory mapping generator  may obtain the program information  from other files configured by a user, or another system in accordance with a file specification understood by the memory mapping generator . The memory mapping generator  may read in the linker file's default memory map generated by the automatic code generator  to determine program information . One ordinarily skilled in the art will appreciate the various types of information that may be defined in the program information  to be useful in generating a memory mapping  for a program , and will recognize the various ways the memory map generator  may obtain the program information .","The memory information  comprises a description of the attributes and physical layout of the memory elements of a computational hardware device, including on-chip memory of one or more processors and\/or any external memory elements accessed by one or more processors. Each of these memory elements can be of different types with different access types and rates, configuration, size and other attributes. As such, the memory description  may comprise information describing the type of each memory, the access type and rate of each memory, the size of each memory and any other configuration of the memory that may impact the performance of a program  storing code and data segments on the one or more memory elements. The memory information  may be one or more files generated by a configuration environment of the memory mapping generator  or may otherwise be configured in the memory mapping generator . The memory mapping generator  may obtain the memory information  from an interface or API call to another application holding or having access to memory related information of the computational hardware device targeted for implementation by the block diagram model . For example, the memory mapping generator  may interface with a block diagram modeling environment that produced the block diagram model  to obtain such information. In another example, the memory mapping generator  interfaces with any device related software, such as an electronic design software tool, to obtain information about the memory of a target device. In one embodiment, the memory information  is included with the block diagram model  and automatically generated by the automatic code generator . One ordinarily skilled in the art will appreciate the various types of memory information  relevant to memory mapping and various methods for obtaining such memory information .","The memory mapping generator  may be configured with one or more optimization algorithms from a set of optimization rules . The optimization rules  may be a component, module, library or other software component, or any combination thereof configured with optimization algorithms by which the memory mapping generator  will apply to generate a memory mapping . The memory mapping generator  applies the optimization algorithm to compare the program information  of a program with the memory information  of a computational hardware device to generate an optimal memory mapping  for executing the program  on the device. A memory mapping  is a description of the placement of code and data segments of a program  into sections of memory of the computational hardware device. The purpose of the memory mapping generator  is to generate a memory mapping  that will provide an optimization of the execution of the program on the processor of the device. The optimizations algorithms are applied to the comparison of the program information  to the memory information  to achieve the fastest possible execution of the program , or a portion of the program , on the targeted device, and to determine the memory mapping  in the shortest possible time or with the least amount of resources. As discussed above, the automatic code generator  uses the memory mapping  to build the code into an executable program . As such, the program  is configured with the memory mapping  generated by the memory mapping generator  to execute according to the desired performance created by the optimization rules .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 2B","FIG. 2B"],"b":["205","102","102","205","205","102","240","102","102","102","102","102","102","102","102","205"]},"The network  can be a local area network (LAN), a metropolitan area network (MAN), or a wide area network (WAN) such as the Internet. In one embodiment (not shown), the network  is separated into two or more networks. The networks can be the same type of network or different types of networks. The topology of the network  over which the computing devices , \u2032 communicate may be a bus, star, or ring network topology. The network  and network topology may be of any such network  or network topology capable of supporting the operations of the present invention described herein.","The first computing device  and the second computing device  can be connected to the network  through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., T1, T3, 56 kb, X.25, SNA, DECNET), broadband connections (ISDN, Frame Relay, ATM, Gigabit Ethernet, Ethernet-over-SONET), cluster interconnections (Myrinet), peripheral component interconnections (PCI, PCI-X), and wireless connections, or some combination of any or all of the above. Connections can be established using a variety of communication protocols (e.g., TCP\/IP, IPX, SPX, NetBIOS, Ethernet, ARCNET, Fiber Distributed Data Interface (FDDI), RS232, IEEE 802.11, IEEE 802.11a, IEEE 802.11b, IEEE 802.11g, and direct asynchronous connections). The network connection and communication protocol may be of any such network connection or communication protocol capable of supporting the operations of the present invention described herein.","The network , network connections and\/or protocols may comprise any transmission medium, such as electrical wiring or cabling, fiber optics, electromagnetic radiation or via any other form of transmission medium, between the first computing device  and the second computing device  capable of supporting the operations of the present invention described herein. The methods and systems of the present invention may also be embodied in the form of computer data signals, program code, or any other type of transmission that is transmitted over the transmission medium, or via any other form of transmission, which may be received, loaded into, and executed, or otherwise processed and used by a computing device  to practice the present invention.","In the networked system  of , each of the first computing device , e.g., a client, and the second computing device \u2032, e.g., a server, are configured to and capable of running at least a portion of the present invention. As a distributed application, the present invention may have one or more software components that run on each of the first computing device , and the second computing device \u2032 and work in communication and in collaboration with each other to meet the functionality of the overall application. As by way of example of , the first computing device  may comprise the technical computing environment  including an automatic code generator , such as Real-Time Workshop\u00ae, and the second computing device \u2032 may comprise the memory mapping generator .","As discussed above, the automatic code generator  obtains a block diagram model  and any input files  to translate the blocks of the block diagram model  and generate source code representing the functionality configured in the blocks of the block diagram model . In the networked system , the block diagram model  and any input files  may be obtained from any computing device  on the network , for example, they may be downloaded from a web server on the second computing device \u2032, or over the Internet from another computing device, e.g., a third computing device \u2033. As also previously discussed, the automatic code generator  produces various output files in the form of source code files , object code , linker files  and programs . Any of or all of these output files may each be created on, stored in, or otherwise provided to any computing device  accessible via the network . The automatic code generator  may produce a default memory mapping  either on the computing device  of the technical computing environment  or on any other computing device  accessible via the network . In other cases, the automatic code generator  obtains one or more memory mappings , such as an optimized memory mapping using the techniques described herein, via the network  from the memory mapping generator .","With respect to the memory mapping generator , the program information , the memory information , and the optimization rules  may be obtained from any computing device  accessible via the network , such as from a storage, for example, a file or database system. In one embodiment, the program information  and the memory information  may be obtained via the network  from the technical computing environment  running on the first computing device . The memory mapping generator  may generate one or more memory mappings \u2032 in accordance with the techniques of the present invention. These memory mappings \u2032 may be stored locally or stored remotely on any other computing device  over the network . The memory mapping generator  may be in communication with the automatic code generator  and\/or the technical computing environment  over the network  to either provide or obtain memory mappings , \u2032 using any suitable means. Additionally, the program simulator  in communication with the memory mapping generator  may run on any other computing device  on the network ","In summary, the technical computing environment  and other components of the present invention may be distributed and deployed across one or more different computing devices in various network topologies and configurations. One ordinarily skilled in the art will appreciate the various ways the present invention may be practiced in a distributed manner in a networked system.","In one aspect, the present invention relates to methods of optimization in generating a memory mapping . In one embodiment, the optimization rules  provide a heuristic approach to generating a memory mapping .  depicts an illustrative method of the heuristic approach to optimizing a memory mapping. At step  of the method, the program information  and memory information  is obtained to perform the optimization. The method uses the attributes of the code and data segments of a program  defined in the program information  and the attributes of the memory in the memory information  to generate the appropriate memory mapping . At step  of the method, prioritization rules are determined to apply to the program information  and\/or the memory information . For example, considering the size and access frequency of each code and data segment of a program  placed in a named memory section, a priority of each memory section may be calculated as follows:\n\nPriority=(1\u00d7size)\u00d7(2\u00d7frequency) where w1 and w2 are scalar weighting factors between 0 and 1, providing relative bias to size and frequency parameters\n\nBased on the calculated priority, the data and code segments are mapped to the available memory sections using an ordering scheme.\n","By way of example, a block diagram model  may comprise three (3) blocks: block , block  and block . Block  is connected to and transfers data to block , and block  is connected to and transfers data to block . The automatic code generator  generates uniquely named memory sections for code and data segments in the source code files  and object code  for each of the three blocks. The code sections associated with blocks ,  and  may be uniquely named Code , Code  and Code , respectively. The data sections associated with data buffers between block  and block  may be uniquely named Data , and the data section comprising the data buffering between block  and block  may be named Data . Referring to step  of the illustrative method of , the prioritization rules are applied to the program information  for this program . For example, the prioritization of the program information  may comprise the following:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Section",{},{},{}]},{"entry":[{},"Name","Size (KB)","Frequency (1\/s)","Priority"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Code 1","1","150","150"]},{"entry":[{},"Code 2","1.5","16","24"]},{"entry":[{},"Code 3","5","5","25"]},{"entry":[{},"Data 1","5","25","125"]},{"entry":[{},"Data 2","5","15","75"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["310","260","230"]},{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},{},"Memory access delay (wait"]},{"entry":["Memory","Size (KB)","states)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bank A","2","0"]},{"entry":["Bank B","64","1"]},{"entry":["Bank C","1000","2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Using the heuristic approach of the illustrative method of  to compare the program information  with the memory information , the memory mapping generator  may apply the optimization rules  to compare the assigned priority of code and data sections with the speed and size of available memory. At step , the method determines the code or data segment with the highest priority that has not been mapped yet according to the optimization rules . For the first time executing step , none of the code and data segments have been mapped. In the example, the memory section of Section Code  has the highest priority and has a size of 1 KB. The method at step  determines the memory section available with the fastest access time (or smallest wait state) and that has memory space available for the code or data segment of the selected named section. In this case, memory Bank A is the fastest memory with space available for Section Code . Therefore, Section Code  is mapped to a portion of memory Bank A. Since the size of the code section is 1 KB and Bank A has 2 KB of memory, there is 1 KB of memory space available on Bank A for mapping an additional code or data segment.","In a similar manner, steps  and  are repeated until all the code and data segments of named memory sections are mapped to an available portion of memory. The following is an illustrative description of the repetition of steps  through steps  in reference to the example:\n\n",{"@attributes":{"id":"p-0073","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Memory","Sections","Unused Memory"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bank A","Code 1","\u2003\u20091 KB"]},{"entry":["Bank B","Code 2, Data 1, Code 3","11.5 KB"]},{"entry":["Bank C","Data 2","\u2009925 KB"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The optimization rules  for the heuristic approach could be configured with a more advanced algorithm that would apply a different priority scheme. For example, the optimization rules  may also consider unused memory and put a code or data section with a lower priority into a faster access memory area to reduce the amount of unused memory with higher access rates. In another example, the optimization rules  may call for re-sectioning of code and data segments to better utilize faster memory. One ordinarily skilled in the art will recognize the various prioritization schemes that may be configured in the optimization rules  to apply to this approach. Using the heuristic approach may not always result is the most optimal memory mapping but the resulting optimization of the memory mapping  will suffice for most real-time requirements of applications.","In another embodiment, the optimization rules  provide a deterministic approach to generating a memory mapping . This approach requires a program simulator with memory timing and profiling capabilities. As depicted in , the memory mapping generator  may interface and interact with a program simulator  to obtain simulated execution times for a program  using a memory mapping  implemented with a target processor. The program simulator  may comprise an instruction set simulator designed to simulate and provide execution profiling of the processor targeted to execute the program . Typically, an instruction set simulator performs the fetch-decode-execute cycle for the target CPU's instruction set on the processor, and may include all the target processor's registers and system state to provide a more complete model of the target processor. One ordinarily skilled in the art will recognize the various types of program simulators  that may be deployed to determine program execution times on a target processor or other timing profiles related to a program .","Referring now to , an illustrative method of using a deterministic or exhaustive type approach to optimizing a memory mapping  is depicted. At step  of the method, the program information  and memory information  is obtained to determine one or more combinations of memory mappings  to simulate. At step , the memory mapping generator  can determine all the possible variations of memory mappings  from the program information , or, in another embodiment, may determine a portion of all the possible memory mappings . In another embodiment, the illustrative method may generate multiple versions of a memory mapping determined by the heuristic method discussed in conjunction with .","At step  of the method, the memory mapping generator  can simulate the execution of instructions for the program  on the program simulator  based on any of the memory mapping versions determined at step . Furthermore, the memory mapping generator  can generate and run on the program simulator  all the possible memory mapping  versions that may occur with a set of program information  and memory information . The simulations on the program simulator  will produce profiles of execution times for each of the simulations associated with a version of a memory mapping . Then, at step , the memory mapping generator  can select the memory mapping  that provided the best performance based on the time results from the simulations on the program simulator .","For example, assuming a block diagram model  with synchronous task scheduling, an optimal memory mapping  can be determined by running all memory mapping  versions. Memory information  of a device targeted to implement the design of the block diagram model  may comprise n memory types or n memory elements with different access speeds. The program information  of the program  generated from the block diagram model  may comprise m memory sections of code and data segments. Therefore, the memory mapping generator  can generate up to ndifferent memory mappings . The memory mapping generator  would run each of the ndifferent memory mappings  on the program simulator  and select the memory mapping  with the best execution performance. In another embodiment, the memory mapping generator  may run through the combinations of memory mappings  until the first memory mapping  meeting a desired performance criteria is determined. Although this deterministic approach can guarantee determining the memory mapping  with the fastest execution time, if there is a large number of memory mapping  versions to run in the program simulator  it may be costly in time and resources.","In a further embodiment, the optimization rules  uses a genetic type algorithm search that combines characteristics of the heuristic type method of  and the exhaustive type method of  discussed above. The memory mapping generator  will run timing simulations on the program simulator  for those combinations determined by a heuristic comparison between the program information  and the memory information . The heuristic comparison will result in a subset of memory mappings  as compared to all the possible versions of memory mappings  from the exhaustive approach. This has advantages over the exhaustive search since it is much less-time consuming. This also has advantages over the heuristic approach in that it will generate a memory mapping  with performance approaching the performance of the optimal memory mapping. More advanced memory mapping algorithms can be configured in the optimization rules  using additional information, such as memory banking requirements and iterative mapping schemes.","Although generally discussed in terms of determining a memory mapping  for the code and data segments of an entire program  for a block diagram model , the memory mapping generator  can generate memory mappings  for portions of the program . The memory mapping generator  may generate a memory mapping  for any user-specified granularity such as a specific function, a specific set of functions, specific data buffer or set of global data buffers. In these cases, the optimization rules  can be configured to specify optimization algorithms for these types of granularities. The memory mapping generator , with any of the combination of optimization approaches discussed above, can generate a memory mapping  for optimal performance for the portion of a program  being optimized. For example, a specific function and data buffer can be optimized for fastest execution time regardless of the execution times that will result in other code and data segments. The memory mapping  provided to the automatic code generator  may provide mapping information just for the specific function and data buffer. Additionally, the memory mapping  may include default mapping information, for example, from the linker, for the code and data segments not optimized by the memory mapping generator .","Furthermore, although the optimization approaches generally discuss code and data segments of a single program running on a single processor, the memory mapping generator  and the optimization rules  may also include algorithms for determining memory mappings  for multiple programs , \u2032 accessing the same memory elements such as a memory element acting as a shared memory resource. In these cases, the memory mapping generator  considers that a code and data segment of one program  cannot be targeted to be stored in a memory location already targeted to store a code or data segment of a second program. Furthermore, the memory mapping generator  will need to consider the program information and the memory information of each of the programs together to determine optimal memory mappings. In the case of the optimization rules  configured with characteristics of the exhaustive approach, the memory mapping generator  will need to simulate on the program simulator  timing results for both programs accessing shared memory and concurrently operating on the computational hardware device.","In another aspect, the present invention relates to a method of automatically generating a program  from a block diagram model  and automatically generating an optimized memory mapping  to incorporate into the automatic generation of the program . The flow diagram of  depicts an illustrative method  for practicing an embodiment of the present invention as described in . Method  includes the steps of obtaining a block diagram model  (step ), and initiating an automatic code generation process (step ) to translate the functionality of the block diagram model  into a software implementation. At step , the automatic code generation process generates source code for each block of the block diagram model  by placing the code and data segments associated with each block into a named memory section. For each of the blocks, the automatic code generation process generates one or more program instructions in source code files . The source code files  direct a compiler to use named memory sections for code and data segments generated for each of the blocks. The automatic code generation process then compiles the source code files  into object code .","At step , an optimized memory mapping  is generated from program information  associated with the program  being automatically generated, and from memory information  describing the memory of the hardware targeted to execute the program . During the optimization of the memory mapping , one or more different types of optimization algorithms contained in the optimization rules  can determine a memory mapping . The optimization algorithm determines the placement of the code and data segments of named memory sections into the portions of the memory of the target device and generates an optimized memory mapping . The optimized memory mapping  represents an optimization of the performance of an execution of the program  on the processor of the target device.","At step , the automatic code generation process obtains the optimized memory mapping . The memory mapping  may be provided in a linker command file . In another embodiment, the automatic code generation process generates a linker command file  implementing the obtained memory mapping . The automatic code generation process can then build the program  with a linking utility using the linker command file  and object files . Since the linker command file  implements the optimized memory mapping , the built program  incorporates the optimized memory mapping .","Although the illustrative method  is discussed in terms of generating a program  from a block diagram model  incorporating an optimized memory mapping , the steps of the method  can be applied in a like manner to one more block diagram models  representing multiple programs to run on a plurality of processors accessing memory that may be shared between the processors. As such, the steps of method  can be applied repetitively in one execution of the automatic code generator  and\/or memory mapping generator , or repetitively by multiple executions of the automatic code generator  and\/or memory mapping generator . Furthermore, the present invention can also be applied to generate memory mappings  for programs to run on components that are on different target devices. For example, the block diagram model  may represent a two processor design with each processor on separate target devices. The systems and methods described herein can generate a program from the block diagram model  for each of the processors on different targets and have the programs incorporate the memory mapping techniques of the present invention","Additionally, either the memory mapping generator  or the automatic code generator  may provide a graphical user interface to allow a user to select one or more of the optimizations determined by the memory mapping generator  for any of the code and data memory sections of the program . In another embodiment, the graphical user interface may allow the user to select user preferred mappings to map the named memory sections to the memory structure of the target device. In a further embodiment, the graphical user interface may allow the user to edit or otherwise re-arrange the optimizations provided by the memory mapping generator . In this manner, the user can exercise control over the optimization on a granular basis. The optimizations selected by the user then would be incorporated in either the memory mapping  provided to the automatic code generator  or otherwise implemented in the linker command files  to build the program .","By way of example,  depicts a graphical modeling environment , such as Simulink\u00ae, of the technical computing environment . The graphical modeling environment  may obtain or provide a block diagram model  that may have one or more blocks -. The design represented by the functionality, algorithms or computations of the blocks -may be targeted for one or more computational hardware devices, such as a an embedded hardware or processing platform. The graphical modeling environment  may provide a configuration mechanism to include a component configuration block  in the block diagram model . The component configuration block  allows for registering the component types and the physical memory layout of the target device. Furthermore, the component configuration block  allows a user to specify custom memory mappings for generated code to the target device. A component configuration block  may be pre-configured or pre-populated to represent a specific component, such as a specific type of processor. For example, the component configuration block  may be a component configuration block to represent a Motorola processor. Also, the component configuration block  may be configurable to represent one or more components, such as a list of component types registered with or otherwise known by the graphical modeling environment . Although a component configuration block  is generally discussed in terms of being a block of the block diagram model , the component configuration block  may comprise any type of graphical element, such as an icon, that may be placed in or otherwise associated with the block diagram model . Alternatively, the component configuration block  may instead be any type of configurable element provided by the graphical modeling environment  that can be associated with a block diagram model , such a graphical user interface form, a file, or any other configurable or editable element suitable for performing the operations described herein.","One or more component configuration blocks  may be associated with the block diagram model  to allow the same design of the block diagram model  be configured for code generation to multiple target devices using the memory mapping techniques of the present invention. For example, one component configuration block  may represent and be configured for a first type of processor and a second component configuration block  may represent and be configured for a second type of processor. This will allow the block diagram model to have code generated incorporating an optimized memory mapping for any target having a component configuration block  associated with the block diagram model . Also, if the design of the block diagram model  is targeted for a multiple component device, such as an embedded system with multiple processors of different types, code and memory maps for portions of the design can be generated for the multiple processors from the same block diagram model .",{"@attributes":{"id":"p-0089","num":"0093"},"figref":["FIGS. 6 through 8","FIG. 6","FIG. 7","FIG. 8","FIG. 6"],"b":["530","600","530","700","800","600","700","800","600","605","610","615","600","605","700","610","615","530","600","700","800","600","700","800","520","600","700","800"]},"Referring now to , the board information graphical user interface  provides as illustrative example of several configurable and editable graphical user interface widgets for defining board related properties of a target computational hardware device. The board type edit widget  allows a user to specify the type of board. The device choose list widget  allows a user to specify the type of processor, and the CPU clock speed widget  allows the user to specify the CPU speed of the processor. From the selection of the processor type from the device choose list widget , the systems and method of the present invention may determine the internal memory information of the processor. This information may form a portion of the memory information  used by the memory mapping generator . The board information graphical user interface  also provides a board name choose list widget  and a processor name choose list widget , which specifies the name of the target board and processor for the block diagram model  associated with the component configuration widget . Although the board information graphical user interface  of  shows a screen for configuring a single processor, the board information graphical user interface  may provide additional widgets for defining board related properties for boards with multiple processors. For example, there may be additional device choose list widgets , CPU clock speed widgets , board name choose list widgets , and processor name choose list widgets .","Referring now to , the memory configuration graphical user interface  provides as illustrative example of several configurable and editable graphical user interface widgets for defining the physical memory layout of a target computational hardware device. The physical memory choose list widget  provides a list of physical memory elements of the target computational hardware device as related to the board properties defined in the graphical user interface  for the board info tab . The graphical user interface  may be configured with or otherwise provide a list of physical memory elements to have the user define the physical memory layout. The default names assigned or given to the physical memory elements may be configured in the technical modeling environment , may follow a pre-determined or configured naming convention, or may be provided by any suitable means. Otherwise, the graphical user interface  may allow the user to edit, add or otherwise specify names to give to portions of the physical memory elements.","The name widget  allows a user to specify the name of a portion of the physical memory layout to which to configure memory size attributes. The address widget  and the address length widget  allow the user to specify memory size attributes for the selected physical memory. The contents choose list widget  allows the user to select the type of contents for the physical memory layout specified by widgets ,  and , such as code and data segments of the program segments generated from a block diagram model  in accordance with the present invention. After providing the name, address, length and contents of a portion of physical memory, the add command button  may be invoked to add this to the physical memory layout configuration for this target device. This will cause the newly named portion of physical memory with the name specified in the name widget  to appear in the physical memory choose list widget . A named portion of the physical memory layout can be selected from the physical memory choose list widget  and widgets ,  and  will be updated accordingly with the current configuration for that named memory element. The remove command button  may be invoked to remove this named memory portion from the configuration for the board. Accordingly, the memory configuration graphical user interface  removes this selection from the physical memory choose list widget . Additionally, in the heap section  the user can specify heap related information with regards to the named memory portion, and via the cache widget  the user can specify an optional cache size. The memory configuration graphical user interface  may save, or otherwise provide this configuration information to form the memory information  in accordance with the present invention. With the configurability illustrated by the memory configuration graphical user interface , the user can arrange the physical memory layout in any desired arrangement with any desired granularity. This provides great flexibility and control for mapping code and data sections as discussed below with regards to .","Referring now to , the memory mapping graphical user interface  provides as illustrative example of several configurable and editable graphical user interface widgets for mapping the program segments of a program to the configured memory physical layout of the target device as configured in the memory configuration graphical user interface  associated with the memory tab . For example, program segments from code  for a program  generated from a block diagram model  may be mapped to the configured physical memory layout. The compiler section  and the processor section  of the graphical user interface  allow the user to map default code and data sections to desired memory elements as configured in memory tab . These default code and data sections may represent the standard named memory sections in the object code  generated by default by the compiler as discussed above with regards to the use of #pragma compiler directive. In the custom section , custom named memory sections in the object code  may be mapped to the desired memory elements. The custom named memory sections may comprise code and\/or data segments representing the code  generated from the block diagram model .","The name widget  comprises a mechanism to specify the name of a custom memory section, and the placement widget  comprises a choose list of the named memory elements as configured via the memory configuration graphical user interface . This identifies the area in memory the custom section will be placed. As shown in the example of , the custom memory section named .SEC1 is specified in the name widget . When the add command button  is invoked, the named memory section of .SEC1 is configured to be mapped to, or otherwise targeted to be placed, in the named memory element of IDRAM selected in the placement widget . The remove command button  can be used to remove any custom section mappings. The user can create and map any of the custom named memory sections of object code  generated by the automatic code generator  to form a memory mapping . In this manner, the memory mapping  may be generated to incorporate into the building of a program so that it executes in a desired manner. Although  shows an example where the user specifies and adds a named memory section, the memory mapping graphical user interface  may provide a list of custom named memory sections, generated automatically or by any suitable means in accordance with the present invention. These provided named memory sections may follow a pre-determined or configured naming convention. In this manner, the user may not desire to specify the name of the custom memory section, but can still configure the memory mapping to place the custom memory sections, with a provided name, to the desired portion of memory.","Furthermore, although the memory mapping graphical user interface  is discussed in terms of a user configuring the memory mapping  to place the named memory sections of the code in one or more memory elements, the memory mapping graphical user interface  could display one or more optimized memory mappings  generated by the memory mapping generator . For example, when the memory mapping graphical user interface  is invoked it may be populated with an optimized memory mapping  provided by the memory mapping generator . In other embodiments, the graphical user interface  may use memory mappings  generated from any other source, such as a program, application, method, mechanism, environment, etc. In one embodiment, the graphical user interface  may use a memory mapping  generated by another type of memory mapping mechanism. As such, the custom section  may be populated with the named memory sections of the object code  provided by the automatic code generator . In a similar manner, the memory configuration graphical user interface  may be pre-populated with a physical memory layout obtained from memory information  in accordance with the present invention. The user then may be able to select, modify, remove or otherwise determine which memory mapping , or which portion thereof, to use for a target device.","In a summary view of the structure, functions and operations of the technical computing environment  as described herein, the present invention provides a systematic approach for generating an optimized memory mapping to incorporate into the automatic source code generation of a block diagram model. The present invention handles memory mapping of programs to be implemented on multi-component heterogeneous computational hardware devices such as a multi-processor embedded control system with shared memory. From a block diagram model, software can be automatically implemented and optimized to execute on the target hardware. With changes in the algorithm of the design reflected in a block diagram model, the program can be automatically generated with an automatically determined memory mapping optimized for the new design. Furthermore, if the memory topology of the device changes, the program can also be automatically regenerated with a new memory mapping optimized for the new memory layout of the hardware. Moreover, the block diagram model design can remain the same but have the programs and memory mapping re-targeted to a different device. From the same design, a new program and memory mapping can be automatically generated for the new target device. As such, the systems and method described herein greatly improve the time and efficiency of software design and development from a block diagram model to optimize software implementations.","Many alterations and modifications may be made by those having ordinary skill in the art without departing from the spirit and scope of the invention. Therefore, it must be expressly understood that the illustrated embodiments have been shown only for the purposes of example and should not be taken as limiting the invention, which is defined by the following claims. These claims are to be read as including what they set forth literally and also those equivalent elements which are insubstantially different, even though not identical in other respects to what is shown and described in the above illustrations."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, aspects, features, and advantages of the invention will become more apparent and may be better understood by referring to the following description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 4","FIG. 2A","FIG. 2B"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 6","b":["7","8"]}]},"DETDESC":[{},{}]}
