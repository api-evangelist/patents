---
title: Forming a signature of parameters extracted from information
abstract: A method of storing information relating to the transmission of messages by an entity over a given time period comprises the step of creating a signature comprising a plurality of parameters related to the transmission of messages over that time period wherein the parameters comprise at least one parameter related to the transmission of messages over a portion of the period and also related to the position of the portion in the period, to enable output data to be derived from the stored information. The signature may be updated by a weighted averaging process with other more recent signatures. Application in fraud detection where signature representing information in many call detail records from a particular subscriber is fed to a neural network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06920440&OS=06920440&RS=06920440
owner: Cerebrus Solution Limited
number: 06920440
owner_city: 
owner_country: GB
publication_date: 19970703
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Appendix A","Appendix B"],"p":["This invention relates to methods of storing information relating to the transmission of messages, to methods of deriving output data from information relating to the transmission of messages to corresponding systems, and to software in computer readable form for such systems and methods.","Anomalies are any irregular or unexpected patterns within a data set. The detection of anomalies is required in many situations in which large amounts of time-variant data are available. For example, detection of telecommunications fraud, detection of credit card fraud, encryption key management systems and early problem identification.","One problem is that known anomaly detectors and methods of anomaly detection are designed for used with only one such situation. They cannot easily be used in other situations. Each anomaly detection situation involves a specific type of data and specific sources and formats for that data. An anomaly detector designed for one situation works specifically for a certain type, source and format of data and it is difficult to adapt the anomaly detector for use in another situation. Known methods of adapting an anomaly detector for used in a new situation have involved carrying out this adaptation manually. This is a lengthy and expensive task requiring specialist knowledge not only of the technology involved in the anomaly detector but also of the application domains involved. The risk of errors being made is also high.","Another problem is that a particular method of anomaly detection is often most suitable for one particular situation. This means that transfer of a particular anomaly detector to a new situation may not be appropriate unless core elements of the anomaly detector method and\/or apparatus are adapted. This is particularly time consuming and expensive particularly as the development of a new anomaly detector from scratch may often be necessary.","One application for anomaly detection is the detection of telecommunications fraud. Telecommunications fraud is a multi-billion dollar problem around the world. Anticipated losses are in excess of $1 billion a year in the mobile market alone. For example, the Cellular Telecoms Industry Association estimate that in 1996 the cost to U.S. carriers of mobile phone fraud alone is $1.6 million per day, projected to rise to $2.5 million per day by 1997. This makes telephone fraud an expensive operating cost for every telephone service provider in the world. Because the telecommunications market is expanding rapidly the problem of telephone fraud is set to become larger.","Most telephone operators have some defence against fraud already in place. These are risk limitation tools such as simple aggregation of call-attempts, credit checking and tools to identify cloning, or tumbling. Cloning occurs where the fraudster gains access to the network by emulating or copying the identification code of a genuine telephone. This results in a multiple occurrence of the telephone unit. Tumbling occurs where the fraudster emulates or copies the identification codes of several different genuine telephone units.","Methods have been developed to detect each of these particular types of fraud. However, new types of fraud are continually evolving and it is difficult for service providers to keep \u201cone-step ahead\u201d of the fraudsters. Also, the known methods of detecting fraud are often based on simple strategies which can easily be defeated by clever thieves who realise what fraud-detection techniques are being used against them.","A number of rule-based systems have been developed, however, they have a series of limitations. It is now being acknowledged that each corporate and individual customer will show different behaviour, and thus a simple set of rules is insufficient to adequately monitor network traffic. To adapt these rule-based systems to allow each customer to have their own unique thresholds in not possible due to the sheer volumes of data involved.","There are a number of difficulties with identifying fraud, namely:\n\n","Another method of detecting telecommunications fraud involves using neural network technology. One problem with the use of neural networks to detect anomalies in a data set lies in pre-processing the information to input to the neural network. The input information needs to be represented in a way which captures the essential features of the information and emphasises these in a manner suitable for use by the neural network itself. The neural network needs to detect fraud efficiently without wasting time maintaining and processing redundant information or simply detecting \u201cnoise\u201d in the data. At the same time the neural network needs enough information to be able to detect many different types of fraud including types of fraud which may evolve in the future. As well as this the neural network should be provided with information in a way that it is able to allow for legitimate changes in behaviour and not identify these as potential frauds.","A particular problem for any known method of detecting fraud is that both static classification and temporal prediction are required. That is, anomalous use has to be classified as such, but only in relation to an emerging temporal pattern. Over a period of time an individual phone will generate a macroscopic pattern of use, in which , for example, intercontinental calls may be rare; however within this overall pattern there will inevitably be violations \u2014on a particular day the phone may be used for several intercontinental calls. A pattern of behaviour may only be anomalous relative to the historical pattern of behaviour.","Another problem is that a particular type of information to be analysed by a neural network is often in a variety of formats. For example, information about individual telephone calls is typically contained in call detail records. The content and format of call detail records differs for different telecommunications systems and this makes it difficult for such information to be input directly to a neural network based system.","A further problem is that once information has been provided for input to a neural network based system it is often not suitable for other purposes. For example, when a neural network system is being used to detect fraudsters much information about the behaviour of customers is prepared for input to the system. This information could also be used for marketing purposes to develop a much more detailed understanding of customer behaviour. However, this is often not easy to effect because of the format of the data.","One problem with known methods of fraud detection is that they are often unable to cope adequately with natural changes in the input data. For example, a customer's telephone call behaviour may change legitimately over time; the customer may travel abroad and make more long distance calls. This should not be detected as an anomaly and be classified as a potential fraud. Because the telecommunications market size is increasing, this is a particular problem for fraud detection in telecommunications.","Known methods of anomaly or fraud detection which have used neural networks involve first training the neural network with a training data set. Once the training phase is over the neural network is used to process telecoms data in order to identify fraud candidates. As the behaviour of customers evolves, new data input to the neural network may be widely different from the original training data set. In these circumstances the neural network may identify legitimate new patterns in the data as anomalies. Similarly, real cases of fraud may go unidentified. In this situation it is necessary to retrain the neural network using an updated training data set which is updated to reflect new features of the data.","Several problems arise as a result of this need for retraining. For example, a decision needs to be made about when to retrain. Typically this complex decision is made by the user who requires specialist knowledge not only about telecoms fraud but also about the neural network system. Because telecoms fraud is an on-going problem which takes place 24 hours a day, 7 days a week, it is often not possible for an expert user to be available. This means that the system may \u201cunder perform\u201d for some time before retraining is initiated.","Another problem is that the performance of the neural network system needs to be monitored in order to determine when the system is \u201cSunder performing\u201d. This can be a difficult and lengthy task which takes up valuable time.","Another problem is that the process of retraining is itself a lengthy and computationally expensive process. Whilst retraining is in progress it is not possible to use the neural network system to detect anomalies. This means that telecoms fraud may go undetected during the retraining phase. Also, the retraining process may take up valuable processing resources which are required for other tasks. This is especially important in the field of telecommunications where it may be required to site the neural network system at a busy switch or node in the telecommuncations network.","A further problem is that intervention and input from the user is typically required during the retraining process. This can be inconvenient when it is necessary to retrain quickly and also requires a trained user to be available.","It is accordingly an object of the present invention to provide an apparatus and method which overcomes or at least mitigates one or more of the problems noted above.","According to a first aspect of the present invention, there is provided a method of storing information relating to the transmission of messages by an entity over a given time period comprising the step of creating a signature comprising a plurality of parameters related to the transmission of messages over that time period wherein the parameters comprise at least one parameter related to the transmission of messages over a portion of the period and also related to the position of the portion in the period, to enable output data to be derived from the stored information. This provides the advantage that information about both a macroscopic pattern of behaviour over the whole time period and a microscopic pattern of behaviour over part of the time period can be stored. Lengthy processing times for signature creation and storage are avoided and redundant information is kept to a minimum. Advantageously, anomalies in the stored data can more easily be detected in relation to an emerging temporal pattern. A further advantage is that the stored data is available for other purposes, for example marketing, forecasting and other types of planning.","Preferably, the signature is created in one of a plurality of predetermined possible formats. This provides the advantage that the stored signatures are suitable for a variety of purposes. For example, the signature can be provided as inputs to a number of different neural network instantiations.","Advantageously, the signature is processed using a predictive model such as a neural network, which is dynamically configured according to the format of the signature. This provides the advantage that the method can easily be reused in a variety of situations. For example, anomaly detection for detecting telecommunications fraud could be one situation and anomaly detection for detecting credit card fraud could be another situation. In these two cases the tasks vary in many respects; the input data is of a different type and will be provided in different formats and from different sources. The method can be used in different situations such as these so that development times and costs are reduced and the likelihood of errors occurring in the method are reduced.","Preferably, the said configuration step further comprises adjusting the topology of the neural network. This provides that advantage that the neural network topology can easily be adapted to best suit different situations in which the method is used. Advantageously, the neural network topology is adapted to provided the best anomaly detection ability.","According to a second aspect of the present invention, there is provided a method of deriving output data from information relating to the transmission of messages by an entity over time, comprising the steps of:\n\n","Preferably, said step of updating the first signature by a weighted averaging with the second signature further comprises the steps of: (i) determining a third signature comprising a plurality of parameters related to the transmission of messages over a third period shorter than the second and more recent than the second; and (ii) updating the secorid signature by a weighted averaging with the third signature such that in use an up-to-date comparison of the second signature with the first signature can be obtained. This provides an advantage when the first and second signatures are provided as inputs to a process that requires first and second signatures of a fixed format. Available information that cannot be incorporated into the first signature can be incorporated into the second signature.","Advantageously the method comprises the steps of:\n\n","Advantageously the method comprises the steps of:\n\n","Advantageously, the method comprises the steps of:\n\n","Advantageously, if the neural network is implemented using an object oriented programming language the objects can be converted into a form that can be stored, using a persistance mechanism. Once converted into data structure format the data structure can be moved between processors which may be nodes in a communications network for example. This provides the advantage that the neural network can be moved to a quiet node to be trained. Also in the event of a system crash or other such event, a stored version of the neural network can be retained and then recreated into object form when the system is up and running again. According to other aspects of the invention, there are provided corresponding systems.","Preferred features as set out in the dependent claims may be combined with each other or with any aspect of the invention as appropriate, as would be apparent to a person skilled in the art.","Embodiments of the present invention are described below by way of example only. These examples represent the best ways of putting the invention into practice that are currently known to the Applicant although they are not the only ways in which this could be achieved.","Definitions:","Call detail record (CDR)\u2014this is a set of information about an individual telephone call. For example, information such as the account number, the date and time of the call, whether it was long distance or local etc. A CDR is created whenever a phone call is completed. The content of a CDR may vary for different telecommunications systems.","CDR interpreter\u2014this examines CDRs and extracts those fields necessary for anomaly detection.","Detection poll period\u2014this is a time interval during which information is collected for input to the anomaly detector.","Profile\/signature\u2014this is a set of information summarising and describing the behaviour of an individual customer or account number over a given time period.","Anomaly\u2014this is any irregular or unexpected pattern within a data set.","FCAPS Application Frameworks\u2014systems for fault management, configuration management, accounting management, performance management and security management in a communications network.","Topology of a neural network\u2014this is the number of units in the neural network, how they are arranged and how they are connected.","Kernel\u2014this is the part of the anomaly detector which detects anomalies and performs many other functions.","Graphical user interface (GUI)\u2014this provides means for communication between the user and the anomaly detector using display screens.",{"@attributes":{"id":"p-0062","num":"0083"},"figref":"FIG. 1","b":["1","2","3","4","1","2","20"]},{"@attributes":{"id":"p-0063","num":"0084"},"figref":"FIG. 2","b":["20","21","21","2","20"]},"The ADE  is used in conjunction with application specific software . This is software which performs any data transformations that are needed in order to convert the network data  to be analysed into a format that the ADE  can use. The application specific software  also includes software to perform a validation of the anomaly candidates detected and also any software to convert the ADE's results into actions to be performed. If the ADE is embedded in a network manager  then the application specific software  includes interface software to allow the ADE to be embedded in this way.","Before the ADE can be used it must be instantiated and integrated into the user's environment. By using an ADE component  in conjunction with application specific software  a particular instantiation of an anomaly detector  is created. This process of creating a particular anomaly detector is referred to as instantiation. Following instantiation, the ADE is integrated into the user's environment. For example, a graphical user interface (GUI)  is added to the ADE to create a stand-alone application such as that shown in FIG. . Alternatively, the ADE is integrated into existing software such as a network manager , which communicates directly with the ADE. The instantiated anomaly detector can be used by only one element in a communications network  or alternatively it may be used by different network elements. For example, by embedding an ADE in an FCAPS application framework an anomaly detector suitable for use by different communications network elements is obtained.","As previously described the ADE contains neural network components  which learn the data patterns or behaviour and detect the differences in the behaviour\u2014the anomalies. For a particular anomaly detection situation a particular neural network topology will be most suitable. Also, the neural network needs to be trained in order to have a set of weights that enable anomalies in the input data to be detected. If the ADE is simply reused in a new situation the topology and weights of the neural network components  may not be appropriate for the new situation. In order to get round this problem when an ADE is instantiated to form a particular anomaly detector the topology of the neural network components  can be automatically adjusted. The neural network components  can then be trained or retrained to achieve a desired set of weights. This provides the advantage that the ADE can be used in a variety of situations. The ADE can be applied \u201ccross-product\u201d and \u201ccross-data layer\u201d. Cross-product means that the ADE can be applied to more than one type of communications network product. Cross-data layer means that the ADE can be applied to data gathered from the various layers of the communications network.","A general overview of how the ADE detects anomalies is now given by way of example. The ADE receives input information  about the transmission of messages in a communications network . This information  is in the form of call detail records (CDR's) and is processed by the ADE to form profiles (also referred to as signatures). A profile is a set of information summarising and describing the behaviour of an individual customer or account number over a given time period. Historic and recent profiles are formed where an historic profile relates to the behaviour of an individual customer over a certain period of time and a recent profile relates to the behaviour over a shorter and more recent period of time. The historic profiles are assumed to represent non-anomalous behaviour. By comparing the historic and recent profiles using the neural network components  anomalies in the recent profile are detected. Many pairs of historic and recent profiles are created and compared and over time the historic profiles are updated with non-anomalous information from the recent profiles.","Before anomaly detection can take place the neural network components  must be trained. The neural network components comprise a multi-layer perceptron neural network. This neural network is trained using a supervised training method. This involves inputting a training data set to the neural network so that the neural network is able to build up an internal representation of any patterns inherent in the data. The training data set contains profiles and information about whether these profiles are anomalous or not. This allows that neural network to learn the typical and exceptional behaviour profiles that occur in the network data and to classify them accordingly. Once the neural network has been trained it is validated to check that the training has been successful. This is done by presenting a new set of profiles, that are known to be anomalous or not, to the trained neural network. The outputs of the neural network are then compared with the expected outputs.","The successfully validated neural network can then be used to detect anomalies. New communications network data is presented to the ADE which uses the new data to form recent profiles. The neural network then compares the recent profiles with the historical profiles in order to detect anomalies. If there is a difference between the recent and historical profiles then the neural network can indicate whether this is due to anomalous behaviour by the system or whether it is simply due to an acceptable change in the behaviour profile. If a pattern of data that has never been encountered before is presented to the neural network then the neural network produces a best-guess result.","As time passes since the neural network was trained general trends in the data from the communications network occur. These trends are not taken account of by the neural network because the neural network was not trained on this data. In order to get round this problem the neural network can be retrained. This process can be carried out automatically using suitable application specific software.","As the ADE is used, further information about whether anomaly candidates produced by the ADE are real anomalies or not may be obtained by the user. Provision can be made for this information to be input to the ADE and used to update the training data set and various other information. This process is described in more detail below.","Main ADE Components","The main components of the ADE are now described and later the processes of instantiating an ADE and integrating it ready for use are described in detail with reference to examples.  shows the main components of the ADE and also the flow of information between these components. The main components comprise:\n\n","The ADE comprises all components inside the boundary  in FIG. . The area outside the boundary  refers to the particular instantiation of the ADE in application specific software. Data about the transmission of messages in a communications network that has been pre-processed into a specific format  is input to the profile generator . The profile generator  forms historic and recent profiles or signatures , of the input information . If necessary the historic profiles are updated with information from the recent profiles using the profile decay process . Information about whether anomaly candidates produced by the anomaly detector are really anomalies or not  can be input to the ADE and used to update the profiles and for other purposes. These processes are described further below.","Once the recent profile  and the historic profile  have been created and updated as required, they are input to the data transformer  which transforms them into a format required by the detector . For example, a recent profile and a historic profile pair may be concatenated, or the difference between the two profiles may be calculated. Other transformations are also possible. The transformed data  is used by the engine administrator  and the detector .","Engine Administrator","The engine administrator, also referred to as an ADE manager, is responsible for the following tasks:\n\n","As shown in  the engine administrator  comprises a data manager ; a training \/retraining processor ; an evaluator ; and a processor for creating a neural network .","Data Manager ","The data manager  maintains two data sets: an evaluation data set , and an example data set  which is also referred to as a training data set. The data manager receives inputs of detection data  and validated results . The validated results comprise information about whether anomaly candidates identified by the neural network  are real anomalies or not. These validated results  are also referred to as \u201cprofile identification and category\u201d information; they are used to update the example data , the evaluation data  and for other purposes as described below. The evaluation data set  is created by splitting the detection data set  into two parts; an evaluation data set  and an example or training set . Both these sets of data contain profiles and information about whether each profile in the set is anomalous or not.","The example or training data set  is used to train the neural network  using the training processor . Adding new examples of anomalous behaviour  to this data set enables the detection to be updated with new information. This aids the general performance of the ADE; examples from false positive identifications can be added to the example data set to reduce the probability that the false identification recurs. Adding results from positive identifications reinforces the ability of the neural network  to make similar positive identifications.","Training\/retaining Process ","The training process enables the ADE to learn, or relearn, a particular task. To obtain the optimum performance from the ADE, a representative data set  needs to be presented during training. This training data set  should include examples of anomalous events as well as non-anomalous events and preferably in a proportion that is representative of the data set to be analysed by the ADE. The neural network  is trained using a learning algorithm. Many different learning algorithms can be used and in a preferred example a non-parameterised learning rule, the known scaled conjugate gradient algorithm, is used. Condition parameters  are input to the training\/retraining process . These parameters can be input by the user or may be predefined. They include information specific to the training\/retraining process such as how many training epochs should be carried out and whether early stopping should be invoked. Retraining can be carried out automatically without intervention by the user as described below. This is done by using specially adapted application specific software. The process of retraining can involve the creation of a second neural network that has the same topology as the original neural network  and retaining the second network. This is described in detail below.","Performance Evaluator ","Once the ADE has been trained, a validation process  is used to determine the performance that the ADE has for the particular task. The performance of the ADE is determined by presenting the evaluation data set  to the neural network  using the performance evaluator . The evaluation data set  contains profiles and information about whether these profiles are anomalous or not. The profiles are presented to the neural network  and the anomaly candidates produced by the neural network  are compared with the expected outputs by the performance evaluator . The performance evaluator  then calculates a value  which indicates the level of similarity between the actual and expected outputs of the neural network. This value  is then provided to application specific software . neural network creation process .","For each instantiation of the ADE a separate neural network  is required. The neural network creation process  creates a neural network of a given internal architecture. The creation process  creates a multi-layer perceptron (MLP) that is either fully connected or not fully connected. The MLP can be created with different numbers of input, output and hidden units. The number of hidden layers can also be varied. It is not essential that the creation process create a multi-layer perceptron type neural network. Other types of neural network such as a self-organising map could be created and used to detect anomalies.","Detector ","Once the data from the two profiles has been prepared, the neural network has been created and evaluated by the administrator , the neural network  is simply presented with the new detection data . Referring to , the detector  receives the detection data  and using the trained and validated neural network  carries out the detection process to produce potential anomaly candidates . The neural network classifies each recent profile either as an anomaly or not and the neural network  also gives an associated confidence value for each classification. Anomaly threshold parameters  are input to the detector  from application specific software. These parameters  are used to filter the potential anomaly candidates  to remove the majority of false positive identifications. For example, all anomaly candidates with a very low confidence rating could be filtered out.","Instantiating and Integrating the ADE to form a Specific Anomaly Detection Application","The ADE is a library of software components which can be used to detect anomalies in data about the transmission of messages in a communications network. The components need to be tailored for each specific application and once instantiated form an engine which can then be integrated into a software system. The ADE has an application programming interface (API). The application specific software  communicates with the ADE via this API.","Appilication programming interface (API)","The API enables  different method calls to be made on the ADE from the application specific software . That is  different instructions can be given to the ADE including:\n\n","This instruction requires that information about the location of an anomaly detector creation specification and a training data set is supplied when the instruction is made. This information is supplied by the application specific software , for example, it may be input by the user through a GUI. When this instruction is given to the ADE an anomaly detector is created which includes a neural network based on the creation specification and the training data set. The anomaly detector creation specification contains information about the minimum size for the training data set as well as other information as described below. Once the anomaly detector has been created a signal is returned to the application specific software  to indicate that the neural network is ready.","TrainAD","This instruction causes the training\/retraining process  to train or retrain the neural network using the training data set and any retraining data that is available. Once the neural network has been trained or retrained information is sent back to the application specific software. This includes information about the location of the trained\/retrained neural network and a classification error. The classification error is a value which indicates the proportion of inputs that were misclassified by the neural network during an evaluation of the performance of the neural network.","PerformDetection","This instruction requires that information about the location of a detection data set  is provided to the ADE. When this instruction is given the detector  in the ADE performs a detection using the supplied detection data set. This is the normal mode of operation for the engine. A series of real presentations are supplied, which the neural network attempts to classify as being anomalies or not. When the detection is completed the ADE returns a data set to the application specific software . This is a list showing which category (anomaly or not) the ADE classified each input into together with a confidence rating for each classification.","EvaluatePerformance","When this instruction is given to the ADE the performance evaluator  carries out an evaluation using the evaluation data set . When the performance evaluation is completed a classification error is returned to the application specific software. This gives an indication as to how many mis-classifications were made by the neural network. A mis-classification occurs when the neural network returns a detection result based on a known input-output pair, which does not match the correct output for that particular input.","SwitchADs","When this instruction is given to the ADE a recently trained second neural network (that was created during the retaining process and is contained in a second anomaly detector) is switched with the current active neural network. That is, the current active neural network is replaced by the newly trained neural network. If a switch is attempted before a second neural network has been created an error message is returned to the application specific software .","AddKnowledge","This instruction requires that information about the location of a data set containing validated results , is provided with the instruction. When the instruction is given, a retraining data set is created or updated within the ADE using the new information. When the updating process is completed information about the location and existence of the retaining data set is returned to the application specific software.","UpdateProfiles","This instruction requires that information about the location of the presentation data set to be provided when the instruction is given. When the instruction is given the historic profiles are updated using information from the recent profiles using the profile decay process . When the updating process is completed information about the location of the updated presentation data set is returned to the application specific software . It is also possible for the recent profiles to be updated with current information as described below.","DeleteAD","When this instruction is given the anomaly detector is deleted. Any memory that was used to store the anomaly detector is released.","Preferably the API (and the ADE) is created using an object oriented programming language such as C++. An object referred to as an ApplicationBridge object is provided which makes available each of the 8 methods or instructions described above. Each of the 8 methods has an associated valid \u201creturn event\u201d method. In order to add further capabilities required by a specific application the user must create further software which inherits from the ApplicationBridge object and overloads the return event methods. It is not essential however for the API and indeed the ADE software to be created using an object oriented programming language. Other programming languages could be used.","Anomaly Detector Creation Specification","This contains three parameters and information about the location of a neural network creation specification. Preferably the anomaly detector creation specification is an object created using an object oriented programming language. It is used by the ADE to instantiate all the C++ objects. The three parameters are:\n\n","In order to produce an anomaly detector creation specification it is necessary to first construct a neural network creation specification.","Neural Network Creation Specification","The neural network creation specification contains information about the location of two other specifications, the layered network specification and the network trainer specification. Preferably the neural network creation specification is formed using an object oriented programming language and is linked to the anomaly detector creation specification object, a layered network specification object and a network trainer specification. The layered network specification and the network trainer specification should be created before the neural network creation specification.","Layered Network Specification","This contains the specification for a particular type of layered neural network. A list of three values is given which specify:\n\n","A list of weights can also be given. This is a list of values for each of the weights between the connections in the neural network. If the specification is for a trained neural network then a list of weights must be given. If the specification is for an untrained neural network then no weights are necessary. The number of input units is determined with reference to the number of attributes of the input data that are deemed significant. The number of units in the hidden layer can be determined either empirically or by statistical analysis using known methods. The number of units in the output layer depends on the number of classifications the user requires for the particular task. It is also possible to specify whether the neural network should have a fully-connected architecture or a partially connected architecture. If a partially connected architecture is selected the specific connections are specified in the list of weights.","Network Trainer Specification","This contains information required by the neural network during training. 7 parameters are included:\n\n","The ADE is generic in nature and requires an additional layer of instantiation software (or application specific software ) to provides further functionality. For example, the instantiation software may provide a GUI, data pre\/post processing and interfaces to the external world. As a minimum requirement the application specific software must allow the user to give any of the  API method instructions or calls to the ADE. The parameters required by each method call must also be provided in the correct format. For example, historic and recent profiles must be of a specified format, as must any specifications and data sets.","The process of instantiating an ADE will now be described by way of example. In this example the ADE is to be instantiated and used to detect fraudulent usage on a mobile telephone or fixed telephone network. Also, the data to be analysed by the ADE is in the form of call detail records which have been preprocessed into the format required by the ADE.","The steps involved in the instantiation process include:",{"@attributes":{"id":"p-0102","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":{"@attributes":{"id":"ul0018-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":["arrange for the application specific software to supply the CDRs in the correct format to the ADE","create an anomaly detector creation specification (this includes the step of creating a neural network creation specification);","create the anomaly detector;","create the training data set, validation data set and presentation data set;","train the neural network;"]}}}},"When these steps have been performed the instantiated ADE is ready to detect fraudulent telephone accounts. The application specific software should also be arranged to allow the other instructions or method calls (add knowledge; retrain; switch; delete) to be sent to the ADE.","Create an Anomaly Detector Creation Specification","This entails determining the values for the various parameters. In this example the ADE is formed using an object oriented programming language. In this cases a call is made on an anomaly detector creation specification object constructor. This causes the anomaly detector creation specification to be created. The parameters should be calculated prior to the creation of the anomaly detector and inserted into the anomaly detector creation specification. The optimum set of parameter values should be used in order to obtain the best detection results. For example, the number of output units for the neural network is determined according to the type of data being analysed. For fraud detection two output units can be used, one for fraud and one for non-fraud. The analysis of raw network data is required to help in the definition of the key attribute\/fields and values that are needed for the anomaly detector specification.","Create the Anomaly Detector","The anomaly detector objects are created by giving an instruction to start the CreateAnomalyDetector method and supplying information about the location of the anomaly detector specification and training data set.","Create the Training Data Set, Validation Data Set and Presentation Data Set","The CDR data must be transformed in order to produce the training, validation and detection data sets. One approach for doing this involves:\n\n","The creation of a historic profile for a new customer account needs to be done at the instantiation layer (application specific software). The historic profile should be a direct copy of the recent profile with a label to indicate that it is a new customer account. Also, data for a profile needs to be consecutive, i.e. if it is determined that a recent profile required 5 hours of data, then 5 consecutive hours need to be used for the recent profile, not just any 5 hours. This means that gaps in the CDR data may cause problems. However, this depends on the relative size of the \u201cgap\u201d. For example, if there is a one hour gap in a months worth of data then there is unlikely to be a problem. Another point is that the window sizes for the historic and recent profiles must be for consecutive time periods. For example, the historic time period may be from 1 Jan to 31 Jan whilst the recent profile window is from 31 Jan to 5 Feb.","Train the Neural Network","This process involves cyclically adjusting the weights stored on the connections between units in the neural network, until sufficient training has been performed. This is done by sending an instruction to the ADE to start the TrainAD method.","Once the ADE has been instantiated or tailored for a specific application it is integrated into the system software. To do this integration code is used to bridge from the tailored ADE to the system software. This integration code is application specific. Many different possible forms for the integration code are possible. The integration code should take account of the following issues:\n\n","The integration software must manage the ADE. The functions which must be performed are:\n\n","Architectural Considerations are:\n\n","The integration code can have the following functionality:\n\n","The integration software is responsible for:\n\n","Some form of feedback loop is therefore needed in order for the fraudulent profiles output by the instantiation layer to be verified. The resultant fraud candidates will need to be assessed and the results of the assessment will need to be fed back into the instantiation layer in order for the correct profile adjustment to be made. Any non-fraudulent output will be allowed to update the associated historical profile without the need for a validation step.\n\n","A particular example of an instantiated ADE will now be described. In this example an anomaly detector is formed using an ADE together with application specific software which makes it possible for automatic retraining of the neural network components to take place. In this example, the particular instantiation of the ADE is referred to as a kernel within the anomaly detector. The major components of the kernel with respect to the fraud detector application domain, are set out in Appendix A below.",{"@attributes":{"id":"p-0116","num":"0196"},"figref":"FIG. 14","b":["201","202","203","204","205","201","201","205","261","206"]},"In the situation where the performance of the anomaly detector  is satisfactory, no retaining takes place. This is illustrated in  at . In this situation validation data has been provided although the neural network  has not been updated using the validated data ; that is, because the neural network  has not been retrained it is not able to take account of the new validation data . When further results are obtained from the anomaly detector , these will not reflect the new information and the user may be presented with results that she has already corrected before. In order to avoid this problem, the anomaly detector  is able to store validated results  between retraining episodes. This store of validated results is then used, as shown at , to update any further output from the anomaly detector before this is presented to the user for validation.","The anomaly detector  also has the ability to create a daughter neural network of the same topology as the parent. This daughter can then be retrained whilst the parent is still in use. Once the daughter is retrained it can then be used in place of the parent, if the performance of the daughter is satisfactory. This is illustrated in FIG. .","It is not essential for the validation data  to be provided by a user via a user interface. For example, the validation data could be obtained automatically and input to the system directly. Also, it is not essential for the neural network to form part of an anomaly detector. The neural network could be used for processing data for another purpose.","The process of monitoring the performance of the anomaly detector will now be described in more detail. This comprises:\n\n","The user is able to change the following settings during operation of the anomaly detector:\n\n","The kernel identifies via the system clock that a detection poll period has been reached. If the kernel is busy when a poll detection period is reached then when it becomes available it will get the current time. If this time is less than the clock interval (plus some overhead time) then the detection is serviced else the poll detection has been missed and the kernel sends a message back to the graphical user interface (GUI) to indicate that a poll detection has been missed.","If a detection is to take place then the kernel sends information to the GUI to indicate that the kernel cannot accept any further commands until the detection has been completed.","The kernel accepts input information that is input to the anomaly detector. This input information is initially in the form of call detail records for those customers who have made calls during the poll period. These call details records are pre-processed before being input to the kernel. The kernel also performs any further processing of the input information before this is provided as input to the neural network within the kernel. The neural network then performs the anomaly detection and outputs a set of results to the kernel. The kernel then stores these results in a file and sends information to the GUI indicating that the detection is complete.","Presenting the Outputs from the Anomaly Detector to the User Via a User-interface","When the GUI receives information from the kernel indicating that a new detection results file has been created it indicates this to the user. This is done by highlighting a reload button on a display screen. By activating this button, for example by clicking it with a mouse, the user can display the results file on the screen.  shows an example of such a display. The user can manipulate the way in which the results are displayed using the user interface. The user is also able to generate a graph displaying the results information as shown in FIG.  and independently to change the viewing criteria for this graph without affecting the table of results.","Accepting Validated Results or Target Outputs from the User Via the User Interface","When viewing the detection results on the table view as shown in , the user is able to indicate if individual responses were correct or incorrect. For example, the table  shown in  has one row  for each customer account number. In the various columns of the table  the following information is provided:","the customer account number; whether this account is identified as a potential fraud or not; the confidence rating of the fraud\/non-fraud classification and the average duration of a telephone call. Other information could also be provided, for example the average duration of long distance calls or information about geographical location. The validity column  displays information that the user has input about the account number concerned. This information can be added to the kernel's knowledge base. The user is able to select individual accounts and validate the anomaly detector's response. When the user has added validation information for a number of accounts this can be added to the engine's knowledge base. This is done by activating the \u201cadd knowledge\u201dbutton  on the user interface as shown in FIG. . When the user activates this button the GUI sends information to the kernel about the set of validated fraud candidates for all those accounts which have been validated and all other non-fraudulent accounts. This is called an add knowledge event.","When this information is sent to the kernel the kernel has several actions to perform as listed below:\n\n","When an add knowledge event has been initiated, the GUI needs to maintain a list of all accounts which have been validated and the condition associated with that account, for example, whether a fraud was correctly identified as such. If subsequent detection take place before the kernel initiates automatic retraining then the GUI can display to the user what that account has been previously validated to.","Add Information about the Validated Fraud Candidates to the Anomaly Detector's Knowledge Base","The kernel adds all the validated fraud candidates to the anomaly detector's knowledge base. The kernel also increments the number of add knowledge events which have been performed.","Update Profiles","The kernel updates the historical profile for those accounts which are validated as correct non-fraud candidates and those which are validated as incorrect fraud candidates. The kernel also updates the historical profiles for the other non-fraud candidates. The kernel matches the recent profiles with the customer's historical profile and then provides this information to another process which updates the historical profiles with the corresponding recent profiles. The updated historical profiles are then stored by the kernel.","Evaluate the Performance of the Anomaly Detector","If the number of add knowledge events is equal to the evaluation interval, the kernel performs an evaluation of the performance of the anomaly detector. If a performance evaluation is carried out then the counter for the number of add knowledge events is reset. The performance evaluation comprises carrying out a comparison of the candidates and any corresponding validation results.","Retrain the Neural Network","If the performance evaluation is less than the performance threshold, the kernel initiates retraining of the neural network. The kernel will not respond to any events that are sent until retraining is complete. No intervention by the user is required during retraining. The kernel informs the GUI when retraining is complete and which of the operations listed as 1-5 above have been performed so that the GUI can update its representations respectively. If an evaluation has taken place then the new performance evaluation result is sent to the GUI. If the neural network has been retrained, information about this is sent back to the GUI.","When retraining takes place, a new neural network is created by the kernel. This daughter neural network has the same topology as its parent. The daughter neural network is trained instead of retaining the parent.","Once retrained the daughter neural network is evaluated by the kernel. If the performance of the daughter is better than the parent then the kernel indicates to the GUI that a new neural network is available. The GUI asks the user if this new neural network should be used. The user's response is sent to the kernel and if affirmative, the kernel replaces the parent neural network with the daughter neural network.","Preferably the anomaly detector and the neural network are implemented using an object oriented programming language, or a non-introspective programming language. The anomaly detector is implemented using at least one instantiated object. In order to store or retain the objects persistence mechanisms are used. Such mechanisms are described in appendix B below. The objects or groups of linked objects are converted into data structures using the persistence mechanisms in order that they can be stored or retained. The data structures can then be passed between processors. For example, these may be different nodes on a communications network. This provides various advantages. For example, a daughter neural network, once created, can be stored as a data structure and moved to a quiet node in the communications network before being retrained. Also the neural network part of the anomaly detector can be moved to a particular node in the communications network whilst the other parts of the anomaly detector such as the GUI are held on a different (and perhaps quieter) node.","The anomaly detector discussed in the example above may also contain application specific software for storage of information relating to the transmission of messages in a communications network. A particular example of an anomaly detector which incorporates such application specific software is discussed below.",{"@attributes":{"id":"p-0138","num":"0231"},"figref":["FIG. 5","FIG. 6. A"],"b":["101","102","103","104","102","110","112","110","111","112","111","113","112"]},"In the case when the historic and recent signatures are compared using a particular instantiation of a neural network the time periods for the historic and recent signatures, once these have been chosen, are fixed. The neural network is trained using historic and recent signatures with the chosen time periods and thereafter signatures with the same size of time period must be used.","As time passes the historic signature needs to be updated because calling habits can change over time. This updating process enables emerging temporal patterns in the CDR data to be taken into account. The process of updating a signature is illustrated in .","The current historic signature  is updated with the current recent signature  to form an updated historic signature . A new recent signature  can then be obtained. As indicated in  the current historic signature  is combined with the current recent signature  using a weighted averaging procedure to form the updated historic signature . The arrow  in  indicates time and the information emanating from the communications network over time is illustrated by .","In the situation where a comparison between an historic and a recent signature is required to detect anomalies it may be that new information has become available since the recent signature was created. For example, if the historic signature must always be updated using a recent signature that represents 7 days worth of data then 6 days worth of new information may be available before it is possible to take this into account. The system must wait until the end of the short recent period before an update is possible.","In order to accommodate new information obtained in-between updates a third dynamic signature is used. The third signature is dynamic because it can be taken over a variable time period as long as this is shorter than the time period for recent signatures. The dynamic third signature can then be used to update the recent signature before the anomaly detection takes place. This has the advantage that all available data is used in the anomaly detection process.","A signature which can also be referred to as a profile contains a statistical representation for each customer over a period of time. In one example, a profile as shown in  comprises the following major components:\n\n","The process of generating signatures from CDRs will now be described in more detail. This process comprises:\n\n","This is done by defining a specification for the CDR type to be parsed. A parser for each type of CDR type is contained in a library of CDR parsers. A base class is created from which each new type of CDR is able to inherit as shown in FIG. .","For each CDR type which is to be parsed to create a profile a specification is built of the position of the important data and the format in which that data is stored within the CDR. An example of a CDR specification is shown in FIG. . The CDRs are then converted into the desired format using information from the CDR specification. An example of a desired or target call detail record format is shown in FIG. .","Generating the Profile","This involves selecting the appropriate attributes from each CDR (that has already been parsed into the desired format) to produce the profile. In this example, the desired CDR format is as shown in FIG.  and the profile has a basic structure as shown in FIG. . As previously described this contains 7 items for the basic structure  and  additional fields  which represent day-of-week and time-of-day information. Additional items can be added to this basic structure. Also, the 21 items  used within the profile shown in  can be expanded to model the time of day-of-week more closely. There is no restriction on the size of the profile which can be generated but the profile size must remain consistent within a particular instantiation of the system.","The appropriate attributes from each pre-parsed CDR are selected to form the profile by taking the following steps:\n\n","In the example target CDR format shown in  there is a DayOf Week field . This is used to determine which day the call was made on. Similarly, the CallTime field  is used to determine the time the call was placed on that particular day.","Calculating the Call Distribution Over the Week","This is done by:\n\n","Once the time when a call was initiated has been determined it is possible to create the elements of the profile which refer to the call distribution pattern i.e. the items shown at  in FIG. . Calls are analysed to calculate the percentage of calls made each day (7 items in the profile of ) and also the percentage of calls made during the day\/night periods (14 items in the profile of FIG. ). This gives 21 items relating to the call distribution. In this example, all the percentages are based on the number of calls made in the respective period compared with the number of calls made over a whole week. Also, in this example, all the percentages are scoped between 0 and 1. For example, 15% would become 0.15.","Calculating the Calls Made each Day","This is done by summing the number of calls made each day during the time period (in this case one week) and dividing this sum by the total number of calls made over the week. Information about the number of calls made each day is obtained using the DayOfWeek field in the CDR, shown as  in FIG. .","Calculating the Calls Made in each Day\/night Period","In this example, a night period is defined to include calls made between 7 pm one evening to 7 am the following day. Because a night period can therefore include calls made on separate days it is necessary to analyse which hour of the day the call is made and see which particular period a call should be classified in. Potentially, calls made over one day can fall into 3 different periods (,  and ) as shown in FIG. . The day of the week and the hour that the call was made are obtained. Then the number of calls made in the relevant period is divided by the number of calls made over the whole week to give the percentage of calls made in that period.","It is not essential that profiles of the form shown in  are used. Many other items could be included, for example the percentage of calls made to mobile telephones, the longest call made within the profile period and the number of call forwards made. Alternatively, the whole profile could be taken up with information about calls made at different times of the day. Many different combinations of different types of information are possible.","The process of updating a signature or profile is now described in more detail. As previously described, an historic signature is updated with the corresponding recent signature by a process involving a weighted averaging. A particular example of such an updating algorithm is given in the equation below:\n\n=(\u2212(\u00d7UpdateFactor))+(\u00d7UpdateFactor)\n\n\n","In this equation T is the target profile or signature, which in this case is the historic profile. S is the source profile which in this case is the recent profile. The term window size refers to the length of the time period to which the signature relates. For example, the source window size may be 1 hour and the target window size 10 hours. Once the target and source profiles have been obtained the update factor is calculated by dividing the source window size by the target window size. If the source window size is 1 hour and the target window size 10 hours then the update factor is 0.1. If no source or recent profile exists a new recent profile is created. If the number of attributes in a profile is 4 then example source and target profiles might be: S[,,,] and T[,,,]. T\u2032 which is the first attribute for the new target profile can then be calculated as follows: T\u2032=(5\u2212(5\u00d70.1))+(1\u00d70.1)=4.6. Similarly, the other attributes for the new target profile are calculated. This updating process can also be used for updating a recent profile with a dynamic profile. In both cases, once the updating process has been completed, the more recent profile is removed.","It is not essential to use the exact updating algorithm as described in the equations above. Modifications of this algorithm are possible; any type of weighted averaging process can be used.","A recent profile can be updated with a third signature or poll profile in the same way as for an historic and recent profile. Alternatively a different updating algorithm can be used for the poll to recent update. For example, one possible preferred update rule for poll to recent updating is given below: \n\n\nwhere p is the window size for the poll profile or third signature;\n\n","For a particular anomaly detector in which the method and apparatus for creating, storing and updating profiles or signatures is to be used then particular values for the time window sizes, the profile update rates and day-of-week dependencies must be chosen. Different values will be most suited to different applications. Some factors which need to be considered when choosing these values are given below:","Time Window Size","Setting the time window size too small may result in insufficient data to expect any reasonable response from the anomaly detector. Too small a time period may also result in the propagation of anomalous behaviour into the historical profile. If the recent time window size is too large the anomalous behaviour may go undetected for a longer period of time. In order to determine the best window sizes the effect of different sampling rates and the subsequent statistical representation of the characteristics of the behaviour being observed needs to be examined.","Profile Decay Rates","To determine the best profile decay rate an assessment of the importance of the historical behaviour relative to the recent behaviour need to be made.","Day-of-week Dependencies","The process of determining the window sizes and the decay rates should also take into account the impact of the day-of-week dependencies.","A wide range of applications are within the scope of the invention. For example, detecting telecommunications fraud; detecting credit card fraud; early detection of faults in a communications network and encryption key management. The invention applies to any situation in which anomalies need to be detected in a large amount of time variant data.","A wide range of other applications are within the scope of the invention. These include situations in which information about both a macroscopic pattern of behaviour and a microscopic pattern of behaviour must be stored. For example, in the area of banking, the detection of credit card fraud involves the storage of information about macroscopic and microscopic patterns of credit card use. Other areas include computer network security, trends analysis and many other fields.","Applications in which stored information must be updated are also within the scope of the invention. These applications include situations where an emerging temporal pattern must be accounted for. For example, the detection of credit card fraud, computer network security mechanisms, trends analysis and many other fields.","A wide range of other applications which involve the use of a neural network are within the scope of the invention. For example, in the area of banking the neural networks can be used for detecting credit card fraud and in this situation the ability to automatically retrain and monitor the performance of the neural network is vital. Also, in the area of computer network security neural networks can play an important role in detecting anomalous behaviour. Any service which involves sending messages over a telecommunications network, including entertainment services such as games or video distribution could also benefit from anomaly detection or trends analysis. Neural networks are used in many other fields as well as anomaly detection. For example, speech recognition, pattern recognition and trends analysis. In any of these applications the ability to retrain the neural network without intervention from the user can be important and these applications fall within the scope of the invention.","Kernel","Major Components","This appendix details the major software components within the fraud detector application domain including analysis and design details required.","The following is a list of passive objects identified as part of the analysis phase which will now be described in more detail using the object numbers in parentheses:\n\n","A representation of a client of a fraud detector. This controls the fraud detection and performance evaluation requests of the application.","C++ class name","FDFraudDetectionClient","Behaviour Description: CreateFraudKernel","Upon receiving the CreateFraudKernel creation event from the GUI terminator, this object will:\n\n","The fraud detection client is now ready to service other events.","Behaviour Description: UpdateEvaluationInterval","Upon receiving an UpdateEvaluationInterval event from the GUI terminator the client will modify the no_evaluation_period attribute of the Fraud Detector Specification object (28) with the new evaluation interval.","Behaviour Description: UpdateDetectionStartDate","Upon receiving an UpdateDetectionStartDate event from the GUI terminator the client will modify the detection_start attribute of the Fraud Detector Specification object (28) with the new date. The client will then stop and update the poll clock mechanism with the new detection time and restart the poll clock mechanism.","Behaviour Description: UpdatePerformanceThreshold","Upon receiving an UpdatePerformanceThreshold event from the GUI terminator the client will modify the evaluation_performance attribute of the Fraud Detector Specification object (28) with the new performance threshold.","Behaviour Description: AddKnowledge","Upon receiving an AddKnowledge event from the GUI terminator which contains a handle to a set of fraud candidate objects (11), the client will then create an AddKnowledgeRequest Object (23) with the associated fraud candidate set. On completion of the request the client will be informed by the AddKnowledgeRequest Object (23) what operations have been completed. These operations will be detailed by use of an enumeration parameter with an associated real value. The enumeration type contains the following:\n\n","If the enumeration value is \u201cAddKnowledge\u201d then the associated real value will be zero, else it will indicate the current performance of the ADE. These values will then be used to send a AddKnowledgeComplete event to GUI terminator.","Behaviour Description: SwitchEngine","Upon receiving a SwitchEngine event from the GUI terminator the client will interrogate the event parameter to establish if a switch is required. If a switch is required then a request will be made to the ADE to switch to a new anomaly detector. If a switch is not required then no request is made of the ADE. On completion of the switch process the client will send a SwitchComplete event to the GUI terminator.","Note: The client is required to control the persistence of the new ADE on completion.","Behaviour Description: PollTime","Upon receiving a PollTime event from the Process IO (clock poll mechanism) terminator which indicates that a detection poll period has been reached. The client will send a DetectionTakingPlace to the GUI terminator to indicate that the client cannot except any events until the operation has been completed. The client will create a fraud detection request object (16) which will control the detection process. On completion the client will send a DectionResultsReady event to GUI terminator. This event includes the time stamp used to create the results file.","Note: If the kernel is busy when a poll detection period is reached then when the client becomes available it will get the current time. If this time is less than the clock interval (plus some overhead time) then the detection is serviced else the poll detection has been missed and the kernel sends a DetectionMissed message back to the GUI to indicate that a poll detection has been missed.","Methods","FDFraudDetectionClient (FDFraudDetectorSpecification& fraud_spec)","\u02dcFDFraudDetectionClient( )","static FDFraudDetectionClient* CreateFraudKernel","(FDFraudDetectorSpecification& fraud_spec)","void UpdateEvaluationInterval(int evaluation_interval)","void UpdateDetectionStartDate(date detection_date)","void UpdatePerformanceThreshold(","float performance_threshold)","void AddKnowledge(FDFraudCandidateDataSet& data_set)","void SwitchEngine(Bool switch_required)","void PollTime( )","Assumptions",{"@attributes":{"id":"p-0194","num":"0000"},"ul":{"@attributes":{"id":"ul0055","list-style":"none"},"li":{"@attributes":{"id":"ul0055-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0056","list-style":"none"},"li":["The bridge will create fraud detector specification object on CreateFraudKernel.","The bridge will create fraud candidate date set object hierarchy on","AddKnowledge.","Retraining will always result in an improved performance of the ADE.","Retraining can follow a retraining without a SwitchEngine event being received.\n\nOwnership\n"]}}}},"FDFraudDetectorSpecification","FDAddKnowledgeRequest","FDFraudDetectionRequest","Read Accessors","RWBoolean IsAnomalyDetectorCreated( ) const;","FDPresentationDataSet* GetPresentationDataSet( ) const;","RWBoolean GetADSwitched( ) const;","Write Accessors","void SetADSwitched(RWBoolean state);","Interpret Call Detall Record (15)","Description","The transformation that is required in order to interpret a comma separated CDR into a CDR.","Note: Not implemented, absorbed into Validate Request (8).","Add Knowledge Request (23)","Description","A request to add knowledge of fraud candidates.","C++ class name","FDAddKnowledgeRequest","Behaviour Description","Upon creation the add knowledge request object (23) is passed a fraud detection data set as a parameter. The object will:\n\n","FDAddKnowledgeRequest(","FDFraudCandidateDataSet& fraud_data_set,","String new_knowledge_filename)","\u02dcFDAddKnowledgeRequest( )","Assumptions","Update Historic Profile Request (24) will always be actioned after an Add Knowledge Request (23).","Ownership","FDUpdateHistRequest","FDPerformanceEvaluationRequest","Read Accessors","No public read access methods are required by the object.","Write Accessors","No public write access methods are required by the object","Update Historic Profile Request (24)","Description","A request to update historic profiles.","C++ class name","FDUpdateHistRequest","Behaviour Description","Upon creation the update historic profile request is passed a fraud detection data set as a parameter. This object will:\n\n","FDUpdateHistRequest(","FDFraudCandidateDataSet& fraud_data_set,","String historic\u2014profile_filename)","\u02dcFDUpdateHistRequest( )","Assumptions","None.","Ownership","Read Accessors","No public read access methods are required by the object.","Write Accessors","No public write access methods are required by the object.","Performance Evaluation Request (29)","Description","A request to evaluate the performance of the fraud detector application.","C++ class name","FDPerformanceEvaluationRequest","Behaviour Description","No parameters are sent on construction of this object. This object will:\n\n","FDPerformanceEvaluationRequest( )","\u02dcFDPerformanceEvaluation Request( )","Assumptions","None.","Ownership","Read Accessors","No public read access methods are required by the object.","Write Accessors","No public write access methods are required by the object","Fraud Detection Request (16)","Description","A request to perform a detection of fraud on a presentation data set. The resultant fraud candidates are contained in the associated candidate data set.","C++ class name","FDFraudDetectionRequest","Behaviour Description","Upon creation the fraud detection request is passed a presentation data set as a parameter. This object will:\n\n","while(not end_of_file)","{","Read(next_line_of_file)","cdr=CreateCDR(next_line_of_file)","if(account_no !=cdr.account_no)","poll_profile=CreatePollProfile(cdr)","else","poll_profile=AccumulatePollProfile(cdr)","account_no=cdr.account_no","DecayRecent(poll_profile)","DeletePollProtile(poll_profile)","}","Note: Assumption that the CDR file is sorted by account number. Decay profile will provide a binary search technique to locate the recent profile.","Methods","FDFraudDetectionRequest(","FDPresentationDataSet& presentation_data_set","FDPollToRecentProfileDecay& profile_decay","String results_filename,","String csv_filename","Time poll_detection_period","Time recent_profile_period)","\u02dcFDFraudDetectionRequest( )","Assumptions","None.","Ownership","Read Accessors","No public read access methods are required by the object.","Write Accessors","No public write access methods are required by the object","Poll To Recent Profile Decay (20)","Description","The decay transform for decaying a poll period profile into a recent profile.","C++ class name","FDPollToRecentProfileDecay","Behaviour Description","Upon creation this object is given recent profile vectors object (4). This object will:\n\n","FDPollToRecentProfileDecay(","RWTPtrDlist<FDRecentProfileVector>& recent_profile,","Time poll_detection_period,","Time recent_profile_period)","\u02dcFDPollToRecentProfileDecay( )","void DecayProfile(FDProfileVector& poll_profile)","Assumptions","None.","Updating profiles algorithm\n\n\u2032=(\u2212(\u00d7UpdateFactor))+(\u00d7UpdateFactor)\n","For all i Where T is the target profile (e.g. recent profile) and S is the source profile (e.g. poll detection period profile.) \n\n\nRead Accessors\n","No public read access methods are required by the passive object.","Write Accessors","No public write access methods are required by the passive object","CDR To Profile Tranform (13)","Description","A request to perform a detection of fraud on a presentation data set. The resultant fraud candidates are contained in the associated candidate data set.","C++ class name","FDCDRProfileTranform","Behaviour Description","Upon creation CDR profile transform. This object will:\n\n","FDCDRProfileTranform( String csv_filename,","int poll_detection_period)","\u02dcFDCDRProfileTranform( )","Assumptions","Operates on an ordered input file.","Ownership","FDProfileVector (Poll detection profiles only).","Read Accessors","No public read access methods are required by the passive object.","Write Accessors","No public write access methods are required by the passive object","Call Detail Record (12)","Description","A software representation of a telecommunication call detail record.","C++ class name","FDCallDetailRecord","Methods","FDCallDetailRecord(String csv_filename)","\u02dcFDCallDetailRecord( )","FDCallDetailRecord ReadCallDetailRecord( )","Assumptions","The source CDR file is ordered by account number.","Ownership","Read Accessors","Write Accessors","Unvalidated Fraud Candidates (25)","Description","An unvalidated association of a customers recent profile and the results of a detection process.","C++ class name","FDUnvalidatedFraudCandidates","Inheritance","FDFraudCandidate","Methods","FDUnvalidatedFraudCandidates(","FDProfileVector& recent_profile,","ADCandidatePresentation& candidate_presentation)","\u02dcFDUnvalidatedFraudCandidates( )","Assumptions","None.","Ownership","None.","Read Accessors","No public read access methods are required by the passive object.","Write Accessors","No public write access methods are required by the passive object","Fraud Detector Specification (28)","Description","The specification of the fraud detector application.","C++ class name","FDFraudDetectorSpecification","Methods","FDFraudDetectorSpecification(String Default_results_filename","String csv_filename","String recent_profile_filename","String historical_profile_filename","String ade_spec_filename","Date detection_start","int evaluation_interval","int evaluation_counter","int performance_threshold","int recent_window_size","int historical_window_size","int detection_time_interval","int input_size","int recent_size)","\u02dcFDFraudDetectorSpecification( )","Assumptions","None.","Ownership","None.","Read Accessors","StringGetDefaultResultsFilename(","default_results_filename)","String GetCSVFilename(csv_filename)","String GetRecentProfileFilename(","recent_profile_filename)","String GetHistoricalProfileFilename(","historical_profile filename)","String GetADESpecFilename (ade_spec_filename","Date GetDetectionStart(detection_start)","int GetEvaluationInterval(evaluation_interval)","int GetEvaluationCounter(evaluation_counter)","int GetPerformanceThreshold(performance_threshold)","int GetHistoricalWindowSize(historical_window_size)","int GetRecentWindowSize(recent_window_size)","int GetDetectionTimeInterval(detection_time_interval)","int GetinputSize(input_size)","int GetRecentSize(recent_size)","Write Accessors","void SetDefaultResultsFilename(String default_results_filename)","void SetCSVFilename(String csv_filename)","void SetRecentProfileFilename(String recent_profile_filename)","void SetHistoricalProfileFilename(String historical_profile_filename)","void SetADESpecFilename (String ade_spec_filename","void SetDetectionStart(Date detection_start)","void SetEvaluationInterval(int evaluation_interval)","void SetEvaluationCounter(int evaluation_counter)","void SetPerformanceThreshold (int performance_threshold)","void SetHistoricalWindowSize(int historical_window_size)","void SetRecentWindowSize(int recent_window_size)","void SetDetectionTimeInterval(int detection_time_interval)","void SetinputSize(int input_size)","void SetRecentSize(int recent_size)","Validate Request (8)","Description","A request to create a validated set of fraud candidates.","Note: Not implemented, absorbed into Fraud Detection Request (16).","Candidate Data Set (18)","Description","A set of candidate presentations.","C++ class name","FDCandidateDataSet","Methods","FDCandidateDataSet(","RWTPtrDlist<ADCandidatePresentation>","&candidate_presentation_ids)","\u02dcFDCandidateDataSet( )","Assumptions","Ownership","Read Accessors","int GetNumberOfPresentations( ) const;","Write Accessors","void SetNumberOfPresentations(int number_of_presentations);","Validated Fraud Candidate (22)","Description","An association of a customers recent profile and the validated results of a detection process.","C++ class name","FDValidatedFraudCandidate","Inheritance","FDFraudCandidate","Methods","FDValidatedFraudCandidate(","FDProfileVector& recent_profile,","NNExampleDataPresentation& example_presentation);","\u02dcFDValidatedFraudCandidate( )","Enumeration Types","enum ValidationStatus","{","UNVALIDATED,","CORRECT_FRAUD,","INCORRECT_FRAUD,","CORRECT_NONFRAUD,","INCORRECT_NON_FRAUD","};","Assumptions","None.","Ownership","Read Accessors","ValidationStatus GetValidationCategory( ) const;","Write Accessors","void SetValidationCategory(ValidationStatus","validation_category);","Fraud Candidate (11)","Description","An association of a customers recent profile and the results of a detection process, (either validated or unvalidated).","C++ class name","FDFraudCandidate","Methods","FDFraudCandidate(FDProfileVector& recent_profile)","\u02dcFDFraudCandidate( )","Assumptions","Ownership","Read Accessors","No public read access methods are required by the passive object.","Write Accessors","No public write access methods are required by the passive object","Presentation Data Set (17)","Description","A set of profile data presentations.","C++ class name","FDPresentationDataSet","Methods","FDPresentationDataSet(FDProfileDataPresentation&","profile_data_presentation_id)","FDPresentationDataSet(","RWTPtrDlist<FDProfileDataPresentation>&","profile_data_presentation_ids)","\u02dcFDPresentationDataSet( )","Assumptions","Ownership","Read Accessors","int GetNumberOfPresentations( ) const;","Write Accessors","void SetNumberOfPresentations(int number_of_presentations);","Fraud Candidate Data Set (21)","Description","A container of fraud candidates.","C++ class name","FDFraudCandidateDataSet","Methods","FDFraudCandidateDataSet( )","\u02dcFDFraudCandidateDataSet( )","Assumptions","Ownership","Read Accessors","int GetNumberOfPresentations( ) const;","Write Accessors","void SetNumberOfPresentations(int number_of_presentations);","Profile Data Presentation (7)","Description","Combination of a historic and a recent profile data vector.","C++ class name","FDProfileDataPresentation","Behaviour Description","Each recent profile is matched with it respective historical profiles and sent to the ADE. This representation is used for both detection (object ) and profile decay (object ).","Methods","FDProfileDataPresentation(","FDProfileVector& recent_profile,","FDProfileVector historical_profile)","FDProfileDataPresentation(","FDProfileVector& recent_profile,","RWTPtrDlist<FDProfileVector>& historical_profile)","\u02dcFDProfileDataPresentation( )","Assumptions","None.","Ownership","Read Accessors","Bool GetProfileModified( ) const;","Write Accessors","void SetProfileModified(Bool profile_modified);","Poll Profile Vector (4)","Description","Describes the structure of a profile data vector.","C++ class name","FDPollProfileVector","Inheritance","NNVector","Methods","FDPollProfileVector(String account_number,","FDCallDetailRecord& call_detail_record)","\u02dcFDPollProfileVector( )","Assumptions","Ownership","Read Accessors","String GetAccountNumber( ) const;","Write Accessors","void SetAccountNumber(String account_number);","Recent Profile Vector (34)","Description","Describes the structure of a recent profile data vector.","C++ class name","FDRecentProfileVector","Inheritance","ADRecentProfileVector","Behaviour Description",{"@attributes":{"id":"p-0424","num":"0000"},"ul":{"@attributes":{"id":"ul0069","list-style":"none"},"li":{"@attributes":{"id":"ul0069-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0070","list-style":"none"},"li":"After the poll profiles have been used to update the recent profile, the updated recent profiles then needs to be persisted to the recent profile file using the persistence mechanism.\n\nMethods\n"}}}},"FDRecentProfileVector(String account_number,","NNVector& data_vector)","\u02dcFDRecentProfileVector( )","Persist(String recent_profile_filename)","Assumptions","Ownership","Read Accessors","String GetAccountNumber( ) const;","Write Accessors","void SetAccountNumber(String account_number);","Historic Profile Vector (33)","Description","Describes the structure of a profile data vector.","C++ class name","FDHistoricProfileVector","Inheritance","ADHistoricalProfileVector","Methods","FDHistoricProfileVector(String account_number,","NNVector& data_vector)","\u02dcFDHistoricProfileVector( )","Assumptions","Ownership","Read Accessors","String GetAccountNumber( ) const;","Write Accessors","void SetAccountNumber(String account_number);","Persistence","Overview Tools.h++ version 7.0 Users Guide, 1996, Rogue Wave Software, defines that a object can have one of four levels of persistence:",{"@attributes":{"id":"p-0439","num":"0000"},"ul":{"@attributes":{"id":"ul0071","list-style":"none"},"li":{"@attributes":{"id":"ul0071-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0072","list-style":"none"},"li":["No persistence. There is no mechanism for storage and retrieval of the object.","Simple persistence. A level of persistence that provides storage and retrieval of individual objects to and from a stream or file. Simple persistence does not preserve pointer relationships among the persisted objects.","Isomorphic persistence. A level of persistence that preserves the pointer relationships among the persisted objects.","Polymorphic persistence. The highest level of persistence. Polymorphic persistence preserves pointer relationships among the persisted objects and allows the restoring process to restore an object without prior knowledge of that object's type."]}}}},"This appendix provides information about the use of Isomorphic persistence through descriptions, examples, and procedures for designing persistent classes. To implement other levels of persistence it is recommended that the reader consult the relevant Tools.h++ manual pages.","Persistence Mechanism","Isomorphic persistence is the storage and retrieval of objects to and from a stream such that the pointer relationships between the objects are preserved. If there are no pointer relationships, isomorphic persistence effectively saves and restores objects the same way as simple persistence. When a collection is isomorphically persisted, all objects within that collection are assumed to have the same type.","The isomorphic persistence mechanism uses a table to keep track of pointers it has saved. When the isomorphic persistence mechanism encounters a pointer to an unsaved object, it copies the object data, saves that object data NOT the pointer to the stream, then keeps track of the pointer in the save table. If the isomorphic persistence mechanism later encounters a pointer to the same object, instead of copying and saving the object data, the mechanism saves the save table's reference to the pointer.","When the isomorphic persistence mechanism restores pointers to objects from the stream, the mechanism uses a restore table to reverse the process. When the isomorphic persistence mechanism encounters a pointer to an unrestored object, it recreates the object with data from the stream, then changes the restored pointer to point to the recreated object. The mechanism keeps track of the pointer in the restore table. If the isomorphic persistence mechanism later encounters a reference to an already-restored pointer, then the mechanism looks up the reference in the restore table, and updates the restored pointer to point to the object referred to in the table.","Class Requirements For Persistence","To create a class that supports isomorphic persistence the class must meet the following requirements.\n\n","PClass( ); \/\/ default constructor","PClass(T& t); \/\/ copy constructor\n\n","PClass& operator=(const PClass& pc); \/\/ member function","PClass& operator=(PClass& Ihs, const PClass& rhs); \/\/ global function\n\n","To create an isomorphically persistent class or to add isomorphic persistence to an existing class, follow these steps:\n\n","#include <rw\/edefs.h>","RWDECLARE_PERSISTABLE(YourClass)\n\n","#include <rw\/epersist.h>","RWDEFINE_PERSISTABLE(YourClass)\n\n","For non-templatized classes, define the following functions:","void rwSaveGuts(RWFile& f, const YourClass& t){\/*_*\/}","void rwSaveGuts(RWvostream& s, const YourClass& t) {\/*_*\/}","void rwRestoreGuts(RWFile& f, YourClass& t) {\/*_*\/}","void rwRestoreGuts(RWvistream& s, YourClass& t) {\/*_*\/}","For templatized classes with a single template parameter T, define the following functions:","template<class T> void","rwSaveGuts(RWFile& f, const YourClass<T>& t){\/*_*\/}","template<class T> void","rwSaveGuts(RWvostream& s, const YourClass<T>& t) {\/*_*\/}","template<class T> void","rwRestoreGuts(RWFile& f, YourClass<T>& t) {\/*_*\/}","template<class T>void","rwRestoreGuts(RWvistream& s, YourClass<T>& t) {\/*_*\/}","For templatized classes with more than one template parameter, define rwRestoreGuts and rwSaveGuts with the appropriate number of template parameters.","Function rwSaveGuts saves the state of each class member necessary persistence to an RWvostream or an RWFile. If the members of your class can be persisted and if the necessary class members are accessible to rwSaveGuts, you can use operator<< to save the class members.","Function rwRestoreGuts restores the state of each class member necessary for persistence from an RWvistream or an RWFile. Provided that the members of your class are types that can be persisted, and provided that the members of your class are accessible to rwRestoreGuts, you can use operator>> to restore the class members.","Example of a Persistent Class","PClass Header File",{"@attributes":{"id":"p-0470","num":"0000"},"ul":{"@attributes":{"id":"ul0082","list-style":"none"},"li":["#include <rw\/cstring.h>","#include <rw\/edefs.h>","#include <rw\/rwfile.h>","#include <rw\/epersist.h>","class PClass","{\n    \n    ","PClass::\u02dcPClass( )","{","}","RWDEFINE_PERSISTABLE(PClass)","void rwRestoreGuts(RWvistream& is, PClass& obj)","{\n    \n    ","void rwRestoreGuts(RWFile& file, PClass& obj)\n    \n    "]}},"if (ptr)\n\n","cout << \u201cpersist_class (after restore):\u201d << endI\n\n","The persistence mechanism is a useful quality, but requires care in some areas. Here are a few things to look out for when using persist classes.","1. Always Save an Object by Value before Saving the Identical Object by Pointer.","In the case of both isomorphic and polymorphic persistence of objects, never stream out an object by pointer before streaming out the identical object by value. Whenever designing a class that contains a value and a pointer to that value, the saveGuts and restoreGuts member functions for that class should always save or restore the value then the pointer.","2. Don't Save Distinct Objects with the Same Address.","Be careful not to isomorphically save distinct objects that may have the same address. The internal tables that are used in isomorphic and polymorphic persistence use the address of an object to determine whether or not an object has already been saved.","3. Don't Use Sorted RWCollections to Store Heterogeneous RWCollectables.","When you have more than one different type of RWCollectable stored in an RWCollection, you can't use a sorted RWCollection. For example, this means that if you plan to store RWCollectableStrings and RWCollectableDates in the same RWCollection, you can't store them in a sorted RWCollection such as RWBtree. The sorted RWCollections are RWBinaryTree, RWBtree, RWBTreeDictionary, and RWSortedVector. The reason for this restriction is that the comparison functions for sorted RWCollections expect that the objects to be compared will have the same type.","4. Define All RWCollectables That Will Be Restored.","These declarations are of particular concern when you save an RWCollectable in a collection, then attempt to take advantage of polymorphic persistence by restoring the collection in a different program, without using the RWCollectable that you saved. If you don't declare the appropriate variables, during the restore attempt the RWFactory will throw an RW_NOCREATE exception for some RWCollectable class ID that you know exists. The RWFactory won't throw an RW_NOCREATE exception when you declare variables of all the RWCollectables that could be polymorphically restored.","The problem occurs because the compiler's linker only links the code that RWFactory needs to create the missing RWCollectable when that RWCollectable is specifically mentioned in your code. Declaring the missing RWCollectables gives the linker the information it needs to link the appropriate code needed by RWFactory."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will be further described, by way of example, with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0034","num":"0055"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0035","num":"0056"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0036","num":"0057"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0037","num":"0058"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0038","num":"0059"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0039","num":"0060"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0040","num":"0061"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0041","num":"0062"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0042","num":"0063"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0043","num":"0064"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0044","num":"0065"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0045","num":"0066"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0046","num":"0067"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0047","num":"0068"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0048","num":"0069"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0049","num":"0070"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0050","num":"0071"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0051","num":"0072"},"figref":"FIG. 18"}]},"DETDESC":[{},{}]}
