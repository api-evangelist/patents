---
title: Method and system of monitoring, sensor validation and predictive fault analysis
abstract: The present invention provides an improved method and system for real-time monitoring, validation, optimization and predictive fault analysis in a process control system. The invention monitors process operations by continuously analyzing sensor measurements and providing predictive alarms using models of normal process operation and statistical parameters corresponding to normal process data, and generating secondary residual process models. The invention allows for the creation of a fault analyzer directly from linearly independent models of normal process operation, and provides for automatic generation from such process models of linearly dependent process models. Fuzzy logic is used in various fault situations to compute certainty factors to identify faults and/or validate underlying assumptions. In one aspect, the invention includes a real-time sensor data communications bridge module; a state transition logic module; a sensor validation and predictive fault analysis module; and a statistical process control module; wherein each of the modules operates simultaneously.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07451003&OS=07451003&RS=07451003
owner: Falconeer Technologies LLC
number: 07451003
owner_city: Williamsville
owner_country: US
publication_date: 20040304
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates generally to fault analysis and, more particularly, to a method and system for real-time monitoring, sensor validation, optimization and predictive fault analysis in a process control system.","Process control systems for industrial applications have existed in many forms for a number of years. Several products, methods and systems have been developed to monitor and validate sensors in such systems and diagnose faults which might occur in such systems. Standard fault management products are based on creating predictive models using multivariate statistics and\/or abnormal operation information. Such models, including neural networks and other complex models, are often difficult for an end-user (such as a manufacturing engineer or other operator) to understand, maintain or even trust. In addition, such models may not be scalable to real fault conditions and are only as good as the set of data provided, which by nature does not encompass all process operating conditions. Therefore, such models may not be robust enough to reliably predict or identify all abnormal or non-steady-state conditions, i.e., the reason for a fault management tool in the first place. Also, existing diagnostic methods and systems based on boolean logic may suffer from \u201cdiagnostic instability.\u201d In addition, the cost of prior art systems such as statistical models, expert systems, neural networks, smart sensors and redundant sensors may be very high.","Several methods and software systems have been developed to monitor process control systems and perform sensor validation. For example, U.S. Pat. No. 6,246,972 (Klimasauskas) discloses an analyzer for modeling and optimizing maintenance operation. U.S. Pat. No. 6,356,857 (Qin et al.) discloses a sensor validation apparatus and method, but not a fault analyzer. Other patents, such as U.S. Pat. No. 5,987,398 (Halverson et al.), disclose the use of statistical process control in the context of a process control system. Other examples of sensor validation, fault analyzer or faulty sensor identification patents include U.S. Pat. No. 6,594,620 (Qin et al.), U.S. Pat. No. 5,442,562 (Hopkins et al.) and U.S. Pat. No. 5,949,678 (Wold et al.). None of the foregoing patents utilizes the method of the present invention, which has significant advantages, as described below. Furthermore, no prior art system provides for simultaneous real-time sensor data collection, sensor validation and predictive fault analysis, and statistical process control.","There is a need, therefore, for an improved method and system of monitoring, validation and predictive fault analysis for process control systems, such as those in chemical plants, which overcomes these deficiencies; includes an evaluation of process models derived from normal data and using real-time measured process data; and provides, among other things, continuous and direct analysis which alerts end-users to potential underlying process problems.","The present invention provides an improved method and system of simultaneous real-time monitoring, validation, optimization and predictive fault analysis in a process control system. In certain aspects, the present invention monitors current process operations by continuously analyzing process sensor measurements and alerting process operators and other end-users when appropriate. The system of the present invention goes beyond typical process alarm systems, which only alert at extreme conditions after failure or fault have occurred. The invention provides predictive or pre-emptive alerts (also referred to herein as alarms) by using linear and non-linear models of normal process operation, also referred to as primary process models, and statistical parameters corresponding to normal process data, and generating secondary residual process models, which may be automatically regenerated as needed. The invention allows for the creation of a fault analyzer directly from linearly independent models of normal process operation, which greatly simplifies implementation and maintenance. In addition, the invention provides for automatic generation from such linearly independent process models of linearly dependent process models, referred to herein as secondary residual process models, which no longer depend upon common eliminated variable(s), and which provide important information as to the state of a process control system. In addition, fuzzy logic is used in various fault situations to compute certainty factors to identify faults and\/or validate underlying assumptions. In this regard, fuzzy logic diagnostic rules are derived automatically and may be regenerated each time they are used. The certainty factors also eliminate \u201cdiagnostic instability\u201d associated with boolean based systems or methods.","The system and method of the present invention also accounts for both measured process variables, i.e., observed, and the correctness of assumed values of unmeasured variables, i.e., unobserved. Both measured and unmeasured variables, in certain aspects, are explicitly included in the process models representing the associated system. In some aspects of the invention, statistical process control (\u201cSPC\u201d) charting techniques are used to determine if sensors are in control. Such SPC techniques include exponentially weighted moving averages (\u201cEWMA\u201d) of sensor readings, i.e. real-time sensor data. In one aspect, historical data is regressed to determine normal offsets and variances of the process models being used, and weighting factors and normal variability for the EWMA calculations of the sensors monitored. Once such values are determined, the invention continuously monitors real-time process sensor measurements and determines their status and the underlying status of the process components themselves. \u201cIntelligent alarms\u201d allow process operators to more effectively control the operation of the associated process control system.","In one aspect, the method of sensor validation and fault analysis comprises the following steps: generating a plurality of primary residual process models derived from the control system's primary process models, the normal process data, and one or more of the calculated statistical parameters; measuring real-time sensor data; computing primary residual values of the primary residual process models corresponding to such real-time sensor data; comparing the primary residual values to expected values; and computing certainty factor(s) for possible fault(s) using fuzzy logic. Other aspects of the invention include calculating statistical parameters corresponding to normal process data in a process control system.","Other aspects of the invention include one or more of these steps: computing certainty factor(s) for each of the primary residual values. Another aspect includes the measuring of normal process data. In one aspect, the fuzzy logic used to compute certainty factors is defined in a diagnostic rule as follows:\n\nFAULT-IS-PRESENT=SOME (evidence-for-fault) AND ALL (neutral-evidence) AND NOT (SOME (evidence-against-fault))\n","The sets described in this diagnostic rule are determined, in certain aspects of the invention, as follows: determining the direction(s) of the deviation(s), if any, of the primary and\/or secondary residual values from expected values and determining evidence-for-fault and evidence-against-fault by comparing the direction of deviation with an expected direction consistent with a fault; and determining neutral-evidence from primary and\/or secondary residual process models which do not depend upon the relevant process variable by comparing the magnitude of a deviation to zero. The diagnostic rule may be regenerated each time it is used. In another aspect, the invention provides for generating one or more secondary residual process models, wherein each of said secondary residual process models is derived from two primary residual process models having at least one common process variable. Other aspects of the invention may also include: computing secondary residual values of the secondary residual process models corresponding to real-time sensor data, and comparing the secondary residual values to expected values. The invention may include computing a certainty factor corresponding to each of the secondary residual values and may include computing a certainty factor for a possible fault as a function of one or more of the secondary residual values using fuzzy logic. In one aspect, this includes determining neutral-evidence from one or more of the secondary residual process models which do not relate to relevant process variables. In certain aspects, the statistical parameters described above comprise a mean and a standard deviation. In other aspects, the primary and\/or secondary residual process models are functions of both a measured process variable and\/or an unmeasured process variable, and are automatically generated. They may be automatically regenerated. In other aspects, first partial derivatives and\/or second partial derivatives of the primary and\/or secondary residual process models are computed. The invention provides for reporting certainty factors if they exceed a predetermined threshhold, and displaying certainty factors on a monitor. Another aspect of the invention includes computing a compressed value. Other aspects include prediction, detection and analysis of multiple faults. In other aspects of the invention, the generation of a plurality of primary residual models is not undertaken. In other aspects, the invention includes a computer-readable medium having computer-executable instructions for performing the foregoing.","Another aspect of the invention includes the following steps: generating a plurality of primary residual process models derived from the primary process models, the normal process data, and one or more statistical parameters corresponding to the normal process data; generating one or more secondary residual process models, wherein each of the secondary residual process models is derived from two primary residual process models having at least one common variable; and using one or more of the primary residual process models and one or more of the secondary residual process models to predict a possible fault. Another aspect includes these steps: generating a plurality of primary residual process models derived from the primary process models, the normal process data, and one or more statistical parameters corresponding to the normal process data; translating the primary residual process models into pseudo-code; measuring real-time sensor data; executing the pseudo-code to compute primary residual values corresponding to the real-time sensor data; comparing the primary residual values to expected values; and computing a certainty factor for a possible fault by executing said pseudo-code. In certain aspects, the pseudo-code uses fuzzy logic, which may be defined in a diagnostic rule as above. Other steps include: generating pseudo-code for computing a certainty factor; computing a certainty factor corresponding to each primary residual value; translating secondary residual process models into pseudo-code; executing the pseudo-code to compute secondary residual values; and computing a certainty factor using fuzzy logic.","The monitoring, validation and analysis system of the present invention includes a real-time sensor data communication bridge module; a state transition logic module; and a sensor validation and fault analysis module; wherein each of these modules operates simultaneously. The system may also include a statistical process control module, an operator display module, a database module and\/or an alarm system module and other modules. In another aspect, the invention includes a master module which coordinates the operation of one or more of the other modules. The system may also include a model compiler and\/or fault analyzer. The process control system of this invention includes such monitoring, validation and analysis system. The phrase \u201cmodule\u201d is not limited to a unit of code in the modular programming style, but may be construed more generally to mean a component of the invention.","Among other things, the invention significantly reduces the amount of computer code which users must maintain, by up to two orders of magnitude. In one embodiment, the invention requires only that 1000 to 2000 database fields be specified for a typical process control system. The invention may be implemented through pseudo-code, or native code such as Visual Basic, or other instructions. In addition to single fault analysis and data validation, the invention performs multiple fault analysis (which would require more than an order of magnitude more code in prior art systems) and performs SPC on all the controlled and uncontrolled sensor measurements. It is also trivial to add\/delete either more process variables or models of normal process operation and recompile the application to include such changes. In one embodiment, the only items maintained are various process variables (both measured and unmeasured) and models of normal process operation directly describing relationships between those variables. This greatly simplifies the creation and maintenance of software programs or code because, among other things, the means of creating all possible secondary models and all the diagnostic\/inferential reasoning is contained as the implemented underlying invention, which does not change for different applications.","The general object of the invention is to provide an improved method and system to predict, detect and correct system faults or failures before they cause operating problems and losses. Another object is to provide a sensor validation and predictive fault analysis system which is simple to understand, maintain and operate. Another object is to provide a system and method which diagnoses multiple fault situations. Another object is to provide a continuous, real-time sensor validation and fault analysis method and system which results in reduced costs and improved safety, reliability and operations. The invention also results in less code, which is more adaptable to process conditions and changes. Yet another object is to provide a system which improves quality control and provides for process optimization. These and other objects and advantages will become apparent from the foregoing and ongoing written specification, the accompanying drawings and the appended claims.","At the outset, it should be clearly understood that like reference numerals are intended to identify the same elements, parts or portions consistently throughout the several drawing figures, as such elements, parts or portions may be further described or explained by the entire written specification, of which this detailed description is an integral part. Unless otherwise indicated, the drawings are intended to be read together with the specification, and are to be considered a portion of the entire written description of this invention.","The present invention provides an improved system and method for simultaneous real-time monitoring, sensor validation, optimization and\/or predictive fault analysis in a process control system. A basic approach to sensor validation and fault analysis in the present invention is an examination of relationships between sensor values and the inference of possible sensor failures, or failures in other parts of a process, by, among other things, determining which relationships differ from expectations. A process (such as in a chemical process plant) has a number of process variables, some of which are measured by sensors (measured variables), such as temperatures, pressures and flows, and some of which are not (unmeasured variables), such as leaks or component concentrations. Unmeasured variables may be difficult to measure, or uneconomical to measure since they may reliably be expected to have known values.","Process engineers design plants and processes such that certain relationships hold between such process variables when a process is in operation. Before the present invention is implemented, a plant engineer or other person typically provides a model or formula for computing a residual which assumes perfect measurements and perfect modeling of the process. For example, liquids may flow in and out of a tank through pipes. Three process variables in such a process might be flow-in, flow-out, and level-in-tank. In such a case, one expected relationship (if the tank or pipes are not leaking) is:\n\nflow-out=flow-in\u2212(level-in-tank)\/\n\nwhere k is a constant that depends on the dimensions of the tank. Such an equation is referred to as a primary process model. To measure the extent to which this relationship holds, a residual process model may be generated by subtracting one side of the equation from the other side of the equation. The residual process model corresponding to the above equation would therefore be:\n\nflow-residual=flow-out\u2212flow-in+(level-in-tank)\/\n","More generally, such a residual process model may be represented generically as follows:\n\nresidual=\u0192(x,x, . . . , x)\n\nwhere x,x, . . . , xare process variables, i.e., parameters that define the state of a process at any given moment, and \u0192is a function of those parameters that computes a balance of energy or mass in a control volume.\n","Because the sensors that measure the three process variables in the tank example may not be 100 percent accurate or provide exact readings; because the process models may not be perfect models of the relationship between the process variables; and because random perturbations may occur, it is empirically observed that flow-residual is not always zero, though it is usually close to zero when the process is operating normally. The mathematical model of sensor validation and predictive fault analysis (\u201cSV&PFA\u201d) used in the present invention requires that all residuals be zero, on average, when a monitored process is normal. Therefore, a calculation is made from historical plant data of the average value of each residual (flow-residual in this example) and that average value is subtracted from the corresponding residual process model.","In practice, then, each function \u0192, above, will behave like a statistical random variable having a mean value \u03b2 and a standard deviation \u03c3. The mean value \u03b2 is modeled as \u03b2\u03c1 and the standard deviation \u03c3 is modeled as \u03c3\u03c1, where \u03b2and \u03c3are constants and \u03c1 is either 1 or a process variable that is the definitive measure of the production level of the process being monitored. Usually, \u03b2 is just a constant value, but sometimes it is the product of a constant times a process variable whose value determines the level of production at which the process is operating.","In the present invention, the generic residual process model above is replaced with a primary residual process model defined as:\n\n()\u2212\u03b2\n\nwhich has a mean value of zero and a standard deviation of \u03c3. The equation defining r is referred to herein as a primary residual process model. The invention examines the values of such (adjusted) residual process models and, among other things, infers from the pattern of deviations from zero which sensors are faulty or which other parts of the process may be faulty.\n","In more generic terms, if a plant engineer provides the formula \u0192( . . . ) as the formula for a residual process model under ideal conditions, and the formula mean for the average of \u0192( . . . ) over time based on historical plant data, and the formula sigma for the standard deviation of \u0192( . . . ) over time, a software program that embodies the present invention generates the primary residual process model:\n\n( . . . )\u2212mean\n\nwhich has the property that the average of r is expected to be zero. These are preferred forms for these formulas (the constants are put in a special array), but any formula that can be expressed in the mathematical language of a software program is allowed. The formula sigma is not used in the primary residual process models, but is used to calculate certainty factors, as discussed below.\n","Primary residual process models are distinguished from certain linearly dependent residual process models generated by the present invention. Such additional models are referred herein to as secondary residual process models, and are computed as follows: Suppose that rand rare primary residual process models and both contain a common variable v. If both residual models are linear functions of v, they may be combined algebraically to remove the terms containing v. In this invention, such residual models are determined to be linear functions of v by symbolically computing their first and second partial derivatives with respect to v. If their first partial derivatives are not uniformly zero, but their second partial derivatives are uniformly zero (that is, they are zero no matter what the values of the process variables are), then they are linear with respect to v. The secondary residual process model computed in this example is:\n\n=(\u2202r\/\u2202)\u2212(\u2202\/\u2202)\n","The standard deviation computed for this secondary residual process model is:\n\nsigma=\u221a{square root over (((\u2202\/\u2202)sigma)+((\u2202\/\u2202)sigma))}{square root over (((\u2202\/\u2202)sigma)+((\u2202\/\u2202)sigma))}\n\nwhere sigmaand sigmaare the standard deviations of residuals rand r, respectively.\n","Referring now to , which is a flowchart illustrating the generation and processing of residual process models and data, the first step  is the creation of primary process models by a plant engineer or other person, as described above. The next step  is the calculation of values of constant parameters needed by such primary process models to estimate corresponding means and standard deviations from normal process data. In one embodiment, this calculation requires analysis of approximately 3 to 6 months of normal process data. Steps  and  may be performed prior to the method of the present invention. Next, such means and standard deviations are added to a model file for future use by the fault analyzer of the present invention . The next step  involves creation of primary residual process models and their conversion into instructions, referred to as pseudo-code, for computing residual values and for subtracting a mean formula. Such instructions may also take the form of native code, such as Visual Basic, in this Figure and elsewhere. The next step  is the computation of first and second partial derivatives of the primary residual process models, and the storage of pseudo-code in the model file. Next, pseudo-code is generated for computing secondary residual process models and their first partial derivatives, which is stored in the model file . In the next step , pseudo-code is generated for computing certainty factors for primary and secondary residual values and stored in the model file. Next, in step , pseudo-code is generated for computing certainty factors for all possible single faults, which are stored in the model file. Mask arrays are then computed and stored in the model file . As used herein, \u201cmask arrays\u201d include residual-to-variable relevance tables or information. Finally, in , other relevant information is stored in the model file that will be needed by the fault analyzer . This may include array sizes to be dynamically allocated and filled with data from a model file and\/or the number of temporary variables generated to store intermediate results computed in prior steps.","A preferred embodiment of the present invention computes certainty factors to identify faults and\/or validate underlying assumptions. As used below, a \u201cfault\u201d is a pair consisting of a process variable v and a direction d, and is designated as <v, d>. The value of d can be either high or low, which are in turn defined by\n\nhigh=1\n\nlow=\u22121\n","For some quantities, the invention is not concerned with values, but only whether they are positive or negative. The sign function is used in this regard:",{"@attributes":{"id":"p-0031","num":"0030"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"sign","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}},{"mrow":{"mn":"1","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","x"]},"mo":">","mn":"0"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":{"mn":"0","mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","x"]},"mo":"=","mn":"0"}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mrow":{"mrow":{"mo":"-","mn":"1"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","x"]},"mo":"<","mn":"0"}}}}]}}}},"At least two different functions for computing certainty factors from residuals may be used. Both functions produce bell-shaped curves when they are graphed. A first function, a Gaussian function, is defined as:\n\nGauss(sigma)=(\u2212(\/sigma)\/2)\n\nwhere sigma is the standard deviation of the process variable x. As used herein, a second function, referred to herein as the Kramer function, is defined as follows:\n\nKramer(sigma)=1\/(1+(\/(3sigma)))\n\nwhere sigma is again the standard deviation of the process variable x. In a preferred embodiment, n is 3. However, this may be modified in this preferred embodiment and may be another value in other embodiments. The function referred to herein as the Kramer function is derived from Kramer, M. A., -, AlChE Journal 33, pp. 130-147, which is incorporated herein by reference.\n","When an embodiment of the present invention monitors a process, it reads real-time sensor data, computes the associated primary and\/or secondary residual values and their standard deviations, and then calculates three certainty factors for each residual value, as needed. Let r be one of the residual values and let sigma be its standard deviation. Residual r is expected to be zero, but often it is not. If it is only a little off from zero, the invention considers it to be satisfactory, but the farther away from zero it gets, there exists less confidence that it is satisfactory. Using the Kramer function, the certainty factor for r being satisfactory is represented in this embodiment as:\n\ncf(r, sat)=Kramer(r, sigma)\n\nIf r is much greater than zero, it is considered to be high, that is, higher than it is supposed to be. The certainty factor for r being high is represented as:\n",{"@attributes":{"id":"p-0034","num":"0033"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"cf","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["r","high"],"mo":","}}},{"mrow":{"mn":"1","mo":"-","mrow":{"mrow":{"mi":"Kramer","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["r","sigma"],"mo":","}}},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","r"]}},"mo":">","mn":"0"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mn":"0","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"otherwise"}}}}]}}},"br":{}},{"@attributes":{"id":"p-0035","num":"0034"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"cf","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["r","low"],"mo":","}}},{"mrow":{"mn":"1","mo":"-","mrow":{"mrow":{"mi":"Kramer","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["r","sigma"],"mo":","}}},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","r"]}},"mo":"<","mn":"0"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mn":"0","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"otherwise"}}}}]}}}},"To achieve some computational efficiency, the present embodiment computes an intermediate value which is referred to as the compressed value for r:\n\ncompressed\u2212value()=sign()(1\u2212Kramer(sigma))\n\nThis one number is stored and used later to compute the three certainty factors using the following formulas:\n",{"@attributes":{"id":"p-0037","num":"0036"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"cf","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["r","sat"],"mo":","}}},{"mn":"1","mo":"-","mrow":{"mo":["\uf603","\uf604"],"mrow":{"mi":"compressed","mo":["\u2062","\u2062"],"mstyle":{"mtext":"-"},"mrow":{"mi":"value","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}}}}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"cf","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["r","high"],"mo":","}}},{"mrow":{"mi":["compressed","if","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mi":"value","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}}},"mo":">","mn":"0"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mn":"0","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"otherwise"}}}},{"mtd":{"mrow":{"mrow":[{"mi":"cf","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["r","low"],"mo":","}}},{"mrow":{"mrow":[{"mo":"-","mi":"compressed"},{"mi":"value","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["if","r"]},"mo":"<","mn":"0"}],"mo":"="}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mn":"0","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"otherwise"}}}}]}}},"br":{}},"As stated above, for purposes of calculating certainty factors for faults, <v, d> signifies a fault; that is, v is a process variable and d is a direction, either high or low. To compute the certainty factor that a fault is present, the certainty factors for the primary and\/or secondary residuals are examined to find evidence for the fault. If r is a residual, r provides evidence for fault <v, d> when it has deviated from zero in a direction that is consistent with variable v deviating in the direction d. For example, if \u2202r\/\u2202v is greater than zero, then both v and r can be expected to go high (or low) at the same time. If, however, \u2202r\/\u2202v is less than zero, then v and r can deviate in opposite directions. The certainty factor for r in the appropriate direction is then the strength to which r can provide evidence for the fault. One strong piece of evidence for the fault is enough to strongly conclude that the fault is present, unless there is also strong evidence that it is not present.","The evidence for fault <v, d> is this set of certainty factors for all relevant residuals:\n\nevidence-for-fault(<v,)={(sign(\u2202))|(\u2202)\u22600 and is a primary residual}\n\nIn some applications, the certainty factor for any residual, primary or secondary, may be included in this set. The strength of the evidence for the fault is the maximum of the values in this set.\n","Similarly, if a residual deviates in the opposite direction from what is expected when the fault is present, that deviation is evidence against the fault being present. The evidence against fault <v, d> is this set of certainty factors for all relevant residuals:\n\nevidence-against-fault(<)={(sign(\u2202))|(\u2202)\u22600}\n\nCertainty factors for both primary and secondary residuals may be included in this set. The strength of the evidence against the fault is the maximum of the values in this set. If that value is subtracted from one, the strength to which this evidence is consistent with the fault being present is determined.\n","An additional consideration is significant in evaluating a certainty factor for a fault. Some residuals are not functions of v and so are not expected to deviate from zero when the fault <v, d> is present. The secondary residual process model that was formed by eliminating v from two primary residual process models is such a residual. It is relevant to evaluating the presence of the fault, so this secondary residual is expected to have a high certainty factor of being satisfactory when the fault involves v. Also, if two primary residual process models were combined to generate a secondary residual process model by eliminating some variable other than v, and one of these primary residuals is a function of v but the other is not, it is expected that the primary residual that is not a function of v is satisfactory. This primary residual is considered relevant to the fault as well.","Some primary residual process models may not be functions of v and are not combined with any models that are. These are considered to be not relevant to the fault <v, d>. Another fault can be present and cause them to deviate from zero, but this will not affect the assessment for fault <v, d>. This allows a diagnosis of the presence of several single faults that happen not to interact with each other. In addition, r may be a function of v, but at the moment, (\u2202r\/\u2202v)=0. The neutral-evidence for fault <v, d> is this set of certainty factors for all relevant residuals:\n\nneutral-evidence(<)={()|is relevant as neutral-evidence for v}\n\nThe strength of this evidence is the minimum of the set because if any one of the residuals that are supposed to be satisfactory is in fact high or low, that weakens the evidence for the fault <v, d>.\n","The certainty factors in these three sets, evidence-for-fault, neutral-evidence, and evidence-against-fault, are considered as fuzzy logic values, and are combined using a common interpretation of fuzzy \u201cAND\u201d as the minimum function, fuzzy \u201cOR\u201d as the maximum function, and fuzzy \u201cNOT\u201d as the complement function (1 minus the value of its argument). For finite sets, the quantifier \u201cSOME\u201d is just the \u201cOR\u201d of the values in the set, so it is equivalent to taking the maximum of the set. Similarly, for finite sets, the quantifier \u201cALL\u201d is just the \u201cAND\u201d of all the values in the set, so it is equivalent to taking the minimum of the set. Putting this all together, the certainty factor for fault <v, d> is defined in this embodiment as:\n\n(<)=SOME(evidence-for-fault(<)) AND ALL(neutral-evidence(<)) AND NOT (SOME(evidence-against-fault(<)))\n\nIf this value is above a threshold, it is displayed as a possible fault.\n","Regarding the display of a fault <v, d>: If v is a measured variable, the sensor value for that variable was substituted for the variable in computing all the primary and secondary residual values. If d=high, a conclusion is drawn that the sensor reading is higher than the true value for that process variable. If d=low, a conclusion is drawn that the sensor reading is lower than the true value for that process variable. In either case, a conclusion is drawn that the sensor is at fault. If cf(<v, d>) is about zero for both cases, d=high and d=low, then the sensor reading has been validated.","In the case of an unmeasured variable v , such as a leak, a high certainty factor for <v, low> means that the assumed value of v, which can be viewed as the reading from a virtual sensor, is low compared to the actual value. In order to display a conclusion about the actual value of the unmeasured variable, a preferred embodiment of the invention displays a message that v is high in this case (i.e., there is a positive leak out of the process). Similarly, if the certainty factor for <v, high> is high, it displays a message about v being low. If neither of these cases apply, a conclusion is drawn that the real value of v is about equal to its assumed value.","The fuzzy logic rule above may be generalized to sets of faults by redefining what counts as evidence for the set, evidence against the set, and what counts as neutral-evidence. An inference may be drawn that a set of faults is present when no subset of them may be inferred to be present. In particular, this means there must be at least one residual value for each fault deviating in the direction that the fault can cause. This leads to the following general fuzzy rule of this invention: Let\n\nfault-set={<v>}\n\nThen\n",{"@attributes":{"id":"p-0047","num":"0046"},"maths":[{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"cf","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["fault","set"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"-"}}}},{"mrow":{"mi":"SOME","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["evidence","for"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mtext":"-"},{"mtext":"-"}],"mrow":{"mi":"fault","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mo":"<","msub":{"mi":"v","mn":"1"}},{"msub":{"mi":"d","mn":"1"},"mo":">"}],"mo":","}}}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"AND"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00005-2","num":"00005.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"3.3em","height":"3.3ex"}}},"mo":"\u2062","mi":"\u22ee"}}},{"@attributes":{"id":"MATH-US-00005-3","num":"00005.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"SOME","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["evidence","for"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mtext":"-"},{"mtext":"-"}],"mrow":{"mi":"fault","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mo":"<","msub":{"mi":["v","n"]}},{"msub":{"mi":["d","n"]},"mo":">"}],"mo":","}}}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"AND"}}},{"@attributes":{"id":"MATH-US-00005-4","num":"00005.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"ALL","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"neutral","mo":["\u2062","\u2062"],"mstyle":{"mtext":"-"},"mrow":{"mi":"evidence","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["fault","set"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"-"}}}}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"AND"}}},{"@attributes":{"id":"MATH-US-00005-5","num":"00005.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"NOT","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"SOME","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"evidence","mo":["\u2062","\u2062"],"mstyle":{"mtext":"-"},"mrow":{"mi":"against","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["fault","set"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"-"}}}}}}}}}}}]},"The component evidence sets are defined as follows:\n\n","Referring now to , which is a flowchart illustrating sensor validation and predictive fault analysis aspects of the present invention, data from the model file is first loaded into internal data structures . Next, a check is made for new process data . If none, the invention waits a short time and checks again. When process data is available, the data is read, i.e., the values for the measured variables are updated. In the next step, primary residual values and their derivatives are computed .","Next, secondary residuals, if any, and their derivatives are computed . In the next step, certainty factors for each primary and\/or secondary residual are computed . For each process variable, certainty factors are computed for it being high and for it being low using a dynamically computed pattern template . The use of a dynamically computed pattern template in  refers to the regeneration of the diagnostic rule. Each of steps  through  execute pseudo-code stored in the model file referred to in .","Next, in , certainty factors are computed for each pair of faults that have some evidence for them . Finally, single faults are displayed with certainty factors that exceed an inputted or predetermined threshold, and pairs of faults are displayed whose certainty factors exceed an inputted or predetermined threshold and also exceed the certainty factors for each of its component faults . After this step, the method returns to step  and repeats.","Code which implements the computation of the certainty factors for single and double faults in this embodiment is set forth below. The code set forth herein illustrates several examples, but should not be construed so as to limit the scope of the invention. The invention may be implemented in a number of programming languages and may be fixed in any computer-readable medium including without limitation any computer memory, floppy disks, hard disks, optical disks, CD-ROM, Flash ROM, non-volatile ROM, and RAM.","The function that computes the certainty factor for the nth variable, which is denoted by Vn, follows. For a given residual r, the code calls three functions, c\u0192High(r), c\u0192Low(r) and c\u0192Satisfactory(r), which compute the values c\u0192(r, high), c\u0192(r, low) and c\u0192(r, sat) as defined earlier. The variable m denotes the number of primary residuals and the variable dm denotes the number of secondary residuals that are being processed by the code. If function parameter d is True, it computes c\u0192(Vn, high); if d is False, it computes c\u0192(Vn, low). The function contains two FOR loops, one for evaluating the primary residual process model (\u201cPMR\u201d in the code) and one for evaluating the secondary residual process model (\u201cSMR\u201d in the code). They are the same except for which set of residual process models they operate on. In the code below, lines are numbered on the right, and corresponding footnotes are below. Two auxiliary arrays are used: pmrMask and pmrPattern. There are corresponding arrays for the smrs as well. Array pmrMask holds some strings of 0s and 1s to indicate which residuals are relevant to which variables. Array pmrPattern indicates whether the variable and the residual change in the same direction, the opposite direction, or that the residual does not change when the variable changes. These conditions correspond to the pattern values 1, \u22121, and 0, respectively. The pattern value is 0 if it is known that the formula for the residual does not contain the variable Vn or if the derivative of the residual with respect to Vn is 0. More accurately, the pattern value for residual i with respect to variable Vn is the sign of the derivative of pmr i with respect to Vn if Vn is a measured variable, and it is minus the sign of the derivative of pmr i with respect to variable Vn if Vn is an unmeasured variable (e.g., a leak). The difference in treatment is due to the fact that for a measured variable, conclusions are drawn about the measurement of the process variable, and for an unmeasured variable, conclusions are drawn about the process variable itself.","Relevant residuals can be divided into two classes: neutral residuals (pattern value=0) and affected residuals. Depending on the direction in which an affected residual has changed, it might be evidence for Vn being a fault (in the direction indicated by d) or it might be evidence against Vn being a fault. The local variable minSoFar keeps track of the minimum c\u0192Satisfactory value for the neutral residuals. For the affected residuals, maxFor keeps track of the maximum certainty factor for those residuals that are evidence for the Vn fault, and maxAgainst keeps track of the maximum certainty factor for those residuals that are evidence against the fault. The certainty factor of the Vn fault is then the minimum of minSoFar, maxFor, and (1\u2212maxAgainst).","Note that if the Vn fault can cause pmr i to rise, the c\u0192High value for pmr i is the certainty level to which pmr i is evidence for the fault, and the c\u0192Low value for pmr i is the certainty level to which pmr i is evidence against the fault. The opposite holds true if the fault can cause pmr i to fall. If maxAgainst is the certainty factor of the strongest evidence against the fault, then the certainty factor for the fault cannot be any higher than 1\u2212maxAgainst. The calculation 1\u2212X is the fuzzy version of NOT(X). Basically, the rule being used is the fuzzy version of the Boolean rule:\n\nFAULT-IS-PRESENT=SOME(evidence-for-fault) AND ALL(neutral-evidence) AND NOT (SOME(evidence-against-fault))\n","The code for computation of certainty factors for single and double faults:",{"@attributes":{"id":"p-0057","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Function computedVarCF(n As Integer, d As Boolean) As Double"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim minSoFar As Double"]},{"entry":[{},"Dim maxFor As Double"]},{"entry":[{},"Dim maxAgainst As Double"]},{"entry":[{},"Dim i As Integer"]},{"entry":[{},"Dim cf As Double"]},{"entry":[{},"minSoFar = 1"]},{"entry":[{},"maxFor = 0"]},{"entry":[{},"maxAgainst = 0"]},{"entry":[{},"For i = 1 To m"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If Mid(pmrMask(n), i, 1) = \u201c1\u201d Then","[1]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If pmrPattern(n * m + i) = 0 Then","[2]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"minSoFar = min(minSoFar, cfSatisfactory(pmrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ElseIf pmrPattern(n * m + i) = 1 Then","[3]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If d Then","[4]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"maxFor = max(maxFor, cfHigh(pmrCF(i)))"]},{"entry":[{},"maxAgainst = max(maxAgainst, cfLow(pmrCF(i)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"maxFor = max(maxFor, cfLow(pmrCF(i)))"]},{"entry":[{},"maxAgainst = max(maxAgainst, cfHigh(pmrCF(i)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ElseIf pmrPattern(n * m + i) = \u22121 Then","[5]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If d Then","[4]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"maxFor = max(maxFor, cfLow(pmrCF(i)))"]},{"entry":[{},"maxAgainst = max(maxAgainst, cfHigh(pmrCF(i)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"maxFor = max(maxFor, cfHigh(pmrCF(i)))"]},{"entry":[{},"maxAgainst = max(maxAgainst, cfLow(pmrCF(i)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Next"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For i = 1 To dm","[6]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If Mid(smrMask(n), i, 1) = \u201c1\u201d Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If smrPattern(n * dm + i) = 0 Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"minSoFar = min(minSoFar, cfSatisfactory(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ElseIf smrPattern(n * dm + i) = 1 Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If d Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"*maxFor = max(maxFor, cfHigh(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"maxAgainst = max(maxAgainst, cfLow(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"*maxFor = max(maxFor, cfLow(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"maxAgainst = max(maxAgainst, cfHigh(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ElseIf smrPattern(n * dm + i) = \u22121 Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If d Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"*maxFor = max(maxFor, cfLow(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"maxAgainst = max(maxAgainst, cfHigh(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"*maxFor = max(maxFor, cfHigh(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"maxAgainst = max(maxAgainst, cfLow(smrCF(i)))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Next"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If d Then","[7]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"var2High(n) = maxFor"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"var2Low(n) = maxFor"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"computedVarCF = min(minSoFar, min(maxFor, 1 \u2212 maxAgainst))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"End Function"},{"entry":"[1] If Mid(pmrMask(n), i, 1) = \u201c1\u201d then pmr i is relevant to Vn."},{"entry":"[2] If pmrPattern(n * m + i) = 0 then pmr i is neutral for Vn."},{"entry":"[3] If pmrPattern(n * m + i) = 1 then a change in Vn causes pmr i"},{"entry":"to change in the same direction."},{"entry":"[4] If d then we are computing cf(Vn, high), else we are computing"},{"entry":"cf(Vn, low)."},{"entry":"[5] If pmrPattern(n * m + i) = \u22121 then a change in Vn causes pmr"},{"entry":"i to change in the opposite direction."},{"entry":"[6] The smrs are handled exactly the same way as the pmrs."},{"entry":"[7] This If statement just saves the maxFor value to indicate when the"},{"entry":"fault should be considered for double faults."},{"entry":"* The lines of code marked with * are used in those applications where the"},{"entry":"certainty factor for any residual, primary or secondary, may be included"},{"entry":"in the evidence-for-fault set, as referred to above."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Pairs of faults are computed by the subroutine below. It computes the certainty factor for the pair of variables Vi and Vj. If b is True, the fault with Vi is that it is high; if b is False, the fault is that Vi is low. Similarly, if c is True, a computation is made for the case where Vj is high, and if c is False, a computation is made for the case where Vj is low.","The strategy is to find the certainty factor of the evidence for the pair of faults, the certainty factor of there not being evidence against the pair of faults, and then take the minimum. For the pair of faults involving Vi and Vj, there must be SOME evidence for Vi, AND SOME evidence for Vj. Local variable maxISoFar is set to the maximum certainty factor for a residual that Vi can change, and local variable maxJSoFar is set to the maximum certainty factor for a residual that Vj can change. Local variable minSoFar is set to the minimum certainty factor of a residual that might count as evidence against the pair (the certainty factor used is the certainty that it is NOT in fact evidence against the pair of faults). The certainty factor for the pair of faults is the minimum of minSoFar, maxISoFar and maxJSoFar.","The code contains two FOR loops, one for the pmrs and one for the smrs. Otherwise, they are the same. Basically, the rule being used can be thought of as the fuzzy version of the boolean rule:\n\nFAULT-PAIR-IS-PRESENT=SOME(evidence-for-first-fault) AND SOME(evidence-for-second-fault) AND ALL(neutral-evidence) AND NOT (SOME(evidence-against-pair))\n","One difficult aspect of fault pairs is determining what counts as neutral-evidence and what counts as evidence against the pair. In this embodiment, this is determined by the nextMin function used to update minSoFar. What counts as evidence for a fault is determined by function nextMax, which is used to update both maxISoFar and maxJSoFar. Both of those functions are called in the subroutine:",{"@attributes":{"id":"p-0062","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Sub pairCF(i As Integer, b As Boolean, j As Integer, c As Boolean)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim minSoFar As Double"]},{"entry":[{},"Dim maxISoFar As Double"]},{"entry":[{},"Dim maxJSoFar As Double"]},{"entry":[{},"Dim finalCF As Double"]},{"entry":[{},"Dim iP As Integer"]},{"entry":[{},"Dim jP As Integer"]},{"entry":[{},"Dim k As Integer"]},{"entry":[{},"minSoFar = 1"]},{"entry":[{},"maxISoFar = 0"]},{"entry":[{},"maxJSoFar = 0"]},{"entry":[{},"For k = 1 To m"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If Mid(pmrMask(i), k, 1) = \u201c1\u201d Or",{}]},{"entry":[{},"Mid(pmrMask(j), k, 1) = \u201c1\u201d Then","[8]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If b Then","[9]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"iP = pmrPattern(i * m + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"iP = \u2212pmrPattern(i * m + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End If",{}]},{"entry":[{},"If c Then","[10]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"jP = pmrPattern(j * m + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"jP = pmrPattern(j * m + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End If",{}]},{"entry":[{},"minSoFar = nextMin(minSoFar,","[11]"]},{"entry":[{},"iP, jP, k, True)"]},{"entry":[{},"maxISoFar = nextMax(maxISoFar, iP, k, True)","[12]"]},{"entry":[{},"maxJSoFar = nextMax(maxJSoFar, jP, k, True)","[13]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Next"]},{"entry":[{},"For k = 1 To dm"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If Mid(smrMask(i), k, 1) = \u201c1\u201d Or"]},{"entry":[{},"Mid(smrMask(j), k, 1) = \u201c1\u201d Then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If b Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"iP = smrPattern(i * dm + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"iP = \u2212smrPattern(i * dm + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End If"]},{"entry":[{},"If c Then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"jP = smrPattern(j * dm + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"jP = \u2212smrPattern(j * dm + k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End If"]},{"entry":[{},"minSoFar = nextMin(minSoFar, iP, jP, k, False)"]},{"entry":[{},"maxISoFar = nextMax(maxISoFar, iP, k, False)"]},{"entry":[{},"maxJSoFar = nextMax(maxJSoFar, jP, k, False)"]},{"entry":[{},"End If"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Next"]},{"entry":[{},"finalCF = min(minSoFar, min(maxISoFar, maxJSoFar))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If finalCF > displayThreshold Then","[14]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"pairCount = pairCount + 1"]},{"entry":[{},"pairList = Array(i, b, j, c, finalCF, pairList)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"End Sub"},{"entry":"[8] If Mid(pmrMask(i), k, 1) = \u201c1\u201d Or Mid(pmrMask(j), k, 1) = \u201c1\u201d then"},{"entry":"pmr k is relevant to either Vi or Vj (or both)."},{"entry":"[9] If b then iP is set to the pattern value for pmr k with respect to"},{"entry":"variable Vi; otherwise iP is set to minus the pattern value for pmr k with"},{"entry":"respect to variable Vi. (If b is True, Vi is failing high, and if b is False,"},{"entry":"Vi is failing low, so the direction of influence on pmr k changes.)"},{"entry":"[10] If c then jP is set the same way iP was as explained in [9]."},{"entry":"[11] Update minSoFar according to neutral and possibly negative"},{"entry":"evidence."},{"entry":"[12] Update maxISoFar with evidence for Vi."},{"entry":"[13] Update maxJSoFar with evidence for Vj."},{"entry":"[14] If finalCF > displayThreshold then add the pair to the list of"},{"entry":"fault pairs."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The NextMin function is used to update minSoFar whenever it sees neutral-evidence or possible evidence against the fault pair. Variable msf is the previous value of minSoFar. Variable iP is the pattern value for pmr k (if b is True) or smr k (if b is False) with respect to Vi, and variable jP is the pattern value for pmr k (if b is True) or smr k (if b is False) with respect to Vj. The residual k is classified as neutral or as evidence against the pair according to the following table:",{"@attributes":{"id":"p-0064","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"iP","jP","Neutral","Evidence Against Pair"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1","1","No","If residual is low"]},{"entry":[{},"1","0","No","If residual is low"]},{"entry":[{},"1","\u22121","No","No"]},{"entry":[{},"0","1","No","If residual is low"]},{"entry":[{},"0","0","Yes","No"]},{"entry":[{},"0","\u22121","No","If residual is high"]},{"entry":[{},"\u22121","1","No","No"]},{"entry":[{},"\u22121","0","No","If residual is high"]},{"entry":[{},"\u22121","\u22121","No","If residual is high"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"If residual k is evidence against the pair because it is low (one or both variables Vi and Vj should be causing it to go high), the certainty that it is NOT in fact evidence against the fault pair is (1\u2014the certainty factor of residual k being low). If residual k is evidence against the pair because it is high, the certainty that it is NOT in fact evidence against the fault pair is (1\u2014the certainty factor of residual k being high). If the certainty factor for residual k as new evidence is lower than the previous minimum, that is what is returned to be the new value of minSoFar.",{"@attributes":{"id":"p-0066","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Function nextMin(msf As Double, iP As Integer, jP As Integer,"},{"entry":"k As Integer, b As Boolean)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim scf As Double"]},{"entry":[{},"If b Then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"scf = pmrCF(k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"scf = smrCF(k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End If"]},{"entry":[{},"If iP = 0 And jP = 0 Then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nextMin = min(msf, cfSatisfactory(scf))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ElseIf (iP = 0 Or jP = 0 Or iP = jP) Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If iP = 1 Or jP = 1 Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nextMin = min(msf, 1 \u2212 cfLow(scf))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ElseIf (iP = \u22121 Or jP = \u22121) Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nextMin = min(msf, 1 \u2212 cfHigh(scf))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nextMin = msf"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"End If"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The function nextMax is used to update maxISoFar and maxJSoFar whenever it sees evidence for one of the faults. Internally, msf is the previous value of whichever program variable is being updated and iP is the pattern value for the fault that the evidence is for. Residual k is seen as evidence if iP is not 0. If iP is 1, the residual k should be high to be counted as evidence for the fault. IF iP is \u22121, the residual k should be low to be counted as evidence for the fault. Since we are looking for SOME evidence for the fault, the maximum of the certainty factors for such evidence is used. The variable b simply indicates whether the residual is a primary residual or a secondary residual.",{"@attributes":{"id":"p-0068","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Function nextMax(msf As Double, iP As Integer, k As Integer, b As"]},{"entry":[{},"Boolean)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim scf As Double"]},{"entry":[{},"If b Then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"scf = pmrCF(k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"scf = smrCF(k)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End If"]},{"entry":[{},"nextMax = msf"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"If iP = 1 Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nextMax = max(msf, cfHigh(scf))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ElseIf iP = \u22121 Then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"nextMax = max(msf, cfLow(scf))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002End If"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The model compiler of a preferred embodiment of the present invention is a subroutine in the code which must be executed at least once before the code can perform sensor validation and predictive fault analysis. The purpose of the model compiler is to translate the primary process models provided by the plant engineer, etc. into a set of instructions, or pseudo-code, for computing primary residual values, secondary residual values, compressed values and partial derivatives in a form used by the fault analyzer to analyze plant data. The fault analyzer in this embodiment is a top-level subroutine with a set of auxiliary subroutines, which is called once each time new sensor data is read from the process.","When a user selects the compile operation, the model compiler processes the primary process models. The model compiler uses the recursive descent approach to parse the models and produce arrays and other data structures. The information from the measured variables table and the unmeasured variables table is stored in a symbol table, implemented as an array. Symbol tables are found in almost every compiler. The primary process models and the formulas for computing the means and standard deviations are parsed into what are called syntax trees. These are data structures representing equations and expressions with nodes that represent either a number, reference to a variable or array, or an operation or function call whose arguments are the nodes it is linked to. The recursive descent methodology for parsing, symbol tables and syntax trees can be found in any introductory textbook on compiling programming languages.","After the process models and auxiliary equations are represented by syntax trees, the generation of pseudo-code for use by the fault analyzer begins. This is when the compiler figures out how to compute the primary residual process models, the secondary residual process models, their compressed values and partial derivatives.","The model compiler performs the following steps:\n\n","During step 7, an index map array is filled in that maps the variable indices in the model compiler's symbol table into the corresponding indices that will be used in the fault analyzer. Some temporary variables created by the model compiler are not needed by the fault analyzer, namely partial derivatives that symbolically evaluate to a constant value, so the variables that are needed are renumbered. As the model compiler stores the pseudo-code in a table in the database, it changes the variable numbers according to the index map array so that they have the values of their position in the fault analyzer's symbol table. At this point, the compiler is done.","The system and method of the present embodiment passively interacts with a distributed control system, programmable logic controller, or a data historian, periodically analyzing the data being collected, and reporting results either locally to a personal computer or control console. In this embodiment, all results are reported in the form of intelligent alarms; i.e., time stamped messages indicating the type and severity of the specific problem(s) determined to be occurring. Reported problems may be specific faults occurring in the process and\/or specific out-of-control process or equipment conditions. Operators interact with such intelligent alarms in a manner they are accustomed to, specifically acknowledging active alarms and clearing inactive ones. This embodiment in many cases will act as an extension of an existing alarm system via interpreting models of normal process operations and EWMA calculations.","In a preferred embodiment, a computer program that performs fault analysis loads the information obtained from a model development environment and then waits for the command to begin monitoring the process for faults. When a user gives this command, the analyzer periodically receives data consisting of the time of day and the current values of the measured variables. It then computes the primary and\/or secondary residual values and the partial derivatives of the primary and\/or secondary residual process models, and computes the certainty factors for all possible single faults and pairs of faults. The model development environment is used to maintain the process models and to set up the fault analyzer program with essential information. Basic user operations are:\n\n","The fault sets and their certainty factors are displayed on a computer screen. An end-user may click on a fault set to see an explanation of why that fault set has the certainty value that is displayed for it. In this embodiment, this explanation takes the form of a table that shows for each relevant residual what certainty it has as evidence for the fault set, as evidence against the fault set and as neutral-evidence. A fault explanation window (with information such as that set forth in example Tables B and C below) lists all process models relevant to the given diagnosis along with evidence collected from those models to arrive at that diagnosis.",{"@attributes":{"id":"p-0077","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE B"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["PMR","Expected","Actual","For","Against"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","0","0","1","0"]},{"entry":["3","0","0","1","0"]},{"entry":["4","0","0","1","0"]},{"entry":["10","\u22121","0","0","0"]},{"entry":["11","0","0","1","0"]},{"entry":["13","\u22121","\u2212.19",".19","0"]},{"entry":["22","0",".01",".99",".01"]},{"entry":["23","0","0","1","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0078","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE C"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["SMR","Expected","Actual","For","Against"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["4","\u22121","0","0","0"]},{"entry":["10","1","0","0","0"]},{"entry":["11","1","0","0","0"]},{"entry":["12","1","0","0","0"]},{"entry":["13","1","0","0","0"]},{"entry":["14","\u22121","0","0","0"]},{"entry":["23","1","0","0","0"]},{"entry":["69","\u22121","0","0","0"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"The relevant primary (PMR) and secondary (SMR) residual process models used in this fault analysis are identified in the first column of Tables A and B by their respective identification numbers. Such residual process models are converted into compressed values for interpreting the evidence for potential faults. The values of the compressed values expected for those models are indicated in the second column. These may be \u22121, 0, or 1. Values of either 1 or \u22121 in the \u201cExpected\u201d column indicate that the corresponding residual process model depends upon the suspect variable and that the residual process model is positively or negatively correlated to it, respectively. A value of 0 indicates that the corresponding residual process model does not depend upon the suspect variable; i.e., changes in the variable do not affect the model residual or are \u201cneutral\u201d to the model residual. Such \u201cneutral\u201d models are included because they share other variables in common with the dependent model(s) and have been used in the generation of the secondary residual process models for fault analysis. The actual compressed value for each relevant residual is listed in the third column and is compared to the expected values to determine the evidence existing For and Against the suspect variable being at fault. If the expected value is 1, the evidence For the suspect variable being at fault is the positive actual value\u2014actual values of 0 are considered no evidence. The evidence Against the suspect variable is the absolute value of a negative actual value. The exact opposite reasoning is applied when the expected value is \u22121. If a value of 0 is expected, the evidence For the fault is one minus the absolute value of the actual value. The evidence Against the fault is the absolute value of the actual value in this case.","An overall certainty factor or rating is computed directly from these For and Against values of all relevant primary and secondary residual process models with the fuzzy logic rule described herein. This value is then compared against preselected certainty factor threshold values to determine if an \u201cintelligent alarm\u201d should be given for the suspect fault. In one embodiment, only faults beyond these alarm limits are available for viewing with a fault explanation window.","One preferred embodiment of the method of the present invention includes the following functions:\n\n","Although multiple faults occur less frequently than single faults, the present invention's ability to detect multiple faults is important because most major process disasters occur as a consequence of a series of two or more concurrent process fault situations. Furthermore, certain types of multiple fault situations occur much more frequently than others. Kramer, -describes three classes of such multiple faults as follows: (1) faults causing other faults (so called \u201cinduced failures\u201d), (2) latent faults which are not detectable until additional faults occur, and (3) intentional operation in the presence of one or more faults, with the sudden occurrence of an additional fault. Also, not all deviations from normal process operation which impact the values of model residuals are necessarily process faults. For instance, unsteady state operation, unusually low production rates, changeover of a feed supply, normal process shutdown, etc. are all examples of events which may generate diagnostic evidence and thus need to be handled by the diagnostic logic. Since such events are much more frequent than even single fault situations, they need to be accounted for directly. A preferred embodiment directly diagnoses many legitimate paired multiple fault\/event situations as well as all single fault\/event situations detectable from the current process data. These plausible multiple fault\/event pairs tend to have lower resolution (i.e., many possible combinations) which need to each be checked by the process operator before the best corrective action is taken. These diagnoses are thus a direct extension of the underlying diagnostic logic for single faults and although less plausible than concurrent single fault diagnoses, exhaustively deduce all potential explanations of the current deviations from normal process operation. In one embodiment, rather than computing pairs of faults, each fault <v, d> whose max(evidence-for (<v, d>)) exceeds the certainty factor for <v, d> is displayed. In this way, each possible fault is displayed at most once, either as a single fault or as a possible member of a multiple fault set.","In one embodiment, the system of the present invention includes the following program modules:\n\n","The SPC Module allows continuous monitoring of process sensor readings to determine if they are under control or not. Its analysis is based upon an EWMA, CUSUM or other common SPC method of those readings over time. This analysis directly allows for out of control sensors to be flagged more quickly and at levels that may allow the process operators to intercede with the proper control actions necessary to mitigate the underlying process problems without unduly disrupting process operations. The analysis is done automatically without the need for the operators to collect and chart any process sensor readings. EWMA, CUSUM and other common SPC calculations such as those used in this invention are known to those skilled in the art.","There are two types of observed variables to contend with in this SPC analysis: controlled variables and uncontrolled variables. A different SPC interpretation is performed for each. Controlled variables have their calculated EWMA, CUSUM or other common SPC values compared to Upper Control Limits (UCL) and Lower Control Limits (LCL) centered on their setpoint to determine their control status. Uncontrolled variables have their current values compared to both UCL and LCL based on their previous EWMA, CUSUM or other common SPC value to determine their control status. Each of these calculations is described below. In one embodiment, exceeding either the UCL or LCL generates a red alarm (out of control); exceeding some fraction, such as \u2154 of the UCL or LCL generates a yellow alarm (going out of control); else it is a green alarm (in control). This analysis will be periodically performed at a frequency that will be different for each sensor point being monitored. As explained, this frequency depends upon the various time constants inherent in the process system. This is necessary since the process data is auto-correlated and thus requires significant time between samples before unique information is forthcoming by the SPC analysis.","Using SPC to monitor the status of measured variables is an additional tool for optimizing process operations. It brings to bear a type of analysis shown to be useful with auto-correlated data, hopefully giving the process operators more timely alarms than those given by their process alarm system. This allows operators to respond with the appropriate control actions sooner.\n\n","The SV&PFA Module and the SPC Module each determine yellow and red alarms whenever appropriate. These yellow and red alarms can be displayed in the manner best suited for the user. In one embodiment, red alarms are displayed as blinking red alarm messages and yellow alarms as non-blinking yellow alarm messages. The operator is apprised of the red alarms only once by the display program and must acknowledge that alarm to stop it from blinking. If the underlying condition causing the blinking alarm subsequently is determined to no longer be present in the process, it disappears from the active alarm list. Yellow alarms are also not retained by the program if the underlying condition goes away; i.e., they automatically disappear from the active alarm list. Both yellow and red alarms and the acknowledgments of those alarms are logged by the display program. Operators are allowed to inhibit specific alarms for only a short period at a time (for example, 2 to 4 hours; this is configurable in the program). This reduces the nuisance of chatty alarms the operators are aware of while ensuring that the results of the SV&PFA and SPC analysis are not permanently ignored. Referring now to the drawings,  is a flowchart illustrating the present invention. In a first step , current data is collected if an appropriate or predetermined time interval has elapsed. Next, the State Transition Logic Module analysis is performed to determine if further analysis is required . If further analysis is required, the SV&PFA analysis is performed . If that analysis is performed, and an appropriate time interval passes, the SPC Module analysis is performed . Last, the results of these three modules are reported as intelligent alarms to operators , and the process repeats.","The software program of a preferred embodiment operates on a server connected either directly to a plant's control system or another server responsible for collecting either current or historical process data (these servers may be the same computer). There are at least five possible computer configurations for providing the results of the invention to an end-user. It may be set up as a Web service where the client(s) reside on either the same computer as the application server or another computer. It may be set up as a Web site using Web forms which consumes the Web service in order to render a display to the client\/browser(s). It may be set up as a stand-alone Windows application (in this case there is just one client which resides on the same computer as the application). It may be set up as a client using windows forms subscribing to the Web service Application Programming Interface. It may also be part of another application, which uses the application's dynamic linked libraries to process information and returns its results to the parent application. There may be other means of operating the application and giving its results. In addition, the invention has in the preferred embodiment an application database (any Open Database Conductivity compliant database will work) which may reside on either another server or the same server the application resides on.","While there has been described what is believed to be the preferred embodiment of the present invention, those skilled in the art will recognize that other and further changes and modifications may be made thereto without departing from the spirit of the invention. Therefore, the invention is not limited to the specific details and representative embodiments shown and described herein. Accordingly, persons skilled in this art will readily appreciate that various additional changes and modifications may be made without departing from the spirit or scope of the invention, as defined and differentiated by the following claims. In addition, the terminology and phraseology used herein is for purposes of description and should not be regarded as limiting."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
