---
title: Application independent write monitoring method for fast backup and synchronization of files
abstract: A method for monitoring file system requests made by an application program, storing changes made to a first copy of a selected file by the application program into a first file and synchronizing the changes made to the selected file with a second copy of the selected file. The monitoring and storing process is application independent in that it is utilized by the operating system for all file system requests made by any application program. The monitoring and storing process is repeated each time a file system request is made by the application program to track changes made to the selected file. At the time of synchronization, if the application program is no longer modifying the selected file and the selected file is closed, all entries in the first file are applied to the second copy of the selected file. As a result, synchronization of both copies of the selected files is achieved.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06985915&OS=06985915&RS=06985915
owner: 
number: 06985915
owner_city: 
owner_country: 
publication_date: 20010228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is related to U.S. patent application Ser. No. 09\/794,093, entitled \u201cApplication Independent Write Monitoring Method for Fast Backup and Synchronization of Open Files,\u201d filed on even date herewith.","The present invention is directed to a method for monitoring changes to files and synchronizing the files in a computer system, and more particularly, to an application independent method for monitoring and recording changes to files for later use to synchronize files in a computer system.","Maintaining the integrity of files stored in a computer system is imperative. This is as true for a single user computer as it is for commercial enterprises that support many computers that operate alone or that are interconnected by some sort of computer network. A good practice that is commonly followed by computer users is to copy the files stored on a computer either to a removable medium, e.g., floppy disk or zip drive, or, if available, to mass storage devices on a computer network, e.g., file servers. This process is sometimes referred to as a \u201cbackup\u201d process.","This practice may be adequate when the volume of files that are backed up is small or if the files are only maintained locally and there is no need to share files among multiple users. Present day computing, however, is not that simple. To the contrary, present day computer users no longer do business while tethered to a stationary work station in a traditional office environment. Technological progress has led to a surge in mobile and remote computing. Mobile and remote users need to be as productive away from the office as they are when they work in a traditional office setting. To accomplish this desired level of productivity, users need access to network resources and up-to-date information. As a result, enterprise data and information is being stored beyond the traditional office environment and is spread across remote offices, remote personal computers (\u201cPCs\u201d), mobile PCs such as laptops, and Personal Digital Assistants (\u201cPDAs\u201d). Thus, critical data stored on mobile and remote PCs, for example, documents, presentations and e-mail files, which can grow to hundreds of megabytes, are not properly protected nor are they always available to other users. As a result, there is even more of a need to ensure the integrity of files and accessibility of current copies of files to all users now that they may be spread out among remote and mobile computers.","The problem of file integrity is particularly acute for remote and mobile computers in that the information stored on a mobile or remote user's computer may not be stored anywhere else. In addition, in instances where files are maintained on a server in a network environment, the server copy of files may not reflect the latest changes or version of the files if a mobile or remote user was working on files locally on his mobile or remote computer. Because typical synchronization of such large files (for example, 200 to 300 megabytes) even over a local area network can take about 10 to 20 minutes, users are discouraged from creating copies of this information and thereby synchronize local copies of files with copies stored in the network.","A number of solutions have been proposed to overcome these shortcomings and facilitate the backup and synchronization of files. Traditional methods for backup and synchronization of files are, for example, copying network files and databases to the hard disk of the local PC and then, if appropriate, synchronizing the stored copies with the network copies of the files maintained on one or more network servers. This \u201ccopy and synchronize\u201d approach, however, is an inefficient use of network bandwidth in that entire files are copied and transmitted during the backup and synchronization process.","Other techniques utilized by backup and synchronization processes are known as \u201cdelta technologies.\u201d Known techniques employing delta technologies are so called \u201cblock level differencing\u201d (illustrated in and ) and \u201cbyte level differencing\u201d (illustrated in and ). These techniques are further described by James J. Hunt, Kiem-Phong Vo and Walter F. Tichy in \u201cAn Empirical Study of Delta Algorithms,\u201d Sixth International Workshop on Software Configuration Management in Berlin, 1996, and Andrew Tridgell and Paul Mackerras in \u201cThe Rsync Algorithm Technical Report TR-CS-96-05,\u201d Department of Computer Sciences, Australian National University, 1996.","In block level differencing, a local copy  and a remote copy  of a file are divided into \u201cdelta\u201d blocks  and  on a client computer  and a server computer , respectively. A comparison is made of the respective blocks and the differences between the local and remote delta blocks  and  are generated and stored in a data structure . The data structure  is then transferred during synchronization from the client computer  to the server computer  where the differences are applied to the server copy of the file  by a software process running on the server computer .","In byte level differencing, the client and server copies of the local copy  and the remote copy  of the file being synchronized are compared and differences down to the byte level are generated and stored in a data structure . This approach produces much smaller differences. The data structure  is then transferred from the client computer  to the server computer  during synchronization so that the differences can be applied to the server copy of the file  by a software process running on the server computer .","The potential inefficiencies in these processes are apparent. Both require two communication sessions between the client computer  and the server computer . The first to ascertain the differences between the files and the second to transmit the differences to the server computer  so they can be applied to the server copy of the file . In addition, because the processes that compute the differences are computationally intensive, they will consume a significant amount of time and a substantial amount of processing resources.","Another known technique that has been utilized to track changes made to database files is known as \u201cdatabase journaling.\u201d This technique requires the database application program to keep a journal of all changes made to a database file. These changes are then utilized during synchronization to incorporate changes made in the local copy of the database file to a remote copy of the database file.","This technique, however, is application specific in that it cannot be used to backup and synchronize files for which the application programs modifying the files do not themselves create change journals. In practice, the change journals are applied to synchronize a remote copy of the database. Typically, only high end database applications create change journals. Most popular software application programs, including Microsoft\u00ae PowerPoint\u00ae, Access, Outlook and Word (all products of the Microsoft Corporation located in Redmond, Wash.), do not create change journals.","The present invention overcomes the shortcomings discussed above by introducing an application independent method for monitoring file system requests made by any application program, and storing changes made to a selected file by the application program into a first file. The monitoring and storing process is repeated each time a file system request to write into the file is made by the application program to track changes made to the selected file.","At the time of synchronization, if the application program is no longer modifying the file, and the file is closed, all the changes that are stored are applied to a copy of the selected file. Alternatively, at the time of synchronization, if the application program is no longer modifying the selected file, and the file is closed, all entries in the first file that reflect duplicate changes to the same location within the selected file are removed so that only the latest changes are retained. The non-duplicate changes to the first file are then applied to a second copy of the selected file. In yet another alternative, changes made to the selected file are extracted and stored in a data structure. Entries in the data structure that reflect duplicate changes to the same location within the selected file may alternatively be removed so that only the latest changes to the same location are retained. The data structure, which may alternatively be compressed, is transmitted to a synchronization process, which decompresses the data structure (if necessary) and then applies the changes to a copy of the selected file. As a result, both copies of the selected file are identical, thereby synchronizing them.","The monitoring and storing process is application independent in that it is utilized by an operating system for all file system requests made by any application program. The monitoring and storing process is invoked each time a file system request is made by an application program. The process could be part of the operating system or it could be separate process accessed as needed by the operating system.","The benefits to this approach are a significant reduction in data transfer time to the location where the second copy or backup copy of the file is stored (network server, tape device, zip drive, or other backup device), significant speed up in achieving the task of synchronizing of the file, and a significant reduction in central processing unit load during the back up and synchronization process.","A method for backing up and synchronizing files stored in a computer is described. In the following detailed description, numerous specific details are set forth regarding the process and the environment in which the process may operate, etc., in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without such specific details. In other instances, well-known components, structures and techniques have not been shown in detail to avoid unnecessarily obscuring the subject matter of the present invention. Also, the same references numerals are used in the drawings and in the description to refer to the same elements.","Referring now to the drawings and, initially to , there is illustrated an exemplary computing environment for employing the present invention. The exemplary environment comprises two computers here identified as a client computer  and a server computer . The client computer  comprises a client Central Processing Unit (\u201cCPU\u201d) , a client memory  and a disk system . The client memory comprises an operating system , which itself comprises a file system . The client CPU , the client memory  and the disk system  are coupled by a system bus . The client memory  is a computer readable medium, which in at least some embodiments of the present invention could be a transmission. The client computer  could be a desktop personal computer, a laptop computer, a PDA, or any other type of computing device that is capable of running application programs and storing files.","The server computer  comprises a server CPU , a server memory , and a disk system . The server memory  comprises an operating system , which itself comprises a file system . The server CPU , the server memory  and the disk system  are coupled by a system bus . The server memory  is computer readable medium, which in at least some embodiments of the present invention could be a transmission. The server computer  could be a Sun Solaris\u2122 server (available from Sun Microsystems, Inc. located in Palo Alto, Calif.) or a PC running, for example, any one of Windows NT\u00ae, Windows\u00ae 2000 (both products of the Microsoft Corporation), Netware, NFS, Lantastic, Linux, Solaris\u2122, or UNIX operating system. It should be understood that the foregoing list of operating system is not meant to be exhaustive. The client computer  and the server computer  are shown as being interconnected via a communication path , which could be a direct physical connection, a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), a wireless network, the world-wide web, the Internet, an intranet, RAS, Virtual Private Network (\u201cVPN\u201d), direct cable connection, or any other type of interconnection that allows computers to communicate.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4","b":["36","50","36","62","64","66","62","64","66"]},"When one or more application programs ,  and  are active, the client CPU  () is executing the programs. The active application programs interact with the operating system , which could be, for example, Windows\u00ae 95, Windows\u00ae 98, Windows\u00ae Me, Windows NT\u00ae, or Windows\u00ae 2000, all of which are available from the Microsoft Corporation. One of the many well known functions carried out by the operating system  is to process requests to access memory by an application program. The file system  is managed by the operating system .","Also shown in  are a file system request monitor , a log record store , a monitor resource store  and a look-up store . The file system request monitor  is a process that is invoked by the operating system  each time one of the application programs ,  and  make a file system request. The file system request monitor  could be part of the operating system  or it could be a separate process accessed as needed by the operating system . The operation of the file system request monitor  will be more fully explained below in connection with . The monitor resource store  is a file that comprises an identification of file resources to be monitored by the file system request monitor . The log record store  is where changes made to a monitored file are stored. The look-up store  is a file that is used to map the identities of files that are monitored (stored in monitor resource store ) with the associated log record store  for each file being monitored.","It should be understood by one skilled in the art that portions of the file system request monitor , the operating system , the file system , and the application programs ,  and  are pulled into the client memory  from the disk system  by the client CPU  as needed. Similarly, if implemented on the server computer , the portions of the file system request monitor , the operating system , the file system , and the application programs ,  and  are pulled into the server memory  from the disk system  by the server CPU  as needed.","It will be more fully explained that the present invention can utilize multiple log record stores , one for each file resource identified in the monitor resource store , or it can use one log record store  where changes for all file resources identified in the monitor resource store  are stored. The look-up store  is not utilized when one log record store  is used to store all changes.","The identification of the file resources in the monitor resource store  can be accomplished several ways. It should be understood that this description is exemplary. It is contemplated that there are other methods that are within the scope of the present invention. One way is to identify them by storing their file names in the monitor resource store . A second way is to identify directories of files to be monitored by storing the pathnames of the directories in the monitor resource store . This approach will result in the monitoring of all files within the identified directories. Additional ways to identify files to be monitored would be to store the extensions of the files or the size range of the files. Example specifications of file resources to be monitored in the monitor resource store  are C:\\My Documents\\*.*, which would cause all files in the C:\\My Documents directory to be monitored and C:\\UserData\\maildata\\*.pst, which would cause all files in the C:\\UserData\\maildata directory with a \u201cpst\u201d file extension to be monitored.","The look-up store  illustrated in  may include a header structure and a plurality of look-up records. The fields comprising the header structure indicate the number of entries or records in the look-up store . The look-up records comprise a number of fields such as (1) the file name of the file being monitored (2) the corresponding log record store  for the file.","The operation of the file system request monitor  will now be explained in connection with . It should be understood that this description is exemplary. It is contemplated that there are other methods that are within the scope of the present invention.","For the purposes of this description, it is assumed that the file resources to be monitored have already been identified, the identity of the file resources are stored in the monitor resource store  and the names of the files to be monitored are mapped to their corresponding log record store  in the look-up table . For this example, only application program  will be active on the client computer  to simplify the explanation. Moreover, the explanation is centered around the monitoring of files on the client computer  and the synchronization of files on the client computer  with files on the server computer . It should be understood the roles could be reversed and the monitoring of files could be on the server computer  and the synchronization process could synchronize files on the server computer  with files on the client computer .","The user of client computer  invokes the application program , which causes client CPU  to activate the application program . Once it is active, the user of the client computer  can work with any files stored on the client computer  or files stored on the server computer . The user selects a particular file, the application program  issues a request to the operating system  to \u201copen\u201d the requested file, which for this example is shown on  as file . The user decides to change an entry in the file . The particular entry chosen is \u201c120 Hanover Sq.,\u201d which the user changes to \u201c260 Madison Avenue\u201d (see block  on FIG. ). The user then selects through the application program  to save this change. The application program , in turn, makes a write request to the file  as shown in step  of FIG. . The request is received by the operating system  and processed in step . Because it is a file system request, the operating system  invokes the file system request monitor , which then determines if the operation was successful in step . If it was not, control is returned to the operating system  (step ). If it was, the file system request monitor  in step  queries the monitor resource store  to determine if the file  was listed as a file resource to be monitored. If it is not, control is returned to the operating system  as shown in step . If the file  is included in the monitor resource store , the file system request monitor  next determines in step  if the file system request is a \u201cwrite\u201d type of request meaning that the application program  desires to change data in the file . If it is not, control is returned to the operating system  as shown in step . If it is a write request, the file system request monitor  accesses the look-up store  to identify the log record store  for the file  as shown in step . Next in step , the file system request monitor stores the write data in the log record store  representative of the change that application program  makes to the file  and control is returned to the operating system .","The log record store  used in the previous description is only used to log changes to the file . Entries in the log record store  would be organized in a data structure such as that illustrated in . There it is shown how the file system request monitor  tracks changes to the file . The data structure  is divided into a first field  that indicates the starting byte in the file  where the change is made, a second field  that indicates the number of bytes in the file  that were changed and a third field  that shows the actual changes that were made. Using the example shown in , the information stored in the third field  would be a binary representation of \u201c260 Madison Avenue.\u201d It should be understood that there would be a separate entry in the data structure  of the log record store  for each write request made by the application program , i.e., each time a change is made to the file .","The log record store  can also be configured to log changes for all files that may be changed by the user of the client computer . If only one log record store  is used, step  in  can be skipped. In this alternative embodiment, a fourth field  is added to the data structure  as illustrated in . Information written in the fourth field  is used to identify the file that is being changed. A new entry in the data structure  of the log record store  would be added for each change made to a file stored on the client computer  provided, however, that the file is identified as a file to be monitored in the monitor resource store .","The process described above is repeated each time the user of the client computer  indicates to the application program  to make a change to the file  or if changes are made by the application program  without any user request or intervention. As is apparent, during a session with the application program , numerous changes could be made to the file . Some of the changes may result in the same locations in the file  being changed more than once. All changes are entered in the log record store .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 5","FIG. 7"],"b":["72","50"]},"In step , a check is made to ascertain if the file under consideration is closed. The synchronization process of the present invention will only synchronize files that are not actively being used by an application program ,  or . In other words, synchronization between the client computer  copies of files and the server computer  copies of files is only performed for files that are closed. The process will synchronize all closed files that are stored locally on the client computer  and remotely on the server computer .","If the file is not closed, control passes to step  where it is determined if there are more files to synchronize. If it is determined that the file is closed, step  is executed to check the look-up store  to determine if the file being processed has been monitored for writes. If it is not, the synchronization process employs any known method\u2014such as those described in the background section\u2014to synchronize the copy of the file on the client computer  with the copy of the file on the server computer  as shown in step . Control would then pass to step  to determine if there are any additional files stored on the client computer  that need synchronization. If, however, the file being processed is a file resource designated as one to be monitored for writes, the log record store  for the file under consideration is identified in step  by accessing the look-up store . Next, the information stored in the log record store  for the file under consideration is retrieved in step . Next, an optional processing step can be performed (step ) to remove all overlapping writes to the same locations so that only the latest writes are retained. This can be accomplished using well known techniques to examine the first field  (and ) to identify entries in the data structure  that recorded writes to the same location in the file under consideration.","After step  is complete (if included), the remaining writes are then applied to the copy of the file under consideration stored on the server computer  in step . This can be accomplished using at least two different approaches. It should be understood that this description is exemplary. It is contemplated that there are other methods that are within the scope of the present invention.","One approach is to apply the writes to the copy of the file maintained on the server computer  directly from the client computer . An exemplary way to accomplish this is to maintain a mapping table of the files and directories on the client computer  that are being synchronized to the corresponding files and directories on the server computer . This is standard information that any synchronization application maintains\u2014namely the corresponding pairs of directories or files being synchronized. Using the mapping table of the files and directories on the client computer  and the server computer , the client synchronization process can directly apply the writes to the copy of the file maintained on the server computer .","A second approach would be to employ a server synchronization process on the server computer  that would manage the step of applying the writes to the copies of files on the server computer . The server synchronization process can be utilized in configurations where one or more server computers are interconnected with one or more client computers. It can reside on one of the server computers and handle all synchronization processing for the files stored on all server computers.","Under the server synchronization process approach, the client synchronization process would build a data structure like that depicted in and , depending on whether it was desired to transfer all changes for all files in one data structure () or to transfer changes in separate data structures for each file monitored (). Either way, after the data structure is built, the client synchronization process may compress the data structure(s) using known compression techniques such as those used in common commercially available compression packages like WinZip, and then transmit the data structure(s) to the server computer . When the data structure(s) is received, it is then decompressed, again using well known corresponding decompression techniques (if needed). The writes are then applied to the copies of the files maintained on the server computer  by the server synchronization process.","After the writes are applied to the copy of the file on the server computer , the log record store  for the file under consideration is removed as is the entry in the look-up store  that associated the file under consideration to the log record store  (step ). Control is then passed to step  where a check is made to determine if any more files need to be synchronized. If there are, control passes back to step  and the foregoing process is repeated for the next file. If there are no more files, the process is complete.","As explained above, when the file system request monitor  is installed, the operating system  invokes the file system request monitor  on any calls to the file system  received from any one of the application programs ,  or . In an operating system  environment such as Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me, the file system request monitor  is installed using an Application Programming Interface (\u201cAPI\u201d) hook known as \u201cIFSMgr_InstallFileSystemApiHook.\u201d Alternatively in an operating system  environment such as Windows NT\u00ae and Windows\u00ae 2000, the file system request monitor  is installed as a filter driver into the operating system . As would be understood by one skilled in the art, similar techniques can be used if the operating system  environment is an operating system such as UNIX, Solaris\u2122, or Linux.","Before describing how the file system request monitor  can be implemented in two different sets of operating systems, a description of how files may be handled by the file system request monitor  is first described. It should be understood that this description is exemplary. It is contemplated that there are other methods that are within the scope of the present invention.","The file system request monitor  monitors \u201cwrite\u201d type requests and logs them into the log record store . However, in many operating systems, including Microsoft\u00ae Windows\u00ae 95, 98, Me, and Windows NT\u00ae and Windows\u00ae 2000, the file system request monitor  would also need to monitor \u201copen\u201d and \u201cclose\u201d calls by the operating system. In many operating systems it is typical that writes and reads are made to files by first issuing an \u201copen\u201d request using the name of the file as one of the parameters of the request. The operating system then returns a unique \u201chandle,\u201d which is typically a 32 or 64 bit binary value that corresponds to the file to be used by the application for further actions. The application then makes \u201cread\u201d and\/or \u201cwrite\u201d requests to the file using the assigned file handle. As used in this manner the handle is a proxy for the file. The application then issues a \u201cclose\u201d request once it no longer needs to make requests on the file using the handle. Thus, the file system request monitor  needs to translate handles to file names, so that it can determine whether to log the particular request or not.","The following is one exemplary implementation of a mapping mechanism between file names and handles. It should be understood that this description is exemplary. It is contemplated that there are other methods that are within the scope of the present invention.","On a successful \u201copen,\u201d after verifying that the file is to be monitored by looking up the file in the monitor resource store , an entry is added into a \u201chandle-to-name\u201d translation table, which is created by the file system request monitor . The table comprises two fields, which are a handle field and a file path field. On a successful \u201cclose,\u201d the entry corresponding to the handle is deleted from the handle-to-name translation table. On a \u201cwrite\u201d request, the handle from the request is looked up in the handle-to-name translation table to locate the file name. The corresponding file name is checked against the monitor resource store  to verify that the file is to be monitored. The log record store  corresponding to the file (based upon the file name) is determined by performing a look-up operation in the look-up store . The file system request monitor  is then able to save the requested changes into the appropriate log record store .","The foregoing mapping mechanism between file names and handles can be further optimized as follows. On a successful \u201copen,\u201d after verifying that the file is to be monitored by locating the file in the monitor resource store , an entry is added to a handle table, which is created by the file system request monitor . The handle table comprises a plurality of records, each having two fields\u2014a handle for the file being monitored and the handle of the corresponding log record store . The entry added corresponds to one of the plurality of records. On a successful \u201cclose,\u201d the entry corresponding to the file name handle is deleted from the handle table. On a \u201cwrite\u201d request, the handle from the request is looked up in the handle table to locate the file name handle. The corresponding log file name handle is the file handle used for storing the write request in the appropriate log record store . The file system request monitor  is then able to save the requested changes into the appropriate log record store .","Turning now to exemplary implementations for specific operating systems, an exemplary embodiment is described for a first set of operating systems\u2014Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me. This is only meant to be exemplary. It is contemplated that there are other methods that are within the scope of the present invention.","In this exemplary embodiment, the API hook known as \u201cIFSMg_InstallFileSystemApiHook\u201d is used to insert the file system request monitor  into the operating system as a virtual device driver so that all IFSFN_OPEN (file open), IFSFN_CLOSE (file close) and IFSFN_WRITE (file write) operations are trapped for the file system request monitor . What this means is that when any of the foregoing operations are detected by the operating system  mentioned above, the file system request monitor  is invoked. For complete details concerning how to install a process in these operating systems using the API hook described above, reference is made to Stan Mitchell, 95 , O'Reilly & Associates, ISBN: 156592200X, in particular, Chapter 7\u2014\u201cMonitoring File Activity\u201d and \u201cMS-DOS\/Win32 File System Driver Reference\u201d\u2014in Microsoft Windows\u00ae 98 Device Driver Kit, which are expressly incorporated herein by reference.","When an IFSFN_OPEN is detected, the file system request monitor , when invoked in the operating system  environment of Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me, performs the following tasks:\n\n","When an IFSFN_WRITE is detected, the file system request monitor , when invoked in the operating system  environment of Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me, performs the following tasks:\n\n","When an IFSFN_CLOSE is detected, the file system request monitor , when invoked in the operating system  environment of Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me, performs the following tasks:\n\n","In an exemplary embodiment for a second set of operating systems\u2014Windows NT\u00ae and Windows\u00ae 2000\u2014the file system request monitor  is installed as a filter driver into the operating system . This is only meant to be exemplary. It is contemplated that there are other methods that are within the scope of the present invention. For complete details concerning how to install a process as a filter driver in these operating systems, reference is made to Rajeev Nagar, , O'Reilly & Associates; ISBN: 1565922492, in particular, Chapter 12\u2014\u201cFilter Drivers,\u201d Microsoft Windows NT\u00ae IFS Kit and Microsoft Windows 2000 IFS Development Kit, which are expressly incorporated herein by reference.","The file system request monitor  is triggered after layering over any local file systems through the monitor filter driver. There is a thread constantly waiting to see if a local file system has come up. When the local file system comes up, a new device is created by the file system request monitor  that attaches over the local file system using an API call known as \u201cIoAttachDeviceByPointer.\u201d This API call allows the file system request monitor  to attach over the file system calls so that all the calls going to the file system trap to the file system request monitor  giving it a chance to monitor file system calls. When any of IRP_MJ_CREATE (open file), IRP_MJ_CLOSE (close file), IRP_MJ_WRITE (write file) operations are detected by the operating system  mentioned above, the file system request monitor  is invoked.","When an IRP_MJ_CREATE is detected, the file system request monitor , when invoked in the operating system  environment of Windows NT\u00ae and Windows\u00ae 2000, performs the same tasks described above for the IFSFN_OPEN operation in the operating system  environment of Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me. Similarly, when an IRP_MJ_WRITE is detected, the file system request monitor , when invoked in the operating system  environment of Windows NT\u00ae and Windows\u00ae 2000, performs the same tasks described above for the IFSFN_WRITE operation in the operating system  environment of Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me. Also, when an IRP_MJ_CLOSE is detected, the file system request monitor , when invoked in the operating system  environment of Windows NT\u00ae and Windows\u00ae 2000, performs the same tasks described above for the IFSFN_CLOSE operation in the operating system  environment of Windows\u00ae 95, Windows\u00ae 98, or Windows\u00ae Me.","Based upon the foregoing, it should be understood by one skilled in the art that the present invention can be utilized to backup and synchronize files in a number of computing environments ranging from a single user computer that stores files on a hard drive and some form of secondary storage, e.g., a zip drive, to a corporate setting where a number of computers are interconnected to a number of server computers via an intranet. Specifically, the present invention can be used to synchronize or backup files from the hard drive of a standalone computer to a removable media drive, or to a second hard drive on the system.","Moreover, it should be apparent to one skilled in the art that the foregoing backup and synchronization processes are application independent. Because the file system request monitor  can be a part of or readily accessible to the operating system , it does not matter which type of application program is modifying files. So long as the application program is one supported by the operating system  the present invention can be employed.","Although the present invention has been described in terms of exemplary embodiments and alternatives, it will be appreciated that various modifications and alterations might be made by those skilled in the art without departing from the spirit and scope of the invention. The invention should, therefore, be measured in terms of the claims which follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 1","i":["a ","b "],"b":"1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 2","i":["a ","b "],"b":"2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 8","i":["a ","b "],"b":"8"}]},"DETDESC":[{},{}]}
