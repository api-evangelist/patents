---
title: Indexing data updates associated with an electronic catalog system
abstract: Systems and methods are provided for efficiently indexing archived objects in an archive data store to allow for efficient and quick access to the archived objects. The systems and methods provided also allow alleviate the strain on a live data store and enable a requester wishing to retrieve updates to do so without knowledge of the location of the stored update on a live or archive data store.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043311&OS=09043311&RS=09043311
owner: Amazon Technologies, Inc.
number: 09043311
owner_city: Seattle
owner_country: US
publication_date: 20111020
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Electronic catalog servers, such as those associated with large e-commerce sites, often store large quantities of catalog data to which updates are frequently made. The quantity of updates received over an extended period of time, such as several months or years, may be too large to enable the updates to be conveniently managed in a single, live data store. Therefore, a portion of the stored updates may be deleted from the live data store and moved to archive storage systems.","Users and administrators of electronic catalog systems often need to access the updates made to the catalog data, for various troubleshooting or marketing purposes. In order to facilitate access to the updates, there may be live or dynamic indexing performed on the live data store. However, such dynamic indexing may affect the throughput and performance of the electronic catalog systems, and may also require increasingly larger storage space for the dynamic index over time.","An electronic catalog server may host an electronic catalog of a variety of items available from various providers. The electronic catalog server may also provide functionality for users to acquire the items found in the electronic catalog. For example, the electronic catalog server may be part of an electronic commerce (\u201ce-commerce\u201d) site that hosts an electronic catalog of many millions of items offered for sale or otherwise made available by numerous retailers, sellers, vendors, merchants, etc. (collectively and interchangeably referred to herein as \u201cmerchants\u201d). One example of such an e-commerce site is described in U.S. Pat. No. 7,600,682, titled \u201cMarketplace System in Which Users Generate Preorder Listings Via a Definitive Product Catalog,\u201d issued on Oct. 13, 2009. Other examples of electronic catalog servers include product review sites, video\/movie rental sites, and video sharing sites.","In the example of an e-commerce site, the items available through the electronic catalog may have item data associated with them, where the item data may include one or more of price, availability, title, item identifier, item feedback (e.g., user reviews, ratings, etc.), item image, item description, and various other item attributes. The item data associated with an item may range from a few kilobytes to a few megabytes in size. The item data may be updated at various points in time, and the updates may come from various sources of item data (manufactures, sellers, retailers, other components of the electronic catalog system, etc.).","In many circumstances, a user of, an administrator of, or an application in communication with, the electronic catalog server may have a need to analyze the updates associated with a particular catalog item or group of catalog items. For example, an administrator may wish to review the updates associated with a particular item to pinpoint the source of erroneous catalog data. As another example, a merchant, analyst, or other entity may wish to analyze the price histories of particular items. In order to analyze the complete history of items, access must be provided to not only the latest updates to those items, as would be stored in a live data store, but also to the historical updates which may have been moved to an archive data store. Having an indexing scheme providing transparent access to the objects (or pointers to the updates stored in the archive data store) as well as to the updates in the live data store, allows quick response to queries from such users, administrators and applications, without affecting the performance of the electronic catalog server.","Generally described, aspects of the present disclosure relate to a system in which in the updates to an electronic catalog are organized into objects consisting of collections of records, and the objects are archived. The objects may have pointers, keys and values associated with the records within them. The system may, in some embodiments, be used to efficiently index the archived objects to allow for relatively quick access to the pointers of the records, or if requested, retrieval of the records within the objects. The indexing scheme provided by the system also allows the periodic purging of the updates indexed by a dynamic indexing system which alleviates the strain on the live data store, thereby improving the performance of the electronic catalog server. The indexing systems and methods provided also enable a requester wishing to retrieve updates associated with an item from the electronic catalog to do so without knowledge of the location of the stored update. In other words, whether the update is stored in the live data store or the archive data store, the requester submits one request to the system, and transparently receives updates or pointers to updates located on both stores.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":["100","110","130","106","106","106","106","102","102","102"]},"In the environment shown in , the requestor computing devices  may communicate with the electronic catalog server  via a communication network , such as the Internet or other communications link. Those skilled in the art will appreciate that the network  may be any wired network, wireless network or combination thereof. In addition, the network  may be a personal area network, local area network, wide area network, cable network, satellite network, cellular telephone network, etc. or combination thereof. Protocols and components for communicating via the Internet or any of the other aforementioned types of communication networks are well known to those skilled in the art of computer communications and, thus, need not be described in more detail herein.","The electronic catalog server  may be connected to or in communication with an archive data store  and a live data store . The archive data store  and the live data store  may be local to electronic catalog server , they may be remote to the electronic catalog server , and\/or they may be network-based services themselves. The archive data store  may be connected to, or in communication with querying server . A static indexing module  on the querying server  may generate one or more static indices  to index the updates stored on the archive data store . The static indices  may, in some embodiments, be stored on archive data store . In other embodiments, the static indices  may be stored on the querying server , or in another store or server illustrated in , or elsewhere, either locally or remotely.","The live data store  may include a dynamic index . The dynamic index  may be generated for the updates stored on the live data store . In the illustrated embodiment, both the archive data store  and the live data store  are connected to, or in communication with the indexing server . The indexing server  may include an index collating module  for collating the static indices  and the dynamic index . The indexing server  may also include a dynamic index purging module  to manage the size of the dynamic index .",{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","100"]},"In brief, the electronic catalog server  is generally responsible for providing an electronic catalog through a user interface in communication with various user devices, such as requestor computing device , via network . The electronic catalog provided by the electronic catalog server  may generate text and\/or graphics, possibly organized as a user interface using hypertext transfer or other protocols in response to information requests received from the various requestor computing devices .","At various points in time, the items available through the electronic catalog system  may have updates associated with them. The updates may be received from various catalog update providers. As the updates are received, they may be stored in live data store , and indexed in real-time for easy retrieval. The dynamic index  may be stored in the live data store . As more updates are stored in the live data store, and\/or over time, the updates may need to be archived and stored in archive data store . The archiving of the updates may be done in accordance with the systems and methods disclosed in U.S. patent application Ser. No. 13\/278,017, titled \u201cARCHIVING AND QUERYING DATA UPDATES ASSOCIATED WITH AN ELECTRONIC CATALOG SYSTEM,\u201d filed on Oct. 20, 2011, which is incorporated herein in its entirety (hereinafter, the \u201c'017 application\u201d).","As disclosed in the '017 application, updates may be archived in collection of records, or objects, wherein each of the records within an object may have a key representing a value associated with the item that was updated, and a version associated with the value of the updated item. The collections of records of data may be grouped together based on time, size, or some other criteria. Records may, for example, be appended to one another until the collection reaches a predetermined size, such as, for example, about a hundred to several hundred megabytes (MB). In other embodiments, the records may be grouped together until a predetermined interval of time is reached. For example, records may be successively appended for fifteen minutes, one hour, one day, or any other predetermined interval of time deemed appropriate for relevance of the update to the querying system. After the predetermined size or interval of time is reached, the collection of records may optionally be compressed.","The objects may also have metadata associated with them, which allows for the static indexing of the records. Generally, metadata may include any data used to describe aspects or properties of a given object. For example, metadata may include information identifying the date of an object's creation, the identity of its creator, whether the object has any records associated with it, or other suitable information. In some embodiments, metadata may include information indicative of usage characteristics of an object, such as the total size of records associated with an object, access history of users with respect to an object and\/or its associated records, or any other suitable information related to current or historical usage of an object. In one embodiment, each object may be associated with a respective unique identifier, which may be automatically assigned by the archive data store . Additionally, a pointer to each record within the object may be stored within the metadata or as a separate property or field of an object. In some other embodiments, a given object may include explicit references or pointers or other information corresponding to the records associated with a given object. By using the identifiers or pointers, it is possible to only decompress a specific record within the collections.","Once the updates are archived in archive data store , they can be indexed by the static indexing module  implemented by the querying server , as will be described in relation to  below. The static indexing module  may generate one or more static indices in the background and independently of activity on the electronic catalog server , and therefore without affecting the performance of the electronic catalog server . The one or more static indices  generated by the static indexing module  may then be stored in the archive data store , as illustrated in , or they may be stored on the querying server , or on another server or data store. The static indexing module  will also periodically update the one or more static indices , as described further below.","The live data store  stores item data updates received for items available on the electronic catalog, in real-time, as the updates are received. The updates may be received from a variety of sources, including, for example, from merchants wishing to sell or otherwise make items available to consumers, from administrators of the electronic catalog server , and from others. The updates may include one or more of a change in the item's price, availability, title, item identifier, item feedback (e.g., user reviews, ratings, etc.), item image, item description, item attributes, etc. The live data store  may include a dynamic index . The dynamic index  may be generated in real-time based on the updates received by the live data store .","In the illustrated embodiment, the live data store  is in communication with the indexing server . The dynamic index purging module  of the indexing server  may be used to manage the size of the dynamic index  by purging updates from the dynamic index , in accordance to a routine, an example of which is illustrated in , and will be described below.","The electronic catalog server  may make the updates available for query by catalog update providers, or administrators of the electronic catalog server . For example, a query request may be input via a requestor computing device , and received by the electronic catalog server . The electronic catalog server  may then submit the request to the indexing server . The indexing server  may then, through the index collating module , respond to the request, as will be described in relation to  below.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["130","130","204","210","202","220","224","207","206","206","130","100","204","206","204","210","202","220","220","224"]},"The memory  may contain computer program instructions that the processing unit  executes in order to implement one or more embodiments. The memory  generally includes RAM, ROM and\/or other persistent, non-transitory computer-readable media. The memory  may store an operating system  that provides computer program instructions for use by the processing unit  in the general administration and operation of the indexing server . The memory  may further include computer program instructions and other information for implementing aspects of the present disclosure. For example, in one embodiment, the memory  includes a user interface module  that generates user interfaces (and\/or instructions therefor) for display upon a computing device, e.g., via a navigation interface such as a web browser installed on the computing device. In addition to the user interface module  and operating system , the memory  may include an index collating module  and a dynamic purging module , discussed above in reference to , which may be executed by the processing unit .","While the indexing server  as depicted in  includes an arrangement of computer hardware and software components that may be used to implement aspects of the present disclosure, those skilled in the art will appreciate that the indexing server  may include many more (or fewer) components than those shown in . It is not necessary, however, that all of these generally conventional components be shown in order to provide an enabling disclosure. Those skilled in the art will also recognize that the querying server  may include some or all of the same components as the example indexing server  illustrated in .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3","b":["300","112","120","300","120","120"]},"The illustrative routine  begins at block , then proceeds to decision block , where it is determined whether a static index  needs to be generated or regenerated. As the archive data store  receives more updates from the electronic catalog server , and\/or from the live data store , there may be a need to create and\/or update the static indices  built as well. In various embodiments, the static index or indices are regenerated, and regeneration may be on a periodic or aperiodic basis, or may be interrupt driven. In some embodiments, the regeneration of each static index may be independent of other indices, while in other embodiments, all static indices may be regenerated at the same time. The periodic basis for index regeneration may be a time interval between static index generations, such hourly, daily, weekly, and the like. The periodic basis may also be a rolling basis where right after all static indices by a first to a last key are generated, the indices are regenerated starting from the first key again. The basis upon which static indices are regenerated is generally policy based, depending on the application for which the indexing would be used.","If, at decision block , it is determined that the criteria for regeneration has been reached, the routine moves to block . Otherwise, the routine ends at block . In between the creation of the static index , and the regeneration of the static index, if there are more updates received by the electronic catalog server , the updates may be indexed by a dynamic indexing module on the live data store  and stored in a dynamic index  on the live data store. The updates indexed in the dynamic index  may be kept in the dynamic index  until those updates are archived in the archive data store  and have subsequently been indexed by the static indexing module . The index collating module  enables the transparent use of the two types of indices, as is described in further detail in relation to  below.","Then, at block , the static indexing module  queries the archive data store . The query is aimed at generating a static index for a specific type of key. As disclosed in the '017 application, the query may be managed by creating a job-controlled query request store to provide persistence in the item data updates for managing queries and other metadata associated with the collections of records stored on the archive data store . In some embodiments, the metadata associated with the records may be updated to reflect the query request received. A server cluster (not shown) may also be initiated to operate a query in parallel with the archiving activities of the archive data store . The cluster then serves as the processor of the query. This enables the query to be executed without affecting the performance of the electronic catalog server . After the cluster is initiated, the query request may be translated into the appropriate format to interact with the archive data store . Once the query received is translated to the appropriate format, the query is executed and query results are received from the archive data store .","Once the query results are received by the static indexing module , the results are aggregated by the key at block . As described above, the records of updates may be keyed by one or several types of keys. The query results received are in response to a query for a specific type of key or keys, and therefore, the query results are aggregated based on the specific key(s). For example, the query request may be to find all updates associated with books, to find all updates associated with nonfiction books, or to find all updates performed on a specific date or over a specific interval of time, or other categories of items or updates. The query results received may thus be aggregated for books, for nonfiction books, for updates on a given date or a given time period, and the like. The aggregation of the query results may in some cases also include de-duplication of data from the objects retrieved. For example, a query request may include a request of the price history of an item over a period of one month. The information retrieved may include the price history of all items on a particular day, and also price history of items on all days, including days where the price history of the given item was not changed. Therefore, the aggregation of query results might include filtering out the records associated with other items during that period. The aggregation may also include removing records of the item on consecutive time periods where the price was not changed.","Once the query results are aggregated by key(s), one or more static indices  are created at block . In some embodiments, each static index  may be a read-only database or read-only object stored in the archive data store , wherein the key associated with the object in the static index  is the key by which the results were aggregated, and the value of the object in the static index  is a pointer, wherein the pointer may point to the location of the object within the archive data store . Continuing with the example above, the archive data store  may be queried for all updates pertaining to nonfiction books. When the query results are received, the static indexing module  may create an object in the static index  with the key being nonfiction books, with values corresponding to all a pointers to the object stored in the archive data store  corresponding to all updates to nonfiction books. Therefore, once such a static index  is created, if an administrator of the system later submits a query regarding updates to all nonfiction books, instead of scanning all the update records stored in archive data store  to locate the records associated with nonfiction books, the system would instead only need to locate a static index  by the key of nonfiction books among all static indices  created, and thereafter return the location of the object associated with that key, and then, if desired, retrieve only the update records of that object, as will be explained further in relation to  below.","Therefore, the creation of the static indices  allows the collections of records or objects stored in the archive data store  to be queried more efficiently, without having to scan all the objects in the archive data store . Rather, only the static indices , which have aggregated results by keys are queried, and the results of such queries can be used to then locate the relevant object records in the archive data store. The static indices created may also, in some embodiments, be compressed and encrypted. Such a static indexing scheme allows several millions and even billions of update records to be queried with minimal random-access memory (RAM) requirements, and in little time, in the order of about 100 ms or less, in some embodiments.","Once one or more static indices  are generated at block , the static indexing module  may, at block , communicate with the index collating module  to notify of the availability of the static index\/indices . In some embodiments, a Bloom filter may be created in conjunction with the static index\/indices . A Bloom filter helps to optimize the use of the indices by providing, in response to a query request from a user based on a key, an indication of whether the key exists in the index without searching the index.","It will be appreciated that certain blocks described above can be performed in a different order without affecting the objective or results achieved by the static indexing module . Alternatively, the blocks can be combined and performed in a single block. Other modifications are possible to achieve the same results without departing from the scope of the present disclosure.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","134","142","142","120","120","112","134","142","142","400","140","400","130","400","400","140","142","400","122"]},"The illustrative routine  begins at block , then proceeds to block , where the dynamic index purging module  obtains the dynamic index  from the live data store . The dynamic index  may, in various embodiments, include a list of update records stored in the live data store . The dynamic index  may be a flat file, a table, a database table, or any other type of index. The dynamic index  may also organize the updates stored on the live data store according to keys associated with the updates. As explained above, the keys may represent a category associated with the update and\/or the item associated with the item. After the dynamic index  stored on the live data store  is received by the dynamic index purging module , the routine moves to decision block , where the dynamic index purging module  verifies whether the updates indexed by the dynamic index  have been indexed by one or more static indices . In some embodiments, this determination may be based on the keys and\/or values associated with the updates. If it is determined at decision block  that the updates are indexed by a static index , then, at block , the dynamic index purging module  instructs the live data store  to purge the updates in the dynamic index . In various embodiments, the purged updates may be some or all of the updates index by the dynamic index . If, however, it is determined at decision block  that some or all of the updates are not yet indexed by a static index , then, at block , the dynamic purging module  may communicate with the index collating module  to notify it of the availability of the dynamic index . As with the static indices, in some embodiments, a Bloom filter may be created in conjunction with the dynamic index . A Bloom filter helps to optimize the use of the indices by providing, in response to a query request from a user based on a key, an indication of whether the key exists in the index without searching the index. The routine then ends at block .",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIGS. 5A-5C","b":["500","600","700","132","106","106","102","106","130"]},"Referring to , the illustrative routine  begins at block , then proceeds to block , where the index collating module  receives the query request and determines the key or keys associated with the request. As described above, an example query may be to determine all updates performed on a given date. In such an example, the date is the key associated with the request. Once the key is determined, the index collating module  determines whether the key is found in the dynamic index  at decision block . If the key is found in the dynamic index  at block , then the routine moves to block . If the key is not found in the dynamic index  at block , then the routine moves to decision block , and the index collating module  determines if the key is found in one of the static indices . If the key is found in a dynamic index  or in a static index , then at block , the index collating module  determines the value(s) associated with the key. As described above, the value in the static index  may be a pointer pointing to the location of the object in the archive data store . For example, the static index  may have a pointer to an object containing all updates provided on the given date. The value in the dynamic index  may be the update itself. Then, at block , the values, and\/or pointers, may be returned by the index collating module  in response to the query. The index collating module  thus returns the updates or pointers to the objects from both indices, which is transparent to the requestor. In other words, the requestor need not separately query the live data store  and the archive data store  in order to retrieve the requested updates. Additionally, since the search is only based on the retrieval of the index files at first, instead of searching through all update records, the response to the search query can be provided more efficiently and quickly. If the key is found in the dynamic index , the index collating module  need not query the static indices , since the most recent version of the update will be available in the dynamic index . Also, in some embodiments, if Bloom filters are created for one or more of the static and dynamic indices, the index collating module  may determine that one or more of the static and dynamic indices need not be searched, thereby optimizing the query response speed.","The response, including the updates in the live data store  and the pointers to the objects in the archive data store  may then be sent to the electronic catalog server  to forward on to the requestor computing device . Upon receipt, the requestor may submit another request to receive the updates included in the object pointed to by the pointer. The index collating module  may then retrieve the relevant update records from the archive data store  and return those to the requestor via the electronic catalog server . In some embodiments, the index collating module  may automatically retrieve the updates pointed by the pointers before returning the response to the requestor.","If the key is not found in a static index  at block , then the index collating module  notifies the requestor that the key was not found at block . As in the above, the response may be sent to the electronic catalog server  to forward on to the requestor computing device. A key may not be found in the indices if, for example, a requestor wants to find updates provided to an item which does not exist in the electronic catalog.","Referring to , the illustrative routine  begins at block , then proceeds to block , where the index collating module  receives the query request and determines the key or keys associated with the request. Once the key is determined, the index collating module  determines whether the key is found in one or more of the static indices  at decision block . If the key is found in a static index  at block , then the routine moves to block . If the key is not found in a static index  at block , then the routine moves directly to decision block . If the key is found in a static index , then at block , the index collating module  determines the value(s) associated with the key in the static index . Then, whether or not the key was found in the static index , the index collating module  determines, at block , if the key is also found in the dynamic index , in order to ensure that the most recent updates which may not have been indexed in a static index  are not missed. Then, at block , the values, and\/or pointers, may be returned by the index collating module  in response to the query. The index collating module  thus returns the updates or pointers to the objects from both indices, which is transparent to the requestor. As described above, in some embodiments, if Bloom filters are created for one or more of the static and dynamic indices, the index collating module  may determine that one or more of the static and dynamic indices need not be searched, thereby optimizing the query response speed.","The response, including the updates in the live data store  and the pointers to the objects in the archive data store  may then be sent to the electronic catalog server  to forward on to the requestor computing device . Upon receipt, the requestor may submit another request to receive the updates included in the object pointed to by the pointer. The index collating module  may then retrieve the relevant update records from the archive data store  and return those to the requestor via the electronic catalog server . In some embodiments, the index collating module  may automatically retrieve the updates pointed by the pointers before returning the response to the requestor.","If the key is not found in a dynamic index  at block , then the index collating module  notifies the requestor, at block , that the key was not found. As in the above, the response may be sent to the electronic catalog server  to forward on to the requestor computing device. A key may not be found in the indices if, for example, a requestor wants to find updates provided to an item which does not exist in the electronic catalog.","Referring to , the illustrative routine  begins at block , then proceeds to block , where the index collating module  receives the query request and determines the key or keys associated with the request. Once the key is determined, the index collating module  determines whether the key is found in one or more of the static indices  and\/or the dynamic index  at decision block . If the key is found in one or more of the indices, then the routine moves to block . If the key is not found in either index, then the routine moves to block . At block , the index collating module  determines the value(s) associated with the key in the static index  and\/or the dynamic index  by aggregating the results found in both indices. Then, at block , the values, and\/or pointers, may be returned by the index collating module  in response to the query. The index collating module  thus returns the updates or pointers to the objects from both indices, which is transparent to the requestor. As described above, in some embodiments, if Bloom filters are created for one or more of the static and dynamic indices, the index collating module  may determine that one or more of the static and dynamic indices need not be searched, thereby optimizing the query response speed.","The response, including the updates in the live data store  and the pointers to the objects in the archive data store  may then be sent to the electronic catalog server  to forward on to the requestor computing device . Upon receipt, the requestor may submit another request to receive the updates included in the object pointed to by the pointer. The index collating module  may then retrieve the relevant update records from the archive data store  and return those to the requestor via the electronic catalog server . In some embodiments, the index collating module  may automatically retrieve the updates pointed by the pointers before returning the response to the requestor.","If the key is not found in either index at block , then the index collating module  notifies the requestor, at block , that the key was not found. As in the above, the response may be sent to the electronic catalog server  to forward on to the requestor computing device. A key may not be found in the indices if, for example, a requestor wants to find updates provided to an item which does not exist in the electronic catalog.","It is to be understood that not necessarily all objects or advantages may be achieved in accordance with any particular embodiment described herein. Thus, for example, those skilled in the art will recognize that certain embodiments may be configured to operate in a manner that achieves or optimizes one advantage or group of advantages as taught herein without necessarily achieving other objects or advantages as may be taught or suggested herein.","All of the processes, including but not limited calculation processes, described herein may be embodied in, and fully automated via, software code modules executed by one or more general purpose computers or processors. The code modules may be stored in any type of computer-readable medium or other computer storage device. Some or all the methods may alternatively be embodied in specialized computer hardware. In addition, the components referred to herein may be implemented in hardware, software, firmware or a combination thereof.","Conditional language such as, among others, \u201ccan,\u201d \u201ccould,\u201d \u201cmight\u201d or \u201cmay,\u201d unless specifically stated otherwise, are otherwise understood within the context as used in general to convey that certain embodiments include, while other embodiments do not include, certain features, elements and\/or steps. Thus, such conditional language is not generally intended to imply that features, elements and\/or steps are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding, with or without user input or prompting, whether these features, elements and\/or steps are included or are to be performed in any particular embodiment.","Any process descriptions, elements or blocks in the flow diagrams described herein and\/or depicted in the attached figures should be understood as potentially representing modules, segments, or portions of code which include one or more executable instructions for implementing specific logical functions or elements in the process. Alternate implementations are included within the scope of the embodiments described herein in which elements or functions may be deleted, executed out of order from that shown, or discussed, including substantially concurrently or in reverse order, depending on the functionality involved as would be understood by those skilled in the art.","It should be emphasized that many variations and modifications may be made to the above-described embodiments, the elements of which are to be understood as being among other acceptable examples. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 5A-5C"}]},"DETDESC":[{},{}]}
