---
title: Yet another transformation language (YATL)
abstract: A practical language for writing analysis and transformation tools for C/C++ and other languages is provided. This language, YATL, is imperative in style and designed to be easy to use for someone familiar with the grammar of the target language. It allows the developer to describe transformations with reference to elements of the target grammar through a pluggable personality to a compiler. This provides the means for powerful, yet easy to write, transformation programs, while fundamentally remaining language agnostic.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08813047&OS=08813047&RS=08813047
owner: Alcatel Lucent
number: 08813047
owner_city: Boulogne-Billancourt
owner_country: FR
publication_date: 20050908
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE INVENTION","1 Introduction","2 YATL Compiler and Back-End","3 Variables And Types","4 Rules And Functions","5 Flow Control","6 Code Construction and Replacement","7 Access to the YATL Run-Time","8 Example","8 Programming with YATL","Computer Program Listing Appendix","Computer Program Listing Appendix","Computer Program Listing Appendix","10 Conclusion"],"p":["The present invention relates generally to the field of computer software and, in particular, relates to meta-programming and domain-specific programming languages for writing source code transformations.","The proliferation of large and complex computer programs has made source code transformation solutions increasingly attractive. Source code transformations are a form of meta-programming. Machine drive analysis and modification can relieve the manual developer of much of the burden of repetitive change. However, for source code transformation to be successful, the developer must be able to clearly define what and how modifications should be made. Herein lies the need for a transformation programming language.","Existing languages cannot attain high-fidelity. Many existing languages require expertise in the use of functional or other programming paradigms that are not intuitive for developers familiar with procedural languages. Existing languages are too generalized and focus on rewriting abstract syntax trees (AST) in a general form, without any provision for target language awareness in the transform language, resulting in a lack of expressiveness. Existing languages are not sufficiently powerful and flexible. Existing languages are based on the specification of rules in the form of predicates and actions. This limits the usefulness of the language and the ability to perform auxiliary calculations.","Various deficiencies of the prior art are addressed by various exemplary embodiments of the present invention of a programming language, YATL, for writing source code transformation tools for a target language, such as C\/C++.","One embodiment is a method for generating analysis and transformation tools. One or more YATL program(s) for transforming ASTs are stored on a storage medium. The ASTs correspond to target source code. The YATL program(s) are compiled to produce one or more transformation program(s). The transformation program(s) are executed with the ASTs as input to produce a number of transformed ASTs. The YATL program includes a tree traversal routine having access to a target symbol table. The target symbol table holds symbols from the target source code, where each symbol is associated with a unique scope identifier. A scope is a programming language term to denote a range of existence for a symbol.","Another embodiment is a system for generating analysis and transformation tools, including YATL programs, a YATL compiler, a YATL parser, a run time, one or more storage device(s), and a processor. The YATL compiler compiles the YATL programs and the YATL parser parses the YATL programs using a YATL grammar. The run time is an environment for executing YATL programs. The storage device(s) store the YATL programs, YATL compiler, YATL parser, and run time. The processor compiles and executes the YATL programs. The YATL programs operate on ASTs to produce transformed ASTs. One of the YATL programs includes a tree traversal routine that has access to a target symbol table. The target symbol table holds symbols from the target source code, where each symbol is associated with a unique scope identifier. The YATL program includes an \u201con\u201d construct for altering a tree temporarily for a single action, a \u201cusing\u201d construct for altering a tree for the duration of a compound statement, and a variable reference construct for permanently altering a tree across rules and functions.","Another embodiment is a computer-readable medium that stores instructions for performing a method for generating analysis and transformation tools. The instructions include a YATL program that has one or more statement(s). Each statement is one of the following: a rule, a function definition, a callback function definition, a preprocessor directive, or a Stratego program. The rule includes \u201crule\u201d followed by an identifier, rule parameters, and a compound statement. The function definition includes \u201csub\u201d followed by the identifier, function parameters, and the compound statement. The compound statement includes at least one YATL statement optionally followed by an else clause. The YATL program includes a tree traversal routine having access to a target symbol table. The target symbol table holds symbols from a target source code, where each symbol is associated with a unique scope identifier.","To facilitate understanding, identical reference numerals have been used, where possible, to designate identical elements that are common to the figures.","The invention will be primarily described within the general context of an exemplary embodiment of a programming language, YATL, for writing source code transformation tools for any kind of target language, such as C\/C++. However, those skilled in the art and informed by the teachings herein will realize that the invention encompasses obvious changes in grammar and syntax and is directed to the broad concepts implemented by the exemplary grammar, syntax, and constructs described. Exemplary embodiments of YATL have a wide variety of applications in automated source transformation, including redundant code removal, dead code removal, code refactoring, platform and application programming interface (API) migration, debugging, instrumentation and fault detection, performance analysis instrumentation, bug rectification, source code watermarking, security hole identification, software fortification, and many other applications.","An exemplary embodiment of a programming language, YATL, for writing source code transformation tools for a target language, such as C\/C++ is provided. YATL allows developers to specify and realize algorithms that both analyze and transform source code. Developers use YATL to write tools that perform analysis and modification of abstract syntax trees and their hybrid forms. YATL allows the developer to describe transformations with reference to elements of the target language grammar, making powerful transformation easy to specify. YATL is target language agnostic through a compartmentalized piece of syntax that can be implemented as a pluggable \u201cpersonality\u201d of the compiler. YATL is PERL-like in style, e.g., typeless and procedural. Unlike existing code transformation languages, YATL does not require any prior knowledge of computation linguistics and transformation programming techniques. Writing YATL transformations is intended to be easy for anyone who can write C and C++ programs.","In this exemplary embodiment, a YATL system provides primitives and run-time support for many capabilities, including the following: template-based searching of program constructs (through tree traversal) specific to the target language; program construction through templates and\/or by example; basic flow control and failure handling; basic data handling (e.g., integers, strings, lists); extensibility through direct access to the back-end intermediate representation (e.g., Stratego and C); access to underlying operating system facilities (e.g., console I\/O); and support for target language symbol tables, among others.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","114","116","118","120","122"]},"In this exemplary embodiment, the YATL compiler takes YATL programs and builds a transformation tool executable. Some exemplary command line options for the YATL compiler include generating only backend (e.g., Stratego) code, not using precompiled binaries for run-time, specifying an input source file, specifying output file, whether to keep intermediate files, optimization levels, and whether to turn on debugging.","An exemplary process for using the meta-programming environment is as follows. A source program is given (e.g., myprog.cpp). Then, the YATL program is written (e.g., simple.yatl). The transformation tool is generated (e.g., simple). An XML project file is created that coordinates the execution of the transformation tool with respect to the target source files. The tool (e.g., simple) is executed, which applies the transformation to the source program. Transformed programs are output to the output file (e.g., myprog.cpp.out). Each of the tools that are generated from the YATL compiler is a stand-alone executable in themselves. They are designed to be efficient and tailored for rapid execution.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIGS. 2A","FIG. 2A","FIG. 2B","FIG. 2B","FIG. 2C"],"b":["2","2"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 3A-3Q","FIGS. 3A-3Q"]},"Automated source code transformation (a\/k\/a source transformation) is defined as the machine executed modification of program source code that is directed by automated program analysis. As a software development paradigm, source code transformation can be used to generate tools that reduce time-frames and lower costs for a wide array of software maintenance tasks. Examples include software migration (porting), debugging, and profiling instrumentation, redundant code removal, security vulnerability remediation and design refactoring (e.g., conversion to object-oriented design).","For many companies, a significant portion of software development is done in the C and C++ programming languages. Furthermore, it is source code written in these two languages that is predominantly involved in the software maintenance tasks listed above.","The term target language means the language that is the subject of transformation and the term transformation language describes the meta-programming language itself (i.e., YATL). Furthermore, the phrase source code transformation means a class of meta-programming that includes both static analysis and program modification.","In one embodiment of YATL, design considerations included the degree that the language allows a developer to express his or her intent with respect to the domain (e.g., source code transformation); how much of the functionality of the program is expressed by its source code, the extent that the language naturally allows the developer to avoid repetition and excess levels of verbosity, and how intuitive the language is to the user. Many existing transformation languages are target language agnostic; that is they are designed for writing transformations on nay target language. Examples include TXL and Stratego. Such generic languages are often cumbersome to use practically because making reference to elements of the target language grammar is difficult to do.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4","b":["400","402","402","404","406"]},"Stratego's ability to interface with native functions, written in C, provides excellent means for extensibility. Most of the back-end logic of Proteus was implemented in Stratego or C, with some elements in YATL itself. Other embodiments may be implemented in many other kinds of code.","One exemplary embodiment of YATL is typeless; there is no type-checking by the compiler. All data is represented as an ATerm tree (or a forest of trees). Variables are not declared, but like PERL, memory is allocated when the variable is first used. All variable identifiers are prefixed with \u2018$\u2019. An exemplary code excerpt for variable initialization is shown in Table 1.",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for variable initialization"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* variable initialization *\/",{}]},{"entry":[{},"$v = \u201creturn to sender\u201d;","\/\/ string"]},{"entry":[{},"$w = 4;","\/\/ basic integer"]},{"entry":[{},"$x = |[1,2,3]|;","\/\/ list"]},{"entry":[{},"$z = 3.1243;","\/\/ real number"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment, introspection, which allows one to determine the type of data, is supported through method call style invocations on the variables. An exemplary code excerpt for variable introspection is shown in Table 2.",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for variable introspection"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/* variable introspection *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ($v.is_string( ))","{ print \u201c$v is a string\u201d; }"]},{"entry":[{},"if ($v.is_list( ))","{ print \u201c$v is a list\u201d; }"]},{"entry":[{},"if ($v.is_int( ))","{ print \u201c$v is an integer\u201d; }"]},{"entry":[{},"if ($v.is_real( ))","{ print \u201c$v is a real number\u201d; }"]},{"entry":[{},"if ($v.is_blob( ))","{ print \u201c$v is a blob\u201d; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"elsif ( ! $v.is_assigned( )) {print \u201c$v is not assigned\u201d; }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment, the basic YATL types are string, list, integer, real number and blob (size, buffer pair). Other embodiments can have many different kinds of types.","3.1 Working with Trees","In this exemplary embodiment, the basis for transformation in this embodiment of YATL is the modification of target program representations in the form of abstract syntax trees (ASTs). At any point in a YATL program, there is the notion of the current tree, i.e., the piece of data that is being modified. The piece of data is a tree representing a program in whole or in part. The current tree is accessible through the special variable $_. If the YATL programmer wishes to change the subject of modification, the programmer can either alter the current tree by explicit assignment to $_ or temporarily modify the subject of transformation through YATL's \u201con\u201d construct. The \u201con\u201d construct modifies the subject of transformation for the duration of the associated compound scope. The language term scope means the logical range of a program construct. The variable entry in the symbol table is updated at termination of the scope. An exemplary code excerpt for accessing the current tree is shown in Table 3.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for accessing the current tree"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2002on-file \u201c*.*\u201d {"]},{"entry":[{},"\u2002\u2002\/* current tree is the term for the whole file *\/"]},{"entry":[{},"\u2002\u2002$result = check-file($_);"]},{"entry":[{},"\u2002\u2002\/* temporarily use result tree *\/"]},{"entry":[{},"\u2002\u2002on $result {"]},{"entry":[{},"\u2002\u2002\u2002if (match (Id:)) { print \u201cYes\u201d; }"]},{"entry":[{},"\u2002\u2002\u2002else { print \u201cNo\u201d; }"]},{"entry":[{},"\u2002\u2002}"]},{"entry":[{},"\u2002\u2002\/* tree is back to original file tree *\/"]},{"entry":[{},"\u2002}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 6A","FIG. 6B","FIG. 6A","FIG. 6B"],"b":["600","602","604","606","608"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6A","b":["600","600"]},{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for modifying a whole current tree 600"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"match (Id:{\u2018x}) {"]},{"entry":[{},"}"]},{"entry":[{},"\/* matches the whole current tree against a tree formed by the Id"]},{"entry":[{},"super-type *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Alternatively  illustrates modification by reference this exemplary embodiment of YATL through the on primitive, which allows making reference to one or more subtrees  within the current tree, as marked by a YATL pointer . Table 5 illustrates statements executed on each subtree marked by pointer p.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for executing statements on subtrees 504"},{"entry":"marked by pointers 606."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"on *p {"},{"entry":"\u2002match(ID:{\u2018x}) {"},{"entry":"\u2002}"},{"entry":"}"},{"entry":"\/* performs the match on the two subtrees within the current tree that are"},{"entry":"marked by pointer p *\/"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary embodiment, when data is assigned to a YATL variable, a copy of the right-hand side tree is made. Replication of trees in this way is made efficient through the ATerm maximal sharing mechanism. This mechanism minimizes memory footprint by careful reuse of subtrees and a copy-on-modification scheme. As a result, the overhead of pass-by-value is not a concern to the YATL programmer.","An alternative method of data passing in this exemplary embodiment is pass-by-reference. This is facilitated by YATL pointers, which are prefixed with *. Pointers are implemented as annotations on the tree, which can be used to locate a given subtree at a later point in time.","In this exemplary embodiment, there are two types of YATL pointers: local and global. Local pointers are unique, i.e., the annotation is different for each assignment. De-referencing local pointers always results in zero or one iterations. Global pointers are prefixed with *:: and use the exact same annotation for each assignment. De-referencing a global pointer results in zero or more iterations. The global pointer is useful for marking a series of constructs of interest and, then, performing some action on all of them.","The \u201con\u201d construct is also used to change the subject f transformation to that pointed to by the given pointer. However, when pointer arguments are used with the \u201con\u201d construct, the primitive is implemented as a traversal on the current tree, matching on the respective pointer annotation. Hence, the current tree must contain the annotated subtree for the de-reference to be successful. An exemplary code excerpt for setting a pointer to the current tree is shown in Table 6.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for setting a pointer to the current tree"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"*p = $_; \u2003\u2003\/* set a pointer to the current tree *\/"]},{"entry":[{},". . ."]},{"entry":[{},"on *p {"]},{"entry":[{},"\u2002print \u201cFound tree again $_\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment, variables in YATL cannot be explicitly deleted. The ATerm garbage collection system frees any unused memory. However, pointer annotations can be deletable through an explicit application of the rule clearptr that traverse the tree and removes the appropriate annotations. An exemplary code excerpt for applying the rule clearptr is shown in Table 7.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for applying the rule clearptr"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"apply clearptr(*::p); \/* clears *::p from current tree *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, YATL variables can be directly used within strings, like PERL. If the variable is not assigned, then the replaced text will be empty. To protect a \u201c$\u201d from interpolation, a \u201c\\\u201d is prepended. An exemplary code excerpt for this protection is shown in Table 8.",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for protecting \u201c$\u201d from interpolation"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"print \u201cThe value of \\$v = $v\\n\u201d;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"However, variable interpolation does come at a cost, because the string is actually assembled at runtime. Therefore, some embodiments avoid interpolation for constant strings. For example, the following exemplary code excerpt shown in Table 9 is not ideal.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for constant string interpolation"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$version = 1.0;"]},{"entry":[{},"$header = \u201cProteus Version $version\u201d;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, YATL variables are implemented as ATerm trees. Trees are put together to form a tuple. Given three individual trees, A, B and C, a single tuple term (A,B,C) is constructed. The reverse process is deconstruction, which splits a tuple into its constituents. Tuple deconstruction fails if the arity is incorrect. In this exemplary embodiment, the YATL syntax for tuple construction and deconstruction is shown in the following exemplary code excerpt in Table 10. Construction and deconstruction is useful for returning data from functions that, by design, only return a single term value.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for tuple construction and deconstruction"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$mytuple = @ (0,1,$v);","\/* construction *\/"]},{"entry":[{},"? ($zero,$one,$v) = $mytuple;","\/* deconstruction *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, YATL support basic integer arithmetic. A summary of the supported operators in this exemplary embodiment is shown in Table 11. Other embodiments support various other classes and operators and have varying orders of precedence.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Basic Integer Handling"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class","Operators (in order of precedence)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Arithmetic expressions","( ), %, *, |, +, \u2212"]},{"entry":[{},"Conditional expressions","<, >, <=, >=, !=, =="]},{"entry":[{},"Logical expressions","&&, ||, !"]},{"entry":[{},"Postfix operators","++, \u2212\u2212"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment, YATL programs are modularized through the use of rules and functions. Rules are defined by the keyword \u2018tifamily rule\u2019 and functions are defined by the keyword \u2018tamily sub\u2019. Rules can be thought of as syntactic sugar for functions that take the current tree as a parameter and assign the result to the current tree. Rules are called through the apply primitive. They differ from functions in that they inherently act upon the current tree, e.g., invisibly passed as the first parameter. The main rule serves as the entry point to the transformation.","In this exemplary embodiment, calls to functions may also include the current tree, but this must be explicitly passed as a parameter. Furthermore, functions have no effect on the current tree unless the result of the call is explicitly assigned to the current tree variable $_. The following code excerpt in Table 12 illustrates the use of rules and functions to modify the current tree.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for using rules and functions to modify the"},{"entry":"current tree"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"rule main($v)"},{"entry":"{"},{"entry":"\u2003apply myTransform1($v); \u2003\u2003\/* these are equivalent *\/"},{"entry":"\u2003$= myTransform2($_,$v);"},{"entry":"}"},{"entry":"rule myTransform1($p)"},{"entry":"{"},{"entry":"\u2003if (match-once(String:{$p})) { $= \u201cbye\u201d; }"},{"entry":"}"},{"entry":"sub myTransform2($prog, $p)"},{"entry":"{"},{"entry":"\u2003$= $prog; \u2003\u2003\/* explicitly make a parameter the current term *\/"},{"entry":"\u2003if (match-once(String:{$p})) { $p})) { $= \u201cbye\u201d; }"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary embodiment, both rules and functions support parameters. Parameters specified on the main rule correspond to command line parameters. For instance, in the above excerpt in Table 12, the main rule parameter $v corresponds to a command line parameter \u2212v<s>, where string s is assigned to the variable $v.","4.1 High-Order Rules and Functions","In this exemplary embodiment, rules and functions can also be passed as parameters to other rules and functions. The prefixes sub:: and rule:: are used to disambiguate an identifier (rule is assumed by default). Of course, conventional parameters (variables and pointers) can be passed in addition to functions and rules. An example is shown in the code excerpt in Table 13.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for rules and functions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003callme(sub::hello);"]},{"entry":[{},"}"]},{"entry":[{},"sub callme(sub::instruction)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003instruction( ); \u2003\u2003\/* make a call to the passed function *\/"]},{"entry":[{},"}"]},{"entry":[{},"sub hello"]},{"entry":[{},"{"]},{"entry":[{},"\u2003print \u201cHello there\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"5.1 Execution Failure","Many programming languages support controlled failure (typically called exceptions). These program failures are from a logical point of view in that the program and\/or machine did not actually fail; they are simply a means of handling unexpected events.","In this exemplary embodiment, all statements in YATL, including function calls and rule applications, can fail. Failure is caused either by an explicit fail statement or through a failing primitive (e.g., match-once). Failures can be trapped through the try\/catch, either\/or and else constructs. Table 14 shows an exemplary code excerpt illustrating catching failures.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for catching failures"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/* three ways to catch failure *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003try {","apply X;","}","\/* method 1 *\/"]},{"entry":[{},"\u2003catch {","error(\u201cRule X failed\u201d);","}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003apply X;","\/* method 2 *\/"]},{"entry":[{},"\u2003else error(\u201cRule X failed\u201d);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003either (","apply X;",")","\/* method 3 *\/"]},{"entry":[{},"\u2003or {","error(\u201cRule X failed\u201d);","}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment, failures are also propagated until they are caught. The following exemplary code excerpt in Table 15 shows how failure is propagated outwards through nested scopes and also across applied rules.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for propagating failure"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003try {"]},{"entry":[{},"\u2003\u2003apply foo;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003catch {"]},{"entry":[{},"\u2003\u2003will_execute( );"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"rule foo"]},{"entry":[{},"{"]},{"entry":[{},"\u2003try {"]},{"entry":[{},"\u2003\u2003if (true) {"]},{"entry":[{},"\u2003\u2003\u2003fail; \u2003\u2003\/* explicit fail *\/"]},{"entry":[{},"\u2003\u2003\u2003will_not_execute( );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003will_not_execute( );"]},{"entry":[{},"\u2003}"]},{"entry":[{},"catch {"]},{"entry":[{},"\u2003\u2003will_execute( );"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"However, the loop primitives while and for will not fail, because the semantics are to loop while the condition exists, irrespective of the state of the action, as shown in Table 16.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt illustrating loops and failure"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003while(true) {"]},{"entry":[{},"\u2003\u2003will_execute( );"]},{"entry":[{},"\u2003\u2003fail;"]},{"entry":[{},"\u2003\u2003will_never_execute( );"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003will_execute( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"For clarity, the keyword continue in the exemplary embodiment of YATL can be used to continue execution without action. This primitive should not be confused with the C continue primitive, which breaks the current execution path and moves to the next iteration of the loop.","5.2 Traversals","Because YATL data is realized as ATerm trees in this exemplary embodiment, constructs that provide tree traversals and manipulation of subtrees are useful.","5.2.1 Matching and Traversal Primitives","Source code transformation languages need the ability to match upon elements of programs (i.e., trees) by traversed repetitive testing. In this exemplary embodiment of YATL, tree equality can be tested through the eq operator or through the using\/match operators. Integer trees can also be tested with the simple conditional operator ==. Tables 17 and 18 illustrate different variations on the same semantics for traversal constructs.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 17"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Traversal Constructs"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Construct","Traversal","Fails"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["match","Direct match without traversal","Yes"]},{"entry":["foreach-match","Top-down left-to-right continual","No"]},{"entry":["foreach-match-rl","Top-down right-to-left continual","No"]},{"entry":["match-once","Top-down left-to-right until action succeeds","Yes"]},{"entry":[{},"on matched tree"]},{"entry":["match-once-rl","Top-down right-to-left until action succeeds","Yes"]},{"entry":[{},"on matched tree"]},{"entry":["foreach-match-","Bottom-up left-to-right continual","No"]},{"entry":"bottomup"},{"entry":["match-once","Bottom-up left-to-right until action succeeds","yes"]},{"entry":["bottomup","on matched tree"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary cod excerpt for matching and traversal."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$x = 1;"},{"entry":"$y = 1;"},{"entry":"if (eq($x,$y)) { print \u201cX is the same as Y\u201d; }"},{"entry":"\/* the using primitive indicates that the subject of the match is $x *\/"},{"entry":"if (using $x match($y)) { print \u201cX is the same as Y\u201d; }"},{"entry":"if ($x == $y) { print \u201cX is the same as Y\u201d; }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary embodiment, the match primitive is designed to be used with super-types. It assumes a match against the current term, unless the \u201cusing\u201d construct is used to explicitly specify the subject of comparison.","This exemplary embodiment of YATL also provides a number of basic traversal primitives as shown in Table 17. These traversals fulfill most of the transformation program needs. In line with the semantics of this exemplary embodiment of YATL's basic looping constructs, continual traversal (e.g., foreach-match) will not fail, while once traversals (e.g., match-once) will fail, if a match is unsuccessful.","Other embodiments include more complex traversals, but these basic traversals are sufficient for many transformation applications.","5.2.2 Super-Types","In this exemplary embodiment of YATL, the underlying trees are manipulated by YATL meta-programs. The underlying trees are inherently complicated, due to the complexity of the target language grammar (e.g., C\/C++) and the augmentation of the basic AST with literal and layout information (e.g., commenting, white space). YATL super-types provide the abstraction over this detail. Super-types are orthogonal to the core YATL language and implemented as a plug-in compiler personality, in this exemplary embodiment.","Each super-type supports parameters that are used to define concrete values that must hold for a match to succeed. The parameters as also used to make copies into variables and to bind pointers to elements of the matched tree. The basic syntax for super-type matching is shown in Table 19 and an example is shown in Table 20.",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 19"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary syntax for super-type matching"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<match-construct>(<super-type>) {"]},{"entry":[{},"\u2003<actions>"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for super-type matching"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"match (FunctionCall:{\u2018foo}<function_name>,{0}<...>) {"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In Table 20, the example matching super-type will match on all calls to a function named foo with exactly one parameter that is a decimal literal zero. The generated Stratego matching strategy, which is congruent, is given in table 21.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 21"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Stratego matching strategy"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FunCall(apply-rightmost(?Id(\u201cfoo\u201d)),?_,?_,?_,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003[(?DecimalLit(\u201c0\u201d,_,_))|?_],?_,?_)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The generated Stratego is less intuitive for a user of imperative languages to understand. Furthermore, this exemplary embodiment of YATL is able to abstract upon the complexity of the hybrid AST that contains augmented layout information. The generated Stratego code must specify actions for all nodes in the subject tree. ?_ is effectively a matching wildcard on the layout nodes.","YATL variables can be used to define concrete values for super-types, in this exemplary embodiment. Furthermore, subtrees of a given match can be bound to YATL variables or marked with a YATL pointer. The exemplary code excerpt in Table 22 de-references the variable $f as a concrete value for the function name, while making a copy of the parameter subtree into variable $p and setting a pointer *q to the same subtree in the original tree.",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 22"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for using variables to define concrete values"},{"entry":"for super-types"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"match(FunctionCall:($f)<function_name>,{=$p,=*q}<...>) {"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This exemplary embodiment of YATL also provides support for basic loops and branching. In all of these primitives, the associated compound statement must be encapsulated with { and} (no potential for dangling else). Table 23 summarizes the loop and branching constructs in this exemplary embodiment of YATL.",{"@attributes":{"id":"p-0089","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 23"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Loop and Branching Constructs"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Construct","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"else","Single statement failure handling"]},{"entry":[{},"if\/elsif\/else","Condition branching"]},{"entry":[{},"either\/or","Sequentional test branching"]},{"entry":[{},"for\/while","Pre-conditional looping"]},{"entry":[{},"do\/while","Post-conditional looping"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"As well as performing identification of program elements, transformations typically replace existing code with new code, in this exemplary embodiment. This requires the ability to construct new program elements. This exemplary embodiment of YATL supports program construction through build super-types. There are two classes of build super-types: concrete and free-text. Concrete super-types use a predefined free template together with a number of concrete values (literal or variable) to form the respective tree. The syntax is the same as that when super-types are used for matching.","Build super-types are used with the new construct. This is the basic primitive for creating new trees. For example, the following excerpt in Table 24 illustrates the construction of a function call using the FunctionCall super-type.",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 24"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for construction of a function call"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$p = 0;"]},{"entry":[{},"$newfc = new (FunctionCall:{\u2018foo},{\u201chello\u201d<:str>},{$p};"]},{"entry":[{},"\/* generates function call *\/"]},{"entry":[{},"foo(\u201chello\u201d,0);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Concrete super-types are useful for building smaller elements of code, but become cumbersome when constructing larger program fragments. Free-text super-types provide a mechanism for building such elements in this exemplary embodiment of YATL. Free-text super-types allow the YATL programmer to use an excerpt of code (i.e., by example) to construct a new program tree. Free-text super-types can also be embedded with YATL variables that will be later interpolated. There are three free-text super-types for this exemplary embodiment of YATL: FreeStatement, FreeExpression and FreeCompound. The program excerpt passed to these super-types must conform to the target language grammar for a statement, expression and compound statement, respectively. Table 25 illustrates with the following code excerpt.",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 25"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt illustrating free-text super-types"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$x = new (FreeStatement : {\u201cif (x>$p) exit (0);\u201d});"]},{"entry":[{},"$y = new (FreeExpression : {\u201c(x > $p)\u201d});"]},{"entry":[{},"$z = new (FreeCompound : {\u201c{ if (x>$p) exit(0); }\u201d});"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"When free-text super-types are used with multi-line programs, the left-hand margin is marked with a colon. This is used as the reference point for intelligent indentation performed by the system during the insertion process, as shown in Table 26.",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 26"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for multi-line programs"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$p = 0;"]},{"entry":[{},"$z = new (FreeStatement : {\u201c:if (x>$p)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},": exit(0);\u201d});"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* create the program *\/"]},{"entry":[{},"if (x>0)"]},{"entry":[{},"exit(0);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This exemplary embodiment of YATL provides a number of constructs for adding and removing subtrees (i.e., program elements) in the target code. Deletion and insertion is done with reference (at, before or after) to a previously established pointer. The following exemplary code excerpt in Table 27 illustrates the use of statement insertion and deletion.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 27"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for insertion and deletion"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* delete last statement assigned to p *\/"]},{"entry":[{},"delete-statement at *p;"]},{"entry":[{},"\/* delete all statements assigned to q *\/"]},{"entry":[{},"delete-statement at *::q;"]},{"entry":[{},"\/* insert statement w.r.t. pointers p and q *\/"]},{"entry":[{},"insert-statement new (FreeStatement : { \u201cexit(0);\u201d}) after *p;"]},{"entry":[{},"insert-statement new (FreeStatement : { \u201cexit(0);\u201d}) before *q;"]},{"entry":[{},"insert-statement $z before *::q;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment of YATL, the insert-statement and delete-statement primitives depend upon the given pointers marking a valid statement, as opposed to a subtree within a statement, which was a common mistake for developers learning YATL. If the pointer parameter cannot be located at the appropriate level of subtree, then the insertion\/deletion will be successful and, furthermore, no failure will occur.","Subtrees can also be rewritten through explicit assignment, as shown in Table 28.",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 28"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for explicit assignment of subtrees"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"match-once (TypeSpec : {\u2018ULONG}) {"]},{"entry":[{},"\u2003$= new (TypeSpec : {\u2018unsigned}, {\u2018long});"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"However, replacement by assignment has to be done carefully to ensure that the new tree is the same form as the tree being replaced, in this exemplary embodiment. If not, a malformed tree will result. Malformed trees may appear to be correct from the built output, but they may nevertheless cause problems (through misinterpretation) in a later stage of transformation.",{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 29"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for malformed trees"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"match-once (FunctionCall : {\u2018foo}) {"},{"entry":"\/* DANGER : mal-formed tree will result *\/"},{"entry":"\u2003$= new (FreeStatement : {\u201cgoo( );\u201d});"},{"entry":"}"},{"entry":"\/* correct form *\/"},{"entry":"foreach-match (ExprStatement :) {"},{"entry":"\u2003if ($first==1 && match-once(FunctionCall : {\u2018foo})) {"},{"entry":"\u2003\u2003\/* replace current expression statement with a new statement *\/"},{"entry":"\u2003\u2003$= new (FreeStatement : {\u201cgoo( );\u201d});"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment of YATL, replacement through explicit assignment is often desirable, because replacement through explicit assignment allows modification with respect to the current tree as opposed to a pointer reference. YATL also supports a primitive called replace-with that allows a single statement as the current tree to be replaced by one or more new statements. Table 30 shows an example.",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 30"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for replace-with"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"foreach-match (Statement:) {"},{"entry":"\u2003if (match-once(FunctionCall:{\u2018foo})) { \/* statement contains foo *\/"},{"entry":"\u2003\u2003\/* current tree is a statement tree *\/"},{"entry":"\u2003\u2003replace-with new (FreeStatement:{\u201c:lock( );"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},": $"]},{"entry":[{},": unlock( );\u201d});"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The replace-with construct is implemented through a technique known as term mutation. The basic idea is that a single term is temporarily replaced by another single term of the form Mutant (I) where I is a list of new terms that will ultimately replace the Mutant term. The replacement is actually performed when the outer context is made available to the transformation engine.","This exemplary embodiment of YATL includes a run-time. The YATL run-time provides auxiliary support for transformations. This includes logic specific to the target language (e.g., scoping rules, symbol tables) as well as access to the underlying operating system services (e.g., file I\/O).","7.1 Native Constructs","In this exemplary embodiment, the YATL programmer may need to implement part of a transformation directly in the underlying Stratego language, in some cases. This is facilitated through native constructs. Single statements are defined with the native keyword, while complete rules and functions are defined by encapsulating the native code in %{ and %}. Table 31 is an exemplary code excerpt illustrating native constructs.",{"@attributes":{"id":"p-0109","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 31"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for native constructs"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003native \u201ctest(map(?Id(_)))\u201d;"]},{"entry":[{},"\u2003nativeFunc($_);"]},{"entry":[{},"}"]},{"entry":[{},"%{"]},{"entry":[{},"\u2003nativeFunc = ?t ; <printnl>(stderr, [\u201cTerm=\u201d,t])"]},{"entry":[{},"%}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment, native functions can also be used to call C-implemented functions via the Stratego prim construct. This provides great flexibility in implementing custom functionality. Table 32 illustrates using native functions to call C-implemented functions.",{"@attributes":{"id":"p-0111","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 32"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for using native functions to call C-"},{"entry":"implemented functions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"rule main( )"},{"entry":"{"},{"entry":"\u2003checkFileChksum(\u201cmyFile\u201d,$sum);"},{"entry":"}"},{"entry":"%{"},{"entry":"\u2003CheckFileChksum = ?(t1,t2) ; prim(\u201c_checkFileChksum\u201d,t1,t2)"},{"entry":"%}"},{"entry":"\/\/ filechk.c"},{"entry":"\/\/"},{"entry":"ATerm _checkFileChksum(ATerm t1, ATerm t2) {"},{"entry":"\u2003. . ."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary embodiment, native Stratego can also be used to directly implement custom super-types. The Native super-type takes a single string parameter that defines the Stratego code for the strategy executed during each iteration of the traversal. Table 33 illustrates custom super-types.",{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 33"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for custom super-types"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"foreach-match(Native:{not(oncetd(?Id(_)))\u201d}) {"]},{"entry":[{},"\u2003debug;"]},{"entry":[{},"}"]},{"entry":[{},"\/* compiles to the following Stratego code *\/"]},{"entry":[{},"traverse-topdown(not(oncetd(?Id(_))) ; debug)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this exemplary embodiment, it is possible to bind YATL variables and pointers to subtrees, using the Native super-type. To do so, appropriate calls to add-yatl-symbol are made so that the variables are added to YATL's rule-function symbol table.","7.2 System Libraries","In this exemplary embodiment, there is a library support that provides access to the underlying operating system. The YATL run-time leverages existing Stratego system libraries in addition to some custom built libraries that are written in C. Other embodiments include other and different libraries. The suite of libraries in this exemplary embodiment includes support for file I\/O, console I\/O, network I\/O, date\/time, program execution (e.g., exec), basic string handling (e.g., strcmp) and data structure handling (e.g., list, table). Table 34 illustrates the loading of a YATL list from a file and then printing out each element to the console.",{"@attributes":{"id":"p-0116","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 34"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for loading a YATL list from a file and"},{"entry":"printing out each element to the console"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003try {"]},{"entry":[{},"\u2003\u2003$fin = fopen(\u201cmylist.txt\u201d, \u201cr\u201d);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003catch {"]},{"entry":[{},"\u2003\u2003print \u201cError: unable to open file\\n\u201d;"]},{"entry":[{},"\u2003\u2003exit(0);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003$list = | [ ] | ;"]},{"entry":[{},"\u2003while($line = fgets($fin)) {"]},{"entry":[{},"\u2003\u2003$list.append($line);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003print \u201cDumping...\\n\u201d;"]},{"entry":[{},"\u2003on $list {"]},{"entry":[{},"\u2003\u2003foreach-element {"]},{"entry":[{},"\u2003\u2003\u2003print \u201cList:$_\\n\u201d;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"A symbol table is a data structure used to record identifiers used in the source program and collect information about various attributes of each. From the perspective of a program transformation system, the symbol table effectively provides a cached representation of information that can be directly derived from the source tree.","In this exemplary embodiment, the target symbol table (i.e., hldig symbols from the target language as opposed to YATL variables) is implemented as a Stratego hash table. Other embodiments implement the symbol table differently. A key element of the symbol table for C and C++ is the scope to which each symbol belongs. In this exemplary embodiment, each new scope in the complete AST is associated with a unique scope identifier. Other embodiments may be modified according to various other language characteristics.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 5","b":["500","502","504","506","508","510","506","508","510"]},"In this exemplary embodiment, access to the target symbol table is provided through a number of APIs that allow table lookups and synchronized modifications between table and tree. The basic symbol lookup functions are symbol-lookup-xxx, where xxx is one of the suffixes, such as those listed in Table 35.",{"@attributes":{"id":"p-0121","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 35"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary list of suffixes for symbol lookup functions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["agnostic","lookup an identifier irrespective of type."]},{"entry":["typedecl","lookup an identifier for a type (do not resolve)."]},{"entry":["typedecl-deep","lookup an identifier for a type (fully resolve)."]},{"entry":["vardecl","lookup an identifier for a variable\/parameter."]},{"entry":["fundecl","lookup an identifier for a function declaration."]},{"entry":["method","lookup an identifier for a C++ class\/struct method."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary embodiment, each of the above APIs takes a (scope, identifier) pair and returns a (scope, declaration) pair, except typedecl-deep, which takes an additional start scope. The C and C++ scoping rules are used to perform a series of symbol lookups, until a result is found. If a given identifier is not found, even in the global scope, then the lookup API fails. Table 36 illustrates a symbol lookup function.",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 36"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for symbol lookup functions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"try {"},{"entry":"\u2003? ($s,$decl) = symbol-lookup-agnostic(current-scope( ), \u201cmain\u201d);"},{"entry":"}"},{"entry":"catch {"},{"entry":"\u2003print \u201cSymbol for main not found!\\n\u201d;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary embodiment, the symbol table can also be used as a reference for identifier rewriting. The rewrite APIs are implemented as rules. Other embodiments implement them differently. Each takes a scope, identifier pair, and a rule that is applied to the associated declaration. Modifications on the declaration are synchronized between both the symbol table and the corresponding subtree. Table 35 illustrates the use of the symbol rewrite API.",{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 37"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for using the symbol rewrite API"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003. . ."]},{"entry":[{},"\u2003try {"]},{"entry":[{},"\u2003\u2003apply symbol-rewrite-vardecl(rule::make-long,$s,\u201dmyVar\u201d);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003catch { }"]},{"entry":[{},"}"]},{"entry":[{},"rule make-long"]},{"entry":[{},"{"]},{"entry":[{},"\u2003match-once(TypeSpec:) {"]},{"entry":[{},"\u2003\u2003$= new (TypeSpec:{\u2018long});"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It is quite common for the symbol table to become out of synchronization with the transformed ATerm tree. To re-synchronize, the rule RebuildSymbols can be applied to a given subtree. This rule flushes the existing symbols, re-annotates the tree with new scope identifiers, and populates the symbol table with new symbols for the respective tree.","An example transformation rewrites code so that it conforms to a Hungarian-like variable naming convention. This convention derives a prefix from the variable type that is prepended to the variable name. Thus, given a variable name, the data type is inherently deducible.","In this example, a YATL function, GetHungarianPrefix, was implemented that generated a Hungarian prefix from a given type specification as shown in Table 38. This program sequentially matched on the type, which was passed as a parameter, using an either\/or construct. Of course, a table could have been used to store the mappings, but this is a simple example. Note that in matching the type specifications, the LooseTypeSpec super-type was used. The LooseTypeSpec super-type ignores declaration sequencing and the inclusion of any type qualifiers (e.g., static, const).","Given the main prefix generation function, the basic algorithm is defined in Table 39. This algorithm was kept simple for brevity. A practical tool would likely be more comprehensive.",{"@attributes":{"id":"p-0130","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 38"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Transformation Program Example"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["1","\/****************************************************************"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2","** GetHungarianPrefix","**"]},{"entry":"3"},{"entry":["4","** Input : a type specification","**"]},{"entry":["5","** Output : a Hungarian prefix","**"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["6","****************************************************************\/"]},{"entry":"7"},{"entry":["8","sub GetHungarianPrefix($type)"]},{"entry":["9","{"]},{"entry":["10","\u2003$= $type;"]},{"entry":"11"},{"entry":["12","\u2003either {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["13","\u2003\u2003$tsn = typespec-node($_) ;","\/\/ extract the TypeSpec subtree so that"]},{"entry":["14",{},"\/\/ the Class super-tree can be used"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["15","\u2003\u2003if (using $tsn match(Class:)) {"]},{"entry":["16","\u2003\u2003\u2003$prefix = \u201ccls\u201d;"]},{"entry":["17","\u2003\u2003}"]},{"entry":["18","\u2003\u2003else {"]},{"entry":["19","\u2003\u2003\u2003fail; \/* fail onto next \u201cor\u201d action *\/"]},{"entry":["20","\u2003\u2003}"]},{"entry":["21","\u2003}"]},{"entry":["22","\u2003or { match(LooseTypeSpec : {\u2018unsigned},{\u2018long});"]},{"entry":["23","\u2003\u2003\u2003\u2003$prefix = \u201cul\u201d;"]},{"entry":["24","\u2003}"]},{"entry":["25","\u2003or { match(LooseTypeSpec : {\u2018unsigned});"]},{"entry":["26","\u2003\u2003\u2003\u2003$prefix = \u201cui\u201d;"]},{"entry":["27","\u2003}"]},{"entry":["28","\u2003or { match(LooseTypeSpec : {\u2018signed});"]},{"entry":["29","\u2003\u2003\u2003\u2003$prefix = \u201ci\u201d;"]},{"entry":["30","\u2003}"]},{"entry":["31","\u2003or { match(LooseTypeSpec : {\u2018unsigned},{\u2018int});"]},{"entry":["32","\u2003\u2003\u2003\u2003$prefix = \u201cui\u201d;"]},{"entry":["33","\u2003}"]},{"entry":["34","\u2003or { match(LooseTypeSpec : {\u2018int});"]},{"entry":["35","\u2003\u2003\u2003\u2003$prefix = \u201ci\u201d;"]},{"entry":["36","\u2003}"]},{"entry":["37","\u2003or { match(LooseTypeSpec : {\u2018long});"]},{"entry":["38","\u2003\u2003\u2003\u2003$prefix = \u201cl\u201d;"]},{"entry":["39","\u2003}"]},{"entry":["40","\u2003or { match(LooseTypeSpec : {\u2018void});"]},{"entry":["41","\u2003\u2003\u2003\u2003$prefix = \u201cv;\u201d"]},{"entry":["42","\u2003}"]},{"entry":["43","\u2003or { match(LooseTypeSpec : {\u2018bool});"]},{"entry":["44","\u2003\u2003\u2003\u2003$prefix = \u201cb\u201d;"]},{"entry":["45","\u2003}"]},{"entry":["46","\u2003or { match(LooseTypeSpec : {\u2018unsigned},{\u2018char});"]},{"entry":["47","\u2003\u2003\u2003\u2003$prefix = \u201cuch\u201d;"]},{"entry":["48","\u2003}"]},{"entry":["49","\u2003or { match(LooseTypeSpec : {\u2018char});"]},{"entry":["50","\u2003\u2003\u2003\u2003$prefix = \u201cch\u201d;"]},{"entry":["51","\u2003}"]},{"entry":["52","\u2003or { $prefix = \u201c\u201d; }"]},{"entry":"53"},{"entry":["54","\u2003return $prefix"]},{"entry":["55","}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0131","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 39"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary algorithm for main prefix generation function"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1. Find each variable declaration."]},{"entry":[{},"2. Extract its name and type (fully resolved)."]},{"entry":[{},"3. Derive the prefix from its type and pointer level."]},{"entry":[{},"4. Capitalize the first letter of the variable name."]},{"entry":[{},"5. Replace variable identifier with prefixed\/capitalized name."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this example, variable declarations were matched through the VarDecl super-type. Using this, a YATL variable\/pointer was bound to the declared type and the list of variable identifiers. In order to modify the variable identifiers in place, without reconstructing the rest of the declaration, a pointer was used as shown in Table 40. Otherwise, a copy would have been modified without effect.",{"@attributes":{"id":"p-0133","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 40"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for matching variable declarations"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"foreach-match(VarDecl : {=*d}<decl>,{=$t}<type>) {"]},{"entry":[{},"\u2003on *d {"]},{"entry":[{},"\u2003\u2003. . . modify declaration . . ."]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Given the type from the declaration, the type was resolved through possible type definitions by using the symbol-lookup-typedecl-deep call. (See line 21 of Table 38.) This API used the symbol table to fully resolve the type from the given scope, because types are scoped. If this call failed, then there was no further resolution of the type and, therefore, the type was treated as a basic type, assuming that all types were available. Storing was also done at the pointer level. For example, given type T defined as typedef unsigned long **T, the type is unsigned long and the pointer level is 1. This pointer level was later added to the level associated with the individual declaration. (See line 37 of Table 38).","The next stage was to build the Hungarian prefix from the fully resolved type using the GetHungarianPrefix function. Iteration through each of the declarators in the declaration list was done and then the identifier was assembled and replaced. Part of the assembly included adding the letter p to the prefix for each pointer level. (See lines 43-45 of Table 38). The name replacement was performed by matching on the Id term and then using explicit assignment on the current term. The complete main rule is shown in Table 41.",{"@attributes":{"id":"p-0136","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 41"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary program main rule"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/***********************************************************************"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["** hungarian.yatl","**"]},{"entry":["**","**"]},{"entry":["** Description: example of Hungarian notation transformation","**"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/**********************************************************************\/"},{"entry":"#include \u201cdebug.ymod\u201d"},{"entry":"#include \u201ctypes.ymod\u201d"},{"entry":"#include \u201ctypesays.ymod\u201d"},{"entry":"rule main"},{"entry":"{"},{"entry":"\u2003on-file \u201c*.*\u201d {"},{"entry":"\u2003\u2003for-each-match(VarDecl : {=*d}<decl>,{=$t}<type>) {"},{"entry":"\u2003\u2003\/\/ dereference the type (through possible typedef statements)"},{"entry":"\u2003\/\/"},{"entry":"\u2003either {"},{"entry":"\u2003\u2003? ($t,$plb) = symbol-lookup-typedecl-deep(current-scope( ),\u201d$t\u201d,0);"},{"entry":"\u2003\u2003$t = crunch-type($t);"},{"entry":"\u2003}"},{"entry":"\u2003or {"},{"entry":"\u2003\u2003$plb = 0;"},{"entry":"\u2003}"},{"entry":"\u2003\/\/ build prefix"},{"entry":"\u2003\/\/"},{"entry":"\u2003$hp = GetHungarianPrefix($t);"},{"entry":"\u2003\/\/ process each identifier in the declaration list"},{"entry":"\u2003\/\/"},{"entry":"\u2003on *d {"},{"entry":"\u2003\u2003foreach-element {"},{"entry":"\u2003\u2003\u2003$tpl = extract-ptrlevel($_) + $plb;"},{"entry":"\u2003\u2003\u2003$prefix=\u201d\u201d;"},{"entry":"\u2003\u2003\u2003\/\/ add one \u201cp\u201d for each pointer level"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003for ($i = 0; $i < $tpl; $i++) {"},{"entry":"\u2003\u2003\u2003\u2003$prefix = conc-strings(\u201cp\u201d,$prefix);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\/\/ add Hungarian prefix to original name"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003$prefix = conc-strings($prefix,$hp);"},{"entry":"\u2003\u2003\u2003\/\/ replace identifier with newly formed name"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003match-once(ID:(=$i) {"},{"entry":"\u2003\u2003\u2003\u2003$newid = conc_strings($prefix,make-first-letter-uppercase($i));"},{"entry":"\u2003\u2003\u2003\u2003$= new(Id:($newid));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2002}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"8.1 All Constructs Take a Tree and Return a Tree","All of the constructs in this exemplary embodiment of YATL operate on a given input tree known as the current subject. For convenience, a tree can be thought of as a fragment of program source code. The constructs may or may not modify the subject, but, in any case, another tree results.","8.2 Variables and Data","This exemplary embodiment of YATL is typeless, that is, variables do not have a type. Variables are identified by the $ prefix followed by an identifier. All variables are locally scoped to the rule and, like PERL, variables do not need to be explicitly declared. Variables are initialized when they are first assigned.","8.2.1 Variable Assignment","In this exemplary embodiment, variables can be re-bound at any time and represent a copy of whatever they have been bound to. They are bound through the assignment operator, =, either within super-type matching or an explicit assignment statement. Table 42 illustrates variable assignment.",{"@attributes":{"id":"p-0140","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 42"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for variable assignment"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003$t = \u201cHello\u201d;"]},{"entry":[{},"}"]},{"entry":[{},"rule FindType"]},{"entry":[{},"{"]},{"entry":[{},"\u2003$t = \u201cBye\u201d; \/\/ does not over-write $t::main"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This exemplary embodiment of YATL has one special variable, $_. $_ Refers to the current tree (e.g., program segment).","8.2.3 Global Variables","In this exemplary embodiment, global variables are scope across rules. A global variable is declared by simply prepending the variable identifier with the :: (double colon) symbol. Table 43 illustrates a global variable. Global variables are not released until the transformation program exists.",{"@attributes":{"id":"p-0143","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 43"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for global variables"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$::g = 10; \/\/ creates a global variable g and assigns it to 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In this exemplary embodiment, variables make copies of the program they are bound to. Marker variables allow transformations by reference. They behave in a manner akin to conventional pointers. Marker variables are denoted with an asterisk. Table 44 illustrates marker variables.",{"@attributes":{"id":"p-0145","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 44"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for marker variables."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ binds a marker fn to the matched function name element"]},{"entry":[{},"\/\/"]},{"entry":[{},"foreach-match (FunctionCall: (=*fn)<function_name> {...}"]},{"entry":[{},"\/\/ bind a marker p to the current program"]},{"entry":[{},"\/\/"]},{"entry":[{},"*p = $_;"]},{"entry":[{},"\/\/ bind global marker q to the current program"]},{"entry":[{},"\/\/"]},{"entry":[{},"*::q = $_;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Markers are either unique or replicated (indicated with ::). Unique markers are changed each time the marker is assigned. Markers are referenced using the \u201con\u201d construct. The \u201con\u201d construct applied to a unique marker results in a single application, while the \u201con\u201d construct applied to a replicated marker repeats for each of the occurrences of the marker.","8.2.5 Stringification","In this exemplary embodiment, one data type is the string. Any LL-AST or subtree can be converted to a string. Stringification is achieved by the concatenation of all strings within the tree from left to right. Table 45 illustrates strings.",{"@attributes":{"id":"p-0148","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 45"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for strings"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$v = | Id(\u201cx\u201d) |;","\/\/ variable v now contains tree ID(\u201cx\u201d)"]},{"entry":[{},"foo($v);","\/\/ passes tree ID(\u201cx\u201d) to function foo"]},{"entry":[{},"foo(\u201c$v\u201d);","\/\/ passes string \u201cx\u201d to function foo"]},{"entry":[{},"$v = \u201c$v\u201d;","\/\/ converts $v to string \u201cx\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, one or more data items (e.g., trees, strings, integers) can be combined into a single tree using bracketing. This is particularly useful in building return values for functions. Unification equates to building a term given a number of siblings. Table 46 illustrates data unification.",{"@attributes":{"id":"p-0150","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 46"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for data unification"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$result = @(0,1,2);","\/\/ result contains term (0,1,2)"]},{"entry":[{},"$p = 20;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$results = @(\u201cfail\u201d,$p);","\/\/ results contains a term (\u201cfail\u201d,20)"]},{"entry":[{},"sub foo( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003return @(0,1);"]},{"entry":[{},"}"]},{"entry":[{},"sub foo2( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003$r = @(0,$t);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003return $r;","\/\/ return unified term (0,$t)"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, unified data can be split using a specialized form of assignment. Table 47 illustrates split assignments of the form ?([list_of_variables])=[term expression];. Split assignments may include the current term variable $_. Note that the leftmost use of the $_ in the last example in Table 47 is bound to the current term.",{"@attributes":{"id":"p-0152","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 47"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for split assignments"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sub foo( ) { return (0,1,2); }"]},{"entry":[{},"?($a,$b,$c) = foo( );"]},{"entry":[{},"\/\/ $a=0, $b=1, $c=2"]},{"entry":[{},"sub foo( ) { return (0,1,2); }"]},{"entry":[{},"? ($_,$b,$c) = foo( );"]},{"entry":[{},"\/\/ $b=1, $c=2"]},{"entry":[{},"\/\/ current term is 0"]},{"entry":[{},"? ($_,$b,$_) = (0,1,2);"]},{"entry":[{},"\/\/ current term is 0 as opposed to 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"This exemplary embodiment of YATL supports modularization of functionality into subroutines. In YATL, there are two types of subroutines: rules and functions.","8.3.1 Rules","In this exemplary embodiment, rules form the basic unit of transformation on the current subject; that is, they cause effect on the current subject. Rules are identified by a unique identifier and optionally support parameters, except the main rule that does not have parameters. The rule identified by main is the entry point from the transformation execution and must exist in every YATL program. Parameters that are specified on rule main map to command line arguments for the tool. Arguments are supported with (default) or without a value (prefix noarg::). The order of the parameters declared does not matter. The values of the parameter variables, scope to function main, are coudn to the command line values (as a string) or the value 1 where there is no argument. They are used in the same way as any other YATL variables. Table 48 illustrates rules.",{"@attributes":{"id":"p-0155","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 48"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for rules"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"rule main"},{"entry":"{"},{"entry":"..."},{"entry":"}"},{"entry":"rule FindType($P,$Q)"},{"entry":"{"},{"entry":"\u2003print \u201cParam 1 is $P and Param 2 is $Q\\n\u201d;"},{"entry":"}"},{"entry":"rule main($port, $noarg::debug)"},{"entry":"{"},{"entry":"\u2003if ($port == \u201c0\u201d) {...}"},{"entry":"}"},{"entry":"\/\/ the variable $port is the string \u201c0\u201d as opposed to the integer value 0"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary embodiment, rules other than the main rule are called using the apply expression. The result of the apply expression changes the current tree to that which results from the particular rule. Table 49 illustrates applying rules when the apply command is within a foreach-match loop. Using the apply operator in the context apply R1>>R2 means apply rule R2 if and only if R1 succeeds. If a rule is applied without explicitly handling its failure, the whole transformation may stop. The else clause is used to catch exceptions and continue.",{"@attributes":{"id":"p-0157","num":"0156"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 49"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for applying rules"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003$result = apply FindType(0,\u201dint\u201d);"]},{"entry":[{},"\u2003$result2 = apply FindRule1 >> FindRule2;"]},{"entry":[{},"}"]},{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003apply FindType(0,\u201dint\u201d)"]},{"entry":[{},"\u2003else print \u201cFindType failed\u201d;"]},{"entry":[{},"\u2003apply FindLong; \/\/ this will always execute"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, functions differ from rules in that functions do not pass an inherent program tree and on calling functions do not effect the current program tree. Rules are, in fact, syntactic sugar over functions. Functions are defined with the sub keyword and called as illustrated in Table 50.",{"@attributes":{"id":"p-0159","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 50"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for functions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003log1(\u201cHello\u201d);"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ log1 subroutine definition"]},{"entry":[{},"\/\/"]},{"entry":[{},"sub log1($r)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003print(\u201cEvent: $r\\n\u201d);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"In this exemplary embodiment of YATL, all statements can succeed (i.e., a tree is returned) or fail if failure is not explicitly handled by an else clause, the program stops. Table 51 illustrates handling failure with an else clause.",{"@attributes":{"id":"p-0161","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 51"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for else clause"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003apply Broken"]},{"entry":[{},"\u2003else {"]},{"entry":[{},"\u2003\u2003print \u201cHandle failure\u201d;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003apply AlsoBroken"]},{"entry":[{},"\u2003else print \u201cHandle failure\u201d;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, the continue construct continues the program, but is useful when an explicit else action is not desired. Table 52 illustrates the continue construct.",{"@attributes":{"id":"p-0163","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 52"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for continue"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003apply CouldFail"]},{"entry":[{},"\u2003else continue;"]},{"entry":[{},"\u2003\/\/ here is always reached"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, statement blocks (including function calls) can be checked for failure through the try clause. The try construct executes the try block and if the block fails, then executes the catch block.","8.4.4 Isolate","In this exemplary embodiment, isolate is used to protect the current tree from being affected, allowing temporary modifications. The isolate construct is used for a single statement or a complete block. Table 53 illustrates the isolate construct.",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 53"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for isolate"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003isolate apply Something;"]},{"entry":[{},"\u2003isolate {"]},{"entry":[{},"\u2003\u2003print \u201cThrow away this block\u201d;"]},{"entry":[{},"\u2003\u2003apply Something;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, simple conditional flow is supported through an if statement. Full statement parentheses are used to avoid the dangling else problem. Table 54 illustrates the if, else statement.",{"@attributes":{"id":"p-0168","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 54"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for if, else statements"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (match-once(ID:{\u2018x})) {"]},{"entry":[{},"\u2003print \u201cContains x\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},"else {"]},{"entry":[{},"\u2003print \u201cDoes not contain x\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, the either or statement is used to execute a number of statement blocks until one succeeds. At least one alternative is provided. Table 55 illustrates the either or statement.",{"@attributes":{"id":"p-0170","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 55"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for the either or statement"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"either ( f1( ); } or ( f2( ); } or { f3( ); }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In this exemplary embodiment, while loops are a basic pre-test looping command. The loop action is applied to the current subject and the expression is isolated. Table 56 illustrates the while statement.",{"@attributes":{"id":"p-0172","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 56"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for the while statement"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"while ($v < 10) { $v++; }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In this exemplary embodiment, the do-while statement is a variation on the while statement for the post-test looping. Table 57 illustrates the do-while statement.",{"@attributes":{"id":"p-0174","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 57"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for the do-while statement"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"do {"]},{"entry":[{},"\u2003$v = $v + 2;"]},{"entry":[{},"}"]},{"entry":[{},"while ($v < 10);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, the for statement provides syntactic sugar for while loops with initialization, test, and increment. The for statement's action causes effect on the current tree. Unlike C, the condition is required in the for statement. Table 58 illustrates the for statement.",{"@attributes":{"id":"p-0176","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 58"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for the for statement"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for ($v=0; $v<10; $v++) {"]},{"entry":[{},"\u2003print \u201cloop $v\\n\u201d);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0177","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 59"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for die and exit"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003apply MustNotFail"]},{"entry":[{},"\u2003else die \u201cIt did fail though!\\n\u201d;"]},{"entry":[{},"\u2003exit(\u22121);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, the fail statement explicitly causes a match or function call to fail. Table 60 illustrates explicit failure.",{"@attributes":{"id":"p-0179","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 60"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for the fail statement"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]},{"entry":[{},"\u2003if (! $v = foovar( )) {"]},{"entry":[{},"\u2003\u2003die \u201cfoobar has failed!\\n\u201d;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"sub foobar( )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003if ($::x > 10) {"]},{"entry":[{},"\u2003\u2003fail;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},"In this exemplary embodiment, foreach-match is the principal construct for recursively searching with the current subject. This construct matches on a given tree (built using a super-type) within the current subject. The semantics of the call are: for each matching tree in the current subject tree, perform the following action on that matching tree. The traversal used for this match is top-down. Table 61 illustrates searching the current subject and for each matching function call to the function atol, applying the rule R2. R2 replaces the call with mynew_atol, transposing the parameters also. Match expressions may be or'ed together to avoid repetition.",{"@attributes":{"id":"p-0181","num":"0180"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 61"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for foreach-match"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"foreach-match (FunctionCall: {'atol})"]},{"entry":[{},"{"]},{"entry":[{},"\u2003apply R2;"]},{"entry":[{},"}"]},{"entry":[{},"rule R2:"]},{"entry":[{},"{"]},{"entry":[{},"\u2003match-once(List: {=$p});"]},{"entry":[{},"\u2003new (FunctionCall: {'mynew_atol},{$p});"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, match-once is used to perform a traversal until a single match within the current subject succeeds. The action is only applied on the first match. If no match is found, the else action is applied to the current subject. Table 62 illustrates the match-once statement.",{"@attributes":{"id":"p-0183","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 62"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for match-once"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"match-once (FunctionCall:) {"]},{"entry":[{},"\u2003apply R2; \/\/ applies R2 to the first matched FunctionCall"]},{"entry":[{},"}"]},{"entry":[{},"match-once (FunctionCall:)"]},{"entry":[{},"else print \u201cCannot find function call\\n\u201d;"]},{"entry":[{},"match-once (FunctionCall:)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003print \u201cFound function call\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},"else print \u201cDid not find function call\\n\u201d;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, match-once and match-once else operate in a top-down fashion, while foreach-match-bottomup search ion a bottom-up fashion so that the leaves are processed first. Table 63 illustrates foreach-match-bottomup.",{"@attributes":{"id":"p-0185","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00063","num":"00063"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 63"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for foreach-match-bottomup"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ given statement a.b.c = 0"]},{"entry":[{},"foreach-match (FieldRef:) {"]},{"entry":[{},"\u2003print \u201cfield ref $_,\u201d;"]},{"entry":[{},"}"]},{"entry":[{},"\/\/outputs a.b.c,a.b"]},{"entry":[{},"foreach-match-bottomup(FieldRef:) {"]},{"entry":[{},"\u2003print \u201cfield ref $_,\u201d;"]},{"entry":[{},"}"]},{"entry":[{},"\/\/outputs a.b.,a.b.c"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, the match expression facilitates an exact match. There is no inherent traversal involved. Match is typically used in conjunction with a conditional. Match conditions can also be directed on a given tree by using the \u201cusing\u201d construct. Table 64 illustrates match using.",{"@attributes":{"id":"p-0187","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00064","num":"00064"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 64"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for match using"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (match(FunctionCall:{'foo})) {"]},{"entry":[{},"\u2003print \u201cFound foo\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},"match(FunctionCall:{'foo}) {"]},{"entry":[{},"\u2003print \u201cFound foo $_\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},"if (using $p match (FunctionCall:{'foo})) {"]},{"entry":[{},"\u2003print \u201cFound foo in \\$p\\n\u201d;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, the developer can match against a piece of code held within a variable or explicitly specified. The parameter to match construct is a term expression that builds a tree. Table 65 illustrates exact matching without a super-type.",{"@attributes":{"id":"p-0189","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00065","num":"00065"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 65"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for exact matching without a super-type"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"foreach-match(\u201cx\u201d) { } \/\/matches on all strings \u201cx\u201d"},{"entry":"foreach-match($v) { } \/\/matches on subtree held in $v"},{"entry":"$v = \u201cs\u201d;"},{"entry":"foreach-match(\u201cx$v\u201d) { } \/\/ matches on string \u201cxs\u201d"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["foreach-match(new (Id:{\u2018x})) { }","\/\/ matches against ID(\u201cx\u201d) - this"]},{"entry":[{},"\/\/ would not normally be used"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment, the \u201con\u201d statement applies some transformation action to a tree (e.g., program segment) held in a variable, without affecting the current tree. Table 66 illustrates the \u201con\u201d statement.",{"@attributes":{"id":"p-0191","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00066","num":"00066"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 66"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for the \u201con\u201d statement"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"on $prog"]},{"entry":[{},"{"]},{"entry":[{},"\u2003foreach-match (FunctionCall: {\u2018atol})"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003print \u201cFound function: $_\\n\u201d;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"\/\/ on used to de-reference markers"]},{"entry":[{},"on *::p { print \u201ctransformed program function: $_\\n\u201d; }"]},{"entry":[{},"on *q ( print \u201cTransformed program function: $_\\n\u201d; }"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment of YATL, super-types are one way to abstract upon the complexity of the target grammar and the LL-ASTs that are produced. The super-types are specific to the target language and implemented as a personality on the YATL compiler. Super-types allow the YATL programmer to both search (match) against segments of program code and also to build new segments of code. Table 67 illustrates a super-type.",{"@attributes":{"id":"p-0193","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00067","num":"00067"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 67"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for a super-type"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$_ = new (FunctionCall: {\u201cntohl\u201d}, {$p});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In this exemplary embodiment, super-type parameters are standard across all super-types parameters include three different optional elements: criteria, field identifier, and attributes. The criteria define the value or variable to which the field data is bound. The field identifier qualifies the field when it cannot be implied from the parameter ordering. Attributes change search strategies and formations. Table 68 illustrates super-type parameters.",{"@attributes":{"id":"p-0195","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00068","num":"00068"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 68"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for super-type parameters"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$_ = new (FunctionCall: {\u201cntohl\u201d,=$fn}<function_name>, {=$p}<all>);"},{"entry":"$_ = new (FunctionCall: {\u201cX\u201d}<param1:str>);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment, matching super-types are used by the YATL programmer to locate program segments of interest. A matching super-type is like a template for a piece of code, where each template is of a given form and contains a number of holes (wildcards). These holes are filled in using the constructor parameters. Super-type parameters are dependent upon the implementation of the respective super-type constructor. Parameters are typically a mixture of YATL variables and constants. The parameters are specified as a comma-separated list and their order is meaningful. When YATL variables are used in a super-type constructor, they are used in either reference or assignment. That is, reference (e.g., $x). means use the contents of $x, whereas assignment (e.g., =$x) means that when the super-type matches, the matching value is assigned to variable $x. Table 69 illustrates match super-types.",{"@attributes":{"id":"p-0197","num":"0196"},"tables":{"@attributes":{"id":"TABLE-US-00069","num":"00069"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 69"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for match super-types"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ TypeSpec"},{"entry":"\/\/ Parameters: 0-2"},{"entry":"\/\/ Semantics: each parameter identifies a member of a composite type"},{"entry":"\/\/ specification"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(TypeSpec: {\u2018unsigned})","\/\/ matches unsigned only,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ unsigned x;","MATCH"]},{"entry":[{},"\/\/ unsigned long x;","NO MATCH"]},{"entry":[{},"\/\/ unsigned x,y,z;","MATCH"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(TypeSpec: {\u2018unsigned}, {=$t})","\/\/ matches arity 2, starting with unsigned"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ unsigned x;","NO MATCH"]},{"entry":[{},"\/\/ unsigned long x;","MATCH $t-long"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(TypeSpec: )","\/\/ match all type specifications"]},{"entry":[{},"\/\/ unsigned x; \u2003\u2003MACTH"]},{"entry":["(TypeSpec: {=$t})","\/\/ match all type specifications and bind to variable $t"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ FunctionCall:"},{"entry":"\/\/ Parameters: 0 or more"},{"entry":"\/\/ Semantics: param (1) is the function identifier, param (1) onwards represent function"},{"entry":"\/\/ call parameters. Each constructor parameter can map to one or more function"},{"entry":"\/\/ parameters. For example, a variable $p, may have been bound to all of the"},{"entry":"\/\/ parameters for some other call."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(FunctionCall: {\u2018atoll})","\/\/ FunctionCall super-type"]},{"entry":[{},"\/\/ atol(\u201c99\u201d); MATCH"]},{"entry":["(FunctionCall: {=$f})","\/\/ atol(\u201c99\u201d); MACTH $f=atol"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ FunctionBody:"},{"entry":"\/\/ Parameters: 0 or 1"},{"entry":"\/\/ Semantics: param (1) is the function identifier"},{"entry":"(FunctionBody: {\u2018myfunction}) \u2003\/\/ void myfunction(int x) { }\u2003\u2003MATCH"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Note: subject match is compound statement"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(FunctionBody: )","\/\/ MATCHES all function bodies"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Id:"},{"entry":"\/\/ Parameters: 0 or 1"},{"entry":"\/\/ Semantics: param (1) is the value of the identifier"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(Id: {\u2018x})","\/\/ int x;","MATCHES x"]},{"entry":[{},"\/\/ int x,y;","MATCHES x"]},{"entry":[{},"\/\/ printf(\u201cx\u201d);","NO MATCH"]},{"entry":["(Id: )","\/\/ int x,y,z;","MATCHES x, y and z"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/Literal:"},{"entry":"\/\/ Parameters: 0 or 1"},{"entry":"\/\/ Semantics: param 91) literal content"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(Literal: {\u201c;\u201d})","\/\/ while(x);","MATCHES \u2018;\u2019"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(Literal: )","\/\/ MATCHES all literals"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Struct:"},{"entry":"\/\/ Parameters: 0 or 1"},{"entry":"\/\/ Semantics: param (1) variable identifier"},{"entry":"\/\/ Notes: if specified, param (1) must be a member of identifier list"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(Struct: {\u2018t})","\/\/ MATCHES also struct definitions type id \u2018t"]},{"entry":[{},"\/\/ e.g., struct t { ... }"]},{"entry":[{},"\/\/ e.g., struct r,s,t { ... }"]},{"entry":["(Struct: {=$t})","\/\/ MATCH all struct definitions bind id to $t"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ VarDecl:"},{"entry":"\/\/ Parameters: 0 or 1"},{"entry":"\/\/ Semantics: param (1) variable identifier"},{"entry":"\/\/ Notes: if specified, param (1) must be a member of identifier list"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(VarDecl: {\u2018x})","\/\/ int x;","MATCHES"]},{"entry":[{},"\/\/ int x,y,z;","MATCHES"]},{"entry":["(VarDecl: {=$x})","\/\/ int y;","MATCH and bind to y"]},{"entry":["(VarDecl: )","\/\/ int a,b;","MATCH"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ MemberDecl:"},{"entry":"\/\/ Parameters: 0 or 1"},{"entry":"\/\/ Semantics: param (1) member identifier"},{"entry":"\/\/ Notes: if specified, param 91) must be a member of identifier list"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(MemberDecl: {\u2018x})","\/\/ struct X {"]},{"entry":[{},"\/\/ int x; \u2003\u2003MACTHES"]},{"entry":[{},"\/\/ };"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment of YATL, a second family of super-types is that of building, which allows the YATL programmer to construct new fragments of code either from scratch or from existing pieces. Table 70 illustrates build super-types. The FreeStatement super-type build constructors allows the YATL developer to directly write a complete C\/C++ statement as part of their transformation program. The FreeExpression super-type build constructor allows the YATL developer to directly write a C\/C++ expression as part of their transformation program. The FreeExpression super-type is used in the same way as the FreeStatement super-type.",{"@attributes":{"id":"p-0199","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00070","num":"00070"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 70"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for build super-types"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ FreeStatement"},{"entry":"\/\/ Parameters: 1"},{"entry":"\/\/ Semantics: param (1) free text code"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["$_ = new (FreeStatement: {\u201cif (x==0) {exit 0; }\u201d});","\/\/ O.K."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$_ = new (FreeStatement: {\u201c",":while(x>0) {","\/\/ O.K."]},{"entry":[{},": pop(x);",{}]},{"entry":[{},"\u201c});",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$_ = new (FreeStatement: {\u201cif (x==0)\u201d});","\/\/ will not compile"]},{"entry":["$_ = new (FreeStatement: {\u201cif ($x ==0)\u201d});","\/\/ will not compile"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ FreeExpression:"},{"entry":"\/\/ Parameters: 1"},{"entry":"\/\/ Semantics: param (1) free text code"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$_ = new (FreeExpression: {\u201c(x > 0)\u201d});","\/\/ O.K."]},{"entry":["$_ = new (FreeExpression: {\u201cif (x==0)\u201d});","\/\/ will not compile"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ FunctionCall:"},{"entry":"\/\/ Parameters: 1 or more"},{"entry":"\/\/ Semantics: param (1) function identifier, (2) and beyond call parameters"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$_ = new (FunctionCall: {\u2018ntohl},{\u2018x});","\/\/ generates --> ntohl(x)"]},{"entry":["$_ = new (FunctionCall: {\u2018ntohl},{$p});","\/\/ generates --> ntohl(?);"]},{"entry":[{},"\/\/ where ? is contents of $p"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ generates --> pr(Hello\u201d)"},{"entry":"\/\/"},{"entry":"$_ = new (FunctionCall: {\u2018pr},{\u201c\\\u201dHello\\\u201c\u201d);"},{"entry":"\/\/ also generates -->pr(\u201cHello\u201d)"},{"entry":"$_ = new (FunctionCall: {\u2018pr},{\u201cHello\u201d}<:str>);"},{"entry":"\/\/ List:"},{"entry":"\/\/ Parameters: 0 or more"},{"entry":"\/\/ Semantics: builds a comma-separated list, e.g., a function call parameter list"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$_ = new(List: {\u20181},{\u201cA\u201d});","\/\/ generates 1,\u201dA\u201d"]},{"entry":["\/\/ Id:",{}]},{"entry":["\/\/ Parameters: 1",{}]},{"entry":["\/\/ Semantics: param (1) contents of the identifier",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["$_ = new (ID: {\u2018x})","\/\/ generates x, e.g., part of int x;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Literal:"},{"entry":"\/\/ Parameters: 1"},{"entry":"\/\/ Semantics: param (1) contents of the literal"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["$_ = new (Literal: {\u2018return})","\/\/ generates literal return"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Native:"},{"entry":"\/\/ Parameters: 1"},{"entry":"\/\/ Semantics: param (1) defines the ATerm for the tree"},{"entry":"\/\/ Notes: this constructor can be used to build ATerm trees directly"},{"entry":"\/\/ generate TypeSpec(Long(\u201clong\u201d))"},{"entry":"$_ = new(Native: (\u201cTypeSpec(Long(\\\u201clong\\\u201d))|});"},{"entry":"\/\/ Type:"},{"entry":"\/\/ Parameters: 1"},{"entry":"\/\/ Semantics: a single element in a compile typespec"},{"entry":"\/\/ Notes: this is useful when replacing a single element in a typespec,"},{"entry":"\/\/ for example, for unsigned mt or const mt to unsigned short and const short,"},{"entry":"\/\/ respectively"},{"entry":"$_= new (Type: {\u2018x})"},{"entry":"\/\/ TypeSpec:"},{"entry":"\/\/ Parameters: variable"},{"entry":"\/\/ Semantics: build the complete typespec"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$_= new(TypeSpec: {\u2018unsigned}, {\u2018int})","\/\/ generates a new typespec:"]},{"entry":[{},"\/\/ unsigned mt"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ TypeId:"},{"entry":"\/\/ Parameters: variable"},{"entry":"\/\/ Semantics: generate an AbstractDecl, which contains a typespec and a"},{"entry":"\/\/ variable list of pointer operators"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["$_ = new(TypeId: :\u2019int}, {\u2018*})","\/\/ generates AbstractDecl int *"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0200","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00071","num":"00071"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 71"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for new construction"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rule main"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$_ = \u201cHello\u201d;","\/\/ will set the current subject to the string"]},{"entry":[{},"\u201cHello\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"rule main"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$newvar = new (FreeStatement: {\u201cint x = 0;\u201d);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, a new statement is inserted with reference to a YATL marker, as illustrated in Table 72. Markers used for statement insertion point to a statement or expression statement rather than a subtree of a statement.",{"@attributes":{"id":"p-0202","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00072","num":"00072"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 72"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for reference statement insertion"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"insert-statement new (FreeStatement: {\u201c:x = 0;\u201d}) before *p;"]},{"entry":[{},"insert-statement new (FreeStatement: {\u201c:x = 0;\u201d) after *::p;"]},{"entry":[{},"insert-statement $ns before *q;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment, a statement is deleted by reference, as illustrated in Table 73.",{"@attributes":{"id":"p-0204","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00073","num":"00073"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 73"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for statement deletion"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"delete-statement at *p;"]},{"entry":[{},"delete-statement at *::q;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment, it is often useful to replace a statement with a new statement without explicitly setting up marker variables. This is achieved through the replace-with construct, which replaces the current statement with one or more new statements, as illustrated in Table 74. The replacement is not actually performed until the inner-most loop is exited.",{"@attributes":{"id":"p-0206","num":"0205"},"tables":{"@attributes":{"id":"TABLE-US-00074","num":"00074"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 74"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for statement replacement"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"foreach-match(Statement:{=$s}) {"]},{"entry":[{},"\u2003foreach-match(FunctionCall: {\u2018foo}) {"]},{"entry":[{},"\u2003replace-with new (FreeStatement: {\u201c:lock( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003: $s"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003: unlock( );\u201d});"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this exemplary embodiment, pointer references are used to insert layout before or after a given statement, as illustrated in Table 75. Insertion after a statement prepends the given string to the layout. Insertion before a statement appends the given string to the layout.",{"@attributes":{"id":"p-0208","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00075","num":"00075"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 75"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for layout insertion"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"insert-layout \u201c\\n\/* new function *\/\\n\u201d after *p;"]},{"entry":[{},"insert-layout \u201c\\n\/* new function *\/\\n\u201d before *p;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"This exemplary embodiment supports basic integer arithmetic. Arithmetic expression include *, \/, +, \u2212, % (multiply, divide, add, subtract, modulo division), ++, \u2212\u2212 (increment, decrement), postfix and conditional expression include !=, ==, >, <, >=, <=(not equal, equal, greater than, less than, greater than or equal, less than or equal). Other embodiments support various and different expressions.","8.9 Input\/Output (I\/O)","Table 76 illustrates I\/O in this exemplary embodiment.",{"@attributes":{"id":"p-0211","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00076","num":"00076"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 76"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary code excerpt for input\/output"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"print \u201cCurrent tree is $_\\n\u201d;"]},{"entry":[{},"print stdout, \u201c$X found\\n\u201d;"]},{"entry":[{},"\/\/ standard streams accessed as follows"]},{"entry":[{},"$fd = stdio-stream( );"]},{"entry":[{},"$fd = stdout-stream( );"]},{"entry":[{},"$fd = stderr-stream( );"]},{"entry":[{},"$fgets = fgets($fd);"]},{"entry":[{},"fputs(\u201csomething\u201d,$fdout);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In this exemplary embodiment, the scoping constructs, transform-uses X where Y and transform-deci X where Y, allow changing the declaration of a variable based on how it is used or vice-versa. In both constructs, the first parameter X is the name for a YATL rule that changes uses\/decis. The second parameter Y is a rule that matches the uses of a variable given the name of the variable, which is passed into the rule as a parameter. Table 77 illustrates scoping in the example of match_use is listed below, $p contains the variable name and specifies that a variable that is assigned the return value of function call rn_getseg.","Computer program listings pertaining to Table 77 are provided in electronic format, as permitted under 37 C.F.R. \u00a71.52(e) and \u00a71.96(c). The submitted compact disc, the contents of which is herein incorporated by reference, contains the following file: 11222418_wordcode_tables77-79.doc","8.11 Interworking with Stratego","This exemplary embodiment of YATL supports the ability to interface directly into Stratego. This is achieved in one of two ways: using a native statement or a Stratego block. The native statement can be used to call Stratego code directly. This is useful to access more complex Stratego functionality that cannot be expressed directly in YATL. The native statement is also useful for debugging purposes. Table 78 illustrates the native statement. Complete blocks of Stratego can be inserted into the YATL code. The contents of these blocks are directly pasted in their declared position. Native blocks are encapsulated with % { and %}. The native block also allows the YATL programmer to directly interface with C code, using the Stratego primitives construct. If there is no super-type available for a given construct, the native super-type is used. This super-type allows the use of Stratego match expressions directly.","Computer program listings pertaining to Table 78 are provided in electronic format, as permitted under 37 C.F.R. \u00a71.52(e) and \u00a71.96(c). The submitted compact disc, the contents of which is herein incorporated by reference, contains the following file: 11222418_wordcode_tables77-79.doc","Table 79 contains a grammar for an exemplary embodiment of the YATL language. Those skilled in the art and informed by the teachings herein will realize that the invention encompasses obvious changes in grammar and syntax and instead is directed to the broad concepts implemented by the exemplary grammar, syntax, and constructs.","Computer program listings pertaining to Table 79 are provided in electronic format, as permitted under 37 C.F.R. \u00a71.52(e) and \u00a71.96(c). The submitted compact disc, the contents of which is herein incorporated by reference, contains the following file: 11222418_wordcode_tables77-79.doc",{"@attributes":{"id":"p-0218","num":"0217"},"figref":"FIG. 7","b":["700","700","730","740","744","746","740","742","744"]},"The processor  cooperates with conventional support circuitry such as power supplies, clock circuits, cache memory and the like as well as circuits that assist in executing the software routines stored in the memory . As such, it is contemplated that some of the steps discussed herein as software methods may be implemented within hardware, for example, as circuitry that cooperates with the processor  to perform various method steps. The computer  also contains input\/output (I\/O) circuitry that forms an interface between the various functional elements communicating with the computer .","Although the computer  is depicted as a general purpose computer that is programmed to perform various functions in accordance with the present invention, the invention can be implemented in hardware as, for example, an application specific integrated circuit (ASIC) or field programmable gate array (FPGA). As such, the process steps described herein are intended to be broadly interpreted as being equivalently performed by software, hardware, or a combination thereof.","The present invention may be implemented as a computer program product wherein computer instructions, when processed by a computer, adapt the operation of the computer such that the methods and\/or techniques of the present invention are invoked or otherwise provided. Instructions for invoking the inventive methods may be stored in fixed or removable media, and\/or stored within a working memory within a computing device operating according to the instructions.","An exemplary embodiment of the YATL program transformation language and some features are described. Other embodiments include additional features. YATL has many advantages. By design, YATL is intuitive for programmers of procedural languages to learn and use. YATL provides powerful support for writing transformations in reference to elements of the target grammar through a compiler personality. YATL is also fully extensible, providing in-line access to the supporting Stratego and C back-end. Of course, other embodiments may be implemented differently. Already, YATL has had much success in writing practical program transformations for C and C++ in a commercial setting. Successful transformation applications include debugging instrumentation, byte ordering, refactoring, compiler migration, and others. In these applications, it has taken much less time to write YATL tools than to perform the modifications by hand, as done conventionally."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The teachings of the present invention can be readily understood by considering the following detailed description in conjunction with the accompanying drawings:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 2A","b":["2","2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 3A-3Q"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 6A","FIG. 6B"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
