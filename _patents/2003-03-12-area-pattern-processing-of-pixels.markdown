---
title: Area pattern processing of pixels
abstract: A circuit for outputting area pattern bits from an area pattern array. The circuit includes a first stage, second stage and third stage. The first stage is configured to output N adjacent scan lines from a 2N×2N area pattern array based on a first address. N is a positive integer. The second stage is configured to receive the N adjacent scanlines and to select an N×N block from the N adjacent scanlines based on a second address. The third stage is configured to (a) select an (N/2)×N region of bits from the N×N block and load bits of the (N/2)×N region into a set of pixel tag outputs in a first mode, and (b) select an N×(N/2) region of bits from the N×N block and load bits of the N×(N/2) region into the set of pixel tag outputs in a second mode.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06924808&OS=06924808&RS=06924808
owner: Sun Microsystems, Inc.
number: 06924808
owner_city: Santa Clara
owner_country: US
publication_date: 20030312
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY CLAIM","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application claims priority to U.S. Provisional Application No. 60\/363,654 filed on Mar. 12, 2002 entitled \u201cArea Pattern Processing of Pixels in Super Sample Mode\u201d invented by Steve M. Kurihara and Charles F. Patton. This Provisional Application is hereby incorporated by reference in its entirety as though fully and completely set forth herein.","1. Field of the Invention","This invention relates generally to the field of computer graphics and, more particularly, to a pipelined system and method for generating an area pattern for controlling various pixel operations within a graphics accelerator system.","2. Description of the Related Art","Early graphics systems were limited to two-dimensional (2D) graphics, were configured to compute a gray scale value for each pixel displayed, and acted as simple translators or interfaces to a display device. Modern high performance graphics systems, however, may support three-dimensional (3D) graphics with one or more special effects such as anti-aliasing, texturing, shading, fogging, alpha-blending, and specular highlighting. 3D graphics data may be several orders of magnitude larger than comparable 2D graphics data. 3D graphics data may include a set of information components for each vertex of the geometric primitives used to model the objects to be imaged.","In recent years, demand for high performance graphics systems that can render complex three-dimensional (3D) objects and scenes have increased substantially. This increase is at least in part due to the demand for new applications such as computer-generated animation for motion pictures, virtual reality simulators\/trainers, and interactive computer games. These new applications place tremendous computational loads upon graphics systems. Modern computer displays have also improved and have a significantly higher pixel resolution, greater color depth, and are able to display more complex images with higher refresh rates than earlier models. Consequently, modern high performance graphics systems incorporate graphics processors with a great deal of complexity and power, and the color value of one pixel may be the accumulated result of many calculations involving several models and mathematical approximations.","With each new generation of graphics system, there is more image data to process, the processing is more complex, and there is less time in which to process it. Thus, there exists a continual need for more efficient graphical processing resources. In particular, there exists a significant need for circuits and processes capable of efficiently generating area patterns for pixels and\/or supersamples.","A graphics system may generate blocks of data (such as pixels) and apply bits of an area pattern (stored in a memory) to the blocks. Area patterning in graphics systems has typically been implemented in a fashion that constrains block origin addresses to be aligned within the area pattern array. This is unfortunate because in certain circumstances it may be advantageous for rendering hardware and\/or software to generate data blocks (e.g., blocks of pixels or supersamples) with addresses that are not necessarily aligned with respect to the area pattern array (or regularly demarked boundaries within the area pattern array). Thus, there exists a need for a circuit and corresponding methodology capable of mapping bits of an area pattern onto blocks having arbitrary origins with respect to the array pattern array.","In one set of embodiments, a circuit for outputting area pattern bits from an area pattern array. The circuit includes a first stage, second stage and third stage. The first stage is configured to output N adjacent scan lines from a 2N\u00d72N area pattern array based on a first address. N is a positive integer. The second stage is configured to receive the N adjacent scanlines and to select an N\u00d7N block from the N adjacent scanlines based on a second address. The third stage is configured to (a) select an (N\/2)\u00d7N region of bits from the N\u00d7N block and load bits of the (N\/2)\u00d7N region into a set of pixel tag outputs in a first mode, and (b) select an N\u00d7(N\/2) region of bits from the N\u00d7N block and load bits of the N\u00d7(N\/2) region into the set of pixel tag outputs in a second mode. The first mode may be a standard (pixel) mode and the second mode may be a supersample mode.","This area patterning circuit may advantageously allow the patterning of blocks having arbitrary origins with respect to the array pattern array.","The parameter N may be a power of two. For example, in one embodiment, N=16. However, the inventive principles described herein naturally generalize to the arbitrary positive integer N.","The N adjacent scan lines are consecutive scan lines in the circular topology (i.e., modulo 2N topology) of the area pattern array.","In some embodiments, the first stage includes a first rank of M register files and a second rank of M register files, where M is a positive integer. Each register file of the first rank may store 2N\/M scan lines of the area pattern array. Furthermore, each register file of the second rank may store N\/M scan lines of the area pattern array. The first rank may be configured to output a first set of (N\/2) of the N adjacent scanlines, and the second rank may be configured to output a second set of (N\/2) of the N adjacent scanlines. The register files are programmable by a host processor.","The second stage may include an array of N mux logic units. Each mux logic unit may be configured to receive a corresponding one of the N adjacent scanlines and to select a set of N consecutive bits defined by the second address input from the corresponding scanline.","The second stage may include a first level of muxes and a second level of muxes coupled to the outputs of the first level of muxes. The first level of muxes may be controlled by y (i.e., vertical) address information. The second level of muxes may be controlled by a stereo indicator bit that selects between stereo mode and non-stereo mode.","The third stage may be further configured to select a K\u00d7Krectangle of bits from the N\u00d7N block in response to an opcode input indicating a pixel write fragment mode. The third stage may be configured to generate a set of K*Kinhibit signal outputs based on the values of the K\u00d7Krectangle of bits. The inhibit signal outputs conditionally inhibit pixel write operations for a corresponding rectangular tile of pixels. In one embodiment, K=K=2. Furthermore, the third stage may generate a set of source select signal outputs based on values of the K\u00d7Krectangle of bits and control input signals. The source select control signals may determine data sources color information (e.g., RGB values) and a data source alpha information.","In another set of embodiments, a method for outputting bits from an area pattern array may be arranged as follows. The method may include:\n\n","In yet another set of embodiments, a graphics system may be configured to include a frame buffer and a hardware accelerator. The hardware accelerator may be operable to receive graphics data, to render samples in response to the graphics data, to store the samples in the frame buffer, to read and filter the samples from the frame buffer to generate pixels, and to store the pixels in the frame buffer. The hardware accelerator may include a circuit for outputting pattern bits of an area pattern in one or more formats depending on a mode of operation. The pattern bits may control pixel operations such as pixel write operations, data source selection operations, or block write operations (e.g., fast fill or fast fill partial operations).","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and will herein be described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Note, the headings are for organizational purposes only and are not meant to be used to limit or interpret the description or claims. Furthermore, note that the word \u201cmay\u201d is used throughout this application in a permissive sense (i.e., having the potential to, being able to), not a mandatory sense (i.e., must).\u201d The term \u201cinclude\u201d, and derivations thereof, mean \u201cincluding, but not limited to\u201d. The term \u201cconnected\u201d means \u201cdirectly or indirectly connected\u201d, and the term \u201ccoupled\u201d means \u201cdirectly or indirectly connected\u201d.","Computer System\u2014",{"@attributes":{"id":"p-0039","num":"0041"},"figref":"FIG. 1","b":"80"},"As shown, the computer system  includes a system unit  and a video monitor or display device  coupled to the system unit . The display device  may be any of various types of display monitors or devices (e.g., a CRT, LCD, or gas-plasma display). Various input devices may be connected to the computer system, including a keyboard  and\/or a mouse , or other input device (e.g., a trackball, digitizer, tablet, six-degree of freedom input device, head tracker, eye tracker, data glove, or body sensors). Application software may be executed by the computer system  to display graphical objects on display device .","Computer System Block Diagram\u2014",{"@attributes":{"id":"p-0041","num":"0043"},"figref":"FIG. 2","b":["1","80","102","104","104","106","104"]},"Host processor  may include one or more processors of varying types, e.g., microprocessors, multi-processors and CPUs. The system memory  may include any combination of different types of memory subsystems such as random access memories (e.g., static random access memories or \u201cSRAMs,\u201d synchronous dynamic random access memories or \u201cSDRAMs,\u201d and Rambus dynamic random access memories or \u201cRDRAMs,\u201d among others), read-only memories, and mass storage devices. The system bus or host bus  may include one or more communication or host computer buses (for communication between host processors, CPUs, and memory subsystems) as well as specialized subsystem buses.","In , a graphics system  is coupled to the high-speed memory bus . The graphics system  may be coupled to the bus  by, for example, a crossbar switch or other bus connectivity logic. It is assumed that various other peripheral devices, or other buses, may be connected to the high-speed memory bus . It is noted that the graphics system  may be coupled to one or more of the buses in computer system  and\/or may be coupled to various types of buses. In addition, the graphics system  may be coupled to a communication port and thereby directly receive graphics data from an external source, e.g., the Internet or a network. As shown in the figure, one or more display devices  may be connected to the graphics system .","Host CPU  may transfer information to and from the graphics system  according to a programmed input\/output (I\/O) protocol over host bus . Alternately, graphics system  may access system memory  according to a direct memory access (DMA) protocol or through intelligent bus mastering.","A graphics application program conforming to an application programming interface (API) such as OpenGL\u00ae or Java 3D\u2122 may execute on host CPU  and generate commands and graphics data that define geometric primitives such as polygons for output on display device . Host processor  may transfer the graphics data to system memory . Thereafter, the host processor  may operate to transfer the graphics data to the graphics system  over the host bus . In another embodiment, the graphics system  may read in geometry data arrays over the host bus  using DMA access cycles. In yet another embodiment, the graphics system  may be coupled to the system memory  through a direct port, such as the Advanced Graphics Port (AGP) promulgated by Intel Corporation.","The graphics system may receive graphics data from any of various sources, including host CPU  and\/or system memory , other memory, or from an external source such as a network (e.g. the Internet), or from a broadcast medium, e.g., television, or from other sources.","Note while graphics system  is depicted as part of computer system , graphics system  may also be configured as a stand-alone device (e.g., with its own built-in display). Graphics system  may also be configured as a single chip device or as part of a system-on-a-chip or a multi-chip module. Additionally, in some embodiments, certain of the processing operations performed by elements of the illustrated graphics system  may be implemented in software.","Graphics System\u2014",{"@attributes":{"id":"p-0048","num":"0050"},"figref":"FIG. 3","b":["112","112","112","14","18","20","22","24","112","26","28","14","18"]},"In some embodiments, one or more of these components may be removed. For example, the texture buffer may not be included in an embodiment that does not provide texture mapping. In other embodiments, all or part of the functionality incorporated in either or both of the media processor or the hardware accelerator may be implemented in software.","In one set of embodiments, media processor  is one integrated circuit and hardware accelerator is another integrated circuit. In other embodiments, media processor  and hardware accelerator  may be incorporated within the same integrated circuit. In some embodiments, portions of media processor  and\/or hardware accelerator  may be included in separate integrated circuits.","As shown, graphics system  may include an interface to a host bus such as host bus  in  to enable graphics system  to communicate with a host system such as computer system . More particularly, host bus  may allow a host processor to send commands to the graphics system . In one embodiment, host bus  may be a bi-directional bus.","Media Processor\u2014",{"@attributes":{"id":"p-0052","num":"0054"},"figref":"FIG. 4","b":["14","14","112","80","80","112","14"]},"Transformation refers to the spatial manipulation of objects (or portions of objects) and includes translation, scaling (e.g. stretching or shrinking), rotation, reflection, or combinations thereof. More generally, transformation may include linear mappinga (e.g. matrix multiplications), nonlinear mappings, and combinations thereof.","Lighting refers to calculating the illumination of the objects within the displayed image to determine what color values and\/or brightness values each individual object will have. Depending upon the shading algorithm being used (e.g., constant, Gourand, or Phong), lighting may be evaluated at a number of different spatial locations.","As illustrated, media processor  may be configured to receive graphics data via host interface . A graphics queue  may be included in media processor  to buffer a stream of data received via the accelerated port of host interface . The received graphics data may include one or more graphics primitives. As used herein, the term graphics primitive may include polygons, parametric surfaces, splines, NURBS (non-uniform rational B-splines), sub-divisions surfaces, fractals, volume primitives, voxels (i.e., three-dimensional pixels), and particle systems. In one embodiment, media processor  may also include a geometry data preprocessor  and one or more microprocessor units (MPUs) . MPUs  may be configured to perform vertex transformation, lighting calculations and other programmable functions, and to send the results to hardware accelerator . MPUs  may also have read\/write access to texels (i.e. the smallest addressable unit of a texture map) and pixels in the hardware accelerator . Geometry data preprocessor  may be configured to decompress geometry, to convert and format vertex data, to dispatch vertices and instructions to the MPUs , and to send vertex and attribute tags or register data to hardware accelerator .","As shown, media processor  may have other possible interfaces, including an interface to one or more memories. For example, as shown, media processor  may include direct Rambus interface  to a direct Rambus DRAM (DRDRAM) . A memory such as DRDRAM  may be used for program and\/or data storage for MPUs . DRDRAM  may also be used to store display lists and\/or vertex texture maps.","Media processor  may also include interfaces to other functional components of graphics system . For example, media processor  may have an interface to another specialized processor such as hardware accelerator . In the illustrated embodiment, controller  includes an accelerated port path that allows media processor  to control hardware accelerator . Media processor  may also include a direct interface such as bus interface unit (BIU) . Bus interface unit  provides a path to memory  and a path to hardware accelerator  and video output processor  via controller .","Hardware Accelerator\u2014","One or more hardware accelerators  may be configured to receive graphics instructions and data from media processor  and to perform a number of functions on the received data according to the received instructions. For example, hardware accelerator  may be configured to perform rasterization, 2D and\/or 3D texturing, pixel transfers, imaging, fragment processing, clipping, depth cueing, transparency processing, set-up, and\/or screen space rendering of various graphics primitives occurring within the graphics data.","Clipping refers to the elimination of graphics primitives or portions of graphics primitives that lie outside of a 3D view volume in world space. The 3D view volume may represent that portion of world space that is visible to a virtual observer (or virtual camera) situated in world space. For example, the view volume may be a solid truncated pyramid generated by a 2D view window, a viewpoint located in world space, a front clipping plane and a back clipping plane. The viewpoint may represent the world space location of the virtual observer. In most cases, primitives or portions of primitives that lie outside the 3D view volume are not currently visible and may be eliminated from further processing. Primitives or portions of primitives that lie inside the 3D view volume are candidates for projection onto the 2D view window.","Set-up refers to mapping primitives to a three-dimensional viewport. This involves translating and transforming the objects from their original \u201cworld-coordinate\u201d system to the established viewport's coordinates. This creates the correct perspective for three-dimensional objects displayed on the screen.","Screen-space rendering refers to the calculations performed to generate the data used to form each pixel that will be displayed. For example, hardware accelerator  may calculate \u201csamples.\u201d Samples are points that have color information but no real area. Samples allow hardware accelerator  to \u201csuper-sample,\u201d or calculate more than one sample per pixel. Super-sampling may result in a higher quality image.","Hardware accelerator  may also include several interfaces. For example, in the illustrated embodiment, hardware accelerator  has four interfaces. Hardware accelerator  has an interface  (referred to as the \u201cNorth Interface\u201d) to communicate with media processor . Hardware accelerator  may receive commands and\/or data from media processor  through interface . Additionally, hardware accelerator  may include an interface  to bus . Bus  may connect hardware accelerator  to boot PROM  and\/or video output processor . Boot PROM  may be configured to store system initialization data and\/or control code for frame buffer . Hardware accelerator  may also include an interface to a texture buffer . For example, hardware accelerator  may interface to texture buffer  using an eight-way interleaved texel bus that allows hardware accelerator  to read from and write to texture buffer . Hardware accelerator  may also interface to a frame buffer . For example, hardware accelerator  may be configured to read from and\/or write to frame buffer  using a four-way interleaved pixel bus.","The vertex processor  may be configured to use the vertex tags received from the media processor  to perform ordered assembly of the vertex data from the MPUs . Vertices may be saved in and\/or retrieved from a mesh buffer .","The render pipeline  may be configured to rasterize 2D window system primitives and 3D primitives into fragments. A fragment may contain one or more samples. Each sample may contain a vector of color data and perhaps other data such as alpha and control tags. 2D primitives include objects such as dots, fonts, Bresenham lines and 2D polygons. 3D primitives include objects such as smooth and large dots, smooth and wide DDA (Digital Differential Analyzer) lines and 3D polygons (e.g. 3D triangles).","For example, the render pipeline  may be configured to receive vertices defining a triangle, to identify fragments that intersect the triangle.","The render pipeline  may be configured to handle full-screen size primitives, to calculate plane and edge slopes, and to interpolate data (such as color) down to tile resolution (or fragment resolution) using interpolants or components such as:\n\n","In embodiments using supersampling, the sample generator  may be configured to generate samples from the fragments output by the render pipeline  and to determine which samples are inside the rasterization edge. Sample positions may be defined by user-loadable tables to enable stochastic sample-positioning patterns.","Hardware accelerator  may be configured to write textured fragments from 3D primitives to frame buffer . The render pipeline  may send pixel tiles defining r, s, t and w to the texture address unit . The texture address unit  may determine the set of neighboring texels that are addressed by the fragment(s), as well as the interpolation coefficients for the texture filter, and write texels to the texture buffer . The texture buffer  may be interleaved to obtain as many neighboring texels as possible in each clock. The texture filter  may perform bilinear, trilinear or quadlinear interpolation. The pixel transfer unit  may also scale and bias and\/or lookup texels. The texture environment  may apply texels to samples produced by the sample generator . The texture environment  may also be used to perform geometric transformations on images (e.g., bilinear scale, rotate, flip) as well as to perform other image filtering operations on texture buffer image data (e.g., bicubic scale and convolutions).","In the illustrated embodiment, the pixel transfer MUX  controls the input to the pixel transfer unit . The pixel transfer unit  may selectively unpack pixel data received via north interface , select channels from either the frame buffer  or the texture buffer , or select data received from the texture filter  or sample filter .","The pixel transfer unit  may be used to perform scale, bias, and\/or color matrix operations, color lookup operations, histogram operations, accumulation operations, normalization operations, and\/or min\/max functions. Depending on the source of (and operations performed on) the processed data, the pixel transfer unit  may output the processed data to the texture buffer  (via the texture buffer MUX ), the frame buffer  (via the texture environment unit  and the fragment processor ), or to the host (via north interface ). For example, in one embodiment, when the pixel transfer unit  receives pixel data from the host via the pixel transfer MUX , the pixel transfer unit  may be used to perform a scale and bias or color matrix operation, followed by a color lookup or histogram operation, followed by a min\/max function. The pixel transfer unit  may then output data to either the texture buffer  or the frame buffer .","Fragment processor  may be used to perform standard fragment processing operations such as the OpenGL\u00ae fragment processing operations. For example, the fragment processor  may be configured to perform the following operations: fog, area pattern, scissor, alpha\/color test, ownership test (WID), stencil test, depth test, alpha blends or logic ops (ROP), plane masking, buffer selection, pick hit\/occlusion detection, and\/or auxiliary clipping in order to accelerate overlapping windows.","Texture Buffer ","Texture buffer  may include several SDRAMs. Texture buffer  may be configured to store texture maps, image processing buffers, and accumulation buffers for hardware accelerator . Texture buffer  may have many different capacities (e.g., depending on the type of SDRAM included in texture buffer ). In some embodiments, each pair of SDRAMs may be independently row and column addressable.","Frame Buffer ","Graphics system  may also include a frame buffer . In one embodiment, frame buffer  may include multiple 3D-RAM memory devices (e.g. 3D-RAM64 memory devices) manufactured by Mitsubishi Electric Corporation. Frame buffer  may be configured as a display pixel buffer, an offscreen pixel buffer, and\/or a supersample buffer. Furthermore, in one embodiment, certain portions of frame buffer  may be used as a display pixel buffer, while other portions may be used as an offscreen pixel buffer and sample buffer.","Video Output Processor\u2014","A video output processor  may also be included within graphics system . Video output processor  may buffer and process pixels output from frame buffer . For example, video output processor  may be configured to read bursts of pixels from frame buffer . Video output processor  may also be configured to perform double buffer selection (dbsel) if the frame buffer  is double-buffered, overlay transparency (using transparency\/overlay unit ), plane group extraction, gamma correction, psuedocolor or color lookup or bypass, and\/or cursor generation. For example, in the illustrated embodiment, the output processor  includes WID (Window ID) lookup tables (WLUTs)  and gamma and color map lookup tables (GLUTs, CLUTs) . In one embodiment, frame buffer  may include multiple 3DRAM64s  that include the transparency overlay  and all or some of the WLUTs . Video output processor  may also be configured to support two video output streams to two displays using the two independent video raster timing generators . For example, one raster (e.g., A) may drive a 1280\u00d71024 CRT while the other (e.g., B) may drive a NTSC or PAL device with encoded television video.","DAC  may operate as the final output stage of graphics system . The DAC  translates the digital pixel data received from GLUT\/CLUTs\/Cursor unit  into analog video signals that are then sent to a display device. In one embodiment, DAC  may be bypassed or omitted completely in order to output digital pixel data in lieu of analog video signals. This may be useful when a display device is based on a digital technology (e.g., an LCD-type display or a digital micro-mirror display).","DAC  may be a red-green-blue digital-to-analog converter configured to provide an analog video output to a display device such as a cathode ray tube (CRT) monitor. In one embodiment, DAC  may be configured to provide a high resolution RGB analog video output at dot rates of 240 MHz. Similarly, encoder  may be configured to supply an encoded video signal to a display. For example, encoder  may provide encoded NTSC or PAL video to an S-Video or composite video television monitor or recording device.","In other embodiments, the video output processor  may output pixel data to other combinations of displays. For example, by outputting pixel data to two DACs  (instead of one DAC  and one encoder ), video output processor  may drive two CRTs. Alternately, by using two encoders , video output processor  may supply appropriate video input to two television monitors. Generally, many different combinations of display devices may be supported by supplying the proper output device and\/or converter for that display device.","Sample-to-Pixel Processing Flow","In one set of embodiments, hardware accelerator  may receive geometric parameters defining primitives such as triangles from media processor , and render the primitives in terms of samples. The samples may be stored in a sample storage area (also referred to as the sample buffer) of frame buffer . The samples are then read from the sample storage area of frame buffer  and filtered by sample filter  to generate pixels. The pixels are stored in a pixel storage area of frame buffer . The pixel storage area may be double-buffered. Video output processor  reads the pixels from the pixel storage area of frame buffer  and generates a video stream from the pixels. The video stream may be provided to one or more display devices (e.g. monitors, projectors, head-mounted displays, and so forth) through DAC  and\/or video encoder .","The samples are computed at positions in a two-dimensional sample space (also referred to as rendering space). The sample space may be partitioned into an array of bins (also referred to herein as fragments). The storage of samples in the sample storage area of frame buffer  may be organized according to bins (e.g. bin ) as illustrated in FIG. . Each bin may contain one or more samples. The number of samples per bin may be a programmable parameter.","Please refer to U.S. patent application Ser. No. 10,383,234, filed on Mar. 6, 2003, entitled \u201cDynamically Adjusting A Number of Rendering Passes in a Graphics System\u201d, invented by Michael G. Lavelle, for additional description of various embodiments of graphics system , hardware accelerator  and frame buffer . This patent application is hereby incorporated by reference in its entirety.","Fragment Processor","The hardware accelerator  includes a fragment processor (FP)  as shown in FIG. . The FP receives data, address and control signals from the texture environment (TE)  and outputs this data to the frame buffer address translation module (FBA). Various single pixel\/sample processes may be performed in the FP. The FP may operate on 2\u00d72 non-textured or textured fragment tiles. The FP may perform pixel merging in non-supersampled mode.","The FP may determine whether or not a pixel\/sample is to be drawn into the frame buffer , substitute colors in some cases, modify the color in other cases, and specify how the pixel\/sample color is to be combined with the existing pixel\/sample color in the frame buffer. The FP is situated between the texture environment unit (TE) and the FBA in the pixel pipeline and performs various functions including: viewport clipping (2D,3D); auxiliary clipping; alpha clipping; alpha test; color test; depth cueing (fog); area patterning; and fragment merging.","In one set of embodiments, the FP has three external interfaces: the TE interface, the FBA interface, and a read port interface (e.g., an UPA read port interface). (UPA is acronym for Universal Port Architecture.)  illustrates one embodiment of these three interfaces within the hardware accelerator .","The FP may include a control pipeline along with several datapath pipelines which process the pixel\/sample information before sending it out to the FBA interface.  illustrates one embodiment of the FP.","The Z submodule (also referred to as the Z pipeline) selects a source for Z data. The source data comes from either the TE interface, or constant source registers in the FP. The Z submodule contains Z clipping logic. The result generated by the Z clipping logic may be sent to the control pipeline where other clipping tests may be performed.","During a \u201cfast fill partial\u201d operation, the render pipe  may generate blocks of pixel tags and forward these pixel tags to the FP. In one embodiment, a block includes 128 pixels tags. The pixel tags are received by the alpha pipeline and z pipeline, and forwarded to the area pattern pipeline. These pixel tags are then processed with the block pattern bits in the area pattern pipeline before being sent back through the alpha pipeline and z pipeline for subsequent output to the merge unit.","The depth cue submodule may implement a fog feature. This depth cue function may scale the intensity of the color channels for each 2\u00d72 tile of pixels\/samples output as a function of depth (Z). In one embodiment, a total of eight slope regions may be used to determine the fog scale factor as a function of Z.","The address pipeline may receive the screen space X\/Y tile address, bin address, and sample number from the TE interface, and send this address information to the merge unit. The merge unit may forward this address information to the FBA interface. In addition, the 2D viewport clip tests may be performed with respect to the auxiliary clip regions and the normal viewport clip region. The clipping results may be output to the control pipeline where they are combined with other clipping tests.","The area pattern submodule (also referred to as the area pattern pipeline) generates source select control signals for the alpha and color pipelines. These control signals are used to select the proper alpha and color channel sources.","The area pattern submodule may also receive the incoming pixel tag values sent on the AOWS and Z-channel during fastfill-partial operations, and process these pixel tags based on the block pattern bits in the area pattern array. The pixel tags are then sent back to the alpha pipeline and z pipeline where they are output to the merge unit. A set of pixel write inhibit signals used by the control submodule are also generated in the area pattern submodule. The area pattern submodule may contain a 32\u00d732 memory array which is used to store the 32\u00d732 area pattern. (AOWS is an acronym for alpha, overlay, window ID and stencil.)","The alpha submodule may select the source of the alpha data. For the alpha source, this data may be one of alpha, overlay, window ID, or stencil. In the case of alpha, the data may come from either the variable data from the TE interface, or constant data from either the foreground X data or the background X data. For overlay, the data may come from either the variable data from the TE interface, or constant data from either the foreground overlay data or the background overlay data. For window ID, the data may come from either the variable data from the TE interface, or from the constant WID register. And similarly for stencil, the data may come from either the TE interface or the constant stencil register. The X-threshold clip test is performed on the alpha channel.","During fastfill-partial operations, the pixel tags with the area pattern mask from the area pattern pipeline are sent to the alpha pipeline, where they are muxed with the actual AOWS data before being sent down to the merge unit.","The color submodule selects the proper color channel source. For the RGB color source, the data may come from either the constant background register, or the RGB data from the TE interface. The RGB data from the TE interface may be either variable data or constant data from the foreground register in the TE module.","Once the color channel source is determined, the color submodule combines this source data with the fog scale factor from the depth cue submodule. Fog equations are then used to calculate new RGB pixel data for each pixel\/sample of the 2\u00d72 tile. (Note that alpha blending may be performed in the memory devices of the frame buffer.) The color test may be performed on the new fog color for all three color channels and all four interleaves. (Note that the inventive principles described herein naturally generalize to any number of interleaves.)","The control pipeline may contain a set of control registers. The attributes specified by these registers may be used with the address, data, and control signals from the TE interface to generate the various control signals used within the FP datapaths. In addition, the control signals used by the FBA may be generated in this submodule.","The read port submodule may provide the read-back mechanism to read the registers in the FP. For register reads, the UPA module may send an address and a request signal to the FP. The FP may then send the read data back to the UPA module.","The merge unit may perform pixel merging. In one embodiment, the merge unit may perform two types of pixel merging in non-supersample mode. The merge unit may merge two tiles, each with pixel 0 enabled, into a single tile with two pixels enabled. Or it may merge two tiles, each with pixel 0 and pixel 1 enabled into a single tile with all four pixels enabled prior to sending it to the frame buffer write queue (FWQ) in the FBA. Pixel merging improves pixel write performance when crossing clock domains from GCLK to FCLK.","Fragment Processor Functionality","For the viewport clipping function, the FP may receive the incoming x,y tile address and bin address and compare it to the xmin, xmax, ymin, ymax values set in the viewport clip boundary registers. For 3D operations, the Z-value may also be compared against the zmin, zmax values. The pixel\/sample may be clipped (i.e., not written to the frame buffer ) if it lies outside the region specified by the register values.","For the auxiliary clipping function, the FP may receive the incoming x,y tile address and bin address and compares it to the xmin, xmax, ymin, ymax values set in the eight auxiliary clip boundary registers. The pixel\/sample may be clipped (i.e., not written to the frame buffer) if it lies outside the region specified by the register values.","Alpha Test. After the alpha source is determined, this alpha value may be compared against a reference value specified by the X-Data threshold register and the X-Test pass condition register. If the alpha test fails, the pixel\/sample may be clipped.","Color Test. After the color source is determined and the fog color is calculated, this RGB value may be compared against a reference value specified by the color threshold register and the color test pass condition register. If the color test fails for any one of the three color components, the pixel\/sample may be clipped.","Depth Cueing (Fog). A fog scale factor may be determined after converting the incoming floating point Z value to a fixed point Z value. The fog scale factor may be based on the fixed point Z value and an eight slope region fog function. The calculated fog scale factor may then be used in calculating the new fogged color. If fog is disabled, a fog scale factor of 1.0 may be used.","Area Patterning. A 32\u00d732 area pattern may be stored in register files within the FP. During a fastfill-partial operation or a fastfill-full operation, if area pattern is enabled, each pixel tag from the render pipe may be masked with the corresponding area pattern bit. In addition, if the FP receives a fastfill-full transaction and area pattern is enabled, the FP may convert this opcode to fastfill-partial before sending it to the FBA. During \u201cwrite fragment tile\u201d operations (wr_frag_tile), if area pattern is enabled, the area pattern bit may be used in conjunction with transparent background to determine if the pixel is to be written. Note that the inventive principles described herein naturally generalize area patterns of arbitrary size.","The type of operation to be performed may be determined by an opcode supplied by the TE interface. In  the opcode input is a 5-bit input and is referred to as te_fp_op.","Fragment Merging. Pixels from separate tiles may be merged into a single time if the separate tiles meet certain criteria. In one embodiment, pixels may be merged from two separate tiles as follows. Two back-to-back tiles with single pixels in interleave 0 may be merged into a single tile with pixel 0 and pixel 1 enabled (horizontal merge). Or two back-to-back tiles, each with pixel 0 and pixel 1 enabled, may be merged into a single tile with all four pixels enabled (vertical merge). In some embodiments, pixels may be merged only in non-supersampled mode.","Area Pattern Pipeline","The area pattern pipeline generates the source select control signals which are used in selecting the alpha and color channel sources. Also, the area pattern pipeline generates (or modifies) the pixel tag values (i.e., pixtag0[31:0], pixtag1[31:0], pixtag2[31:0] and pixtag3[31:0]) for the Z and AOWS pipelines. Additionally, the area pattern pipeline generates the pixel write inhibit signals (i.e., wrinh0, wrinh1, wrinh2 and wrinh3) that are output to the control pipeline. The area pattern pipeline may contain eight 4\u00d732-bit register files and eight 2\u00d732-bit register files. These register files make up a 32-row by 32-column by 1-bit deep area pattern scan memory array. The memory array addressing is screen aligned: Y mod 32 is the row address to the memory array; X mod 32 is the column address to the memory array. Thus, the area pattern repeats every 32 pixels in X and Y. Depending on other control bits in the FPC register, the area pattern bits can determine the source of pixel data for the corresponding pixel and, in some cases, whether or not the pixel is to be written to the frame buffer. A first stage of the area pattern pipeline is illustrated in FIG. A.","In standard mode, the eight 4\u00d732 register files are used to read out a 16\u00d78 block of data (i.e., 8 scanlines of 16-bits each) from the area pattern array. In supersample mode, the eight 4\u00d732 register files and the eight 2\u00d732 register files are used to read out an 8\u00d716 block (i.e., 16 scanlines of 8-bits each).","The first stage of the area pattern pipeline includes the read address, write address, write data, and write enable registers within the register files themselves. For the 4\u00d732 register files, the Y scanlines (i.e., horizontal rows) of the area pattern are stored as follows:\n\n","The register file outputs are then registered before sending the data to the second stage. The output of the eight 4\u00d732 register files are also muxed onto the 32-bit bus, apc_apd[31:0], which serves as a register readback path.","As an example, if te_fp_y[4:0]=00011 (i.e., 3 decimal) the first stage outputs scanlines 3-18 inclusive as follows:\n\n","As another example, if te_fp_y[4:0]=01001 (i.e., 9 decimal) the first stage outputs scanlines 9-24 as follows:\n\n","As yet another example, if te_fp_y[4:0]=11110, i.e., 30 decimal, the first stage outputs scanlines 30, 31 and 0-13 as follows:\n\n","In the second stage (illustrated in ) the 16 row\u00d732 column region may be narrowed down to a 16 row\u00d716 column region as suggested by  using the ca_p1_x[4:0] address bits, and the cap_p1_std_ssp mode bit (which distinguishes been standard mode and supersample mode). The 16 scanlines generated by the first stage are supplied to 16 corresponding mux logic units. The first eight mux logic units receive the scanlines p1_apd0 through p1_apd7 generated by the 4\u00d732 register files. The last eight mux logic units receive the scanlines p_apd8 through p_apd15 generated by the 2\u00d732 register files.","Each mux logic unit selects and outputs 16 consecutive bits starting at the address ca_p1_x[4:0] from its 32 bit input scanline. In particular, each mux logic unit may select the sixteen bits defined by (ca_p1_x[4:0]+j) mod 32, where j ranges from 0 through 15 inclusive.","The next two levels of muxes in the second stage use the ca_p1_y[2] address bit along with the a stereo mode indicator bit (i.e., cap_stereo) to select the proper eight rows in the y-direction.","The third stage of the area pattern pipeline (see ) includes combinatorial logic that narrows the 16 row\u00d716 column region provided by the second stage to an 8 row\u00d716 column region in standard mode, or, to a 16 row\u00d78 column region in supersample mode as suggested by FIG. . The input line p2_std_ssp may determine which mode is in effect.","The third stage receives 16 rows of which the first eight are denoted p2_ap0L3 through p2_ap7L3 and the last eight are denoted p2_apd8L1 through p2_apd15L1. The L3 in the first eight row names indicates that they derive from layer 3 of the second stage. Similarly, the L1 in the last eight row names indicates that they derive from the first layer of the second stage.","In standard mode, the 128 pattern bits from the first eight rows, i.e., p2_ap0L3 through p2_ap7L3, may be used to mask the 128 pixel tag bits contained in the inputs:\n\n","In supersample mode, the 128 pattern bits from the first eight columns of each of the 16 rows, i.e., rows p2_ap0L3 through p2_ap7L3 and rows p2_apd8L1 through p2_apd15L1, may be used to mask the 128 pixel tag bits contained in the inputs:\n\n","During a fast fill operation or fastfill partial operation, the third stage may generate the pixel tag output as indicated above based on the mode indicator p2_std_ssd.","During a \u201cwrite fragment tile\u201d operation (wr_frag_tile), the third stage may generate:\n\n",{"@attributes":{"id":"p-0122","num":"0211"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0123","num":"0212"},"figref":"FIG. 15"},"The third stage of the area pattern pipeline receives three color source select signals (cap_cs_r, cap_cs_g, cap_cs_b), an area pattern enable (cap_ap), a transparent background enable (cap_tb), an x source select (cap_xs) from the FPC register of the control pipeline. The third stage may perform the operations indicated by  to generate the color source select and x source select output signals.","Among other inputs, the third stage receives:\n\n","Note: Many of the signals described herein follow the convention of having a one (or two) letter prefix for the source submodule, followed by a one (or two) letter prefix for the destination submodule, followed by the signal name. These prefix letters are summarized in following table.",{"@attributes":{"id":"p-0127","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Table of Submodule Prefix Letters"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Submodule Name","Submodule Prefix Letters"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Z-Pipeline","z"]},{"entry":[{},"Depth-Cue Pipeline","d"]},{"entry":[{},"Address Pipeline","a"]},{"entry":[{},"Area Pattern Pipeline","ap"]},{"entry":[{},"Alpha Pipeline","x"]},{"entry":[{},"Color Pipeline","cl"]},{"entry":[{},"Merge Unit","m"]},{"entry":[{},"Control Pipeline","c"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Although the embodiments above have been described in considerable detail, other versions are possible. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications. Note the section headings used herein are for organizational purposes only and are not meant to limit the description provided herein or the claims attached hereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing, as well as other objects, features, and advantages of this invention may be more completely understood by reference to the following detailed description when read together with the accompanying drawings in which:",{"@attributes":{"id":"p-0021","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0026"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0025","num":"0027"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0026","num":"0028"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0027","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0029","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0030","num":"0032"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0031","num":"0033"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0032","num":"0034"},"figref":"FIG. 10C"},{"@attributes":{"id":"p-0033","num":"0035"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0036"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0037"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0036","num":"0038"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0037","num":"0039"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
