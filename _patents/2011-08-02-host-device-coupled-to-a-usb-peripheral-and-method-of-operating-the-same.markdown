---
title: Host device coupled to a USB peripheral and method of operating the same
abstract: Embodiments of the present invention relate to methods and apparatus for operating a host device (e.g. a ‘plug-and-play’ host device) coupled to a peripheral device (e.g. a mobile phone). In some embodiments, the host device may analyzed peripheral device-descriptive data (e.g. including but not limited to USB endpoint data) and determine information about the peripheral device in accordance with the results of the analysis. Operations that may be carried out by the host device in accordance with results of the analysis include but are not limited to protocol selection, retrieval of cell phone data, and determining software or hardware resource(s) of the peripheral device. In some embodiments, it is possible to actively suppress natural OS behavior whereby a device driver(s) specified by the peripheral device (e.g. in a hardware identifier) is loaded by the host device. For example, it is possible to load a surrogate driver instead. In one example, the hardware identifier is intercepted and not forwarded to a plug-and-play manager executing on the host device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09514065&OS=09514065&RS=09514065
owner: MCE-SYS LTD.
number: 09514065
owner_city: Tel Aviv
owner_country: IL
publication_date: 20110802
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND AND RELATED ART","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION OF EMBODIMENTS","CONCLUSION"],"p":["Embodiments of the present invention relate to methods and apparatus for operating a host device (e.g. a \u2018plug-and-play\u2019 host device) coupled to a peripheral device (e.g. a mobile phone).","USB Descriptor Data","USB provides an expandable, hot-pluggable Plug and Play serial interface that ensures a standard, low-cost connection for peripheral devices such as storage devices, keyboards, joysticks, printers, scanners, modems, and digital cameras.","USB uses a set of data called \u201cdescriptors\u201d to allow devices to be properly recognized by the host. In USB 1.x, the following five descriptors were used: \u2018Device descriptor,\u2019 \u2018Configuration Descriptor,\u2019 \u2018Interface Descriptor,\u2019 \u2018Endpoint Descriptor,\u2019 and \u2018String Descriptor.\u2019","The first four of these descriptors may be arranged hierarchically as illustrated in . According to the \u201cRenesas\u201d website (http:\/\/www2.renesas.com):","(A) the Device Descriptor \u201cspecifies information such as the supported USB version, the Device Class, Device SubClass, Protocol, and maximum packet size for Endpoint . The Device Descriptor includes \u201cVender ID, Product ID, Device version, number of possible configurations, and Index of String Descriptor.\u201d There is exactly one device ID per device.","(B) the Configuration Descriptor \u201cspecifies information such as the number of interfaces, and the value for selecting the configuration.\u201d The Configure Descriptor includes: \u201cDevice attributes (i.e. how the device is powered), Consumption Electricity, and Index of String Descriptor.\u201d There are one or more configuration descriptors per device. As shown in , each configuration descriptor has one or more interface descriptors.","(C) the Interface Descriptor \u201cspecifies information such as the value for selecting the interface.\u201d As shown in , the Interface Descriptor is a \u2018struct\u2019 that includes: \u201cNumber of alternative settings, Number of endpoints, Interface Class, Interface SubClass, Interface Protocol, String Descriptor Index.\u201d","(D) the Endpoint Descriptor \u201cSpecifies information such as the value for selecting the endpoint.\u201d The Endpoint Descriptor includes \u201cTransfer type (direction of transfer), Maximum packet size available for transfer, and Interval for transfers.\u201d The Endpoint Descriptor \u201cExists independently for each Interface Descriptor. Depending on the interface, there may be an Interface Descriptor without Endpoint Descriptors, since Endpoint  is defined by a Device Descriptor and not an Endpoint Descriptor.\u201d","Sometimes, in the literature, people use the term \u2018Device Descriptor\u2019 to refer to additional hierarchies of USB descriptor data, below the \u2018Device Descriptor\u2019 level. In the present disclosure, USB \u2018Device Descriptor\u2019 data specifically refers to data of the USB \u2018Device Descriptor\u2019 hierarchy.","Plug and Play Apparatus and Techniques","Plug-and-play techniques and apparatus have been ubiquitous in the computing world for well over a decade. Operating systems that provide plug and play functionality include but are not limited to Windows\u00ae (i.e. various \u2018flavors\u2019 including but not limited to Windows 98, Windows CE, Windows 2000, Windows XP, Windows Vista and Windows 7), MacOS\u00ae and many distributions of Linux.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 2A-2B","b":["20","22","100","20","100","22","110","21"]},"A piece of operating system code running on host device  known as the USB host controller (illustrated in  as \u2018USB host controller code \u2019 which resides in memory  and is executed by processor((s)) listens to host-side port  and receives the USB device descriptor. The USB hub driver (i.e. implemented as executing code) generates directly or indirectly (e.g. by invoking a function call of one or more other code module(s)) a so-called \u2018Hardware ID\u2019 from at least a portion of the data of the USB Device Descriptor.","This \u2018hardware ID\u2019 specific for the peripheral device (in , specific for the printer) is: (i) generated according to content of the USB Device Descriptor and (ii) forwarded (see step S of ) from the executing USB host controller  code to another piece of executing operating system code known as the plug and play manager . Plug and play manager  responds to receiving the peripheral device identifier (in this case, a printer identifier) by loading device driver(s)  selected from a \u2018repository\u2019 or \u2018library\u2019 of device drivers that matches the hardware identifier (in this case, a printer identifier) (see step S of ).","In , this repository is referred to as the \u2018OS Device Driver Database \u2019 which (i) is located on the \u2018host-side\u2019 of the communications link  between respective USB ports , , (ii) may reside in any combination of device(s) on the host side including host device  and\/or any other device; (iii) may reside in any combination of volatile  and\/or non-volatile  storage; and which (iv) typically includes some sort of indexing data structure(s) which maps between various hardware IDs and the actual data driver data object(s) (e.g. files or any other data object). The \u2018OS Device Driver Database \u2019 and\/or any portion thereof may be provided as a single data structure and\/or may be distributed among data structures. In one non-limiting example, portions of the entirety of the \u2018OS Device Driver Database \u2019 may be located in the OS \u2018Registry.\u2019","Specifying of a Device Driver","The driver loaded in step S is not a generic driver determined exclusively by and\/or primarily by a USB device class (e.g. a generic printer driver, a generic modem driver). Instead, a \u2018customer\u2019 device driver (i.e. as opposed to a \u2018generic\u2019 or \u2018standard\u2019 device driver for that device class\u2014e.g. \u2018standard printer driver,\u2019 etc) that is \u2018specific for\u2019 the particular \u2018hardware ID\u2019 and that is \u2018specific for\u2019 the USB device descriptor data passed from the peripheral in step S is loaded in step S.","There is a casual relation between (i) the content of the USB Device Descriptor passed in step S from the peripheral to the host which determines the Hardware ID (as well as the content of the hardware ID passed from the USB hub driver to the plug-and-play manager in step S); and (ii) the identity of the actual device driver loaded into memory  in step S. Even though the USB Device Descriptor as well as the Hardware ID do not exclusively determine the identity of the actual device driver loaded into memory  in step S (this is determined in conjunction with the content of at least a portion of the host-side-residing OS device driver database ), the USB Device Descriptor as well as the Hardware ID certainly play a central role in determining the identity of the actual device driver.","Thus, in the present disclosure, it may be said that because the USB Device Descriptor as well as the Hardware ID play this central role in determining the identity of the actual device driver, that each \u2018specify\u2019 the device-specific driver loaded for the peripheral device (in , this device is a printer \u2014in , this driver is loaded in step S).","Steps S and S of ","The printer device driver(s)  loaded in step S exposes a printer API that translates device-independent printer commands (e.g. \u201cEndPage\u201d, or \u201cPrintWindow\u201d) to the specific printer's language. In addition, the printer API may also provide support for commands that are understood by a specific printer but are not necessarily device-independent printer commands, through API call such as \u201cWritePrinter.\u201d In this sense printer device driver(s)  may \u2018expand\u2019 or \u2018extend\u2019 the generic device-independent printer API to include additional printer commands","The printer API provided by printer device driver(s)  is available to user applications  (for example, word processor applications and Internet browsers or any other application) which utilize the printer API to send (see step S of ) specific printer commands (abbreviated as PCs) to the printer. The printer  receives these printer commands and sends (see step S of ) printer responses (i.e. \u2018on line\u2019 or \u2018out of toner\u2019) (abbreviated as PRs) to the user application .",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2C-2D","b":["30","32","31","39","21","29","36","36"]},"Coupling of Composite Devices to PC Hosts",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 2A-2D","b":["100","100"]},"In other example, the user may couple a \u2018composite\u2019 device to the host device . The USB spec defines a \u2018composite device\u2019 as \u201cA device that has multiple interfaces controlled independently of each other.\u201d","Using composite device, multiple functions are combined into a single device. For example, a \u2018mouse and a webcam\u2019 or a \u2018printer and a scanner\u2019 The example of  relate to the case of a \u2018printer and a mass-storage device.\u2019 In this example, multiple drivers are loaded for a USB peripheral single device\u2014the \u2018device descriptor\u2019 passed from the composite device  to the host , and the \u2018hardware ID\u2019 passed from the USB hub driver  and the plug and play manager  play a role in determining which particular drivers (i.e. specific for each device of the multiple devices of the composite device) are loaded for the \u2018composite device\u2019 . For a composite USB hub, hub driver code  may include a \u2018composite bus\u2019 component. Thus, for the case of the \u2018composite device,\u2019 the USB device descriptor and the \u2018hardware ID,\u2019 each may be said to \u2018specify device-specific drivers.\u2019",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 3A-3B","b":["100","100"]},"Although the details in the specific implementation of various steps may differ for the composite device case, at the level of description of  (see elements , ; see steps S, S, S, S and s), in all examples the host device loads multiple device drivers. In all examples, the host can send commands to multiple \u2018targets\u2019 after loading the drivers\u2014for example, in the example of , the host can send mass storage device commands to (i) a \u2018target\u2019 interface descriptor associated with a mass storage device type and (ii) \u2018target\u2019 interface descriptor associated with a printer device type.","Cell Phone Commands","Mobile telephones are ubiquitous in 21century life, and require no introduction.  is a block diagram of an exemplary cellular telephone device  including: a display screen , a keyboard  (for example, a numerical keypad including mechanical buttons or provided in the context of \u2018touch-screen\u2019 functionality), cellular communication circuitry , volatile and\/or non-volatile memory , one or more processors , a device-side port  and an antenna .","Cellular communication circuitry  (i.e. including any combination of hardware and\/or software for communicating with the cellular network according to a cellular network protocol) is configured to handle communication with the cellular network (e.g. including but not limited to Global System for Mobile Communications (GSM), General Packet Radio Service (GPRS), Code Division Multiple Access (CDMA), Evolution-Data Optimized (EV-DO), Enhanced Data Rates for GSM Evolution (EDGE), 3GSM, Digital Enhanced Cordless Telecommunications (DECT), Digital AMPS (IS-136\/TDMA), and Integrated Digital Enhanced Network (iDEN)). For example, cellular communication circuitry  may handle voice and\/or data protocols and\/or messaging protocols of the cellular network.","Although cellular communication circuitry is illustrated separately from CPU  and memory  this is not a requirement and in some embodiments one or more functions of the cellular network communication circuitry  is implemented by the processor  and memory . It is noted that \u2018circuitry\u2019 refers to any combination and software and is not limited to \u2018pure hardware\u2019 implementation.","According to the example of , the following items are stored within memory : data storage repository  for storing cell-phone-specific data cellular telephones (e.g. storing received SMS messages or for storing network identifier data for identifying the cellular phone's device identifier or subscriber number, a log of cellular network operations carried out by the phone device , or address book information), and data management code  for managing data access to the cellular-telephone-specific data.","It is appreciated that  is a block diagram, and that memory  may include different types of memory such as generic storage (e.g. flash memory formatted using a file system or as object-oriented storage) as well as other types of storage (e.g. a special cell-phone chip in which a cell phone device identifier is stored). Similarly, data storage repository  is only illustrated in general terms and may be distributed over various locations\u2014e.g. there is no requirement for SMS data and address book data to be stored together, SMS data may be stored in more than one format or location, etc","Data management code  (i.e. when executed by processor(s) ) regulates access to the cell-phone-specific data stored in cell-phone-specific data storage repository . For example, a set of commands or command sequences may be defined for accessing previously-received SMS messages or for accessing cellular log records (i.e. describing previous cellular network operations) or for accessing address book entries or for accessing a cell phone identifier.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5A","b":["11","15","300","328","328","300","100","324"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5B","b":["21","25","300","320","320","100","322","324"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5C","b":["31","300","35","300","328","300","328","324"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5D","b":["328","300","324","400","300","324"]},"Communicating with a Peripheral Telephone Device from a Host Device","It is common for cell-phone vendors to provide \u2018phone suite\u2019 software applications for communicating with a cell phone coupled to a host computer \u2014for example, running a \u2018plug-and-play\u2019 operating system such as Mac OS\u00ae or Windows\u00ae XP or Windows Vista\u00ae or Windows 7\u00ae.","When the cell phone device  is coupled to the host  as a peripheral \u2018slave\u2019 device, it is possible for the user to, for example, copy data (e.g. SMS data or phone address books entries) to his\/her laptop or desktop computer and\/or to operate the phone using a keyboard or other user control of the \u2018host device.\u2019 (e.g. laptop or desktop computer).","Upon coupling of the cell phone to the host device via the USB port, cell phone sends a USB hardware ID to the host device as in steps S, S, and S. However, there is no predefined USB device class for cell phones as is the case for other peripherals (i.e. printers, modems, etc). Thus, the USB hardware ID corresponds to devices other than cellular phone devices\u2014in the present disclosure, these non-cellular phone devices are referred to as \u2018surrogate devices.\u2019","For the present disclosure, a \u2018surrogate device\u2019 is a device having a class or type that is different from a phone device class\u2014exemplary surrogate devices include but are not limited to USB hubs, modems, printers, wireless devices and human interface devices (HID).",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIGS. 6A-6B","FIG. 6A"],"b":["120","152"]},"In step S of , in response to a device coupling between the host  and the mobile phone  (for example, a wired or wireless USB coupling), the mobile phone , presents itself to the host as a surrogate device (or array of one or more surrogate devices) other than a phone by passing a \u201csurrogate device identifier\u201d describing an array of one or non-phone devices. This surrogate device identifier is received by host device  via host-side port  (for example, a USB port). In particular, this surrogate device identifier is received by \u2018USB host controller\u2019  of the operating system.","In many examples, this surrogate device identifier describes a \u2018composite\u2019 device see the discussion above with respect to ).","As was seen for previous cases (see step S of , step S of , step S of ) in  USB Host Controller  automatically forwards (see step S) any device identifier (i.e. either the simple identifier or the identifier associated with a composite surrogate device) received via host-side port  to plug-and-play-manager \u2014thus, in the example of , the surrogate device identifier is forwarded to plug-and-play-manager  (step S).","In general, plug and play manager  then loads (in step s) into memory  a set of one or more drivers that match the device identifier(s) it receiver from USB host controller . For the specific yet ubiquitous example where the surrogate device identifier refers to a composite device, one or more teachings of  are employed in step S for example, to load\/invoke multiple driver objects for a surrogate composite device.","In one example relating to step S, if the user couples an audio device (class 01h) to the host  via host-side port , plug and play manager  loads appropriate audio device drivers into memory , and these audio device drivers execute in kernel mode. Thus, for the particular case of , the plug-and-play manager , which is not \u2018aware\u2019 of the \u2018true identity\u2019 of mobile phone , loads into memory  the surrogate device driver(s)  for the one or more surrogate devices of the surrogate device array (for example, printer drivers or modem drivers or human interface device (HID) drivers or any other drivers)\u2014this is S of .","In , the term \u2018surrogate device driver(s) \u2019 refers either to the device driver specified by the hardware ID passed from the phone  to the host or, for the case of phones that present themselves as composite devices, to the device driver \u2018indirectly\u2019 specified by a USB hardware ID.","Surrogate Device Driver(s)  does not provide a \u2018phone command interface. Instead, surrogate device driver is configured to receive and handle commands that match its device type\u2014if \u2018surrogate device driver\u2019  is a \u2018Wireless Communication Device\u2019 driver (or includes a \u2018Wireless Communication Device\u2019 for the case where there are a plurality of surrogate devices that are part of a composite surrogate device), then the surrogate device API exposed by surrogate device driver  is a \u2018Wireless Communication Device\u2019 command interface (i.e. for handling \u2018generic\u2019 and\/or proprietary printer commands). If \u2018surrogate device driver\u2019  is a modem driver, then the surrogate device API exposed by surrogate device driver  is a modem command interface, if \u2018surrogate device driver\u2019 is a mass storage driver, then the surrogate device API exposed by surrogate device driver  is a mass storage drive interface, as so on.","For the case of a composite surrogate device, the statements of the preceding paragraph may be true for each surrogate driver(s) of each device type.","One real-life example from known mobile phones is illustrated in .  illustrates a \u2018tree description\u2019 of visible on a host device (in this case, operating the Windows\u00ae operating system) that has connected to a single Nokia\u00ae N95 phone that presents itself as a composite device comprising more than one surrogate device;  illustrates a \u2018tree description\u2019 of visible on a host device (in this case, operating the Windows\u00ae operating system) that has connected to a single Sony Ericsson\u00ae K310 phone","In this case of the Nokia\u00ae phone (see ), when the phone device is coupled to the host device (i.e. where the phone device is a \u2018peripheral device\u2019), the phone device presents itself in step  as a composite device including a plurality of USB interface descriptor . . . . This surrogate composite device includes a number of USB interface descriptors\u2014including (i) a \u2018Nokia N95 8 GB Portable Device\u2019 of the \u2018Portable Device\u2019 device interface descriptor; (ii) a \u2018Nokia N95 Modem\u2019 Interface descriptor; (iii) a Nokia N95 8 GB USB ports of the \u2018port device type\u2019) and (iv) six separate wireless communications device.","In this case of the Sony-Ericsson\u00ae phone (see ), when the phone device is coupled to the host device (i.e. where the phone device is a \u2018peripheral device\u2019), the phone device presents itself in step  as a composite device). This surrogate composite device includes a number of USB interface descriptors (i) two separate modem devices; and (ii) two separate port devices.","For the case of \u2018composite surrogate devices\u2019, multiple surrogate class drivers  are loaded in step S for the single mobile phone (see ). For the example of the Nokia\u00ae N95 and the Sony Ericsson\u00ae K310 phones, the drivers for the devices illustrated in  are loaded in step S, and are collectively known as surrogate class drivers .","In some examples related to phones that present themselves as composite surrogate devices, having multiple devices of the same type (for example, more than one \u2018modem\u2019 as illustrated in ) may be useful to allow the host to communicate with the phone over similar multiple data channels.","In order for phone suite application  of  (i.e. which is a client of the surrogate device drivers ) to communicate with phone , phone suite application  utilizes the device API provided by the surrogate device driver . Since phone suite application  is custom-made and hard-wired for a particular family of phones (in some implementations, a given manufacturer (e.g. Motorola) may market several families of phones\u2014in this case, the user may be able to type in his\/her particular model or may provide related information using some sort of PC-based menu interface), phone suite application  is able to issue surrogate device commands rather than phone command according to some sort of mapping.","In one example, many phones expand the MODEM protocol (which was originally used for AT-commands) to additional commands, which all start with the AT-commands. These commands may be used to a variety of operations on the mobile phone  including managing contacts, getting information on the phone, updating phone software, etc. For example. Nokia(s) has a proprietary protocol called F-BUS used with its S family of phones. The communication starts with the following AT command:","Host: AT&F","Phone: AT&F OK","Host: AT*nokiafbus","Phone: AT",". . . from this point, the communication is in the F-BUS binary language. The F-BUS protocol includes a command to switch back to AT-commands protocol.","The commands sent by phone suite application  (for example, AT commands or F-Bus commands or printer commands such as \u2018line feed\u2019 or \u2018print test page\u2019) are thus surrogate device commands\u2014specific to a surrogate device such as a printer or a modem or any other surrogate device. They may specific either to a \u2018generic version of a surrogate device\u2019 or to a specific version of a surrogate device (analogous to device drivers that expand the basic command set for a particular device such as a modem or printer).","A Discussion of ",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 8"},"In step S, host receives a USB hardware identifier (e.g. corresponding to a non-phone surrogate device(s)) from the peripheral phone device. In step S, the host  loads the device driver(s) (e.g. surrogate device drivers) specified by the USB hardware identifier received from the peripheral phone .","In step S, the host (e.g. phone suite software ) communicates with the peripheral phone device  using the phone-specific loaded device drivers.","Below is a list of various features of the \u2018phone suite\u2019 paradigm for communicating peripheral cell phone devices:\n\n","Embodiments of the disclosed subject-matter relate to methods and apparatus for communicating with a peripheral cell phone device whereby instead of relying on the cell phone drivers directly or indirectly specified by the USB hardware identifier passed by the cellphone to the host, it is possible to (i) actively suppress the loading of a peripheral-device-specific driver into memory and (ii) to identify the cellphone from a plurality of candidates without relying on device drivers. Once the cellphone is properly identified (e.g. to determine a vendor identity, to determine phone hardware or software capabilities, to determine a protocol recognized by the peripheral phone, etc), it is possible to communicate with a cellphone according to its particular \u2018language\u2019 even if no information about the identity of the cellphone is provided to the host a priori (i.e. manually provided or provided by loading the cellphone-specific device driver).","In one non-limiting example, it is possible to analyze endpoint descriptor data of the peripheral cell phone, and then to compare the endpoint descriptor data to a database\u2014for example, residing on a host side of a host-peripheral USB interface. It has been determined that for many cases, USB endpoint descriptor data by itself and\/or in combination with other USB-fingerprint data (e.g. USB interface descriptor and\/or USB configuration descriptor and\/or USB device descriptor data) suffices, in many cases, to specify one or more of (i) a phone vendor name; (ii) a phone model name; (iii) phone hardware and\/or software resources; (iv) phone protocol features and (v) one or more additional phone-specific features.","As such, instead of assuming a priori that a user has coupled to the host device a phone from a specific vendor, it is possible to provide a relatively \u2018universal phone host\u2019 product which configures a host to appropriately communicate with phone devices from a relatively \u2018large\u2019 numbers of vendors and with a relatively \u2018large\u2019 number of models.","Instead of requiring the user to load into host device memory phone drivers when coupling the phone to the host device, it is possible to (i) suppress this behavior; (ii) \u2018recognize the phone\u2019 (i.e. even from a relatively \u2018large\u2019 and\/or \u2018diverse\u2019 set of candidates) without relying on device drivers. In many cases, this obviates the need for users to install vendor-specific PC phone suites on their host devices, and allows the user to simply plug in almost any phone of a relatively large \u2018set\u2019 of phone to his\/her host device and communicate with the coupled peripheral phone device (i.e. in many cases regardless of vendors) from the host device.","In different examples, it is possible for a user, from the host, to carry out various cellphone related operations from the host device in a substantially phone-model independent and\/or phone-vendor independent and\/or phone-chipset-independent and\/or phone-operating-system independent manner. This feature is provided despite the fact that most cellphones provide model-specific and\/or vendor-specific schemes for accessing cellphone data. Exemplary cellphone related operations include but are not limited to: (i) reading, writing or deleting SMS messages; (ii) reading or modifying a cell phone log; (iii) reading cell phone identifier information (e.g. International Mobile Equipment Identity (IMEI), Electronic Serial Number (ESN), or Mobile Equipment IDentifier (MEID)); and (iv) reading or modifying address book entrees.","In one non-limiting example, it is possible to maintain a database whereby a \u2018key\u2019 of each entry is cellphone-model specific data (e.g. USB fingerprint data down to the \u2018endpoint descriptor level\u2019) and that \u2018data\u2019 of each entry describes information about the specific model (e.g. vendor name, model number, protocol(s) recognized, schemes for accessing SMS or address book or log or phone identifier data, phone hardware or software resources, etc). When a \u2018candidate phone\u2019 is coupled to the host device, data descriptive of the \u2018candidate phone\u2019 (e.g. \u2018endpoint descriptor\u2019 data or other data) is used as a key to effect a \u2018look up\u2019 in the host-side database. After matching this descriptive data with the entry that provides the closest match, it is possible to read, from the host-side database, information specific to the now-\u2018identified\u2019 cellphone model.","It is then possible to display this information or related information to the user and\/or to communicate with the phone in a vendor-specific or model-specific manner (e.g. according to the \u2018correct protocols\u2019).","Some embodiments of the disclosed subject-matter relate to techniques for suppressing and\/or preventing the loading into memory of one or more specified drivers. Although this feature was explained above in the context of cell phone peripheral devices, it is now disclosed that, in some embodiments, this feature may be provided for any peripheral device (e.g. \u2018slave device\u2019) directly coupled with the host via a wired or wireless USB port, including but not limited to cell phone devices.","Some embodiments of the disclosed subject-matter relate to technique for \u2018identifying\u2019 and\/or \u2018recognizing\u2019 a peripheral cell phone device and\/or carrying out a model-specific or vendor-specific operation from the host related to the peripheral cell phone. Although this feature was explained above in the context of cell phone peripheral devices, it is now disclosed that, in some embodiments, this feature may be provided for any peripheral device (e.g. \u2018slave device\u2019) directly coupled with the host via a wired or wireless USB port, including but not limited to cell phone devices.","It is now disclosed a method of retrieving cell-phone related data from a peripheral cell phone device by a host device, the method comprising:","a. receiving USB endpoint descriptor data by the host device from the peripheral cell phone device that is coupled to the host device via a USB port;","b. analyzing the received USB endpoint descriptor data by the host device; and","c. in a manner determined by the results of the analysis of the USB endpoint descriptor data, retrieving by the host device from the peripheral cell phone device at least one:\n\n","In one example, phones from a \u2018first vendor\u2019 or from a \u2018first family of models\u2019 employ a first scheme for retrieving SMS messages (or other cell-phone data such as cell phone logs, address-books entries, or hardware identifiers), while phones from a \u2018second vendor\u2019 or from a \u2018second family of model.\u2019 In this example, it is possible to employ USB endpoint descriptor to identify the phone vendor and\/or model and\/or chipset and\/or model family to determine if the phone is from a \u2018first family\u2019 or a \u2018second family\u2019 In non-limiting embodiments, there may be any number of families\/vendors\u2014for example, hundreds or thousands or more.","Once the vendor or family or chipset or other identifying characteristic is determined, it is possible to utilize the \u2018appropriate\u2019 scheme according to the results of the phone model\/model type identification. Thus, if it is determined from the analysis of the USB endpoint descriptor data (and optionally additional data\u2014e.g. \u2018higher levels\u2019 of the USB tree) that a \u2018candidate\u2019 phone is from the \u2018first family,\u2019 then the cell-phone related data (e.g. SMS messages, etc) is retrieved from the peripheral phone device by the host device using a retrieval \u2018scheme\u2019 associated with the first family of phones. Alternatively, if it is determined from the analysis of the USB endpoint descriptor data that a \u2018candidate\u2019 phone is from the \u2018second family,\u2019 then the cell-phone related data (e.g. SMS messages, etc) is retrieved from the peripheral phone device by the host device using a retrieval \u2018scheme\u2019 associated with the second family of phones.","It is now disclosed for the first time a method of determining peripheral device property(ies) by a host device that is coupled to the peripheral device via a USB port, the method comprising:\n\n","In one example, a first model of phones (e.g. a Nokia\u00ae phone) provides a first memory capacity, while a second model of phones (e.g. an Apple\u00ae phone) provides a second memory capacity. In this example, it is possible to employ USB endpoint descriptor to identify the phone vendor and\/or model and\/or chipset and\/or model family to determine if the phone (or any peripheral device\u2014not necessarily limited to phone devices) is from a \u2018first family\u2019 or a \u2018second family\u2019 In non-limiting embodiments, there may be any number of families\/vendors\u2014for example, hundreds or thousands or more.","It is possible to store a table (or other data structure) of peripheral device features on the host side mapping peripheral device identification information with information describing capabilities of each peripheral device\u2014e.g. \u2018Model X1\u2019 has 8 Gigabytes of memory, \u2018Model X2\u2019 has 12 Gigabytes of memory, etc. Once model-identifying information derived from the USB endpoint descriptor (and optionally additional data\u2014e.g. \u2018higher levels\u2019 of the USB tree) about the vendor or family or chipset or other identifying characteristic is determined, it is possible to effect a \u2018look-up\u2019 of a data structure describing different capabilities of various models. In this manner, the host device can utilize the \u2018USB endpoint descriptor data\u2019 to determine one or more hardware or software capabilities of a peripheral device (e.g. memory capacity, network type, etc.)","It is now disclosed for the first time a method of sending a command from a host device to a composite peripheral device coupled to the host device via a USB port, the method comprising:\n\n","In one example, a peripheral device presents itself to the host device as a composite device including two wireless communications devices (i.e. referred to as \u2018WC\u2019 and \u2018WC\u2019) and three modem devices referred to as (\u2018M\u2019 and \u2018M\u2019 and \u2018M\u2019). In this example, any given command from the host device to the peripheral device may be routed to any one of five \u2018interfaces\u2019 of the USB composite peripheral device\u2014i.e. to the USB interface associated with WC (first USB interface of the peripheral device), to the USB interface associated with WC (second USB interface of the peripheral device), to the USB interface associated with M (third USB interface of the peripheral device), to the USB interface associated with M (fourth USB interface of the peripheral device), or to the USB interface associated with M (fifth USB interface of the peripheral device).","In some embodiments, it is possible for a command sequence (e.g. a phone command sequence) to be implemented as a sequence of surrogate device commands. For example, on a particular model, a command to display a photo may be implemented as the following sequence: \u201cCommand  to WC ,\u201d \u201cCommand  to WC ,\u201d Command  to WC \u201d and \u201cCommand  to M.\u201d In this example, each of the four commands needs to be routed to a particular USB interface selected from the 5 interfaces of the composite device. Thus, the first command from the host needs to be routed to the WC interface (i.e. instead of the WC, M, M or M interface), the second command needs to be routed to the WC interface and so on.","In some embodiments, for a number of devices (e.g. phones or PDAs or any other peripheral devices), each device model encodes various commands according to a different \u2018underlying command scheme\u2019\u2014for example, a first cell phone model (e.g. a certain Andoid\u00ae phone model) expects to receive a \u2018retrieve SMS\u2019 command according to a first set of underlying commands (e.g. \u2018surrogate device commands\u2019 such as modem commands or wireless communications device) of a \u2018lower level\u2019 protocol(s), while a second phone model (e.g. a certain RIM\u00ae phone model) expects to receive a a \u2018retrieve SMS\u2019 command according to a second set of underlying commands. The \u2018translation\u2019 scheme between the \u2018higher level command\u2019 (e.g. retrieve SMS) and the \u2018lower level command\u2019 (e.g. modem commands or WC commands) may be particular to different composite devices.","In this example, it is possible to maintain on the host device a per-model (or per-model family) map (or other data structure) explaining how \u2018higher level\u2019 commands are translated into lower level \u2018device commands\u2019 to be sent to the peripheral device. For example, the vendors or even different phone models from the same vendors each maintain different schemes and each phone model (or other peripheral device) may be mapped to a different scheme-descriptor. Once the peripheral device is identified as a particular peripheral device model (e.g. phone model) in accordance with the USB endpoint data (and optionally additional data), it is possible to invoke the \u2018matching\u2019 translation scheme. Part of this scheme for translating commands may also describe to which interface (e.g. to M or WC, etc) to \u2018lower level command\u2019 is to be routed when sent from the host device to the peripheral device.","Thus, in this non-limiting example, (i) each peripheral device model is associated with a different \u2018mapping scheme\u2019 between the higher and lower level commands; (ii) each scheme routes \u2018lower level\u2019 commands differently; (iii) once the particular model is identified according to USB endpoint data (and optionally additional data), it is possible to employ the \u2018correct\u2019 matching scheme\u2014this matching scheme specifies how to route (i.e. to a target USB interface\u2014.e.g. to M or WC, etc) commands sent from the host device to the peripheral device; (iv) commands are thus routed according to the identified device model, and thus are routed in accordance with results of analyzing USB endpoint data (and optionally additional data).","Each peripheral device may use different protocols for encoding commands. For example, a device from \u2018Vendor A\u2019 (i.e. \u2018Model X\u2019) may encode a command for retrieving a photograph or for retrieving a cell-phone log using a text protocol (e.g. an XML or SOAP protocol) while a device from \u2018Vendor B\u2019 (i.e. \u2018Model Y\u2019) may encode a command for retrieving a photograph or for retrieving a binary protocol. Once the particular model is determined (i.e. in accordance with results of analyzing USB endpoint data and optionally additional data), it is possible to employ a \u2018matching scheme\u2019 for encoding commands that matches the particular model\u2014this matching scheme may relate to protocol selection or to when to switch from a first protocol to a second protocol.","It is now disclosed for the first time a method of encoding a peripheral device command by a host device that is coupled to a peripheral device via a USB port, the method comprising:\n\n","It is now disclosed a method of retrieving cell-phone related data by a host device from a peripheral cell phone device that is coupled to the host device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral cell phone device that is coupled to the host device via the USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. in a manner determined by the results of the analysis of the USB endpoint descriptor data, retrieving by the host device from the peripheral cell phone device at least one: A. one or more SMS message(s); B. a cell phone log or a portion thereof; C. one or more cell phone-address-book entries; and D. retrieving an IMEI or ESN or MEID hardware identifier.","It is now disclosed a method of determining device property(ies) of a peripheral device by a host device that is coupled to the peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. in a manner determined by the results of the analysis of the USB endpoint descriptor data, determining at least one of: A. a memory capacity of the peripheral device; B. a cellular network type(s) supported by the peripheral device; C. a presence or absence of an onboard keyboard on the peripheral device; D. an SMS repository capacity and\/or an cellphone address book capacity of the peripheral device; and E. a SMS and\/or cellular phone log and\/or cell phone address book and\/or cellular phone hardware identifier retrieval scheme.","It is now disclosed a method of sending a command from a host device to a composite peripheral device that is coupled to the host device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the composite peripheral device that is coupled to the host device via the USB port, the composite peripheral device having a plurality of interface descriptors; b. analyzing the received USB endpoint descriptor data by the host device; and c. according to the results of the analysis of the USB endpoint descriptor data, selecting a target interface descriptor selected from the plurality of interface descriptors; and d. routing a command sent to the peripheral device to the interface specified by the target interface descriptor.","It is now disclosed a method of encoding a peripheral device command by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from a peripheral device coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; c. according to the results of the analysis of the USB endpoint descriptor data, effecting a binary protocol-text protocol selection that prefers a text protocol over candidate binary protocol(s) or a binary protocol over candidate text protocol(s); and d. encoding a command using the selected text or binary protocol.","It is now disclosed a method of encoding a peripheral device command by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. for a candidate protocol set that includes all members of protocol set A={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}, selecting a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set A; and d. encoding one or more commands using the selected protocol that is a member of protocol set A. wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae.","It is now disclosed a method of encoding a peripheral device command by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. for a candidate protocol set that includes all members of protocol set B={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}, selecting a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set B; and d. encoding one or more commands using the selected protocol that is a member of protocol set B, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a method of encoding a peripheral device command by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. for a candidate protocol set that includes all members of protocol set C={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}, selecting a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set C; and d. encoding one or more commands using the selected protocol that is a member of protocol set C, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol.","It is now disclosed a method of encoding a peripheral device command by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. for a candidate protocol set that includes all members of protocol set D={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}, selecting a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set D; and d. encoding one or more commands using the selected protocol that is a member of protocol set D, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a protocol switch method by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. contingent upon results of the analyzing of the received USB endpoint descriptor data, effecting a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members of protocol set A={PROTOCOL_, PROTOCOL_ PROTOCOL_, PROTOCOL_}; ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae.","It is now disclosed a protocol switch method by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from a peripheral device coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. contingent upon results of the analyzing of the received USB endpoint descriptor data, effecting a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members protocol set B={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}; ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a protocol switch method by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. contingent upon results of the analyzing of the received USB endpoint descriptor data, effecting a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members protocol set C={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}; ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol.","It is now disclosed a protocol switch method by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. contingent upon results of the analyzing of the received USB endpoint descriptor data, effecting a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members protocol set D=as {PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL\u2014, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}, ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a protocol switch method by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. contingent upon results of the analyzing of the received USB endpoint descriptor data, effecting a protocol switch by the host device from a first protocol that is one of a binary protocol and a text protocol to a second protocol that is different from the first protocol and that is the other from a text protocol and a binary protocol such that: A. the last host-encoded command before the protocol switch is encoded using the first protocol; and B. the first host-encoded command after the protocol switch is encoded using the second protocol.","In some embodiments, steps (b) and (c) are carried out in accordance with the combination of the USB endpoint descriptor data and data of higher levels in the USB descriptor hierarchy.","In some embodiments, steps (b) and (c) are carried out in accordance with the USB endpoint descriptor data without influence by data of higher levels in the USB descriptor hierarchy. In some embodiments, the analysis of step (b) includes analyzing the bEndpointAddress field and wherein step (c) is carried out in a manner that is contingent upon the results of the analyzing of the bEndpointAddress field.","In some embodiments, the analysis of step (b) includes analyzing the bmAttributes field and wherein step (c) is carried out in a manner that is contingent upon the results of the analyzing of the bmAttributes field.","In some embodiments, the analysis of step (b) includes analyzing the wMaxPacketSize field and wherein step (c) is carried out in a manner that is contingent upon the results of the analyzing of the wMaxPacketSize field.","In some embodiments, the analysis of step (b) includes analyzing the bInterval field and wherein step (c) is carried out in a manner that is contingent upon results of the analyzing of the bInterval field.","It is now disclosed a method of operating a host device on which operating system (OS) software is executing, the method comprising: contingent upon the host device being in a first mode, responding to a coupling between a peripheral device and a host device so that the peripheral device passes hardware identifier information to the host device directly or indirectly specifying device driver(s) by preventing the hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side, wherein the method is carried out on a host device that provides mutually-exclusive first and second modes, and wherein the method is carried out contingently on the host device being in the first mode and not in the second mode.","In some embodiments, the method further comprises: responding into a user log-in event or user attempted-log-in event by transitioning the host device mode from one of the first and second modes to the other of the first and second modes.","In some embodiments, the method further comprises: in accordance with content of user input received from a user into the host device, transitioning the host device mode from one of the first and second modes to the other of the first and second modes.","It is now disclosed a method of operating a host device on which operating system (OS) software is executing, the method comprising: a. responding, by soliciting user input, to a coupling between a peripheral device and a host device so that the peripheral device passes to the host device hardware identifier information that directly or indirectly specifying device driver(s); b. in response to the user input soliciting, receiving the user input into the host device from the user; c. in accordance with the contents of the user input, operating the host device in a first mode or in a second mode, the first and second modes being mutually exclusive; d. only if the host device is operating in the first mode, preventing the device-driver-specifying hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side, thereby preventing the loading of the device driver(s) specified by the hardware identifier; and e. otherwise, refraining from the preventing so that the OS executing on the host device or component(s) thereof forwards the hardware identifier to the plug-and-play-manager of the OS.","It is now disclosed a method of operating a host device on which operating system (OS) is executing, the host device configured to receive input via a plurality of USB ports divided into first and second non-empty complementary disjoint subsets, the method comprising: in response to a coupling, via one of the USB ports, between a peripheral device and a host device so that the peripheral device passes to the host device, via the one of the USB ports, hardware identifier information that directly or indirectly specifying device driver(s); if the coupling is via a USB port that is a member of the first subset, preventing the device-driver-specifying hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side, thereby preventing the loading of the device driver(s) specified by the hardware identifier; and otherwise, refraining from the preventing so that the OS executing on the host device or component(s) thereof forwards the hardware identifier to the plug-and-play-manager of the OS.","In some embodiments, at least one of the USB ports are built-in ports of the host device.","In some embodiments, at least one of the USB ports is an auxiliary external port.","It is now disclosed a host device apparatus configured to carry out any method of any previous claim.","It is now disclosed a method of retrieving cell-phone related data from a peripheral device by a host device on which operating system (OS) software executes, the method comprising: a. in response to a coupling between the peripheral device and the host device via a USB port so that passes hardware identifier information to the host device directly or indirectly specifying device driver(s), executing code to prevent the executing OS software from loading the specified device driver(s) on the host device; b. analyzing peripheral-device-descriptive data received from the peripheral device by the host device via the USB port; and c. in a manner determined by the results of the analysis of the peripheral-device-descriptive data, determining at least one of: A. a memory capacity of the peripheral device; B. a cellular network type(s) supported by the peripheral device; C. a presence or absence of an onboard keyboard on the peripheral device; D. an SMS repository capacity and\/or an cellphone address book capacity of the peripheral device; and E. a SMS and\/or cellular phone log and\/or cell phone address book and\/or cellular phone hardware identifier retrieval scheme.","It is now disclosed a method of retrieving cell-phone related data from a composite peripheral device by a host device on which operating system (OS) software executes, the method comprising: a. in response to a coupling between the composite peripheral device having a plurality of USB interface descriptors and the host device via a USB port so that passes hardware identifier information to the host device directly or indirectly specifying device driver(s), executing code to prevent the executing OS software from loading the specified device driver(s) on the host device; b. analyzing peripheral-device-descriptive data received from the peripheral device by the host device via the USB port; and c. according to the results of the analysis of the peripheral-device-descriptive data, selecting a target interface descriptor selected from the plurality of interface descriptors; and d. routing a command sent to the peripheral device to the interface specified by the target interface descriptor.","It is now disclosed a method of retrieving cell-phone related data from a peripheral device by a host device on which operating system (OS) software executes, the method comprising: a. in response to a coupling between the peripheral device and the host device via a USB port so that passes hardware identifier information to the host device directly or indirectly specifying device driver(s), executing code to prevent the executing OS software from loading the specified device driver(s) on the host device; b. analyzing peripheral-device-descriptive data received from the peripheral device by the host device via the USB port; and c. according to the results of the analysis of the peripheral-device-descriptive data, effecting a binary protocol-text protocol selection that prefers a text protocol over candidate binary protocol(s) or a binary protocol over candidate text protocol(s); and d. encoding a command using the selected text or binary protocol.","In some embodiments, the host device communicates with the peripheral device by means of a substitute driver that is different from a driver specified directly or indirectly by the hardware identifier information passed from the peripheral device to the host device.","It is now disclosed a host device apparatus configured to carry out any method of any previous claim.","It is now disclosed a system comprising a host device apparatus configured to carry out any method of any previous claim and the peripheral device coupled to the host device apparatus.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral cell phone device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyzing the received USB endpoint descriptor data; and iii. in a manner determined by the results of the analysis of the USB endpoint descriptor data, retrieve via the USB interface, from the peripheral cell phone device, at least one: A. one or more SMS message(s); B. a cell phone log or a portion thereof; C. one or more cell phone-address-book entries; and D. retrieving an IMEI or ESN or MEID hardware identifier.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. in a manner determined by the results of the analysis of the USB endpoint descriptor data, determine at least one of: A. a memory capacity of the peripheral device; B. a cellular network type(s) supported by the peripheral device; C. a presence or absence of an onboard keyboard on the peripheral device; D. an SMS repository capacity and\/or an cellphone address book capacity of the peripheral device; and E. a SMS and\/or cellular phone log and\/or cell phone address book and\/or cellular phone hardware identifier retrieval scheme.","It is now disclosed host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. according to the results of the analysis of the USB endpoint descriptor data, selecting a target interface descriptor selected from the plurality of interface descriptors; and iv. routing a command sent to the peripheral device to the interface specified by the target interface descriptor.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. according to the results of the analysis of the USB endpoint descriptor data, effect a binary protocol-text protocol selection that prefers a text protocol over candidate binary protocol(s) or a binary protocol over candidate text protocol(s); and iv. encode a command using the selected text or binary protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. for a candidate protocol set that includes all members of protocol set A={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}, select a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set A; and iv. encode one or more commands using the selected protocol that is a member of protocol set A. wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. for a candidate protocol set that includes all members of protocol set B={ PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}, select a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set B; and d. encode one or more commands using the selected protocol that is a member of protocol set B, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. for a candidate protocol set that includes all members of protocol set C={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}, select a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set C; and iv. encoding one or more commands using the selected protocol that is a member of protocol set C, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. for a candidate protocol set that includes all members of protocol set D={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}, select a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set D; and iv. encode one or more commands using the selected protocol that is a member of protocol set D, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. contingent upon results of the analyzing of the received USB endpoint descriptor data, effect a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members of protocol set A={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}; ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. contingent upon results of the analyzing of the received USB endpoint descriptor data, effect a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members of protocol set B={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}; ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. contingent upon results of the analyzing of the received USB endpoint descriptor data, effect a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members of protocol set C={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}; ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. contingent upon results of the analyzing of the received USB endpoint descriptor data, effect a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members of protocol set D=as {PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_,}, ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. contingent upon results of the analyzing of the received USB endpoint descriptor data, effect a protocol switch by the host device from a first protocol that is one of a binary protocol and a text protocol to a second protocol that is different from the first protocol and that is the other from a text protocol and a binary protocol such that: A. the last host-encoded command before the protocol switch is encoded using the first protocol; and B. the first host-encoded command after the protocol switch is encoded using the second protocol.","In some embodiments, the electronic circuitry is configured to carry out the steps (ii) and (iii) in accordance with the combination of the USB endpoint descriptor data and data of higher levels in the USB descriptor hierarchy.","In some embodiments, steps (b) and (c) are carried out in accordance with the USB endpoint descriptor data without influence by data of higher levels in the USB descriptor hierarchy.","In some embodiments, the analysis of step (b) includes analyzing the bEndpointAddress field and wherein step (c) is carried out in a manner that is contingent upon the results of the analyzing of the bEndpointAddress field.","In some embodiments, the analysis of step (b) includes analyzing the bmAttributes field and wherein step (c) is carried out in a manner that is contingent upon the results of the analyzing of the bmAttributes field.","In some embodiments, the analysis of step (b) includes analyzing the wMaxPacketSize field and wherein step (c) is carried out in a manner that is contingent upon the results of the analyzing of the wMaxPacketSize field.","In some embodiments, the analysis of step (b) includes analyzing the bInterval field and wherein step (c) is carried out in a manner that is contingent upon results of the analyzing of the bInterval field.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) electronic circuitry configured to execute operating system (OS) software code, the electronic circuitry having mutually-exclusive first and second modes so that the host device has mutually-exclusive first and second modes, the electronic circuitry being further configured to carry out the following while the operating system (OS) software code executes: contingent upon the host device being in a first mode, responding to a coupling between the peripheral device and the host device so that the peripheral device passes hardware identifier information to the host device directly or indirectly specifying device driver(s) by preventing the hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side, wherein the method is carried out contingently the host device being in the first mode and not in the second mode.","In some embodiments, the electronic circuitry is further operative to carry out the following: responding into a user log-in event or user attempted-log-in event by transitioning the electronic circuitry mode from one of the first and second modes to the other of the first and second modes.","In some embodiments, the electronic circuitry is further operative to carry out the following: In accordance with content of user input received from a user into the host device, transitioning the host device mode from one of the first and second modes to the other of the first and second modes.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) electronic circuitry configured to execute operating system (OS) software code, the electronic circuitry having mutually-exclusive first and second modes so that the host device has mutually-exclusive first and second modes, the electronic circuitry being further configured to carry out the following while the operating system (OS) software code executes: i. in response to the user input soliciting, receive the user input into the host device from the user; ii. in accordance with the contents of the user input, operate the host device in a first mode or in a second mode, the first and second modes being mutually exclusive; iii. only if the host device is operating in the first mode, prevent the device-driver-specifying hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side, thereby preventing the loading of the device driver(s) specified by the hardware identifier; and iv. otherwise, refrain from the preventing so that the OS executing on the host device or component(s) thereof forwards the hardware identifier to the plug-and-play-manager of the OS.","It is now disclosed a host device comprising: a) a plurality of USB ports divided into first and second non-empty complementary disjoint subsets; and b) electronic circuitry configured to execute operating system (OS) software code, the electronic circuitry being further configured to carry out the following while the operating system (OS) software code executes: in response to a coupling, via one of the USB ports, between a peripheral device and a host device so that the peripheral device passes to the host device, via the one of the USB ports, hardware identifier information that directly or indirectly specifying device driver(s); A) if the coupling is via a USB port that is a member of the first subset, preventing the device-driver-specifying hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side, thereby preventing the loading of the device driver(s) specified by the hardware identifier; and B) otherwise, refraining from the preventing so that the OS executing on the host device or component(s) thereof forwards the hardware identifier to the plug-and-play-manager of the OS.","In some embodiments, at least one of the USB ports are built-in ports of the host device. In some embodiments, at least one of the USB ports is an auxiliary external port.","It is now disclosed a method of encoding a peripheral device command by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. for a candidate protocol set E that includes any two or more members of protocol set X={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}selecting a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set E and d. encoding one or more commands using the selected protocol that is a member of protocol set E. wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol. PROTOCOL_ is an android fastboot protocol and PROTOCOL_ is an LG binqary object exchange proprietary protocol.","It is now disclosed a protocol switch method by a host device that is coupled to a peripheral device via a USB port, the method comprising: a. receiving USB endpoint descriptor data by the host device from the peripheral device that is coupled to the host device via a USB port; b. analyzing the received USB endpoint descriptor data by the host device; and c. contingent upon results of the analyzing of the received USB endpoint descriptor data, effecting a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members of protocol set X={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}' ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol. PROTOCOL_ is an android fastboot protocol and PROTOCOL_ is an LG binary object exchange proprietary protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. for a candidate protocol set E that includes any two or more members of protocol set X={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_}, select a protocol from the candidate protocol set in accordance with the results of the analysis of the USB descriptor endpoint descriptor data, the selected protocol being a member of protocol set E; and iv. encode one or more commands using the selected protocol that is a member of protocol set E, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol. PROTOCOL_ is an android fastboot protocol and PROTOCOL_ is an LG binary object exchange proprietary protocol.","It is now disclosed a host device comprising: a) a USB interface operative for inter-device coupling with a peripheral device; and b) a electronic circuitry configured to: i. receive, via the USB interface and from the peripheral cell phone device that is coupled to the host device via the USB port, USB endpoint descriptor data; ii. analyze the received USB endpoint descriptor; and iii. contingent upon results of the analyzing of the received USB endpoint descriptor data, effect a protocol switch by the host device from a first protocol to a second protocol different from the first protocol such that: i. both the first and second protocols are members of protocol set X={PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_, PROTOCOL_} ii. the last host-encoded command before the protocol switch is encoded using the first protocol; and iii. the first host-encoded command after the protocol switch is encoded using the second protocol, wherein PROTOCOL_ is an AT protocol, PROTOCOL_ is a Nokia fBus Protocol, PROTOCOL_ is a OBject EXchange (OBEX) protocol, PROTOCOL_ is a block-type mass-storage protocol, PROTOCOL_ is a Qualcom BREW OS protocol, PROTOCOL_ is a mediate transfer protocol (MTP) of Microscoft\u00ae, PROTOCOL_ is a RIM OS proprietary protocol, PROTOCOL_ is a Android Debug Bridge (ADB) protocol, PROTOCOL_ is an Apple\u00ae IOS proprietary protocol, PROTOCOL_ is a Synchronization Markup Language (SyncML) protocol, PROTOCOL_ is a remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), PROTOCOL_ is a SIM card protocol. PROTOCOL_ is an android fastboot protocol and PROTOCOL_ is an LG binary object exchange proprietary protocol.","It is now disclosed a host device apparatus configured to carry out any disclosed method.","In some embodiments, the electronic circuitry includes any combination of one or more microprocessor(s) and computer memory.","In some embodiments, the computer memory includes volatile and\/or non-volatile memory.","In some embodiments, the electronic circuitry includes any combination digital circuitry, software and firmware.","In some embodiments, computer readable medium comprising storage media having stored thereon computer readable program code for performing any disclosed method.","The claims below will be better understood by referring to the present detailed description of example embodiments with reference to the figures. The description, embodiments and figures are not to be taken as limiting the scope of the claims. It should be understood that not every feature of the presently disclosed methods, apparatuses, and computer readable media having stored thereon is necessary in every implementation. It should also be understood that throughout this disclosure, where a process or method is shown or described, the steps of the method may be performed in any order or simultaneously, unless it is clear from the context that one step depends on another being performed first. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning \u201chaving the potential to\u2019), rather than the mandatory sense (i.e. meaning \u201cmust\u201d).","Embodiments of the present invention relate to method, apparatus, and system whereby a client application executing on the host device can appropriately communicate with any mobile phone of a \u2018large list\u2019 of candidate phones including peripheral-protocol dissimilar methods even in situations there is little or no manually-provided \u2018guidance\u2019 about the particular phone model from the user (e.g. where the user would type in the phone model or the name of the vendor).","In the present disclosure \u2018electronic circuitry\u2019 is intended broadly to describe any combination of hardware, software and\/or firmware.","Electronic circuitry may include may include any executable code module (i.e. stored on a computer-readable medium) and\/or firmware and\/or hardware element(s) including but not limited to field programmable logic array (FPLA) element(s), hard-wired logic element(s), field programmable gate array (FPGA) element(s), and application-specific integrated circuit (ASIC) element(s). Any instruction set architecture may be used including but not limited to reduced instruction set computer (RISC) architecture and\/or complex instruction set computer (CISC) architecture. Electronic circuitry may be located in a single location or distributed among a plurality of locations where various circuitry elements may be in wired or wireless electronic communication with each other.","When a given phone is coupled as a peripheral  to the host  device, instead of loading into memory the various device surrogate drivers into memory (see  of ) specified by the USB hardware ID passed from the peripheral phone to the host, and instead of relying on these surrogate device drivers to send commands to the peripheral phone , it is possible to load into memory a single device driver that can be used with any phone of the \u2018large list\u2019 of candidate phones.","Techniques are disclosed herein whereby a host computer device may automatically identify a vendor and\/or model and\/or chipset of a peripheral phone without relying on a priori information about the phone. In some embodiments, it has been found that USB endpoint data (see ) of the peripheral phone device is a useful indicator of a phone model. This USB endpoint data may be used \u2018by itself\u2019 or in combination with other data of the USB \u2018fingerprint\u2019 (see ).","In general, even for a large \u2018candidate set\u2019 of hundreds of thousands of phone models, it has been found that the USB endpoint data (e.g. together with other data of the USB fingerprint), in many situations, is unique for particular phone models, or at least for \u2018families of\u2019 phone models.","Various vendors may implement common peripheral device functionality and\/or cell phone functionality in different manners. For example, the scheme for retrieving SMS data from a Nokia\u00ae phone may differ than that of a Sony-Ericsson\u00ae or RIM\u00ae or Apple IPhone\u00ae or Android Phone\u00ae.","Nevertheless, once a phone model (or at least \u2018family\u2019 of models) has been automatically identified, it is possible for the host device to provide different functionality whose implementation is phone-model dependent according to the results of the \u2018phone model identifying.\u2019","In various embodiments, it is possible for the host device to carry out one or more of the following in a manner that is \u2018contingent\u2019 upon the results of analyzing peripheral-device specific data (e.g. USB endpoint data).","(i) retrieving cell-phone specific data (see );","(ii) determining phone resources (see );","(iii) routing and\/or addressing a command(s) to a \u2018target\u2019 USB interface descriptor (e.g. in , a command may be \u2018routed\u2019 to a modem or wireless communication device OR may be \u2018routed\u2019 to a particular communication device) (see );","(iv) determining a protocol in which to encode a command on the host device (e.g. different phone vendors may utilize different protocols for common functionality\u2014once the model or model family is determined, it is possible to use the \u2018appropriate\u2019 or \u2018matching\u2019 protocol which matches the model identity) (see ).","A \u2018vendor agnostic\u2019 phone software interface is provided which accepts \u2018generic phone commands\u2019 that are not required to be proprietary to any phone vendor or model.  is a flow chart of a routine whereby a host device  communicates with a phone device  that is coupled (e.g. via a wired or wireless USB port) to the host device. Although  relates to the particular cases of phone devices , some teachings relate to host devices coupled to peripheral devices other than phone devices or to host device that are not necessarily coupled to any peripheral device.  is a block diagram of a system configured to carry out the routine of .","As will be explained below, in some embodiments relating to the routine of , when a phone is coupled to a host device (e.g. as a \u2018peripheral device\u2019) (i) certain \u2018native\u2019 host-side operating system behavior that would normally be observed when a mobile phone presents a surrogate hardware identifier (e.g. associated with a surrogate composite device scheme\u2014see ) is now suppressed (see, for example, \u2014step S and\/or S and\/or step S or at least a portion thereof). Although this functionality is not limited to the specific case where the peripheral device is a mobile phone, it is now disclosed that this functionality is particularly useful for the case where the peripheral device is a mobile phone that presents surrogate device identifier(s) to host .","For the case where the peripheral device is a mobile phone that presents surrogate device identifier(s) to host , suppression of the native OS eliminates the passing of certain \u2018surrogate-device\u2019 specific information to the plug and play manager  and\/or eliminates the loading of surrogate device drivers specific to the device interface presented.","In some embodiments, despite that fact that the loading of one or more surrogate device drivers is suppressed, it is still possible for the host device  to send to a peripheral phone (i.e. that functions as described in ) \u2018understandable\u2019 commands via respective ports ,  according to a surrogate device protocol and\/or wrapped in the language of the surrogate device according","Each phone model (or family if phones or phone vendor or chip family) tends to be associated with a different respective \u2018surrogate command language.\u2019 Some embodiments provide a method and apparatus for determining a mobile phone \u2018type\u2019 whereby the host device, without having or using a-priori information about the type of mobile phone coupled with host , is able to automatically, without being supplied with and\/or without relying on manually-input information about the type of mobile phone  coupled as a peripheral device to host . In the examples of  where phone suite application  was required to handle specific types of mobile phones and\/or could rely on manually-provided information about the coupled phone (e.g. because the \u2018mobile phone suite\u2019  only supports a very small sub-set of the set of all possible mobile phones). In some embodiments, there is no such requirement, and it is possible to \u2018automatically\u2019 identify a phone model or family of models.","Thus, in one use non-limiting case, when the user couples a Nokia N95 phone to the host device , the Nokia N95 phone may behave in a manner similar (or identical to) to what was described in the Background Art section; when the user couples a Sony Ericsson K310 phone to host device , the Sony Ericsson K310 phone may behave in a manner similar (or identical to) to what was described in the Background Art section.","However, instead of relying on the a priori information about a particular phone model (this is the case with many phone suite applications  which may also receive manually-provide information about phone models), it is possible for the host to (i) automatically identify (for example, in accordance with USB fingerprint data which describes a surrogate device scheme for the phone) the phone; and (ii) communicate according to the appropriate phone command-surrogate device command translation scheme (e.g. selected in step S).","Furthermore, in contrast to the routine of  where there is a requirement to load, into memory  of the host device , actual \u2018surrogate device drivers\u2019, according to embodiments of the present invention, it is possible for the host to communicate with the phone without relying on the surrogate device drivers and without relying on manually-supplied information from the user about the type of the phone or model or vendor.","In some embodiments, it is possible to load a single driver (e.g. multiple instances of a single driver) for multiple phone vendors, and to communicate with multiple phones (even if they are simultaneously coupled to the host) via the single device driver.","Definitions","For convenience, in the context of the description herein, various terms are presented here. To the extent that definitions are provided, explicitly or implicitly, here or elsewhere in this application, such definitions are understood to be consistent with the usage of the defined terms by those of skill in the pertinent art(s). Furthermore, such definitions are to be construed in the broadest possible sense consistent with such usage","In some embodiments, host  and peripheral device  communicate with each other using a \u2018master-slave\u2019 communication protocol that has a \u2018host side\u2019 (used by host ) and a \u2018peripheral side\u2019 (used by device ). One example of such a protocol is the USB protocol. According to these embodiments, peripheral device  is the \u201cslave\u201d during the communication session when commands are sent from host  to device (for example, in step S of ).","In one example, device  and host  are configured so that device  is always a \u201cslave\u201d to host  when coupled\u2014the \u201cdedicated\u201d case. Alternatively, device  is only the \u201cslave\u201d during a particular session,","Peripheral storage devices communicate with their hosts using a \u2018master-slave\u2019 communications protocol that has a \u2018host side\u2019 and a \u2018peripheral side.\u2019 Examples of \u201cmaster-slave\u201d protocols include but are not limited to Universal Serial Bus (USB) protocols, MultiMediaCard (MMC) protocols, and Secure Digital (SD) protocols.","When a \u2018host\u2019 and a \u2018peripheral storage device\u2019 are \u2018coupled\u2019: (i) they are in communication with each other via a \u2018point-to-point\u2019 data link (either a \u2018wired connection\u2019 or a short-range wireless link without any requirement for an intermediate routing device) so that data may flow via the \u2018point-to-point\u2019 data link between the host and peripheral; and (ii) they are configured to communicate using a \u2018master-slave\u2019 protocol\u2014i.e. the host is configured to communicate with the peripheral storage device in the \u2018host\u2019 or master role defined by the protocol and the peripheral storage device is configured to communicate with the host in the \u2018slave\u2019 or peripheral role defined by the protocol.","Reference is made, once again, to , which are flow charts of routines of operating host device  to interact with peripheral phone device  to send commands to the peripheral phone device .  is a block diagram of a system configured to carry out the routine of .","Step S of  is the same as step S of .","In step S, the native operating system behavior of step S and\/or step S and\/or step S is suppressed. In step S, \u2018native OS behavior\u2019 of the executing OS is suppressed. According to this \u2018native OS behavior,\u2019 executing USB hub driver code  serves as a conduit for HW identifier information which flows from the peripheral device  to to plug-and-play manager ). According to the routine of , even if this HW identifier information is received by executing USB hub driver code , this HW identifier information is intercepted and withheld from plug-and-play manager .","In one non-limiting example describing how this suppression of the \u2018native OS behavior\u2019 may be implemented, it is possible to modify, within memory , at least one instance of operating system USB driver code  in order to suppress behavior described in . This modification of the operating system USB driver code  to inject one or units (e.g. lines) of \u2018non-native\u2019 code other than the OS code and\/or modify or delete one or more units code is referred to as \u2018kernel mode code modification.\u2019 This kernel mode code modification can take place at any time (there is no limitation)\u2014for example, upon start up of host device  or in response to any event associated with the instantiation or loading into memory of USB driver code . For example, it is possible to install on host device a service which \u2018listens\u2019 for loading events where USB driver code  is loaded or instantiated or about to be executed. In response to this event, it is possible to modify the native OS code for a specific instance loaded into memory . In one example, code injector\/modifier  which operates in user or kernel mode may, in response to the \u2018USB driver code  loading or execution or instantiation event, modify for a particular instance(s) of USB driver code , the code within memory .","Modification of an instance of code of a native OS driver is not the whole technique that may be used. Alternatively or additionally, in another example related to the \u2018suppressing\u2019 of certain native OS code behavior of one or more steps of  that leads to the receipt by plug-and-play manager of peripheral device-specific (e.g. surrogate device data) data, it is possible to write a replacement driver for the USB controller or hub. This replacement driver, (i) receives data from the hardware of the host-sided port  and (ii) passes this hardware-received data to the native OS USB host controller . This \u2018intercepting\u2019 proxy driver (not illustrated in the figures) may provide certain data interception features so that not only does plug-and-play driver not directly receive certain peripheral-device-specific data (e.g. hardware ID data and\/or a list of supported peripheral device interfaces supported by peripheral )","In step S, the host-side USB port hardware  receives the surrogate device identifier(s). Instead of USB host controller  passing this surrogate device data to plug and play manager  (see step S of ), this information is intercepted\u2014e.g. by a proxy driver or modified OS code of USB hub driver .","The intercepted information is replaced, in step S, with a \u2018substitute HW identifier and\/or substitute list of one or more supported device interfaces.","This different device identifier will be referred to as a \u2018substitute device identifier.\u2019 This \u2018substitute device identifier\u2019 is different from the device identifier received via communications link  into the host-side USB port  hardware\u2014in the case of the mobile phones, this \u2018substitute device identifier\u2019 is different from the surrogate device identifiers discussed in the background section.","In one non-limiting example, the \u2018substitute device driver\u2019 is a simple generic \u2018data pipe\u2019 device driver. In one non-limiting example, this \u2018substitute device driver\u2019 may be utilized by multiple phones simultaneously coupled to host .","Thus,  the OS-native flow of device identifier data from the USB peripheral device  via communications link  and host-side port  to plug and play manager  is intercepted by a modified version of USB Host Controller  (or *) This data flow is referred to as the \u2018natural flow of data\u2019 because it describes how data flow would occur with \u2018uncontaminated\u2019 pure OS code\u2014i.e. if the memory-residing copy of USB Host Controller  were to remain in its unmodified form.","In step S, substitute class driver(s) are loaded in memory . In one non-limiting example, this substitute class driver(s) is a simple data pipe driver. In contrast to step S of , whereby each \u2018surrogate device scheme\u2019 presented in step S was associated with a different set of device drivers loaded into memory (for example, coupling the Nokia phone of  induced loading in step S of a first set of device drivers specified in  while coupling the Ericsson Sony phone of induced loading in step S of a second set of device drivers specified in ), in step S, it is possible that the same driver (or set of drivers) are loaded into memory for different phones having different surrogate device schemes.","In step S, software executing on host device  is able to determine (or assess) information about the specifics of phone \u2014for example, phone manufacturer (i.e. Nokia\u00ae vs. Apple\u00ae, etc) and\/or phone family identifier and\/or phone model and\/or phone chipset type to \u2018identify\u2019 (i.e. at least in part) phone . For example, it is possible to utilize surrogate device data received in step S or acquired in any other manner at any time\u2014for example, by probing a USB fingerprint e.g. including USB endpoint data.","It is possible, for each of a plurality of phone models and\/or vendors and\/or chipsets, to maintain on the host side of communications link  a data structure that maps between various phone-model specific information to phone models\u2014i.e. the phone-specific information for the Nokia N95 would be different from the phone model-specific information of the Ericsson\u00ae phone which would be different from an Apple\u00ae I-Phone\u00ae. This phone-model specific information may include information about retrieving data or encoding commands or \u2018sniffing\u2019 the peripheral cell phone device for its resources (e.g. memory capacity or other resources).","In step S, the host may identify the phone\u2014e.g. manufacturer\/vendor identity, chipset identity, model number, etc. In some embodiments, some or all of this \u2018phone identity information\u2019 may be displayed to a user\u2014for example, on a display screen.","Experiments carried out by the present inventor have indicated that the \u2018USB endpoint data\u2019 has a useful degree of \u2018predictive power\u2019 for determining a model number and\/or vendor ID and\/or chipset family ID of a peripheral device (e.g. cell phone device). For example, it is possible to maintain on the host side a map (or other data structure) between (i) USB endpoint data (e.g. the lowest level of the hierarchy of  and\/or multiple levels of the hierarchy of  including the \u2018endpoint level\u2019) or portions or combinations of portions thereof (e.g. see any element of ) and\/or any other peripheral-device-descriptive data and (ii) identifier data\u2014e.g. a name of a peripheral device vendor, model number and\/or chipset family ID.","A Discussion of ",{"@attributes":{"id":"p-0217","num":"0241"},"figref":"FIGS. 10-13","b":["207","209"]},"In step S, the host receives peripheral-derive-descriptive data (e.g. USB endpoint descriptor data and\/or other levels of the USB data hierarchy of  or any other data describing the peripheral device) from the peripheral device. This peripheral-derive-descriptive data is also analyzed in step S.","In some embodiments, the analyzes could indicate to the host device the vendor ID and\/or phone ID and\/or chip ID of the peripheral device (e.g. cell phone device). Once this information is known, it is possible to look up properties of the peripheral device in a host-side data structure that maps data identifier information (e.g. vendor, model, chipset, etc) with peripheral device capabilities information.","Once the host device has access to a description of the peripheral device capabilities, the host device can (i) appropriately retrieve information from the peripheral device (see step S of ) and\/or (ii) assess the hardware and\/or software resources or capabilities of the peripheral device (see step S of ) and\/or (iii) route commands to the correct USB interface descriptor (see step S of ) and\/or (iv) communicate with the peripheral device using the correct protocol (see steps S-S of ).","In the example of , the host can send proper instructions (e.g. \u2018platform-specific instructions\u2019) to a cell phone peripheral device for retrieving cell-phone specific data, despite the fact that these instructions could normally vary between phone vendors or model identifiers. For example, the commands for opening an address book, or reading a log may differ between phone models.","In the example of , the host device can access information about the hardware and\/or software resources or capabilities of the peripheral device\u2014for example, by looking up this information in a data structure relating peripheral device model (e.g. phone model number, table model number, printer model number) to hardware and\/or software resources or capabilities of the peripheral device.","The example of  relates to composite peripheral devices. In one example, a composite peripheral device may include two or more interfaces of differing USB device class\u2014e.g. a modem USB interface and a mass storage device USB interface. In another example, a composite peripheral device may include multiple interfaces of the same USB device class\u2014.e.g more than one mass storage device. In some embodiments, in order to send a command (or command sequence to the peripheral device), certain command or command(s) may need to be routed to a particular \u2018target interface\u2019\u2014e.g. not to the modem but to the mass storage device OR not to \u2018mass storage device A\u2019 but to \u2018mass storage device B.\u2019","In general, each peripheral (e.g. phone) vendor and\/or each model and\/or each chipset family may use a different scheme for mapping \u2018higher level commands\u2019 with lower level commands. Each lower level commands may be \u2018targeted\u2019 to a particular USB interface descriptor\u2014e.g. to a particular wireless communication device when more than one is present, or to a certain USB class. In some embodiments, it is possible to maintain, on the host side, a map (or other data structure) between (i) peripheral device model and\/or vendor and\/or chipset family and (ii) a description of a an \u2018encoding scheme\u2019 whereby \u2018higher level commands\u2019 are encoded according to a \u2018lower-level protocol\u2019 (e.g. a modem protocol or a mass storage device protocol). Part of this \u2018command encoding scheme\u2019 includes information about how to target particular commands\u2014e.g. to a particular interface descriptor selected from a plurality of possible \u2018candidate\u2019 descriptors of a USB composite device.","In some embodiments, it is possible to \u2018look up\u2019 information describing this encoding scheme according to device and\/or vendor and\/or chipset ID. The device and\/or vendor and\/or chipset ID may be determined in an \u2018earlier\u2019 step of the routine of \u2014e.g. by analyzing USB endpoint data or other \u2018peripheral device descriptive data.\u2019","The term \u2018routing\u2019 includes associating a command with \u2018addressing information\u2019 indicating to the peripheral device a particular \u2018target\u2019 device of a plurality of the \u2018candidate devices\u2019 of the composite device is \u2018supposed to\u2019 execute a command. The routing does not require actually sending the command to the peripheral device (though it may include this). Once a command is \u2018routed\u2019 to a target, there is an association within computer memory (i.e. volatile and\/or non-volatile memory) of the \u2018host\u2019 between (i) the command; and (ii) a \u2018target device\u2019 (i.e. USB interface descriptor) of the composite devices to which the command is addressed.","In the example of , it is possible to encode a command sequence of command(s) according to the results of the analysis.","In one particular example, the \u2018command encoding scheme\u2019 also relates to a particular protocol or protocol combination for the \u2018low level commands. \u2019For example, the \u2018low level command protocol(s)\u2019 used by a Nokia Phone\u00ae may be different from the \u2018low level command protocol(s)\u2019 used by a Apple\u00ae phone. Protocols that should may be used in commands that are encoded by the host device and sent to the peripheral device include but are not limited to: AT protocol(s), Nokia fBus Protocol(s), OBject EXchange (OBEX) protocol(s), block-type mass-storage protocol(s), Qualcom BREW OS protocol(s), a mediate transfer protocol (MTP) of Microscoft\u00ae, RIM\u00ae OS proprietary protocol(s), a Android Debug Bridge (ADB) protocol(s), Apple\u00ae IOS proprietary protocol(s), Synchronization Markup Language (SyncML) protocol(s), remote application programming interface (RAPI) over Remote Network Driver Interface Specification (RNDIS) protocol), SIM card protocol.","Once a vendor and\/or model and\/or chipset family ID is \u2018known,\u2019 it is possible to select the \u2018correct protocol\u2019 according to the ID information, and to then, in accordance with this information, encode one or more commands by the host device.","Command sequences may include commands of different protocols, and this information may also be used for \u2018switching protocols.\u2019",{"@attributes":{"id":"p-0231","num":"0255"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Table of Commonly Used Protocols"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#","Protocol(s) Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","AT command","Textual modem protocol, extended over the years with numerous"]},{"entry":[{},{},"domain-commands, e.g. CDMA related commands, GSM related"]},{"entry":[{},{},"commands."]},{"entry":["2","Nokia FBus","Binary protocol for Nokia phones"]},{"entry":["3","OBEX","A binary object exchange protocol."]},{"entry":["4","Block-type mass","USB MSD standard sector-based protocol (SCSI over USB) In LG devices, it"]},{"entry":[{},"storage protocol","is possible to change the phone's state from mass-storage to modem"]},{"entry":["5","Qualcomm BREW","Binary protocols for devices using Qualcomm's chipset."]},{"entry":["6","MTP","Media transfer protocol, defined by Microsoft."]},{"entry":["7","RIM proprietary","RIM proprietary binary protocol for Blackberry devices. Works with OS4,"]},{"entry":[{},{},"OS5, OS6."]},{"entry":["8","Android adb","Android Debug Bridge, a proprietary Google protocol for Android devices."]},{"entry":["9","Apple proprietary","Apple proprietary protocols, varying from low-level packet exchange to"]},{"entry":[{},"protocols","files exchange and PIM sync."]},{"entry":["10","SyncML","Data synchronization protocol. It is also possible to to access configuration"]},{"entry":[{},{},"database and configure phone (Symbian)."]},{"entry":["11","RAPI over RNDIS","Microsoft proprietary Remote Procedure Call protocol and Ethernet-over-"]},{"entry":[{},{},"USB protocol. Used by ActiveSync."]},{"entry":["12","SIM Card","Standard object exchange protocol with the SIM card."]},{"entry":["13","Android Fastboot","A protocol used to update the flash file system in Android devices over"]},{"entry":[{},{},"USB, and diagnose the device."]},{"entry":["14","LG proprietary","A binary object exchange protocol for LG devices."]},{"entry":[{},"protocol"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Discussion of ",{"@attributes":{"id":"p-0233","num":"0257"},"figref":["FIGS. 15-20","FIG. 8","FIG. 17","FIG. 3B"],"b":["203","205","134","120","203"]},"It is now disclosed a host device comprising: a) a peripheral device port configured for coupling with a peripheral device; and b) electronic circuitry configured, to automatically classify the mobile phone so as to specify a surrogate device command:phone command mapping scheme specific for the coupled mobile phone,","wherein the electronic circuitry of the host device is operative to: i) to distinguish between a plurality of USB interface-identical-endpoint-different phones without carrying out any application-level queries, the USB interface-identical-endpoint-different phones having USB fingerprint data that is identical at the interface descriptor level but different at the endpoint descriptor level; and\/or ii) to distinguish between a plurality of USB fingerprint identical phones by carrying out at most one application-level query, the USB fingerprint identical phones having USB fingerprint data that is identical at both the interface descriptor level as well as at the endpoint descriptor level.","A Discussion of ",{"@attributes":{"id":"p-0237","num":"0261"},"figref":["FIG. 22","FIG. 1B","FIG. 1D","FIG. 4A","FIG. 8"],"b":["100","501","505","100","210","220","21","31","101","201"]},"In the event that \u2018normal OS\u2019 behavior prevails, host device  allows the data passed in step S to reach plug-and-play-manager  (for example executing USB hub driver code  relays the HW identifier data of step S to plug and play manager ) and\/or host device  responds to the data passing of step S by loading drivers specified directly or indirectly by the specified HW data. (see ).","In , however, host device  provides a different behavior. In , the HW identifier received in step S is NOT passed to plug and play manager  (e.g. USB hub driver code  intercepts the HW identifier data en route to the plug and play manager\u2014e.g. a \u2018surrogate device identifier is passed instead of the HW identifier data). This prevents the loading of the device drivers specified by the HW identifier.","In step S, a surrogate device driver is invoked and\/or loaded instead of the device driver(s) specified directly or indirectly by the HW identifier received in step S.","One example of step S-S is illustrated in , for one specific case relating to mobile phone devices coupled as peripherals.","In some embodiments, the routine of  is carried out by non-OS code executing on the host device.","In some embodiments, the \u2018behavior\u2019 of steps S-S is not \u2018absolute\u2019 but, instead is \u2018conditional.\u2019","In one example, (i) every hour during the first half of the hour (i.e. between 0:00-0:30, between 1:00-1:30, between 2:00-2:30, etc), host device  implements steps S-S of  so that the HW identifier is blocked from reaching plug-and-play-manager  while (i) every hour during the second half of the hour (i.e. between 0:31-0:59, between 1:31-1:59, between 2:31-2:59, etc), host device  does not carry out step s-S, and instead provides \u2018native behavior\u2019 whereby the HW identifier reaches the plug and play manager  (step S of ) and\/or device driver(s) specified by the HW device identifier received by host device  from peripheral device  in step S of  are loaded on the host side (step S).","In another example: on certain occasions, it is desired to upgrade the firmware of the attached phone. It is possible to rely on vendor's application and drivers to run on host to perform this action. It is possible to therefore temporarily expose the true hardware identity, allowing the vendor's drivers to load, and its firmware software to function properly. Then we replace the identity with our own \u201cfake\u201d.","Thus, in some embodiments, steps S and\/or S are \u2018contingent\u2019 upon some condition being met\u2014when the condition is met, steps S and\/or S are carried out. Otherwise, the \u2018native OS\u2019 behavior may be observed in steps S and\/or S.","One example relating to \u2018contingent\u2019 suppressing of the \u2018native OS\u2019 code (i.e. by carrying out steps S and\/or S is illustrated in . When peripheral device  is connected to host  \u2018directly,\u2019 the \u2018blocking condition\u2019 of step S is met and the \u2018YES\u2019 option leaving S is adopted. However, it is possible to provide a \u2018mediating device \u2019 (e.g. either externally or within the housing of the housing of the host device) such that when a peripheral  coupled to the host  via the mediating device , the blocking condition is NOT met and it is possible to \u2018override\u2019 the behavior of steps S and\/or S (e.g. thus the \u2018NO\u2019 option leaving S is adopted).",{"@attributes":{"id":"p-0248","num":"0272"},"figref":["FIGS. 24A-C","FIG. 24B"],"b":["200","298","110","521","200","144","200","298","100","110","521"]},"In , host device  has a plurality of ports. When the peripheral device  (i.e. phone or another peripheral) is coupled to the host via the first port A (e.g. USB port), the host  together with port A behaves according to the \u2018YES\u2019 option leaving S providing a \u2018default\u2019 to override the \u2018native OS\u2019 behavior and to suppress the passing of the hardware ID (i.e. provided by the peripheral device \u2014i.e. phone device or any other device\u2014to the host device) to plug-and-play manager . Alternatively, when the peripheral  (i.e. phone or another peripheral) is coupled to the host via the second host-side port B, then the host  together with port B behaves according to the \u2018NO\u2019 option leaving S to provide \u2018native OS\u2019 behavior.","In one example, a father and his young children share a single desktop or laptop computer  (e.g. or any other host)\u2014during work hours, the father uses the computer for work purposes while during other the young children use the computer for \u2018leisure\u2019 purposes. In this example, the father's job requires him to copy content between mobile phones often\u2014in this case, there may be a mechanical lock on the first port A, while the second port B will be freely-accessible to his children. During work hours, the father unlocks the first port A and uses the port to enjoy \u2018phone-related\u2019 functionality when the flow to the plug-and-play manager  is suppressed (e.g. see S and\/or S). During the \u2018off-hours,\u2019 the children can freely connect peripheral devices via the second port B and enjoy the \u2018benefits\u2019 of native OS behavior.","In another example (see ), the host device may provide two modes. In one non-limiting example, in the \u2018first half\u2019 of every hour, the host device may be in host device mode , while in the second half of every hour, host device  may be in host device mode .","In another example, if a user named \u2018Joe Smith\u2019 is logged into host device , the device is in \u2018mode \u2019 where the \u2018native OS behavior\u2019 is suppressed\u2014otherwise, the device is in \u2018mode .\u2019 In one non-limiting use case, Joe Smith may be a \u2018special\u2019 user who has a need for the OS-overriding behavior (for example, Joe Smith has a business copying content between multiple phones) while for other users (for example, Joe Smith's children who may use the machine for more \u2018conventional\u2019 purposes) the \u2018native OS\u2019 behavior prevails (i.e. in MODE  of ).","In the example of , it is possible, in response to the coupling of step S, to query the user (e.g. visually or orally\u2014e.g. to present an \u2018input box\u2019 or any other user interface element for receiving user input) to ascertain if the user wants to override \u2018native OS\u2019 behavior and carry out step S, or to allow the host to provide \u2018native OS\u2019 functionality of steps S and\/or S.","This is shown in . For example, the user input S may be received via keyboard or mouse or touchscreen or any other way known in the art.","It is now disclosed a method of operating a host device on which operating system (OS) software is executing, the method comprising the steps of: contingent upon the host device being in a first mode, responding to a coupling between a peripheral device and a host device so that the peripheral device passes hardware identifier information to the host device directly or indirectly specifying device driver(s) by preventing the hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side, wherein the method is carried out on a host device that mutually-exclusive provides first and second modes, and wherein the method is carried out contingently on the host device being in the first mode and not in the second mode.","In some embodiments, the method further comprises: responding into a user log-in event or user attempted-log-in event by transitioning the host device mode from one of the first and second modes to the other of the first and second modes.","In some embodiments, the method further comprises: in accordance with content of user input received from a user into the host device, transitioning the host device mode from one of the first and second modes to the other of the first and second modes.","It is now disclosed a method of operating a host device on which operating system (OS) software is executing, the method comprising: a) responding to a coupling between a peripheral device and a host device so that the peripheral device passes hardware identifier information to the host device directly or indirectly specifying device driver(s) by soliciting user input; b) receiving user input into the host device from the user; c) in accordance with the contents of the user input, operating the host device in a first mode or in a second mode; and d) only if the host device is operating in the first mode, preventing the hardware identifier information from reaching an executing plug-and-play-manager of the OS executing on the host side.","Another embodiment relates to a \u201cpartial\u201d mode. If the coupled peripheral device is a composite device, namely exposing more than one interface, we can selectively expose any combination of interfaces to the PnP Manager. We can change it dynamically. We have control over the other interfaces. Example: in many environments blocking mass storage devices is desirable, to avoid virus infection or to prevent data theft. Up to now, it required inhibiting the USB port completely. But we can selectively block the interface. Let's assume a phone exposes a Modem interface and a Mass Storage interface. We hide the Mass Storage interface, but keep the modem interface working.","It is further noted that any of the embodiments described above may further include receiving, sending or storing instructions and\/or data that implement the operations described above in conjunction with the figures upon a computer readable medium. Generally speaking, a computer readable medium may include storage media or memory media such as magnetic or flash or optical media, e.g. disk or CD-ROM, volatile or non-volatile media such as RAM, ROM, etc. as well as transmission media or signals such as electrical, electromagnetic or digital signals conveyed via a communication medium such as network and\/or wireless links.","Having thus described the foregoing exemplary embodiments it will be apparent to those skilled in the art that various equivalents, alterations, modifications, and improvements thereof are possible without departing from the scope and spirit of the claims as hereafter recited. In particular, different embodiments may include combinations of features other than those described herein. Accordingly, the claims are not limited to the foregoing discussion."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0163","num":"0187"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0164","num":"0188"},"figref":"FIGS. 1B-1C"},{"@attributes":{"id":"p-0165","num":"0189"},"figref":"FIGS. 2A,2C, 3A and 6B"},{"@attributes":{"id":"p-0166","num":"0190"},"figref":"FIGS. 2B, 2D, 3B, 6A and 8"},{"@attributes":{"id":"p-0167","num":"0191"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0168","num":"0192"},"figref":"FIGS. 5A-5D"},{"@attributes":{"id":"p-0169","num":"0193"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0170","num":"0194"},"figref":"FIGS. 9-13, 15-17, 20-23, and 26-27"},{"@attributes":{"id":"p-0171","num":"0195"},"figref":"FIGS. 14, 18, 19 and 24-25"}]},"DETDESC":[{},{}]}
