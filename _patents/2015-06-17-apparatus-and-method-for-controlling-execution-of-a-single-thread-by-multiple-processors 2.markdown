---
title: Apparatus and method for controlling execution of a single thread by multiple processors
abstract: An apparatus includes a plurality of processors and a holder unit. The plurality of processors execute a task as a unit of processing by dividing the task into multiple threads including single and parallel threads, where the single thread is executed by only one of the plurality of processors whose respective pieces of processing have reached the thread, and the parallel thread is executed in parallel with another parallel thread by the plurality of processors. The holder unit is configured to held information to be shared by the plurality of processors. Each processor executes one of the multiple threads at a time, and causes the holder unit to hold reaching-state information indicating an extent to which the multiple threads executed by the plurality of processors have reached the single thread. Each processor determines whether to execute the single thread, based on the reaching-state information held in the holder unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09569273&OS=09569273&RS=09569273
owner: FUJITSU LIMITED
number: 09569273
owner_city: Kawasaki
owner_country: JP
publication_date: 20150617
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD","BACKGROUND","SUMMARY","DESCRIPTION OF EMBODIMENT"],"p":["This application is based upon and claims the benefit of priority of the prior Japanese Patent Application No. 2014-165172, filed on Aug. 14, 2014, the entire contents of which are incorporated herein by reference.","The embodiment discussed herein is related to apparatus and method for controlling execution of a single thread by multiple processors.","A parallel computer including multiple processors operable in parallel enhances processing efficiency by dividing a task as a unit of processing into multiple threads and then making the multiple processors to execute the threads. A processor device, such as a central processing unit (CPU) including multiple cores, is one of parallel computers.","For a parallel computer of this type, there has been proposed a technique in which a storage area is first allocated to a thread continuously activating from the start to the end of a program, and then variables used in the other treads threads are stored in the storage area (for example, see Japanese Laid-open Patent Publication No. 2002-99426). This technique ensures that even when another thread executed in parallel ends, a variable used in the other thread is held in the storage area without being lost during the execution of the program.","Another proposed technique is that, based on a value set to a flag allocated to a main memory, a thread waits for execution of synchronous processing until execution of an instruction code by another thread completes, and executes the synchronous processing after the execution of the instruction code is completed (for example, see Japanese Laid-open Patent Publication No. 2011-134145).","According to an aspect of the invention, an apparatus includes a plurality of processors and a holder unit. The plurality of processors execute a task as a unit of processing by dividing the task into multiple threads including a single thread and a parallel thread, where the single thread is a thread to be executed by only one of the plurality of processors whose respective pieces of processing have reached the thread, and the parallel thread is a thread to be executed in parallel with another parallel thread by the plurality of processors. The holder unit is configured to held information to be shared by the plurality of processors. Each of the plurality of processors executes one of the multiple threads at a time, and causes the holder unit to hold reaching-state information indicating an extent to which the multiple threads executed by the plurality of processors have reached the single thread. Each processor determines whether to execute the single thread, based on the reaching-state information held in the holder unit.","The object and advantages of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the claims.","It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are not restrictive of the invention, as claimed.","A storage area used by multiple threads is allocated to an external storage device such as a main memory in order to enable access from multiple threads. For this reason, the number of cycles for access to the storage area is larger than the number of cycles for access to a register provided in a processor device, and thereby the access efficiency is low. As a result, processing efficiency during execution of multiple threads in parallel may be lowered.","Hereinafter, embodiments are described with reference to the accompanying drawings. A signal line for transmitting a signal is described by using a reference numeral same as a signal name.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 1"],"b":["10","20","30","10","12","14","16","20","22","24","26","10","20"]},"The execution units ,  may execute multiple threads in parallel, or a single thread alone. The holder unit  is shared by both of the processors , , and is configured to hold reaching-state information indicating an extent to which processing executed by the execution units ,  has reached a single thread STH (STH or STH). The single thread STH is a thread exclusively executed only by any one of the execution units , . For example, when the execution unit  of the processor  executes a single thread STH, the execution unit  of the other processor  skips the single thread STH without executing. In the example illustrated in , the holder unit  holds reaching-state information corresponding to one single thread STH.","Each of the control units ,  stores reaching-state information into the holder unit  when processing of execution units ,  reach an entrance of the single thread STH. Each of the determination units ,  determines based on the reaching-state information held by the holder unit  whether to cause execution units ,  to execute the single thread.","Lower part of  illustrates that after a thread PTH is executed by execution units ,  in parallel, a single thread STH is executed by the execution unit , and further after a thread PTH is executed by execution units ,  in parallel, a single thread STH is executed by the execution unit . Reference numerals T, T, T, T, T, and T represent time, indicating that processing by the execution unit  is faster than processing by the execution unit .","At times T, T, processing of both the execution units ,  has not reached an entrance of a single thread STH. Therefore, the holder unit  holds reaching-state information indicating \u201cno execution unit whose processing has reached the single thread STH\u201d.","At a time T, processing executed by the execution unit  reaches the entrance of the single thread STH, and the control unit  stores reaching-state information indicating \u201cprocessing of the execution unit  has reached the single thread STH\u201d into the holder unit . Since the holder unit  is provided in the processor device, time for storing the reaching-state information is shorter than time for storing reaching-state information into an external storage device of the processor device. The determination unit  of the processor  including the execution unit  whose processing has reached the entrance of the single thread STH causes the execution unit , based on the reaching-state information for the single thread STH held by the holder unit , to execute the single thread STH. Next, at a time T, the execution unit  executes a thread PTH, and the execution unit  executes a thread PTH.","At a time T, processing executed by the execution unit  reaches an entrance of a single thread STH. However, reaching-state information held by the holder unit  indicates \u201cprocessing of the execution unit  has reached the single thread STH\u201d (that is, processing of the execution unit  has not yet reached an entrance of the single thread STH). Since reaching-state information which the holder unit  is able to hold is information corresponding to one single thread STH, the control unit  of the processor  does not store reaching-state information indicating \u201cprocessing of the execution unit  has reached the single thread STH\u201d into the holder unit . Since reaching-state information for the single thread STH is not held by the holder unit , the determination unit  of the processor  determines to suspend execution of the single thread STH by the execution unit .","That is, the determination unit  detects that before processing executed by the execution unit  reaches the entrance of the single thread STH, processing executed by the execution unit  has reached the entrance of the single thread STH executed after the single thread STH. Then, when the holder unit  has no area to store reaching-state information corresponding to the single thread STH, the execution unit  suspends execution of the single thread STH.","Next, at a time T, processing executed by the execution unit  reaches the entrance of the single thread STH. The determination unit  of the processor  determines by referring to reaching-state information held by the holder unit  that entire processing of execution units ,  has reaches the entrance of the single thread STH. The determination unit  detects, based on reaching-state information held by the holder unit , that the execution unit  of the other processor  has executed the single thread STH, and causes processing executed by the execution unit  to jump from the entrance of the single thread STH to the exit thereof. Thus, execution of the single thread STH by the execution unit  is skipped.","Time for referring to the reaching-state information is shorter than time for referring to reaching-state information held by an external storage device of the processor device. Then, the control unit  of the processor  initializes reaching-state information held by the holder unit  to \u201cno execution unit whose processing has reached the single thread STH\u201d.","Then, referring to reaching-state information held by the holder unit , the control unit  of the processor  stores reaching-state information indicating \u201cprocessing of execution unit  has reached the single thread STH\u201d into the holder unit , since reaching-state information for the single thread STH is held therein. Then, the determination unit  of the processor  causes the execution unit , based on the reaching-state information for the single thread STH held by the holder unit , to execute the single thread STH.","In the embodiment illustrated in , since the processor device includes the holder unit  for holding reaching-state information, time for access to reaching-state information may be reduced compared with reaching-state information stored in an external storage device of the processor device. Access time used herein refers to a storage time for storing reaching-state information into the holder unit , and a read time for reading reaching-state information from the holder unit . This enables processors ,  to reduce a time for storing reaching-state information indicating reach of the single thread STH (or STH) into the holder unit , and a time for determining the propriety of executing the single thread STH (or STH). Thus, processing efficiency of threads PTH, STH, PTH, and STH may be improved.","When the holder unit  does not hold reaching-state information indicating \u201cprocessing of the processor  has reached the single thread STH\u201d, the determination unit  of the processor  determines to hold execution of the single thread STH by the execution unit . When an area for storing new reaching-state information is not available in the holder unit , propriety of executing the single thread STH may be controlled according to a storage capacity of the holder unit  by suspending execution of the single thread STH.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["0","1","2","3","0","0"]},"The core C includes an operation unit OPU, a data register unit DREG, an address register unit AREG, a program counter PC, an incrementer INC, an instruction register unit IREG, a decoder unit DEC, and selectors S, S. The operation unit OPU includes a register file REG, an arithmetic unit EX, and a flag registers SF, ZF. The operation unit OPU is an example of an execution unit for executing a thread.","The program counter PC outputs an address received from the selector S to the incrementer INC, and the selector S. The incrementer INC increments an address received from the program counter PC, and outputs the incremented address to the selector S.","The selector S selects an address from the incrementer INC when sequentially fetching instruction codes, and selects an address from the operation unit OPU when a branch instruction, a jump instruction, or the like is executed. The selector S outputs a selected address to the program counter PC. The selector S selects an address outputted from the program counter PC when fetching an instruction code, and selects an address outputted from the address register unit AREG when executing a load instruction or a store instruction. The selector S outputs the selected address to the cache memory CM via the address bus AD.","When the core C fetches an instruction, an instruction code is read from the cache memory CM according to the address bus AD, and a read instruction code is stored into the instruction register unit IREG via the data bus DIN. When the instruction code is not held in the cache memory, the cache memory CM outputs an address to the main memory MM via the address bus AD, and receives the instruction code from the main memory MM via the data bus DT. For example, the address AD is a high-order address of the address AD, and the instruction code (program) corresponding to one cache line of the cache memory CM is read from the main memory MM. Then, the cache memory CM holds the instruction code read from the main memory MM, and outputs the read target instruction code out of held instruction codes to the instruction register unit IREG via the data bus DIN.","When the core C executes a load instruction, data is read from the cache memory CM according to the address bus AD, and a read data is stored into the register file REG via the data bus DIN. When target data of the load instruction is not held in the cache memory CM, the cache memory CM reads data corresponding to one cache line from the main memory MM in a manner similar to the reading of the instruction code. Then, the cache memory CM holds the data read from the main memory MM, and outputs a load target data out of the held data to the register file REG via the data bus DIN.","When the core C executes a store instruction, data outputted from the data register unit DREG to the data bus DOUT is written into the cache memory CM according to an address outputted to the address bus AD.","The instruction register unit IREG has multiple areas for holding instruction codes received from the cache memory CM, and outputs the held instruction codes sequentially to the decoder unit DEC. The decoder unit DEC decodes the instruction codes received from the instruction register unit IREG, and, based on the decoding results, generates control signals for controlling operations of the operation unit OPU, selectors S, S, and so on.","The data register unit DREG includes multiple areas for holding data outputted from the operation unit OPU during execution of the store instruction. The address register unit AREG includes multiple areas for holding addresses outputted from the operation unit OPU during execution of the load instruction or store instruction.","The register file REG includes multiple registers for holding data read from the cache memory CM, or data outputted from the arithmetic unit EX. Based on a control signal from the decoder unit DEC, the register file REG outputs data held in at least one of the multiple registers of the register file REG to the arithmetic unit EX.","The arithmetic unit EX executes operation in accordance with an instruction code decoded by the decoder unit DEC, and outputs operation results to the register file REG, data register unit DREG, address register unit AREG, or selector S. The arithmetic unit EX sets or resets flag registers SF, ZF based on the operation results, and refers to values of the flag registers SF, ZF when executing the logical operation instruction or branch instruction. The operation unit OPU may include a flag register other than flag registers SF, ZF.","The register unit REGU includes multiple registers REGi (i represents any one of 0, 1, 2, 3, and 4), and registers REGj. Here, I, the number of storage areas of the register REGi, is not limited to \u201c5\u201d, but may be any number greater than or equal to \u201c1\u201d. However, as illustrated in  and the like, larger the number I of storage areas of the registers REGi, larger the number of parallel processes performed by the multiple cores C, thereby improving the processing efficiency of the CPU. The register unit REGU is an example of the holder unit for holding reaching-state information indicating that processing executed by each of cores C to C has reached an entrance of the single processing block SIB.","In , a value held by each of registers REGi is represented by a reference numeral Xi (any one of X to X). For example, a bit width of each of registers REGi and a bit width of the register REGj are equal to each other.","Registers REGi, REGj are accessed when each of cores C to C executes the instruction code TEST&IDA (TEST & Increment, Decrement and Assignment) which will be illustrated in . Registers REGi are used cyclically as processing illustrated in  proceeds, and each of registers REGi store an unreached-thread count Xi indicating the number of threads THs which have not reached the entrance of the single processing block SIB illustrated in . A value obtained by subtracting the unreached-thread count Xi from the number of cores C to C (=4) indicates the number of threads THs which have reached the entrance of the single processing block SIB. In other words, the unreached-thread count Xi may be regarded as an example of reached-processor count information indicating the number of cores C to C whose respective pieces of processing have reached the entrance of the single processing block SIB. Each of registers REGi may store the number of threads THs which have reached the entrance of the single processing block SIB. In registers REGi of the register unit REGU, each area where the unreached-thread count Xi is stored is an example of a reached-processor count area.","The register REGj stores a total passing count j which represents the total number of single processing blocks SIBs through which all the threads THs have passed. The total passing count j is an example of total passing count information indicating the number of single processing blocks SIBs through which processing of all the cores C to C has passed. The register REGj is an example of total passing count area for holding the total passing count information. Usage of registers REGi, REGj are described with reference to  to .","The instruction code TEST&IDA is processed when the microprogram is executed by the arithmetic unit EX, in a manner similar to the addition instruction, multiplication instruction, load instruction, and store instruction. Operation of the arithmetic unit EX executing the instruction code TEST&IDA may be implemented by a wired logic. However, by employing the microcode, the instruction code TEST&IDA may be added easily compared with the wired logic system, and a hardware function (architecture of instruction set) may be easily modified.","The cache memory CM operates as an instruction cache and a data cache. The cache memory CM may be provided for each of cores C, and may include a primary cache and a secondary cache. The main memory MM is a memory module, such as a synchronous dynamic random access memory (SDRAM) or a flash memory, and stores a program executed by the CPU and data handled by the CPU. The main memory MM includes a storage area for holding a core number n indicating the number of cores C, and a storage area for holding passing counts m (m, m, m, m) indicating the number of single processing blocks SIBs, illustrated in , through which respective pieces of processing of cores C to C have passed. The core number n and the passing count m are held in the cache memory CM as well. In the case where the cache memory CM holds the core number n and the passing count m, each of cores may refer to the core number n and the passing count m, and rewrite the passing count m, just by accessing to the cache memory CM without accessing to the main memory MM.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3","FIG. 2","FIG. 3","FIG. 3","FIG. 2","FIG. 3"],"b":["0","3","0","3","0","3","0","3"]},"The single processing block SIB is a processing block that is executed by one thread at a time. Except when there is no free space in the register REGi illustrated in , a thread TH executing the single processing block SIB may execute the single processing block SIB without waiting for completion of the parallel processing block PAB by the other thread TH. The thread TH executing the single processing block SIB is an example of the single thread which is a thread executed only by any one of multiple cores C to C.","Upon reaching the entrance of the single processing block SIB, each thread TH executes the instruction code TEST&IDA. \u201cn\u201d and \u201cm\u201d of the instruction code TEST&IDA are operands (variables), respectively representing the core number n and the passing count m held in the main memory MM or the cache memory CM.","Based on values of flag registers SF, ZF that are set by execution of the instruction code TEST&IDA, each thread TH determines whether to execute the single processing block SIB or pass the single processing block SIB without executing the same. An example of determination processing executed by each thread TH is illustrated in . Examples of the single processing block SIB and the parallel processing block PAB are illustrated in  to .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 4","FIG. 4","FIG. 2","FIG. 4","FIG. 4","FIG. 4"]},"Upon reaching the entrance of the single processing block SIB, cores C execute, in the step S, a load instruction to load the core number n and the passing count m from the main memory MM. When the cache memory CM holds the core number n and the passing count m, the core number n and the passing count m are read from the cache memory CM.","Next, in the step S, cores C execute the instruction code TEST&IDA with the core number n and the passing count m loaded from the main memory MM as variables. An example of the processing executed by the instruction code TEST&IDA is illustrated in .","Next, in the step S, when the value of the flag register SF after execution of the instruction code TEST&IDA is \u201c1\u201d, cores C determines that there is an available register in the registers REGi, and causes the processing to shift to the step S. When the value of the flag register SF after execution of the instruction code TEST&IDA is not \u201c1\u201d (that is, \u201c0\u201d), cores C determines that there is no available register in the registers REGi, and causes the processing to shift to the step S.","In the step S, cores C return the processing to the step S after waiting for a predetermined period of time. In the step S, cores C may execute the other processing while waiting for the predetermined period of time.","In the step S, when the value of the flag register ZF after execution of the instruction code TEST&IDA is \u201c1\u201d, the core C determines that the core C has first reached the entrance of the single processing block SIB, and causes the processing to shift to the step S. When the value of the flag register ZF after execution of the instruction code TEST&IDA is not \u201c1\u201d (that is, \u201c0\u201d), the core C determines that the other thread has reached the entrance of the single processing block SIB earlier, and causes the processing to shift to the step S.","In the step S, processing of the core C jumps to the single processing block SIB, and the core C executes the single processing block SIB. In the step S, processing of the core C jumps to the exit of the single processing block SIB, and the core C starts next processing without executing the single processing block SIB. That is, the core C determines not to execute the single processing block SIB, and jumps the processing to the exit of the single processing block SIB. This inhibits the single processing block SIB from being executed by multiple cores C, and also suppresses malfunction of the CPU. After execution of steps S and S, the processing is shifted to the step S.","In the step S, the core C increments the passing count m loaded from the main memory MM in the step S by \u201c1\u201d. Next, in the step S, the core C executes the store instruction to store the passing count m incremented in the step S into the main memory MM. When the cache memory CM holds a passing count m, the passing count m incremented in the step S is stored into the cache memory CM and thereafter stored into the main memory MM. Then, the processing executed by the core C ends.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 5","FIG. 5","FIG. 2","FIG. 5"]},"In the step S, when a difference between the passing count m and the total passing count j is smaller than I indicating the number of registers REGi (\u201c5\u201d in ), there is an available register REGi. Therefore, the arithmetic unit EX causes the processing to shift to the step S. When the difference between the passing count m and the total passing count j is equal to or larger than I indicating the number of registers REGi, there is no available register REGi. Therefore, the arithmetic unit EX causes the processing to shift to the step S.","In the step S, the arithmetic unit EX sets the flag register SF at \u201c1\u201d to indicate that the processing has reached the entrance of the single processing block SIB, and then causes the processing to shift to the step S. In the step S, the arithmetic unit EX calculates a remainder i (\u201cm % I\u201d) by dividing the passing count m by I indicating the number of registers REGi, as the number i that is assigned to a register REGi to be used, and causes the processing to shift to the step S.","In the step S, when the unreached-thread count Xi stored in the register REGi, whose number i is obtained in the step S, is \u201c0\u201d, the arithmetic unit EX determines that the processing has first reached the entrance of the single processing block SIB, and causes the processing to shift to the step S. On the other hand, when the unreached-thread count Xi is not \u201c0\u201d, the arithmetic unit EX determines that processing of the other core C has reached the entrance of the single processing block SIB, and causes the processing to shift to the step S.","In the step S, the arithmetic unit EX stores a value obtained by subtracting \u201c1\u201d from the core number n (\u201c4\u201d in ) into the register REGi as the unreached-thread count Xi, and causes the processing to shift to the step S. In the step S, the arithmetic unit EX sets the flag register ZF at \u201c1\u201d to indicate that the processing has first reached the entrance of the single processing block SIB, and ends the processing.","When processing of the other core C has reached the entrance of the single processing block SIB, the arithmetic unit EX reduces the unreached-thread count Xi by \u201c1\u201d in the step S, and causes the processing to shift to the step S. In the step S, the arithmetic unit EX resets the flag register ZF at \u201c0\u201d to indicate that the processing has failed to first reach the entrance of the single processing block SIB, and causes the processing to shift to the step S.","In the step S, when the unreached-thread count Xi is \u201c0\u201d, the arithmetic unit EX determines that the processing has last reached the entrance of the single processing block SIB, and causes the processing to shift to the step S. When the unreached-thread count Xi is not \u201c0\u201d, the arithmetic unit EX determines that there is a Core C whose processing has not yet reached the entrance of the single processing block SIB, and ends the processing. In the step S, since the processing of all cores C has reached the entrance of the single processing block SIB, the arithmetic unit EX increments the total passing count j by \u201c1\u201d, and ends the processing.","On the other hand, when there is no available register REGi, the arithmetic unit EX sets the flag register SF at \u201c0\u201d to artificially indicate that the processing has not reached the entrance of the single processing block SIB (although already having reached actually) in the step S, and ends the processing.","Thus, the processing of steps S and S is performed by a core C whose processing has first reached the entrance of the single processing block SIB. The processing of steps S to S is performed by a core C whose processing has reached the entrance of the single processing block SIB secondly or later. Further, the processing of the step S is performed by a core C whose processing has last reached the entrance of the single processing block SIB. The step S is processing executed by a core C when there is no free space in the register REGi.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIGS. 6 to 10","FIG. 2","FIGS. 6 to 10","FIG. 3"]},"The mark \u201c*\u201d of flag registers SF, ZF represents \u201c0\u201d or \u201c1\u201d. A broken line pointed by arrow represents a single processing block (SIB to SIB), and a section above or below the single processing block represents a parallel processing block PAB (PAB to PAB). A number i of the register REGi illustrated along with single processing blocks SIB to SIB is calculated in the step S illustrated in , and is cyclically allocated to any one of \u201c0\u201d to \u201c4\u201d.","Processing executed by each of cores C proceeds from above downward in . A small black circle illustrated on a progression line (dotted line in a vertical direction of the figures) of each of cores C indicates a position of processing. A polygonal line connecting small black circles with each other indicates an arbitrary time in a manner similar to , the time being provided for convenience sake to easily recognize a difference in the progress status of the processing executed by each of cores C. A white circle on a broken line illustrating the single processing block SIB indicates that a core C, which has first reached the entrance of the single processing block SIB, has executed the single processing block SIB.","First, at a time T, each of cores C to C starts the parallel processing block PAB. In the initialized state, registers REGi, REGj, and passing counts m to m are initialized.","At a time T, the core C completes execution of the parallel processing block PAB, first reaches the entrance of the single processing block SIB, and executes the instruction code TEST&IDA ((a) in ). Before the processing of the core C reaches the entrance of the single processing block SIB, the passing count m and the total passing count j are \u201c0\u201d, and \u201cm\u2212j (=0)\u201d is smaller than the number I (\u201c4\u201d) of the register REGi. Thus, in the step S illustrated in , the register REGi is determined to have a free space, and the flag register SF is set at \u201c1\u201d in the step S illustrated in  ((b) of ).","Since the unreached-thread count X of the register REGi is initialized to \u201c0\u201d before the processing reaches the entrance of the single processing block SIB, the processing of the core C is determined to have first reached the entrance of the single processing block SIB. Thus, in the step S illustrated in , the unreached-thread count X is set at \u201c3\u201d (core number \u22121), and the flag register ZF is set at \u201c1\u201d in the step S ((c) and (d) of ).","After executing the instruction code TEST&IDA, the core C causes the processing, in the step S illustrated in , to jump to the single processing block SIB, since flag registers SF and ZF are \u201c1\u201d. In steps S and S illustrated in , the core C increments the passing count m, and stores the incremented passing count m into the main memory MM ((e) of ). After executing the single processing block SIB, the core C executes a parallel processing block PAB.","Next, at a time T, the core C completes execution of the parallel processing block PAB, reaches the entrance of the single processing block SIB in second place, and executes the instruction code TEST&IDA ((f) of ). Similarly with the operation of the core C at the time T, the core C sets the flag register SF at \u201c1\u201d ((g) of ). Since the unreached-thread count X of the register REGi is set at \u201c3\u201d at the time T, the core C changes, in steps S and S illustrated in , the unreached-thread count X to \u201c2\u201d and resets the flag register ZF to \u201c0\u201d ((h) and (i) of ).","After executing the instruction code TEST&IDA, the core C causes the processing, in the step S illustrated in , to jump to the exit of the single processing block SIB, since the flag register SF is \u201c1\u201d, and the flag register ZF is \u201c0\u201d. In steps S and S illustrated in , the core C increments the passing count m, and stores the incremented passing count m into the main memory MM ((j) of ). After executing the single processing block SIB, the core C executes the parallel processing block PAB.","Next, at a time T, the core C completes execution of the parallel processing block PAB, reaches the entrance of the single processing block SIB in the third place, and executes the instruction code TEST&IDA ((k) of ). Similarly with the operation of the core C at the time T, the core C sets the flag register SF at \u201c1\u201d, changes the unreached-thread count X to \u201c1\u201d, and resets the flag register ZF to \u201c0\u201d ((l), (m), and (n) of ). Then, after executing the instruction code TEST&IDA, the core C causes the processing to jump to the exit of the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((o) of ). After executing the single processing block SIB, the core C executes the parallel processing block PAB.","Next, at a time T, the core C completes execution of the parallel processing block PAB, reaches the entrance of the single processing block SIB in the last place, and executes the instruction code TEST&IDA ((p) of ). Similarly with the operation of the core C at the time T, the core C sets the flag register SF at \u201c1\u201d, changes the unreached-thread count X to \u201c0\u201d, and resets the flag register ZF to \u201c0\u201d ((q), (r), and (s) of ). Further, since the unreached-thread count X becomes \u201c0\u201d, the core C increments the total passing count j to \u201c1\u201d in the step S illustrated in  ((t) of ). Then, after executing the instruction code TEST&IDA, the core C causes the processing to jump to the exit of the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((u) of ).","Next, at a time T of , the core C completes execution of the parallel processing block PAB, reaches the entrance of the single processing block SIB in the first place, and executes the instruction code TEST&IDA ((a) of ). Similarly with the time T, since the register REGi is determined to have a free space, the flag register SF is set at \u201c1\u201d ((b) of ).","Since the unreached-thread count X of the register REGi is initialized to \u201c0\u201d before the processing reaches the entrance of the single processing block SIB, the processing of the core C is determined to have reached the entrance of the single processing block SIB in the first place. Thus, similarly with the operation at the time T, the core C sets the unreached-thread count X at \u201c3\u201d (core number\u22121), and sets the flag register ZF at \u201c1\u201d ((c) and (d) of ). Then, after executing the instruction code TEST&IDA, the core C causes the processing to jump to the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((e) of ).","Next, at a time T, the core C completes execution of the parallel processing block PAB, reaches the entrance of the single processing block SIB ((f) of ), and operates similarly with the core C at the time T. The core C sets the flag register SF at \u201c1\u201d, changes the unreached-thread count X to \u201c2\u201d, and resets the flag register ZF to \u201c0\u201d ((g), (h), and (i) of ). Then, after executing the instruction code TEST&IDA, the core C causes the processing to jump to the exit of the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((j) of ). Thereafter, at a time T, the core C operates similarly with the time T.","Next, at a time T, before the processing of the core C reaches the entrance of the single processing block SIB, the processing of the core C reaches the entrance of the single processing block SIB ((k) of ). The core C operates similarly with the core C at the time T by using a storage area of an unreached-thread count X of the register REGi. Next, at a time T, the processing of the core C reaches the entrance of the single processing block SIB ((I) of ). The core C operates similarly as in the time T by using a storage area of the unreached-thread count X of the register REGi.","Next, at a time T of , the processing of the core C reaches the entrance of the single processing block SIB ((a) of ). The core C operates similarly with the core C at the time T by using a storage area of the unreached-thread count X of the register REGi.","Next, at a time T, before the processing of the core C reaches the entrance of the single processing block SIB, the processing of the core C reaches the entrance of the single processing block SIB ((b) of ). The core C operates similarly with the time T by using a storage area of an unreached-thread count X of the register REGi.","Next, at a time T, the processing of the core C reaches the entrance of the single processing block SIB ((c) of ). The core C operates similarly with the time T by using a storage area of the unreached-thread count X of the register REGi. Next, at a time T, the processing of the core C reaches the entrance of the single processing block SIB ((d) of ). The core C operates similarly with the time T by using a storage area of the unreached-thread count X of the register REGi.","Next, at a time T, before the processing of the core C reaches the entrance of the single processing block SIB, the processing of the core C reaches the entrance of the single processing block SIB ((e) of ). The core C operates similarly with the time T by using a storage area of an unreached-thread count X of the register REGi.","Next, at a time T of , the processing of the core C reaches the entrance of the single processing block SIB ((a) of ). The core C operates similarly with the core C at the time T by using a storage area of the unreached-thread count X of the register REGi.","Next, at a time T, before the processing of the core C reaches the entrance of the single processing block SIB, the processing of the core C reaches the entrance of the single processing block SIB ((b) of ). Before the processing of the core C reaches the entrance of the single processing block SIB, the passing count m is \u201c5\u201d, the total passing count j is \u201c1\u201d, and \u201cm\u2212j (=4)\u201d is smaller than the number I (\u201c5\u201d) of the register REGi. Thus, in the step S illustrated in , the register REGi is determined to have a free space. In the step S illustrated in , the core C calculates a remainder (=0) by dividing the passing count m (=5) by the number I (=5) of the registers REGi, and determines to use a storage area of the unreached-thread count X of the register REGi ((c) of ). Then, the core C operates similarly with the core C at the time T by using a storage area of the unreached-thread count X.","Next, at a time T, before the processing of the core C reaches the entrance of the single processing block SIB, the processing of the core C reaches the entrance of the single processing block SIB ((d) of ). Before the processing of the core C reaches the entrance of the single processing block SIB, the passing count m is \u201c6\u201d, the total passing count j is \u201c1\u201d, and \u201cm\u2212j (=5)\u201d is same as the number I (\u201c5\u201d) of the register REGi. Thus, in the step S illustrated in , the core C determines that there is no free space in the register REGi, sets the flag register SF at \u201c0\u201d, and ends the instruction code TEST&IDA ((e) of ).","In the step S of , the core C determines that the flag register SF is \u201c0\u201d, and waits for a predetermined period of time in the step S. That is, the core C waits without causing the processing to jump to the single processing block SIB, and does not increment the passing count m as well.","Next, at a time T, the core C completes execution of the parallel processing block PAB, and reaches the entrance of the single processing block SIB ((f) of ). Before the processing of the core C reaches the entrance of the single processing block SIB, the passing count m is \u201c1\u201d, the total passing count j is \u201c1\u201d, and \u201cm\u2212j (=0)\u201d is smaller than the number I (\u201c5\u201d) of the register REGi. Thus, in the step S of , the core C sets the flag register SF at \u201c1\u201d ((g) of ).","Before the processing of the core C reaches the entrance of the single processing block SIB, the unreached-thread count X is \u201c1\u201d. Thus, in steps S and S of , the core C changes the unreached-thread count X to \u201c0\u201d, and resets the flag register ZF to \u201c0\u201d ((h) and (i) of ). Further, since the unreached-thread count X becomes \u201c0\u201d, the core C increments the total passing count j to \u201c2\u201d in the step S of  ((j) of ).","After executing the instruction code TEST&IDA, the core C causes the processing, in the step S illustrated in , to jump to the exit of the single processing block SIB, since the flag register SF is \u201c1\u201d, and the flag register ZF is \u201c0\u201d. In steps S and S illustrated in , the core C increments the passing count m, and stores the incremented passing count m into the main memory MM ((k) of ). When the core C executes the other arithmetic operation while waiting for a predetermined period of time, values of flag registers SF, ZF become indefinite (\u201c0\u201d or \u201c1\u201d).","Thereafter, at a time T, the core C waits for a predetermined period of time, and then executes the instruction code TEST&IDA. Although times T and T are provided separately for the purpose of illustration, operations indicated at times T and T are executed consecutively.","Before reaching the time T, the passing count m is \u201c6\u201d, the total passing count j is \u201c2\u201d, and \u201cm\u2212j (=4)\u201d is smaller than the number I (\u201c5\u201d) of the register REGi. Thus, the core C sets the flag register SF at \u201c1\u201d ((l) of ). In the step S illustrated in , the core C calculates a remainder (=1) by dividing the passing count m (=6) by the number I (=5) of the registers REGi, and determines to use a storage area of the unreached-thread count X of the register REGi. Since the unreached-thread count X is \u201c0\u201d before reaching the time T, the core C sets the unreached-thread count X at \u201c3\u201d (core number\u22121) in steps S and S illustrated in , and sets the flag register ZF at \u201c1\u201d ((m) and (n) of ).","After executing the instruction code TEST&IDA, the core C causes the processing, in the step S illustrated in , to jump to the single processing block SIB, since flag registers SF and ZF are \u201c1\u201d ((o) of ). In steps S and S illustrated in , the core C increments the passing count m, and stores the incremented passing count m into the main memory MM ((p) of ).","Next, at a time T of , the core C completes execution of the parallel processing block PAB, and reaches the entrance of the single processing block SIB ((a) of ). Similarly with the operation of the core C at the time T of , the core C sets the flag register SF at \u201c1\u201d, decrements the unreached-thread count X to \u201c0\u201d, and resets the flag register ZF to \u201c0\u201d ((b), (c), and (d) of ). Thus, a storage area of the unreached-thread count X of the register REGi becomes available. Further, since the unreached-thread count X becomes \u201c0\u201d, similarly with the time T of , the core C increments the total passing count j to \u201c3\u201d((e) of ).","After executing the instruction code TEST&IDA, since the flag register SF is \u201c1\u201d, and the flag register ZF is \u201c0\u201d, the core C causes the processing to jump to the exit of the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((f) of ).","Next, at a time T, the core C completes execution of the parallel processing block PAB, and reaches the entrance of the single processing block SIB ((g) of ). Similarly with the operation of the core C at the time T, the core C sets the flag register SF at \u201c1\u201d, decrements the unreached-thread count X to \u201c0\u201d, and resets the flag register ZF to \u201c0\u201d ((h), (i), and (j) of ). Thus, a storage area of the unreached-thread count X of the register REGi becomes available. Further, similarly with the operation at the time T, the core C increments the total passing count j to \u201c4\u201d, causes the processing to the exit of the single processing block SIB, and increments the passing count m ((k) and (l) of ).",{"@attributes":{"id":"p-0107","num":"0106"},"figref":["FIGS. 11 to 12","FIG. 2","FIG. 6","FIG. 10","FIG. 11","FIG. 12","FIG. 11","FIG. 12"],"b":["0","6","0","6","0","3","0","3","0","3"]},"Operations at times T and T are the same as operations at times T and T illustrated in . At the time T, the core C, which has completed processing in the parallel processing block PAB and whose processing has reached the entrance of the single processing block SIB in first place, causes the processing to jump to the single processing block SIB in the step S illustrated in . However, start of the single processing block SIB is suspended until other cores C to C complete processing of the parallel processing block PAB and reach the entrance of the single processing block SIB ((a) of ).","Next, at a time T, the processing of the core C reaches the entrance of the single processing block SIB, and at a time T, the processing of the core C reaches the entrance of the single processing block SIB ((b) and (c) of ). In the step S illustrated in , after causing the processing to jump to the exit of the single processing block SIB, cores C and C suspend start of the parallel processing block PAB until execution of the single processing block SIB by the core C completes.","Next, at a time T, the processing of the core C reaches the entrance of the single processing block SIB, and the total passing count j is set at \u201c1\u201d ((d) and (e) of ). The core C executes the single processing block SIB after processing of all cores C to C reaches the entrance of the single processing block SIB, and starts the parallel processing block PAB after completion of the single processing block SIB ((f) of ). Cores C to C start processing of the parallel processing block PAB. In the case, although passing counts m, m, and m are changed from \u201c0\u201d to \u201c1\u201d respectively at times T to T, the passing counts m, m, and m may be changed after the core C executes the single processing block SIB at a time T.","Next, at a time T of , the processing of the core C reaches the entrance of the single processing block SIB in first place, in the step S illustrated in , the core C causes the processing to jump to the single processing block SIB. However, similarly with the operation at the time T illustrated in , start of the single processing block SIB is suspended until processing of other cores C, C, and C reaches the entrance of the single processing block SIB ((a) of ).","Thereafter, at times T, T, and T, processing of core C, C, and C reach the entrance of the single processing block SIB sequentially ((b), (c), and (d) of ). The core C, whose processing reaches the entrance of the single processing block SIB in last place sets the total passing count j at \u201c2\u201d ((e) of ). Then, the core C executes the single processing block SIB after all other cores C, C, and C have reached the entrance of the single processing block SIB ((f) of ).",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 13","FIG. 2","FIG. 13","FIG. 13"]},"A statement \u201c#pragma omp parallel\u201d indicates that blocks enclosed in \u201c{ }\u201d are executed in parallel with each other. A statement \u201c#pragma omp single\u201d indicates that a block enclosed in \u201c{ }\u201d is executed by a single thread. A clause \u201c(nowait)\u201d indicates that a thread, which has completed a single processing block SIB directed by the statement \u201c#pragma omp single\u201d, shifts to a next processing regardless of the status of other threads. Operations illustrated in  to  are implemented by a program illustrated in  including description of the statement \u201c#pragma omp single (nowait)\u201d.","On the other hand, an exit of a statement \u201c#pragma omp single\u201d modified by excluding a clause \u201cnowait\u201d from a statement \u201c#pragma omp single (nowait)\u201d includes an implicit barrier for waiting for a next processing until completion of processing of all threads. Thus, when the statement \u201c#pragma omp single (nowait)\u201d illustrated in  is modified to the statement \u201c#pragma omp single\u201d, the operation illustrated in  and  is implemented.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":["FIG. 14","FIG. 2","FIG. 14","FIG. 13"]},"A statement \u201c#pragma omp parallel for\u201d indicates that \u201cfor sentence\u201d in a next line is executed in parallel. In a program illustrated in , a parallel processing block PAB, a single processing block SIB, and a parallel block PAB are executed repeatedly by the number indicated by a variable COUNT. Similarly with the program illustrated in , the program illustrated in  implements the operation illustrated in  to .",{"@attributes":{"id":"p-0118","num":"0117"},"figref":["FIG. 15","FIG. 2","FIG. 15","FIG. 13","FIG. 15"]},"A statement \u201c#pragma omp sections\u201d indicates that blocks enclosed in \u201c{ }\u201d are executed in parallel by allocating a thread for each statement \u201c#pragma omp sections\u201d. An exit of a block specified by the statement \u201c#pragma omp sections\u201d includes an implicit barrier for waiting for a next processing until completion of processing of all the threads. Thus, when re-writing the statement \u201c#pragma omp sections\u201d to the statement \u201c#pragma omp single (nowait)\u201d, a statement \u201c#pragma omp barrier\u201d is added to the end of the block \u201cfor sentence\u201d. The statement \u201c#pragma omp barrier\u201d is used for synchronization.","As described above, even in this embodiment, the CPU includes a register REGU which holds reaching-state information including the unreached-thread count Xi, and the total passing count j, similarly with the embodiment illustrated in . Thus, time for access to the reaching-state information may be reduced compared with the reaching-state information stored in the main memory MM. As a result, a processing efficiency of the thread executed by multiple cores C to C may be enhanced.","Further, a core C, whose processing has reached the entrance of the single processing block SIB in the last place, initializes areas corresponding to a register REGi to a state ready for holding a new unreached-thread count Xi. This enables execution of a single processing block SIB whose execution has been suspended, and also enables control of the propriety of executing a new single processing block SIB by using the initialized area. That is, the propriety of executing the single processing block SIB may be controlled by cyclically using multiple areas for storing the unreached-thread count Xi in the register REGi.","The passing count m managed for each of cores C to C is incremented for every passing of the single processing block SIB, and the total passing count j of cores C to C is incremented every time any processing of cores C to C reaches the entrance of each of single processing blocks SIB in the last place. Thus, execution or suspension of a single processing block SIB corresponding to the passing count m may be determined by comparing a difference between the passing count m and the total passing count j, and the number I indicating the number of areas for storing the unreached-thread count Xi in the register REGi, with each other.","A core C, whose processing has reached the entrance of the single processing block SIB in the second place or later, determines not to execute the single processing block SIB, and causes the processing to jump to the exit of the single processing block SIB to suppress execution of the single processing block SIB by multiple cores C.","Each of cores C, whose processing has reached the entrance of the single processing block SIB, fetches an instruction code TEST&IDA. The instruction code TEST&IDA is executed by a microprogram. Thus, a hardware function (architecture of instruction set) may be easily altered.",{"@attributes":{"id":"p-0125","num":"0124"},"figref":["FIG. 16","FIG. 1","FIG. 15"]},"The CPU illustrated in  includes a register unit REGU different from the register illustrated in . The register unit REGU includes one storage area (i=0) for storing the unreached-thread count X. The other configuration of the CPU is the same as the CPU illustrated in . That is, the CPU illustrated in  includes multiple cores C (C, C, C, and C), a cash memory CM, and a register unit REGU. In a manner similar to the CPU in , each of cores C includes an operation unit OPU, a data register unit DREG, an address register unit AREG, a program counter PC, an incrementer INC, an instruction register unit IREG, a decoder unit DEC, and selectors S, S.","Processing executed by the CPU illustrated in  is the same as the processing illustrated in . Processing executed by each of cores C to C at the entrance of the single processing block SIB is the same as or similar to the processing illustrated in , and the operation of the instruction code TEST&IDA executed by each of cores C to C is the same as or similar to the operation illustrated in .",{"@attributes":{"id":"p-0128","num":"0127"},"figref":["FIGS. 17 to 19","FIG. 16","FIG. 6","FIG. 10","FIG. 6"],"b":["0","10","20","0","10","20"]},"At a time T, before the processing of cores C and C reaches the entrance of the single processing block SIB, the core C completes the parallel processing block PAB, and the processing thereof reaches the entrance of the single processing block SIB ((a) and (b) of ). Before the processing of the core C reaches the entrance of the single processing block SIB, the passing count m is \u201c1\u201d, the total passing count j is \u201c0\u201d, and \u201cm\u2212j (=1)\u201d is the same as the number I (\u201c1\u201d) indicating the number of the registers REGi. Thus, in the step S illustrated in , the core C determines that there is no free space in the register REGi, resets the flag register SF to \u201c0\u201d, and ends the instruction code TEST&IDA ((c) of ).","In the step S of , the core C determines that the flag register SF is \u201c0\u201d, and waits for a predetermined period of time in the step S. That is, the core C waits without causing the processing to jump to the single processing block SIB, and does not increment the passing count m as well.","Next, at a time T, the core C completes execution of the parallel processing block PAB, the processing thereof reaches the entrance of the single processing block SIB, and the unreached-thread count X of the register REGi is changed to \u201c1\u201d ((d) and (e) of ). However, since \u201cm\u2212j (=1) is the same as the number I (\u201c1\u201d) indicating the number of the registers REGi in a manner similar to the time T, the core C resets the flag register SF to \u201c0\u201d again, and waits for a predetermined period of time ((f) of ).","Next, at a time T of , the core C completes execution of the parallel processing block PAB, the processing thereof reaches the entrance of the single processing block SIB, and the unreached-thread count X of the register REGi is changed to \u201c0\u201d((a) and (b) of ). Since the unreached-thread count X becomes \u201c0\u201d, the core C sets the total passing count j at \u201c1\u201d ((c) of ).","The core C, which has waited for the predetermined period of time in the step S illustrated in , executes the instruction code TEST&IDA (). Since the passing count m is \u201c1\u201d, and \u201cm\u2212j (=0)\u201d is smaller than the number I (\u201c1\u201d) indicating the number of the registers REGi, the core C sets the flag register SF at \u201c1\u201d ((d) of ). The core C calculates a remainder i (=0) by dividing the passing count m (=1) by the number I (=1) indicating the number of the registers REGi, and determines to use a storage area of the unreached-thread count X of the register REGi.","Thereafter, at a time T, since the unreached-thread count X is \u201c0\u201d, the core C determines that the storage area of the unreached-thread count X is empty, sets \u201c3\u201d at the unreached-thread count X, and sets the flag register ZF at \u201c1\u201d ((e) and (f) of ). After executing the instruction code TEST&IDA, since flag registers SF, ZF are \u201c1\u201d, the core C causes the processing to jump to the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((g) of ). Although times T and T are provided separately for purpose of illustration, operations indicated at times T and T are executed consecutively.","Next, at a time T, processing of the core C reaches the entrance of the single processing block SIB, the unreached-thread count X is changed to \u201c2\u201d, and the flag register ZF is reset to \u201c0\u201d ((h) and (i) of ). After executing the instruction code TEST&IDA, since the flag register SF is \u201c1\u201d, and the flag register ZF is \u201c0\u201d, the core C causes the processing to jump to the exit of the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((j) of ).","Next, at a time T, before processing of cores C and C reaches the entrance of the single processing block SIB, the core C completes the parallel processing block PAB, and processing thereof reaches the entrance of the single processing block SIB ((k) and (l) of ). The core C waits until the storage area of the unreached-thread count X becomes empty, in a manner similar to the core C at the time T of .","Next, at a time T, processing of the core C reaches the entrance of the single processing block SIB, and processing of the core C reaches the entrance of the single processing block SIB ((m) and (n) of ). The core C waits until the storage area of the unreached-thread count X becomes empty, in a manner similar to the time T of . When the core C executes the other arithmetic operation while waiting for a predetermined period of time, values of flag registers SF, ZF become indefinite (\u201c0\u201d or \u201c1\u201d).","Next, at a time T of , the processing of the core C reaches the entrance of the single processing block SIB ((a) of ). The core C changes the unreached-thread count X to \u201c0\u201d, and sets the total passing count j at \u201c2\u201d ((b) and (c) of ). The core C, which has executed the instruction code TEST&IDA for a predetermined period of time, sets the flag register SF at \u201c1\u201d since \u201cm\u2212j (=0)\u201d is smaller than the number I (\u201c1\u201d) of the register REGi ((d) of ).","Next, at a time T, the core C calculates a remainder i (=0) by dividing the passing count m (=2) by the number I (=1) indicating the number of the registers REGi, and determines to use a storage area of the unreached-thread count X. Then, the core C sets \u201c3\u201d to the unreached-thread count X, and sets the flag register ZF at \u201c1\u201d ((e) and (f) of ). After executing the instruction code TEST&IDA, since flag registers SF, ZF are \u201c1\u201d, the core C causes the processing to jump to the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((g) and (h) of ).","Thereafter, the core C, which has executed the instruction code TEST&IDA when the passing count m is \u201c2\u201d, sets the flag register SF at \u201c1\u201d since \u201cm\u2212j (=0)\u201d is smaller than the number I (\u201c1\u201d) indicating the number of the registers REGi ((i) of ). The core C changes the unreached-thread count X to \u201c2\u201d, and resets the flag register ZF to \u201c0\u201d ((j) and (k) of ). Although times T and T are provided separately for the purpose of illustration, operations indicated at times T and T are executed consecutively.","After executing the instruction code TEST&IDA, since the flag register SF is \u201c1\u201d, and the flag register ZF is \u201c0\u201d, the core C causes the processing to jump to the exit of the single processing block SIB, increments the passing count m, and stores the incremented passing count m into the main memory MM ((l) of ). When the core C whose processing has reached the entrance of the single processing block SIB, executes the instruction code TEST&IDA prior to the core C, processing of the core C jumps to the single processing block SIB, and processing of the core C jumps to the exit of the single processing block SIB. That is, the core C executes the operation of the core C illustrated at times T, T, and the core C executes the operation of the core C illustrated at times T, T.","Then, at a time T, cores C, C execute the parallel processing block PAB, and cores C, C execute the parallel processing block PAB.","In the embodiment illustrated in  to , since the CPU includes the register unit REGU for holding reaching-state information, time for access to the reaching-state information may be reduced compared with a case where the reaching-state information is stored in the main memory MM. As a result, a processing efficiency of the thread executed by multiple cores C to C may be enhanced.","The embodiments illustrated in  to  may be implemented by multiple CPUs respectively including multiple cores C. For example, when one CPU includes cores C and C, and the other CPU includes cores C and C, each CPU operates as illustrated in  to  and  to .","Each of cores C may execute multiple threads in parallel. In this case, when the core C illustrated in  executes two threads in parallel, and the core C illustrated in  executes two threads, the operation illustrated in  to  is implemented by replacing processing of cores C and C with processing of cores C and C, respectively. Similarly, parallel execution of multiple threads by each of cores C illustrated in  to  is implemented by replacing processing of cores C and C with processing of cores C and C, respectively.","Characteristics and advantages of the embodiments shall be apparent from the above detailed description. This intends that the appended claims cover the characteristics and advantages of the above embodiments within a scope not deviating from the spirit and the right thereof. Any modifications and variations may be readily conceivable to those of ordinary skill in the art. Therefore, it is not intended to limit the scope of embodiments having inventiveness to the foregoing, and appropriate modifications and equivalents included in the scope disclosed in the embodiments may be covered.","All examples and conditional language recited herein are intended for pedagogical purposes to aid the reader in understanding the invention and the concepts contributed by the inventor to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions, nor does the organization of such examples in the specification relate to a showing of the superiority and inferiority of the invention. Although the embodiment of the present invention has been described in detail, it should be understood that the various changes, substitutions, and alterations could be made hereto without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 6 to 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 11 to 12"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 17 to 19"}]},"DETDESC":[{},{}]}
