---
title: Application server scalability through runtime restrictions enforcement in a distributed application execution system
abstract: In an application execution system having a plurality of application servers, each application server includes non-volatile storage for storing a plurality of applications, volatile storage and computational resources for executing applications in response to requests received by the application execution system and for returning results to the requestors. In addition, each application server includes instructions for conditionally terminating execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. The execution restrictions in aggregate maintain scalability of the application execution system with respect to at least one or more of the following limits: number of applications that can be executed and number of requests that can be processed per period of time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08005950&OS=08005950&RS=08005950
owner: Google Inc.
number: 08005950
owner_city: Mountain View
owner_country: US
publication_date: 20081209
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DESCRIPTION OF EMBODIMENTS"],"p":["This application is related to U.S. patent application Ser. No. 12\/060,798, filed Apr. 1, 2008, entitled \u201cEfficient Hosting in a Distributed Application Execution System\u201d which is incorporated by reference herein in its entirety.","The disclosed embodiments relate generally to methods and systems, sometimes called application servers, for hosting and executing large numbers of heterogeneous applications.","In general, increases in an application's popularity could present a variety of scalability problems that negatively impact a user's experience. For example, users could experience slower response times, slower page loading, and increased time outs on page requests. These scalability problems are typically alleviated by allocating additional capacity to the application such as more storage, more memory, more CPUs, and more machines in general.","Allocating or installing more computing capacity may be a reasonable solution when increases in an application's popularity are experienced over a prolonged period of time, or when usage of the application is predictable. Similarly, when an application experiences a decrease in usage, removing computing capacity previously allocated to the application may be a reasonable solution, especially when the decrease is experienced over a prolonged period of time, or when the decrease is predictable. However, the popularity of an application is often unpredictable, due to a variety of factors (e.g., time of day, current events, advertising, trends), and fluctuates to a large extent, which creates load spikes and dips in the application execution or hosting system.","Predefined allocations of computing resources are inefficient solutions for handling temporary load spikes and dips. Increasing or installing more computing resources to handle a load spike is inefficient, since the additional pre-allocated resources go unused when the spike disappears (e.g., when the spike in demand subsides, or the application's popularity dips). Similarly, decreasing computing resources allocated to an application when its popularity declines is also inefficient, since future usage spikes will require the re-allocation of previously removed resources back to the application.","To complicate matters further, application systems may host a large number of heterogeneous applications, each with its own set of fluctuating resource requirements. Pre-allocation of resources, for the reasons discussed above, is often an inefficient solution for ensuring consistent positive user experiences among heterogeneous applications hosted on an application system.","In an application execution system having a plurality of application servers, each application server includes non-volatile storage for storing a plurality of applications, volatile storage and computational resources for executing applications in response to requests received by the application execution system. Each application server also includes instructions for storing in non-volatile storage applications distributed to the application server, for loading a plurality of respective applications into volatile storage, for executing a respective application in response to a respective received request from a client, and for returning a result to the request. In addition, each application server includes instructions for conditionally terminating execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. The execution restrictions include two of more of the following: a response time limit; an average response time limit over multiple executions of the respective application; a volatile memory usage limit that limits how much volatile memory can be used by each execution of the respective application; a restriction on using non-volatile storage of the application server; and a requirement that any state information to be retained after returning the result is either sent to the client for storage, or retained in a datastore accessible by all the application servers. The execution restrictions in aggregate maintain scalability of the application execution system with respect to at least one or more of the following limits: number of applications that can be executed and number of requests that can be processed per period of time.","In another aspect of the invention, a method of operating an application server in a system having a plurality of application servers is disclosed. The method comprises storing in non-volatile storage applications distributed to the application server, loading a plurality of respective applications into volatile storage, executing a respective application in response to a respective received request from a client, and returning a result to the request. In addition, the method includes conditionally terminating execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. The execution restrictions include two of more of the following: a response time limit; an average response time limit over multiple executions of the respective application; a volatile memory usage limit that limits how much volatile memory can be used by each execution of the respective application; a restriction on using non-volatile storage of the application server; and a requirement that any state information to be retained after returning the result is either sent to the client for storage, or retained in a datastore accessible by all the application servers. The execution restrictions in aggregate maintain scalability of the application execution system with respect to at least one or more of the following limits: number of applications that can be executed and number of requests that can be processed per period of time.","Like reference numerals refer to corresponding parts throughout the several views of the drawings.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","130","102","102","1","102","110","102","104","104","1","104","130","102","102","130"],"i":["n","n"]},"In some embodiments, the application execution system  include a front-end server , which receives application execution requests from clients  and returns results to the requesting clients. The front-end server  receives, from the application master , an application distribution map which may include resource usage information that can be used to route requests received from client(s) . More information regarding the application distribution map is provided in U.S. patent application Ser. No. 12\/060,798, filed Apr. 1, 2008, entitled \u201cEfficient Hosting in a Distributed Application Execution System\u201d which is incorporated by reference herein in its entirety.","The application execution system  include a plurality of application servers  (e.g., - through -). As described in more detail below with reference to FIG. , each of the application servers  includes non-volatile storage for storing a plurality of applications in a local library , volatile storage, and computational resources for executing applications in response to requests received by the application execution system . The application servers  may include a runtime manager , which as further discussed below with reference to , enforces resource limits and restrictions for various resources consumed by an application during execution. In some embodiments, the application execution system  includes a quota system  which, in conjunction with the runtime manager , implements a plurality of application restriction limits as further discussed below.","The application execution system  also includes an application master  that distributes applications, from a main library  having a plurality of applications, among the application servers . In the embodiment shown in , the main library  is stored in the application master . Alternately, the main library  may be stored remotely from the application master, such as in a datastore . In some embodiments, each application of the plurality of applications in the main library  is a web application that is responsive to HTTP requests. However, the present invention can also be used in non-web based environments, in which case the applications need not be web-based applications.","In some embodiments, the application execution system  also includes a datastore  accessible to at least the application master  and the front-end server , for sharing information about the location of applications among the application servers  and resource usage or loading information with respect to the application servers .","Optionally, the distributed system  includes additional resources , which may be located either internally or externally to the system , for use when executing applications in the application execution system . For example, an application executed by the application execution system  may access information in one or more of the additional resources  in order to process a request received from a respective client . These additional resources may include one or more of: other applications and data provided by web services (e.g., web feed data from sources such as blog entries, headlines, podcasts, etc.).",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["200","150","202","204","140","160","212"]},"The application server may remove one or more applications from volatile memory before performing operation  when there is insufficient volatile memory to process the request. Alternatively, the application server may automatically remove applications from volatile memory when the amount of available volatile storage is below a predefined threshold.","In some embodiments, after returning the result to the request, the application server can either remove the respective application from volatile storage (), or retain the respective application in volatile storage () for responding to future requests, by determining whether predefined criteria has been met (). In some embodiments, the predefined criteria () used by the application server include usage level criteria, which may include the number of requests for the application processed per period of time. The predefined criteria may also include caching criteria, which may include the number of respective application instances in volatile storage available for handling new requests, and the number of respective application instances handling active requests and therefore not available for handling new requests. Cached application instances are discussed in more detail below with reference to . The predefined criteria may also include error criteria, which may be based on the number of errors encountered during execution of the application, and the type of errors encountered. For example, the application server may remove the respective application from volatile storage if severe errors are encountered during N (e.g., 5, 10 or 20) consecutive executions of the application.","For applications that fail to meet the predefined criteria (\u2014No), the application server removes the respective applications from volatile storage upon returning the result to the request (). In some embodiments, the application server may remove the respective applications from volatile storage according to a predefined order for removal. For example, the application server may remove the least recently used application.","In some embodiments, when determining which application instance to remove from volatile storage, the application servers may take into account the service quality levels of the applications for which instances are stored in volatile memory. The service quality level of each application may be based on the level of service requested, or paid for. Various forms of preferences (for retention of application instances in volatile memory) may be given to applications with high service quality levels, compared to applications with lower service quality levels. For example, lower service quality level application instances may be evicted before higher service quality level application instances whenever a predefined condition is true. The predefined condition may relate to numbers or ratios of lower and higher service quality level application instances loaded in volatile memory. Alternately, scores may be computed to determine which application instances to unload from volatile memory, and computation of the scores may take into account the service quality levels of the applications.","For applications that meet the predefined criteria (-Yes), the application server retains the respective applications in volatile storage for responding to future requests for the application (). In some embodiments, the application server retains more than one application instance of the respective application in volatile storage in accordance with predefined caching criteria. In some embodiments, the application server limits the number of application instances in volatile storage. For example, the application server may limit the total number of application instances in volatile memory to ensure that there is sufficient volatile memory for other processing tasks. Alternatively, the application server may limit the number of instances of a respective application to ensure that other requested applications have access to sufficient volatile memory to service their requests.","In some embodiments, the application server may terminate () execution of the respective application prior to returning the result if the respective application violates any of a plurality of execution restrictions. These execution restrictions may include application resource limits for limiting an application's consumption of system resources during runtime (e.g., a response time limit, an average response time limit over multiple executions of an application, a volatile memory usage limit that limits the amount of volatile memory used by each execution of an application). In some embodiments, the same application resource limits are applied to all applications (e.g., the volatile memory usage limit is the same for all applications). For example, the application execution system may terminate execution of an application if the application's run time or execution time exceeds the response time limit. Alternatively, the application resource limits may vary between applications. Optionally, in embodiments where the average response time for an application is frequently or periodically updated, the application execution system may terminate execution of the application if the application's average response time exceeds the average response time limit (e.g., 0.5 seconds). For example, multiple instances (e.g., all instances being executed) of the same application may all be terminated if, for some reason, the average response time of the application extends beyond the applicable resource limit. The application execution system may also restrict the number of requests processed per period of time for an application, the number of CPU cycles per period of time, the stack size associated with the execution of an application, and other resource usage data as further discussed with reference to  (Resource Usage Data ).","The execution restrictions may also prohibit certain actions performed by applications using one or more predefined application programming interfaces (APIs). These execution restrictions may restrict the use of non-volatile storage of the application server by an application during execution by preventing the application code from reading or accessing data stored in non-volatile storage. In addition the execution restrictions may govern the storage of state information by requiring state information (to be retained after returning the result) to either be sent to the client for storage, or retained in a datastore accessible by all application servers in the application execution system. Other execution restrictions may include restrictions on: opening network connections; creating new processes by an application, including the creation of threads by the application; making system calls by an application; and other system function calls. In some embodiments, to maintain scalability of the application execution system with respect to number of applications that can be executed and number of requests that can be processed per period of time, the execution restrictions include a restriction requiring all applications to execute within a secure execution environment. In these embodiments, external access to memory locations within the application servers is prohibited. The application execution system may also monitor and enforce restrictions on the frequency of certain actions performed by the applications that impact system performance by monitoring the frequency of calls (made by an application) to APIs associated with these restricted actions (e.g., number of times per period of time that the application calls the API(s) for accessing a datastore, number of times per period of time that the application calls the API(s) for accessing an external web service).","As previously discussed with reference to , in some embodiments, the application execution system includes a quota system . The monitoring and enforcement of certain execution restrictions described above may involve the quota system , which maintains aggregate quota information for each application. When an application needs to consume a system resource, the application execution system may consult the quota system to ensure that the application has not exceeded quota or threshold limits. For example, the system may include a restriction on the number of times per day the application can access the datastore (e.g., 2,000,000 calls per day) using the associated API (e.g., the Datastore Interface  ). Before the application can call the Datastore Interface , the system checks the number of calls to the Datastore Interface  (made by a respective application on all application servers) to ensure that the application is still within its quota limit (e.g., 2,000,000 calls per day).",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3A","b":["350","330","332","334","336","338","342","335"]},"In , the application server loads () the code for \u201cApp \u201d into a generic instance in response to a request received for \u201cApp .\u201d The \u201cApp \u201d instance may be referred to as \u201clive\u201d or \u201calive\u201d since it contains code that is readily executable by the application server. The App  instance is loaded into a cache (e.g., \u201cLive Process Cache\u201d) . The cache may contain other instances of App  as well as instances of other requested applications (e.g., App . . . AppN). These application instances in the Live Process Cache  are either \u201cbusy\u201d or \u201cavailable,\u201d although other transitional states could be used in addition in other embodiments. A \u201cbusy\u201d application instance is one that is processing a current request, and therefore cannot process another incoming request until it finishes processing the current request. The \u201cavailable\u201d instances are ready to process any received request for the respective application.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIGS. 3B-3C","FIG. 3A"],"b":["304","1","350","1","1","362","364","1","362","366","334","366","368","372","374","366","372","1","372","1","374","350","1","382","1","384","388","1","386","392","1","350","386","1","1","390"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 3A","FIG. 4"],"b":["562","350","562"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["cache size information , which may be represented (for example) in terms of memory capacity (e.g., a number of gigabytes), or a maximum number of application instances that can be stored in the live process cache ;","the number of generic instances  currently available for allocation; and","information  about each of the applications, or application instances, currently in the live process cache . For example, information  may indicate for each application having at least one instance in the live process cache , the identity  of the application, the number  of \u201cbusy\u201d instances of the application, the number  of \u201cavailable\u201d instances of the application, last use information  (e.g., the date\/time of last use of the application), and data for execution restrictions  or other information for enabling implementation of a cache eviction policy. Examples of execution restrictions data  including resource usage data , response time data , and violations data  are further described below."]}}}},"Resource usage data , which allows the system to monitor the amount of system resources consumed by an application, may include any combination of the following (per period of time): number of CPU megacycles, number of HTTP requests, amount of bandwidth consumed by incoming requests for the application (\u201cbandwidth in\u201d), and amount of bandwidth consumed by transmission of outgoing results to requests for the application (\u201cbandwidth out\u201d). In addition, resource usage data  may also monitor the frequency of certain activities such as accessing a datastore, accessing internal or external application resources  (e.g., web services, web feeds, news feeds), and sending email from the application. These monitored activities are further discussed above with reference to .","Response time data  includes data indicating the amount of time it takes the application to issue a response to serve a request. Violations data  may include data indicating the frequency of restriction violations associated with the application (e.g., number of response time violations over a period of time, type of violated restriction(s), aggregate number of violations). In some embodiments, violations data  is updated during application execution. For example, during execution of an application, the application server (executing the application) may monitor and update violations data  to ensure compliance with application restrictions.",{"@attributes":{"id":"p-0038","num":"0040"},"figref":["FIG. 5","FIG. 1"],"b":["500","500","500","502","506","510","504","504","510","510","170","502","510","510","510"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["an operating system  that includes procedures for handling various basic system services and for performing hardware dependent tasks;","a network communication module  that is used for connecting the application server  to other computers via the one or more communication network interfaces  (wired or wireless) and one or more communication networks (e.g., communication networks ), such as the Internet, other wide area networks, local area networks, metropolitan area networks, and the like;","an application server module  for processing application requests. In some embodiments, the application server module  includes an application master interface module  for interfacing with the application master  (), a front-end interface module for interfacing with the front-end , a quota system interface module  for interfacing with the quota system , and a live process cache monitor and control module  for managing application instances in the live process cache  (). The application server module  may also store a security module  for executing untrusted processes (Run Untrusted Process Module)  and trusted processes (Run Trusted Process Module) . Some of the procedures included in the application server module  are further described below.","a local application library , for storing the applications distributed to the application server by the application master ;","application instances in volatile memory  (e.g., in a live process cache , ) for servicing application requests. In some embodiments, there is at least one application instance for an application in volatile memory;","data  includes data used primarily by the application master  (e.g., local application library data , server resource data , application resource data ). More information regarding data used by the application master is provided in U.S. patent application Ser. No. 12\/060,798, filed, Apr. 1, 2008, entitled \u201cEfficient Hosting in a Distributed Application Execution System\u201d which is incorporated by reference herein in its entirety. When needed, data  includes user data , which may include data received from a requesting user (e.g., user name, passwords, user preferences, profiling information) and\/or data produced or retrieved for the requesting user by the application server. In addition, data  may include live process cache data , described with reference to ;","an optional Cache Memory , for temporarily storing data and making the data for a respective application accessible to all instances of that application."]}}}},"In some embodiments, the application master interface module  includes procedures for adding or removing applications from the non-volatile storage of the application server. The application master interface module  may also include procedures for sending usage information on application resources and server resources to the application master. In some embodiments, the front end interface module  includes procedures for handling application requests  forwarded from the front end . More information regarding the application master and the front-end is provided in U.S. patent application Ser. No. 12\/060,798, filed, Apr. 1, 2008, entitled \u201cEfficient Hosting in a Distributed Application Execution System\u201d which is incorporated by reference herein in its entirety.","Procedure(s) (Live Process Cache Monitor & Control)  for managing application instances in the live process cache  may include procedures (Load and Remove Application Instance Module)  for loading and removing application instances into the live process cache in accordance with application usage and available volatile memory as previously discussed with reference to , procedures (Execute Application Instance Module)  for executing application instances when processing application requests. The Execute Application Instance Module  may also include procedures (Resource Limit Enforcement)  for limiting resource consumption of a particular application. For example, an application that consumes more resources than a limit or threshold may be terminated (Terminate App Instance) , as previously described with reference to . The resource limit may be a predefined amount or the threshold may vary depending on factors such as the number of requests for the application. For example, applications that receive higher numbers of requests may have a higher threshold before the application instance is terminated. Alternatively, the threshold may also depend on the amount of processing resources (e.g., one or more of: CPU time, \u201cwall clock\u201d time (i.e., total elapsed real time), memory, communication bandwidth, and number of system function calls made) consumed by the application. The threshold(s) may be applied per execution of an application, or to a running average of resources used over multiple executions of the application. An application instance that consumes resources above a corresponding threshold may be terminated.","The procedures (Live Process Cache Monitor & Control)  may also include application programming interfaces (APIs)  that enable and restrict activities that applications may engage in during execution. The APIs  may include any combination of the following: a Datastore Interface  for interfacing with a datastore (e.g., the datastore ); a Cache Memory Interface  for interfacing with shared Cache Memory ; and an External Resources Interface  for interfacing with external resources (e.g., other applications, other websites, web services). In embodiments having the Cache Memory  and the Cache Memory Interface , an application instance can store data (e.g., data copied from a datastore) for high speed access by all instances of the same application. The application must not rely upon retention of data by the Cache Memory ; for example, the data stored in the Cache Memory  for a respective application may be deleted whenever there are no longer any active instances of the application. The Datastore and Cache Memory mechanisms for sharing information between instances of the same application are accessibly only through the APIs provided by the application execution system, which facilitates enforcement of application restrictions associated with both durable and temporary storage of data that can be shared between application instances.","The live process cache monitor & control module  may also include procedures for monitoring the status of application instances (Monitor Application Instance Status Module) . For example, the status of the application instances may be \u201cbusy,\u201d \u201cavailable,\u201d or any transitional state in between (see ).",{"@attributes":{"id":"p-0043","num":"0052"},"figref":["FIG. 5","FIG. 5"]},"Each of the above identified elements in  may be stored in one or more of the previously mentioned memory devices, and corresponds to a set of instructions for performing a function described above. The above identified modules or programs (i.e., sets of instructions) need not be implemented as separate software programs, procedures or modules, and thus various subsets of these modules may be combined or otherwise re-arranged in various embodiments. In some embodiments, Memory  may store a subset of the modules and data structures identified above. Furthermore, Memory  may store additional modules and data structures not described above.","The foregoing description, for purpose of explanation, has been described with reference to specific embodiments. However, the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the invention and its practical applications, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 3B-3C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
